<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:43 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>BTPARSE</title>

</head>
<body>
<h1>btparse</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">btparse &minus;
C library for parsing and processing BibTeX data files</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;btparse.h&gt; <br>
/* Basic library initialization / cleanup */ <br>
void bt_initialize (void); <br>
void bt_free_ast (AST *ast); <br>
void bt_cleanup (void); <br>
/* Input / interface to parser */ <br>
void bt_set_stringopts (bt_metatype_t metatype, btshort
options); <br>
AST * bt_parse_entry_s (char * entry_text, <br>
char * filename, <br>
int line, <br>
btshort options, <br>
boolean * status); <br>
AST * bt_parse_entry (FILE * infile, <br>
char * filename, <br>
btshort options, <br>
boolean * status); <br>
AST * bt_parse_file (char * filename, <br>
btshort options, <br>
boolean * overall_status); <br>
/* AST traversal/query */ <br>
AST * bt_next_entry (AST * entry_list, <br>
AST * prev_entry) <br>
AST * bt_next_field (AST *entry, AST *prev, char **name);
<br>
AST * bt_next_value (AST *head, <br>
AST *prev, <br>
bt_nodetype_t *nodetype, <br>
char **text); <br>
bt_metatype_t bt_entry_metatype (AST *entry); <br>
char *bt_entry_type (AST *entry); <br>
char *bt_entry_key (AST *entry); <br>
char *bt_get_text (AST *node); <br>
/* Splitting names and lists of names */ <br>
bt_stringlist * bt_split_list (char * string, <br>
char * delim, <br>
char * filename, <br>
int line, <br>
char * description); <br>
void bt_free_list (bt_stringlist *list); <br>
bt_name * bt_split_name (char * name, <br>
char * filename, <br>
int line, <br>
int name_num); <br>
void bt_free_name (bt_name * name); <br>
/* Formatting names */ <br>
bt_name_format * bt_create_name_format (char * parts,
boolean abbrev_first); <br>
void bt_free_name_format (bt_name_format * format); <br>
void bt_set_format_text (bt_name_format * format, <br>
bt_namepart part, <br>
char * pre_part, <br>
char * post_part, <br>
char * pre_token, <br>
char * post_token); <br>
void bt_set_format_options (bt_name_format * format, <br>
bt_namepart part, <br>
boolean abbrev, <br>
bt_joinmethod join_tokens, <br>
bt_joinmethod join_part); <br>
char * bt_format_name (bt_name * name, bt_name_format *
format); <br>
/* Construct tree from TeX groups */ <br>
bt_tex_tree * bt_build_tex_tree (char * string); <br>
void bt_free_tex_tree (bt_tex_tree **top); <br>
void bt_dump_tex_tree (bt_tex_tree *node, int depth, FILE
*stream); <br>
char * bt_flatten_tex_tree (bt_tex_tree *top); <br>
/* Miscellaneous string utilities */ <br>
void bt_purify_string (char * string, btshort options); <br>
void bt_change_case (char transform, char * string, btshort
options);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>btparse</b>
is a C library for parsing and processing BibTeX files. It
provides a lexical scanner and <small>LR</small> parser
(constructed by <small>PCCTS</small> ), both of which are
efficient and offer good error detection and recovery; a set
of functions for traversing the <small>AST</small> (abstract
syntax tree) generated by the parser; and utility functions
for manipulating strings according to BibTeX conventions.
(Note that nothing in the library assumes that you&rsquo;re
using BibTeX files for their original purpose of
bibliographic data for scholarly publications; you could use
the file format for any conceivable purpose that fits it.
However, there is some code in the library that is really
only appropriate for use with strings meant to be processed
in the same way that BibTeX itself does. This is all
entirely optional, though.)</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
interface provided by <b>btparse</b>, while complete, is
fairly low-level. If you have more sophisticated needs, you
might be interested my &quot;Text::BibTeX&quot; module for
Perl 5 (available on <small>CPAN</small> ).</p>

<h2>CONCEPTS AND TERMINOLOGY
<a name="CONCEPTS AND TERMINOLOGY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To understand
this document and use <b>btparse</b>, you should already be
familiar with the BibTeX language&minus;&minus;&minus;more
specifically, the BibTeX data description language. (BibTeX
being the complex beast that it is, one can conceive of the
term applying to the program, the data language, the
particular database structure described in the original
BibTeX documentation, the &quot;.bst&quot; formatting
language, and the set of conventions embodied in the
standard styles included with the BibTeX distribution. In
this document, I&rsquo;ll stick to the first two
meanings&minus;&minus;&minus;the data language because
that&rsquo;s what <b>btparse</b> deals with, and the program
because it&rsquo;s occasionally necessary to explain
differences between my parser and BibTeX&rsquo;s.)</p>

<p style="margin-left:11%; margin-top: 1em">In particular,
you should have a good idea what&rsquo;s going on in the
following:</p>

<p style="margin-left:11%; margin-top: 1em">@string{and = {
and }, <br>
joe = &quot;Blow, Joe&quot;, <br>
john = &quot;John Smith&quot;} <br>
@book(ourbook, <br>
author = joe # and # john, <br>
title = {Our Little Book})</p>

<p style="margin-left:11%; margin-top: 1em">If this looks
like something you want to parse, but don&rsquo;t want to
have to write your own parser for, you&rsquo;ve come to the
right place.</p>

<p style="margin-left:11%; margin-top: 1em">Before going
much further, though, you&rsquo;re going to have to learn
some of the terminology I use for describing BibTeX data.
Most of it&rsquo;s the same as you&rsquo;ll find in any
BibTeX documentation, but it&rsquo;s important to be sure
that we&rsquo;re talking about the same things here. So,
some definitions: <br>
top-level</p>

<p style="margin-left:17%;">All text in a BibTeX file from
the start of the file to the start of the first entry, and
between entries thereafter.</p>

<p style="margin-left:11%;">name</p>

<p style="margin-left:17%;">A string of letters, digits,
and the following characters:</p>

<p style="margin-left:17%; margin-top: 1em">! $ &amp; * +
&minus; . / : ; &lt; &gt; ? [ ] ^ _ ` |</p>

<p style="margin-left:17%; margin-top: 1em">A
&quot;name&quot; is a catch-all used for entry types, entry
keys, and field and macro names. For BibTeX compatibility,
there are slightly different rules for these four entities;
currently, the only such rule actually implemented is that
field and macro names may not begin with a digit. Some names
in the above example: &quot;string&quot;,
&quot;and&quot;.</p>

<p style="margin-left:11%;">entry</p>

<p style="margin-left:17%;">A chunk of text starting with
an &quot;at&quot; sign (&quot;@&quot;) at top-level,
followed by a name (the <i>entry type</i>), an <i>entry
delimiter</i> (&quot;{&quot; or &quot;(&quot;), and
proceeding to the matching closing delimiter. Also, the data
structure that results from parsing this chunk of text.
There are two entries in the above example.</p>

<p style="margin-left:11%;">entry type</p>

<p style="margin-left:17%;">The name that comes right after
an &quot;@&quot; at top-level. Examples from above:
&quot;string&quot;, &quot;book&quot;.</p>

<p style="margin-left:11%;">entry metatype</p>

<p style="margin-left:17%;">A classification of entry types
that allows us to group one or more entry types under the
same heading. With the standard BibTeX database structure,
&quot;article&quot;, &quot;book&quot;, &quot;inbook&quot;,
etc. all fall under the &quot;regular entry&quot; metatype.
Other metatypes are &quot;macro definition&quot; (for
&quot;string&quot; entries), &quot;preamble&quot; (for
&quot;preamble&quot;) entries, and &quot;comment&quot;
(&quot;comment&quot; entries). In fact, any entry whose type
is not one of &quot;string&quot;, &quot;preamble&quot;, or
&quot;comment&quot; is called a &quot;regular&quot;
entry.</p>

<p style="margin-left:11%;">entry delimiters</p>

<p style="margin-left:17%;">&quot;{&quot; and
&quot;}&quot;, or &quot;(&quot; and &quot;)&quot;: the pair
of characters that (almost) mark the boundaries of an entry.
&quot;Almost&quot; because the start of an entry is marked
by an &quot;@&quot;, not by the &quot;entry open&quot;
delimiter.</p>

<p style="margin-left:11%;">entry key</p>

<p style="margin-left:17%;">(Or just <i>key</i> when
it&rsquo;s clear what we&rsquo;re speaking of.) The name
immediately following the entry open delimiter in a regular
entry, which uniquely identifies the entry. Example from
above: &quot;ourbook&quot;. Only regular entries have
keys.</p>

<p style="margin-left:11%;">field</p>

<p style="margin-left:17%;">A name to the left of an equals
sign in a regular or macro-definition entry. In the latter
context, might also be called a macro name. Examples from
above: &quot;joe&quot;, &quot;author&quot;.</p>

<p style="margin-left:11%;">field list</p>

<p style="margin-left:17%;">In a regular entry, everything
between the entry delimiters except for the entry key. In a
macro definition entry, everything between the entry
delimiters (possibly also called a macro list).</p>

<p style="margin-left:11%;">compound value</p>

<p style="margin-left:17%;">(Usually just
&quot;value&quot;.) The text that follows an equals sign
(&quot;=&quot;) in a regular or macro definition entry, up
to a comma or the entry close delimiter; a list of one or
more simple values joined by hash signs (&quot;#&quot;).</p>

<p style="margin-left:11%;">simple value</p>

<p style="margin-left:17%;">A string, macro, or number.</p>

<p style="margin-left:11%;">string</p>

<p style="margin-left:17%;">(Or, sometimes, &quot;quoted
string.&quot;) A chunk of text between quotes
(&quot;&quot;&quot;) or braces (&quot;{&quot; and
&quot;}&quot;). Braces must balance: &quot;{this is a
{string}&quot; is not a BibTeX string, but &quot;{this is a
{string}}&quot; is. (&quot;this is a {string&quot; is also
illegal, mainly to avoid the possibility of generating bogus
TeX code--which BibTeX will do in certain cases.)</p>

<p style="margin-left:11%;">macro</p>

<p style="margin-left:17%;">A name that appears on the
right-hand side of an equals sign (i.e. as one simple value
in a compound value). Implies that this name was defined as
a macro in an earlier macro definition entry, but this is
only checked if <b>btparse</b> is being asked to expand
macros to their full definitions.</p>

<p style="margin-left:11%;">number</p>

<p style="margin-left:17%;">An unquoted string of
digits.</p>

<p style="margin-left:11%; margin-top: 1em">Working with
<b>btparse</b> generally consists of passing the library
some BibTeX data (or a source for some BibTeX data, such as
a filename or a file pointer), which it then lexically
scans, parses, and constructs an abstract syntax tree (
<small>AST</small> ) from. It returns this
<small>AST</small> to you, and you call other <b>btparse</b>
functions to traverse and query the tree.</p>

<p style="margin-left:11%; margin-top: 1em">The contents of
<small>AST</small> nodes are the private domain of the
library, and you shouldn&rsquo;t go poking into them. This
being C, though, there&rsquo;s nothing to prevent you from
doing so except good manners and the possibility that I
might change the <small>AST</small> structure in future
releases, breaking any badly-behaved code. Also, it&rsquo;s
not necessary to know the structural relationships between
nodes in the AST&minus;&minus;&minus;that&rsquo;s taken care
of by the query/traversal functions.</p>

<p style="margin-left:11%; margin-top: 1em">However,
it&rsquo;s useful to know some of the things that
<b>btparse</b> deposits in the <small>AST</small> and
returns to you through those query/traversal functions.
First off, each node has a &quot;node type,&quot; which
records the syntactic element corresponding to each node.
For instance, the entry</p>

<p style="margin-left:11%; margin-top: 1em">@book{mybook,
author = &quot;Joe Blow&quot;, title = &quot;My Little
Book&quot;}</p>

<p style="margin-left:11%; margin-top: 1em">is rooted by an
&quot;entry&quot; node; under this would be found a
&quot;key&quot; node (for the entry key), two
&quot;field&quot; nodes (for the &quot;author&quot; and
&quot;title&quot; fields); and associated with each field
node would be a &quot;string&quot; node. The only time this
concerns you is when you ask the library for a simple value;
just looking at the text is not enough to distinguish quoted
strings, numbers, and macro names, so <b>btparse</b> returns
the nodetype as well.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the nodetype, <b>btparse</b> records the metatype of each
&quot;entry&quot; node. This allows you (and the library) to
distinguish, say, regular entries from comment entries. Not
only do they have very different structures and must
therefore be traversed differently by the library, but
certain traversal functions make no sense on certain entry
metatypes&minus;&minus;&minus;thus it&rsquo;s necessary for
you to be able to make the distinction as well.</p>

<p style="margin-left:11%; margin-top: 1em">That said,
everything you need to know to work with the
<small>AST</small> is explained in bt_traversal.</p>

<h2>DATA TYPES AND MACROS
<a name="DATA TYPES AND MACROS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>btparse</b>
defines several types required for the external interface.
First, it trivially defines a &quot;boolean&quot; type
(along with &quot;TRUE&quot; and &quot;FALSE&quot; macros).
This might affect you when including the <i>btparse.h</i>
header in your own code&minus;&minus;&minus;since it&rsquo;s
not possible for the code to detect if there is already a
&quot;boolean&quot; type defined, you might have to define
the &quot;HAVE_BOOLEAN&quot; pre-processor token to
deactivate <i>btparse.h</i>&rsquo;s &quot;typedef&quot; of
&quot;boolean&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Next, two
enumeration types are defined: &quot;bt_metatype&quot; and
&quot;bt_nodetype&quot;. Both of these are used extensively
in the library itself, and are made available to users of
the library because they can be found in nodes of the
&quot;btparse&quot; <small>AST</small> (abstract syntax
tree). (I.e., querying the <small>AST</small> can give you
&quot;bt_metatype&quot; and &quot;bt_nodetype&quot; values,
so the &quot;typedef&quot;s must be available to your
code.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Entry
metatype enum</b> <br>
&quot;bt_metatype_t&quot; has the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>&quot;BTE_UNKNOWN&quot;</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>&quot;BTE_REGULAR&quot;</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>&quot;BTE_COMMENT&quot;</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>&quot;BTE_PREAMBLE&quot;</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>&quot;BTE_MACRODEF&quot;</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">which are
determined by the &quot;entry type&quot; token. (@string
entries have the &quot;BTE_MACRODEF&quot; metatype; @comment
and @preamble correspond to &quot;BTE_COMMENT&quot; and
&quot;BTE_PREAMBLE&quot;; and any other entry type has the
&quot;BTE_REGULAR&quot; metatype.)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>AST</small>
nodetype enum</b> <br>
&quot;bt_nodetype&quot; has the following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p style="margin-top: 1em">&quot;BTAST_UNKNOWN&quot;</p></td>
<td width="60%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p>&quot;BTAST_ENTRY&quot;</p></td>
<td width="60%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p>&quot;BTAST_KEY&quot;</p></td>
<td width="60%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p>&quot;BTAST_FIELD&quot;</p></td>
<td width="60%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p>&quot;BTAST_STRING&quot;</p></td>
<td width="60%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p>&quot;BTAST_NUMBER&quot;</p></td>
<td width="60%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p>&quot;BTAST_MACRO&quot;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Of these,
you&rsquo;ll only ever deal with the last three. They are
returned when you query the <small>AST</small> for a simple
value&minus;&minus;&minus;just seeing the text isn&rsquo;t
enough to distinguish between a quoted string, a number, and
a macro, so the <small>AST</small> nodetype is supplied
along with the text.</p>

<p style="margin-left:11%; margin-top: 1em"><b>String
processing option macros</b> <br>
Since BibTeX is essentially a system for glueing strings
together in a wide variety of ways, the processing done to
its strings is fairly important. Most of the string
transformations are done outside of the lexer/parser; this
reduces their complexity, and makes it easier to switch
different transformations on and off. This switching is done
with an &quot;options&quot; bitmap which can be specified on
a per-entry-metatype basis. (That is, you can have one set
of transformations done to the strings in all regular
entries, another set done to the strings in all macro
definition entries, and so on.) If you need finer control
than that, it&rsquo;s currently unavailable outside of the
library (but it&rsquo;s just a matter of making a couple
functions available and documenting
them&minus;&minus;&minus;so bug me if you need this
feature).</p>

<p style="margin-left:11%; margin-top: 1em">There are three
basic macros for constructing this bitmap: <br>
&quot;BTO_CONVERT&quot;</p>

<p style="margin-left:17%;">Convert &quot;number&quot;
values to strings. (The conversion is trivial, involving
changing the type of the <small>AST</small> node
representing the number from &quot;BTAST_NUMBER&quot; to
&quot;BTAST_STRING&quot;. &quot;Number&quot; values are
stored as strings of digits, just as they are in the input
data.)</p>

<p style="margin-left:11%;">&quot;BTO_EXPAND&quot;</p>

<p style="margin-left:17%;">Expand macro invocations to the
full macro text.</p>

<p style="margin-left:11%;">&quot;BTO_PASTE&quot;</p>

<p style="margin-left:17%;">Paste simple values
together.</p>

<p style="margin-left:11%;">&quot;BTO_COLLAPSE&quot;</p>

<p style="margin-left:17%;">Collapse whitespace according
to the BibTeX rules.</p>

<p style="margin-left:11%; margin-top: 1em">For instance,
supplying &quot;BTO_CONVERT | BTO_EXPAND&quot; as the string
options bitmap for the &quot;BTE_REGULAR&quot; metatype
means that all simple values in &quot;regular&quot; entries
will be converted to strings: numbers will simply have their
&quot;nodetype&quot; changed, and macros will be expanded.
Nothing else will be done to the simple values,
though&minus;&minus;&minus;they will not be concatenated,
nor will whitespace be collapsed. See the
&quot;bt_set_stringopts()&quot; and &quot;bt_parse_*()&quot;
functions in bt_input for more information on the various
options for parsing; see bt_postprocess for details on the
post-processing.</p>

<h2>USING THE LIBRARY
<a name="USING THE LIBRARY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
code is a skeletal example of using the <b>btparse</b>
library:</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;btparse.h&gt; <br>
int main (void) <br>
{ <br>
bt_initialize (); <br>
/* process some data */ <br>
bt_cleanup (); <br>
exit (0); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Please note the
call to &quot;bt_initialize()&quot;; this is very important!
Without it, the library may crash or fail mysteriously. You
<i>must</i> call &quot;bt_initialize()&quot; before calling
any other <b>btparse</b> functions. &quot;bt_cleanup()&quot;
just frees the memory allocated by
&quot;bt_initialize()&quot;; if you are careful to call it
before exiting, and &quot;bt_free_ast()&quot; on any
abstract syntax trees generated by <b>btparse</b> when you
are done with them, then your program shouldn&rsquo;t have
any memory leaks. (Unless they&rsquo;re due to your own
code, of course!)</p>

<h2>BUGS AND LIMITATIONS
<a name="BUGS AND LIMITATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>btparse</b>
has several inherent limitations that are due to the lexical
scanner and parser generated by <small>PCCTS 1</small> .x.
In short, the scanner and parser are both heavily dependent
on global variables, meaning that thread safety -- or even
the ability to have two files open and being parsed at the
same time -- is well-nigh impossible. This will not change
until I get with the times and adopt <small>ANTLR
2.0,</small> the successor to <small>PCCTS</small> --
presuming of course that it can generate more modular C
scanners and parsers.</p>

<p style="margin-left:11%; margin-top: 1em">Another
limitation that is due to <small>PCCTS:</small> entries with
a large number of fields (more than about 90, if each field
value is just a single string) will cause the parser to
crash. This is unavoidable due to the parser using
statically-allocated stacks for attributes and
abstract-syntax tree nodes. I could increase the static
allocation, but that would just decrease the likelihood of
encountering the problem, not make it go away. Again, the
chances of this changing as long as I&rsquo;m using
<small>PCCTS 1</small> .x are nil.</p>

<p style="margin-left:11%; margin-top: 1em">Apart from
those inherent limitations, there are no known bugs in
<b>btparse</b>. Any segmentation faults or bus errors from
the library should be considered bugs. They probably result
from using the library incorrectly (eg. attempting to
interleave the parsing of two files), but I do make an
attempt to catch all such mistakes, and if I&rsquo;ve missed
any I&rsquo;d like to know about it.</p>

<p style="margin-left:11%; margin-top: 1em">Any memory
leaks from the library are also a concern; as long as you
are conscientious about calling the cleanup functions
(&quot;bt_free_ast()&quot; and &quot;bt_cleanup()&quot;),
then the library shouldn&rsquo;t leak.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To read and
parse BibTeX data files, see bt_input.</p>

<p style="margin-left:11%; margin-top: 1em">To traverse the
syntax tree that results, see bt_traversal.</p>

<p style="margin-left:11%; margin-top: 1em">To learn what
is done to values in parsed entries, and how to customize
that munging, see bt_postprocess.</p>

<p style="margin-left:11%; margin-top: 1em">To learn how
<b>btparse</b> deals with strings, see bt_strings (oops, I
haven&rsquo;t written this one yet!).</p>

<p style="margin-left:11%; margin-top: 1em">To manipulate
and access the <b>btparse</b> macro table, see
bt_macros.</p>

<p style="margin-left:11%; margin-top: 1em">For splitting
author names and lists &quot;the BibTeX way&quot; using
<b>btparse</b>, bt_split_names.</p>

<p style="margin-left:11%; margin-top: 1em">To put author
names back together again, see bt_format_names.</p>

<p style="margin-left:11%; margin-top: 1em">Miscellaneous
functions for processing strings &quot;the BibTeX way&quot;:
bt_misc.</p>

<p style="margin-left:11%; margin-top: 1em">A semi-formal
language definition is in bt_language.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Greg Ward
&lt;gward@python.net&gt;</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1996&minus;97 by Gregory P. Ward.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the terms of the <small>GNU</small> Library General
Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any
later version.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the
<small>GNU</small> Library General Public License for more
details.</p>

<p style="margin-left:11%; margin-top: 1em">You should have
received a copy of the <small>GNU</small> Library General
Public License along with this library; if not, write to the
Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
<small>MA 02139, USA.</small></p>

<h2>AVAILABILITY
<a name="AVAILABILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The btOOL home
page, where you can get up-to-date information about
<b>btparse</b> (and download the latest version) is</p>


<p style="margin-left:11%; margin-top: 1em">http://starship.python.net/~gward/btOOL/</p>

<p style="margin-left:11%; margin-top: 1em">You will also
find the latest version of <b>Text::BibTeX</b>, the Perl
library that provides a high-level front-end to
<b>btparse</b>, there. <b>btparse</b> is needed to build
&quot;Text::BibTeX&quot;, and must be downloaded
separately.</p>

<p style="margin-left:11%; margin-top: 1em">Both libraries
are also available on <small>CTAN</small> (the Comprehensive
TeX Archive Network,
&quot;http://www.ctan.org/tex&minus;archive/&quot;) and
<small>CPAN</small> (the Comprehensive Perl Archive Network,
&quot;http://www.cpan.org/&quot;). Look in
<i>biblio/bibtex/utils/btOOL/</i> on <small>CTAN,</small>
and <i>authors/Greg_Ward/</i> on <small>CPAN.</small> For
example,</p>


<p style="margin-left:11%; margin-top: 1em">http://www.ctan.org/tex&minus;archive/biblio/bibtex/utils/btOOL/
<br>
http://www.cpan.org/authors/Greg_Ward</p>

<p style="margin-left:11%; margin-top: 1em">will both get
you to the latest version of &quot;Text::BibTeX&quot; and
<b>btparse</b> -- but of course, you should always access
busy sites like <small>CTAN</small> and <small>CPAN</small>
through a mirror.</p>
<hr>
</body>
</html>
