<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLUNIINTRO</title>

</head>
<body>
<h1>perluniintro</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perluniintro
&minus; Perl Unicode introduction</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
gives a general idea of Unicode and how to use Unicode in
Perl. See &quot;Further Resources&quot; for references to
more in-depth treatments of Unicode.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unicode</b>
<br>
Unicode is a character set standard which plans to codify
all of the writing systems of the world, plus many other
symbols.</p>

<p style="margin-left:11%; margin-top: 1em">Unicode and
<small>ISO/IEC 10646</small> are coordinated standards that
unify almost all other modern character set standards,
covering more than 80 writing systems and hundreds of
languages, including all commercially-important modern
languages. All characters in the largest Chinese, Japanese,
and Korean dictionaries are also encoded. The standards will
eventually cover almost all characters in more than 250
writing systems and thousands of languages. Unicode 1.0 was
released in October 1991, and 6.0 in October 2010.</p>

<p style="margin-left:11%; margin-top: 1em">A Unicode
<i>character</i> is an abstract entity. It is not bound to
any particular integer width, especially not to the C
language &quot;char&quot;. Unicode is language-neutral and
display-neutral: it does not encode the language of the
text, and it does not generally define fonts or other
graphical layout details. Unicode operates on characters and
on text built from those characters.</p>

<p style="margin-left:11%; margin-top: 1em">Unicode defines
characters like &quot;LATIN CAPITAL LETTER A&quot; or
&quot;GREEK SMALL LETTER ALPHA&quot; and unique numbers for
the characters, in this case 0x0041 and 0x03B1,
respectively. These unique numbers are called <i>code
points</i>. A code point is essentially the position of the
character within the set of all possible Unicode characters,
and thus in Perl, the term <i>ordinal</i> is often used
interchangeably with it.</p>

<p style="margin-left:11%; margin-top: 1em">The Unicode
standard prefers using hexadecimal notation for the code
points. If numbers like 0x0041 are unfamiliar to you, take a
peek at a later section, &quot;Hexadecimal Notation&quot;.
The Unicode standard uses the notation &quot;U+0041 LATIN
CAPITAL LETTER A&quot;, to give the hexadecimal code point
and the normative name of the character.</p>

<p style="margin-left:11%; margin-top: 1em">Unicode also
defines various <i>properties</i> for the characters, like
&quot;uppercase&quot; or &quot;lowercase&quot;,
&quot;decimal digit&quot;, or &quot;punctuation&quot;; these
properties are independent of the names of the characters.
Furthermore, various operations on the characters like
uppercasing, lowercasing, and collating (sorting) are
defined.</p>

<p style="margin-left:11%; margin-top: 1em">A Unicode
<i>logical</i> &quot;character&quot; can actually consist of
more than one internal <i>actual</i> &quot;character&quot;
or code point. For Western languages, this is adequately
modelled by a <i>base character</i> (like &quot;LATIN
CAPITAL LETTER A&quot;) followed by one or more
<i>modifiers</i> (like &quot;COMBINING ACUTE ACCENT&quot;).
This sequence of base character and modifiers is called a
<i>combining character sequence</i>. Some non-western
languages require more complicated models, so Unicode
created the <i>grapheme cluster</i> concept, which was later
further refined into the <i>extended grapheme cluster</i>.
For example, a Korean Hangul syllable is considered a single
logical character, but most often consists of three actual
Unicode characters: a leading consonant followed by an
interior vowel followed by a trailing consonant.</p>

<p style="margin-left:11%; margin-top: 1em">Whether to call
these extended grapheme clusters &quot;characters&quot;
depends on your point of view. If you are a programmer, you
probably would tend towards seeing each element in the
sequences as one unit, or &quot;character&quot;. However
from the user&rsquo;s point of view, the whole sequence
could be seen as one &quot;character&quot; since
that&rsquo;s probably what it looks like in the context of
the user&rsquo;s language. In this document, we take the
programmer&rsquo;s point of view: one &quot;character&quot;
is one Unicode code point.</p>

<p style="margin-left:11%; margin-top: 1em">For some
combinations of base character and modifiers, there are
<i>precomposed</i> characters. There is a single character
equivalent, for example, for the sequence &quot;LATIN
CAPITAL LETTER A&quot; followed by &quot;COMBINING ACUTE
ACCENT&quot;. It is called &quot;LATIN CAPITAL LETTER A WITH
ACUTE&quot;. These precomposed characters are, however, only
available for some combinations, and are mainly meant to
support round-trip conversions between Unicode and legacy
standards (like <small>ISO 8859</small> ). Using sequences,
as Unicode does, allows for needing fewer basic building
blocks (code points) to express many more potential grapheme
clusters. To support conversion between equivalent forms,
various <i>normalization forms</i> are also defined. Thus,
&quot;LATIN CAPITAL LETTER A WITH ACUTE&quot; is in
<i>Normalization Form Composed</i>, (abbreviated
<small>NFC</small> ), and the sequence &quot;LATIN CAPITAL
LETTER A&quot; followed by &quot;COMBINING ACUTE
ACCENT&quot; represents the same character in
<i>Normalization Form Decomposed</i> ( <small>NFD</small>
).</p>

<p style="margin-left:11%; margin-top: 1em">Because of
backward compatibility with legacy encodings, the &quot;a
unique number for every character&quot; idea breaks down a
bit: instead, there is &quot;at least one number for every
character&quot;. The same character could be represented
differently in several legacy encodings. The converse is not
true: some code points do not have an assigned character.
Firstly, there are unallocated code points within otherwise
used blocks. Secondly, there are special Unicode control
characters that do not represent true characters.</p>

<p style="margin-left:11%; margin-top: 1em">When Unicode
was first conceived, it was thought that all the
world&rsquo;s characters could be represented using a
16&minus;bit word; that is a maximum of 0x10000 (or 65,536)
characters would be needed, from 0x0000 to 0xFFFF. This soon
proved to be wrong, and since Unicode 2.0 (July 1996),
Unicode has been defined all the way up to 21 bits
(0x10FFFF), and Unicode 3.1 (March 2001) defined the first
characters above 0xFFFF. The first 0x10000 characters are
called the <i>Plane 0</i>, or the <i>Basic Multilingual
Plane</i> ( <small>BMP</small> ). With Unicode 3.1, 17 (yes,
seventeen) planes in all were defined--but they are nowhere
near full of defined characters, yet.</p>

<p style="margin-left:11%; margin-top: 1em">When a new
language is being encoded, Unicode generally will choose a
&quot;block&quot; of consecutive unallocated code points for
its characters. So far, the number of code points in these
blocks has always been evenly divisible by 16. Extras in a
block, not currently needed, are left unallocated, for
future growth. But there have been occasions when a later
release needed more code points than the available extras,
and a new block had to allocated somewhere else, not
contiguous to the initial one, to handle the overflow. Thus,
it became apparent early on that &quot;block&quot;
wasn&rsquo;t an adequate organizing principle, and so the
&quot;Script&quot; property was created. (Later an improved
script property was added as well, the
&quot;Script_Extensions&quot; property.) Those code points
that are in overflow blocks can still have the same script
as the original ones. The script concept fits more closely
with natural language: there is &quot;Latin&quot; script,
&quot;Greek&quot; script, and so on; and there are several
artificial scripts, like &quot;Common&quot; for characters
that are used in multiple scripts, such as mathematical
symbols. Scripts usually span varied parts of several
blocks. For more information about scripts, see
&quot;Scripts&quot; in perlunicode. The division into blocks
exists, but it is almost completely accidental--an artifact
of how the characters have been and still are allocated.
(Note that this paragraph has oversimplified things for the
sake of this being an introduction. Unicode doesn&rsquo;t
really encode languages, but the writing systems for
them--their scripts; and one script can be used by many
languages. Unicode also encodes things that aren&rsquo;t
really about languages, such as symbols like &quot;BAGGAGE
CLAIM&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">The Unicode
code points are just abstract numbers. To input and output
these abstract numbers, the numbers must be <i>encoded</i>
or <i>serialised</i> somehow. Unicode defines several
<i>character encoding forms</i>, of which
<i><small>UTF&minus;8</small></i> is the most popular.
<small>UTF&minus;8</small> is a variable length encoding
that encodes Unicode characters as 1 to 4 bytes. Other
encodings include <small>UTF&minus;16</small> and
<small>UTF&minus;32</small> and their big&minus; and
little-endian variants ( <small>UTF&minus;8</small> is
byte-order independent). The <small>ISO/IEC 10646</small>
defines the <small>UCS&minus;2</small> and
<small>UCS&minus;4</small> encoding forms.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information about encodings--for instance, to learn what
<i>surrogates</i> and <i>byte order marks</i> (BOMs)
are--see perlunicode.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Perl&rsquo;s
Unicode Support</b> <br>
Starting from Perl v5.6.0, Perl has had the capacity to
handle Unicode natively. Perl v5.8.0, however, is the first
recommended release for serious Unicode work. The
maintenance release 5.6.1 fixed many of the problems of the
initial Unicode implementation, but for example regular
expressions still do not work with Unicode in 5.6.1. Perl
v5.14.0 is the first release where Unicode support is
(almost) seamlessly integratable without some gotchas.
(There are a few exceptions. Firstly, some differences in
quotemeta were fixed starting in Perl 5.16.0. Secondly, some
differences in the range operator were fixed starting in
Perl 5.26.0. Thirdly, some differences in split were fixed
started in Perl 5.28.0.)</p>

<p style="margin-left:11%; margin-top: 1em">To enable this
seamless support, you should &quot;use feature
'unicode_strings'&quot; (which is automatically selected if
you &quot;use v5.12&quot; or higher). See feature. (5.14
also fixes a number of bugs and departures from the Unicode
standard.)</p>

<p style="margin-left:11%; margin-top: 1em">Before Perl
v5.8.0, the use of &quot;use utf8&quot; was used to declare
that operations in the current block or file would be
Unicode-aware. This model was found to be wrong, or at least
clumsy: the &quot;Unicodeness&quot; is now carried with the
data, instead of being attached to the operations. Starting
with Perl v5.8.0, only one case remains where an explicit
&quot;use utf8&quot; is needed: if your Perl script itself
is encoded in <small>UTF&minus;8,</small> you can use
<small>UTF&minus;8</small> in your identifier names, and in
string and regular expression literals, by saying &quot;use
utf8&quot;. This is not the default because scripts with
legacy 8&minus;bit data in them would break. See utf8.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Perl&rsquo;s
Unicode Model</b> <br>
Perl supports both pre&minus;5.6 strings of eight-bit native
bytes, and strings of Unicode characters. The general
principle is that Perl tries to keep its data as eight-bit
bytes for as long as possible, but as soon as Unicodeness
cannot be avoided, the data is transparently upgraded to
Unicode. Prior to Perl v5.14.0, the upgrade was not
completely transparent (see &quot;The &quot;Unicode
Bug&quot;&quot; in perlunicode), and for backwards
compatibility, full transparency is not gained unless
&quot;use feature 'unicode_strings'&quot; (see feature) or
&quot;use v5.12&quot; (or higher) is selected.</p>

<p style="margin-left:11%; margin-top: 1em">Internally,
Perl currently uses either whatever the native eight-bit
character set of the platform (for example Latin&minus;1)
is, defaulting to <small>UTF&minus;8,</small> to encode
Unicode strings. Specifically, if all code points in the
string are 0xFF or less, Perl uses the native eight-bit
character set. Otherwise, it uses
<small>UTF&minus;8.</small></p>

<p style="margin-left:11%; margin-top: 1em">A user of Perl
does not normally need to know nor care how Perl happens to
encode its internal strings, but it becomes relevant when
outputting Unicode strings to a stream without a PerlIO
layer (one with the &quot;default&quot; encoding). In such a
case, the raw bytes used internally (the native character
set or <small>UTF&minus;8,</small> as appropriate for each
string) will be used, and a &quot;Wide character&quot;
warning will be issued if those strings contain a character
beyond 0x00FF.</p>

<p style="margin-left:11%; margin-top: 1em">For
example,</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;e
'print &quot;\x{DF}\n&quot;,
&quot;\x{0100}\x{DF}\n&quot;'</p>

<p style="margin-left:11%; margin-top: 1em">produces a
fairly useless mixture of native bytes and
<small>UTF&minus;8,</small> as well as a warning:</p>

<p style="margin-left:11%; margin-top: 1em">Wide character
in print at ...</p>

<p style="margin-left:11%; margin-top: 1em">To output
<small>UTF&minus;8,</small> use the &quot;:encoding&quot; or
&quot;:utf8&quot; output layer. Prepending</p>


<p style="margin-left:11%; margin-top: 1em">binmode(STDOUT,
&quot;:utf8&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">to this sample
program ensures that the output is completely
<small>UTF&minus;8,</small> and removes the program&rsquo;s
warning.</p>

<p style="margin-left:11%; margin-top: 1em">You can enable
automatic UTF&minus;8&minus;ification of your standard file
handles, default &quot;open()&quot; layer, and @ARGV by
using either the &quot;&minus;C&quot; command line switch or
the &quot;PERL_UNICODE&quot; environment variable, see
perlrun for the documentation of the &quot;&minus;C&quot;
switch.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
means that Perl expects other software to work the same way:
if Perl has been led to believe that <small>STDIN</small>
should be <small>UTF&minus;8,</small> but then
<small>STDIN</small> coming in from another command is not
<small>UTF&minus;8,</small> Perl will likely complain about
the malformed <small>UTF&minus;8.</small></p>

<p style="margin-left:11%; margin-top: 1em">All features
that combine Unicode and I/O also require using the new
PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO,
though: you can see whether yours is by running &quot;perl
&minus;V&quot; and looking for
&quot;useperlio=define&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unicode and
<small>EBCDIC</small></b> <br>
Perl 5.8.0 added support for Unicode on
<small>EBCDIC</small> platforms. This support was allowed to
lapse in later releases, but was revived in 5.22. Unicode
support is somewhat more complex to implement since
additional conversions are needed. See perlebcdic for more
information.</p>

<p style="margin-left:11%; margin-top: 1em">On
<small>EBCDIC</small> platforms, the internal Unicode
encoding form is UTF-EBCDIC instead of
<small>UTF&minus;8.</small> The difference is that as
<small>UTF&minus;8</small> is &quot;ASCII-safe&quot; in that
<small>ASCII</small> characters encode to
<small>UTF&minus;8</small> as-is, while UTF-EBCDIC is
&quot;EBCDIC-safe&quot;, in that all the basic characters
(which includes all those that have <small>ASCII</small>
equivalents (like &quot;A&quot;, &quot;0&quot;,
&quot;%&quot;, <i>etc.</i>) are the same in both
<small>EBCDIC</small> and UTF-EBCDIC. Often, documentation
will use the term &quot; <small>UTF&minus;8&quot;</small> to
mean UTF-EBCDIC as well. This is the case in this
document.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Creating
Unicode</b> <br>
This section applies fully to Perls starting with v5.22.
Various caveats for earlier releases are in the
&quot;Earlier releases caveats&quot; subsection below.</p>

<p style="margin-left:11%; margin-top: 1em">To create
Unicode characters in literals, use the &quot;\N{...}&quot;
notation in double-quoted strings:</p>

<p style="margin-left:11%; margin-top: 1em">my
$smiley_from_name = &quot;\N{WHITE SMILING FACE}&quot;; <br>
my $smiley_from_code_point = &quot;\N{U+263a}&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, they
can be used in regular expression literals</p>

<p style="margin-left:11%; margin-top: 1em">$smiley =~
/\N{WHITE SMILING FACE}/; <br>
$smiley =~ /\N{U+263a}/;</p>

<p style="margin-left:11%; margin-top: 1em">or, starting in
v5.32:</p>

<p style="margin-left:11%; margin-top: 1em">$smiley =~
/\p{Name=WHITE SMILING FACE}/; <br>
$smiley =~ /\p{Name=whitesmilingface}/;</p>

<p style="margin-left:11%; margin-top: 1em">At run-time you
can use:</p>

<p style="margin-left:11%; margin-top: 1em">use charnames
(); <br>
my $hebrew_alef_from_name <br>
= charnames::string_vianame(&quot;HEBREW LETTER ALEF&quot;);
<br>
my $hebrew_alef_from_code_point =
charnames::string_vianame(&quot;U+05D0&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">Naturally,
&quot;ord()&quot; will do the reverse: it turns a character
into a code point.</p>

<p style="margin-left:11%; margin-top: 1em">There are other
runtime options as well. You can use &quot;pack()&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">my
$hebrew_alef_from_code_point = pack(&quot;U&quot;,
0x05d0);</p>

<p style="margin-left:11%; margin-top: 1em">Or you can use
&quot;chr()&quot;, though it is less convenient in the
general case:</p>


<p style="margin-left:11%; margin-top: 1em">$hebrew_alef_from_code_point
= chr(utf8::unicode_to_native(0x05d0)); <br>
utf8::upgrade($hebrew_alef_from_code_point);</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;utf8::unicode_to_native()&quot; and
&quot;utf8::upgrade()&quot; aren&rsquo;t needed if the
argument is above 0xFF, so the above could have been written
as</p>


<p style="margin-left:11%; margin-top: 1em">$hebrew_alef_from_code_point
= chr(0x05d0);</p>

<p style="margin-left:11%; margin-top: 1em">since 0x5d0 is
above 255.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;\x{}&quot;
and &quot;\o{}&quot; can also be used to specify code points
at compile time in double-quotish strings, but, for backward
compatibility with older Perls, the same rules apply as with
&quot;chr()&quot; for code points less than 256.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;utf8::unicode_to_native()&quot;
is used so that the Perl code is portable to
<small>EBCDIC</small> platforms. You can omit it if
you&rsquo;re <i>really</i> sure no one will ever want to use
your code on a non-ASCII platform. Starting in Perl v5.22,
calls to it on <small>ASCII</small> platforms are optimized
out, so there&rsquo;s no performance penalty at all in
adding it. Or you can simply use the other constructs that
don&rsquo;t require it.</p>

<p style="margin-left:11%; margin-top: 1em">See
&quot;Further Resources&quot; for how to find all these
names and numeric codes.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Earlier
releases caveats</i></p>

<p style="margin-left:11%; margin-top: 1em">On
<small>EBCDIC</small> platforms, prior to v5.22, using
&quot;\N{U+...}&quot; doesn&rsquo;t work properly.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to v5.16,
using &quot;\N{...}&quot; with a character name (as opposed
to a &quot;U+...&quot; code point) required a
&quot;use&nbsp;charnames&nbsp;:full&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to v5.14,
there were some bugs in &quot;\N{...}&quot; with a character
name (as opposed to a &quot;U+...&quot; code point).</p>


<p style="margin-left:11%; margin-top: 1em">&quot;charnames::string_vianame()&quot;
was introduced in v5.14. Prior to that,
&quot;charnames::vianame()&quot; should work, but only if
the argument is of the form &quot;U+...&quot;. Your best bet
there for runtime Unicode by character name is probably:</p>

<p style="margin-left:11%; margin-top: 1em">use charnames
(); <br>
my $hebrew_alef_from_name <br>
= pack(&quot;U&quot;, charnames::vianame(&quot;HEBREW LETTER
ALEF&quot;));</p>

<p style="margin-left:11%; margin-top: 1em"><b>Handling
Unicode</b> <br>
Handling Unicode is for the most part transparent: just use
the strings as usual. Functions like &quot;index()&quot;,
&quot;length()&quot;, and &quot;substr()&quot; will work on
the Unicode characters; regular expressions will work on the
Unicode characters (see perlunicode and perlretut).</p>

<p style="margin-left:11%; margin-top: 1em">Note that Perl
considers grapheme clusters to be separate characters, so
for example</p>

<p style="margin-left:11%; margin-top: 1em">print
length(&quot;\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE
ACCENT}&quot;), <br>
&quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">will print 2,
not 1. The only exception is that regular expressions have
&quot;\X&quot; for matching an extended grapheme cluster.
(Thus &quot;\X&quot; in a regular expression would match the
entire sequence of both the example characters.)</p>

<p style="margin-left:11%; margin-top: 1em">Life is not
quite so transparent, however, when working with legacy
encodings, I/O, and certain special cases:</p>

<p style="margin-left:11%; margin-top: 1em"><b>Legacy
Encodings</b> <br>
When you combine legacy data and Unicode, the legacy data
needs to be upgraded to Unicode. Normally the legacy data is
assumed to be <small>ISO 8859&minus;1</small> (or
<small>EBCDIC,</small> if applicable).</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;Encode&quot; module knows about many encodings and has
interfaces for doing conversions between those
encodings:</p>

<p style="margin-left:11%; margin-top: 1em">use Encode
'decode'; <br>
$data = decode(&quot;iso&minus;8859&minus;3&quot;, $data); #
convert from legacy</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unicode
I/O</b> <br>
Normally, writing out Unicode data</p>

<p style="margin-left:11%; margin-top: 1em">print FH
$some_string_with_unicode, &quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">produces raw
bytes that Perl happens to use to internally encode the
Unicode string. Perl&rsquo;s internal encoding depends on
the system as well as what characters happen to be in the
string at the time. If any of the characters are at code
points 0x100 or above, you will get a warning. To ensure
that the output is explicitly rendered in the encoding you
desire--and to avoid the warning--open the stream with the
desired encoding. Some examples:</p>

<p style="margin-left:11%; margin-top: 1em">open FH,
&quot;&gt;:utf8&quot;, &quot;file&quot;; <br>
open FH, &quot;&gt;:encoding(ucs2)&quot;, &quot;file&quot;;
<br>
open FH, &quot;&gt;:encoding(UTF&minus;8)&quot;,
&quot;file&quot;; <br>
open FH, &quot;&gt;:encoding(shift_jis)&quot;,
&quot;file&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">and on already
open streams, use &quot;binmode()&quot;:</p>


<p style="margin-left:11%; margin-top: 1em">binmode(STDOUT,
&quot;:utf8&quot;); <br>
binmode(STDOUT, &quot;:encoding(ucs2)&quot;); <br>
binmode(STDOUT, &quot;:encoding(UTF&minus;8)&quot;); <br>
binmode(STDOUT, &quot;:encoding(shift_jis)&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">The matching of
encoding names is loose: case does not matter, and many
encodings have several aliases. Note that the
&quot;:utf8&quot; layer must always be specified exactly
like that; it is <i>not</i> subject to the loose matching of
encoding names. Also note that currently &quot;:utf8&quot;
is unsafe for input, because it accepts the data without
validating that it is indeed valid
<small>UTF&minus;8</small> ; you should instead use
&quot;:encoding(UTF&minus;8)&quot; (with or without a
hyphen).</p>

<p style="margin-left:11%; margin-top: 1em">See PerlIO for
the &quot;:utf8&quot; layer, PerlIO::encoding and
Encode::PerlIO for the &quot;:encoding()&quot; layer, and
Encode::Supported for many encodings supported by the
&quot;Encode&quot; module.</p>

<p style="margin-left:11%; margin-top: 1em">Reading in a
file that you know happens to be encoded in one of the
Unicode or legacy encodings does not magically turn the data
into Unicode in Perl&rsquo;s eyes. To do that, specify the
appropriate layer when opening files</p>

<p style="margin-left:11%; margin-top: 1em">open(my
$fh,'&lt;:encoding(UTF&minus;8)', 'anything'); <br>
my $line_of_unicode = &lt;$fh&gt;; <br>
open(my $fh,'&lt;:encoding(Big5)', 'anything'); <br>
my $line_of_unicode = &lt;$fh&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">The I/O layers
can also be specified more flexibly with the
&quot;open&quot; pragma. See open, or look at the following
example.</p>

<p style="margin-left:11%; margin-top: 1em">use open
':encoding(UTF&minus;8)'; # input/output default encoding
will be <br>
# UTF&minus;8 <br>
open X, &quot;&gt;file&quot;; <br>
print X chr(0x100), &quot;\n&quot;; <br>
close X; <br>
open Y, &quot;&lt;file&quot;; <br>
printf &quot;%#x\n&quot;, ord(&lt;Y&gt;); # this should
print 0x100 <br>
close Y;</p>

<p style="margin-left:11%; margin-top: 1em">With the
&quot;open&quot; pragma you can use the &quot;:locale&quot;
layer</p>

<p style="margin-left:11%; margin-top: 1em">BEGIN {
$ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8&minus;R' } <br>
# the :locale will probe the locale environment variables
like <br>
# LC_ALL <br>
use open OUT =&gt; ':locale'; # russki parusski <br>
open(O, &quot;&gt;koi8&quot;); <br>
print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A =
KOI8&minus;R 0xc1 <br>
close O; <br>
open(I, &quot;&lt;koi8&quot;); <br>
printf &quot;%#x\n&quot;, ord(&lt;I&gt;), &quot;\n&quot;; #
this should print 0xc1 <br>
close I;</p>

<p style="margin-left:11%; margin-top: 1em">These methods
install a transparent filter on the I/O stream that converts
data from the specified encoding when it is read in from the
stream. The result is always Unicode.</p>

<p style="margin-left:11%; margin-top: 1em">The open pragma
affects all the &quot;open()&quot; calls after the pragma by
setting default layers. If you want to affect only certain
streams, use explicit layers directly in the
&quot;open()&quot; call.</p>

<p style="margin-left:11%; margin-top: 1em">You can switch
encodings on an already opened stream by using
&quot;binmode()&quot;; see &quot;binmode&quot; in
perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;:locale&quot; does not currently work with
&quot;open()&quot; and &quot;binmode()&quot;, only with the
&quot;open&quot; pragma. The &quot;:utf8&quot; and
&quot;:encoding(...)&quot; methods do work with all of
&quot;open()&quot;, &quot;binmode()&quot;, and the
&quot;open&quot; pragma.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, you
may use these I/O layers on output streams to automatically
convert Unicode to the specified encoding when it is written
to the stream. For example, the following snippet copies the
contents of the file &quot;text.jis&quot; (encoded as
<small>ISO&minus;2022&minus;JP,</small> aka
<small>JIS</small> ) to the file &quot;text.utf8&quot;,
encoded as <small>UTF&minus;8:</small></p>

<p style="margin-left:11%; margin-top: 1em">open(my
$nihongo, '&lt;:encoding(iso&minus;2022&minus;jp)',
'text.jis'); <br>
open(my $unicode, '&gt;:utf8', 'text.utf8'); <br>
while (&lt;$nihongo&gt;) { print $unicode $_ }</p>

<p style="margin-left:11%; margin-top: 1em">The naming of
encodings, both by the &quot;open()&quot; and by the
&quot;open&quot; pragma allows for flexible names:
&quot;koi8&minus;r&quot; and &quot;KOI8R&quot; will both be
understood.</p>

<p style="margin-left:11%; margin-top: 1em">Common
encodings recognized by <small>ISO, MIME, IANA,</small> and
various other standardisation organisations are recognised;
for a more detailed list see Encode::Supported.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;read()&quot;
reads characters and returns the number of characters.
&quot;seek()&quot; and &quot;tell()&quot; operate on byte
counts, as does &quot;sysseek()&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;sysread()&quot;
and &quot;syswrite()&quot; should not be used on file
handles with character encoding layers, they behave badly,
and that behaviour has been deprecated since perl 5.24.</p>

<p style="margin-left:11%; margin-top: 1em">Notice that
because of the default behaviour of not doing any conversion
upon input if there is no default layer, it is easy to
mistakenly write code that keeps on expanding a file by
repeatedly encoding the data:</p>

<p style="margin-left:11%; margin-top: 1em"># BAD CODE
WARNING <br>
open F, &quot;file&quot;; <br>
local $/; ## read in the whole file of 8&minus;bit
characters <br>
$t = &lt;F&gt;; <br>
close F; <br>
open F, &quot;&gt;:encoding(UTF&minus;8)&quot;,
&quot;file&quot;; <br>
print F $t; ## convert to UTF&minus;8 on output <br>
close F;</p>

<p style="margin-left:11%; margin-top: 1em">If you run this
code twice, the contents of the <i>file</i> will be twice
<small>UTF&minus;8</small> encoded. A &quot;use open
':encoding(UTF&minus;8)'&quot; would have avoided the bug,
or explicitly opening also the <i>file</i> for input as
<small>UTF&minus;8.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small><b>NOTE</b></small>
: the &quot;:utf8&quot; and &quot;:encoding&quot; features
work only if your Perl has been built with PerlIO, which is
the default on most systems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Displaying
Unicode As Text</b> <br>
Sometimes you might want to display Perl scalars containing
Unicode as simple <small>ASCII</small> (or
<small>EBCDIC</small> ) text. The following subroutine
converts its argument so that Unicode characters with code
points greater than 255 are displayed as
&quot;\x{...}&quot;, control characters (like
&quot;\n&quot;) are displayed as &quot;\x..&quot;, and the
rest of the characters as themselves:</p>

<p style="margin-left:11%; margin-top: 1em">sub nice_string
{ <br>
join(&quot;&quot;, <br>
map { $_ &gt; 255 # if wide character... <br>
? sprintf(&quot;\\x{%04X}&quot;, $_) # \x{...} <br>
: chr($_) =~ /[[:cntrl:]]/ # else if control character...
<br>
? sprintf(&quot;\\x%02X&quot;, $_) # \x.. <br>
: quotemeta(chr($_)) # else quoted or as themselves <br>
} unpack(&quot;W*&quot;, $_[0])); # unpack Unicode
characters <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">For
example,</p>


<p style="margin-left:11%; margin-top: 1em">nice_string(&quot;foo\x{100}bar\n&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">returns the
string</p>


<p style="margin-left:11%; margin-top: 1em">'foo\x{0100}bar\x0A'</p>

<p style="margin-left:11%; margin-top: 1em">which is ready
to be printed.</p>


<p style="margin-left:11%; margin-top: 1em">(&quot;\\x{}&quot;
is used here instead of &quot;\\N{}&quot;, since it&rsquo;s
most likely that you want to see what the native values
are.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Special
Cases</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Starting in Perl 5.28, it is illegal for bit operators,
like &quot;~&quot;, to operate on strings containing code
points above 255.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <b>vec()</b> function may produce surprising results
if used on strings containing characters with ordinal values
above 255. In such a case, the results are consistent with
the internal encoding of the characters, but not with much
else. So don&rsquo;t do that, and starting in Perl 5.28, a
deprecation message is issued if you do so, becoming illegal
in Perl 5.32.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Peeking At Perl&rsquo;s Internal Encoding</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Normal users of
Perl should never care how Perl encodes any particular
Unicode string (because the normal ways to get at the
contents of a string with Unicode--via input and
output--should always be via explicitly-defined I/O layers).
But if you must, there are two ways of looking behind the
scenes.</p>

<p style="margin-left:17%; margin-top: 1em">One way of
peeking inside the internal encoding of Unicode characters
is to use &quot;unpack(&quot;C*&quot;, ...&quot; to get the
bytes of whatever the string encoding happens to be, or
&quot;unpack(&quot;U0..&quot;, ...)&quot; to get the bytes
of the <small>UTF&minus;8</small> encoding:</p>

<p style="margin-left:17%; margin-top: 1em"># this prints
c4 80 for the UTF&minus;8 bytes 0xc4 0x80 <br>
print join(&quot; &quot;, unpack(&quot;U0(H2)*&quot;,
pack(&quot;U&quot;, 0x100))), &quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Yet another way
would be to use the Devel::Peek module:</p>

<p style="margin-left:17%; margin-top: 1em">perl
&minus;MDevel::Peek &minus;e 'Dump(chr(0x100))'</p>

<p style="margin-left:17%; margin-top: 1em">That shows the
&quot;UTF8&quot; flag in <small>FLAGS</small> and both the
<small>UTF&minus;8</small> bytes and Unicode characters in
&quot;PV&quot;. See also later in this document the
discussion about the &quot;utf8::is_utf8()&quot;
function.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Advanced
Topics</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p style="margin-top: 1em">String Equivalence</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The question of
string equivalence turns somewhat complicated in Unicode:
what do you mean by &quot;equal&quot;?</p>

<p style="margin-left:17%; margin-top: 1em">(Is &quot;LATIN
CAPITAL LETTER A WITH ACUTE&quot; equal to &quot;LATIN
CAPITAL LETTER A&quot;?)</p>

<p style="margin-left:17%; margin-top: 1em">The short
answer is that by default Perl compares equivalence
(&quot;eq&quot;, &quot;ne&quot;) based only on code points
of the characters. In the above case, the answer is no
(because 0x00C1 != 0x0041). But sometimes, any
<small>CAPITAL LETTER A</small> &rsquo;s should be
considered equal, or even A&rsquo;s of any case.</p>

<p style="margin-left:17%; margin-top: 1em">The long answer
is that you need to consider character normalization and
casing issues: see Unicode::Normalize, Unicode Technical
Report #15, Unicode Normalization Forms
&lt;https://www.unicode.org/reports/tr15&gt; and sections on
case mapping in the Unicode Standard
&lt;https://www.unicode.org&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">As of Perl
5.8.0, the &quot;Full&quot; case-folding of <i>Case
Mappings/SpecialCasing</i> is implemented, but bugs remain
in &quot;qr//i&quot; with them, mostly fixed by 5.14, and
essentially entirely by 5.18.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="25%">


<p style="margin-top: 1em">String Collation</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">People like to
see their strings nicely sorted--or as Unicode parlance
goes, collated. But again, what do you mean by collate?</p>

<p style="margin-left:17%; margin-top: 1em">(Does
&quot;LATIN CAPITAL LETTER A WITH ACUTE&quot; come before or
after &quot;LATIN CAPITAL LETTER A WITH GRAVE&quot;?)</p>

<p style="margin-left:17%; margin-top: 1em">The short
answer is that by default, Perl compares strings
(&quot;lt&quot;, &quot;le&quot;, &quot;cmp&quot;,
&quot;ge&quot;, &quot;gt&quot;) based only on the code
points of the characters. In the above case, the answer is
&quot;after&quot;, since 0x00C1 &gt; 0x00C0.</p>

<p style="margin-left:17%; margin-top: 1em">The long answer
is that &quot;it depends&quot;, and a good answer cannot be
given without knowing (at the very least) the language
context. See Unicode::Collate, and <i>Unicode Collation
Algorithm</i>
&lt;https://www.unicode.org/reports/tr10/&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="43%">


<p style="margin-top: 1em">Character Ranges and Classes</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Character
ranges in regular expression bracketed character classes (
e.g., &quot;/[a&minus;z]/&quot;) and in the
&quot;tr///&quot; (also known as &quot;y///&quot;) operator
are not magically Unicode-aware. What this means is that
&quot;[A&minus;Za&minus;z]&quot; will not magically start to
mean &quot;all alphabetic letters&quot; (not that it does
mean that even for 8&minus;bit characters; for those, if you
are using locales (perllocale), use
&quot;/[[:alpha:]]/&quot;; and if not, use the
8&minus;bit&minus;aware property &quot;\p{alpha}&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">All the
properties that begin with &quot;\p&quot; (and its inverse
&quot;\P&quot;) are actually character classes that are
Unicode-aware. There are dozens of them, see
perluniprops.</p>

<p style="margin-left:17%; margin-top: 1em">Starting in
v5.22, you can use Unicode code points as the end points of
regular expression pattern character ranges, and the range
will include all Unicode code points that lie between those
end points, inclusive.</p>

<p style="margin-left:17%; margin-top: 1em">qr/ [ \N{U+03}
&minus; \N{U+20} ] /xx</p>

<p style="margin-left:17%; margin-top: 1em">includes the
code points &quot;\N{U+03}&quot;, &quot;\N{U+04}&quot;, ...,
&quot;\N{U+20}&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This also works
for ranges in &quot;tr///&quot; starting in Perl v5.24.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="43%">


<p style="margin-top: 1em">String-To-Number Conversions</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Unicode does
define several other decimal--and numeric--characters
besides the familiar 0 to 9, such as the Arabic and Indic
digits. Perl does not support string-to-number conversion
for digits other than <small>ASCII</small> 0 to 9 (and
<small>ASCII</small> &quot;a&quot; to &quot;f&quot; for
hexadecimal). To get safe conversions from any Unicode
string, use &quot;<b>num()</b>&quot; in Unicode::UCD.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Questions
With Answers</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em">Will My Old Scripts Break?</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Very probably
not. Unless you are generating Unicode characters somehow,
old behaviour should be preserved. About the only behaviour
that has changed and which could start generating Unicode is
the old behaviour of &quot;chr()&quot; where supplying an
argument more than 255 produced a character modulo 255.
&quot;chr(300)&quot;, for example, was equal to
&quot;chr(45)&quot; or &quot;&minus;&quot; (in
<small>ASCII</small> ), now it is <small>LATIN CAPITAL
LETTER I WITH BREVE.</small></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="66%">


<p style="margin-top: 1em">How Do I Make My Scripts Work
With Unicode?</p></td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Very little
work should be needed since nothing changes until you
generate Unicode data. The most important thing is getting
input as Unicode; for that, see the earlier I/O discussion.
To get full seamless Unicode support, add &quot;use feature
'unicode_strings'&quot; (or &quot;use v5.12&quot; or higher)
to your script.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="71%">


<p style="margin-top: 1em">How Do I Know Whether My String
Is In Unicode?</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">You
shouldn&rsquo;t have to care. But you may if your Perl is
before 5.14.0 or you haven&rsquo;t specified &quot;use
feature 'unicode_strings'&quot; or &quot;use 5.012&quot; (or
higher) because otherwise the rules for the code points in
the range 128 to 255 are different depending on whether the
string they are contained within is in Unicode or not. (See
&quot;When Unicode Does Not Happen&quot; in
perlunicode.)</p>

<p style="margin-left:17%; margin-top: 1em">To determine if
a string is in Unicode, use:</p>

<p style="margin-left:17%; margin-top: 1em">print
utf8::is_utf8($string) ? 1 : 0, &quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">But note that
this doesn&rsquo;t mean that any of the characters in the
string are necessary <small>UTF&minus;8</small> encoded, or
that any of the characters have code points greater than
0xFF (255) or even 0x80 (128), or that the string has any
characters at all. All the &quot;is_utf8()&quot; does is to
return the value of the internal &quot;utf8ness&quot; flag
attached to the $string. If the flag is off, the bytes in
the scalar are interpreted as a single byte encoding. If the
flag is on, the bytes in the scalar are interpreted as the
(variable-length, potentially multi-byte)
<small>UTF&minus;8</small> encoded code points of the
characters. Bytes added to a <small>UTF&minus;8</small>
encoded string are automatically upgraded to
<small>UTF&minus;8.</small> If mixed non&minus;UTF&minus;8
and <small>UTF&minus;8</small> scalars are merged
(double-quoted interpolation, explicit concatenation, or
printf/sprintf parameter substitution), the result will be
<small>UTF&minus;8</small> encoded as if copies of the byte
strings were upgraded to <small>UTF&minus;8:</small> for
example,</p>

<p style="margin-left:17%; margin-top: 1em">$a =
&quot;ab\x80c&quot;; <br>
$b = &quot;\x{100}&quot;; <br>
print &quot;$a = $b\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">the output
string will be UTF&minus;8&minus;encoded &quot;ab\x80c =
\x{100}\n&quot;, but $a will stay byte-encoded.</p>

<p style="margin-left:17%; margin-top: 1em">Sometimes you
might really need to know the byte length of a string
instead of the character length. For that use the
&quot;bytes&quot; pragma and the &quot;length()&quot;
function:</p>

<p style="margin-left:17%; margin-top: 1em">my $unicode =
chr(0x100); <br>
print length($unicode), &quot;\n&quot;; # will print 1 <br>
use bytes; <br>
print length($unicode), &quot;\n&quot;; # will print 2 <br>
# (the 0xC4 0x80 of the UTF&minus;8) <br>
no bytes;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="66%">


<p style="margin-top: 1em">How Do I Find Out What Encoding
a File Has?</p></td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">You might try
Encode::Guess, but it has a number of limitations.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">How Do I Detect Data
That&rsquo;s Not Valid In a Particular Encoding?</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Use the
&quot;Encode&quot; package to try converting it. For
example,</p>

<p style="margin-left:17%; margin-top: 1em">use Encode
'decode'; <br>
if (eval { decode('UTF&minus;8', $string, Encode::FB_CROAK);
1 }) { <br>
# $string is valid UTF&minus;8 <br>
} else { <br>
# $string is not valid UTF&minus;8 <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">Or use
&quot;unpack&quot; to try decoding it:</p>

<p style="margin-left:17%; margin-top: 1em">use warnings;
<br>
@chars = unpack(&quot;C0U*&quot;,
$string_of_bytes_that_I_think_is_utf8);</p>

<p style="margin-left:17%; margin-top: 1em">If invalid, a
&quot;Malformed UTF&minus;8 character&quot; warning is
produced. The &quot;C0&quot; means &quot;process the string
character per character&quot;. Without that, the
&quot;unpack(&quot;U*&quot;, ...)&quot; would work in
&quot;U0&quot; mode (the default if the format string starts
with &quot;U&quot;) and it would return the bytes making up
the <small>UTF&minus;8</small> encoding of the target
string, something that will always work.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">How Do I Convert Binary Data
Into a Particular Encoding, Or Vice Versa?</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This probably
isn&rsquo;t as useful as you might think. Normally, you
shouldn&rsquo;t need to.</p>

<p style="margin-left:17%; margin-top: 1em">In one sense,
what you are asking doesn&rsquo;t make much sense: encodings
are for characters, and binary data are not
&quot;characters&quot;, so converting &quot;data&quot; into
some encoding isn&rsquo;t meaningful unless you know in what
character set and encoding the binary data is in, in which
case it&rsquo;s not just binary data, now is it?</p>

<p style="margin-left:17%; margin-top: 1em">If you have a
raw sequence of bytes that you know should be interpreted
via a particular encoding, you can use
&quot;Encode&quot;:</p>

<p style="margin-left:17%; margin-top: 1em">use Encode
'from_to'; <br>
from_to($data, &quot;iso&minus;8859&minus;1&quot;,
&quot;UTF&minus;8&quot;); # from latin&minus;1 to
UTF&minus;8</p>

<p style="margin-left:17%; margin-top: 1em">The call to
&quot;from_to()&quot; changes the bytes in $data, but
nothing material about the nature of the string has changed
as far as Perl is concerned. Both before and after the call,
the string $data contains just a bunch of 8&minus;bit bytes.
As far as Perl is concerned, the encoding of the string
remains as &quot;system-native 8&minus;bit bytes&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">You might
relate this to a fictional &rsquo;Translate&rsquo;
module:</p>

<p style="margin-left:17%; margin-top: 1em">use Translate;
<br>
my $phrase = &quot;Yes&quot;; <br>
Translate::from_to($phrase, 'english', 'deutsch'); <br>
## phrase now contains &quot;Ja&quot;</p>

<p style="margin-left:17%; margin-top: 1em">The contents of
the string changes, but not the nature of the string. Perl
doesn&rsquo;t know any more after the call than before that
the contents of the string indicates the affirmative.</p>

<p style="margin-left:17%; margin-top: 1em">Back to
converting data. If you have (or want) data in your
system&rsquo;s native 8&minus;bit encoding (e.g.
Latin&minus;1, <small>EBCDIC,</small> etc.), you can use
pack/unpack to convert to/from Unicode.</p>

<p style="margin-left:17%; margin-top: 1em">$native_string
= pack(&quot;W*&quot;, unpack(&quot;U*&quot;,
$Unicode_string)); <br>
$Unicode_string = pack(&quot;U*&quot;,
unpack(&quot;W*&quot;, $native_string));</p>

<p style="margin-left:17%; margin-top: 1em">If you have a
sequence of bytes you <b>know</b> is valid
<small>UTF&minus;8,</small> but Perl doesn&rsquo;t know it
yet, you can make Perl a believer, too:</p>

<p style="margin-left:17%; margin-top: 1em">$Unicode =
$bytes; <br>
utf8::decode($Unicode);</p>

<p style="margin-left:17%; margin-top: 1em">or:</p>

<p style="margin-left:17%; margin-top: 1em">$Unicode =
pack(&quot;U0a*&quot;, $bytes);</p>

<p style="margin-left:17%; margin-top: 1em">You can find
the bytes that make up a <small>UTF&minus;8</small> sequence
with</p>

<p style="margin-left:17%; margin-top: 1em">@bytes =
unpack(&quot;C*&quot;, $Unicode_string)</p>

<p style="margin-left:17%; margin-top: 1em">and you can
create well-formed Unicode with</p>


<p style="margin-left:17%; margin-top: 1em">$Unicode_string
= pack(&quot;U*&quot;, 0xff, ...)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">How Do I Display Unicode? How Do
I Input Unicode?</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">See
&lt;http://www.alanwood.net/unicode/&gt; and
&lt;http://www.cl.cam.ac.uk/~mgk25/unicode.html&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="72%">


<p style="margin-top: 1em">How Does Unicode Work With
Traditional Locales?</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If your locale
is a <small>UTF&minus;8</small> locale, starting in Perl
v5.26, Perl works well for all categories; before this,
starting with Perl v5.20, it works for all categories but
&quot;LC_COLLATE&quot;, which deals with sorting and the
&quot;cmp&quot; operator. But note that the standard
&quot;Unicode::Collate&quot; and
&quot;Unicode::Collate::Locale&quot; modules offer much more
powerful solutions to collation issues, and work on earlier
releases.</p>

<p style="margin-left:17%; margin-top: 1em">For other
locales, starting in Perl 5.16, you can specify</p>

<p style="margin-left:17%; margin-top: 1em">use locale
':not_characters';</p>

<p style="margin-left:17%; margin-top: 1em">to get Perl to
work well with them. The catch is that you have to translate
from the locale character set to/from Unicode yourself. See
&quot;Unicode I/O&quot; above for how to</p>

<p style="margin-left:17%; margin-top: 1em">use open
':locale';</p>

<p style="margin-left:17%; margin-top: 1em">to accomplish
this, but full details are in &quot;Unicode and
<small>UTF&minus;8&quot;</small> in perllocale, including
gotchas that happen if you don&rsquo;t specify
&quot;:not_characters&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Hexadecimal
Notation</b> <br>
The Unicode standard prefers using hexadecimal notation
because that more clearly shows the division of Unicode into
blocks of 256 characters. Hexadecimal is also simply shorter
than decimal. You can use decimal notation, too, but
learning to use hexadecimal just makes life easier with the
Unicode standard. The &quot;U+HHHH&quot; notation uses
hexadecimal, for example.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;0x&quot; prefix means a hexadecimal number, the digits
are 0&minus;9 <i>and</i> a&minus;f (or A&minus;F, case
doesn&rsquo;t matter). Each hexadecimal digit represents
four bits, or half a byte. &quot;print 0x...,
&quot;\n&quot;&quot; will show a hexadecimal number in
decimal, and &quot;printf &quot;%x\n&quot;, $decimal&quot;
will show a decimal number in hexadecimal. If you have just
the &quot;hex digits&quot; of a hexadecimal number, you can
use the &quot;hex()&quot; function.</p>

<p style="margin-left:11%; margin-top: 1em">print 0x0009,
&quot;\n&quot;; # 9 <br>
print 0x000a, &quot;\n&quot;; # 10 <br>
print 0x000f, &quot;\n&quot;; # 15 <br>
print 0x0010, &quot;\n&quot;; # 16 <br>
print 0x0011, &quot;\n&quot;; # 17 <br>
print 0x0100, &quot;\n&quot;; # 256 <br>
print 0x0041, &quot;\n&quot;; # 65 <br>
printf &quot;%x\n&quot;, 65; # 41 <br>
printf &quot;%#x\n&quot;, 65; # 0x41 <br>
print hex(&quot;41&quot;), &quot;\n&quot;; # 65</p>

<p style="margin-left:11%; margin-top: 1em"><b>Further
Resources</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p style="margin-top: 1em">Unicode Consortium</p></td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;https://www.unicode.org/&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">


<p style="margin-top: 1em">Unicode <small>FAQ</small></p></td>
<td width="66%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;https://www.unicode.org/faq/&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="25%">


<p style="margin-top: 1em">Unicode Glossary</p></td>
<td width="58%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;https://www.unicode.org/glossary/&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p style="margin-top: 1em">Unicode Recommended Reading
List</p> </td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The Unicode
Consortium has a list of articles and books, some of which
give a much more in depth treatment of Unicode:
&lt;http://unicode.org/resources/readinglist.html&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="37%">


<p style="margin-top: 1em">Unicode Useful Resources</p></td>
<td width="46%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;https://www.unicode.org/unicode/onlinedat/resources.html&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Unicode and Multilingual Support
in <small>HTML,</small> Fonts, Web Browsers and Other
Applications</p> </td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;http://www.alanwood.net/unicode/&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="55%">


<p style="margin-top: 1em"><small>UTF&minus;8</small> and
Unicode <small>FAQ</small> for Unix/Linux</p></td>
<td width="28%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;http://www.cl.cam.ac.uk/~mgk25/unicode.html&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="32%">


<p style="margin-top: 1em">Legacy Character Sets</p></td>
<td width="51%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;http://www.czyborra.com/&gt;
&lt;http://www.eki.ee/letter/&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">You can explore various
information from the Unicode data files using the
&quot;Unicode::UCD&quot; module.</p></td></tr>
</table>

<h2>UNICODE IN OLDER PERLS
<a name="UNICODE IN OLDER PERLS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you cannot
upgrade your Perl to 5.8.0 or later, you can still do some
Unicode processing by using the modules
&quot;Unicode::String&quot;, &quot;Unicode::Map8&quot;, and
&quot;Unicode::Map&quot;, available from
<small>CPAN.</small> If you have the <small>GNU</small>
recode installed, you can also use the Perl front-end
&quot;Convert::Recode&quot; for character conversions.</p>

<p style="margin-left:11%; margin-top: 1em">The following
are fast conversions from <small>ISO 8859&minus;1</small>
(Latin&minus;1) bytes to <small>UTF&minus;8</small> bytes
and back, the code works even with older Perl 5
versions.</p>

<p style="margin-left:11%; margin-top: 1em"># ISO
8859&minus;1 to UTF&minus;8 <br>

s/([\x80&minus;\xFF])/chr(0xC0|ord($1)&gt;&gt;6).chr(0x80|ord($1)&amp;0x3F)/eg;
<br>
# UTF&minus;8 to ISO 8859&minus;1 <br>

s/([\xC2\xC3])([\x80&minus;\xBF])/chr(ord($1)&lt;&lt;6&amp;0xC0|ord($2)&amp;0x3F)/eg;</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlunitut,
perlunicode, Encode, open, utf8, bytes, perlretut, perlrun,
Unicode::Collate, Unicode::Normalize, Unicode::UCD</p>

<h2>ACKNOWLEDGMENTS
<a name="ACKNOWLEDGMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Thanks to the
kind readers of the perl5&minus;porters@perl.org,
perl&minus;unicode@perl.org, linux&minus;utf8@nl.linux.org,
and unicore@unicode.org mailing lists for their valuable
feedback.</p>

<h2>AUTHOR, COPYRIGHT, AND LICENSE
<a name="AUTHOR, COPYRIGHT, AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2001&minus;2011 Jarkko Hietaniemi &lt;jhi@iki.fi&gt;. Now
maintained by Perl 5 Porters.</p>

<p style="margin-left:11%; margin-top: 1em">This document
may be distributed under the same terms as Perl itself.</p>
<hr>
</body>
</html>
