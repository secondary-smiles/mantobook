<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLREBACKSLASH</title>

</head>
<body>
<h1>perlrebackslash</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">perlrebackslash
&minus; Perl Regular Expression Backslash Sequences and
Escapes</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The top level
documentation about Perl regular expressions is found in
perlre.</p>

<p style="margin-left:11%; margin-top: 1em">This document
describes all backslash and escape sequences. After
explaining the role of the backslash, it lists all the
sequences that have a special meaning in Perl regular
expressions (in alphabetical order), then describes each of
them.</p>

<p style="margin-left:11%; margin-top: 1em">Most sequences
are described in detail in different documents; the primary
purpose of this document is to have a quick reference guide
describing all backslash and escape sequences.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
backslash</b> <br>
In a regular expression, the backslash can perform one of
two tasks: it either takes away the special meaning of the
character following it (for instance, &quot;\|&quot; matches
a vertical bar, it&rsquo;s not an alternation), or it is the
start of a backslash or escape sequence.</p>

<p style="margin-left:11%; margin-top: 1em">The rules
determining what it is are quite simple: if the character
following the backslash is an <small>ASCII</small>
punctuation (non-word) character (that is, anything that is
not a letter, digit, or underscore), then the backslash just
takes away any special meaning of the character following
it.</p>

<p style="margin-left:11%; margin-top: 1em">If the
character following the backslash is an <small>ASCII</small>
letter or an <small>ASCII</small> digit, then the sequence
may be special; if so, it&rsquo;s listed below. A few
letters have not been used yet, so escaping them with a
backslash doesn&rsquo;t change them to be special. A future
version of Perl may assign a special meaning to them, so if
you have warnings turned on, Perl issues a warning if you
use such a sequence. [1].</p>

<p style="margin-left:11%; margin-top: 1em">It is however
guaranteed that backslash or escape sequences never have a
punctuation character following the backslash, not now, and
not in a future version of Perl 5. So it is safe to put a
backslash in front of a non-word character.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
backslash itself is special; if you want to match a
backslash, you have to escape the backslash with a
backslash: &quot;/\\/&quot; matches a single backslash.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p>There is one exception. If you use an alphanumeric
character as the delimiter of your pattern (which you
probably shouldn&rsquo;t do for readability reasons), you
have to escape the delimiter if you want to match it. Perl
won&rsquo;t warn then. See also &quot;Gory details of
parsing quoted constructs&quot; in perlop.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>All the
sequences and escapes</b> <br>
Those not usable within a bracketed character class (like
&quot;[\da&minus;z]&quot;) are marked as &quot;Not in
[].&quot;</p>

<p style="margin-left:11%; margin-top: 1em">\000 Octal
escape sequence. See also \o{}. <br>
\1 Absolute backreference. Not in []. <br>
\a Alarm or bell. <br>
\A Beginning of string. Not in []. <br>
\b{}, \b Boundary. (\b is a backspace in []). <br>
\B{}, \B Not a boundary. Not in []. <br>
\cX Control&minus;X. <br>
\d Match any digit character. <br>
\D Match any character that isn't a digit. <br>
\e Escape character. <br>
\E Turn off \Q, \L and \U processing. Not in []. <br>
\f Form feed. <br>
\F Foldcase till \E. Not in []. <br>
\g{}, \g1 Named, absolute or relative backreference. <br>
Not in []. <br>
\G Pos assertion. Not in []. <br>
\h Match any horizontal whitespace character. <br>
\H Match any character that isn't horizontal whitespace.
<br>
\k{}, \k&lt;&gt;, \k'' Named backreference. Not in []. <br>
\K Keep the stuff left of \K. Not in []. <br>
\l Lowercase next character. Not in []. <br>
\L Lowercase till \E. Not in []. <br>
\n (Logical) newline character. <br>
\N Match any character but newline. Not in []. <br>
\N{} Named or numbered (Unicode) character or sequence. <br>
\o{} Octal escape sequence. <br>
\p{}, \pP Match any character with the given Unicode
property. <br>
\P{}, \PP Match any character without the given property.
<br>
\Q Quote (disable) pattern metacharacters till \E. Not <br>
in []. <br>
\r Return character. <br>
\R Generic new line. Not in []. <br>
\s Match any whitespace character. <br>
\S Match any character that isn't a whitespace. <br>
\t Tab character. <br>
\u Titlecase next character. Not in []. <br>
\U Uppercase till \E. Not in []. <br>
\v Match any vertical whitespace character. <br>
\V Match any character that isn't vertical whitespace <br>
\w Match any word character. <br>
\W Match any character that isn't a word character. <br>
\x{}, \x00 Hexadecimal escape sequence. <br>
\X Unicode &quot;extended grapheme cluster&quot;. Not in [].
<br>
\z End of string. Not in []. <br>
\Z End of string. Not in [].</p>

<p style="margin-left:11%; margin-top: 1em"><b>Character
Escapes</b> <i><br>
Fixed characters</i></p>

<p style="margin-left:11%; margin-top: 1em">A handful of
characters have a dedicated <i>character escape</i>. The
following table shows them, along with their
<small>ASCII</small> code points (in decimal and hex), their
<small>ASCII</small> name, the control escape on
<small>ASCII</small> platforms and a short description. (For
<small>EBCDIC</small> platforms, see &quot; <small>OPERATOR
DIFFERENCES&quot;</small> in perlebcdic.)</p>

<p style="margin-left:11%; margin-top: 1em">Seq. Code Point
ASCII Cntrl Description. <br>
Dec Hex <br>
\a 7 07 BEL \cG alarm or bell <br>
\b 8 08 BS \cH backspace [1] <br>
\e 27 1B ESC \c[ escape character <br>
\f 12 0C FF \cL form feed <br>
\n 10 0A LF \cJ line feed [2] <br>
\r 13 0D CR \cM carriage return <br>
\t 9 09 TAB \cI tab</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">&quot;\b&quot; is the backspace
character only inside a character class. Outside a character
class, &quot;\b&quot; alone is a
word&minus;character/non&minus;word&minus;character
boundary, and &quot;\b{}&quot; is some other type of
boundary.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;\n&quot; matches a logical newline. Perl converts
between &quot;\n&quot; and your <small>OS</small> &rsquo;s
native newline character when reading from or writing to
text files.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Example</p>

<p style="margin-left:11%; margin-top: 1em">$str =~ /\t/; #
Matches if $str contains a (horizontal) tab.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Control
characters</i></p>

<p style="margin-left:11%; margin-top: 1em">&quot;\c&quot;
is used to denote a control character; the character
following &quot;\c&quot; determines the value of the
construct. For example the value of &quot;\cA&quot; is
chr(1), and the value of &quot;\cb&quot; is chr(2), etc. The
gory details are in &quot;Regexp Quote-Like Operators&quot;
in perlop. A complete list of what chr(1), etc. means for
<small>ASCII</small> and <small>EBCDIC</small> platforms is
in &quot; <small>OPERATOR DIFFERENCES&quot;</small> in
perlebcdic.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;\c\&quot; alone at the end of a regular expression (or
doubled-quoted string) is not valid. The backslash must be
followed by another character. That is,
&quot;\c\<i>X</i>&quot; means &quot;chr(28) .
'<i>X</i>'&quot; for all characters <i>X</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To write
platform-independent code, you must use
&quot;\N{<i>NAME</i>}&quot; instead, like
&quot;\N{ESCAPE}&quot; or &quot;\N{U+001B}&quot;, see
charnames.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>c</i>ontrol character.</p>

<p style="margin-left:11%; margin-top: 1em">Example</p>

<p style="margin-left:11%; margin-top: 1em">$str =~ /\cK/;
# Matches if $str contains a vertical tab
(control&minus;K).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Named or
numbered characters and character sequences</i></p>

<p style="margin-left:11%; margin-top: 1em">Unicode
characters have a Unicode name and numeric code point
(ordinal) value. Use the &quot;\N{}&quot; construct to
specify a character by either of these values. Certain
sequences of characters also have names.</p>

<p style="margin-left:11%; margin-top: 1em">To specify by
name, the name of the character or character sequence goes
between the curly braces.</p>

<p style="margin-left:11%; margin-top: 1em">To specify a
character by Unicode code point, use the form
&quot;\N{U+<i>code point</i>}&quot;, where <i>code point</i>
is a number in hexadecimal that gives the code point that
Unicode has assigned to the desired character. It is
customary but not required to use leading zeros to pad the
number to 4 digits. Thus &quot;\N{U+0041}&quot; means
&quot;LATIN CAPITAL LETTER A&quot;, and you will rarely see
it written without the two leading zeros.
&quot;\N{U+0041}&quot; means &quot;A&quot; even on
<small>EBCDIC</small> machines (where the ordinal value of
&quot;A&quot; is not 0x41).</p>

<p style="margin-left:11%; margin-top: 1em">Blanks may
freely be inserted adjacent to but within the braces
enclosing the name or code point. So
&quot;\N{&nbsp;U+0041&nbsp;}&quot; is perfectly legal.</p>

<p style="margin-left:11%; margin-top: 1em">It is even
possible to give your own names to characters and character
sequences by using the charnames module. These custom names
are lexically scoped, and so a given code point may have
different names in different scopes. The name used is what
is in effect at the time the &quot;\N{}&quot; is expanded.
For patterns in double-quotish context, that means at the
time the pattern is parsed. But for patterns that are
delimitted by single quotes, the expansion is deferred until
pattern compilation time, which may very well have a
different &quot;charnames&quot; translator in effect.</p>

<p style="margin-left:11%; margin-top: 1em">(There is an
expanded internal form that you may see in debug output:
&quot;\N{U+<i>code point</i>.<i>code point</i>...}&quot;.
The &quot;...&quot; means any number of these <i>code
point</i>s separated by dots. This represents the sequence
formed by the characters. This is an internal form only,
subject to change, and you should not try to use it
yourself.)</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>N</i>amed character.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
character or character sequence expressed as a named or
numbered character is considered a character without special
meaning by the regex engine, and will match &quot;as
is&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Example</p>

<p style="margin-left:11%; margin-top: 1em">$str =~
/\N{THAI CHARACTER SO SO}/; # Matches the Thai SO SO
character <br>
use charnames 'Cyrillic'; # Loads Cyrillic names. <br>
$str =~ /\N{ZHE}\N{KA}/; # Match &quot;ZHE&quot; followed by
&quot;KA&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Octal
escapes</i></p>

<p style="margin-left:11%; margin-top: 1em">There are two
forms of octal escapes. Each is used to specify a character
by its code point specified in base 8.</p>

<p style="margin-left:11%; margin-top: 1em">One form,
available starting in Perl 5.14 looks like
&quot;\o{...}&quot;, where the dots represent one or more
octal digits. It can be used for any Unicode character.</p>

<p style="margin-left:11%; margin-top: 1em">It was
introduced to avoid the potential problems with the other
form, available in all Perls. That form consists of a
backslash followed by three octal digits. One problem with
this form is that it can look exactly like an old-style
backreference (see &quot;Disambiguation rules between
old-style octal escapes and backreferences&quot; below.) You
can avoid this by making the first of the three digits
always a zero, but that makes \077 the largest code point
specifiable.</p>

<p style="margin-left:11%; margin-top: 1em">In some
contexts, a backslash followed by two or even one octal
digits may be interpreted as an octal escape, sometimes with
a warning, and because of some bugs, sometimes with
surprising results. Also, if you are creating a regex out of
smaller snippets concatenated together, and you use fewer
than three digits, the beginning of one snippet may be
interpreted as adding digits to the ending of the snippet
before it. See &quot;Absolute referencing&quot; for more
discussion and examples of the snippet problem.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
character expressed as an octal escape is considered a
character without special meaning by the regex engine, and
will match &quot;as is&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To summarize,
the &quot;\o{}&quot; form is always safe to use, and the
other form is safe to use for code points through \077 when
you use exactly three digits to specify them.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>0</i>ctal or <i>o</i>ctal.</p>

<p style="margin-left:11%; margin-top: 1em">Examples
(assuming an <small>ASCII</small> platform)</p>

<p style="margin-left:11%; margin-top: 1em">$str =
&quot;Perl&quot;; <br>
$str =~ /\o{120}/; # Match, &quot;\120&quot; is
&quot;P&quot;. <br>
$str =~ /\120/; # Same. <br>
$str =~ /\o{120}+/; # Match, &quot;\120&quot; is
&quot;P&quot;, <br>
# it's repeated at least once. <br>
$str =~ /\120+/; # Same. <br>
$str =~ /P\053/; # No match, &quot;\053&quot; is
&quot;+&quot; and taken literally. <br>
/\o{23073}/ # Black foreground, white background smiling
face. <br>
/\o{4801234567}/ # Raises a warning, and yields chr(4). <br>
/\o{ 400}/ # LATIN CAPITAL LETTER A WITH MACRON <br>
/\o{ 400 }/ # Same. These show blanks are allowed adjacent
to <br>
# the braces</p>

<p style="margin-left:11%; margin-top: 1em">Disambiguation
rules between old-style octal escapes and backreferences</p>

<p style="margin-left:11%; margin-top: 1em">Octal escapes
of the &quot;\000&quot; form outside of bracketed character
classes potentially clash with old-style backreferences (see
&quot;Absolute referencing&quot; below). They both consist
of a backslash followed by numbers. So Perl has to use
heuristics to determine whether it is a backreference or an
octal escape. Perl uses the following rules to
disambiguate:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If the backslash is followed by
a single digit, it&rsquo;s a backreference.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the first digit following the backslash is a 0,
it&rsquo;s an octal escape.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the number following the backslash is N (in decimal),
and Perl already has seen N capture groups, Perl considers
this a backreference. Otherwise, it considers it an octal
escape. If N has more than three digits, Perl takes only the
first three for the octal escape; the rest are matched as
is.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">my $pat =
&quot;(&quot; x 999; <br>
$pat .= &quot;a&quot;; <br>
$pat .= &quot;)&quot; x 999; <br>
/^($pat)\1000$/; # Matches 'aa'; there are 1000 capture
groups. <br>
/^$pat\1000$/; # Matches 'a@0'; there are 999 capture groups
<br>
# and \1000 is seen as \100 (a '@') and a '0'.</p>

<p style="margin-left:11%; margin-top: 1em">You can force a
backreference interpretation always by using the
&quot;\g{...}&quot; form. You can the force an octal
interpretation always by using the &quot;\o{...}&quot; form,
or for numbers up through \077 (= 63 decimal), by using
three digits, beginning with a &quot;0&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Hexadecimal
escapes</i></p>

<p style="margin-left:11%; margin-top: 1em">Like octal
escapes, there are two forms of hexadecimal escapes, but
both start with the sequence &quot;\x&quot;. This is
followed by either exactly two hexadecimal digits forming a
number, or a hexadecimal number of arbitrary length
surrounded by curly braces. The hexadecimal number is the
code point of the character you want to express.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
character expressed as one of these escapes is considered a
character without special meaning by the regex engine, and
will match &quot;as is&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
he<i>x</i>adecimal.</p>

<p style="margin-left:11%; margin-top: 1em">Examples
(assuming an <small>ASCII</small> platform)</p>

<p style="margin-left:11%; margin-top: 1em">$str =
&quot;Perl&quot;; <br>
$str =~ /\x50/; # Match, &quot;\x50&quot; is &quot;P&quot;.
<br>
$str =~ /\x50+/; # Match, &quot;\x50&quot; is &quot;P&quot;,
it is repeated at least once <br>
$str =~ /P\x2B/; # No match, &quot;\x2B&quot; is
&quot;+&quot; and taken literally. <br>
/\x{2603}\x{2602}/ # Snowman with an umbrella. <br>
# The Unicode character 2603 is a snowman, <br>
# the Unicode character 2602 is an umbrella. <br>
/\x{263B}/ # Black smiling face. <br>
/\x{263b}/ # Same, the hex digits A &minus; F are case
insensitive. <br>
/\x{ 263b }/ # Same, showing optional blanks adjacent to the
<br>
# braces</p>


<p style="margin-left:11%; margin-top: 1em"><b>Modifiers</b>
<br>
A number of backslash sequences have to do with changing the
character, or characters following them. &quot;\l&quot; will
lowercase the character following it, while &quot;\u&quot;
will uppercase (or, more accurately, titlecase) the
character following it. They provide functionality similar
to the functions &quot;lcfirst&quot; and
&quot;ucfirst&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To uppercase or
lowercase several characters, one might want to use
&quot;\L&quot; or &quot;\U&quot;, which will
lowercase/uppercase all characters following them, until
either the end of the pattern or the next occurrence of
&quot;\E&quot;, whichever comes first. They provide
functionality similar to what the functions &quot;lc&quot;
and &quot;uc&quot; provide.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;\Q&quot;
is used to quote (disable) pattern metacharacters, up to the
next &quot;\E&quot; or the end of the pattern.
&quot;\Q&quot; adds a backslash to any character that could
have special meaning to Perl. In the <small>ASCII</small>
range, it quotes every character that isn&rsquo;t a letter,
digit, or underscore. See &quot;quotemeta&quot; in perlfunc
for details on what gets quoted for non-ASCII code points.
Using this ensures that any character between &quot;\Q&quot;
and &quot;\E&quot; will be matched literally, not
interpreted as a metacharacter by the regex engine.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;\F&quot;
can be used to casefold all characters following, up to the
next &quot;\E&quot; or the end of the pattern. It provides
the functionality similar to the &quot;fc&quot;
function.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>L</i>owercase, <i>U</i>ppercase, <i>F</i>old-case,
<i>Q</i>uotemeta, <i>E</i>nd.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<p style="margin-left:11%; margin-top: 1em">$sid =
&quot;sid&quot;; <br>
$greg = &quot;GrEg&quot;; <br>
$miranda = &quot;(Miranda)&quot;; <br>
$str =~ /\u$sid/; # Matches 'Sid' <br>
$str =~ /\L$greg/; # Matches 'greg' <br>
$str =~ /\Q$miranda\E/; # Matches '(Miranda)', as if the
pattern <br>
# had been written as /\(Miranda\)/</p>

<p style="margin-left:11%; margin-top: 1em"><b>Character
classes</b> <br>
Perl regular expressions have a large range of character
classes. Some of the character classes are written as a
backslash sequence. We will briefly discuss those here; full
details of character classes can be found in
perlrecharclass.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;\w&quot;
is a character class that matches any single <i>word</i>
character (letters, digits, Unicode marks, and connector
punctuation (like the underscore)). &quot;\d&quot; is a
character class that matches any decimal digit, while the
character class &quot;\s&quot; matches any whitespace
character. New in perl 5.10.0 are the classes &quot;\h&quot;
and &quot;\v&quot; which match horizontal and vertical
whitespace characters.</p>

<p style="margin-left:11%; margin-top: 1em">The exact set
of characters matched by &quot;\d&quot;, &quot;\s&quot;, and
&quot;\w&quot; varies depending on various pragma and
regular expression modifiers. It is possible to restrict the
match to the <small>ASCII</small> range by using the
&quot;/a&quot; regular expression modifier. See
perlrecharclass.</p>

<p style="margin-left:11%; margin-top: 1em">The uppercase
variants (&quot;\W&quot;, &quot;\D&quot;, &quot;\S&quot;,
&quot;\H&quot;, and &quot;\V&quot;) are character classes
that match, respectively, any character that isn&rsquo;t a
word character, digit, whitespace, horizontal whitespace, or
vertical whitespace.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonics:
<i>w</i>ord, <i>d</i>igit, <i>s</i>pace, <i>h</i>orizontal,
<i>v</i>ertical.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Unicode
classes</i></p>


<p style="margin-left:11%; margin-top: 1em">&quot;\pP&quot;
(where &quot;P&quot; is a single letter) and
&quot;\p{Property}&quot; are used to match a character that
matches the given Unicode property; properties include
things like &quot;letter&quot;, or &quot;thai
character&quot;. Capitalizing the sequence to
&quot;\PP&quot; and &quot;\P{Property}&quot; make the
sequence match a character that doesn&rsquo;t match the
given Unicode property. For more details, see
&quot;Backslash sequences&quot; in perlrecharclass and
&quot;Unicode Character Properties&quot; in perlunicode.</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>p</i>roperty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Referencing</b>
<br>
If capturing parenthesis are used in a regular expression,
we can refer to the part of the source string that was
matched, and match exactly the same thing. There are three
ways of referring to such <i>backreference</i>: absolutely,
relatively, and by name.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Absolute
referencing</i></p>

<p style="margin-left:11%; margin-top: 1em">Either
&quot;\g<i>N</i>&quot; (starting in Perl 5.10.0), or
&quot;\<i>N</i>&quot; (old-style) where <i>N</i> is a
positive (unsigned) decimal number of any length is an
absolute reference to a capturing group.</p>

<p style="margin-left:11%; margin-top: 1em"><i>N</i> refers
to the Nth set of parentheses, so &quot;\g<i>N</i>&quot;
refers to whatever has been matched by that set of
parentheses. Thus &quot;\g1&quot; refers to the first
capture group in the regex.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;\g<i>N</i>&quot; form can be equivalently written as
&quot;\g{<i>N</i>}&quot; which avoids ambiguity when
building a regex by concatenating shorter strings. Otherwise
if you had a regex &quot;qr/$a$b/&quot;, and $a contained
&quot;\g1&quot;, and $b contained &quot;37&quot;, you would
get &quot;/\g137/&quot; which is probably not what you
intended.</p>

<p style="margin-left:11%; margin-top: 1em">In the
&quot;\<i>N</i>&quot; form, <i>N</i> must not begin with a
&quot;0&quot;, and there must be at least <i>N</i> capturing
groups, or else <i>N</i> is considered an octal escape (but
something like &quot;\18&quot; is the same as
&quot;\0018&quot;; that is, the octal escape
&quot;\001&quot; followed by a literal digit
&quot;8&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Mnemonic:
<i>g</i>roup.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<p style="margin-left:11%; margin-top: 1em">/(\w+) \g1/; #
Finds a duplicated word, (e.g. &quot;cat cat&quot;). <br>
/(\w+) \1/; # Same thing; written old&minus;style. <br>
/(\w+) \g{1}/; # Same, using the safer braced notation <br>
/(\w+) \g{ 1 }/;# Same, showing optional blanks adjacent to
the braces <br>
/(.)(.)\g2\g1/; # Match a four letter palindrome (e.g.
&quot;ABBA&quot;).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Relative
referencing</i></p>


<p style="margin-left:11%; margin-top: 1em">&quot;\g&minus;<i>N</i>&quot;
(starting in Perl 5.10.0) is used for relative addressing.
(It can be written as &quot;\g{&minus;<i>N</i>}&quot;.) It
refers to the <i>N</i>th group before the
&quot;\g{&minus;<i>N</i>}&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The big
advantage of this form is that it makes it much easier to
write patterns with references that can be interpolated in
larger patterns, even if the larger pattern also contains
capture groups.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<p style="margin-left:11%; margin-top: 1em">/(A) # Group 1
<br>
( # Group 2 <br>
(B) # Group 3 <br>
\g{&minus;1} # Refers to group 3 (B) <br>
\g{&minus;3} # Refers to group 1 (A) <br>
\g{ &minus;3 } # Same, showing optional blanks adjacent to
the braces <br>
) <br>
/x; # Matches &quot;ABBA&quot;. <br>
my $qr = qr /(.)(.)\g{&minus;2}\g{&minus;1}/; # Matches
'abab', 'cdcd', etc. <br>
/$qr$qr/ # Matches 'ababcdcd'.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Named
referencing</i></p>


<p style="margin-left:11%; margin-top: 1em">&quot;\g{<i>name</i>}&quot;
(starting in Perl 5.10.0) can be used to back refer to a
named capture group, dispensing completely with having to
think about capture buffer positions.</p>

<p style="margin-left:11%; margin-top: 1em">To be
compatible with .Net regular expressions,
&quot;\g{name}&quot; may also be written as
&quot;\k{name}&quot;, &quot;\k&lt;name&gt;&quot; or
&quot;\k'name'&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To prevent any
ambiguity, <i>name</i> must not start with a digit nor
contain a hyphen.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>


<p style="margin-left:11%; margin-top: 1em">/(?&lt;word&gt;\w+)
\g{word}/ # Finds duplicated word, (e.g. &quot;cat
cat&quot;) <br>
/(?&lt;word&gt;\w+) \k{word}/ # Same. <br>
/(?&lt;word&gt;\w+) \g{ word }/ # Same, showing optional
blanks adjacent to <br>
# the braces <br>
/(?&lt;word&gt;\w+) \k{ word }/ # Same. <br>
/(?&lt;word&gt;\w+) \k&lt;word&gt;/ # Same. There are no
braces, so no blanks <br>
# are permitted <br>

/(?&lt;letter1&gt;.)(?&lt;letter2&gt;.)\g{letter2}\g{letter1}/
<br>
# Match a four letter palindrome (e.g. <br>
# &quot;ABBA&quot;)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Assertions</b>
<br>
Assertions are conditions that have to be true; they
don&rsquo;t actually match parts of the substring. There are
six assertions that are written as backslash sequences.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\A</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">&quot;\A&quot; only matches at
the beginning of the string. If the &quot;/m&quot; modifier
isn&rsquo;t used, then &quot;/\A/&quot; is equivalent to
&quot;/^/&quot;. However, if the &quot;/m&quot; modifier is
used, then &quot;/^/&quot; matches internal newlines, but
the meaning of &quot;/\A/&quot; isn&rsquo;t changed by the
&quot;/m&quot; modifier. &quot;\A&quot; matches at the
beginning of the string regardless whether the
&quot;/m&quot; modifier is used.</p></td></tr>
</table>

<p style="margin-left:11%;">\z, \Z</p>

<p style="margin-left:17%;">&quot;\z&quot; and
&quot;\Z&quot; match at the end of the string. If the
&quot;/m&quot; modifier isn&rsquo;t used, then
&quot;/\Z/&quot; is equivalent to &quot;/$/&quot;; that is,
it matches at the end of the string, or one before the
newline at the end of the string. If the &quot;/m&quot;
modifier is used, then &quot;/$/&quot; matches at internal
newlines, but the meaning of &quot;/\Z/&quot; isn&rsquo;t
changed by the &quot;/m&quot; modifier. &quot;\Z&quot;
matches at the end of the string (or just before a trailing
newline) regardless whether the &quot;/m&quot; modifier is
used.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;\z&quot;
is just like &quot;\Z&quot;, except that it does not match
before a trailing newline. &quot;\z&quot; matches at the end
of the string only, regardless of the modifiers used, and
not just before a newline. It is how to anchor the match to
the true end of the string under all conditions.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>\G</p></td>
<td width="3%"></td>
<td width="83%">


<p>&quot;\G&quot; is usually used only in combination with
the &quot;/g&quot; modifier. If the &quot;/g&quot; modifier
is used and the match is done in scalar context, Perl
remembers where in the source string the last match ended,
and the next time, it will start the match from where it
ended the previous time.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">&quot;\G&quot;
matches the point where the previous match on that string
ended, or the beginning of that string if there was no
previous match.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
<i>G</i>lobal.</p>

<p style="margin-left:11%;">\b{}, \b, \B{}, \B</p>

<p style="margin-left:17%;">&quot;\b{...}&quot;, available
starting in v5.22, matches a boundary (between two
characters, or before the first character of the string, or
after the final character of the string) based on the
Unicode rules for the boundary type specified inside the
braces. The boundary types are given a few paragraphs below.
&quot;\B{...}&quot; matches at any place between characters
where &quot;\b{...}&quot; of the same type doesn&rsquo;t
match.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;\b&quot;
when not immediately followed by a &quot;{&quot; is
available in all Perls. It matches at any place between a
word (something matched by &quot;\w&quot;) and a non-word
character (&quot;\W&quot;); &quot;\B&quot; when not
immediately followed by a &quot;{&quot; matches at any place
between characters where &quot;\b&quot; doesn&rsquo;t match.
To get better word matching of natural language text, see
&quot;\b{wb}&quot; below.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;\b&quot;
and &quot;\B&quot; assume there&rsquo;s a non-word character
before the beginning and after the end of the source string;
so &quot;\b&quot; will match at the beginning (or end) of
the source string if the source string begins (or ends) with
a word character. Otherwise, &quot;\B&quot; will match.</p>

<p style="margin-left:17%; margin-top: 1em">Do not use
something like &quot;\b=head\d\b&quot; and expect it to
match the beginning of a line. It can&rsquo;t, because for
there to be a boundary before the non-word &quot;=&quot;,
there must be a word character immediately previous. All
plain &quot;\b&quot; and &quot;\B&quot; boundary
determinations look for word characters alone, not for
non-word characters nor for string ends. It may help to
understand how &quot;\b&quot; and &quot;\B&quot; work by
equating them as follows:</p>

<p style="margin-left:17%; margin-top: 1em">\b really means
(?:(?&lt;=\w)(?!\w)|(?&lt;!\w)(?=\w)) <br>
\B really means (?:(?&lt;=\w)(?=\w)|(?&lt;!\w)(?!\w))</p>

<p style="margin-left:17%; margin-top: 1em">In contrast,
&quot;\b{...}&quot; and &quot;\B{...}&quot; may or may not
match at the beginning and end of the line, depending on the
boundary type. These implement the Unicode default
boundaries, specified in
&lt;https://www.unicode.org/reports/tr14/&gt; and
&lt;https://www.unicode.org/reports/tr29/&gt;. The boundary
types are: <br>
&quot;\b{gcb}&quot; or &quot;\b{g}&quot;</p>

<p style="margin-left:23%;">This matches a Unicode
&quot;Grapheme Cluster Boundary&quot;. (Actually Perl always
uses the improved &quot;extended&quot; grapheme
cluster&quot;). These are explained below under
&quot;\X&quot;. In fact, &quot;\X&quot; is another way to
get the same functionality. It is equivalent to
&quot;/.+?\b{gcb}/&quot;. Use whichever is most convenient
for your situation.</p>

<p style="margin-left:17%;">&quot;\b{lb}&quot;</p>

<p style="margin-left:23%;">This matches according to the
default Unicode Line Breaking Algorithm
(&lt;https://www.unicode.org/reports/tr14/&gt;), as
customized in that document (Example 7 of revision 35
&lt;https://www.unicode.org/reports/tr14/tr14-35.html#Example7&gt;)
for better handling of numeric expressions.</p>

<p style="margin-left:23%; margin-top: 1em">This is
suitable for many purposes, but the Unicode::LineBreak
module is available on <small>CPAN</small> that provides
many more features, including customization.</p>

<p style="margin-left:17%;">&quot;\b{sb}&quot;</p>

<p style="margin-left:23%;">This matches a Unicode
&quot;Sentence Boundary&quot;. This is an aid to parsing
natural language sentences. It gives good, but imperfect
results. For example, it thinks that &quot;Mr. Smith&quot;
is two sentences. More details are at
&lt;https://www.unicode.org/reports/tr29/&gt;. Note also
that it thinks that anything matching &quot;\R&quot; (except
form feed and vertical tab) is a sentence boundary.
&quot;\b{sb}&quot; works with text designed for
word-processors which wrap lines automatically for display,
but hard-coded line boundaries are considered to be
essentially the ends of text blocks (paragraphs really), and
hence the ends of sentences. &quot;\b{sb}&quot;
doesn&rsquo;t do well with text containing embedded
newlines, like the source text of the document you are
reading. Such text needs to be preprocessed to get rid of
the line separators before looking for sentence boundaries.
Some people view this as a bug in the Unicode standard, and
this behavior is quite subject to change in future Perl
versions.</p>

<p style="margin-left:17%;">&quot;\b{wb}&quot;</p>

<p style="margin-left:23%;">This matches a Unicode
&quot;Word Boundary&quot;, but tailored to Perl
expectations. This gives better (though not perfect) results
for natural language processing than plain &quot;\b&quot;
(without braces) does. For example, it understands that
apostrophes can be in the middle of words and that
parentheses aren&rsquo;t (see the examples below). More
details are at
&lt;https://www.unicode.org/reports/tr29/&gt;.</p>

<p style="margin-left:23%; margin-top: 1em">The current
Unicode definition of a Word Boundary matches between every
white space character. Perl tailors this, starting in
version 5.24, to generally not break up spans of white
space, just as plain &quot;\b&quot; has always functioned.
This allows &quot;\b{wb}&quot; to be a drop-in replacement
for &quot;\b&quot;, but with generally better results for
natural language processing. (The exception to this
tailoring is when a span of white space is immediately
followed by something like U+0303, <small>COMBINING
TILDE.</small> If the final space character in the span is a
horizontal white space, it is broken out so that it attaches
instead to the combining character. To be precise, if a span
of white space that ends in a horizontal space has the
character immediately following it have any of the Word
Boundary property values &quot;Extend&quot;,
&quot;Format&quot; or &quot; <small>ZWJ&quot;,</small> the
boundary between the final horizontal space character and
the rest of the span matches &quot;\b{wb}&quot;. In all
other cases the boundary between two white space characters
matches &quot;\B{wb}&quot;.)</p>

<p style="margin-left:17%; margin-top: 1em">It is important
to realize when you use these Unicode boundaries, that you
are taking a risk that a future version of Perl which
contains a later version of the Unicode Standard will not
work precisely the same way as it did when your code was
written. These rules are not considered stable and have been
somewhat more subject to change than the rest of the
Standard. Unicode reserves the right to change them at will,
and Perl reserves the right to update its implementation to
Unicode&rsquo;s new rules. In the past, some changes have
been because new characters have been added to the Standard
which have different characteristics than all previous
characters, so new rules are formulated for handling them.
These should not cause any backward compatibility issues.
But some changes have changed the treatment of existing
characters because the Unicode Technical Committee has
decided that the change is warranted for whatever reason.
This could be to fix a bug, or because they think better
results are obtained with the new rule.</p>

<p style="margin-left:17%; margin-top: 1em">It is also
important to realize that these are default boundary
definitions, and that implementations may wish to tailor the
results for particular purposes and locales. For example,
some languages, such as Japanese and Thai, require
dictionary lookup to accurately determine word
boundaries.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
<i>b</i>oundary.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>


<p style="margin-left:11%; margin-top: 1em">&quot;cat&quot;
=~ /\Acat/; # Match. <br>
&quot;cat&quot; =~ /cat\Z/; # Match. <br>
&quot;cat\n&quot; =~ /cat\Z/; # Match. <br>
&quot;cat\n&quot; =~ /cat\z/; # No match. <br>
&quot;cat&quot; =~ /\bcat\b/; # Matches. <br>
&quot;cats&quot; =~ /\bcat\b/; # No match. <br>
&quot;cat&quot; =~ /\bcat\B/; # No match. <br>
&quot;cats&quot; =~ /\bcat\B/; # Match. <br>
while (&quot;cat dog&quot; =~ /(\w+)/g) { <br>
print $1; # Prints 'catdog' <br>
} <br>
while (&quot;cat dog&quot; =~ /\G(\w+)/g) { <br>
print $1; # Prints 'cat' <br>
} <br>
my $s = &quot;He said, \&quot;Is pi 3.14? (I'm not
sure).\&quot;&quot;; <br>
print join(&quot;|&quot;, $s =~ m/ ( .+? \b ) /xg),
&quot;\n&quot;; <br>
print join(&quot;|&quot;, $s =~ m/ ( .+? \b{wb} ) /xg),
&quot;\n&quot;; <br>
prints <br>
He| |said|, &quot;|Is| |pi| |3|.|14|? (|I|'|m| |not| |sure
<br>
He| |said|,| |&quot;|Is| |pi| |3.14|?| |(|I'm| |not|
|sure|)|.|&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Misc</b>
<br>
Here we document the backslash sequences that don&rsquo;t
fall in one of the categories above. These are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>\K</p></td>
<td width="3%"></td>
<td width="83%">


<p>This appeared in perl 5.10.0. Anything matched left of
&quot;\K&quot; is not included in $&amp;, and will not be
replaced if the pattern is used in a substitution. This lets
you write &quot;s/PAT1 \K PAT2/REPL/x&quot; instead of
&quot;s/(PAT1) PAT2/${1}REPL/x&quot; or &quot;s/(?&lt;=PAT1)
PAT2/REPL/x&quot;.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
<i>K</i>eep.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\N</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">This feature, available starting
in v5.12, matches any character that is <b>not</b> a
newline. It is a short-hand for writing &quot;[^\n]&quot;,
and is identical to the &quot;.&quot; metasymbol, except
under the &quot;/s&quot; flag, which changes the meaning of
&quot;.&quot;, but not &quot;\N&quot;.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;\N{...}&quot; can mean a named or numbered character
.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
Complement of <i>\n</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\R</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">&quot;\R&quot; matches a
<i>generic newline</i>; that is, anything considered a
linebreak sequence by Unicode. This includes all characters
matched by &quot;\v&quot; (vertical whitespace), and the
multi character sequence &quot;\x0D\x0A&quot; (carriage
return followed by a line feed, sometimes called the network
newline; it&rsquo;s the end of line sequence used in
Microsoft text files opened in binary mode). &quot;\R&quot;
is equivalent to &quot;(?&gt;\x0D\x0A|\v)&quot;. (The reason
it doesn&rsquo;t backtrack is that the sequence is
considered inseparable. That means that</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;\x0D\x0A&quot;
=~ /^\R\x0A$/ # No match</p>

<p style="margin-left:17%; margin-top: 1em">fails, because
the &quot;\R&quot; matches the entire string, and
won&rsquo;t backtrack to match just the &quot;\x0D&quot;.)
Since &quot;\R&quot; can match a sequence of more than one
character, it cannot be put inside a bracketed character
class; &quot;/[\R]/&quot; is an error; use &quot;\v&quot;
instead. &quot;\R&quot; was introduced in perl 5.10.0.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
does not respect any locale that might be in effect; it
matches according to the platform&rsquo;s native character
set.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic: none
really. &quot;\R&quot; was picked because
<small>PCRE</small> already uses &quot;\R&quot;, and more
importantly because Unicode recommends such a regular
expression metacharacter, and suggests &quot;\R&quot; as its
notation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">\X</p></td>
<td width="3%"></td>
<td width="75%">


<p style="margin-top: 1em">This matches a Unicode
<i>extended grapheme cluster</i>.</p></td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">&quot;\X&quot;
matches quite well what normal (non-Unicode-programmer)
usage would consider a single character. As an example,
consider a G with some sort of diacritic mark, such as an
arrow. There is no such single character in Unicode, but one
can be composed by using a G followed by a Unicode &quot;
<small>COMBINING UPWARDS ARROW BELOW&quot;,</small> and
would be displayed by Unicode-aware software as if it were a
single character.</p>

<p style="margin-left:17%; margin-top: 1em">The match is
greedy and non-backtracking, so that the cluster is never
broken up into smaller components.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;\b{gcb}&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic:
e<i>X</i>tended Unicode character.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<p style="margin-left:11%; margin-top: 1em">$str =~
s/foo\Kbar/baz/g; # Change any 'bar' following a 'foo' to
'baz' <br>
$str =~ s/(.)\K\g1//g; # Delete duplicated characters. <br>
&quot;\n&quot; =~ /^\R$/; # Match, \n is a generic newline.
<br>
&quot;\r&quot; =~ /^\R$/; # Match, \r is a generic newline.
<br>
&quot;\r\n&quot; =~ /^\R$/; # Match, \r\n is a generic
newline. <br>
&quot;P\x{307}&quot; =~ /^\X$/ # \X matches a P with a dot
above.</p>
<hr>
</body>
</html>
