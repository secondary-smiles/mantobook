<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:58 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLEMBED</title>

</head>
<body>
<h1>perlembed</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlembed
&minus; how to embed perl in your C program</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>PREAMBLE</small></b>
<br>
Do you want to: <b><br>
Use C from Perl?</b></p>

<p style="margin-left:18%;">Read perlxstut, perlxs, h2xs,
perlguts, and perlapi.</p>

<p style="margin-left:11%;"><b>Use a Unix program from
Perl?</b></p>

<p style="margin-left:18%;">Read about back-quotes and
about &quot;system&quot; and &quot;exec&quot; in
perlfunc.</p>

<p style="margin-left:11%;"><b>Use Perl from Perl?</b></p>

<p style="margin-left:18%;">Read about &quot;do&quot; in
perlfunc and &quot;eval&quot; in perlfunc and
&quot;require&quot; in perlfunc and &quot;use&quot; in
perlfunc.</p>

<p style="margin-left:11%;"><b>Use C from C?</b></p>

<p style="margin-left:18%;">Rethink your design.</p>

<p style="margin-left:11%;"><b>Use Perl from C?</b></p>

<p style="margin-left:18%;">Read on...</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ROADMAP</small></b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Compiling your C program</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Adding a Perl interpreter to your C program</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Calling a Perl subroutine from your C program</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Evaluating a Perl statement from your C program</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Performing Perl pattern matches and substitutions from
your C program</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Fiddling with the Perl stack from your C program</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Maintaining a persistent interpreter</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Maintaining multiple interpreter instances</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Using Perl modules, which themselves use C libraries,
from your C program</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Embedding Perl under Win32</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Compiling
your C program</b> <br>
If you have trouble compiling the scripts in this
documentation, you&rsquo;re not alone. The cardinal rule:
<small>COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT
YOUR PERL WAS COMPILED.</small> (Sorry for yelling.)</p>

<p style="margin-left:11%; margin-top: 1em">Also, every C
program that uses Perl must link in the <i>perl library</i>.
What&rsquo;s that, you ask? Perl is itself written in C; the
perl library is the collection of compiled C programs that
were used to create your perl executable
(<i>/usr/bin/perl</i> or equivalent). (Corollary: you
can&rsquo;t use Perl from your C program unless Perl has
been compiled on your machine, or installed
properly--that&rsquo;s why you shouldn&rsquo;t blithely copy
Perl executables from machine to machine without also
copying the <i>lib</i> directory.)</p>

<p style="margin-left:11%; margin-top: 1em">When you use
Perl from C, your C program
will--usually&minus;&minus;allocate, &quot;run&quot;, and
deallocate a <i>PerlInterpreter</i> object, which is defined
by the perl library.</p>

<p style="margin-left:11%; margin-top: 1em">If your copy of
Perl is recent enough to contain this documentation (version
5.002 or later), then the perl library (and
<i><small>EXTERN</small> .h</i> and <i>perl.h</i>, which
you&rsquo;ll also need) will reside in a directory that
looks like this:</p>


<p style="margin-left:11%; margin-top: 1em">/usr/local/lib/perl5/your_architecture_here/CORE</p>

<p style="margin-left:11%; margin-top: 1em">or perhaps
just</p>


<p style="margin-left:11%; margin-top: 1em">/usr/local/lib/perl5/CORE</p>

<p style="margin-left:11%; margin-top: 1em">or maybe
something like</p>


<p style="margin-left:11%; margin-top: 1em">/usr/opt/perl5/CORE</p>

<p style="margin-left:11%; margin-top: 1em">Execute this
statement for a hint about where to find
<small>CORE:</small></p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;MConfig &minus;e 'print $Config{archlib}'</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
how you&rsquo;d compile the example in the next section,
&quot;Adding a Perl interpreter to your C program&quot;, on
my Linux box:</p>

<p style="margin-left:11%; margin-top: 1em">% gcc &minus;O2
&minus;Dbool=char &minus;DHAS_BOOL
&minus;I/usr/local/include <br>
&minus;I/usr/local/lib/perl5/i586&minus;linux/5.003/CORE
<br>
&minus;L/usr/local/lib/perl5/i586&minus;linux/5.003/CORE
<br>
&minus;o interp interp.c &minus;lperl &minus;lm</p>

<p style="margin-left:11%; margin-top: 1em">(That&rsquo;s
all one line.) On my <small>DEC</small> Alpha running old
5.003_05, the incantation is a bit different:</p>

<p style="margin-left:11%; margin-top: 1em">% cc &minus;O2
&minus;Olimit 2900 &minus;I/usr/local/include <br>

&minus;I/usr/local/lib/perl5/alpha&minus;dec_osf/5.00305/CORE
<br>

&minus;L/usr/local/lib/perl5/alpha&minus;dec_osf/5.00305/CORE
&minus;L/usr/local/lib <br>
&minus;D__LANGUAGE_C__ &minus;D_NO_PROTO &minus;o interp
interp.c &minus;lperl &minus;lm</p>

<p style="margin-left:11%; margin-top: 1em">How can you
figure out what to add? Assuming your Perl is
post&minus;5.001, execute a &quot;perl &minus;V&quot;
command and pay special attention to the &quot;cc&quot; and
&quot;ccflags&quot; information.</p>

<p style="margin-left:11%; margin-top: 1em">You&rsquo;ll
have to choose the appropriate compiler (<i>cc</i>,
<i>gcc</i>, et al.) for your machine: &quot;perl
&minus;MConfig &minus;e 'print $Config{cc}'&quot; will tell
you what to use.</p>

<p style="margin-left:11%; margin-top: 1em">You&rsquo;ll
also have to choose the appropriate library directory
(<i>/usr/local/lib/...</i>) for your machine. If your
compiler complains that certain functions are undefined, or
that it can&rsquo;t locate <i>&minus;lperl</i>, then you
need to change the path following the &quot;&minus;L&quot;.
If it complains that it can&rsquo;t find
<i><small>EXTERN</small> .h</i> and <i>perl.h</i>, you need
to change the path following the &quot;&minus;I&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You may have to
add extra libraries as well. Which ones? Perhaps those
printed by</p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;MConfig &minus;e 'print $Config{libs}'</p>

<p style="margin-left:11%; margin-top: 1em">Provided your
perl binary was properly configured and installed the
<b>ExtUtils::Embed</b> module will determine all of this
information for you:</p>

<p style="margin-left:11%; margin-top: 1em">% cc &minus;o
interp interp.c `perl &minus;MExtUtils::Embed &minus;e
ccopts &minus;e ldopts`</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>ExtUtils::Embed</b> module isn&rsquo;t part of your Perl
distribution, you can retrieve it from
&lt;https://metacpan.org/pod/ExtUtils::Embed&gt; (If this
documentation came from your Perl distribution, then
you&rsquo;re running 5.004 or better and you already have
it.)</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>ExtUtils::Embed</b> kit on <small>CPAN</small> also
contains all source code for the examples in this document,
tests, additional examples and other information you may
find useful.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Adding a
Perl interpreter to your C program</b> <br>
In a sense, perl (the C program) is a good example of
embedding Perl (the language), so I&rsquo;ll demonstrate
embedding with <i>miniperlmain.c</i>, included in the source
distribution. Here&rsquo;s a bastardized, non-portable
version of <i>miniperlmain.c</i> containing the essentials
of embedding:</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;EXTERN.h&gt; /* from the Perl distribution */ <br>
#include &lt;perl.h&gt; /* from the Perl distribution */
<br>
static PerlInterpreter *my_perl; /*** The Perl interpreter
***/ <br>
int main(int argc, char **argv, char **env) <br>
{ <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
my_perl = perl_alloc(); <br>
perl_construct(my_perl); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
perl_parse(my_perl, NULL, argc, argv, (char **)NULL); <br>
perl_run(my_perl); <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
exit(EXIT_SUCCESS); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Notice that we
don&rsquo;t use the &quot;env&quot; pointer. Normally handed
to &quot;perl_parse&quot; as its final argument,
&quot;env&quot; here is replaced by &quot;NULL&quot;, which
means that the current environment will be used.</p>

<p style="margin-left:11%; margin-top: 1em">The macros
<b><small>PERL_SYS_INIT3</small> ()</b> and
<b><small>PERL_SYS_TERM</small> ()</b> provide
system-specific tune up of the C runtime environment
necessary to run Perl interpreters; they should only be
called once regardless of how many interpreters you create
or destroy. Call <b><small>PERL_SYS_INIT3</small> ()</b>
before you create your first interpreter, and
<b><small>PERL_SYS_TERM</small> ()</b> after you free your
last interpreter.</p>

<p style="margin-left:11%; margin-top: 1em">Since
<b><small>PERL_SYS_INIT3</small> ()</b> may change
&quot;env&quot;, it may be more appropriate to provide
&quot;env&quot; as an argument to <b>perl_parse()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Also notice
that no matter what arguments you pass to
<b>perl_parse()</b>, <b><small>PERL_SYS_INIT3</small> ()</b>
must be invoked on the C <b>main()</b> argc, argv and env
and only once.</p>

<p style="margin-left:11%; margin-top: 1em">Mind that
argv[argc] must be <small>NULL,</small> same as those passed
to a main function in C.</p>

<p style="margin-left:11%; margin-top: 1em">Now compile
this program (I&rsquo;ll call it <i>interp.c</i>) into an
executable:</p>

<p style="margin-left:11%; margin-top: 1em">% cc &minus;o
interp interp.c `perl &minus;MExtUtils::Embed &minus;e
ccopts &minus;e ldopts`</p>

<p style="margin-left:11%; margin-top: 1em">After a
successful compilation, you&rsquo;ll be able to use
<i>interp</i> just like perl itself:</p>

<p style="margin-left:11%; margin-top: 1em">% interp <br>
print &quot;Pretty Good Perl \n&quot;; <br>
print &quot;10890 &minus; 9801 is &quot;, 10890 &minus;
9801; <br>
&lt;CTRL&minus;D&gt; <br>
Pretty Good Perl <br>
10890 &minus; 9801 is 1089</p>

<p style="margin-left:11%; margin-top: 1em">or</p>

<p style="margin-left:11%; margin-top: 1em">% interp
&minus;e 'printf(&quot;%x&quot;, 3735928559)' <br>
deadbeef</p>

<p style="margin-left:11%; margin-top: 1em">You can also
read and execute Perl statements from a file while in the
midst of your C program, by placing the filename in
<i>argv[1]</i> before calling <i>perl_run</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Calling a
Perl subroutine from your C program</b> <br>
To call individual Perl subroutines, you can use any of the
<b>call_*</b> functions documented in perlcall. In this
example we&rsquo;ll use &quot;call_argv&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
shown below, in a program I&rsquo;ll call
<i>showtime.c</i>.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt; <br>
static PerlInterpreter *my_perl; <br>
int main(int argc, char **argv, char **env) <br>
{ <br>
char *args[] = { NULL }; <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
my_perl = perl_alloc(); <br>
perl_construct(my_perl); <br>
perl_parse(my_perl, NULL, argc, argv, NULL); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
/*** skipping perl_run() ***/ <br>
call_argv(&quot;showtime&quot;, G_DISCARD | G_NOARGS, args);
<br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
exit(EXIT_SUCCESS); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>showtime</i> is a Perl subroutine that takes no arguments
(that&rsquo;s the <i>G_NOARGS</i>) and for which I&rsquo;ll
ignore the return value (that&rsquo;s the <i>G_DISCARD</i>).
Those flags, and others, are discussed in perlcall.</p>

<p style="margin-left:11%; margin-top: 1em">I&rsquo;ll
define the <i>showtime</i> subroutine in a file called
<i>showtime.pl</i>:</p>

<p style="margin-left:11%; margin-top: 1em">print &quot;I
shan't be printed.&quot;; <br>
sub showtime { <br>
print time; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Simple enough.
Now compile and run:</p>

<p style="margin-left:11%; margin-top: 1em">% cc &minus;o
showtime showtime.c \ <br>
`perl &minus;MExtUtils::Embed &minus;e ccopts &minus;e
ldopts` <br>
% showtime showtime.pl <br>
818284590</p>

<p style="margin-left:11%; margin-top: 1em">yielding the
number of seconds that elapsed between January 1, 1970 (the
beginning of the Unix epoch), and the moment I began writing
this sentence.</p>

<p style="margin-left:11%; margin-top: 1em">In this
particular case we don&rsquo;t have to call <i>perl_run</i>,
as we set the PL_exit_flag
<small>PERL_EXIT_DESTRUCT_END</small> which executes
<small>END</small> blocks in perl_destruct.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
pass arguments to the Perl subroutine, you can add strings
to the &quot;NULL&quot;&minus;terminated &quot;args&quot;
list passed to <i>call_argv</i>. For other data types, or to
examine return values, you&rsquo;ll need to manipulate the
Perl stack. That&rsquo;s demonstrated in &quot;Fiddling with
the Perl stack from your C program&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Evaluating a
Perl statement from your C program</b> <br>
Perl provides two <small>API</small> functions to evaluate
pieces of Perl code. These are &quot;eval_sv&quot; in
perlapi and &quot;eval_pv&quot; in perlapi.</p>

<p style="margin-left:11%; margin-top: 1em">Arguably, these
are the only routines you&rsquo;ll ever need to execute
snippets of Perl code from within your C program. Your code
can be as long as you wish; it can contain multiple
statements; it can employ &quot;use&quot; in perlfunc,
&quot;require&quot; in perlfunc, and &quot;do&quot; in
perlfunc to include external Perl files.</p>

<p style="margin-left:11%; margin-top: 1em"><i>eval_pv</i>
lets us evaluate individual Perl strings, and then extract
variables for coercion into C types. The following program,
<i>string.c</i>, executes three Perl strings, extracting an
&quot;int&quot; from the first, a &quot;float&quot; from the
second, and a &quot;char *&quot; from the third.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt; <br>
static PerlInterpreter *my_perl; <br>
main (int argc, char **argv, char **env) <br>
{ <br>
char *embedding[] = { &quot;&quot;, &quot;&minus;e&quot;,
&quot;0&quot;, NULL }; <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
my_perl = perl_alloc(); <br>
perl_construct( my_perl ); <br>
perl_parse(my_perl, NULL, 3, embedding, NULL); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
perl_run(my_perl); <br>
/** Treat $a as an integer **/ <br>
eval_pv(&quot;$a = 3; $a **= 2&quot;, TRUE); <br>
printf(&quot;a = %d\n&quot;, SvIV(get_sv(&quot;a&quot;,
0))); <br>
/** Treat $a as a float **/ <br>
eval_pv(&quot;$a = 3.14; $a **= 2&quot;, TRUE); <br>
printf(&quot;a = %f\n&quot;, SvNV(get_sv(&quot;a&quot;,
0))); <br>
/** Treat $a as a string **/ <br>
eval_pv( <br>
&quot;$a = 'rekcaH lreP rehtonA tsuJ'; $a =
reverse($a);&quot;, TRUE); <br>
printf(&quot;a = %s\n&quot;,
SvPV_nolen(get_sv(&quot;a&quot;, 0))); <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">All of those
strange functions with <i>sv</i> in their names help convert
Perl scalars to C types. They&rsquo;re described in perlguts
and perlapi.</p>

<p style="margin-left:11%; margin-top: 1em">If you compile
and run <i>string.c</i>, you&rsquo;ll see the results of
using <b><i>SvIV()</i></b> to create an &quot;int&quot;,
<b><i>SvNV()</i></b> to create a &quot;float&quot;, and
<b><i>SvPV()</i></b> to create a string:</p>

<p style="margin-left:11%; margin-top: 1em">a = 9 <br>
a = 9.859600 <br>
a = Just Another Perl Hacker</p>

<p style="margin-left:11%; margin-top: 1em">In the example
above, we&rsquo;ve created a global variable to temporarily
store the computed value of our eval&rsquo;ed expression. It
is also possible and in most cases a better strategy to
fetch the return value from <b><i>eval_pv()</i></b> instead.
Example:</p>

<p style="margin-left:11%; margin-top: 1em">... <br>
SV *val = eval_pv(&quot;reverse 'rekcaH lreP rehtonA
tsuJ'&quot;, TRUE); <br>
printf(&quot;%s\n&quot;, SvPV_nolen(val)); <br>
...</p>

<p style="margin-left:11%; margin-top: 1em">This way, we
avoid namespace pollution by not creating global variables
and we&rsquo;ve simplified our code as well.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Performing
Perl pattern matches and substitutions from your C
program</b> <br>
The <b><i>eval_sv()</i></b> function lets us evaluate
strings of Perl code, so we can define some functions that
use it to &quot;specialize&quot; in matches and
substitutions: <b><i>match()</i></b>,
<b><i>substitute()</i></b>, and <b><i>matches()</i></b>.</p>

<p style="margin-left:11%; margin-top: 1em">I32 match(SV
*string, char *pattern);</p>

<p style="margin-left:11%; margin-top: 1em">Given a string
and a pattern (e.g., &quot;m/clasp/&quot; or
&quot;/\b\w*\b/&quot;, which in your C program might appear
as &quot;/\\b\\w*\\b/&quot;), <b>match()</b> returns 1 if
the string matches the pattern and 0 otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">int
substitute(SV **string, char *pattern);</p>

<p style="margin-left:11%; margin-top: 1em">Given a pointer
to an &quot;SV&quot; and an &quot;=~&quot; operation (e.g.,
&quot;s/bob/robert/g&quot; or
&quot;tr[A&minus;Z][a&minus;z]&quot;), <b>substitute()</b>
modifies the string within the &quot;SV&quot; as according
to the operation, returning the number of substitutions
made.</p>

<p style="margin-left:11%; margin-top: 1em">SSize_t
matches(SV *string, char *pattern, AV **matches);</p>

<p style="margin-left:11%; margin-top: 1em">Given an
&quot;SV&quot;, a pattern, and a pointer to an empty
&quot;AV&quot;, <b>matches()</b> evaluates &quot;$string =~
$pattern&quot; in a list context, and fills in
<i>matches</i> with the array elements, returning the number
of matches found.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
sample program, <i>match.c</i>, that uses all three (long
lines have been wrapped here):</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt; <br>
static PerlInterpreter *my_perl; <br>
/** my_eval_sv(code, error_check) <br>
** kinda like eval_sv(), <br>
** but we pop the return value off the stack <br>
**/ <br>
SV* my_eval_sv(SV *sv, I32 croak_on_error) <br>
{ <br>
dSP; <br>
SV* retval; <br>
PUSHMARK(SP); <br>
eval_sv(sv, G_SCALAR); <br>
SPAGAIN; <br>
retval = POPs; <br>
PUTBACK; <br>
if (croak_on_error &amp;&amp; SvTRUE(ERRSV)) <br>
croak_sv(ERRSV); <br>
return retval; <br>
} <br>
/** match(string, pattern) <br>
** <br>
** Used for matches in a scalar context. <br>
** <br>
** Returns 1 if the match was successful; 0 otherwise. <br>
**/ <br>
I32 match(SV *string, char *pattern) <br>
{ <br>
SV *command = newSV(0), *retval; <br>
sv_setpvf(command, &quot;my $string = '%s'; $string =~
%s&quot;, <br>
SvPV_nolen(string), pattern); <br>
retval = my_eval_sv(command, TRUE); <br>
SvREFCNT_dec(command); <br>
return SvIV(retval); <br>
} <br>
/** substitute(string, pattern) <br>
** <br>
** Used for =~ operations that <br>
** modify their left&minus;hand side (s/// and tr///) <br>
** <br>
** Returns the number of successful matches, and <br>
** modifies the input string if there were any. <br>
**/ <br>
I32 substitute(SV **string, char *pattern) <br>
{ <br>
SV *command = newSV(0), *retval; <br>
sv_setpvf(command, &quot;$string = '%s'; ($string =~
%s)&quot;, <br>
SvPV_nolen(*string), pattern); <br>
retval = my_eval_sv(command, TRUE); <br>
SvREFCNT_dec(command); <br>
*string = get_sv(&quot;string&quot;, 0); <br>
return SvIV(retval); <br>
} <br>
/** matches(string, pattern, matches) <br>
** <br>
** Used for matches in a list context. <br>
** <br>
** Returns the number of matches, <br>
** and fills in **matches with the matching substrings <br>
**/ <br>
SSize_t matches(SV *string, char *pattern, AV **match_list)
<br>
{ <br>
SV *command = newSV(0); <br>
SSize_t num_matches; <br>
sv_setpvf(command, &quot;my $string = '%s'; @array =
($string =~ %s)&quot;, <br>
SvPV_nolen(string), pattern); <br>
my_eval_sv(command, TRUE); <br>
SvREFCNT_dec(command); <br>
*match_list = get_av(&quot;array&quot;, 0); <br>
num_matches = av_top_index(*match_list) + 1; <br>
return num_matches; <br>
} <br>
main (int argc, char **argv, char **env) <br>
{ <br>
char *embedding[] = { &quot;&quot;, &quot;&minus;e&quot;,
&quot;0&quot;, NULL }; <br>
AV *match_list; <br>
I32 num_matches, i; <br>
SV *text; <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
my_perl = perl_alloc(); <br>
perl_construct(my_perl); <br>
perl_parse(my_perl, NULL, 3, embedding, NULL); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
text = newSV(0); <br>
sv_setpv(text, &quot;When he is at a convenience store and
the &quot; <br>
&quot;bill comes to some amount like 76 cents, Maynard is
&quot; <br>
&quot;aware that there is something he *should* do,
something &quot; <br>
&quot;that will enable him to get back a quarter, but he has
&quot; <br>
&quot;no idea *what*. He fumbles through his red squeezey
&quot; <br>
&quot;changepurse and gives the boy three extra pennies with
&quot; <br>
&quot;his dollar, hoping that he might luck into the correct
&quot; <br>
&quot;amount. The boy gives him back two of his own pennies
&quot; <br>
&quot;and then the big shiny quarter that is his prize.
&quot; <br>
&quot;&minus;RICHH&quot;); <br>
if (match(text, &quot;m/quarter/&quot;)) /** Does text
contain 'quarter'? **/ <br>
printf(&quot;match: Text contains the word
'quarter'.\n\n&quot;); <br>
else <br>
printf(&quot;match: Text doesn't contain the word
'quarter'.\n\n&quot;); <br>
if (match(text, &quot;m/eighth/&quot;)) /** Does text
contain 'eighth'? **/ <br>
printf(&quot;match: Text contains the word
'eighth'.\n\n&quot;); <br>
else <br>
printf(&quot;match: Text doesn't contain the word
'eighth'.\n\n&quot;); <br>
/** Match all occurrences of /wi../ **/ <br>
num_matches = matches(text, &quot;m/(wi..)/g&quot;,
&amp;match_list); <br>
printf(&quot;matches: m/(wi..)/g found %d
matches...\n&quot;, num_matches); <br>
for (i = 0; i &lt; num_matches; i++) <br>
printf(&quot;match: %s\n&quot;, <br>
SvPV_nolen(*av_fetch(match_list, i, FALSE))); <br>
printf(&quot;\n&quot;); <br>
/** Remove all vowels from text **/ <br>
num_matches = substitute(&amp;text,
&quot;s/[aeiou]//gi&quot;); <br>
if (num_matches) { <br>
printf(&quot;substitute: s/[aeiou]//gi...%lu substitutions
made.\n&quot;, <br>
(unsigned long)num_matches); <br>
printf(&quot;Now text is: %s\n\n&quot;, SvPV_nolen(text));
<br>
} <br>
/** Attempt a substitution **/ <br>
if (!substitute(&amp;text, &quot;s/Perl/C/&quot;)) { <br>
printf(&quot;substitute: s/Perl/C...No substitution
made.\n\n&quot;); <br>
} <br>
SvREFCNT_dec(text); <br>
PL_perl_destruct_level = 1; <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">which produces
the output (again, long lines have been wrapped here)</p>

<p style="margin-left:11%; margin-top: 1em">match: Text
contains the word 'quarter'. <br>
match: Text doesn't contain the word 'eighth'. <br>
matches: m/(wi..)/g found 2 matches... <br>
match: will <br>
match: with <br>
substitute: s/[aeiou]//gi...139 substitutions made. <br>
Now text is: Whn h s t cnvnnc str nd th bll cms t sm mnt lk
76 cnts, <br>
Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl
hm t gt <br>
bck qrtr, bt h hs n d *wht*. H fmbls thrgh hs rd sqzy
chngprs nd <br>
gvs th by thr xtr pnns wth hs dllr, hpng tht h mght lck nt
th crrct <br>
mnt. Th by gvs hm bck tw f hs wn pnns nd thn th bg shny qrtr
tht s <br>
hs prz. &minus;RCHH <br>
substitute: s/Perl/C...No substitution made.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Fiddling
with the Perl stack from your C program</b> <br>
When trying to explain stacks, most computer science
textbooks mumble something about spring-loaded columns of
cafeteria plates: the last thing you pushed on the stack is
the first thing you pop off. That&rsquo;ll do for our
purposes: your C program will push some arguments onto
&quot;the Perl stack&quot;, shut its eyes while some magic
happens, and then pop the results--the return value of your
Perl subroutine--off the stack.</p>

<p style="margin-left:11%; margin-top: 1em">First
you&rsquo;ll need to know how to convert between C types and
Perl types, with <b>newSViv()</b> and <b>sv_setnv()</b> and
<b>newAV()</b> and all their friends. They&rsquo;re
described in perlguts and perlapi.</p>

<p style="margin-left:11%; margin-top: 1em">Then
you&rsquo;ll need to know how to manipulate the Perl stack.
That&rsquo;s described in perlcall.</p>

<p style="margin-left:11%; margin-top: 1em">Once
you&rsquo;ve understood those, embedding Perl in C is
easy.</p>

<p style="margin-left:11%; margin-top: 1em">Because C has
no builtin function for integer exponentiation, let&rsquo;s
make Perl&rsquo;s ** operator available to it (this is less
useful than it sounds, because Perl implements ** with
C&rsquo;s <b><i>pow()</i></b> function). First I&rsquo;ll
create a stub exponentiation function in
<i>power.pl</i>:</p>

<p style="margin-left:11%; margin-top: 1em">sub expo { <br>
my ($a, $b) = @_; <br>
return $a ** $b; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now I&rsquo;ll
create a C program, <i>power.c</i>, with a function
<b><i>PerlPower()</i></b> that contains all the perlguts
necessary to push the two arguments into
<b><i>expo()</i></b> and to pop the return value out. Take a
deep breath...</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt; <br>
static PerlInterpreter *my_perl; <br>
static void <br>
PerlPower(int a, int b) <br>
{ <br>
dSP; /* initialize stack pointer */ <br>
ENTER; /* everything created after here */ <br>
SAVETMPS; /* ...is a temporary variable. */ <br>
PUSHMARK(SP); /* remember the stack pointer */ <br>
XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the
stack */ <br>
XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto
stack */ <br>
PUTBACK; /* make local stack pointer global */ <br>
call_pv(&quot;expo&quot;, G_SCALAR); /* call the function */
<br>
SPAGAIN; /* refresh stack pointer */ <br>
/* pop the return value from stack */ <br>
printf (&quot;%d to the %dth power is %d.\n&quot;, a, b,
POPi); <br>
PUTBACK; <br>
FREETMPS; /* free that return value */ <br>
LEAVE; /* ...and the XPUSHed &quot;mortal&quot; args.*/ <br>
} <br>
int main (int argc, char **argv, char **env) <br>
{ <br>
char *my_argv[] = { &quot;&quot;, &quot;power.pl&quot;, NULL
}; <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
my_perl = perl_alloc(); <br>
perl_construct( my_perl ); <br>
perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL); <br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
perl_run(my_perl); <br>
PerlPower(3, 4); /*** Compute 3 ** 4 ***/ <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
exit(EXIT_SUCCESS); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Compile and
run:</p>

<p style="margin-left:11%; margin-top: 1em">% cc &minus;o
power power.c `perl &minus;MExtUtils::Embed &minus;e ccopts
&minus;e ldopts` <br>
% power <br>
3 to the 4th power is 81.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Maintaining
a persistent interpreter</b> <br>
When developing interactive and/or potentially long-running
applications, it&rsquo;s a good idea to maintain a
persistent interpreter rather than allocating and
constructing a new interpreter multiple times. The major
reason is speed: since Perl will only be loaded into memory
once.</p>

<p style="margin-left:11%; margin-top: 1em">However, you
have to be more cautious with namespace and variable scoping
when using a persistent interpreter. In previous examples
we&rsquo;ve been using global variables in the default
package &quot;main&quot;. We knew exactly what code would be
run, and assumed we could avoid variable collisions and
outrageous symbol table growth.</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s say
your application is a server that will occasionally run Perl
code from some arbitrary file. Your server has no way of
knowing what code it&rsquo;s going to run. Very
dangerous.</p>

<p style="margin-left:11%; margin-top: 1em">If the file is
pulled in by &quot;perl_parse()&quot;, compiled into a newly
constructed interpreter, and subsequently cleaned out with
&quot;perl_destruct()&quot; afterwards, you&rsquo;re
shielded from most namespace troubles.</p>

<p style="margin-left:11%; margin-top: 1em">One way to
avoid namespace collisions in this scenario is to translate
the filename into a guaranteed-unique package name, and then
compile the code into that package using &quot;eval&quot; in
perlfunc. In the example below, each file will only be
compiled once. Or, the application might choose to clean out
the symbol table associated with the file after it&rsquo;s
no longer needed. Using &quot;call_argv&quot; in perlapi,
We&rsquo;ll call the subroutine
&quot;Embed::Persistent::eval_file&quot; which lives in the
file &quot;persistent.pl&quot; and pass the filename and
boolean cleanup/cache flag as arguments.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
process will continue to grow for each file that it uses. In
addition, there might be &quot;AUTOLOAD&quot;ed subroutines
and other conditions that cause Perl&rsquo;s symbol table to
grow. You might want to add some logic that keeps track of
the process size, or restarts itself after a certain number
of requests, to ensure that memory consumption is minimized.
You&rsquo;ll also want to scope your variables with
&quot;my&quot; in perlfunc whenever possible.</p>

<p style="margin-left:11%; margin-top: 1em">package
Embed::Persistent; <br>
#persistent.pl <br>
use strict; <br>
our %Cache; <br>
use Symbol qw(delete_package); <br>
sub valid_package_name { <br>
my($string) = @_; <br>
$string =~
s/([^A&minus;Za&minus;z0&minus;9\/])/sprintf(&quot;_%2x&quot;,unpack(&quot;C&quot;,$1))/eg;
<br>
# second pass only for words starting with a digit <br>
$string =~
s|/(\d)|sprintf(&quot;/_%2x&quot;,unpack(&quot;C&quot;,$1))|eg;
<br>
# Dress it up as a real package name <br>
$string =~ s|/|::|g; <br>
return &quot;Embed&quot; . $string; <br>
} <br>
sub eval_file { <br>
my($filename, $delete) = @_; <br>
my $package = valid_package_name($filename); <br>
my $mtime = &minus;M $filename; <br>
if(defined $Cache{$package}{mtime} <br>
&amp;&amp; <br>
$Cache{$package}{mtime} &lt;= $mtime) <br>
{ <br>
# we have compiled this subroutine already, <br>
# it has not been updated on disk, nothing left to do <br>
print STDERR &quot;already compiled
$package&minus;&gt;handler\n&quot;; <br>
} <br>
else { <br>
local *FH; <br>
open FH, $filename or die &quot;open '$filename' $!&quot;;
<br>
local($/) = undef; <br>
my $sub = &lt;FH&gt;; <br>
close FH; <br>
#wrap the code into a subroutine inside our unique package
<br>
my $eval = qq{package $package; sub handler { $sub; }}; <br>
{ <br>
# hide our variables within this block <br>
my($filename,$mtime,$package,$sub); <br>
eval $eval; <br>
} <br>
die $@ if $@; <br>
#cache it unless we're cleaning out each time <br>
$Cache{$package}{mtime} = $mtime unless $delete; <br>
} <br>
eval {$package&minus;&gt;handler;}; <br>
die $@ if $@; <br>
delete_package($package) if $delete; <br>
#take a look if you want <br>
#print
Devel::Symdump&minus;&gt;rnew($package)&minus;&gt;as_string,
$/; <br>
} <br>
1; <br>
__END__ <br>
/* persistent.c */ <br>
#include &lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt; <br>
/* 1 = clean out filename's symbol table after each request,
<br>
0 = don't <br>
*/ <br>
#ifndef DO_CLEAN <br>
#define DO_CLEAN 0 <br>
#endif <br>
#define BUFFER_SIZE 1024 <br>
static PerlInterpreter *my_perl = NULL; <br>
int <br>
main(int argc, char **argv, char **env) <br>
{ <br>
char *embedding[] = { &quot;&quot;,
&quot;persistent.pl&quot;, NULL }; <br>
char *args[] = { &quot;&quot;, DO_CLEAN, NULL }; <br>
char filename[BUFFER_SIZE]; <br>
int failing, exitstatus; <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
if((my_perl = perl_alloc()) == NULL) { <br>
fprintf(stderr, &quot;no memory!&quot;); <br>
exit(EXIT_FAILURE); <br>
} <br>
perl_construct(my_perl); <br>
PL_origalen = 1; /* don't let $0 assignment update the <br>
proctitle or embedding[0] */ <br>
failing = perl_parse(my_perl, NULL, 2, embedding, NULL);
<br>
PL_exit_flags |= PERL_EXIT_DESTRUCT_END; <br>
if(!failing) <br>
failing = perl_run(my_perl); <br>
if(!failing) { <br>
while(printf(&quot;Enter file name: &quot;) &amp;&amp; <br>
fgets(filename, BUFFER_SIZE, stdin)) { <br>
filename[strlen(filename)&minus;1] = '\0'; /* strip \n */
<br>
/* call the subroutine, <br>
passing it the filename as an argument */ <br>
args[0] = filename; <br>
call_argv(&quot;Embed::Persistent::eval_file&quot;, <br>
G_DISCARD | G_EVAL, args); <br>
/* check $@ */ <br>
if(SvTRUE(ERRSV)) <br>
fprintf(stderr, &quot;eval error: %s\n&quot;,
SvPV_nolen(ERRSV)); <br>
} <br>
} <br>
PL_perl_destruct_level = 0; <br>
exitstatus = perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
PERL_SYS_TERM(); <br>
exit(exitstatus); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now
compile:</p>

<p style="margin-left:11%; margin-top: 1em">% cc &minus;o
persistent persistent.c \ <br>
`perl &minus;MExtUtils::Embed &minus;e ccopts &minus;e
ldopts`</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s an
example script file:</p>

<p style="margin-left:11%; margin-top: 1em">#test.pl <br>
my $string = &quot;hello&quot;; <br>
foo($string); <br>
sub foo { <br>
print &quot;foo says: @_\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now run:</p>

<p style="margin-left:11%; margin-top: 1em">% persistent
<br>
Enter file name: test.pl <br>
foo says: hello <br>
Enter file name: test.pl <br>
already compiled Embed::test_2epl&minus;&gt;handler <br>
foo says: hello <br>
Enter file name: ^C</p>

<p style="margin-left:11%; margin-top: 1em"><b>Execution of
<small>END</small> blocks</b> <br>
Traditionally <small>END</small> blocks have been executed
at the end of the perl_run. This causes problems for
applications that never call perl_run. Since perl 5.7.2 you
can specify &quot;PL_exit_flags |=
PERL_EXIT_DESTRUCT_END&quot; to get the new behaviour. This
also enables the running of <small>END</small> blocks if the
perl_parse fails and &quot;perl_destruct&quot; will return
the exit value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$0
assignments</b> <br>
When a perl script assigns a value to $0 then the perl
runtime will try to make this value show up as the program
name reported by &quot;ps&quot; by updating the memory
pointed to by the argv passed to <b>perl_parse()</b> and
also calling <small>API</small> functions like
<b>setproctitle()</b> where available. This behaviour might
not be appropriate when embedding perl and can be disabled
by assigning the value 1 to the variable
&quot;PL_origalen&quot; before <b>perl_parse()</b> is
called.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>persistent.c</i> example above is for instance likely to
segfault when $0 is assigned to if the &quot;PL_origalen =
1;&quot; assignment is removed. This because perl will try
to write to the read only memory of the
&quot;embedding[]&quot; strings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Maintaining
multiple interpreter instances</b> <br>
Some rare applications will need to create more than one
interpreter during a session. Such an application might
sporadically decide to release any resources associated with
the interpreter.</p>

<p style="margin-left:11%; margin-top: 1em">The program
must take care to ensure that this takes place <i>before</i>
the next interpreter is constructed. By default, when perl
is not built with any special options, the global variable
&quot;PL_perl_destruct_level&quot; is set to 0, since extra
cleaning isn&rsquo;t usually needed when a program only ever
creates a single interpreter in its entire lifetime.</p>

<p style="margin-left:11%; margin-top: 1em">Setting
&quot;PL_perl_destruct_level&quot; to 1 makes everything
squeaky clean:</p>

<p style="margin-left:11%; margin-top: 1em">while(1) { <br>
... <br>
/* reset global variables here with PL_perl_destruct_level =
1 */ <br>
PL_perl_destruct_level = 1; <br>
perl_construct(my_perl); <br>
... <br>
/* clean and reset _everything_ during perl_destruct */ <br>
PL_perl_destruct_level = 1; <br>
perl_destruct(my_perl); <br>
perl_free(my_perl); <br>
... <br>
/* let's go do it again! */ <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">When
<b><i>perl_destruct()</i></b> is called, the
interpreter&rsquo;s syntax parse tree and symbol tables are
cleaned up, and global variables are reset. The second
assignment to &quot;PL_perl_destruct_level&quot; is needed
because perl_construct resets it to 0.</p>

<p style="margin-left:11%; margin-top: 1em">Now suppose we
have more than one interpreter instance running at the same
time. This is feasible, but only if you used the Configure
option &quot;&minus;Dusemultiplicity&quot; or the options
&quot;&minus;Dusethreads &minus;Duseithreads&quot; when
building perl. By default, enabling one of these Configure
options sets the per-interpreter global variable
&quot;PL_perl_destruct_level&quot; to 1, so that thorough
cleaning is automatic and interpreter variables are
initialized correctly. Even if you don&rsquo;t intend to run
two or more interpreters at the same time, but to run them
sequentially, like in the above example, it is recommended
to build perl with the &quot;&minus;Dusemultiplicity&quot;
option otherwise some interpreter variables may not be
initialized correctly between consecutive runs and your
application may crash.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Thread-aware system interfaces&quot; in perlxs.</p>

<p style="margin-left:11%; margin-top: 1em">Using
&quot;&minus;Dusethreads &minus;Duseithreads&quot; rather
than &quot;&minus;Dusemultiplicity&quot; is more appropriate
if you intend to run multiple interpreters concurrently in
different threads, because it enables support for linking in
the thread libraries of your system with the
interpreter.</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
give it a try:</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;EXTERN.h&gt; <br>
#include &lt;perl.h&gt; <br>
/* we're going to embed two interpreters */ <br>
#define SAY_HELLO &quot;&minus;e&quot;, &quot;print qq(Hi,
I'm $^X\n)&quot; <br>
int main(int argc, char **argv, char **env) <br>
{ <br>
PerlInterpreter *one_perl, *two_perl; <br>
char *one_args[] = { &quot;one_perl&quot;, SAY_HELLO, NULL
}; <br>
char *two_args[] = { &quot;two_perl&quot;, SAY_HELLO, NULL
}; <br>
PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env); <br>
one_perl = perl_alloc(); <br>
two_perl = perl_alloc(); <br>
PERL_SET_CONTEXT(one_perl); <br>
perl_construct(one_perl); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_construct(two_perl); <br>
PERL_SET_CONTEXT(one_perl); <br>
perl_parse(one_perl, NULL, 3, one_args, (char **)NULL); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_parse(two_perl, NULL, 3, two_args, (char **)NULL); <br>
PERL_SET_CONTEXT(one_perl); <br>
perl_run(one_perl); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_run(two_perl); <br>
PERL_SET_CONTEXT(one_perl); <br>
perl_destruct(one_perl); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_destruct(two_perl); <br>
PERL_SET_CONTEXT(one_perl); <br>
perl_free(one_perl); <br>
PERL_SET_CONTEXT(two_perl); <br>
perl_free(two_perl); <br>
PERL_SYS_TERM(); <br>
exit(EXIT_SUCCESS); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Note the calls
to <b><small>PERL_SET_CONTEXT</small> ()</b>. These are
necessary to initialize the global state that tracks which
interpreter is the &quot;current&quot; one on the particular
process or thread that may be running it. It should always
be used if you have more than one interpreter and are making
perl <small>API</small> calls on both interpreters in an
interleaved fashion.</p>


<p style="margin-left:11%; margin-top: 1em"><small>PERL_SET_CONTEXT</small>
(interp) should also be called whenever &quot;interp&quot;
is used by a thread that did not create it (using either
<b>perl_alloc()</b>, or the more esoteric
<b>perl_clone()</b>).</p>

<p style="margin-left:11%; margin-top: 1em">Compile as
usual:</p>

<p style="margin-left:11%; margin-top: 1em">% cc &minus;o
multiplicity multiplicity.c \ <br>
`perl &minus;MExtUtils::Embed &minus;e ccopts &minus;e
ldopts`</p>

<p style="margin-left:11%; margin-top: 1em">Run it, Run
it:</p>

<p style="margin-left:11%; margin-top: 1em">% multiplicity
<br>
Hi, I'm one_perl <br>
Hi, I'm two_perl</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using Perl
modules, which themselves use C libraries, from your C
program</b> <br>
If you&rsquo;ve played with the examples above and tried to
embed a script that <b><i>use()</i></b>s a Perl module (such
as <i>Socket</i>) which itself uses a C or C
<small>++</small> library, this probably happened:</p>

<p style="margin-left:11%; margin-top: 1em">Can't load
module Socket, dynamic loading not available in this perl.
<br>
(You may need to build a new perl executable which either
supports <br>
dynamic loading or has the Socket module statically linked
into it.)</p>

<p style="margin-left:11%; margin-top: 1em">What&rsquo;s
wrong?</p>

<p style="margin-left:11%; margin-top: 1em">Your
interpreter doesn&rsquo;t know how to communicate with these
extensions on its own. A little glue will help. Up until now
you&rsquo;ve been calling <b><i>perl_parse()</i></b>,
handing it <small>NULL</small> for the second argument:</p>


<p style="margin-left:11%; margin-top: 1em">perl_parse(my_perl,
NULL, argc, my_argv, NULL);</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
where the glue code can be inserted to create the initial
contact between Perl and linked C/C <small>++</small>
routines. Let&rsquo;s take a look some pieces of
<i>perlmain.c</i> to see how Perl does this:</p>

<p style="margin-left:11%; margin-top: 1em">static void
xs_init (pTHX); <br>
EXTERN_C void boot_DynaLoader (pTHX_ CV* cv); <br>
EXTERN_C void boot_Socket (pTHX_ CV* cv); <br>
EXTERN_C void <br>
xs_init(pTHX) <br>
{ <br>
char *file = __FILE__; <br>
/* DynaLoader is a special case */ <br>
newXS(&quot;DynaLoader::boot_DynaLoader&quot;,
boot_DynaLoader, file); <br>
newXS(&quot;Socket::bootstrap&quot;, boot_Socket, file);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Simply put: for
each extension linked with your Perl executable (determined
during its initial configuration on your computer or when
adding a new extension), a Perl subroutine is created to
incorporate the extension&rsquo;s routines. Normally, that
subroutine is named <b><i>Module::bootstrap()</i></b> and is
invoked when you say <i>use Module</i>. In turn, this hooks
into an <small>XSUB,</small> <i>boot_Module</i>, which
creates a Perl counterpart for each of the extension&rsquo;s
XSUBs. Don&rsquo;t worry about this part; leave that to the
<i>xsubpp</i> and extension authors. If your extension is
dynamically loaded, DynaLoader creates
<b><i>Module::bootstrap()</i></b> for you on the fly. In
fact, if you have a working DynaLoader then there is rarely
any need to link in any other extensions statically.</p>

<p style="margin-left:11%; margin-top: 1em">Once you have
this code, slap it into the second argument of
<b><i>perl_parse()</i></b>:</p>


<p style="margin-left:11%; margin-top: 1em">perl_parse(my_perl,
xs_init, argc, my_argv, NULL);</p>

<p style="margin-left:11%; margin-top: 1em">Then
compile:</p>

<p style="margin-left:11%; margin-top: 1em">% cc &minus;o
interp interp.c `perl &minus;MExtUtils::Embed &minus;e
ccopts &minus;e ldopts` <br>
% interp <br>
use Socket; <br>
use SomeDynamicallyLoadedModule; <br>
print &quot;Now I can use extensions!\n&quot;'</p>


<p style="margin-left:11%; margin-top: 1em"><b>ExtUtils::Embed</b>
can also automate writing the <i>xs_init</i> glue code.</p>

<p style="margin-left:11%; margin-top: 1em">% perl
&minus;MExtUtils::Embed &minus;e xsinit &minus;&minus;
&minus;o perlxsi.c <br>
% cc &minus;c perlxsi.c `perl &minus;MExtUtils::Embed
&minus;e ccopts` <br>
% cc &minus;c interp.c `perl &minus;MExtUtils::Embed
&minus;e ccopts` <br>
% cc &minus;o interp perlxsi.o interp.o `perl
&minus;MExtUtils::Embed &minus;e ldopts`</p>

<p style="margin-left:11%; margin-top: 1em">Consult perlxs,
perlguts, and perlapi for more details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
embedded Perl with <small>POSIX</small> locales</b> <br>
(See perllocale for information about these.) When a Perl
interpreter normally starts up, it tells the system it wants
to use the system&rsquo;s default locale. This is often, but
not necessarily, the &quot;C&quot; or &quot;
<small>POSIX&quot;</small> locale. Absent a
&quot;use&nbsp;locale&quot; within the perl code, this
mostly has no effect (but see &quot;Not within the scope of
&quot;use locale&quot;&quot; in perllocale). Also, there is
not a problem if the locale you want to use in your embedded
perl is the same as the system default. However, this
doesn&rsquo;t work if you have set up and want to use a
locale that isn&rsquo;t the system default one. Starting in
Perl v5.20, you can tell the embedded Perl interpreter that
the locale is already properly set up, and to skip doing its
own normal initialization. It skips if the environment
variable &quot;PERL_SKIP_LOCALE_INIT&quot; is set (even if
set to 0 or &quot;&quot;). A perl that has this capability
will define the C pre-processor symbol
&quot;HAS_SKIP_LOCALE_INIT&quot;. This allows code that has
to work with multiple Perl versions to do some sort of
work-around when confronted with an earlier Perl.</p>

<p style="margin-left:11%; margin-top: 1em">If your program
is using the <small>POSIX 2008</small> multi-thread locale
functionality, you should switch into the global locale and
set that up properly before starting the Perl interpreter.
It will then properly switch back to using the thread-safe
functions.</p>

<h2>Hiding Perl_
<a name="Hiding Perl_"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you
completely hide the short forms of the Perl public
<small>API,</small> add &minus;DPERL_NO_SHORT_NAMES to the
compilation flags. This means that for example instead of
writing</p>

<p style="margin-left:11%; margin-top: 1em">warn(&quot;%d
bottles of beer on the wall&quot;, bottlecount);</p>

<p style="margin-left:11%; margin-top: 1em">you will have
to write the explicit full form</p>


<p style="margin-left:11%; margin-top: 1em">Perl_warn(aTHX_
&quot;%d bottles of beer on the wall&quot;,
bottlecount);</p>

<p style="margin-left:11%; margin-top: 1em">(See
&quot;Background and <small>MULTIPLICITY&quot;</small> in
perlguts for the explanation of the &quot;aTHX_&quot;. )
Hiding the short forms is very useful for avoiding all sorts
of nasty (C preprocessor or otherwise) conflicts with other
software packages (Perl defines about 2400 APIs with these
short names, take or leave few hundred, so there certainly
is room for conflict.)</p>

<h2>MORAL
<a name="MORAL"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You can
sometimes <i>write faster code</i> in C, but you can always
<i>write code faster</i> in Perl. Because you can use each
from the other, combine them as you wish.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Jon Orwant
&lt;<i>orwant@media.mit.edu</i>&gt; and Doug MacEachern
&lt;<i>dougm@covalent.net</i>&gt;, with small contributions
from Tim Bunce, Tom Christiansen, Guy Decoux, Hallvard
Furuseth, Dov Grobgeld, and Ilya Zakharevich.</p>

<p style="margin-left:11%; margin-top: 1em">Doug MacEachern
has an article on embedding in Volume 1, Issue 4 of The Perl
Journal ( &lt;http://www.tpj.com/&gt; ). Doug is also the
developer of the most widely-used Perl embedding: the
mod_perl system (perl.apache.org), which embeds Perl in the
Apache web server. Oracle, Binary Evolution, ActiveState,
and Ben Sugars&rsquo;s nsapi_perl have used this model for
Oracle, Netscape and Internet Information Server Perl
plugins.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (C)
1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant. All
Rights Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This document
may be distributed under the same terms as Perl itself.</p>
<hr>
</body>
</html>
