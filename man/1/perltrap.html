<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLTRAP</title>

</head>
<body>
<h1>perltrap</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perltrap
&minus; Perl traps for the unwary</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The biggest
trap of all is forgetting to &quot;use warnings&quot; or use
the <b>&minus;w</b> switch; see warnings and
&quot;&minus;w&quot; in perlrun. The second biggest trap is
not making your entire program runnable under &quot;use
strict&quot;. The third biggest trap is not reading the list
of changes in this version of Perl; see perldelta.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Awk
Traps</b> <br>
Accustomed <b>awk</b> users should take special note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A Perl program executes only once, not once for each
input line. You can do an implicit loop with
&quot;&minus;n&quot; or &quot;&minus;p&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The English module, loaded via</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">use
English;</p>

<p style="margin-left:17%; margin-top: 1em">allows you to
refer to special variables (like $/) with names (like $RS),
as though they were in <b>awk</b>; see perlvar for
details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Semicolons are required after
all simple statements in Perl (except at the end of a
block). Newline is not a statement delimiter.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Curly brackets are required on &quot;if&quot;s and
&quot;while&quot;s.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Variables begin with &quot;$&quot;, &quot;@&quot; or
&quot;%&quot; in Perl.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Arrays index from 0. Likewise string positions in
<b>substr()</b> and <b>index()</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You have to decide whether your array has numeric or
string indices.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Hash values do not spring into existence upon mere
reference.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You have to decide whether you want to use string or
numeric comparisons.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Reading an input line does not split it for you. You get
to split it to an array yourself. And the <b>split()</b>
operator has different arguments than
<b>awk</b>&rsquo;s.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The current input line is normally in $_, not $0. It
generally does not have the newline stripped. ($0 is the
name of the program executed.) See perlvar.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>$&lt;<i>digit</i>&gt; does not refer to fields--it
refers to substrings matched by the last match pattern.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The <b>print()</b> statement does not add field and
record separators unless you set $, and &quot;$\&quot;. You
can set $OFS and $ORS if you&rsquo;re using the English
module.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You must open your files before you print to them.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The range operator is &quot;..&quot;, not comma. The
comma operator works as in C.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The match operator is &quot;=~&quot;, not &quot;~&quot;.
(&quot;~&quot; is the one&rsquo;s complement operator, as in
C.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The exponentiation operator is &quot;**&quot;, not
&quot;^&quot;. &quot;^&quot; is the <small>XOR</small>
operator, as in C. (You know, one could get the feeling that
<b>awk</b> is basically incompatible with C.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The concatenation operator is &quot;.&quot;, not the
null string. (Using the null string would render &quot;/pat/
/pat/&quot; unparsable, because the third slash would be
interpreted as a division operator--the tokenizer is in fact
slightly context sensitive for operators like &quot;/&quot;,
&quot;?&quot;, and &quot;&gt;&quot;. And in fact,
&quot;.&quot; itself can be the beginning of a number.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The &quot;next&quot;, &quot;exit&quot;, and
&quot;continue&quot; keywords work differently.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The following variables work differently:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Awk Perl <br>
ARGC scalar @ARGV (compare with $#ARGV) <br>
ARGV[0] $0 <br>
FILENAME $ARGV <br>
FNR $. &minus; something <br>
FS (whatever you like) <br>
NF $#Fld, or some such <br>
NR $. <br>
OFMT $# <br>
OFS $, <br>
ORS $\ <br>
RLENGTH length($&amp;) <br>
RS $/ <br>
RSTART length($`) <br>
SUBSEP $;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">You cannot set $RS to a pattern,
only a string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>When in doubt, run the <b>awk</b> construct through
<b>a2p</b> and see what it gives you.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>C/C
<small>++</small> Traps</b> <br>
Cerebral C and C <small>++</small> programmers should take
note of the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Curly brackets are required on
&quot;if&quot;&rsquo;s and &quot;while&quot;&rsquo;s.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You must use &quot;elsif&quot; rather than &quot;else
if&quot;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The &quot;break&quot; and &quot;continue&quot; keywords
from C become in Perl &quot;last&quot; and &quot;next&quot;,
respectively. Unlike in C, these do <i>not</i> work within a
&quot;do { } while&quot; construct. See &quot;Loop
Control&quot; in perlsyn.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The switch statement is called
&quot;given&quot;/&quot;when&quot; and only available in
perl 5.10 or newer. See &quot;Switch Statements&quot; in
perlsyn.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Variables begin with &quot;$&quot;, &quot;@&quot; or
&quot;%&quot; in Perl.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Comments begin with &quot;#&quot;, not &quot;/*&quot; or
&quot;//&quot;. Perl may interpret C/C <small>++</small>
comments as division operators, unterminated regular
expressions or the defined-or operator.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You can&rsquo;t take the address of anything, although a
similar operator in Perl is the backslash, which creates a
reference.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>&quot;ARGV&quot; must be capitalized. $ARGV[0] is
C&rsquo;s &quot;argv[1]&quot;, and &quot;argv[0]&quot; ends
up in $0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>System calls such as <b>link()</b>, <b>unlink()</b>,
<b>rename()</b>, etc. return nonzero for success, not 0.
(<b>system()</b>, however, returns zero for success.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Signal handlers deal with signal names, not numbers. Use
&quot;kill &minus;l&quot; to find their names on your
system.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>JavaScript
Traps</b> <br>
Judicious JavaScript programmers should take note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">In Perl, binary &quot;+&quot; is
always addition. &quot;$string1 + $string2&quot; converts
both strings to numbers and then adds them. To concatenate
two strings, use the &quot;.&quot; operator.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The &quot;+&quot; unary operator doesn&rsquo;t do
anything in Perl. It exists to avoid syntactic
ambiguities.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Unlike &quot;for...in&quot;, Perl&rsquo;s
&quot;for&quot; (also spelled &quot;foreach&quot;) does not
allow the left-hand side to be an arbitrary expression. It
must be a variable:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">for my
$variable (keys %hash) { <br>
... <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">Furthermore,
don&rsquo;t forget the &quot;keys&quot; in there, as
&quot;foreach my $kv (%hash) {}&quot; iterates over the keys
and values, and is generally not useful ($kv would be a key,
then a value, and so on).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">To iterate over the indices of
an array, use &quot;foreach my $i (0 .. $#array) {}&quot;.
&quot;foreach my $v (@array) {}&quot; iterates over the
values.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Perl requires braces following &quot;if&quot;,
&quot;while&quot;, &quot;foreach&quot;, etc.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>In Perl, &quot;else if&quot; is spelled
&quot;elsif&quot;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>&quot;? :&quot; has higher precedence than assignment.
In JavaScript, one can write:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">condition ?
do_something() : variable = 3</p>

<p style="margin-left:17%; margin-top: 1em">and the
variable is only assigned if the condition is false. In
Perl, you need parentheses:</p>

<p style="margin-left:17%; margin-top: 1em">$condition ?
do_something() : ($variable = 3);</p>

<p style="margin-left:17%; margin-top: 1em">Or just use
&quot;if&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Perl requires semicolons to
separate statements.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Variables declared with &quot;my&quot; only affect code
<i>after</i> the declaration. You cannot write &quot;$x = 1;
my $x;&quot; and expect the first assignment to affect the
same variable. It will instead assign to an $x declared
previously in an outer scope, or to a global variable.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Note also that
the variable is not visible until the following
<i>statement</i>. This means that in &quot;my $x = 1 +
$x&quot; the second $x refers to one declared
previously.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">&quot;my&quot; variables are
scoped to the current block, not to the current function. If
you write &quot;{my $x;} $x;&quot;, the second $x does not
refer to the one declared inside the block.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>An object&rsquo;s members cannot be made accessible as
variables. The closest Perl equivalent to &quot;with(object)
{ method() }&quot; is &quot;for&quot;, which can alias $_ to
the object:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">for ($object) {
<br>
$_&minus;&gt;method; <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The object or class on which a
method is called is passed as one of the method&rsquo;s
arguments, not as a separate &quot;this&quot; value.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Sed
Traps</b> <br>
Seasoned <b>sed</b> programmers should take note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">A Perl program executes only
once, not once for each input line. You can do an implicit
loop with &quot;&minus;n&quot; or &quot;&minus;p&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Backreferences in substitutions use &quot;$&quot; rather
than &quot;\&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The pattern matching metacharacters &quot;(&quot;,
&quot;)&quot;, and &quot;|&quot; do not have backslashes in
front.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The range operator is &quot;...&quot;, rather than
comma.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Shell
Traps</b> <br>
Sharp shell programmers should take note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The backtick operator does
variable interpolation without regard to the presence of
single quotes in the command.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The backtick operator does no translation of the return
value, unlike <b>csh</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Shells (especially <b>csh</b>) do several levels of
substitution on each command line. Perl does substitution in
only certain constructs such as double quotes, backticks,
angle brackets, and search patterns.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Shells interpret scripts a little bit at a time. Perl
compiles the entire program before executing it (except for
&quot;BEGIN&quot; blocks, which execute at compile
time).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The arguments are available via @ARGV, not $1, $2,
etc.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The environment is not automatically made available as
separate scalar variables.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The shell&rsquo;s &quot;test&quot; uses &quot;=&quot;,
&quot;!=&quot;, &quot;&lt;&quot; etc for string comparisons
and &quot;&minus;eq&quot;, &quot;&minus;ne&quot;,
&quot;&minus;lt&quot; etc for numeric comparisons. This is
the reverse of Perl, which uses &quot;eq&quot;,
&quot;ne&quot;, &quot;lt&quot; for string comparisons, and
&quot;==&quot;, &quot;!=&quot; &quot;&lt;&quot; etc for
numeric comparisons.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Perl
Traps</b> <br>
Practicing Perl Programmers should take note of the
following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Remember that many operations
behave differently in a list context than they do in a
scalar one. See perldata for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Avoid barewords if you can, especially all lowercase
ones. You can&rsquo;t tell by just looking at it whether a
bareword is a function or a string. By using quotes on
strings and parentheses on function calls, you won&rsquo;t
ever get them confused.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You cannot discern from mere inspection which builtins
are unary operators (like <b>chop()</b> and <b>chdir()</b>)
and which are list operators (like <b>print()</b> and
<b>unlink()</b>). (Unless prototyped, user-defined
subroutines can <b>only</b> be list operators, never unary
ones.) See perlop and perlsub.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>People have a hard time remembering that some functions
default to $_, or @ARGV, or whatever, but that others which
you might expect to do not.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The &lt; <small>FH</small> &gt; construct is not the
name of the filehandle, it is a readline operation on that
handle. The data read is assigned to $_ only if the file
read is the sole condition in a while loop:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">while
(&lt;FH&gt;) { } <br>
while (defined($_ = &lt;FH&gt;)) { }.. <br>
&lt;FH&gt;; # data discarded!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Remember not to use
&quot;=&quot; when you need &quot;=~&quot;; these two
constructs are quite different:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">$x = /foo/;
<br>
$x =~ /foo/;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The &quot;do {}&quot; construct
isn&rsquo;t a real loop that you can use loop control
on.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Use &quot;my()&quot; for local variables whenever you
can get away with it (but see perlform for where you
can&rsquo;t). Using &quot;local()&quot; actually gives a
local value to a global variable, which leaves you open to
unforeseen side-effects of dynamic scoping.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If you localize an exported variable in a module, its
exported value will not change. The local name becomes an
alias to a new value but the external name is still an alias
for the original.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">As always, if
any of these are ever officially declared as bugs,
they&rsquo;ll be fixed and removed.</p>
<hr>
</body>
</html>
