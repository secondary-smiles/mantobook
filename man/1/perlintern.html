<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLINTERN</title>

</head>
<body>
<h1>perlintern</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlintern
&minus; autogenerated documentation of purely internal Perl
functions</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This file is
the autogenerated documentation of functions in the Perl
interpreter that are documented using Perl&rsquo;s internal
documentation format but are not marked as part of the Perl
<small>API.</small> In other words, <b>they are not for use
in extensions</b>!</p>

<p style="margin-left:11%; margin-top: 1em">It has the same
sections as perlapi, though some may be empty.</p>

<h2>AV Handling
<a name="AV Handling"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;av_fetch_simple&quot;</p>

<p style="margin-left:17%;">This is a cut-down version of
av_fetch that assumes that the array is very straightforward
&minus; no magic, not readonly, and AvREAL &minus; and that
&quot;key&quot; is not negative. This function <small>MUST
NOT</small> be used in situations where any of those
assumptions may not hold.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
<small>SV</small> at the specified index in the array. The
&quot;key&quot; is the index. If lval is true, you are
guaranteed to get a real <small>SV</small> back (in case it
wasn&rsquo;t real before), which you can then modify. Check
that the return value is non-null before dereferencing it to
a &quot;SV*&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The rough perl
equivalent is $myarray[$key].</p>

<p style="margin-left:17%; margin-top: 1em">SV**
av_fetch_simple(AV *av, SSize_t key, I32 lval)</p>

<p style="margin-left:11%;">&quot;AvFILLp&quot;</p>

<p style="margin-left:17%;">If the array &quot;av&quot; is
empty, this returns &minus;1; otherwise it returns the
maximum value of the indices of all the array elements which
are currently defined in &quot;av&quot;. It does not handle
magic, hence the &quot;p&quot; private indication in its
name.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
AvFILLp(AV* av)</p>

<p style="margin-left:11%;">&quot;av_new_alloc&quot;</p>

<p style="margin-left:17%;">This implements
&quot;&quot;newAV_alloc_x&quot;&quot; in perlapi and
&quot;&quot;newAV_alloc_xz&quot;&quot; in perlapi, which are
the public <small>API</small> for this functionality.</p>

<p style="margin-left:17%; margin-top: 1em">Creates a new
<small>AV</small> and allocates its SV* array.</p>

<p style="margin-left:17%; margin-top: 1em">This is similar
to, but more efficient than doing:</p>

<p style="margin-left:17%; margin-top: 1em">AV *av =
newAV(); <br>
av_extend(av, key);</p>

<p style="margin-left:17%; margin-top: 1em">The size
parameter is used to pre-allocate a SV* array large enough
to hold at least elements &quot;0..(size&minus;1)&quot;.
&quot;size&quot; must be at least 1.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;zeroflag&quot; parameter controls whether or not the
array is <small>NULL</small> initialized.</p>

<p style="margin-left:17%; margin-top: 1em">AV*
av_new_alloc(SSize_t size, bool zeroflag)</p>


<p style="margin-left:11%;">&quot;av_store_simple&quot;</p>

<p style="margin-left:17%;">This is a cut-down version of
av_store that assumes that the array is very straightforward
&minus; no magic, not readonly, and AvREAL &minus; and that
&quot;key&quot; is not negative. This function <small>MUST
NOT</small> be used in situations where any of those
assumptions may not hold.</p>

<p style="margin-left:17%; margin-top: 1em">Stores an
<small>SV</small> in an array. The array index is specified
as &quot;key&quot;. It can be dereferenced to get the
&quot;SV*&quot; that was stored there (=
&quot;val&quot;)).</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
caller is responsible for suitably incrementing the
reference count of &quot;val&quot; before the call.</p>

<p style="margin-left:17%; margin-top: 1em">Approximate
Perl equivalent: &quot;splice(@myarray, $key, 1,
$val)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV**
av_store_simple(AV *av, SSize_t key, SV *val)</p>

<h2>Callback Functions
<a name="Callback Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;dowantarray&quot;</p>

<p style="margin-left:17%;">Implements the deprecated
&quot;&quot;GIMME&quot;&quot; in perlapi.</p>

<p style="margin-left:17%; margin-top: 1em">U8
dowantarray()</p>

<p style="margin-left:11%;">&quot;leave_scope&quot;</p>

<p style="margin-left:17%;">Implements
&quot;LEAVE_SCOPE&quot; which you should use instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
leave_scope(I32 base)</p>

<p style="margin-left:11%;">&quot;pop_scope&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;LEAVE&quot;&quot; in perlapi</p>

<p style="margin-left:17%; margin-top: 1em">void
pop_scope()</p>

<p style="margin-left:11%;">&quot;push_scope&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;ENTER&quot;&quot; in perlapi</p>

<p style="margin-left:17%; margin-top: 1em">void
push_scope()</p>

<p style="margin-left:11%;">&quot;save_adelete&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVEADELETE&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_adelete(AV *av, SSize_t key)</p>


<p style="margin-left:11%;">&quot;save_generic_pvref&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVEGENERICPV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Like
<b>save_pptr()</b>, but also <b>Safefree()</b>s the new
value if it is different from the old one. Can be used to
restore a global char* to its prior contents, freeing new
value.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_generic_pvref(char** str)</p>


<p style="margin-left:11%;">&quot;save_generic_svref&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVEGENERICSV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Like
<b>save_sptr()</b>, but also <b>SvREFCNT_dec()</b>s the new
value. Can be used to restore a global <small>SV</small> to
its prior contents, freeing new value.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_generic_svref(SV** sptr)</p>

<p style="margin-left:11%;">&quot;save_hdelete&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVEHDELETE&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_hdelete(HV *hv, SV *keysv)</p>

<p style="margin-left:11%;">&quot;save_hints&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVEHINTS&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_hints()</p>

<p style="margin-left:11%;">&quot;save_op&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVEOP&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_op()</p>


<p style="margin-left:11%;">&quot;save_padsv_and_mortalize&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVEPADSVANDMORTALIZE&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_padsv_and_mortalize(PADOFFSET off)</p>


<p style="margin-left:11%;">&quot;save_set_svflags&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVESETSVFLAGS&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Set the SvFLAGS
specified by mask to the values in val</p>

<p style="margin-left:17%; margin-top: 1em">void
save_set_svflags(SV *sv, U32 mask, U32 val)</p>


<p style="margin-left:11%;">&quot;save_shared_pvref&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVESHAREDPV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Like
<b>save_generic_pvref()</b>, but uses
<b>PerlMemShared_free()</b> rather than <b>Safefree()</b>.
Can be used to restore a shared global char* to its prior
contents, freeing new value.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_shared_pvref(char** str)</p>

<p style="margin-left:11%;">&quot;save_vptr&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SAVEVPTR&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_vptr(void *ptr)</p>

<h2>Casting
<a name="Casting"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Casting</p>

<h2>Character case changing
<a name="Character case changing"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Character case
changing</p>

<h2>Character classification
<a name="Character classification"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Character
classification</p>

<h2>Compiler and Preprocessor information
<a name="Compiler and Preprocessor information"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Compiler and
Preprocessor information</p>

<h2>Compiler directives
<a name="Compiler directives"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Compiler
directives</p>

<h2>Compile-time scope hooks
<a name="Compile-time scope hooks"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;BhkENTRY&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;BhkENTRY&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Return an entry
from the <small>BHK</small> structure. &quot;which&quot; is
a preprocessor token indicating which entry to return. If
the appropriate flag is not set this will return
&quot;NULL&quot;. The type of the return value depends on
which entry you ask for.</p>

<p style="margin-left:17%; margin-top: 1em">void *
BhkENTRY(BHK *hk, which)</p>

<p style="margin-left:11%;">&quot;BhkFLAGS&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;BhkFLAGS&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Return the
<small>BHK</small> &rsquo;s flags.</p>

<p style="margin-left:17%; margin-top: 1em">U32
BhkFLAGS(BHK *hk)</p>


<p style="margin-left:11%;">&quot;CALL_BLOCK_HOOKS&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;CALL_BLOCK_HOOKS&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Call all the
registered block hooks for type &quot;which&quot;.
&quot;which&quot; is a preprocessing token; the type of
&quot;arg&quot; depends on &quot;which&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
CALL_BLOCK_HOOKS(which, arg)</p>

<h2>Concurrency
<a name="Concurrency"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;CVf_SLABBED&quot;
<br>
&quot;CvROOT&quot; <br>
&quot;CvSTART&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;CX_CUR&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">CX_CUR()</p>

<p style="margin-left:11%;">&quot;CXINC&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;CX_LEAVE_SCOPE&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
CX_LEAVE_SCOPE(PERL_CONTEXT* cx)</p>

<p style="margin-left:11%;">&quot;CX_POP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
CX_POP(PERL_CONTEXT* cx)</p>

<p style="margin-left:11%;">&quot;cxstack&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;cxstack_ix&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;CXt_BLOCK&quot; <br>
&quot;CXt_EVAL&quot; <br>
&quot;CXt_FORMAT&quot; <br>
&quot;CXt_GIVEN&quot; <br>
&quot;CXt_LOOP_ARY&quot; <br>
&quot;CXt_LOOP_LAZYIV&quot; <br>
&quot;CXt_LOOP_LAZYSV&quot; <br>
&quot;CXt_LOOP_LIST&quot; <br>
&quot;CXt_LOOP_PLAIN&quot; <br>
&quot;CXt_NULL&quot; <br>
&quot;CXt_SUB&quot; <br>
&quot;CXt_SUBST&quot; <br>
&quot;CXt_WHEN&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;cx_type&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;dounwind&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
dounwind(I32 cxix)</p>

<p style="margin-left:11%;">&quot;my_fork&quot;</p>

<p style="margin-left:17%;">This is for the use of
&quot;PerlProc_fork&quot; as a wrapper for the C library
<b>fork</b>(2) on some platforms to hide some platform
quirks. It should not be used except through
&quot;PerlProc_fork&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Pid_t
my_fork()</p>

<p style="margin-left:11%;">&quot;PERL_CONTEXT&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<h2>COPs and Hint Hashes
<a name="COPs and Hint Hashes"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in COPs and Hint
Hashes</p>

<h2>Custom Operators
<a name="Custom Operators"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;core_prototype&quot;</p>

<p style="margin-left:17%;">This function assigns the
prototype of the named core function to &quot;sv&quot;, or
to a new mortal <small>SV</small> if &quot;sv&quot; is
&quot;NULL&quot;. It returns the modified &quot;sv&quot;, or
&quot;NULL&quot; if the core function has no prototype.
&quot;code&quot; is a code as returned by
&quot;keyword()&quot;. It must not be equal to 0.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
core_prototype(SV *sv, const char *name, const int code,
<br>
int * const opnum)</p>

<h2>CV Handling
<a name="CV Handling"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;CvWEAKOUTSIDE&quot;</p>

<p style="margin-left:17%;">Each <small>CV</small> has a
pointer, &quot;CvOUTSIDE()&quot;, to its lexically enclosing
<small>CV</small> (if any). Because pointers to anonymous
sub prototypes are stored in &quot;&amp;&quot; pad slots, it
is a possible to get a circular reference, with the parent
pointing to the child and vice-versa. To avoid the ensuing
memory leak, we do not increment the reference count of the
<small>CV</small> pointed to by &quot;CvOUTSIDE&quot; in the
<i>one specific instance</i> that the parent has a
&quot;&amp;&quot; pad slot pointing back to us. In this
case, we set the &quot;CvWEAKOUTSIDE&quot; flag in the
child. This allows us to determine under what circumstances
we should decrement the refcount of the parent when freeing
the child.</p>

<p style="margin-left:17%; margin-top: 1em">There is a
further complication with non-closure anonymous subs (i.e.
those that do not refer to any lexicals outside that sub).
In this case, the anonymous prototype is shared rather than
being cloned. This has the consequence that the parent may
be freed while there are still active children,
<i>e.g.</i>,</p>

<p style="margin-left:17%; margin-top: 1em">BEGIN { $a =
sub { eval '$x' } }</p>

<p style="margin-left:17%; margin-top: 1em">In this case,
the <small>BEGIN</small> is freed immediately after
execution since there are no active references to it: the
anon sub prototype has &quot;CvWEAKOUTSIDE&quot; set since
it&rsquo;s not a closure, and $a points to the same
<small>CV,</small> so it doesn&rsquo;t contribute to
<small>BEGIN</small> &rsquo;s refcount either. When $a is
executed, the &quot;eval '$x'&quot; causes the chain of
&quot;CvOUTSIDE&quot;s to be followed, and the freed
<small>BEGIN</small> is accessed.</p>

<p style="margin-left:17%; margin-top: 1em">To avoid this,
whenever a <small>CV</small> and its associated pad is
freed, any &quot;&amp;&quot; entries in the pad are
explicitly removed from the pad, and if the refcount of the
pointed-to anon sub is still positive, then that
child&rsquo;s &quot;CvOUTSIDE&quot; is set to point to its
grandparent. This will only occur in the single specific
case of a non-closure anon prototype having one or more
active references (such as $a above).</p>

<p style="margin-left:17%; margin-top: 1em">One other thing
to consider is that a <small>CV</small> may be merely
undefined rather than freed, eg &quot;undef &amp;foo&quot;.
In this case, its refcount may not have reached zero, but we
still delete its pad and its &quot;CvROOT&quot; etc. Since
various children may still have their &quot;CvOUTSIDE&quot;
pointing at this undefined <small>CV,</small> we keep its
own &quot;CvOUTSIDE&quot; for the time being, so that the
chain of lexical scopes is unbroken. For example, the
following should print 123:</p>

<p style="margin-left:17%; margin-top: 1em">my $x = 123;
<br>
sub tmp { sub { eval '$x' } } <br>
my $a = tmp(); <br>
undef &amp;tmp; <br>
print $a&minus;&gt;();</p>

<p style="margin-left:17%; margin-top: 1em">bool
CvWEAKOUTSIDE(CV *cv)</p>

<p style="margin-left:11%;">&quot;docatch&quot;</p>

<p style="margin-left:17%;">Check for the cases 0 or 3 of
cur_env.je_ret, only used inside an eval context.</p>

<p style="margin-left:17%; margin-top: 1em">0 is used as
continue inside eval,</p>

<p style="margin-left:17%; margin-top: 1em">3 is used for a
die caught by an inner eval &minus; continue inner loop</p>

<p style="margin-left:17%; margin-top: 1em">See
<i>cop.h</i>: je_mustcatch, when set at any runlevel to
<small>TRUE,</small> means eval ops must establish a local
jmpenv to handle exception traps.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
docatch(Perl_ppaddr_t firstpp)</p>

<h2>Debugging
<a name="Debugging"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;_aDEPTH&quot;</p>

<p style="margin-left:17%;">Some functions when compiled
under <small>DEBUGGING</small> take an extra final argument
named &quot;depth&quot;, indicating the C stack depth. This
argument is omitted otherwise. This macro expands to either
&quot;,&nbsp;depth&quot; under <small>DEBUGGING,</small> or
to nothing at all when not under <small>DEBUGGING,</small>
reducing the number of &quot;#ifdef&quot;&rsquo;s in the
code.</p>

<p style="margin-left:17%; margin-top: 1em">The program is
responsible for maintaining the correct value for
&quot;depth&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">_aDEPTH</p>

<p style="margin-left:11%;">&quot;debop&quot;</p>

<p style="margin-left:17%;">Implements <b>&minus;Dt</b>
perl command line option on <small>OP</small>
&quot;o&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32 debop(const
OP* o)</p>

<p style="margin-left:11%;">&quot;debprof&quot;</p>

<p style="margin-left:17%;">Called to indicate that
&quot;o&quot; was executed, for profiling purposes under the
&quot;&minus;DP&quot; command line option.</p>

<p style="margin-left:17%; margin-top: 1em">void
debprof(const OP *o)</p>

<p style="margin-left:11%;">&quot;debprofdump&quot;</p>

<p style="margin-left:17%;">Dumps the contents of the data
collected by the &quot;&minus;DP&quot; perl command line
option.</p>

<p style="margin-left:17%; margin-top: 1em">void
debprofdump()</p>


<p style="margin-left:11%;">&quot;free_c_backtrace&quot;</p>

<p style="margin-left:17%;">Deallocates a backtrace
received from get_c_backtrace.</p>

<p style="margin-left:17%; margin-top: 1em">void
free_c_backtrace(Perl_c_backtrace* bt)</p>


<p style="margin-left:11%;">&quot;get_c_backtrace&quot;</p>

<p style="margin-left:17%;">Collects the backtrace (aka
&quot;stacktrace&quot;) into a single linear malloced
buffer, which the caller <b>must</b>
&quot;Perl_free_c_backtrace()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Scans the
frames back by &quot;depth&nbsp;+&nbsp;skip&quot;, then
drops the &quot;skip&quot; innermost, returning at most
&quot;depth&quot; frames.</p>


<p style="margin-left:17%; margin-top: 1em">Perl_c_backtrace*
get_c_backtrace(int max_depth, int skip)</p>

<p style="margin-left:11%;">&quot;_pDEPTH&quot;</p>

<p style="margin-left:17%;">This is used in the prototype
declarations for functions that take a
&quot;&quot;_aDEPTH&quot;&quot; final parameter, much like
&quot;pTHX_&quot; is used in functions that take a thread
context initial parameter.</p>

<p style="margin-left:11%;">&quot;PL_DBsingle&quot;</p>

<p style="margin-left:17%;">When Perl is run in debugging
mode, with the <b>&minus;d</b> switch, this
<small>SV</small> is a boolean which indicates whether subs
are being single-stepped. Single-stepping is automatically
turned on after every step. This is the C variable which
corresponds to Perl&rsquo;s $DB::single variable. See
&quot;PL_DBsub&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
PL_DBsingle</p>

<p style="margin-left:11%;">&quot;PL_DBsub&quot;</p>

<p style="margin-left:17%;">When Perl is run in debugging
mode, with the <b>&minus;d</b> switch, this
<small>GV</small> contains the <small>SV</small> which holds
the name of the sub being debugged. This is the C variable
which corresponds to Perl&rsquo;s $DB::sub variable. See
&quot;PL_DBsingle&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">GV *
PL_DBsub</p>

<p style="margin-left:11%;">&quot;PL_DBtrace&quot;</p>

<p style="margin-left:17%;">Trace variable used when Perl
is run in debugging mode, with the <b>&minus;d</b> switch.
This is the C variable which corresponds to Perl&rsquo;s
$DB::trace variable. See &quot;PL_DBsingle&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
PL_DBtrace</p>

<p style="margin-left:11%;">&quot;runops_debug&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">int
runops_debug()</p>


<p style="margin-left:11%;">&quot;runops_standard&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">int
runops_standard()</p>

<h2>Display functions
<a name="Display functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;sv_peek&quot;</p>

<p style="margin-left:17%;">Implements
&quot;SvPEEK&quot;</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_peek(SV* sv)</p>

<h2>Embedding, Threads, and Interpreter Cloning
<a name="Embedding, Threads, and Interpreter Cloning"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;cv_dump&quot;</p>

<p style="margin-left:17%;">dump the contents of a
<small>CV</small></p>

<p style="margin-left:17%; margin-top: 1em">void
cv_dump(const CV *cv, const char *title)</p>

<p style="margin-left:11%;">&quot;cv_forget_slab&quot;</p>

<p style="margin-left:17%;">When a <small>CV</small> has a
reference count on its slab (&quot;CvSLABBED&quot;), it is
responsible for making sure it is freed. (Hence, no two CVs
should ever have a reference count on the same slab.) The
<small>CV</small> only needs to reference the slab during
compilation. Once it is compiled and &quot;CvROOT&quot;
attached, it has finished its job, so it can forget the
slab.</p>

<p style="margin-left:17%; margin-top: 1em">void
cv_forget_slab(CV *cv)</p>

<p style="margin-left:11%;">&quot;do_dump_pad&quot;</p>

<p style="margin-left:17%;">Dump the contents of a
padlist</p>

<p style="margin-left:17%; margin-top: 1em">void
do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist, <br>
int full)</p>

<p style="margin-left:11%;">&quot;get_context&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;PERL_GET_CONTEXT&quot;&quot; in perlapi, which
you should use instead.</p>

<p style="margin-left:17%; margin-top: 1em">void*
get_context()</p>

<p style="margin-left:11%;">&quot;pad_alloc_name&quot;</p>

<p style="margin-left:17%;">Allocates a place in the
currently-compiling pad (via &quot;pad_alloc&quot; in
perlapi) and then stores a name for that entry.
&quot;name&quot; is adopted and becomes the name entry; it
must already contain the name string. &quot;typestash&quot;
and &quot;ourstash&quot; and the &quot;padadd_STATE&quot;
flag get added to &quot;name&quot;. None of the other
processing of &quot;pad_add_name_pvn&quot; in perlapi is
done. Returns the offset of the allocated pad slot.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_alloc_name(PADNAME *name, U32 flags, HV *typestash, <br>
HV *ourstash)</p>


<p style="margin-left:11%;">&quot;pad_block_start&quot;</p>

<p style="margin-left:17%;">Update the pad compilation
state variables on entry to a new block.</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_block_start(int full)</p>

<p style="margin-left:11%;">&quot;pad_check_dup&quot;</p>

<p style="margin-left:17%;">Check for duplicate
declarations: report any of:</p>

<p style="margin-left:17%; margin-top: 1em">* a 'my' in the
current scope with the same name; <br>
* an 'our' (anywhere in the pad) with the same name and the
<br>
same stash as 'ourstash'</p>


<p style="margin-left:17%; margin-top: 1em">&quot;is_our&quot;
indicates that the name to check is an &quot;our&quot;
declaration.</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_check_dup(PADNAME *name, U32 flags, const HV
*ourstash)</p>

<p style="margin-left:11%;">&quot;pad_findlex&quot;</p>

<p style="margin-left:17%;">Find a named lexical anywhere
in a chain of nested pads. Add fake entries in the inner
pads if it&rsquo;s found in an outer one.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
offset in the bottom pad of the lex or the fake lex.
&quot;cv&quot; is the <small>CV</small> in which to start
the search, and seq is the current &quot;cop_seq&quot; to
match against. If &quot;warn&quot; is true, print
appropriate warnings. The &quot;out_&quot;* vars return
values, and so are pointers to where the returned values
should be stored. &quot;out_capture&quot;, if non-null,
requests that the innermost instance of the lexical is
captured; &quot;out_name&quot; is set to the innermost
matched pad name or fake pad name; &quot;out_flags&quot;
returns the flags normally associated with the
&quot;PARENT_FAKELEX_FLAGS&quot; field of a fake pad
name.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;pad_findlex()&quot; is recursive; it recurses up the
chain of CVs, then comes back down, adding fake entries as
it goes. It has to be this way because fake names in anon
prototypes have to store in &quot;xpadn_low&quot; the index
into the parent pad.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_findlex(const char *namepv, STRLEN namelen, <br>
U32 flags, const CV* cv, U32 seq, int warn, <br>
SV** out_capture, PADNAME** out_name, <br>
int *out_flags)</p>


<p style="margin-left:11%;">&quot;pad_fixup_inner_anons&quot;</p>

<p style="margin-left:17%;">For any anon CVs in the pad,
change &quot;CvOUTSIDE&quot; of that <small>CV</small> from
&quot;old_cv&quot; to &quot;new_cv&quot; if necessary.
Needed when a newly-compiled <small>CV</small> has to be
moved to a pre-existing <small>CV</small> struct.</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv, <br>
CV *new_cv)</p>

<p style="margin-left:11%;">&quot;pad_free&quot;</p>

<p style="margin-left:17%;">Free the <small>SV</small> at
offset po in the current pad.</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_free(PADOFFSET po)</p>

<p style="margin-left:11%;">&quot;pad_leavemy&quot;</p>

<p style="margin-left:17%;">Cleanup at end of scope during
compilation: set the max seq number for lexicals in this
scope and warn of any lexicals that never got
introduced.</p>

<p style="margin-left:17%; margin-top: 1em">OP *
pad_leavemy()</p>

<p style="margin-left:11%;">&quot;padlist_dup&quot;</p>

<p style="margin-left:17%;">Duplicates a pad.</p>

<p style="margin-left:17%; margin-top: 1em">PADLIST *
padlist_dup(PADLIST *srcpad, CLONE_PARAMS *param)</p>

<p style="margin-left:11%;">&quot;padname_dup&quot;</p>

<p style="margin-left:17%;">Duplicates a pad name.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAME *
padname_dup(PADNAME *src, CLONE_PARAMS *param)</p>


<p style="margin-left:11%;">&quot;padnamelist_dup&quot;</p>

<p style="margin-left:17%;">Duplicates a pad name list.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAMELIST *
padnamelist_dup(PADNAMELIST *srcpad, <br>
CLONE_PARAMS *param)</p>

<p style="margin-left:11%;">&quot;pad_push&quot;</p>

<p style="margin-left:17%;">Push a new pad frame onto the
padlist, unless there&rsquo;s already a pad at this depth,
in which case don&rsquo;t bother creating a new one. Then
give the new pad an @_ in slot zero.</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_push(PADLIST *padlist, int depth)</p>

<p style="margin-left:11%;">&quot;pad_reset&quot;</p>

<p style="margin-left:17%;">Mark all the current
temporaries for reuse</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_reset()</p>

<p style="margin-left:11%;">&quot;pad_setsv&quot;</p>

<p style="margin-left:17%;">Set the value at offset
&quot;po&quot; in the current (compiling or executing) pad.
Use the macro &quot;PAD_SETSV()&quot; rather than calling
this function directly.</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_setsv(PADOFFSET po, SV* sv)</p>

<p style="margin-left:11%;">&quot;pad_sv&quot;</p>

<p style="margin-left:17%;">Get the value at offset
&quot;po&quot; in the current (compiling or executing) pad.
Use macro &quot;PAD_SV&quot; instead of calling this
function directly.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
pad_sv(PADOFFSET po)</p>

<p style="margin-left:11%;">&quot;pad_swipe&quot;</p>

<p style="margin-left:17%;">Abandon the tmp in the current
pad at offset &quot;po&quot; and replace with a new one.</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_swipe(PADOFFSET po, bool refadjust)</p>

<p style="margin-left:11%;">&quot;set_context&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;PERL_SET_CONTEXT&quot;&quot; in perlapi, which
you should use instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
set_context(void *t)</p>

<h2>Errno
<a name="Errno"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;dSAVEDERRNO&quot;</p>

<p style="margin-left:17%;">Declare variables needed to
save &quot;errno&quot; and any operating system specific
error number.</p>

<p style="margin-left:17%; margin-top: 1em">void
dSAVEDERRNO</p>

<p style="margin-left:11%;">&quot;dSAVE_ERRNO&quot;</p>

<p style="margin-left:17%;">Declare variables needed to
save &quot;errno&quot; and any operating system specific
error number, and save them for optional later restoration
by &quot;RESTORE_ERRNO&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
dSAVE_ERRNO</p>

<p style="margin-left:11%;">&quot;RESTORE_ERRNO&quot;</p>

<p style="margin-left:17%;">Restore &quot;errno&quot; and
any operating system specific error number that was saved by
&quot;dSAVE_ERRNO&quot; or &quot;RESTORE_ERRNO&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
RESTORE_ERRNO</p>

<p style="margin-left:11%;">&quot;SAVE_ERRNO&quot;</p>

<p style="margin-left:17%;">Save &quot;errno&quot; and any
operating system specific error number for optional later
restoration by &quot;RESTORE_ERRNO&quot;. Requires
&quot;dSAVEDERRNO&quot; or &quot;dSAVE_ERRNO&quot; in
scope.</p>

<p style="margin-left:17%; margin-top: 1em">void
SAVE_ERRNO</p>

<p style="margin-left:11%;">&quot;SETERRNO&quot;</p>

<p style="margin-left:17%;">Set &quot;errno&quot;, and on
<small>VMS</small> set &quot;vaxc$errno&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SETERRNO(int errcode, int vmserrcode)</p>

<h2>Exception Handling (simple) Macros
<a name="Exception Handling (simple) Macros"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Exception
Handling (simple) Macros</p>

<h2>Filesystem configuration values
<a name="Filesystem configuration values"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Filesystem
configuration values</p>

<h2>Floating point
<a name="Floating point"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Floating
point</p>

<h2>General Configuration
<a name="General Configuration"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in General
Configuration</p>

<h2>Global Variables
<a name="Global Variables"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Global
Variables</p>

<h2>GV Handling and Stashes
<a name="GV Handling and Stashes"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;gp_dup&quot;</p>

<p style="margin-left:17%;">Duplicate a typeglob, returning
a pointer to the cloned object.</p>

<p style="margin-left:17%; margin-top: 1em">GP* gp_dup(GP
*const gp, CLONE_PARAMS *const param)</p>

<p style="margin-left:11%;">&quot;gv_handler&quot;</p>

<p style="margin-left:17%;">Implements
&quot;StashHANDLER&quot;, which you should use instead</p>

<p style="margin-left:17%; margin-top: 1em">CV*
gv_handler(HV* stash, I32 id)</p>


<p style="margin-left:11%;">&quot;gv_stashsvpvn_cached&quot;</p>

<p style="margin-left:17%;">Returns a pointer to the stash
for a specified package, possibly cached. Implements both
&quot;&quot;gv_stashpvn&quot;&quot; in perlapi and
&quot;&quot;gv_stashsv&quot;&quot; in perlapi.</p>

<p style="margin-left:17%; margin-top: 1em">Requires one of
either &quot;namesv&quot; or &quot;namepv&quot; to be
non-null.</p>

<p style="margin-left:17%; margin-top: 1em">If the flag
&quot;GV_CACHE_ONLY&quot; is set, return the stash only if
found in the cache; see &quot;&quot;gv_stashpvn&quot;&quot;
in perlapi for details on the other &quot;flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note it is
strongly preferred for &quot;namesv&quot; to be non-null,
for performance reasons.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
gv_stashsvpvn_cached(SV *namesv, const char* name, <br>
U32 namelen, I32 flags)</p>


<p style="margin-left:11%;">&quot;gv_try_downgrade&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;gv_try_downgrade&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">If the typeglob
&quot;gv&quot; can be expressed more succinctly, by having
something other than a real <small>GV</small> in its place
in the stash, replace it with the optimised form. Basic
requirements for this are that &quot;gv&quot; is a real
typeglob, is sufficiently ordinary, and is only referenced
from its package. This function is meant to be used when a
<small>GV</small> has been looked up in part to see what was
there, causing upgrading, but based on what was found it
turns out that the real <small>GV</small> isn&rsquo;t
required after all.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;gv&quot; is a completely empty typeglob, it is deleted
from the stash.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;gv&quot; is a typeglob containing only a
sufficiently-ordinary constant sub, the typeglob is replaced
with a scalar-reference placeholder that more compactly
represents the same thing.</p>

<p style="margin-left:17%; margin-top: 1em">void
gv_try_downgrade(GV* gv)</p>

<h2>Hook manipulation
<a name="Hook manipulation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Hook
manipulation</p>

<h2>HV Handling
<a name="HV Handling"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;hv_eiter_p&quot;</p>

<p style="margin-left:17%;">Implements &quot;HvEITER&quot;
which you should use instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;hv_eiter_p&quot; must be explicitly called as
&quot;Perl_hv_eiter_p&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">HE**
Perl_hv_eiter_p(pTHX_ HV *hv)</p>

<p style="margin-left:11%;">&quot;hv_eiter_set&quot;</p>

<p style="margin-left:17%;">Implements
&quot;HvEITER_set&quot; which you should use instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;hv_eiter_set&quot; must be explicitly called as
&quot;Perl_hv_eiter_set&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_hv_eiter_set(pTHX_ HV *hv, HE *eiter)</p>

<p style="margin-left:11%;">&quot;hv_ename_add&quot;</p>

<p style="margin-left:17%;">Adds a name to a stash&rsquo;s
internal list of effective names. See
&quot;hv_ename_delete&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This is called
when a stash is assigned to a new location in the symbol
table.</p>

<p style="margin-left:17%; margin-top: 1em">void
hv_ename_add(HV *hv, const char *name, U32 len, U32
flags)</p>


<p style="margin-left:11%;">&quot;hv_ename_delete&quot;</p>

<p style="margin-left:17%;">Removes a name from a
stash&rsquo;s internal list of effective names. If this is
the name returned by &quot;HvENAME&quot;, then another name
in the list will take its place (&quot;HvENAME&quot; will
use it).</p>

<p style="margin-left:17%; margin-top: 1em">This is called
when a stash is deleted from the symbol table.</p>

<p style="margin-left:17%; margin-top: 1em">void
hv_ename_delete(HV *hv, const char *name, U32 len, <br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;hv_fill&quot;</p>

<p style="margin-left:17%;">Returns the number of hash
buckets that happen to be in use.</p>

<p style="margin-left:17%; margin-top: 1em">This function
implements the &quot;HvFILL&quot; macro which you should use
instead.</p>

<p style="margin-left:17%; margin-top: 1em">As of perl 5.25
this function is used only for debugging purposes, and the
number of used hash buckets is not in any way cached, thus
this function can be costly to execute as it must iterate
over all the buckets in the hash.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;hv_fill&quot; must be explicitly called as
&quot;Perl_hv_fill&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
Perl_hv_fill(pTHX_ HV *const hv)</p>


<p style="margin-left:11%;">&quot;hv_placeholders_get&quot;</p>

<p style="margin-left:17%;">Implements
&quot;HvPLACEHOLDERS_get&quot;, which you should use
instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;hv_placeholders_get&quot; must be explicitly called as
&quot;Perl_hv_placeholders_get&quot; with an
&quot;aTHX_&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">I32
Perl_hv_placeholders_get(pTHX_ const HV *hv)</p>


<p style="margin-left:11%;">&quot;hv_placeholders_set&quot;</p>

<p style="margin-left:17%;">Implements
&quot;HvPLACEHOLDERS_set&quot;, which you should use
instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;hv_placeholders_set&quot; must be explicitly called as
&quot;Perl_hv_placeholders_set&quot; with an
&quot;aTHX_&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_hv_placeholders_set(pTHX_ HV *hv, I32 ph)</p>

<p style="margin-left:11%;">&quot;hv_riter_p&quot;</p>

<p style="margin-left:17%;">Implements &quot;HvRITER&quot;
which you should use instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;hv_riter_p&quot; must be explicitly called as
&quot;Perl_hv_riter_p&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">I32*
Perl_hv_riter_p(pTHX_ HV *hv)</p>

<p style="margin-left:11%;">&quot;hv_riter_set&quot;</p>

<p style="margin-left:17%;">Implements
&quot;HvRITER_set&quot; which you should use instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;hv_riter_set&quot; must be explicitly called as
&quot;Perl_hv_riter_set&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_hv_riter_set(pTHX_ HV *hv, I32 riter)</p>


<p style="margin-left:11%;">&quot;refcounted_he_chain_2hv&quot;</p>

<p style="margin-left:17%;">Generates and returns a
&quot;HV *&quot; representing the content of a
&quot;refcounted_he&quot; chain. &quot;flags&quot; is
currently unused and must be zero.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
refcounted_he_chain_2hv(const struct refcounted_he *c, <br>
U32 flags)</p>


<p style="margin-left:11%;">&quot;refcounted_he_fetch_pv&quot;</p>

<p style="margin-left:17%;">Like
&quot;refcounted_he_fetch_pvn&quot;, but takes a
nul-terminated string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
refcounted_he_fetch_pv(const struct refcounted_he *chain,
<br>
const char *key, U32 hash, U32 flags)</p>


<p style="margin-left:11%;">&quot;refcounted_he_fetch_pvn&quot;</p>

<p style="margin-left:17%;">Search along a
&quot;refcounted_he&quot; chain for an entry with the key
specified by &quot;keypv&quot; and &quot;keylen&quot;. If
&quot;flags&quot; has the &quot;REFCOUNTED_HE_KEY_UTF8&quot;
bit set, the key octets are interpreted as
<small>UTF&minus;8,</small> otherwise they are interpreted
as Latin&minus;1. &quot;hash&quot; is a precomputed hash of
the key string, or zero if it has not been precomputed.
Returns a mortal scalar representing the value associated
with the key, or &amp;PL_sv_placeholder if there is no value
associated with the key.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
refcounted_he_fetch_pvn(const struct refcounted_he *chain,
<br>
const char *keypv, STRLEN keylen, <br>
U32 hash, U32 flags)</p>


<p style="margin-left:11%;">&quot;refcounted_he_fetch_pvs&quot;</p>

<p style="margin-left:17%;">Like
&quot;refcounted_he_fetch_pvn&quot;, but takes a literal
string instead of a string/length pair, and no precomputed
hash.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
refcounted_he_fetch_pvs(const struct refcounted_he *chain,
<br>
&quot;key&quot;, U32 flags)</p>


<p style="margin-left:11%;">&quot;refcounted_he_fetch_sv&quot;</p>

<p style="margin-left:17%;">Like
&quot;refcounted_he_fetch_pvn&quot;, but takes a Perl scalar
instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
refcounted_he_fetch_sv(const struct refcounted_he *chain,
<br>
SV *key, U32 hash, U32 flags)</p>


<p style="margin-left:11%;">&quot;refcounted_he_free&quot;</p>

<p style="margin-left:17%;">Decrements the reference count
of a &quot;refcounted_he&quot; by one. If the reference
count reaches zero the structure&rsquo;s memory is freed,
which (recursively) causes a reduction of its parent
&quot;refcounted_he&quot;&rsquo;s reference count. It is
safe to pass a null pointer to this function: no action
occurs in this case.</p>

<p style="margin-left:17%; margin-top: 1em">void
refcounted_he_free(struct refcounted_he *he)</p>


<p style="margin-left:11%;">&quot;refcounted_he_inc&quot;</p>

<p style="margin-left:17%;">Increment the reference count
of a &quot;refcounted_he&quot;. The pointer to the
&quot;refcounted_he&quot; is also returned. It is safe to
pass a null pointer to this function: no action occurs and a
null pointer is returned.</p>

<p style="margin-left:17%; margin-top: 1em">struct
refcounted_he * refcounted_he_inc( <br>
struct refcounted_he *he)</p>


<p style="margin-left:11%;">&quot;refcounted_he_new_pv&quot;</p>

<p style="margin-left:17%;">Like
&quot;refcounted_he_new_pvn&quot;, but takes a
nul-terminated string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">struct
refcounted_he * refcounted_he_new_pv( <br>
struct refcounted_he *parent, <br>
const char *key, U32 hash, <br>
SV *value, U32 flags)</p>


<p style="margin-left:11%;">&quot;refcounted_he_new_pvn&quot;</p>

<p style="margin-left:17%;">Creates a new
&quot;refcounted_he&quot;. This consists of a single
key/value pair and a reference to an existing
&quot;refcounted_he&quot; chain (which may be empty), and
thus forms a longer chain. When using the longer chain, the
new key/value pair takes precedence over any entry for the
same key further along the chain.</p>

<p style="margin-left:17%; margin-top: 1em">The new key is
specified by &quot;keypv&quot; and &quot;keylen&quot;. If
&quot;flags&quot; has the &quot;REFCOUNTED_HE_KEY_UTF8&quot;
bit set, the key octets are interpreted as
<small>UTF&minus;8,</small> otherwise they are interpreted
as Latin&minus;1. &quot;hash&quot; is a precomputed hash of
the key string, or zero if it has not been precomputed.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;value&quot;
is the scalar value to store for this key. &quot;value&quot;
is copied by this function, which thus does not take
ownership of any reference to it, and later changes to the
scalar will not be reflected in the value visible in the
&quot;refcounted_he&quot;. Complex types of scalar will not
be stored with referential integrity, but will be coerced to
strings. &quot;value&quot; may be either null or
&amp;PL_sv_placeholder to indicate that no value is to be
associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key
further along the chain.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;parent&quot;
points to the rest of the &quot;refcounted_he&quot; chain to
be attached to the new &quot;refcounted_he&quot;. This
function takes ownership of one reference to
&quot;parent&quot;, and returns one reference to the new
&quot;refcounted_he&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">struct
refcounted_he * refcounted_he_new_pvn( <br>
struct refcounted_he *parent, <br>
const char *keypv, <br>
STRLEN keylen, U32 hash, <br>
SV *value, U32 flags)</p>


<p style="margin-left:11%;">&quot;refcounted_he_new_pvs&quot;</p>

<p style="margin-left:17%;">Like
&quot;refcounted_he_new_pvn&quot;, but takes a literal
string instead of a string/length pair, and no precomputed
hash.</p>

<p style="margin-left:17%; margin-top: 1em">struct
refcounted_he * refcounted_he_new_pvs( <br>
struct refcounted_he *parent, <br>
&quot;key&quot;, SV *value, U32 flags)</p>


<p style="margin-left:11%;">&quot;refcounted_he_new_sv&quot;</p>

<p style="margin-left:17%;">Like
&quot;refcounted_he_new_pvn&quot;, but takes a Perl scalar
instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">struct
refcounted_he * refcounted_he_new_sv( <br>
struct refcounted_he *parent, <br>
SV *key, U32 hash, SV *value, <br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;unsharepvn&quot;</p>

<p style="margin-left:17%;">If no one has access to shared
string &quot;str&quot; with length &quot;len&quot;, free
it.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;len&quot;
and &quot;hash&quot; must both be valid for
&quot;str&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
unsharepvn(const char* sv, I32 len, U32 hash)</p>

<h2>Input/Output
<a name="Input/Output"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;dirp_dup&quot;</p>

<p style="margin-left:17%;">Duplicate a directory handle,
returning a pointer to the cloned object.</p>

<p style="margin-left:17%; margin-top: 1em">DIR*
dirp_dup(DIR *const dp, CLONE_PARAMS *const param)</p>

<p style="margin-left:11%;">&quot;fp_dup&quot;</p>

<p style="margin-left:17%;">Duplicate a file handle,
returning a pointer to the cloned object.</p>

<p style="margin-left:17%; margin-top: 1em">PerlIO*
fp_dup(PerlIO *const fp, const char type, <br>
CLONE_PARAMS *const param)</p>

<p style="margin-left:11%;">&quot;my_fflush_all&quot;</p>

<p style="margin-left:17%;">Implements
&quot;PERL_FLUSHALL_FOR_CHILD&quot; on some platforms.</p>

<p style="margin-left:17%; margin-top: 1em">I32
my_fflush_all()</p>

<p style="margin-left:11%;">&quot;my_mkostemp&quot;</p>

<p style="margin-left:17%;">The C library mkostemp(3) if
available, or a Perl implementation of it.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;my_mkostemp&quot; must be explicitly called as
&quot;Perl_my_mkostemp&quot; .</p>

<p style="margin-left:17%; margin-top: 1em">int
Perl_my_mkostemp(char *templte, int flags)</p>

<p style="margin-left:11%;">&quot;my_mkstemp&quot;</p>

<p style="margin-left:17%;">The C library mkstemp(3) if
available, or a Perl implementation of it.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;my_mkstemp&quot; must be explicitly called as
&quot;Perl_my_mkstemp&quot; .</p>

<p style="margin-left:17%; margin-top: 1em">int
Perl_my_mkstemp(char *templte)</p>

<p style="margin-left:11%;">&quot;PL_last_in_gv&quot;</p>

<p style="margin-left:17%;">The <small>GV</small> which was
last used for a filehandle input operation.
(&quot;&lt;FH&gt;&quot;)</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
PL_last_in_gv</p>

<p style="margin-left:11%;">&quot;PL_ofsgv&quot;</p>

<p style="margin-left:17%;">The glob containing the output
field separator &minus; &quot;*,&quot; in Perl space.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
PL_ofsgv</p>

<p style="margin-left:11%;">&quot;PL_rs&quot;</p>

<p style="margin-left:17%;">The input record separator
&minus; $/ in Perl space.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">SV* PL_rs</p>

<p style="margin-left:11%;">&quot;start_glob&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;start_glob&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Function called
by &quot;do_readline&quot; to spawn a glob (or do the glob
inside perl on <small>VMS</small> ). This code used to be
inline, but now perl uses &quot;File::Glob&quot; this glob
starter is only used by miniperl during the build process,
or when <small>PERL_EXTERNAL_GLOB</small> is defined. Moving
it away shrinks <i>pp_hot.c</i>; shrinking <i>pp_hot.c</i>
helps speed perl up.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;start_glob&quot; must be explicitly called as
&quot;Perl_start_glob&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">PerlIO*
Perl_start_glob(pTHX_ SV *tmpglob, IO *io)</p>

<h2>Integer
<a name="Integer"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Integer</p>

<h2>I/O Formats
<a name="I/O Formats"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in I/O Formats</p>

<h2>Lexer interface
<a name="Lexer interface"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;validate_proto&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;validate_proto&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">This function
performs syntax checking on a prototype, &quot;proto&quot;.
If &quot;warn&quot; is true, any illegal characters or
mismatched brackets will trigger illegalproto warnings,
declaring that they were detected in the prototype for
&quot;name&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value is &quot;true&quot; if this is a valid prototype, and
&quot;false&quot; if it is not, regardless of whether
&quot;warn&quot; was &quot;true&quot; or
&quot;false&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;NULL&quot; is a valid &quot;proto&quot; and will
always return &quot;true&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
validate_proto(SV *name, SV *proto, bool warn, <br>
bool curstash)</p>

<h2>Locales
<a name="Locales"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Locales</p>

<h2>Magic
<a name="Magic"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;magic_clearhint&quot;</p>

<p style="margin-left:17%;">Triggered by a delete from
&quot;%^H&quot;, records the key to
&quot;PL_compiling.cop_hints_hash&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
magic_clearhint(SV* sv, MAGIC* mg)</p>


<p style="margin-left:11%;">&quot;magic_clearhints&quot;</p>

<p style="margin-left:17%;">Triggered by clearing
&quot;%^H&quot;, resets
&quot;PL_compiling.cop_hints_hash&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
magic_clearhints(SV* sv, MAGIC* mg)</p>

<p style="margin-left:11%;">&quot;magic_methcall&quot;</p>

<p style="margin-left:17%;">Invoke a magic method (like
<small>FETCH</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">&quot;sv&quot;
and &quot;mg&quot; are the tied thingy and the tie
magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;meth&quot;
is the name of the method to call.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;argc&quot;
is the number of args (in addition to $self) to pass to the
method.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; can be:</p>

<p style="margin-left:17%; margin-top: 1em">G_DISCARD
invoke method with G_DISCARD flag and don't <br>
return a value <br>
G_UNDEF_FILL fill the stack with argc pointers to <br>
PL_sv_undef</p>

<p style="margin-left:17%; margin-top: 1em">The arguments
themselves are any values following the &quot;flags&quot;
argument.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
<small>SV</small> (if any) returned by the method, or
&quot;NULL&quot; on failure.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;magic_methcall&quot; must be explicitly called as
&quot;Perl_magic_methcall&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth,
<br>
U32 flags, U32 argc, ...)</p>

<p style="margin-left:11%;">&quot;magic_sethint&quot;</p>

<p style="margin-left:17%;">Triggered by a store to
&quot;%^H&quot;, records the key/value pair to
&quot;PL_compiling.cop_hints_hash&quot;. It is assumed that
hints aren&rsquo;t storing anything that would need a deep
copy. Maybe we should warn if we find a reference.</p>

<p style="margin-left:17%; margin-top: 1em">int
magic_sethint(SV* sv, MAGIC* mg)</p>

<p style="margin-left:11%;">&quot;mg_dup&quot;</p>

<p style="margin-left:17%;">Duplicate a chain of magic,
returning a pointer to the cloned object.</p>

<p style="margin-left:17%; margin-top: 1em">MAGIC*
mg_dup(MAGIC *mg, CLONE_PARAMS *const param)</p>

<p style="margin-left:11%;">&quot;mg_localize&quot;</p>

<p style="margin-left:17%;">Copy some of the magic from an
existing <small>SV</small> to new localized version of that
<small>SV.</small> Container magic (<i>e.g.</i>, %ENV, $1,
&quot;tie&quot;) gets copied, value magic doesn&rsquo;t
(<i>e.g.</i>, &quot;taint&quot;, &quot;pos&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;setmagic&quot; is false then no set magic will be
called on the new (empty) <small>SV.</small> This typically
means that assignment will soon follow (e.g.
'local&nbsp;$x&nbsp;=&nbsp;$y'), and that will handle the
magic.</p>

<p style="margin-left:17%; margin-top: 1em">void
mg_localize(SV* sv, SV* nsv, bool setmagic)</p>

<p style="margin-left:11%;">&quot;si_dup&quot;</p>

<p style="margin-left:17%;">Duplicate a stack info
structure, returning a pointer to the cloned object.</p>

<p style="margin-left:17%; margin-top: 1em">PERL_SI*
si_dup(PERL_SI* si, CLONE_PARAMS* param)</p>

<p style="margin-left:11%;">&quot;ss_dup&quot;</p>

<p style="margin-left:17%;">Duplicate the save stack,
returning a pointer to the cloned object.</p>

<p style="margin-left:17%; margin-top: 1em">ANY*
ss_dup(PerlInterpreter* proto_perl, CLONE_PARAMS* param)</p>

<h2>Memory Management
<a name="Memory Management"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;calloc&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;Newxz&quot;&quot; in perlapi which you should
use instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;calloc&quot; must be explicitly called as
&quot;Perl_calloc&quot; .</p>

<p style="margin-left:17%; margin-top: 1em">Malloc_t
Perl_calloc(MEM_SIZE elements, MEM_SIZE size)</p>

<p style="margin-left:11%;">&quot;malloc&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;Newx&quot;&quot; in perlapi which you should use
instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;malloc&quot; must be explicitly called as
&quot;Perl_malloc&quot; .</p>

<p style="margin-left:17%; margin-top: 1em">Malloc_t
Perl_malloc(MEM_SIZE nbytes)</p>

<p style="margin-left:11%;">&quot;mfree&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;Safefree&quot;&quot; in perlapi which you should
use instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;mfree&quot; must be explicitly called as
&quot;Perl_mfree&quot; .</p>

<p style="margin-left:17%; margin-top: 1em">Free_t
Perl_mfree(Malloc_t where)</p>

<p style="margin-left:11%;">&quot;realloc&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;Renew&quot;&quot; in perlapi which you should
use instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;realloc&quot; must be explicitly called as
&quot;Perl_realloc&quot; .</p>

<p style="margin-left:17%; margin-top: 1em">Malloc_t
Perl_realloc(Malloc_t where, MEM_SIZE nbytes)</p>

<h2>MRO
<a name="MRO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;mro_get_linear_isa_dfs&quot;</p>

<p style="margin-left:17%;">Returns the Depth-First Search
linearization of @ISA the given stash. The return value is a
read-only AV*. &quot;level&quot; should be 0 (it is used
internally in this function&rsquo;s recursion).</p>

<p style="margin-left:17%; margin-top: 1em">You are
responsible for &quot;SvREFCNT_inc()&quot; on the return
value if you plan to store it anywhere semi-permanently
(otherwise it might be deleted out from under you the next
time the cache is invalidated).</p>

<p style="margin-left:17%; margin-top: 1em">AV*
mro_get_linear_isa_dfs(HV* stash, U32 level)</p>


<p style="margin-left:11%;">&quot;mro_isa_changed_in&quot;</p>

<p style="margin-left:17%;">Takes the necessary steps
(cache invalidations, mostly) when the @ISA of the given
package has changed. Invoked by the &quot;setisa&quot;
magic, should not need to invoke directly.</p>

<p style="margin-left:17%; margin-top: 1em">void
mro_isa_changed_in(HV* stash)</p>


<p style="margin-left:11%;">&quot;mro_package_moved&quot;</p>

<p style="margin-left:17%;">Call this function to signal to
a stash that it has been assigned to another spot in the
stash hierarchy. &quot;stash&quot; is the stash that has
been assigned. &quot;oldstash&quot; is the stash it
replaces, if any. &quot;gv&quot; is the glob that is
actually being assigned to.</p>

<p style="margin-left:17%; margin-top: 1em">This can also
be called with a null first argument to indicate that
&quot;oldstash&quot; has been deleted.</p>

<p style="margin-left:17%; margin-top: 1em">This function
invalidates isa caches on the old stash, on all subpackages
nested inside it, and on the subclasses of all those,
including non-existent packages that have corresponding
entries in &quot;stash&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">It also sets
the effective names (&quot;HvENAME&quot;) on all the stashes
as appropriate.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;gv&quot; is present and is not in the symbol table,
then this function simply returns. This checked will be
skipped if &quot;flags &amp; 1&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
mro_package_moved(HV * const stash, HV * const oldstash,
<br>
const GV * const gv, U32 flags)</p>

<h2>Multicall Functions
<a name="Multicall Functions"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Multicall
Functions</p>

<h2>Numeric Functions
<a name="Numeric Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;isinfnansv&quot;</p>

<p style="margin-left:17%;">Checks whether the argument
would be either an infinity or &quot;NaN&quot; when used as
a number, but is careful not to trigger non-numeric or
uninitialized warnings. it assumes the caller has done
&quot;SvGETMAGIC(sv)&quot; already.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
always accepts trailing garbage (similar to
&quot;grok_number_flags&quot; with
&quot;PERL_SCAN_TRAILING&quot;), so &quot;inferior&quot; and
&quot;NAND gates&quot; will return true.</p>

<p style="margin-left:17%; margin-top: 1em">bool
isinfnansv(SV *sv)</p>

<h2>Optrees
<a name="Optrees"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;finalize_optree&quot;</p>

<p style="margin-left:17%;">This function finalizes the
optree. Should be called directly after the complete optree
is built. It does some additional checking which can&rsquo;t
be done in the normal &quot;ck_&quot;xxx functions and makes
the tree thread-safe.</p>

<p style="margin-left:17%; margin-top: 1em">void
finalize_optree(OP* o)</p>

<p style="margin-left:11%;">&quot;newATTRSUB_x&quot;</p>

<p style="margin-left:17%;">Construct a Perl subroutine,
also performing some surrounding jobs.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is expected to be called in a Perl compilation context, and
some aspects of the subroutine are taken from global
variables associated with compilation. In particular,
&quot;PL_compcv&quot; represents the subroutine that is
currently being compiled. It must be non-null when this
function is called, and some aspects of the subroutine being
constructed are taken from it. The constructed subroutine
may actually be a reuse of the &quot;PL_compcv&quot; object,
but will not necessarily be so.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;block&quot; is null then the subroutine will have no
body, and for the time being it will be an error to call it.
This represents a forward subroutine declaration such as
&quot;sub&nbsp;foo&nbsp;($$);&quot;. If &quot;block&quot; is
non-null then it provides the Perl code of the subroutine
body, which will be executed when the subroutine is called.
This body includes any argument unwrapping code resulting
from a subroutine signature or similar. The pad use of the
code must correspond to the pad attached to
&quot;PL_compcv&quot;. The code is not expected to include a
&quot;leavesub&quot; or &quot;leavesublv&quot; op; this
function will add such an op. &quot;block&quot; is consumed
by this function and will become part of the constructed
subroutine.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;proto&quot;
specifies the subroutine&rsquo;s prototype, unless one is
supplied as an attribute (see below). If &quot;proto&quot;
is null, then the subroutine will not have a prototype. If
&quot;proto&quot; is non-null, it must point to a
&quot;const&quot; op whose value is a string, and the
subroutine will have that string as its prototype. If a
prototype is supplied as an attribute, the attribute takes
precedence over &quot;proto&quot;, but in that case
&quot;proto&quot; should preferably be null. In any case,
&quot;proto&quot; is consumed by this function.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;attrs&quot;
supplies attributes to be applied the subroutine. A handful
of attributes take effect by built-in means, being applied
to &quot;PL_compcv&quot; immediately when seen. Other
attributes are collected up and attached to the subroutine
by this route. &quot;attrs&quot; may be null to supply no
attributes, or point to a &quot;const&quot; op for a single
attribute, or point to a &quot;list&quot; op whose children
apart from the &quot;pushmark&quot; are &quot;const&quot;
ops for one or more attributes. Each &quot;const&quot; op
must be a string, giving the attribute name optionally
followed by parenthesised arguments, in the manner in which
attributes appear in Perl source. The attributes will be
applied to the sub by this function. &quot;attrs&quot; is
consumed by this function.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;o_is_gv&quot; is false and &quot;o&quot; is null, then
the subroutine will be anonymous. If &quot;o_is_gv&quot; is
false and &quot;o&quot; is non-null, then &quot;o&quot; must
point to a &quot;const&quot; <small>OP,</small> which will
be consumed by this function, and its string value supplies
a name for the subroutine. The name may be qualified or
unqualified, and if it is unqualified then a default stash
will be selected in some manner. If &quot;o_is_gv&quot; is
true, then &quot;o&quot; doesn&rsquo;t point to an
&quot;OP&quot; at all, but is instead a cast pointer to a
&quot;GV&quot; by which the subroutine will be named.</p>

<p style="margin-left:17%; margin-top: 1em">If there is
already a subroutine of the specified name, then the new sub
will either replace the existing one in the glob or be
merged with the existing one. A warning may be generated
about redefinition.</p>

<p style="margin-left:17%; margin-top: 1em">If the
subroutine has one of a few special names, such as
&quot;BEGIN&quot; or &quot;END&quot;, then it will be
claimed by the appropriate queue for automatic running of
phase-related subroutines. In this case the relevant glob
will be left not containing any subroutine, even if it did
contain one before. In the case of &quot;BEGIN&quot;, the
subroutine will be executed and the reference to it disposed
of before this function returns.</p>

<p style="margin-left:17%; margin-top: 1em">The function
returns a pointer to the constructed subroutine. If the sub
is anonymous then ownership of one counted reference to the
subroutine is transferred to the caller. If the sub is named
then the caller does not get ownership of a reference. In
most such cases, where the sub has a non-phase name, the sub
will be alive at the point it is returned by virtue of being
contained in the glob that names it. A phase-named
subroutine will usually be alive by virtue of the reference
owned by the phase&rsquo;s automatic run queue. But a
&quot;BEGIN&quot; subroutine, having already been executed,
will quite likely have been destroyed already by the time
this function returns, making it erroneous for the caller to
make any use of the returned pointer. It is the
caller&rsquo;s responsibility to ensure that it knows which
of these situations applies.</p>

<p style="margin-left:17%; margin-top: 1em">CV*
newATTRSUB_x(I32 floor, OP *o, OP *proto, OP *attrs, <br>
OP *block, bool o_is_gv)</p>


<p style="margin-left:11%;">&quot;newXS_len_flags&quot;</p>

<p style="margin-left:17%;">Construct an <small>XS</small>
subroutine, also performing some surrounding jobs.</p>

<p style="margin-left:17%; margin-top: 1em">The subroutine
will have the entry point &quot;subaddr&quot;. It will have
the prototype specified by the nul-terminated string
&quot;proto&quot;, or no prototype if &quot;proto&quot; is
null. The prototype string is copied; the caller can mutate
the supplied string afterwards. If &quot;filename&quot; is
non-null, it must be a nul-terminated filename, and the
subroutine will have its &quot;CvFILE&quot; set accordingly.
By default &quot;CvFILE&quot; is set to point directly to
the supplied string, which must be static. If
&quot;flags&quot; has the &quot;XS_DYNAMIC_FILENAME&quot;
bit set, then a copy of the string will be taken
instead.</p>

<p style="margin-left:17%; margin-top: 1em">Other aspects
of the subroutine will be left in their default state. If
anything else needs to be done to the subroutine for it to
function correctly, it is the caller&rsquo;s responsibility
to do that after this function has constructed it. However,
beware of the subroutine potentially being destroyed before
this function returns, as described below.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;name&quot; is null then the subroutine will be
anonymous, with its &quot;CvGV&quot; referring to an
&quot;__ANON__&quot; glob. If &quot;name&quot; is non-null
then the subroutine will be named accordingly, referenced by
the appropriate glob. &quot;name&quot; is a string of length
&quot;len&quot; bytes giving a sigilless symbol name, in
<small>UTF&minus;8</small> if &quot;flags&quot; has the
&quot;SVf_UTF8&quot; bit set and in Latin&minus;1 otherwise.
The name may be either qualified or unqualified, with the
stash defaulting in the same manner as for
&quot;gv_fetchpvn_flags&quot;. &quot;flags&quot; may contain
flag bits understood by &quot;gv_fetchpvn_flags&quot; with
the same meaning as they have there, such as
&quot;GV_ADDWARN&quot;. The symbol is always added to the
stash if necessary, with &quot;GV_ADDMULTI&quot;
semantics.</p>

<p style="margin-left:17%; margin-top: 1em">If there is
already a subroutine of the specified name, then the new sub
will replace the existing one in the glob. A warning may be
generated about the redefinition. If the old subroutine was
&quot;CvCONST&quot; then the decision about whether to warn
is influenced by an expectation about whether the new
subroutine will become a constant of similar value. That
expectation is determined by &quot;const_svp&quot;. (Note
that the call to this function doesn&rsquo;t make the new
subroutine &quot;CvCONST&quot; in any case; that is left to
the caller.) If &quot;const_svp&quot; is null then it
indicates that the new subroutine will not become a
constant. If &quot;const_svp&quot; is non-null then it
indicates that the new subroutine will become a constant,
and it points to an &quot;SV*&quot; that provides the
constant value that the subroutine will have.</p>

<p style="margin-left:17%; margin-top: 1em">If the
subroutine has one of a few special names, such as
&quot;BEGIN&quot; or &quot;END&quot;, then it will be
claimed by the appropriate queue for automatic running of
phase-related subroutines. In this case the relevant glob
will be left not containing any subroutine, even if it did
contain one before. In the case of &quot;BEGIN&quot;, the
subroutine will be executed and the reference to it disposed
of before this function returns, and also before its
prototype is set. If a &quot;BEGIN&quot; subroutine would
not be sufficiently constructed by this function to be ready
for execution then the caller must prevent this happening by
giving the subroutine a different name.</p>

<p style="margin-left:17%; margin-top: 1em">The function
returns a pointer to the constructed subroutine. If the sub
is anonymous then ownership of one counted reference to the
subroutine is transferred to the caller. If the sub is named
then the caller does not get ownership of a reference. In
most such cases, where the sub has a non-phase name, the sub
will be alive at the point it is returned by virtue of being
contained in the glob that names it. A phase-named
subroutine will usually be alive by virtue of the reference
owned by the phase&rsquo;s automatic run queue. But a
&quot;BEGIN&quot; subroutine, having already been executed,
will quite likely have been destroyed already by the time
this function returns, making it erroneous for the caller to
make any use of the returned pointer. It is the
caller&rsquo;s responsibility to ensure that it knows which
of these situations applies.</p>

<p style="margin-left:17%; margin-top: 1em">CV *
newXS_len_flags(const char *name, STRLEN len, <br>
XSUBADDR_t subaddr, <br>
const char *const filename, <br>
const char *const proto, SV **const_svp, <br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;op_refcnt_lock&quot;</p>

<p style="margin-left:17%;">Implements the
&quot;OP_REFCNT_LOCK&quot; macro which you should use
instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
op_refcnt_lock()</p>


<p style="margin-left:11%;">&quot;op_refcnt_unlock&quot;</p>

<p style="margin-left:17%;">Implements the
&quot;OP_REFCNT_UNLOCK&quot; macro which you should use
instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
op_refcnt_unlock()</p>


<p style="margin-left:11%;">&quot;optimize_optree&quot;</p>

<p style="margin-left:17%;">This function applies some
optimisations to the optree in top-down order. It is called
before the peephole optimizer, which processes ops in
execution order. Note that <b>finalize_optree()</b> also
does a top-down scan, but is called *after* the peephole
optimizer.</p>

<p style="margin-left:17%; margin-top: 1em">void
optimize_optree(OP* o)</p>


<p style="margin-left:11%;">&quot;traverse_op_tree&quot;</p>

<p style="margin-left:17%;">Return the next op in a
depth-first traversal of the op tree, returning
<small>NULL</small> when the traversal is complete.</p>

<p style="margin-left:17%; margin-top: 1em">The initial
call must supply the root of the tree as both top and o.</p>

<p style="margin-left:17%; margin-top: 1em">For now
it&rsquo;s static, but it may be exposed to the
<small>API</small> in the future.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
traverse_op_tree(OP* top, OP* o)</p>

<h2>Pack and Unpack
<a name="Pack and Unpack"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Pack and
Unpack</p>

<h2>Pad Data Structures
<a name="Pad Data Structures"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;CX_CURPAD_SAVE&quot;</p>

<p style="margin-left:17%;">Save the current pad in the
given context block structure.</p>

<p style="margin-left:17%; margin-top: 1em">void
CX_CURPAD_SAVE(struct context)</p>

<p style="margin-left:11%;">&quot;CX_CURPAD_SV&quot;</p>

<p style="margin-left:17%;">Access the <small>SV</small> at
offset &quot;po&quot; in the saved current pad in the given
context block structure (can be used as an lvalue).</p>

<p style="margin-left:17%; margin-top: 1em">SV *
CX_CURPAD_SV(struct context, PADOFFSET po)</p>

<p style="margin-left:11%;">&quot;PAD_BASE_SV&quot;</p>

<p style="margin-left:17%;">Get the value from slot
&quot;po&quot; in the base (DEPTH=1) pad of a padlist</p>

<p style="margin-left:17%; margin-top: 1em">SV *
PAD_BASE_SV(PADLIST padlist, PADOFFSET po)</p>

<p style="margin-left:11%;">&quot;PAD_CLONE_VARS&quot;</p>

<p style="margin-left:17%;">Clone the state variables
associated with running and compiling pads.</p>

<p style="margin-left:17%; margin-top: 1em">void
PAD_CLONE_VARS(PerlInterpreter *proto_perl, <br>
CLONE_PARAMS* param)</p>


<p style="margin-left:11%;">&quot;PAD_COMPNAME_FLAGS&quot;</p>

<p style="margin-left:17%;">Return the flags for the
current compiling pad name at offset &quot;po&quot;. Assumes
a valid slot entry.</p>

<p style="margin-left:17%; margin-top: 1em">U32
PAD_COMPNAME_FLAGS(PADOFFSET po)</p>


<p style="margin-left:11%;">&quot;PAD_COMPNAME_GEN&quot;</p>

<p style="margin-left:17%;">The generation number of the
name at offset &quot;po&quot; in the current compiling pad
(lvalue).</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
PAD_COMPNAME_GEN(PADOFFSET po)</p>


<p style="margin-left:11%;">&quot;PAD_COMPNAME_GEN_set&quot;</p>

<p style="margin-left:17%;">Sets the generation number of
the name at offset &quot;po&quot; in the current ling pad
(lvalue) to &quot;gen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)</p>


<p style="margin-left:11%;">&quot;PAD_COMPNAME_OURSTASH&quot;</p>

<p style="margin-left:17%;">Return the stash associated
with an &quot;our&quot; variable. Assumes the slot entry is
a valid &quot;our&quot; lexical.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
PAD_COMPNAME_OURSTASH(PADOFFSET po)</p>


<p style="margin-left:11%;">&quot;PAD_COMPNAME_PV&quot;</p>

<p style="margin-left:17%;">Return the name of the current
compiling pad name at offset &quot;po&quot;. Assumes a valid
slot entry.</p>

<p style="margin-left:17%; margin-top: 1em">char *
PAD_COMPNAME_PV(PADOFFSET po)</p>


<p style="margin-left:11%;">&quot;PAD_COMPNAME_TYPE&quot;</p>

<p style="margin-left:17%;">Return the type (stash) of the
current compiling pad name at offset &quot;po&quot;. Must be
a valid name. Returns null if not typed.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
PAD_COMPNAME_TYPE(PADOFFSET po)</p>

<p style="margin-left:11%;">&quot;PadnameIsOUR&quot;</p>

<p style="margin-left:17%;">Whether this is an
&quot;our&quot; variable.</p>

<p style="margin-left:17%; margin-top: 1em">bool
PadnameIsOUR(PADNAME * pn)</p>

<p style="margin-left:11%;">&quot;PadnameIsSTATE&quot;</p>

<p style="margin-left:17%;">Whether this is a
&quot;state&quot; variable.</p>

<p style="margin-left:17%; margin-top: 1em">bool
PadnameIsSTATE(PADNAME * pn)</p>


<p style="margin-left:11%;">&quot;PadnameOURSTASH&quot;</p>

<p style="margin-left:17%;">The stash in which this
&quot;our&quot; variable was declared.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
PadnameOURSTASH(PADNAME * pn)</p>

<p style="margin-left:11%;">&quot;PadnameOUTER&quot;</p>

<p style="margin-left:17%;">Whether this entry belongs to
an outer pad. Entries for which this is true are often
referred to as &rsquo;fake&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
PadnameOUTER(PADNAME * pn)</p>

<p style="margin-left:11%;">&quot;PadnameTYPE&quot;</p>

<p style="margin-left:17%;">The stash associated with a
typed lexical. This returns the %Foo:: hash for &quot;my Foo
$bar&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
PadnameTYPE(PADNAME * pn)</p>


<p style="margin-left:11%;">&quot;PAD_RESTORE_LOCAL&quot;</p>

<p style="margin-left:17%;">Restore the old pad saved into
the local variable &quot;opad&quot; by
&quot;PAD_SAVE_LOCAL()&quot;</p>

<p style="margin-left:17%; margin-top: 1em">void
PAD_RESTORE_LOCAL(PAD *opad)</p>

<p style="margin-left:11%;">&quot;PAD_SAVE_LOCAL&quot;</p>

<p style="margin-left:17%;">Save the current pad to the
local variable &quot;opad&quot;, then make the current pad
equal to &quot;npad&quot;</p>

<p style="margin-left:17%; margin-top: 1em">void
PAD_SAVE_LOCAL(PAD *opad, PAD *npad)</p>


<p style="margin-left:11%;">&quot;PAD_SAVE_SETNULLPAD&quot;</p>

<p style="margin-left:17%;">Save the current pad then set
it to null.</p>

<p style="margin-left:17%; margin-top: 1em">void
PAD_SAVE_SETNULLPAD()</p>

<p style="margin-left:11%;">&quot;PAD_SETSV&quot;</p>

<p style="margin-left:17%;">Set the slot at offset
&quot;po&quot; in the current pad to &quot;sv&quot;</p>

<p style="margin-left:17%; margin-top: 1em">SV *
PAD_SETSV(PADOFFSET po, SV* sv)</p>

<p style="margin-left:11%;">&quot;PAD_SET_CUR&quot;</p>

<p style="margin-left:17%;">Set the current pad to be pad
&quot;n&quot; in the padlist, saving the previous current
pad. <small>NB</small> currently this macro expands to a
string too long for some compilers, so it&rsquo;s best to
replace it with</p>

<p style="margin-left:17%; margin-top: 1em">SAVECOMPPAD();
<br>
PAD_SET_CUR_NOSAVE(padlist,n);</p>

<p style="margin-left:17%; margin-top: 1em">void
PAD_SET_CUR(PADLIST padlist, I32 n)</p>


<p style="margin-left:11%;">&quot;PAD_SET_CUR_NOSAVE&quot;</p>

<p style="margin-left:17%;">like
<small>PAD_SET_CUR,</small> but without the save</p>

<p style="margin-left:17%; margin-top: 1em">void
PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)</p>

<p style="margin-left:11%;">&quot;PAD_SV&quot;</p>

<p style="margin-left:17%;">Get the value at offset
&quot;po&quot; in the current pad</p>

<p style="margin-left:17%; margin-top: 1em">SV *
PAD_SV(PADOFFSET po)</p>

<p style="margin-left:11%;">&quot;PAD_SVl&quot;</p>

<p style="margin-left:17%;">Lightweight and lvalue version
of &quot;PAD_SV&quot;. Get or set the value at offset
&quot;po&quot; in the current pad. Unlike
&quot;PAD_SV&quot;, does not print diagnostics with
&minus;DX. For internal use only.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
PAD_SVl(PADOFFSET po)</p>

<p style="margin-left:11%;">&quot;SAVECLEARSV&quot;</p>

<p style="margin-left:17%;">Clear the pointed to pad value
on scope exit. (i.e. the runtime action of
&quot;my&quot;)</p>

<p style="margin-left:17%; margin-top: 1em">void
SAVECLEARSV(SV **svp)</p>

<p style="margin-left:11%;">&quot;SAVECOMPPAD&quot;</p>

<p style="margin-left:17%;">save &quot;PL_comppad&quot; and
&quot;PL_curpad&quot;</p>

<p style="margin-left:17%; margin-top: 1em">void
SAVECOMPPAD()</p>

<p style="margin-left:11%;">&quot;SAVEPADSV&quot;</p>

<p style="margin-left:17%;">Save a pad slot (used to
restore after an iteration)</p>

<p style="margin-left:17%; margin-top: 1em">void
SAVEPADSV(PADOFFSET po)</p>

<h2>Password and Group access
<a name="Password and Group access"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Password and
Group access</p>

<h2>Paths to system commands
<a name="Paths to system commands"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Paths to system
commands</p>

<h2>Prototype information
<a name="Prototype information"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Prototype
information</p>

<h2>REGEXP Functions
<a name="REGEXP Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;regnode&quot;</p>

<p style="margin-left:17%;">Described in perlreguts.</p>

<h2>Reports and Formats
<a name="Reports and Formats"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Reports and
Formats</p>

<h2>Signals
<a name="Signals"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Signals</p>

<h2>Site configuration
<a name="Site configuration"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Site
configuration</p>

<h2>Sockets configuration values
<a name="Sockets configuration values"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Sockets
configuration values</p>

<h2>Source Filters
<a name="Source Filters"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Source
Filters</p>

<h2>Stack Manipulation Macros
<a name="Stack Manipulation Macros"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;djSP&quot;</p>

<p style="margin-left:17%;">Declare Just &quot;SP&quot;.
This is actually identical to &quot;dSP&quot;, and declares
a local copy of perl&rsquo;s stack pointer, available via
the &quot;SP&quot; macro. See &quot;&quot;SP&quot; in
perlapi&quot;. (Available for backward source code
compatibility with the old (Perl 5.005) thread model.)</p>

<p style="margin-left:17%; margin-top: 1em">djSP();</p>

<p style="margin-left:11%;">&quot;LVRET&quot;</p>

<p style="margin-left:17%;">True if this op will be the
return value of an lvalue subroutine</p>

<p style="margin-left:11%;">&quot;save_alloc&quot;</p>

<p style="margin-left:17%;">Implements
&quot;&quot;SSNEW&quot;&quot; in perlapi and kin, which
should be used instead of this function.</p>

<p style="margin-left:17%; margin-top: 1em">I32
save_alloc(I32 size, I32 pad)</p>

<h2>String Handling
<a name="String Handling"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;delimcpy_no_escape&quot;</p>

<p style="margin-left:17%;">Copy a source buffer to a
destination buffer, stopping at (but not including) the
first occurrence in the source of the delimiter byte,
&quot;delim&quot;. The source is the bytes between
&quot;from&quot;&nbsp;and&nbsp;&quot;from_end&quot;&nbsp;&minus;&nbsp;1.
Similarly, the dest is &quot;to&quot; up to
&quot;to_end&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The number of
bytes copied is written to *retlen.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
position of &quot;delim&quot; in the &quot;from&quot;
buffer, but if there is no such occurrence before
&quot;from_end&quot;, then &quot;from_end&quot; is returned,
and the entire buffer
&quot;from&quot;&nbsp;..&nbsp;&quot;from_end&quot;&nbsp;&minus;&nbsp;1
is copied.</p>

<p style="margin-left:17%; margin-top: 1em">If there is
room in the destination available after the copy, an extra
terminating safety &quot;NUL&quot; byte is appended (not
included in the returned length).</p>

<p style="margin-left:17%; margin-top: 1em">The error case
is if the destination buffer is not large enough to
accommodate everything that should be copied. In this
situation, a value larger than
&quot;to_end&quot;&nbsp;&minus;&nbsp;&quot;to&quot; is
written to *retlen, and as much of the source as fits will
be written to the destination. Not having room for the
safety &quot;NUL&quot; is not considered an error.</p>

<p style="margin-left:17%; margin-top: 1em">char*
delimcpy_no_escape(char* to, const char* to_end, <br>
const char* from, const char* from_end, <br>
const int delim, I32* retlen)</p>

<p style="margin-left:11%;">&quot;my_cxt_init&quot;</p>

<p style="margin-left:17%;">Implements the
&quot;&quot;MY_CXT_INIT&quot;&quot; in perlxs macro, which
you should use instead.</p>

<p style="margin-left:17%; margin-top: 1em">The first time
a module is loaded, the global &quot;PL_my_cxt_index&quot;
is incremented, and that value is assigned to that
module&rsquo;s static &quot;my_cxt_index&quot; (whose
address is passed as an arg). Then, for each interpreter
this function is called for, it makes sure a
&quot;void*&quot; slot is available to hang the static data
off, by allocating or extending the interpreter&rsquo;s
&quot;PL_my_cxt_list&quot; array</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;my_cxt_init&quot; must be explicitly called as
&quot;Perl_my_cxt_init&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void*
Perl_my_cxt_init(pTHX_ int *indexp, size_t size)</p>


<p style="margin-left:11%;">&quot;quadmath_format_needed&quot;</p>


<p style="margin-left:17%;">&quot;quadmath_format_needed()&quot;
returns true if the &quot;format&quot; string seems to
contain at least one non-Q-prefixed &quot;%[efgaEFGA]&quot;
format specifier, or returns false otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">The format
specifier detection is not complete printf-syntax detection,
but it should catch most common cases.</p>

<p style="margin-left:17%; margin-top: 1em">If true is
returned, those arguments <b>should</b> in theory be
processed with &quot;quadmath_snprintf()&quot;, but in case
there is more than one such format specifier (see
&quot;quadmath_format_valid&quot;), and if there is anything
else beyond that one (even just a single byte), they
<b>cannot</b> be processed because
&quot;quadmath_snprintf()&quot; is very strict, accepting
only one format spec, and nothing else. In this case, the
code should probably fail.</p>

<p style="margin-left:17%; margin-top: 1em">bool
quadmath_format_needed(const char* format)</p>


<p style="margin-left:11%;">&quot;quadmath_format_valid&quot;</p>


<p style="margin-left:17%;">&quot;quadmath_snprintf()&quot;
is very strict about its &quot;format&quot; string and will
fail, returning &minus;1, if the format is invalid. It
accepts exactly one format spec.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;quadmath_format_valid()&quot;
checks that the intended single spec looks sane: begins with
&quot;%&quot;, has only one &quot;%&quot;, ends with
&quot;[efgaEFGA]&quot;, and has &quot;Q&quot; before it.
This is not a full &quot;printf syntax check&quot;, just the
basics.</p>

<p style="margin-left:17%; margin-top: 1em">Returns true if
it is valid, false if not.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;quadmath_format_needed&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
quadmath_format_valid(const char* format)</p>

<h2>SV Flags
<a name="SV Flags"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;SVt_INVLIST&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot; in perlapi.</p>

<h2>SV Handling
<a name="SV Handling"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;PL_Sv&quot;</p>

<p style="margin-left:17%;">A scratch pad <small>SV</small>
for whatever temporary use you need. Chiefly used as a
fallback by macros on platforms where &quot;
<small>PERL_USE_GCC_BRACE_GROUPS&quot;</small> in
perlapi&gt; is unavailable, and which would otherwise
evaluate their <small>SV</small> parameter more than
once.</p>

<p style="margin-left:17%; margin-top: 1em">PL_Sv</p>

<p style="margin-left:11%;">&quot;sv_2bool&quot;</p>

<p style="margin-left:17%;">This macro is only used by
&quot;sv_true()&quot; or its macro equivalent, and only if
the latter&rsquo;s argument is neither &quot;SvPOK&quot;,
&quot;SvIOK&quot; nor &quot;SvNOK&quot;. It calls
&quot;sv_2bool_flags&quot; with the &quot;SV_GMAGIC&quot;
flag.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_2bool(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_2bool_flags&quot;</p>

<p style="margin-left:17%;">This function is only used by
&quot;sv_true()&quot; and friends, and only if the
latter&rsquo;s argument is neither &quot;SvPOK&quot;,
&quot;SvIOK&quot; nor &quot;SvNOK&quot;. If the flags
contain &quot;SV_GMAGIC&quot;, then it does an
&quot;mg_get()&quot; first.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_2bool_flags(SV *sv, I32 flags)</p>

<p style="margin-left:11%;">&quot;sv_2num&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;sv_2num&quot; is <b>experimental</b> and may change or
be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Return an
<small>SV</small> with the numeric value of the source
<small>SV,</small> doing any necessary reference or overload
conversion. The caller is expected to have handled get-magic
already.</p>

<p style="margin-left:17%; margin-top: 1em">SV* sv_2num(SV
*const sv)</p>


<p style="margin-left:11%;">&quot;sv_2pvbyte_nolen&quot;</p>

<p style="margin-left:17%;">Return a pointer to the
byte-encoded representation of the <small>SV.</small> May
cause the <small>SV</small> to be downgraded from
<small>UTF&minus;8</small> as a side-effect.</p>

<p style="margin-left:17%; margin-top: 1em">Usually
accessed via the &quot;SvPVbyte_nolen&quot; macro.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_2pvbyte_nolen(SV* sv)</p>


<p style="margin-left:11%;">&quot;sv_2pvutf8_nolen&quot;</p>

<p style="margin-left:17%;">Return a pointer to the
UTF&minus;8&minus;encoded representation of the
<small>SV.</small> May cause the <small>SV</small> to be
upgraded to <small>UTF&minus;8</small> as a side-effect.</p>

<p style="margin-left:17%; margin-top: 1em">Usually
accessed via the &quot;SvPVutf8_nolen&quot; macro.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_2pvutf8_nolen(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_2pv_nolen&quot;</p>

<p style="margin-left:17%;">Like &quot;sv_2pv()&quot;, but
doesn&rsquo;t return the length too. You should usually use
the macro wrapper &quot;SvPV_nolen(sv)&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_2pv_nolen(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_add_arena&quot;</p>

<p style="margin-left:17%;">Given a chunk of memory, link
it to the head of the list of arenas, and split it into a
list of free SVs.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_add_arena(char *const ptr, const U32 size, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_clean_all&quot;</p>

<p style="margin-left:17%;">Decrement the refcnt of each
remaining <small>SV,</small> possibly triggering a cleanup.
This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.</p>

<p style="margin-left:17%; margin-top: 1em">I32
sv_clean_all()</p>

<p style="margin-left:11%;">&quot;sv_clean_objs&quot;</p>

<p style="margin-left:17%;">Attempt to destroy all objects
not yet freed.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_clean_objs()</p>

<p style="margin-left:11%;">&quot;sv_free_arenas&quot;</p>

<p style="margin-left:17%;">Deallocate the memory used by
all arenas. Note that all the individual <small>SV</small>
heads and bodies within the arenas must already have been
freed.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_free_arenas()</p>

<p style="margin-left:11%;">&quot;sv_grow&quot;</p>

<p style="margin-left:17%;">Expands the character buffer in
the <small>SV.</small> If necessary, uses
&quot;sv_unref&quot; and upgrades the <small>SV</small> to
&quot;SVt_PV&quot;. Returns a pointer to the character
buffer. Use the &quot;SvGROW&quot; wrapper instead.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_grow(SV *const sv, STRLEN newlen)</p>

<p style="margin-left:11%;">&quot;sv_grow_fresh&quot;</p>

<p style="margin-left:17%;">A cut-down version of sv_grow
intended only for when sv is a freshly-minted SVt_PV,
SVt_PVIV, SVt_PVNV, or SVt_PVMG. i.e. sv has the default
flags, has never been any other type, and does not have an
existing string. Basically, just assigns a char buffer and
returns a pointer to it.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_grow_fresh(SV *const sv, STRLEN newlen)</p>

<p style="margin-left:11%;">&quot;sv_iv&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;sv_iv&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">A private
implementation of the &quot;SvIVx&quot; macro for compilers
which can&rsquo;t cope with complex macro expressions.
Always use the macro instead.</p>

<p style="margin-left:17%; margin-top: 1em">IV sv_iv(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_newref&quot;</p>

<p style="margin-left:17%;">Increment an <small>SV</small>
&rsquo;s reference count. Use the &quot;SvREFCNT_inc()&quot;
wrapper instead.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_newref(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_nv&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;sv_nv&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">A private
implementation of the &quot;SvNVx&quot; macro for compilers
which can&rsquo;t cope with complex macro expressions.
Always use the macro instead.</p>

<p style="margin-left:17%; margin-top: 1em">NV sv_nv(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_pv&quot;</p>

<p style="margin-left:17%;">Use the &quot;SvPV_nolen&quot;
macro instead</p>

<p style="margin-left:17%; margin-top: 1em">char* sv_pv(SV
*sv)</p>

<p style="margin-left:11%;">&quot;sv_pvbyte&quot;</p>

<p style="margin-left:17%;">Use &quot;SvPVbyte_nolen&quot;
instead.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_pvbyte(SV *sv)</p>

<p style="margin-left:11%;">&quot;sv_pvbyten&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;sv_pvbyten&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">A private
implementation of the &quot;SvPVbyte&quot; macro for
compilers which can&rsquo;t cope with complex macro
expressions. Always use the macro instead.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_pvbyten(SV *sv, STRLEN *lp)</p>


<p style="margin-left:11%;">&quot;sv_pvbyten_force&quot;</p>

<p style="margin-left:17%;">The backend for the
&quot;SvPVbytex_force&quot; macro. Always use the macro
instead. If the <small>SV</small> cannot be downgraded from
<small>UTF&minus;8,</small> this croaks.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_pvbyten_force(SV *const sv, STRLEN *const lp)</p>

<p style="margin-left:11%;">&quot;sv_pvn&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;sv_pvn&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">A private
implementation of the &quot;SvPV&quot; macro for compilers
which can&rsquo;t cope with complex macro expressions.
Always use the macro instead.</p>

<p style="margin-left:17%; margin-top: 1em">char* sv_pvn(SV
*sv, STRLEN *lp)</p>

<p style="margin-left:11%;">&quot;sv_pvn_force&quot;</p>

<p style="margin-left:17%;">Get a sensible string out of
the <small>SV</small> somehow. A private implementation of
the &quot;SvPV_force&quot; macro for compilers which
can&rsquo;t cope with complex macro expressions. Always use
the macro instead.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_pvn_force(SV* sv, STRLEN* lp)</p>

<p style="margin-left:11%;">&quot;sv_pvutf8&quot;</p>

<p style="margin-left:17%;">Use the
&quot;SvPVutf8_nolen&quot; macro instead</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_pvutf8(SV *sv)</p>

<p style="margin-left:11%;">&quot;sv_pvutf8n&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;sv_pvutf8n&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">A private
implementation of the &quot;SvPVutf8&quot; macro for
compilers which can&rsquo;t cope with complex macro
expressions. Always use the macro instead.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_pvutf8n(SV *sv, STRLEN *lp)</p>


<p style="margin-left:11%;">&quot;sv_pvutf8n_force&quot;</p>

<p style="margin-left:17%;">The backend for the
&quot;SvPVutf8x_force&quot; macro. Always use the macro
instead.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_pvutf8n_force(SV *const sv, STRLEN *const lp)</p>

<p style="margin-left:11%;">&quot;sv_tainted&quot;</p>

<p style="margin-left:17%;">Test an <small>SV</small> for
taintedness. Use &quot;SvTAINTED&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_tainted(SV *const sv)</p>

<p style="margin-left:11%;">&quot;SvTHINKFIRST&quot;</p>

<p style="margin-left:17%;">A quick flag check to see
whether an &quot;sv&quot; should be passed to
&quot;sv_force_normal&quot; to be &quot;downgraded&quot;
before &quot;SvIVX&quot; or &quot;SvPVX&quot; can be
modified directly.</p>

<p style="margin-left:17%; margin-top: 1em">For example, if
your scalar is a reference and you want to modify the
&quot;SvIVX&quot; slot, you can&rsquo;t just do
&quot;SvROK_off&quot;, as that will leak the referent.</p>

<p style="margin-left:17%; margin-top: 1em">This is used
internally by various sv-modifying functions, such as
&quot;sv_setsv&quot;, &quot;sv_setiv&quot; and
&quot;sv_pvn_force&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">One case that
this does not handle is a gv without SvFAKE set. After</p>

<p style="margin-left:17%; margin-top: 1em">if
(SvTHINKFIRST(gv)) sv_force_normal(gv);</p>

<p style="margin-left:17%; margin-top: 1em">it will still
be a gv.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvTHINKFIRST&quot;
sometimes produces false positives. In those cases
&quot;sv_force_normal&quot; does nothing.</p>

<p style="margin-left:17%; margin-top: 1em">U32
SvTHINKFIRST(SV *sv)</p>

<p style="margin-left:11%;">&quot;sv_true&quot;</p>

<p style="margin-left:17%;">Returns true if the
<small>SV</small> has a true value by Perl&rsquo;s rules.
Use the &quot;SvTRUE&quot; macro instead, which may call
&quot;sv_true()&quot; or may instead use an in-line
version.</p>

<p style="margin-left:17%; margin-top: 1em">I32 sv_true(SV
*const sv)</p>

<p style="margin-left:11%;">&quot;sv_untaint&quot;</p>

<p style="margin-left:17%;">Untaint an <small>SV.</small>
Use &quot;SvTAINTED_off&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_untaint(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_uv&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;sv_uv&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">A private
implementation of the &quot;SvUVx&quot; macro for compilers
which can&rsquo;t cope with complex macro expressions.
Always use the macro instead.</p>

<p style="margin-left:17%; margin-top: 1em">UV sv_uv(SV*
sv)</p>

<h2>Tainting
<a name="Tainting"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;sv_taint&quot;</p>

<p style="margin-left:17%;">Taint an <small>SV.</small> Use
&quot;SvTAINTED_on&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_taint(SV* sv)</p>

<p style="margin-left:11%;">&quot;TAINT&quot;</p>

<p style="margin-left:17%;">If we aren&rsquo;t in taint
checking mode, do nothing; otherwise indicate to
&quot;&quot;TAINT_set&quot;&quot; and
&quot;&quot;TAINT_PROPER&quot;&quot; that some unspecified
element is tainted.</p>

<p style="margin-left:17%; margin-top: 1em">void
TAINT()</p>

<p style="margin-left:11%;">&quot;TAINT_ENV&quot;</p>

<p style="margin-left:17%;">Looks at several components of
%ENV for taintedness, and calls
&quot;&quot;taint_proper&quot;&quot; if any are tainted. The
components it searches are things like $PATH.</p>

<p style="margin-left:17%; margin-top: 1em">void
TAINT_ENV</p>

<p style="margin-left:11%;">&quot;taint_env&quot;</p>

<p style="margin-left:17%;">Implements the &quot;
<small>TAINT_ENV&quot;</small> macro, which you should
generally use instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
taint_env()</p>

<p style="margin-left:11%;">&quot;TAINT_get&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
some element is tainted or not.</p>

<p style="margin-left:17%; margin-top: 1em">bool
TAINT_get()</p>

<p style="margin-left:11%;">&quot;TAINT_IF&quot;</p>

<p style="margin-left:17%;">If &quot;c&quot; evaluates to
true, call &quot;&quot;TAINT&quot;&quot; to indicate that
something is tainted; otherwise do nothing.</p>

<p style="margin-left:17%; margin-top: 1em">void
TAINT_IF(bool c)</p>

<p style="margin-left:11%;">&quot;TAINTING_get&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
taint checking is enabled or not.</p>

<p style="margin-left:17%; margin-top: 1em">bool
TAINTING_get()</p>

<p style="margin-left:11%;">&quot;TAINTING_set&quot;</p>

<p style="margin-left:17%;">Turn taint checking mode
off/on</p>

<p style="margin-left:17%; margin-top: 1em">void
TAINTING_set(bool s)</p>

<p style="margin-left:11%;">&quot;TAINT_NOT&quot;</p>

<p style="margin-left:17%;">Remove any taintedness
previously set by, <i>e.g.</i>, &quot;TAINT&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
TAINT_NOT()</p>

<p style="margin-left:11%;">&quot;TAINT_PROPER&quot;</p>

<p style="margin-left:17%;">If no element is tainted, do
nothing; otherwise output a message (containing
&quot;s&quot;) that indicates there is a tainting violation.
If such violations are fatal, it croaks.</p>

<p style="margin-left:17%; margin-top: 1em">void
TAINT_PROPER(const char * s)</p>

<p style="margin-left:11%;">&quot;taint_proper&quot;</p>

<p style="margin-left:17%;">Implements the &quot;
<small>TAINT_PROPER&quot;</small> macro, which you should
generally use instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
taint_proper(const char* f, const char *const s)</p>

<p style="margin-left:11%;">&quot;TAINT_set&quot;</p>

<p style="margin-left:17%;">If &quot;s&quot; is true,
&quot;&quot;TAINT_get&quot;&quot; returns true; If
&quot;s&quot; is false, &quot;&quot;TAINT_get&quot;&quot;
returns false;</p>

<p style="margin-left:17%; margin-top: 1em">void
TAINT_set(bool s)</p>

<p style="margin-left:11%;">&quot;TAINT_WARN_get&quot;</p>

<p style="margin-left:17%;">Returns false if tainting
violations are fatal; Returns true if they&rsquo;re just
warnings</p>

<p style="margin-left:17%; margin-top: 1em">bool
TAINT_WARN_get()</p>

<p style="margin-left:11%;">&quot;TAINT_WARN_set&quot;</p>

<p style="margin-left:17%;">&quot;s&quot; being true
indicates &quot;&quot;TAINT_WARN_get&quot;&quot; should
return that tainting violations are just warnings</p>

<p style="margin-left:17%; margin-top: 1em">&quot;s&quot;
being false indicates &quot;&quot;TAINT_WARN_get&quot;&quot;
should return that tainting violations are fatal.</p>

<p style="margin-left:17%; margin-top: 1em">void
TAINT_WARN_set(bool s)</p>

<h2>Time
<a name="Time"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Time</p>

<h2>Typedef names
<a name="Typedef names"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Typedef
names</p>

<h2>Unicode Support
<a name="Unicode Support"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;bytes_from_utf8_loc&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;bytes_from_utf8_loc&quot; is <b>experimental</b> and
may change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Like
&quot;&quot;bytes_from_utf8&quot; in perlapi()&quot;, but
takes an extra parameter, a pointer to where to store the
location of the first character in &quot;s&quot; that cannot
be converted to non&minus;UTF8.</p>

<p style="margin-left:17%; margin-top: 1em">If that
parameter is &quot;NULL&quot;, this function behaves
identically to &quot;bytes_from_utf8&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise if
*is_utf8p is 0 on input, the function behaves identically to
&quot;bytes_from_utf8&quot;, except it also sets
*first_non_downgradable to &quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise, the
function returns a newly created
&quot;NUL&quot;&minus;terminated string containing the
non&minus;UTF8 equivalent of the convertible first portion
of &quot;s&quot;. *lenp is set to its length, not including
the terminating &quot;NUL&quot;. If the entire input string
was converted, *is_utf8p is set to a <small>FALSE</small>
value, and *first_non_downgradable is set to
&quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise,
*first_non_downgradable is set to point to the first byte of
the first character in the original string that wasn&rsquo;t
converted. *is_utf8p is unchanged. Note that the new string
may have length 0.</p>

<p style="margin-left:17%; margin-top: 1em">Another way to
look at it is, if *first_non_downgradable is
non&minus;&quot;NULL&quot; and *is_utf8p is
<small>TRUE,</small> this function starts at the beginning
of &quot;s&quot; and converts as many characters in it as
possible stopping at the first one it finds that can&rsquo;t
be converted to non&minus;UTF&minus;8.
*first_non_downgradable is set to point to that. The
function returns the portion that could be converted in a
newly created &quot;NUL&quot;&minus;terminated string, and
*lenp is set to its length, not including the terminating
&quot;NUL&quot;. If the very first character in the original
could not be converted, *lenp will be 0, and the new string
will contain just a single &quot;NUL&quot;. If the entire
input string was converted, *is_utf8p is set to
<small>FALSE</small> and *first_non_downgradable is set to
&quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Upon successful
return, the number of variants in the converted portion of
the string can be computed by having saved the value of
*lenp before the call, and subtracting the after-call value
of *lenp from it.</p>

<p style="margin-left:17%; margin-top: 1em">U8*
bytes_from_utf8_loc(const U8 *s, STRLEN *lenp, <br>
bool *is_utf8p, <br>
const U8 ** first_unconverted)</p>


<p style="margin-left:11%;">&quot;find_uninit_var&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;find_uninit_var&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Find the name
of the undefined variable (if any) that caused the operator
to issue a &quot;Use of uninitialized value&quot; warning.
If match is true, only return a name if its value matches
&quot;uninit_sv&quot;. So roughly speaking, if a unary
operator (such as &quot;OP_COS&quot;) generates a warning,
then following the direct child of the op may yield an
&quot;OP_PADSV&quot; or &quot;OP_GV&quot; that gives the
name of the undefined variable. On the other hand, with
&quot;OP_ADD&quot; there are two branches to follow, so we
only print the variable name if we get an exact match.
&quot;desc_p&quot; points to a string pointer holding the
description of the op. This may be updated if needed.</p>

<p style="margin-left:17%; margin-top: 1em">The name is
returned as a mortal <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">Assumes that
&quot;PL_op&quot; is the <small>OP</small> that originally
triggered the error, and that
&quot;PL_comppad&quot;/&quot;PL_curpad&quot; points to the
currently executing pad.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
find_uninit_var(const OP *const obase, <br>
const SV *const uninit_sv, bool match, <br>
const char **desc_p)</p>

<p style="margin-left:11%;">&quot;isSCRIPT_RUN&quot;</p>

<p style="margin-left:17%;">Returns a bool as to whether or
not the sequence of bytes from &quot;s&quot; up to but not
including &quot;send&quot; form a &quot;script run&quot;.
&quot;utf8_target&quot; is <small>TRUE</small> iff the
sequence starting at &quot;s&quot; is to be treated as
<small>UTF&minus;8.</small> To be precise, except for two
degenerate cases given below, this function returns
<small>TRUE</small> iff all code points in it come from any
combination of three &quot;scripts&quot; given by the
Unicode &quot;Script Extensions&quot; property: Common,
Inherited, and possibly one other. Additionally all decimal
digits must come from the same consecutive sequence of
10.</p>

<p style="margin-left:17%; margin-top: 1em">For example, if
all the characters in the sequence are Greek, or Common, or
Inherited, this function will return <small>TRUE,</small>
provided any decimal digits in it are from the same block of
digits in Common. (These are the <small>ASCII</small> digits
&quot;0&quot;..&quot;9&quot; and additionally a block for
full width forms of these, and several others used in
mathematical notation.) For scripts (unlike Greek) that have
their own digits defined this will accept either digits from
that set or from one of the Common digit sets, but not a
combination of the two. Some scripts, such as Arabic, have
more than one set of digits. All digits must come from the
same set for this function to return
<small>TRUE.</small></p>

<p style="margin-left:17%; margin-top: 1em">*ret_script, if
&quot;ret_script&quot; is not <small>NULL,</small> will on
return of <small>TRUE</small> contain the script found,
using the &quot;SCX_enum&quot; typedef. Its value will be
&quot;SCX_INVALID&quot; if the function returns
<small>FALSE.</small></p>

<p style="margin-left:17%; margin-top: 1em">If the sequence
is empty, <small>TRUE</small> is returned, but *ret_script
(if asked for) will be &quot;SCX_INVALID&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If the sequence
contains a single code point which is unassigned to a
character in the version of Unicode being used, the function
will return <small>TRUE,</small> and the script will be
&quot;SCX_Unknown&quot;. Any other combination of unassigned
code points in the input sequence will result in the
function treating the input as not being a script run.</p>

<p style="margin-left:17%; margin-top: 1em">The returned
script will be &quot;SCX_Inherited&quot; iff all the code
points in it are from the Inherited script.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise, the
returned script will be &quot;SCX_Common&quot; iff all the
code points in it are from the Inherited or Common
scripts.</p>

<p style="margin-left:17%; margin-top: 1em">bool
isSCRIPT_RUN(const U8 *s, const U8 *send, <br>
const bool utf8_target)</p>


<p style="margin-left:11%;">&quot;is_utf8_non_invariant_string&quot;</p>

<p style="margin-left:17%;">Returns <small>TRUE</small> if
&quot;is_utf8_invariant_string&quot; in perlapi returns
<small>FALSE</small> for the first &quot;len&quot; bytes of
the string &quot;s&quot;, but they are, nonetheless, legal
Perl-extended <small>UTF&minus;8</small> ; otherwise returns
<small>FALSE.</small></p>

<p style="margin-left:17%; margin-top: 1em">A
<small>TRUE</small> return means that at least one code
point represented by the sequence either is a wide character
not representable as a single byte, or the representation
differs depending on whether the sequence is encoded in
<small>UTF&minus;8</small> or not.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;&quot;is_utf8_invariant_string&quot; in perlapi&quot;,
&quot;&quot;is_utf8_string&quot; in perlapi&quot;</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_non_invariant_string(const U8* const s, STRLEN
len)</p>

<p style="margin-left:11%;">&quot;report_uninit&quot;</p>

<p style="margin-left:17%;">Print appropriate &quot;Use of
uninitialized variable&quot; warning.</p>

<p style="margin-left:17%; margin-top: 1em">void
report_uninit(const SV *uninit_sv)</p>

<p style="margin-left:11%;">&quot;utf8n_to_uvuni&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;utf8n_to_uvuni&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Instead use
&quot;utf8_to_uvchr_buf&quot; in perlapi, or rarely,
&quot;utf8n_to_uvchr&quot; in perlapi.</p>

<p style="margin-left:17%; margin-top: 1em">This function
was useful for code that wanted to handle both
<small>EBCDIC</small> and <small>ASCII</small> platforms
with Unicode properties, but starting in Perl v5.20, the
distinctions between the platforms have mostly been made
invisible to most code, so this function is quite unlikely
to be what you want. If you do need this precise
functionality, use instead
&quot;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&quot; or
&quot;NATIVE_TO_UNI(utf8n_to_uvchr(...))&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">UV
utf8n_to_uvuni(const U8 *s, STRLEN curlen, STRLEN *retlen,
<br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;utf8_to_uvuni&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;utf8_to_uvuni&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
Unicode code point of the first character in the string
&quot;s&quot; which is assumed to be in
<small>UTF&minus;8</small> encoding; &quot;retlen&quot; will
be set to the length, in bytes, of that character.</p>

<p style="margin-left:17%; margin-top: 1em">Some, but not
all, <small>UTF&minus;8</small> malformations are detected,
and in fact, some malformed input could cause reading beyond
the end of the input buffer, which is one reason why this
function is deprecated. The other is that only in extremely
limited circumstances should the Unicode versus native code
point be of any interest to you. See
&quot;utf8_to_uvuni_buf&quot; for alternatives.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;s&quot; points to one of the detected malformations,
and <small>UTF8</small> warnings are enabled, zero is
returned and *retlen is set (if &quot;retlen&quot;
doesn&rsquo;t point to <small>NULL</small> ) to &minus;1. If
those warnings are off, the computed value if well-defined
(or the Unicode <small>REPLACEMENT CHARACTER,</small> if
not) is silently returned, and *retlen is set (if
&quot;retlen&quot; isn&rsquo;t <small>NULL</small> ) so that
(&quot;s&quot;&nbsp;+&nbsp;*retlen) is the next possible
position in &quot;s&quot; that could begin a non-malformed
character. See &quot;utf8n_to_uvchr&quot; in perlapi for
details on when the <small>REPLACEMENT CHARACTER</small> is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">UV
utf8_to_uvuni(const U8 *s, STRLEN *retlen)</p>


<p style="margin-left:11%;">&quot;utf8_to_uvuni_buf&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;utf8_to_uvuni_buf&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Only in very
rare circumstances should code need to be dealing in Unicode
(as opposed to native) code points. In those few cases, use
&quot;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&quot; instead.
If you are not absolutely sure this is one of those cases,
then assume it isn&rsquo;t and use plain
&quot;utf8_to_uvchr_buf&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
Unicode (not-native) code point of the first character in
the string &quot;s&quot; which is assumed to be in
<small>UTF&minus;8</small> encoding; &quot;send&quot; points
to 1 beyond the end of &quot;s&quot;. &quot;retlen&quot;
will be set to the length, in bytes, of that character.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;s&quot; does not point to a well-formed
<small>UTF&minus;8</small> character and <small>UTF8</small>
warnings are enabled, zero is returned and *retlen is set
(if &quot;retlen&quot; isn&rsquo;t <small>NULL</small> ) to
&minus;1. If those warnings are off, the computed value if
well-defined (or the Unicode <small>REPLACEMENT
CHARACTER,</small> if not) is silently returned, and *retlen
is set (if &quot;retlen&quot; isn&rsquo;t
<small>NULL</small> ) so that
(&quot;s&quot;&nbsp;+&nbsp;*retlen) is the next possible
position in &quot;s&quot; that could begin a non-malformed
character. See &quot;utf8n_to_uvchr&quot; in perlapi for
details on when the <small>REPLACEMENT CHARACTER</small> is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">UV
utf8_to_uvuni_buf(const U8 *s, const U8 *send, STRLEN
*retlen)</p>


<p style="margin-left:11%;">&quot;uvoffuni_to_utf8_flags&quot;</p>

<p style="margin-left:17%;"><small>THIS FUNCTION SHOULD BE
USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.</small>
Instead, <b>Almost all code should use
&quot;uvchr_to_utf8&quot; in perlapi or
&quot;uvchr_to_utf8_flags&quot; in perlapi</b>.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is like them, but the input is a strict Unicode (as opposed
to native) code point. Only in very rare circumstances
should code not be using the native code point.</p>

<p style="margin-left:17%; margin-top: 1em">For details,
see the description for &quot;uvchr_to_utf8_flags&quot; in
perlapi.</p>

<p style="margin-left:17%; margin-top: 1em">U8*
uvoffuni_to_utf8_flags(U8 *d, UV uv, UV flags)</p>


<p style="margin-left:11%;">&quot;uvuni_to_utf8_flags&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;uvuni_to_utf8_flags&quot; from
a future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Instead you
almost certainly want to use &quot;uvchr_to_utf8&quot; in
perlapi or &quot;uvchr_to_utf8_flags&quot; in perlapi.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is a deprecated synonym for
&quot;uvoffuni_to_utf8_flags&quot;, which itself, while not
deprecated, should be used only in isolated circumstances.
These functions were useful for code that wanted to handle
both <small>EBCDIC</small> and <small>ASCII</small>
platforms with Unicode properties, but starting in Perl
v5.20, the distinctions between the platforms have mostly
been made invisible to most code, so this function is quite
unlikely to be what you want.</p>

<p style="margin-left:17%; margin-top: 1em">U8*
uvuni_to_utf8_flags(U8 *d, UV uv, UV flags)</p>


<p style="margin-left:11%;">&quot;valid_utf8_to_uvchr&quot;</p>

<p style="margin-left:17%;">Like
&quot;&quot;utf8_to_uvchr_buf&quot; in perlapi&quot;, but
should only be called when it is known that the next
character in the input <small>UTF&minus;8</small> string
&quot;s&quot; is well-formed (<i>e.g.</i>, it passes
&quot;&quot;isUTF8_CHAR&quot; in perlapi&quot;. Surrogates,
non-character code points, and non-Unicode code points are
allowed.</p>

<p style="margin-left:17%; margin-top: 1em">UV
valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)</p>


<p style="margin-left:11%;">&quot;variant_under_utf8_count&quot;</p>

<p style="margin-left:17%;">This function looks at the
sequence of bytes between &quot;s&quot; and &quot;e&quot;,
which are assumed to be encoded in ASCII/Latin1, and returns
how many of them would change should the string be
translated into <small>UTF&minus;8.</small> Due to the
nature of <small>UTF&minus;8,</small> each of these would
occupy two bytes instead of the single one in the input
string. Thus, this function returns the precise number of
bytes the string would expand by when translated to
<small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">Unlike most of
the other functions that have &quot;utf8&quot; in their
name, the input to this function is <small>NOT</small> a
UTF&minus;8&minus;encoded string. The function name is
slightly <i>odd</i> to emphasize this.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is internal to Perl because khw thinks that any
<small>XS</small> code that would want this is probably
operating too close to the internals. Presenting a valid use
case could change that.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;&quot;is_utf8_invariant_string&quot; in perlapi&quot;
and &quot;&quot;is_utf8_invariant_string_loc&quot; in
perlapi&quot;,</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
variant_under_utf8_count(const U8* const s, <br>
const U8* const e)</p>

<h2>Utility Functions
<a name="Utility Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;my_popen_list&quot;</p>

<p style="margin-left:17%;">Implementing function on some
systems for <b>PerlProc_popen_list()</b></p>

<p style="margin-left:17%; margin-top: 1em">PerlIO*
my_popen_list(const char* mode, int n, SV ** args)</p>

<p style="margin-left:11%;">&quot;my_socketpair&quot;</p>

<p style="margin-left:17%;">Emulates <b>socketpair</b>(2)
on systems that don&rsquo;t have it, but which do have
enough functionality for the emulation.</p>

<p style="margin-left:17%; margin-top: 1em">int
my_socketpair(int family, int type, int protocol, int
fd[2])</p>

<h2>Versioning
<a name="Versioning"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in Versioning</p>

<h2>Warning and Dieing
<a name="Warning and Dieing"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;PL_dowarn&quot;</p>

<p style="margin-left:17%;">The C variable that roughly
corresponds to Perl&rsquo;s $^W warning variable. However,
$^W is treated as a boolean, whereas &quot;PL_dowarn&quot;
is a collection of flag bits.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">U8
PL_dowarn</p>

<h2>XS
<a name="XS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are only
public <small>API</small> items currently in
<small>XS</small></p>

<h2>Undocumented elements
<a name="Undocumented elements"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
functions are currently undocumented. If you use one of
them, you may wish to consider creating and submitting
documentation for it.</p>


<p style="margin-left:11%; margin-top: 1em">abort_execution
<br>
add_cp_to_invlist <br>
_add_range_to_invlist <br>
alloc_LOGOP <br>
allocmy <br>
amagic_cmp <br>
amagic_cmp_desc <br>
amagic_cmp_locale <br>
amagic_cmp_locale_desc <br>
amagic_is_enabled <br>
amagic_i_ncmp <br>
amagic_i_ncmp_desc <br>
amagic_ncmp <br>
amagic_ncmp_desc <br>
any_dup <br>
append_utf8_from_native_byte <br>
apply <br>
ASCII_TO_NEED <br>
atfork_lock <br>
atfork_unlock <br>
av_arylen_p <br>
av_extend_guts <br>
av_iter_p <br>
av_nonelem <br>
av_reify <br>
bind_match <br>
block_gimme <br>
boot_core_builtin <br>
boot_core_mro <br>
boot_core_PerlIO <br>
boot_core_UNIVERSAL <br>
_byte_dump_string <br>
call_list <br>
cando <br>
cast_i32 <br>
cast_iv <br>
cast_ulong <br>
cast_uv <br>
check_utf8_print <br>
ck_anoncode <br>
ck_backtick <br>
ck_bitop <br>
ck_cmp <br>
ck_concat <br>
ck_defined <br>
ck_delete <br>
ck_each <br>
ck_entersub_args_core <br>
ck_eof <br>
ck_eval <br>
ck_exec <br>
ck_exists <br>
ck_ftst <br>
ck_fun <br>
ck_glob <br>
ck_grep <br>
ck_index <br>
ck_isa <br>
ck_join <br>
ck_length <br>
ck_lfun <br>
ck_listiob <br>
ck_match <br>
ck_method <br>
ck_null <br>
ck_open <br>
ck_prototype <br>
ck_readline <br>
ck_refassign <br>
ck_repeat <br>
ck_require <br>
ck_return <br>
ck_rfun <br>
ck_rvconst <br>
ck_sassign <br>
ck_select <br>
ck_shift <br>
ck_smartmatch <br>
ck_sort <br>
ck_spair <br>
ck_split <br>
ck_stringify <br>
ck_subr <br>
ck_substr <br>
ck_svconst <br>
ck_tell <br>
ck_trunc <br>
ck_trycatch <br>
ckwarn <br>
ckwarn_d <br>
clear_defarray <br>
closest_cop <br>
cmpchain_extend <br>
cmpchain_finish <br>
cmpchain_start <br>
cmp_desc <br>
cmp_locale_desc <br>
cntrl_to_mnemonic <br>
cop_file_avn <br>
coresub_op <br>
create_eval_scope <br>
croak_caller <br>
croak_memory_wrap <br>
croak_no_mem <br>
croak_popstack <br>
csighandler <br>
csighandler1 <br>
csighandler3 <br>
current_re_engine <br>
custom_op_get_field <br>
cv_ckproto_len_flags <br>
cv_clone_into <br>
cv_const_sv_or_av <br>
cvgv_from_hek <br>
cvgv_set <br>
cvstash_set <br>
cv_undef_flags <br>
cx_dump <br>
cx_dup <br>
cxinc <br>
cx_popblock <br>
cx_popeval <br>
cx_popformat <br>
cx_popgiven <br>
cx_poploop <br>
cx_popsub <br>
cx_popsub_args <br>
cx_popsub_common <br>
cx_popwhen <br>
cx_pushblock <br>
cx_pusheval <br>
cx_pushformat <br>
cx_pushgiven <br>
cx_pushloop_for <br>
cx_pushloop_plain <br>
cx_pushsub <br>
cx_pushtry <br>
cx_pushwhen <br>
cx_topblock <br>
debstackptrs <br>
deb_stack_all <br>
debug_hash_seed <br>
defelem_target <br>
delete_eval_scope <br>
despatch_signals <br>
die_unwind <br>
do_aexec <br>
do_aexec5 <br>
do_aspawn <br>
do_eof <br>
does_utf8_overflow <br>
do_exec <br>
do_exec3 <br>
dofile <br>
do_gvgv_dump <br>
do_gv_dump <br>
do_hv_dump <br>
doing_taint <br>
do_ipcctl <br>
do_ipcget <br>
do_magic_dump <br>
do_msgrcv <br>
do_msgsnd <br>
do_ncmp <br>
do_open6 <br>
do_open_raw <br>
do_op_dump <br>
do_pmop_dump <br>
do_print <br>
do_readline <br>
doref <br>
do_seek <br>
do_semop <br>
do_shmio <br>
do_spawn <br>
do_spawn_nowait <br>
do_sv_dump <br>
do_sysseek <br>
do_tell <br>
do_trans <br>
do_uniprop_match <br>
do_vecget <br>
do_vecset <br>
do_vop <br>
drand48_init_r <br>
drand48_r <br>
dtrace_probe_call <br>
dtrace_probe_load <br>
dtrace_probe_op <br>
dtrace_probe_phase <br>
dump_all_perl <br>
dump_indent <br>
dump_packsubs_perl <br>
dump_sub_perl <br>
dump_sv_child <br>
dump_vindent <br>
dup_warnings <br>
emulate_cop_io <br>
find_first_differing_byte_pos <br>
find_lexical_cv <br>
find_runcv_where <br>
find_script <br>
foldEQ_latin1 <br>
foldEQ_latin1_s2_folded <br>
foldEQ_utf8_flags <br>
_force_out_malformed_utf8_message <br>
form_alien_digit_msg <br>
form_cp_too_large_msg <br>
free_tied_hv_pool <br>
free_tmps <br>
get_and_check_backslash_N_name <br>
get_db_sub <br>
get_debug_opts <br>
get_deprecated_property_msg <br>
getenv_len <br>
get_hash_seed <br>
get_invlist_iter_addr <br>
get_invlist_offset_addr <br>
get_invlist_previous_index_addr <br>
get_mstats <br>
get_no_modify <br>
get_opargs <br>
get_ppaddr <br>
get_prop_definition <br>
get_prop_values <br>
get_regclass_nonbitmap_data <br>
get_regex_charset_name <br>
get_re_arg <br>
get_re_gclass_nonbitmap_data <br>
get_vtbl <br>
gimme_V <br>
gp_free <br>
gp_ref <br>
grok_bin_oct_hex <br>
grok_bslash_c <br>
grok_bslash_o <br>
grok_bslash_x <br>
gv_check <br>
gv_fetchmeth_internal <br>
gv_override <br>
gv_setref <br>
gv_stashpvn_internal <br>
he_dup <br>
hek_dup <br>
hfree_next_entry <br>
hv_auxalloc <br>
hv_backreferences_p <br>
hv_common <br>
hv_common_key_len <br>
hv_delayfree_ent <br>
hv_kill_backrefs <br>
hv_placeholders_p <br>
hv_pushkv <br>
hv_rand_set <br>
hv_undef_flags <br>
init_argv_symbols <br>
init_constants <br>
init_dbargs <br>
init_debugger <br>
init_i18nl10n <br>
init_i18nl14n <br>
init_named_cv <br>
init_stacks <br>
init_tm <br>
init_uniprops <br>
_inverse_folds <br>
invert <br>
invlist_array <br>
invlist_clear <br>
invlist_clone <br>
invlist_contents <br>
_invlistEQ <br>
invlist_extend <br>
invlist_highest <br>
invlist_is_iterating <br>
invlist_iterfinish <br>
invlist_iterinit <br>
invlist_iternext <br>
invlist_lowest <br>
invlist_max <br>
invlist_previous_index <br>
invlist_set_len <br>
invlist_set_previous_index <br>
invlist_trim <br>
_invlist_array_init <br>
_invlist_contains_cp <br>
_invlist_dump <br>
_invlist_intersection <br>
_invlist_intersection_maybe_complement_2nd <br>
_invlist_invert <br>
_invlist_len <br>
_invlist_search <br>
_invlist_subtract <br>
_invlist_union <br>
_invlist_union_maybe_complement_2nd <br>
invmap_dump <br>
io_close <br>
isFF_overlong <br>
is_grapheme <br>
is_invlist <br>
is_utf8_char_helper_ <br>
is_utf8_common <br>
is_utf8_FF_helper_ <br>
is_utf8_overlong <br>
_is_cur_LC_category_utf8 <br>
_is_in_locale_category <br>
_is_uni_FOO <br>
_is_uni_perl_idcont <br>
_is_uni_perl_idstart <br>
_is_utf8_FOO <br>
_is_utf8_perl_idcont <br>
_is_utf8_perl_idstart <br>
jmaybe <br>
keyword <br>
keyword_plugin_standard <br>
list <br>
load_charnames <br>
localize <br>
lossless_NV_to_IV <br>
lsbit_pos32 <br>
lsbit_pos64 <br>
magic_cleararylen_p <br>
magic_clearenv <br>
magic_clearisa <br>
magic_clearpack <br>
magic_clearsig <br>
magic_clear_all_env <br>
magic_copycallchecker <br>
magic_existspack <br>
magic_freearylen_p <br>
magic_freecollxfrm <br>
magic_freemglob <br>
magic_freeovrld <br>
magic_freeutf8 <br>
magic_get <br>
magic_getarylen <br>
magic_getdebugvar <br>
magic_getdefelem <br>
magic_getnkeys <br>
magic_getpack <br>
magic_getpos <br>
magic_getsig <br>
magic_getsubstr <br>
magic_gettaint <br>
magic_getuvar <br>
magic_getvec <br>
magic_killbackrefs <br>
magic_nextpack <br>
magic_regdata_cnt <br>
magic_regdatum_get <br>
magic_regdatum_set <br>
magic_scalarpack <br>
magic_set <br>
magic_setarylen <br>
magic_setcollxfrm <br>
magic_setdbline <br>
magic_setdebugvar <br>
magic_setdefelem <br>
magic_setenv <br>
magic_setisa <br>
magic_setlvref <br>
magic_setmglob <br>
magic_setnkeys <br>
magic_setnonelem <br>
magic_setpack <br>
magic_setpos <br>
magic_setregexp <br>
magic_setsig <br>
magic_setsigall <br>
magic_setsubstr <br>
magic_settaint <br>
magic_setutf8 <br>
magic_setuvar <br>
magic_setvec <br>
magic_set_all_env <br>
magic_sizepack <br>
magic_wipepack <br>
malloced_size <br>
malloc_good_size <br>
markstack_grow <br>
mem_collxfrm <br>
mem_log_alloc <br>
mem_log_del_sv <br>
mem_log_free <br>
mem_log_new_sv <br>
mem_log_realloc <br>
_mem_collxfrm <br>
mg_find_mglob <br>
mg_size <br>
mode_from_discipline <br>
more_bodies <br>
more_sv <br>
moreswitches <br>
mortal_getenv <br>
mro_get_private_data <br>
mro_meta_dup <br>
mro_meta_init <br>
msbit_pos32 <br>
msbit_pos64 <br>
multiconcat_stringify <br>
multideref_stringify <br>
my_atof2 <br>
my_atof3 <br>
my_attrs <br>
my_clearenv <br>
my_lstat <br>
my_lstat_flags <br>
my_memrchr <br>
my_mkostemp_cloexec <br>
my_mkstemp_cloexec <br>
my_stat <br>
my_stat_flags <br>
my_strerror <br>
my_unexec <br>
NATIVE_TO_NEED <br>
newFORM <br>
newGP <br>
newMETHOP_internal <br>
newMYSUB <br>
newPROG <br>
new_stackinfo <br>
newSTUB <br>
newSVavdefelem <br>
new_warnings_bitfield <br>
newXS_deffile <br>
_new_invlist <br>
_new_invlist_C_array <br>
nextargv <br>
no_bareword_filehandle <br>
noperl_die <br>
notify_parser_that_changed_to_utf8 <br>
oopsAV <br>
oopsHV <br>
op_clear <br>
op_integerize <br>
op_lvalue_flags <br>
opmethod_stash <br>
op_refcnt_dec <br>
op_refcnt_inc <br>
op_relocate_sv <br>
opslab_force_free <br>
opslab_free <br>
opslab_free_nopad <br>
op_std_init <br>
op_unscope <br>
package <br>
package_version <br>
pad_add_weakref <br>
padlist_store <br>
padname_free <br>
PadnameIN_SCOPE <br>
padnamelist_free <br>
parser_dup <br>
parser_free <br>
parser_free_nexttoke_ops <br>
parse_unicode_opts <br>
path_is_searchable <br>
peep <br>
perl_alloc_using <br>
perl_clone_using <br>
PerlIO_context_layers <br>
PerlIO_restore_errno <br>
PerlIO_save_errno <br>
PerlLIO_dup2_cloexec <br>
PerlLIO_dup_cloexec <br>
PerlLIO_open3_cloexec <br>
PerlLIO_open_cloexec <br>
PerlProc_pipe_cloexec <br>
PerlSock_accept_cloexec <br>
PerlSock_socketpair_cloexec <br>
PerlSock_socket_cloexec <br>
perly_sighandler <br>
pmruntime <br>
POPMARK <br>
populate_isa <br>
pregfree <br>
pregfree2 <br>
qerror <br>
ReANY <br>
reentrant_free <br>
reentrant_init <br>
reentrant_retry <br>
reentrant_size <br>
re_exec_indentf <br>
ref <br>
regcurly <br>
regdump <br>
regdupe_internal <br>
regexec_flags <br>
regfree_internal <br>
reginitcolors <br>
reg_named_buff <br>
reg_named_buff_all <br>
reg_named_buff_exists <br>
reg_named_buff_fetch <br>
reg_named_buff_firstkey <br>
reg_named_buff_iter <br>
reg_named_buff_nextkey <br>
reg_named_buff_scalar <br>
regnext <br>
reg_numbered_buff_fetch <br>
reg_numbered_buff_length <br>
reg_numbered_buff_store <br>
regprop <br>
reg_qr_package <br>
reg_skipcomment <br>
reg_temp_copy <br>
re_indentf <br>
re_intuit_start <br>
re_intuit_string <br>
re_op_compile <br>
report_evil_fh <br>
report_redefined_cv <br>
report_wrongway_fh <br>
re_printf <br>
rpeep <br>
rsignal_restore <br>
rsignal_save <br>
rvpv_dup <br>
rxres_save <br>
same_dirent <br>
save_bool <br>
save_clearsv <br>
save_delete <br>
save_destructor <br>
save_destructor_x <br>
save_freeop <br>
save_freepv <br>
save_freesv <br>
save_I16 <br>
save_I32 <br>
save_I8 <br>
save_int <br>
save_iv <br>
save_long <br>
save_mortalizesv <br>
save_pptr <br>
save_re_context <br>
save_sptr <br>
savestack_grow <br>
savestack_grow_cnt <br>
save_strlen <br>
save_to_buffer <br>
sawparens <br>
scalar <br>
scalarvoid <br>
scan_num <br>
scan_str <br>
scan_word <br>
seed <br>
set_caret_X <br>
setfd_cloexec <br>
setfd_cloexec_for_nonsysfd <br>
setfd_cloexec_or_inhexec_by_sysfdness <br>
setfd_inhexec <br>
setfd_inhexec_for_sysfd <br>
set_numeric_standard <br>
set_numeric_underlying <br>
set_padlist <br>
_setup_canned_invlist <br>
share_hek <br>
should_warn_nl <br>
should_we_output_Debug_r <br>
sighandler <br>
sighandler1 <br>
sighandler3 <br>
single_1bit_pos32 <br>
single_1bit_pos64 <br>
skipspace_flags <br>
Slab_Alloc <br>
Slab_Free <br>
Slab_to_ro <br>
Slab_to_rw <br>
softref2xv <br>
sortsv_flags_impl <br>
stack_grow <br>
str_to_version <br>
sub_crush_depth <br>
sv_2iv <br>
sv_2uv <br>
sv_add_backref <br>
sv_buf_to_ro <br>
sv_del_backref <br>
sv_free2 <br>
sv_i_ncmp <br>
sv_i_ncmp_desc <br>
sv_kill_backrefs <br>
sv_magicext_mglob <br>
sv_ncmp <br>
sv_ncmp_desc <br>
sv_only_taint_gmagic <br>
sv_or_pv_pos_u2b <br>
sv_resetpvn <br>
sv_sethek <br>
sv_setsv_cow <br>
SvTRUE_common <br>
sv_unglob <br>
sys_init <br>
sys_init3 <br>
sys_intern_clear <br>
sys_intern_dup <br>
sys_intern_init <br>
sys_term <br>
tied_method <br>
tmps_grow_p <br>
TOPMARK <br>
to_uni_fold <br>
to_uni_lower <br>
to_uni_title <br>
to_uni_upper <br>
_to_fold_latin1 <br>
_to_uni_fold_flags <br>
_to_upper_title_latin1 <br>
_to_utf8_fold_flags <br>
_to_utf8_lower_flags <br>
_to_utf8_title_flags <br>
_to_utf8_upper_flags <br>
translate_substr_offsets <br>
try_amagic_bin <br>
try_amagic_un <br>
uiv_2buf <br>
unlnk <br>
unshare_hek <br>
utf16_to_utf8 <br>
utf16_to_utf8_base <br>
utf16_to_utf8_reversed <br>
_utf8n_to_uvchr_msgs_helper <br>
utf8_to_utf16_base <br>
utf8_to_uvchr_buf_helper <br>
utilize <br>
uvoffuni_to_utf8_flags_msgs <br>
uvuni_to_utf8 <br>
valid_utf8_to_uvuni <br>
variant_byte_number <br>
varname <br>
vivify_defelem <br>
vivify_ref <br>
wait4pid <br>
_warn_problematic_locale <br>
was_lvalue_sub <br>
watch <br>
win32_croak_not_implemented <br>
write_to_stderr <br>
xs_boot_epilog <br>
xs_handshake <br>
yyerror <br>
yyerror_pv <br>
yyerror_pvn <br>
yylex <br>
yyparse <br>
yyquit <br>
yyunlex</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
autodocumentation system was originally added to the Perl
core by Benjamin Stuhl. Documentation is by whoever was kind
enough to document their functions.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>config.h</i>,
perlapi, perlapio, perlcall, perlclib, perlembed,
perlfilter, perlguts, perlhacktips, perlinterp, perliol,
perlmroapi, perlreapi, perlreguts, perlxs</p>
<hr>
</body>
</html>
