<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:52 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>JQ</title>

</head>
<body>
<h1>jq</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>jq</b>
&minus; Command&minus;line JSON processor</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>jq</b>
[<i>options</i>...] <i>filter</i> [<i>files</i>...]</p>

<p style="margin-left:11%; margin-top: 1em"><b>jq</b> can
transform JSON in various ways, by selecting, iterating,
reducing and otherwise mangling JSON documents. For
instance, running the command <b>jq &acute;map(.price) |
add&acute;</b> will take an array of JSON objects as input
and return the sum of their &quot;price&quot; fields.</p>

<p style="margin-left:11%; margin-top: 1em"><b>jq</b> can
accept text input as well, but by default, <b>jq</b> reads a
stream of JSON entities (including numbers and other
literals) from <b>stdin</b>. Whitespace is only needed to
separate entities such as 1 and 2, and true and false. One
or more <i>files</i> may be specified, in which case
<b>jq</b> will read input from those instead.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>options</i> are described in the <i>INVOKING JQ</i>
section; they mostly concern input and output formatting.
The <i>filter</i> is written in the jq language and
specifies how to transform the input file or document.</p>

<h2>FILTERS
<a name="FILTERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A jq program is
a &quot;filter&quot;: it takes an input, and produces an
output. There are a lot of builtin filters for extracting a
particular field of an object, or converting a number to a
string, or various other standard tasks.</p>

<p style="margin-left:11%; margin-top: 1em">Filters can be
combined in various ways &minus; you can pipe the output of
one filter into another filter, or collect the output of a
filter into an array.</p>

<p style="margin-left:11%; margin-top: 1em">Some filters
produce multiple results, for instance there&acute;s one
that produces all the elements of its input array. Piping
that filter into a second runs the second filter for each
element of the array. Generally, things that would be done
with loops and iteration in other languages are just done by
gluing filters together in jq.</p>

<p style="margin-left:11%; margin-top: 1em">It&acute;s
important to remember that every filter has an input and an
output. Even literals like &quot;hello&quot; or 42 are
filters &minus; they take an input but always produce the
same literal as output. Operations that combine two filters,
like addition, generally feed the same input to both and
combine the results. So, you can implement an averaging
filter as <b>add / length</b> &minus; feeding the input
array both to the <b>add</b> filter and the <b>length</b>
filter and then performing the division.</p>

<p style="margin-left:11%; margin-top: 1em">But
that&acute;s getting ahead of ourselves. :) Let&acute;s
start with something simpler:</p>

<h2>INVOKING JQ
<a name="INVOKING JQ"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">jq filters run
on a stream of JSON data. The input to jq is parsed as a
sequence of whitespace&minus;separated JSON values which are
passed through the provided filter one at a time. The
output(s) of the filter are written to standard out, again
as a sequence of whitespace&minus;separated JSON data.</p>

<p style="margin-left:11%; margin-top: 1em">Note: it is
important to mind the shell&acute;s quoting rules. As a
general rule it&acute;s best to always quote (with
single&minus;quote characters) the jq program, as too many
characters with special meaning to jq are also shell
meta&minus;characters. For example, <b>jq
&quot;foo&quot;</b> will fail on most Unix shells because
that will be the same as <b>jq foo</b>, which will generally
fail because <b>foo is not defined</b>. When using the
Windows command shell (cmd.exe) it&acute;s best to use
double quotes around your jq program when given on the
command&minus;line (instead of the <b>&minus;f
program&minus;file</b> option), but then double&minus;quotes
in the jq program need backslash escaping.</p>

<p style="margin-left:11%; margin-top: 1em">You can affect
how jq reads and writes its input and output using some
command&minus;line options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p><b>&minus;&minus;version</b>:</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Output the jq
version and exit with zero.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>&minus;&minus;seq</b>:</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Use the
<b>application/json&minus;seq</b> MIME type scheme for
separating JSON texts in jq&acute;s input and output. This
means that an ASCII RS (record separator) character is
printed before each value on output and an ASCII LF (line
feed) is printed after every output. Input JSON texts that
fail to parse are ignored (but warned about), discarding all
subsequent input until the next RS. This mode also parses
the output of jq without the <b>&minus;&minus;seq</b>
option.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">



<p style="margin-top: 1em"><b>&minus;&minus;stream</b>:</p> </td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Parse the input
in streaming fashion, outputing arrays of path and leaf
values (scalars and empty arrays or empty objects). For
example, <b>&quot;a&quot;</b> becomes
<b>[[],&quot;a&quot;]</b>, and
<b>[[],&quot;a&quot;,[&quot;b&quot;]]</b> becomes
<b>[[0],[]]</b>, <b>[[1],&quot;a&quot;]</b>, and
<b>[[1,0],&quot;b&quot;]</b>.</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
for processing very large inputs. Use this in conjunction
with filtering and the <b>reduce</b> and <b>foreach</b>
syntax to reduce large inputs incrementally.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">



<p style="margin-top: 1em"><b>&minus;&minus;slurp</b>/<b>&minus;s</b>:</p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Instead of
running the filter for each JSON object in the input, read
the entire input stream into a large array and run the
filter just once.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">



<p style="margin-top: 1em"><b>&minus;&minus;raw&minus;input</b>/<b>&minus;R</b>:</p> </td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Don&acute;t
parse the input as JSON. Instead, each line of text is
passed to the filter as a string. If combined with
<b>&minus;&minus;slurp</b>, then the entire input is passed
to the filter as a single long string.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="25%">



<p style="margin-top: 1em"><b>&minus;&minus;null&minus;input</b>/<b>&minus;n</b>:</p> </td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Don&acute;t
read any input at all! Instead, the filter is run once using
<b>null</b> as the input. This is useful when using jq as a
simple calculator or to construct JSON data from
scratch.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="34%">



<p style="margin-top: 1em"><b>&minus;&minus;compact&minus;output</b>
/ <b>&minus;c</b>:</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">By default, jq
pretty&minus;prints JSON output. Using this option will
result in more compact output by instead putting each JSON
object on a single line.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>&minus;&minus;tab</b>:</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Use a tab for
each indentation level instead of two spaces.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">


<p style="margin-top: 1em"><b>&minus;&minus;indent
n</b>:</p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Use the given
number of spaces (no more than 8) for indentation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="75%">



<p style="margin-top: 1em"><b>&minus;&minus;color&minus;output</b>
/ <b>&minus;C</b> and
<b>&minus;&minus;monochrome&minus;output</b> /
<b>&minus;M</b>:</p> </td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">By default, jq
outputs colored JSON if writing to a terminal. You can force
it to produce color even if writing to a pipe or a file
using <b>&minus;C</b>, and disable color with
<b>&minus;M</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Colors can be
configured with the <b>JQ_COLORS</b> environment variable
(see below).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="31%">



<p style="margin-top: 1em"><b>&minus;&minus;ascii&minus;output</b>
/ <b>&minus;a</b>:</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">jq usually
outputs non&minus;ASCII Unicode codepoints as UTF&minus;8,
even if the input specified them as escape sequences (like
&quot;\u03bc&quot;). Using this option, you can force jq to
produce pure ASCII output with every non&minus;ASCII
character replaced with the equivalent escape sequence.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="18%">



<p style="margin-top: 1em"><b>&minus;&minus;unbuffered</b></p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Flush the
output after each JSON object is printed (useful if
you&acute;re piping a slow data source into jq and piping
jq&acute;s output elsewhere).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">



<p style="margin-top: 1em"><b>&minus;&minus;sort&minus;keys</b>
/ <b>&minus;S</b>:</p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Output the
fields of each object with the keys in sorted order.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">



<p style="margin-top: 1em"><b>&minus;&minus;raw&minus;output</b>
/ <b>&minus;r</b>:</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">With this
option, if the filter&acute;s result is a string then it
will be written directly to standard output rather than
being formatted as a JSON string with quotes. This can be
useful for making jq filters talk to
non&minus;JSON&minus;based systems.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="29%">



<p style="margin-top: 1em"><b>&minus;&minus;join&minus;output</b>
/ <b>&minus;j</b>:</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Like
<b>&minus;r</b> but jq won&acute;t print a newline after
each output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="54%">


<p style="margin-top: 1em"><b>&minus;f filename</b> /
<b>&minus;&minus;from&minus;file filename</b>:</p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Read filter
from the file rather than from a command line, like
awk&acute;s &minus;f option. You can also use
&acute;#&acute; to make comments.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="41%">


<p style="margin-top: 1em"><b>&minus;Ldirectory</b> /
<b>&minus;L directory</b>:</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Prepend
<b>directory</b> to the search list for modules. If this
option is used then no builtin search list is used. See the
section on modules below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="29%">


<p style="margin-top: 1em"><b>&minus;e</b> /
<b>&minus;&minus;exit&minus;status</b>:</p> </td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Sets the exit
status of jq to 0 if the last output values was neither
<b>false</b> nor <b>null</b>, 1 if the last output value was
either <b>false</b> or <b>null</b>, or 4 if no valid result
was ever produced. Normally jq exits with 2 if there was any
usage problem or system error, 3 if there was a jq program
compile error, or 0 if the jq program ran.</p>

<p style="margin-left:17%; margin-top: 1em">Another way to
set the exit status is with the <b>halt_error</b> builtin
function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p style="margin-top: 1em"><b>&minus;&minus;arg name
value</b>:</p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option
passes a value to the jq program as a predefined variable.
If you run jq with <b>&minus;&minus;arg foo bar</b>, then
<b>$foo</b> is available in the program and has the value
<b>&quot;bar&quot;</b>. Note that <b>value</b> will be
treated as a string, so <b>&minus;&minus;arg foo 123</b>
will bind <b>$foo</b> to <b>&quot;123&quot;</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Named arguments
are also available to the jq program as
<b>$ARGS.named</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="38%">


<p style="margin-top: 1em"><b>&minus;&minus;argjson name
JSON&minus;text</b>:</p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option
passes a JSON&minus;encoded value to the jq program as a
predefined variable. If you run jq with
<b>&minus;&minus;argjson foo 123</b>, then <b>$foo</b> is
available in the program and has the value <b>123</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="54%">


<p style="margin-top: 1em"><b>&minus;&minus;slurpfile
variable&minus;name filename</b>:</p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option
reads all the JSON texts in the named file and binds an
array of the parsed JSON values to the given global
variable. If you run jq with <b>&minus;&minus;argfile foo
bar</b>, then <b>$foo</b> is available in the program and
has an array whose elements correspond to the texts in the
file named <b>bar</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="51%">


<p style="margin-top: 1em"><b>&minus;&minus;argfile
variable&minus;name filename</b>:</p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Do not use. Use
<b>&minus;&minus;slurpfile</b> instead.</p>

<p style="margin-left:17%; margin-top: 1em">(This option is
like <b>&minus;&minus;slurpfile</b>, but when the file has
just one text, then that is used, else an array of texts is
used as in <b>&minus;&minus;slurpfile</b>.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><b>&minus;&minus;args</b>:</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Remaining
arguments are positional string arguments. These are
available to the jq program as
<b>$ARGS.positional[]</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">



<p style="margin-top: 1em"><b>&minus;&minus;jsonargs</b>:</p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Remaining
arguments are positional JSON text arguments. These are
available to the jq program as
<b>$ARGS.positional[]</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">



<p style="margin-top: 1em"><b>&minus;&minus;run&minus;tests
[filename]</b>:</p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Runs the tests
in the given file or standard input. This must be the last
option given and does not honor all preceding options. The
input consists of comment lines, empty lines, and program
lines followed by one input line, as many lines of output as
are expected (one per output), and a terminating empty line.
Compilation failure tests start with a line containing only
&quot;%%FAIL&quot;, then a line containing the program to
compile, then a line containing an error message to compare
to the actual.</p>

<p style="margin-left:17%; margin-top: 1em">Be warned that
this option can change backwards&minus;incompatibly.</p>

<h2>BASIC FILTERS
<a name="BASIC FILTERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Identity:
.</b> <br>
The absolute simplest filter is <b>.</b> . This is a filter
that takes its input and produces it unchanged as output.
That is, this is the identity operator.</p>

<p style="margin-left:11%; margin-top: 1em">Since jq by
default pretty&minus;prints all output, this trivial program
can be a useful way of formatting JSON output from, say,
<b>curl</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="9%">


<p>jq &acute;.&acute;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;Hello, world!&quot; <br>
=&gt; &quot;Hello, world!&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Object
Identifier&minus;Index: .foo, .foo.bar</b> <br>
The simplest <i>useful</i> filter is <b>.foo</b>. When given
a JSON object (aka dictionary or hash) as input, it produces
the value at the key &quot;foo&quot;, or null if
there&acute;s none present.</p>

<p style="margin-left:11%; margin-top: 1em">A filter of the
form <b>.foo.bar</b> is equivalent to <b>.foo|.bar</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This syntax
only works for simple, identifier&minus;like keys, that is,
keys that are all made of alphanumeric characters and
underscore, and which do not start with a digit.</p>

<p style="margin-left:11%; margin-top: 1em">If the key
contains special characters, you need to surround it with
double quotes like this: <b>.&quot;foo$&quot;</b>, or else
<b>.[&quot;foo$&quot;]</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For example
<b>.[&quot;foo::bar&quot;]</b> and
<b>.[&quot;foo.bar&quot;]</b> work while <b>.foo::bar</b>
does not, and <b>.foo.bar</b> means
<b>.[&quot;foo&quot;].[&quot;bar&quot;]</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="14%">


<p>jq &acute;.foo&acute;</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;foo&quot;: 42,
&quot;bar&quot;: &quot;less interesting data&quot;} <br>
=&gt; 42</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.foo&acute; <br>
{&quot;notfoo&quot;: true, &quot;alsonotfoo&quot;: false}
<br>
=&gt; null</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[&quot;foo&quot;]&acute; <br>
{&quot;foo&quot;: 42} <br>
=&gt; 42</p>

<p style="margin-left:11%; margin-top: 1em"><b>Optional
Object Identifier&minus;Index: .foo?</b> <br>
Just like <b>.foo</b>, but does not output even an error
when <b>.</b> is not an array or an object.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="15%">


<p>jq &acute;.foo?&acute;</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;foo&quot;: 42,
&quot;bar&quot;: &quot;less interesting data&quot;} <br>
=&gt; 42</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.foo?&acute; <br>
{&quot;notfoo&quot;: true, &quot;alsonotfoo&quot;: false}
<br>
=&gt; null</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[&quot;foo&quot;]?&acute; <br>
{&quot;foo&quot;: 42} <br>
=&gt; 42</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[.foo?]&acute; <br>
[1,2] <br>
=&gt; []</p>

<p style="margin-left:11%; margin-top: 1em"><b>Generic
Object Index: .[&lt;string&gt;]</b> <br>
You can also look up fields of an object using syntax like
<b>.[&quot;foo&quot;]</b> (.foo above is a shorthand version
of this, but only for identifier&minus;like strings).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Array Index:
.[2]</b> <br>
When the index value is an integer, <b>.[&lt;value&gt;]</b>
can index arrays. Arrays are zero&minus;based, so
<b>.[2]</b> returns the third element.</p>

<p style="margin-left:11%; margin-top: 1em">Negative
indices are allowed, with &minus;1 referring to the last
element, &minus;2 referring to the next to last element, and
so on.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="14%">


<p>jq &acute;.[0]&acute;</p></td>
<td width="69%">
</td></tr>
</table>


<p style="margin-left:17%;">[{&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;,
&quot;good&quot;:false}] <br>
=&gt; {&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[2]&acute; <br>
[{&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true},
{&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false}]
<br>
=&gt; null</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[&minus;2]&acute; <br>
[1,2,3] <br>
=&gt; 2</p>


<p style="margin-left:11%; margin-top: 1em"><b>Array/String
Slice: .[10:15]</b> <br>
The <b>.[10:15]</b> syntax can be used to return a subarray
of an array or substring of a string. The array returned by
<b>.[10:15]</b> will be of length 5, containing the elements
from index 10 (inclusive) to index 15 (exclusive). Either
index may be negative (in which case it counts backwards
from the end of the array), or omitted (in which case it
refers to the start or end of the array).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="17%">


<p>jq &acute;.[2:4]&acute;</p></td>
<td width="66%">
</td></tr>
</table>


<p style="margin-left:17%;">[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;c&quot;, &quot;d&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[2:4]&acute; <br>
&quot;abcdefghi&quot; <br>
=&gt; &quot;cd&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[:3]&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[&minus;2:]&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; [&quot;d&quot;, &quot;e&quot;]</p>


<p style="margin-left:11%; margin-top: 1em"><b>Array/Object
Value Iterator: .[]</b> <br>
If you use the <b>.[index]</b> syntax, but omit the index
entirely, it will return <i>all</i> of the elements of an
array. Running <b>.[]</b> with the input <b>[1,2,3]</b> will
produce the numbers as three separate results, rather than
as a single array.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use this on an object, and it will return all the values of
the object.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>jq &acute;.[]&acute;</p></td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:17%;">[{&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;,
&quot;good&quot;:false}] <br>
=&gt; {&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;,
&quot;good&quot;:false}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[]&acute; <br>
[] <br>
=&gt;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[]&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 1} <br>
=&gt; 1, 1</p>

<p style="margin-left:11%; margin-top: 1em"><b>.[]?</b>
<br>
Like <b>.[]</b>, but no errors will be output if . is not an
array or object.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Comma: ,</b>
<br>
If two filters are separated by a comma, then the same input
will be fed into both and the two filters&acute; output
value streams will be concatenated in order: first, all of
the outputs produced by the left expression, and then all of
the outputs produced by the right. For instance, filter
<b>.foo, .bar</b>, produces both the &quot;foo&quot; fields
and &quot;bar&quot; fields as separate outputs.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="23%">


<p>jq &acute;.foo, .bar&acute;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;foo&quot;: 42,
&quot;bar&quot;: &quot;something else&quot;,
&quot;baz&quot;: true} <br>
=&gt; 42, &quot;something else&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.user, .projects[]&acute; <br>
{&quot;user&quot;:&quot;stedolan&quot;,
&quot;projects&quot;: [&quot;jq&quot;,
&quot;wikiflow&quot;]} <br>
=&gt; &quot;stedolan&quot;, &quot;jq&quot;,
&quot;wikiflow&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;.[4,2]&acute; <br>

[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]
<br>
=&gt; &quot;e&quot;, &quot;c&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pipe: |</b>
<br>
The | operator combines two filters by feeding the output(s)
of the one on the left into the input of the one on the
right. It&acute;s pretty much the same as the Unix
shell&acute;s pipe, if you&acute;re used to that.</p>

<p style="margin-left:11%; margin-top: 1em">If the one on
the left produces multiple results, the one on the right
will be run for each of those results. So, the expression
<b>.[] | .foo</b> retrieves the &quot;foo&quot; field of
each element of the input array.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<b>.a.b.c</b> is the same as <b>.a | .b | .c</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Note too that
<b>.</b> is the input value at the particular stage in a
&quot;pipeline&quot;, specifically: where the <b>.</b>
expression appears. Thus <b>.a | . | .b</b> is the same as
<b>.a.b</b>, as the <b>.</b> in the middle refers to
whatever value <b>.a</b> produced.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>jq &acute;.[] | .name&acute;</p></td>
<td width="58%">
</td></tr>
</table>


<p style="margin-left:17%;">[{&quot;name&quot;:&quot;JSON&quot;,
&quot;good&quot;:true}, {&quot;name&quot;:&quot;XML&quot;,
&quot;good&quot;:false}] <br>
=&gt; &quot;JSON&quot;, &quot;XML&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parenthesis</b>
<br>
Parenthesis work as a grouping operator just as in any
typical programming language.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>jq &acute;(. + 2) * 5&acute;</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%;">1 <br>
=&gt; 15</p>

<h2>TYPES AND VALUES
<a name="TYPES AND VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">jq supports the
same set of datatypes as JSON &minus; numbers, strings,
booleans, arrays, objects (which in JSON&minus;speak are
hashes with only string keys), and &quot;null&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Booleans, null,
strings and numbers are written the same way as in
javascript. Just like everything else in jq, these simple
values take an input and produce an output &minus; <b>42</b>
is a valid jq expression that takes an input, ignores it,
and returns 42 instead.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Array
construction: []</b> <br>
As in JSON, <b>[]</b> is used to construct arrays, as in
<b>[1,2,3]</b>. The elements of the arrays can be any jq
expression, including a pipeline. All of the results
produced by all of the expressions are collected into one
big array. You can use it to construct an array out of a
known quantity of values (as in <b>[.foo, .bar, .baz]</b>)
or to &quot;collect&quot; all the results of a filter into
an array (as in <b>[.items[].name]</b>)</p>

<p style="margin-left:11%; margin-top: 1em">Once you
understand the &quot;,&quot; operator, you can look at
jq&acute;s array syntax in a different light: the expression
<b>[1,2,3]</b> is not using a built&minus;in syntax for
comma&minus;separated arrays, but is instead applying the
<b>[]</b> operator (collect results) to the expression 1,2,3
(which produces three different results).</p>

<p style="margin-left:11%; margin-top: 1em">If you have a
filter <b>X</b> that produces four results, then the
expression <b>[X]</b> will produce a single result, an array
of four elements.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="38%">


<p>jq &acute;[.user, .projects[]]&acute;</p></td>
<td width="45%">
</td></tr>
</table>


<p style="margin-left:17%;">{&quot;user&quot;:&quot;stedolan&quot;,
&quot;projects&quot;: [&quot;jq&quot;,
&quot;wikiflow&quot;]} <br>
=&gt; [&quot;stedolan&quot;, &quot;jq&quot;,
&quot;wikiflow&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;[ .[]
| . * 2]&acute; <br>
[1, 2, 3] <br>
=&gt; [2, 4, 6]</p>

<p style="margin-left:11%; margin-top: 1em"><b>Object
Construction: {}</b> <br>
Like JSON, <b>{}</b> is for constructing objects (aka
dictionaries or hashes), as in: <b>{&quot;a&quot;: 42,
&quot;b&quot;: 17}</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If the keys are
&quot;identifier&minus;like&quot;, then the quotes can be
left off, as in <b>{a:42, b:17}</b>. Keys generated by
expressions need to be parenthesized, e.g.,
<b>{(&quot;a&quot;+&quot;b&quot;):59}</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The value can
be any expression (although you may need to wrap it in
parentheses if it&acute;s a complicated one), which gets
applied to the {} expression&acute;s input (remember, all
filters have an input and an output).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="17%">


<p>{foo: .bar}</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">will produce
the JSON object <b>{&quot;foo&quot;: 42}</b> if given the
JSON object <b>{&quot;bar&quot;:42, &quot;baz&quot;:43}</b>
as its input. You can use this to select particular fields
of an object: if the input is an object with
&quot;user&quot;, &quot;title&quot;, &quot;id&quot;, and
&quot;content&quot; fields and you just want
&quot;user&quot; and &quot;title&quot;, you can write</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="43%">


<p>{user: .user, title: .title}</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Because that is
so common, there&acute;s a shortcut syntax for it: <b>{user,
title}</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If one of the
expressions produces multiple results, multiple dictionaries
will be produced. If the input&acute;s</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="81%">



<p>{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]}</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">then the
expression</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="37%">


<p>{user, title: .titles[]}</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">will produce
two outputs:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="63%">


<p>{&quot;user&quot;:&quot;stedolan&quot;,
&quot;title&quot;: &quot;JQ Primer&quot;}</p></td>
<td width="20%">
</td></tr>
</table>


<p style="margin-left:17%;">{&quot;user&quot;:&quot;stedolan&quot;,
&quot;title&quot;: &quot;More JQ&quot;}</p>

<p style="margin-left:11%; margin-top: 1em">Putting
parentheses around the key means it will be evaluated as an
expression. With the same input as above,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="28%">


<p>{(.user): .titles}</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">produces</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="58%">


<p>{&quot;stedolan&quot;: [&quot;JQ Primer&quot;,
&quot;More JQ&quot;]}</p></td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;{user, title: .titles[]}&acute; <br>

{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]} <br>
=&gt; {&quot;user&quot;:&quot;stedolan&quot;,
&quot;title&quot;: &quot;JQ Primer&quot;},
{&quot;user&quot;:&quot;stedolan&quot;, &quot;title&quot;:
&quot;More JQ&quot;}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;{(.user): .titles}&acute; <br>

{&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ
Primer&quot;, &quot;More JQ&quot;]} <br>
=&gt; {&quot;stedolan&quot;: [&quot;JQ Primer&quot;,
&quot;More JQ&quot;]}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Recursive
Descent: ..</b> <br>
Recursively descends <b>.</b>, producing every value. This
is the same as the zero&minus;argument <b>recurse</b>
builtin (see below). This is intended to resemble the XPath
<b>//</b> operator. Note that <b>..a</b> does not work; use
<b>..|.a</b> instead. In the example below we use
<b>..|.a?</b> to find all the values of object keys
&quot;a&quot; in any object found &quot;below&quot;
<b>.</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This is
particularly useful in conjunction with <b>path(EXP)</b>
(also see below) and the <b>?</b> operator.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="17%">


<p>jq &acute;..|.a?&acute;</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%;">[[{&quot;a&quot;:1}]] <br>
=&gt; 1</p>

<h2>BUILTIN OPERATORS AND FUNCTIONS
<a name="BUILTIN OPERATORS AND FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Some jq
operator (for instance, <b>+</b>) do different things
depending on the type of their arguments (arrays, numbers,
etc.). However, jq never does implicit type conversions. If
you try to add a string to an object you&acute;ll get an
error message and no result.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Addition:
+</b> <br>
The operator <b>+</b> takes two filters, applies them both
to the same input, and adds the results together. What
&quot;adding&quot; means depends on the types involved:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>Numbers</b> are added by normal arithmetic.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>Arrays</b> are added by being concatenated into a
larger array.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>Strings</b> are added by being joined into a larger
string.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>Objects</b> are added by merging, that is, inserting
all the key&minus;value pairs from both objects into a
single combined object. If both objects contain a value for
the same key, the object on the right of the <b>+</b> wins.
(For recursive merge use the <b>*</b> operator.)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>null</b> can
be added to any value, and returns the other value
unchanged.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="17%">


<p>jq &acute;.a + 1&acute;</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;a&quot;: 7} <br>
=&gt; 8</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.a +
.b&acute; <br>
{&quot;a&quot;: [1,2], &quot;b&quot;: [3,4]} <br>
=&gt; [1,2,3,4]</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.a +
null&acute; <br>
{&quot;a&quot;: 1} <br>
=&gt; 1</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.a +
1&acute; <br>
{} <br>
=&gt; 1</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;{a:
1} + {b: 2} + {c: 3} + {a: 42}&acute; <br>
null <br>
=&gt; {&quot;a&quot;: 42, &quot;b&quot;: 2, &quot;c&quot;:
3}</p>


<p style="margin-left:11%; margin-top: 1em"><b>Subtraction:
&minus;</b> <br>
As well as normal arithmetic subtraction on numbers, the
<b>&minus;</b> operator can be used on arrays to remove all
occurrences of the second array&acute;s elements from the
first array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="17%">


<p>jq &acute;4 &minus; .a&acute;</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;a&quot;:3} <br>
=&gt; 1</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.
&minus; [&quot;xml&quot;, &quot;yaml&quot;]&acute; <br>
[&quot;xml&quot;, &quot;yaml&quot;, &quot;json&quot;] <br>
=&gt; [&quot;json&quot;]</p>


<p style="margin-left:11%; margin-top: 1em"><b>Multiplication,
division, modulo: *, /, and %</b> <br>
These infix operators behave as expected when given two
numbers. Division by zero raises an error. <b>x % y</b>
computes x modulo y.</p>

<p style="margin-left:11%; margin-top: 1em">Multiplying a
string by a number produces the concatenation of that string
that many times. <b>&quot;x&quot; * 0</b> produces
<b>null</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Dividing a
string by another splits the first using the second as
separators.</p>

<p style="margin-left:11%; margin-top: 1em">Multiplying two
objects will merge them recursively: this works like
addition but if both objects contain a value for the same
key, and the values are objects, the two are merged with the
same strategy.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="23%">


<p>jq &acute;10 / . * 3&acute;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%;">5 <br>
=&gt; 6</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;. /
&quot;, &quot;&acute; <br>
&quot;a, b,c,d, e&quot; <br>
=&gt; [&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;{&quot;k&quot;: {&quot;a&quot;: 1, &quot;b&quot;: 2}}
* {&quot;k&quot;: {&quot;a&quot;: 0,&quot;c&quot;:
3}}&acute; <br>
null <br>
=&gt; {&quot;k&quot;: {&quot;a&quot;: 0, &quot;b&quot;: 2,
&quot;c&quot;: 3}}</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.[] |
(1 / .)?&acute; <br>
[1,0,&minus;1] <br>
=&gt; 1, &minus;1</p>

<p style="margin-left:11%; margin-top: 1em"><b>length</b>
<br>
The builtin function <b>length</b> gets the length of
various different types of value:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The length of a <b>string</b> is the number of Unicode
codepoints it contains (which will be the same as its
JSON&minus;encoded length in bytes if it&acute;s pure
ASCII).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The length of an <b>array</b> is the number of
elements.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The length of an <b>object</b> is the number of
key&minus;value pairs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The length of <b>null</b> is zero.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.[] |
length&acute; [[1,2], &quot;string&quot;, {&quot;a&quot;:2},
null] =&gt; 2, 6, 1, 0</p>


<p style="margin-left:11%; margin-top: 1em"><b>utf8bytelength</b>
<br>
The builtin function <b>utf8bytelength</b> outputs the
number of bytes used to encode a string in UTF&minus;8.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="29%">


<p>jq &acute;utf8bytelength&acute;</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;\u03bc&quot; <br>
=&gt; 2</p>

<p style="margin-left:11%; margin-top: 1em"><b>keys,
keys_unsorted</b> <br>
The builtin function <b>keys</b>, when given an object,
returns its keys in an array.</p>

<p style="margin-left:11%; margin-top: 1em">The keys are
sorted &quot;alphabetically&quot;, by unicode codepoint
order. This is not an order that makes particular sense in
any particular language, but you can count on it being the
same for any two objects with the same set of keys,
regardless of locale settings.</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>keys</b> is given an array, it returns the valid indices
for that array: the integers from 0 to length&minus;1.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>keys_unsorted</b> function is just like <b>keys</b>, but
if the input is an object then the keys will not be sorted,
instead the keys will roughly be in insertion order.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="14%">


<p>jq &acute;keys&acute;</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;abc&quot;: 1,
&quot;abcd&quot;: 2, &quot;Foo&quot;: 3} <br>
=&gt; [&quot;Foo&quot;, &quot;abc&quot;,
&quot;abcd&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;keys&acute; <br>
[42,3,35] <br>
=&gt; [0,1,2]</p>


<p style="margin-left:11%; margin-top: 1em"><b>has(key)</b>
<br>
The builtin function <b>has</b> returns whether the input
object has the given key, or the input array has an element
at the given index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>has($key)</b>
has the same effect as checking whether <b>$key</b> is a
member of the array returned by <b>keys</b>, although
<b>has</b> will be faster.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="31%">


<p>jq &acute;map(has(&quot;foo&quot;))&acute;</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:17%;">[{&quot;foo&quot;: 42}, {}]
<br>
=&gt; [true, false]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;map(has(2))&acute; <br>
[[0,1], [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]] <br>
=&gt; [false, true]</p>

<p style="margin-left:11%; margin-top: 1em"><b>in</b> <br>
The builtin function <b>in</b> returns whether or not the
input key is in the given object, or the input index
corresponds to an element in the given array. It is,
essentially, an inversed version of <b>has</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="40%">


<p>jq &acute;.[] | in({&quot;foo&quot;: 42})&acute;</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%;">[&quot;foo&quot;,
&quot;bar&quot;] <br>
=&gt; true, false</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;map(in([0,1]))&acute; <br>
[2, 0] <br>
=&gt; [false, true]</p>

<p style="margin-left:11%; margin-top: 1em"><b>map(x),
map_values(x)</b> <br>
For any filter <b>x</b>, <b>map(x)</b> will run that filter
for each element of the input array, and return the outputs
in a new array. <b>map(.+1)</b> will increment each element
of an array of numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
<b>map_values(x)</b> will run that filter for each element,
but it will return an object when an object is passed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>map(x)</b>
is equivalent to <b>[.[] | x]</b>. In fact, this is how
it&acute;s defined. Similarly, <b>map_values(x)</b> is
defined as <b>.[] |= x</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="20%">


<p>jq &acute;map(.+1)&acute;</p></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:17%;">[1,2,3] <br>
=&gt; [2,3,4]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;map_values(.+1)&acute; <br>
{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3} <br>
=&gt; {&quot;a&quot;: 2, &quot;b&quot;: 3, &quot;c&quot;:
4}</p>


<p style="margin-left:11%; margin-top: 1em"><b>path(path_expression)</b>
<br>
Outputs array representations of the given path expression
in <b>.</b>. The outputs are arrays of strings (object keys)
and/or numbers (array indices).</p>

<p style="margin-left:11%; margin-top: 1em">Path
expressions are jq expressions like <b>.a</b>, but also
<b>.[]</b>. There are two types of path expressions: ones
that can match exactly, and ones that cannot. For example,
<b>.a.b.c</b> is an exact match path expression, while
<b>.a[].b</b> is not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>path(exact_path_expression)</b>
will produce the array representation of the path expression
even if it does not exist in <b>.</b>, if <b>.</b> is
<b>null</b> or an array or an object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>path(pattern)</b>
will produce array representations of the paths matching
<b>pattern</b> if the paths exist in <b>.</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
path expressions are not different from normal expressions.
The expression
<b>path(..|select(type==&quot;boolean&quot;))</b> outputs
all the paths to boolean values in <b>.</b>, and only those
paths.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="28%">


<p>jq &acute;path(.a[0].b)&acute;</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; [&quot;a&quot;,0,&quot;b&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[path(..)]&acute; <br>
{&quot;a&quot;:[{&quot;b&quot;:1}]} <br>
=&gt;
[[],[&quot;a&quot;],[&quot;a&quot;,0],[&quot;a&quot;,0,&quot;b&quot;]]</p>


<p style="margin-left:11%; margin-top: 1em"><b>del(path_expression)</b>
<br>
The builtin function <b>del</b> removes a key and its
corresponding value from an object.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="21%">


<p>jq &acute;del(.foo)&acute;</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;foo&quot;: 42,
&quot;bar&quot;: 9001, &quot;baz&quot;: 42} <br>
=&gt; {&quot;bar&quot;: 9001, &quot;baz&quot;: 42}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;del(.[1, 2])&acute; <br>
[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;] <br>
=&gt; [&quot;foo&quot;]</p>


<p style="margin-left:11%; margin-top: 1em"><b>getpath(PATHS)</b>
<br>
The builtin function <b>getpath</b> outputs the values in
<b>.</b> found at each path in <b>PATHS</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="35%">


<p>jq
&acute;getpath([&quot;a&quot;,&quot;b&quot;])&acute;</p> </td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; null</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[getpath([&quot;a&quot;,&quot;b&quot;],
[&quot;a&quot;,&quot;c&quot;])]&acute; <br>
{&quot;a&quot;:{&quot;b&quot;:0, &quot;c&quot;:1}} <br>
=&gt; [0, 1]</p>


<p style="margin-left:11%; margin-top: 1em"><b>setpath(PATHS;
VALUE)</b> <br>
The builtin function <b>setpath</b> sets the <b>PATHS</b> in
<b>.</b> to <b>VALUE</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="40%">


<p>jq &acute;setpath([&quot;a&quot;,&quot;b&quot;];
1)&acute;</p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; {&quot;a&quot;: {&quot;b&quot;: 1}}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;setpath([&quot;a&quot;,&quot;b&quot;]; 1)&acute; <br>
{&quot;a&quot;:{&quot;b&quot;:0}} <br>
=&gt; {&quot;a&quot;: {&quot;b&quot;: 1}}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;setpath([0,&quot;a&quot;]; 1)&acute; <br>
null <br>
=&gt; [{&quot;a&quot;:1}]</p>


<p style="margin-left:11%; margin-top: 1em"><b>delpaths(PATHS)</b>
<br>
The builtin function <b>delpaths</b> sets the <b>PATHS</b>
in <b>.</b>. <b>PATHS</b> must be an array of paths, where
each path is an array of strings and numbers.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="40%">


<p>jq
&acute;delpaths([[&quot;a&quot;,&quot;b&quot;]])&acute;</p> </td>
<td width="43%">
</td></tr>
</table>


<p style="margin-left:17%;">{&quot;a&quot;:{&quot;b&quot;:1},&quot;x&quot;:{&quot;y&quot;:2}}
<br>
=&gt; {&quot;a&quot;:{},&quot;x&quot;:{&quot;y&quot;:2}}</p>

<p style="margin-left:11%; margin-top: 1em"><b>to_entries,
from_entries, with_entries</b> <br>
These functions convert between an object and an array of
key&minus;value pairs. If <b>to_entries</b> is passed an
object, then for each <b>k: v</b> entry in the input, the
output array includes <b>{&quot;key&quot;: k,
&quot;value&quot;: v}</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>from_entries</b>
does the opposite conversion, and <b>with_entries(foo)</b>
is a shorthand for <b>to_entries | map(foo) |
from_entries</b>, useful for doing some operation to all
keys and values of an object. <b>from_entries</b> accepts
key, Key, name, Name, value and Value as keys.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="23%">


<p>jq &acute;to_entries&acute;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;a&quot;: 1,
&quot;b&quot;: 2} <br>
=&gt; [{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1},
{&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;from_entries&acute; <br>
[{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1},
{&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}] <br>
=&gt; {&quot;a&quot;: 1, &quot;b&quot;: 2}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;with_entries(.key |= &quot;KEY_&quot; + .)&acute;
<br>
{&quot;a&quot;: 1, &quot;b&quot;: 2} <br>
=&gt; {&quot;KEY_a&quot;: 1, &quot;KEY_b&quot;: 2}</p>


<p style="margin-left:11%; margin-top: 1em"><b>select(boolean_expression)</b>
<br>
The function <b>select(foo)</b> produces its input unchanged
if <b>foo</b> returns true for that input, and produces no
output otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">It&acute;s
useful for filtering lists: <b>[1,2,3] | map(select(. &gt;=
2))</b> will give you <b>[2,3]</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="37%">


<p>jq &acute;map(select(. &gt;= 2))&acute;</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:17%;">[1,5,3,0,7] <br>
=&gt; [5,3,7]</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.[] |
select(.id == &quot;second&quot;)&acute; <br>
[{&quot;id&quot;: &quot;first&quot;, &quot;val&quot;: 1},
{&quot;id&quot;: &quot;second&quot;, &quot;val&quot;: 2}]
<br>
=&gt; {&quot;id&quot;: &quot;second&quot;, &quot;val&quot;:
2}</p>

<p style="margin-left:11%; margin-top: 1em"><b>arrays,
objects, iterables, booleans, numbers, normals, finites,
strings, nulls, values, scalars</b> <br>
These built&minus;ins select only inputs that are arrays,
objects, iterables (arrays or objects), booleans, numbers,
normal numbers, finite numbers, strings, null,
non&minus;null values, and non&minus;iterables,
respectively.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>jq &acute;.[]|numbers&acute;</p></td>
<td width="58%">
</td></tr>
</table>


<p style="margin-left:17%;">[[],{},1,&quot;foo&quot;,null,true,false]
<br>
=&gt; 1</p>

<p style="margin-left:11%; margin-top: 1em"><b>empty <br>
empty</b> returns no results. None at all. Not even
<b>null</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It&acute;s
useful on occasion. You&acute;ll know if you need it :)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>jq &acute;1, empty, 2&acute;</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; 1, 2</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[1,2,empty,3]&acute; <br>
null <br>
=&gt; [1,2,3]</p>


<p style="margin-left:11%; margin-top: 1em"><b>error(message)</b>
<br>
Produces an error, just like <b>.a</b> applied to values
other than null and objects would, but with the given
message as the error&acute;s value. Errors can be caught
with try/catch; see below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>halt</b>
<br>
Stops the jq program with no further outputs. jq will exit
with exit status <b>0</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>halt_error,
halt_error(exit_code)</b> <br>
Stops the jq program with no further outputs. The input will
be printed on <b>stderr</b> as raw output (i.e., strings
will not have double quotes) with no decoration, not even a
newline.</p>

<p style="margin-left:11%; margin-top: 1em">The given
<b>exit_code</b> (defaulting to <b>5</b>) will be jq&acute;s
exit status.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
<b>&quot;Error: somthing went
wrong\n&quot;|halt_error(1)</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$__loc__</b>
<br>
Produces an object with a &quot;file&quot; key and a
&quot;line&quot; key, with the filename and line number
where <b>$__loc__</b> occurs, as values.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="57%">


<p>jq &acute;try error(&quot;\($__loc__)&quot;) catch
.&acute;</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt;
&quot;{\&quot;file\&quot;:\&quot;&lt;top&minus;level&gt;\&quot;,\&quot;line\&quot;:1}&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>paths,
paths(node_filter), leaf_paths <br>
paths</b> outputs the paths to all the elements in its input
(except it does not output the empty list, representing .
itself).</p>


<p style="margin-left:11%; margin-top: 1em"><b>paths(f)</b>
outputs the paths to any values for which <b>f</b> is true.
That is, <b>paths(numbers)</b> outputs the paths to all
numeric values.</p>


<p style="margin-left:11%; margin-top: 1em"><b>leaf_paths</b>
is an alias of <b>paths(scalars)</b>; <b>leaf_paths</b> is
<i>deprecated</i> and will be removed in the next major
release.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="18%">


<p>jq &acute;[paths]&acute;</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%;">[1,[[],{&quot;a&quot;:2}]] <br>
=&gt; [[0],[1],[1,0],[1,1],[1,1,&quot;a&quot;]]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[paths(scalars)]&acute; <br>
[1,[[],{&quot;a&quot;:2}]] <br>
=&gt; [[0],[1,1,&quot;a&quot;]]</p>

<p style="margin-left:11%; margin-top: 1em"><b>add</b> <br>
The filter <b>add</b> takes as input an array, and produces
as output the elements of the array added together. This
might mean summed, concatenated or merged depending on the
types of the elements of the input array &minus; the rules
are the same as those for the <b>+</b> operator (described
above).</p>

<p style="margin-left:11%; margin-top: 1em">If the input is
an empty array, <b>add</b> returns <b>null</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>jq &acute;add&acute;</p></td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:17%;">[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
<br>
=&gt; &quot;abc&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;add&acute; <br>
[1, 2, 3] <br>
=&gt; 6</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;add&acute; <br>
[] <br>
=&gt; null</p>

<p style="margin-left:11%; margin-top: 1em"><b>any,
any(condition), any(generator; condition)</b> <br>
The filter <b>any</b> takes as input an array of boolean
values, and produces <b>true</b> as output if any of the
elements of the array are <b>true</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If the input is
an empty array, <b>any</b> returns <b>false</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>any(condition)</b> form applies the given condition to
the elements of the input array.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>any(generator; condition)</b> form applies the given
condition to all the outputs of the given generator.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>jq &acute;any&acute;</p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:17%;">[true, false] <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;any&acute; <br>
[false, false] <br>
=&gt; false</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;any&acute; <br>
[] <br>
=&gt; false</p>

<p style="margin-left:11%; margin-top: 1em"><b>all,
all(condition), all(generator; condition)</b> <br>
The filter <b>all</b> takes as input an array of boolean
values, and produces <b>true</b> as output if all of the
elements of the array are <b>true</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>all(condition)</b> form applies the given condition to
the elements of the input array.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>all(generator; condition)</b> form applies the given
condition to all the outputs of the given generator.</p>

<p style="margin-left:11%; margin-top: 1em">If the input is
an empty array, <b>all</b> returns <b>true</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>jq &acute;all&acute;</p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:17%;">[true, false] <br>
=&gt; false</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;all&acute; <br>
[true, true] <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;all&acute; <br>
[] <br>
=&gt; true</p>

<p style="margin-left:11%; margin-top: 1em"><b>flatten,
flatten(depth)</b> <br>
The filter <b>flatten</b> takes as input an array of nested
arrays, and produces a flat array in which all arrays inside
the original array have been recursively replaced by their
values. You can pass an argument to it to specify how many
levels of nesting to flatten.</p>


<p style="margin-left:11%; margin-top: 1em"><b>flatten(2)</b>
is like <b>flatten</b>, but going only up to two levels
deep.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="18%">


<p>jq &acute;flatten&acute;</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%;">[1, [2], [[3]]] <br>
=&gt; [1, 2, 3]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;flatten(1)&acute; <br>
[1, [2], [[3]]] <br>
=&gt; [1, 2, [3]]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;flatten&acute; <br>
[[]] <br>
=&gt; []</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;flatten&acute; <br>
[{&quot;foo&quot;: &quot;bar&quot;}, [{&quot;foo&quot;:
&quot;baz&quot;}]] <br>
=&gt; [{&quot;foo&quot;: &quot;bar&quot;}, {&quot;foo&quot;:
&quot;baz&quot;}]</p>


<p style="margin-left:11%; margin-top: 1em"><b>range(upto),
range(from;upto) range(from;upto;by)</b> <br>
The <b>range</b> function produces a range of numbers.
<b>range(4;10)</b> produces 6 numbers, from 4 (inclusive) to
10 (exclusive). The numbers are produced as separate
outputs. Use <b>[range(4;10)]</b> to get a range as an
array.</p>

<p style="margin-left:11%; margin-top: 1em">The one
argument form generates numbers from 0 to the given number,
with an increment of 1.</p>

<p style="margin-left:11%; margin-top: 1em">The two
argument form generates numbers from <b>from</b> to
<b>upto</b> with an increment of 1.</p>

<p style="margin-left:11%; margin-top: 1em">The three
argument form generates numbers <b>from</b> to <b>upto</b>
with an increment of <b>by</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="23%">


<p>jq &acute;range(2;4)&acute;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; 2, 3</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[range(2;4)]&acute; <br>
null <br>
=&gt; [2,3]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[range(4)]&acute; <br>
null <br>
=&gt; [0,1,2,3]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[range(0;10;3)]&acute; <br>
null <br>
=&gt; [0,3,6,9]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[range(0;10;&minus;1)]&acute; <br>
null <br>
=&gt; []</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[range(0;&minus;5;&minus;1)]&acute; <br>
null <br>
=&gt; [0,&minus;1,&minus;2,&minus;3,&minus;4]</p>

<p style="margin-left:11%; margin-top: 1em"><b>floor</b>
<br>
The <b>floor</b> function returns the floor of its numeric
input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="15%">


<p>jq &acute;floor&acute;</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%;">3.14159 <br>
=&gt; 3</p>

<p style="margin-left:11%; margin-top: 1em"><b>sqrt</b>
<br>
The <b>sqrt</b> function returns the square root of its
numeric input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="14%">


<p>jq &acute;sqrt&acute;</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%;">9 <br>
=&gt; 3</p>


<p style="margin-left:11%; margin-top: 1em"><b>tonumber</b>
<br>
The <b>tonumber</b> function parses its input as a number.
It will convert correctly&minus;formatted strings to their
numeric equivalent, leave numbers alone, and give an error
on all other input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="29%">


<p>jq &acute;.[] | tonumber&acute;</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%;">[1, &quot;1&quot;] <br>
=&gt; 1, 1</p>


<p style="margin-left:11%; margin-top: 1em"><b>tostring</b>
<br>
The <b>tostring</b> function prints its input as a string.
Strings are left unchanged, and all other values are
JSON&minus;encoded.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="29%">


<p>jq &acute;.[] | tostring&acute;</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%;">[1, &quot;1&quot;, [1]] <br>
=&gt; &quot;1&quot;, &quot;1&quot;, &quot;[1]&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>type</b>
<br>
The <b>type</b> function returns the type of its argument as
a string, which is one of null, boolean, number, string,
array or object.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="21%">


<p>jq &acute;map(type)&acute;</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%;">[0, false, [], {}, null,
&quot;hello&quot;] <br>
=&gt; [&quot;number&quot;, &quot;boolean&quot;,
&quot;array&quot;, &quot;object&quot;, &quot;null&quot;,
&quot;string&quot;]</p>

<p style="margin-left:11%; margin-top: 1em"><b>infinite,
nan, isinfinite, isnan, isfinite, isnormal</b> <br>
Some arithmetic operations can yield infinities and
&quot;not a number&quot; (NaN) values. The <b>isinfinite</b>
builtin returns <b>true</b> if its input is infinite. The
<b>isnan</b> builtin returns <b>true</b> if its input is a
NaN. The <b>infinite</b> builtin returns a positive infinite
value. The <b>nan</b> builtin returns a NaN. The
<b>isnormal</b> builtin returns true if its input is a
normal number.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
division by zero raises an error.</p>

<p style="margin-left:11%; margin-top: 1em">Currently most
arithmetic operations operating on infinities, NaNs, and
sub&minus;normals do not raise errors.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="45%">


<p>jq &acute;.[] | (infinite * .) &lt; 0&acute;</p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:17%;">[&minus;1, 1] <br>
=&gt; true, false</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;infinite, nan | type&acute; <br>
null <br>
=&gt; &quot;number&quot;, &quot;number&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>sort,
sort_by(path_expression)</b> <br>
The <b>sort</b> functions sorts its input, which must be an
array. Values are sorted in the following order:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>null</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>false</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>true</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>numbers</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>strings, in alphabetical order (by unicode codepoint
value)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>arrays, in lexical order</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>objects</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The ordering
for objects is a little complex: first they&acute;re
compared by comparing their sets of keys (as arrays in
sorted order), and if their keys are equal then the values
are compared key by key.</p>

<p style="margin-left:11%; margin-top: 1em"><b>sort</b> may
be used to sort by a particular field of an object, or by
applying any jq filter.</p>


<p style="margin-left:11%; margin-top: 1em"><b>sort_by(foo)</b>
compares two elements by comparing the result of <b>foo</b>
on each element.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="14%">


<p>jq &acute;sort&acute;</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%;">[8,3,null,6] <br>
=&gt; [null,3,6,8]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;sort_by(.foo)&acute; <br>
[{&quot;foo&quot;:4, &quot;bar&quot;:10},
{&quot;foo&quot;:3, &quot;bar&quot;:100},
{&quot;foo&quot;:2, &quot;bar&quot;:1}] <br>
=&gt; [{&quot;foo&quot;:2, &quot;bar&quot;:1},
{&quot;foo&quot;:3, &quot;bar&quot;:100},
{&quot;foo&quot;:4, &quot;bar&quot;:10}]</p>


<p style="margin-left:11%; margin-top: 1em"><b>group_by(path_expression)
<br>
group_by(.foo)</b> takes as input an array, groups the
elements having the same <b>.foo</b> field into separate
arrays, and produces all of these arrays as elements of a
larger array, sorted by the value of the <b>.foo</b>
field.</p>

<p style="margin-left:11%; margin-top: 1em">Any jq
expression, not just a field access, may be used in place of
<b>.foo</b>. The sorting order is the same as described in
the <b>sort</b> function above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="29%">


<p>jq &acute;group_by(.foo)&acute;</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%;">[{&quot;foo&quot;:1,
&quot;bar&quot;:10}, {&quot;foo&quot;:3,
&quot;bar&quot;:100}, {&quot;foo&quot;:1,
&quot;bar&quot;:1}] <br>
=&gt; [[{&quot;foo&quot;:1, &quot;bar&quot;:10},
{&quot;foo&quot;:1, &quot;bar&quot;:1}],
[{&quot;foo&quot;:3, &quot;bar&quot;:100}]]</p>

<p style="margin-left:11%; margin-top: 1em"><b>min, max,
min_by(path_exp), max_by(path_exp)</b> <br>
Find the minimum or maximum element of the input array.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>min_by(path_exp)</b> and <b>max_by(path_exp)</b>
functions allow you to specify a particular field or
property to examine, e.g. <b>min_by(.foo)</b> finds the
object with the smallest <b>foo</b> field.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="12%">


<p>jq &acute;min&acute;</p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:17%;">[5,4,2,7] <br>
=&gt; 2</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;max_by(.foo)&acute; <br>
[{&quot;foo&quot;:1, &quot;bar&quot;:14},
{&quot;foo&quot;:2, &quot;bar&quot;:3}] <br>
=&gt; {&quot;foo&quot;:2, &quot;bar&quot;:3}</p>

<p style="margin-left:11%; margin-top: 1em"><b>unique,
unique_by(path_exp)</b> <br>
The <b>unique</b> function takes as input an array and
produces an array of the same elements, in sorted order,
with duplicates removed.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>unique_by(path_exp)</b> function will keep only one
element for each value obtained by applying the argument.
Think of it as making an array by taking one element out of
every group produced by <b>group</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="17%">


<p>jq &acute;unique&acute;</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%;">[1,2,5,3,5,3,1,3] <br>
=&gt; [1,2,3,5]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;unique_by(.foo)&acute; <br>
[{&quot;foo&quot;: 1, &quot;bar&quot;: 2}, {&quot;foo&quot;:
1, &quot;bar&quot;: 3}, {&quot;foo&quot;: 4,
&quot;bar&quot;: 5}] <br>
=&gt; [{&quot;foo&quot;: 1, &quot;bar&quot;: 2},
{&quot;foo&quot;: 4, &quot;bar&quot;: 5}]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;unique_by(length)&acute; <br>
[&quot;chunky&quot;, &quot;bacon&quot;, &quot;kitten&quot;,
&quot;cicada&quot;, &quot;asparagus&quot;] <br>
=&gt; [&quot;bacon&quot;, &quot;chunky&quot;,
&quot;asparagus&quot;]</p>

<p style="margin-left:11%; margin-top: 1em"><b>reverse</b>
<br>
This function reverses an array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="18%">


<p>jq &acute;reverse&acute;</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%;">[1,2,3,4] <br>
=&gt; [4,3,2,1]</p>


<p style="margin-left:11%; margin-top: 1em"><b>contains(element)</b>
<br>
The filter <b>contains(b)</b> will produce true if b is
completely contained within the input. A string B is
contained in a string A if B is a substring of A. An array B
is contained in an array A if all elements in B are
contained in any element in A. An object B is contained in
object A if all of the values in B are contained in the
value in A with the same key. All other types are assumed to
be contained in each other if they are equal.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="31%">


<p>jq &acute;contains(&quot;bar&quot;)&acute;</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;foobar&quot; <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;contains([&quot;baz&quot;, &quot;bar&quot;])&acute;
<br>
[&quot;foobar&quot;, &quot;foobaz&quot;, &quot;blarp&quot;]
<br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;contains([&quot;bazzzzz&quot;,
&quot;bar&quot;])&acute; <br>
[&quot;foobar&quot;, &quot;foobaz&quot;, &quot;blarp&quot;]
<br>
=&gt; false</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;contains({foo: 12, bar: [{barp: 12}]})&acute; <br>
{&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]} <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;contains({foo: 12, bar: [{barp: 15}]})&acute; <br>
{&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]} <br>
=&gt; false</p>


<p style="margin-left:11%; margin-top: 1em"><b>indices(s)</b>
<br>
Outputs an array containing the indices in <b>.</b> where
<b>s</b> occurs. The input may be an array, in which case if
<b>s</b> is an array then the indices output will be those
where all elements in <b>.</b> match those of <b>s</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="28%">


<p>jq &acute;indices(&quot;, &quot;)&acute;</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;a,b, cd, efg, hijk&quot;
<br>
=&gt; [3,7,12]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;indices(1)&acute; <br>
[0,1,2,1,3,1,4] <br>
=&gt; [1,3,5]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;indices([1,2])&acute; <br>
[0,1,2,3,1,4,2,5,1,2,6,7] <br>
=&gt; [1,8]</p>

<p style="margin-left:11%; margin-top: 1em"><b>index(s),
rindex(s)</b> <br>
Outputs the index of the first (<b>index</b>) or last
(<b>rindex</b>) occurrence of <b>s</b> in the input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>jq &acute;index(&quot;, &quot;)&acute;</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;a,b, cd, efg, hijk&quot;
<br>
=&gt; 3</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;rindex(&quot;, &quot;)&acute; <br>
&quot;a,b, cd, efg, hijk&quot; <br>
=&gt; 12</p>

<p style="margin-left:11%; margin-top: 1em"><b>inside</b>
<br>
The filter <b>inside(b)</b> will produce true if the input
is completely contained within b. It is, essentially, an
inversed version of <b>contains</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="32%">


<p>jq &acute;inside(&quot;foobar&quot;)&acute;</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;bar&quot; <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;inside([&quot;foobar&quot;, &quot;foobaz&quot;,
&quot;blarp&quot;])&acute; <br>
[&quot;baz&quot;, &quot;bar&quot;] <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;inside([&quot;foobar&quot;, &quot;foobaz&quot;,
&quot;blarp&quot;])&acute; <br>
[&quot;bazzzzz&quot;, &quot;bar&quot;] <br>
=&gt; false</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;inside({&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]})&acute; <br>
{&quot;foo&quot;: 12, &quot;bar&quot;: [{&quot;barp&quot;:
12}]} <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;inside({&quot;foo&quot;: 12,
&quot;bar&quot;:[1,2,{&quot;barp&quot;:12,
&quot;blip&quot;:13}]})&acute; <br>
{&quot;foo&quot;: 12, &quot;bar&quot;: [{&quot;barp&quot;:
15}]} <br>
=&gt; false</p>


<p style="margin-left:11%; margin-top: 1em"><b>startswith(str)</b>
<br>
Outputs <b>true</b> if . starts with the given string
argument.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="43%">


<p>jq &acute;[.[]|startswith(&quot;foo&quot;)]&acute;</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:17%;">[&quot;fo&quot;,
&quot;foo&quot;, &quot;barfoo&quot;, &quot;foobar&quot;,
&quot;barfoob&quot;] <br>
=&gt; [false, true, false, true, false]</p>


<p style="margin-left:11%; margin-top: 1em"><b>endswith(str)</b>
<br>
Outputs <b>true</b> if . ends with the given string
argument.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="40%">


<p>jq &acute;[.[]|endswith(&quot;foo&quot;)]&acute;</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%;">[&quot;foobar&quot;,
&quot;barfoo&quot;] <br>
=&gt; [false, true]</p>


<p style="margin-left:11%; margin-top: 1em"><b>combinations,
combinations(n)</b> <br>
Outputs all combinations of the elements of the arrays in
the input array. If given an argument <b>n</b>, it outputs
all combinations of <b>n</b> repetitions of the input
array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="26%">


<p>jq &acute;combinations&acute;</p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:17%;">[[1,2], [3, 4]] <br>
=&gt; [1, 3], [1, 4], [2, 3], [2, 4]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;combinations(2)&acute; <br>
[0, 1] <br>
=&gt; [0, 0], [0, 1], [1, 0], [1, 1]</p>


<p style="margin-left:11%; margin-top: 1em"><b>ltrimstr(str)</b>
<br>
Outputs its input with the given prefix string removed, if
it starts with it.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="40%">


<p>jq &acute;[.[]|ltrimstr(&quot;foo&quot;)]&acute;</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%;">[&quot;fo&quot;,
&quot;foo&quot;, &quot;barfoo&quot;, &quot;foobar&quot;,
&quot;afoo&quot;] <br>
=&gt;
[&quot;fo&quot;,&quot;&quot;,&quot;barfoo&quot;,&quot;bar&quot;,&quot;afoo&quot;]</p>


<p style="margin-left:11%; margin-top: 1em"><b>rtrimstr(str)</b>
<br>
Outputs its input with the given suffix string removed, if
it ends with it.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="40%">


<p>jq &acute;[.[]|rtrimstr(&quot;foo&quot;)]&acute;</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:17%;">[&quot;fo&quot;,
&quot;foo&quot;, &quot;barfoo&quot;, &quot;foobar&quot;,
&quot;foob&quot;] <br>
=&gt;
[&quot;fo&quot;,&quot;&quot;,&quot;bar&quot;,&quot;foobar&quot;,&quot;foob&quot;]</p>

<p style="margin-left:11%; margin-top: 1em"><b>explode</b>
<br>
Converts an input string into an array of the string&acute;s
codepoint numbers.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="18%">


<p>jq &acute;explode&acute;</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;foobar&quot; <br>
=&gt; [102,111,111,98,97,114]</p>

<p style="margin-left:11%; margin-top: 1em"><b>implode</b>
<br>
The inverse of explode.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="18%">


<p>jq &acute;implode&acute;</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%;">[65, 66, 67] <br>
=&gt; &quot;ABC&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b>split(str)</b>
<br>
Splits an input string on the separator argument.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>jq &acute;split(&quot;, &quot;)&acute;</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;a, b,c,d, e, &quot; <br>
=&gt;
[&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;,&quot;&quot;]</p>


<p style="margin-left:11%; margin-top: 1em"><b>join(str)</b>
<br>
Joins the array of elements given as input, using the
argument as separator. It is the inverse of <b>split</b>:
that is, running <b>split(&quot;foo&quot;) |
join(&quot;foo&quot;)</b> over any input string returns said
input string.</p>

<p style="margin-left:11%; margin-top: 1em">Numbers and
booleans in the input are converted to strings. Null values
are treated as empty strings. Arrays and objects in the
input are not supported.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="23%">


<p>jq &acute;join(&quot;, &quot;)&acute;</p></td>
<td width="60%">
</td></tr>
</table>


<p style="margin-left:17%;">[&quot;a&quot;,&quot;b,c,d&quot;,&quot;e&quot;]
<br>
=&gt; &quot;a, b,c,d, e&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;join(&quot; &quot;)&acute; <br>
[&quot;a&quot;,1,2.3,true,null,false] <br>
=&gt; &quot;a 1 2.3 true false&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b>ascii_downcase,
ascii_upcase</b> <br>
Emit a copy of the input string with its alphabetic
characters (a&minus;z and A&minus;Z) converted to the
specified case.</p>

<p style="margin-left:11%; margin-top: 1em"><b>while(cond;
update)</b> <br>
The <b>while(cond; update)</b> function allows you to
repeatedly apply an update to <b>.</b> until <b>cond</b> is
false.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<b>while(cond; update)</b> is internally defined as a
recursive jq function. Recursive calls within <b>while</b>
will not consume additional memory if <b>update</b> produces
at most one output for each input. See advanced topics
below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="37%">


<p>jq &acute;[while(.&lt;100; .*2)]&acute;</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:17%;">1 <br>
=&gt; [1,2,4,8,16,32,64]</p>

<p style="margin-left:11%; margin-top: 1em"><b>until(cond;
next)</b> <br>
The <b>until(cond; next)</b> function allows you to
repeatedly apply the expression <b>next</b>, initially to
<b>.</b> then to its own output, until <b>cond</b> is true.
For example, this can be used to implement a factorial
function (see below).</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<b>until(cond; next)</b> is internally defined as a
recursive jq function. Recursive calls within <b>until()</b>
will not consume additional memory if <b>next</b> produces
at most one output for each input. See advanced topics
below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>jq &acute;[.,1]|until(.[0] &lt; 1; [.[0] &minus; 1, .[1]
* .[0]])|.[1]&acute;</p></td></tr>
</table>

<p style="margin-left:17%;">4 <br>
=&gt; 24</p>

<p style="margin-left:11%; margin-top: 1em"><b>recurse(f),
recurse, recurse(f; condition), recurse_down</b> <br>
The <b>recurse(f)</b> function allows you to search through
a recursive structure, and extract interesting data from all
levels. Suppose your input represents a filesystem:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="41%">


<p>{&quot;name&quot;: &quot;/&quot;, &quot;children&quot;:
[</p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;name&quot;:
&quot;/bin&quot;, &quot;children&quot;: [ <br>
{&quot;name&quot;: &quot;/bin/ls&quot;,
&quot;children&quot;: []}, <br>
{&quot;name&quot;: &quot;/bin/sh&quot;,
&quot;children&quot;: []}]}, <br>
{&quot;name&quot;: &quot;/home&quot;, &quot;children&quot;:
[ <br>
{&quot;name&quot;: &quot;/home/stephen&quot;,
&quot;children&quot;: [ <br>
{&quot;name&quot;: &quot;/home/stephen/jq&quot;,
&quot;children&quot;: []}]}]}]}</p>

<p style="margin-left:11%; margin-top: 1em">Now suppose you
want to extract all of the filenames present. You need to
retrieve <b>.name</b>, <b>.children[].name</b>,
<b>.children[].children[].name</b>, and so on. You can do
this with:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="43%">


<p>recurse(.children[]) | .name</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">When called
without an argument, <b>recurse</b> is equivalent to
<b>recurse(.[]?)</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>recurse(f)</b>
is identical to <b>recurse(f; . != null)</b> and can be used
without concerns about recursion depth.</p>

<p style="margin-left:11%; margin-top: 1em"><b>recurse(f;
condition)</b> is a generator which begins by emitting . and
then emits in turn .|f, .|f|f, .|f|f|f, ... so long as the
computed value satisfies the condition. For example, to
generate all the integers, at least in principle, one could
write <b>recurse(.+1; true)</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For legacy
reasons, <b>recurse_down</b> exists as an alias to calling
<b>recurse</b> without arguments. This alias is considered
<i>deprecated</i> and will be removed in the next major
release.</p>

<p style="margin-left:11%; margin-top: 1em">The recursive
calls in <b>recurse</b> will not consume additional memory
whenever <b>f</b> produces at most a single output for each
input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="31%">


<p>jq &acute;recurse(.foo[])&acute;</p></td>
<td width="52%">
</td></tr>
</table>


<p style="margin-left:17%;">{&quot;foo&quot;:[{&quot;foo&quot;:
[]}, {&quot;foo&quot;:[{&quot;foo&quot;:[]}]}]} <br>
=&gt;
{&quot;foo&quot;:[{&quot;foo&quot;:[]},{&quot;foo&quot;:[{&quot;foo&quot;:[]}]}]},
{&quot;foo&quot;:[]},
{&quot;foo&quot;:[{&quot;foo&quot;:[]}]},
{&quot;foo&quot;:[]}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;recurse&acute; <br>
{&quot;a&quot;:0,&quot;b&quot;:[1]} <br>
=&gt; {&quot;a&quot;:0,&quot;b&quot;:[1]}, 0, [1], 1</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;recurse(. * .; . &lt; 20)&acute; <br>
2 <br>
=&gt; 2, 4, 16</p>

<p style="margin-left:11%; margin-top: 1em"><b>walk(f)</b>
<br>
The <b>walk(f)</b> function applies f recursively to every
component of the input entity. When an array is encountered,
f is first applied to its elements and then to the array
itself; when an object is encountered, f is first applied to
all the values and then to the object. In practice, f will
usually test the type of its input, as illustrated in the
following examples. The first example highlights the
usefulness of processing the elements of an array of arrays
before processing the array itself. The second example shows
how all the keys of all the objects within the input can be
considered for alteration.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="77%">


<p>jq &acute;walk(if type == &quot;array&quot; then sort
else . end)&acute;</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:17%;">[[4, 1, 7], [8, 5, 2], [3, 6,
9]] <br>
=&gt; [[1,4,7],[2,5,8],[3,6,9]]</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;walk(
if type == &quot;object&quot; then with_entries( .key |=
sub( &quot;^_+&quot;; &quot;&quot;) ) else . end )&acute;
<br>
[ { &quot;_a&quot;: { &quot;__b&quot;: 2 } } ] <br>
=&gt; [{&quot;a&quot;:{&quot;b&quot;:2}}]</p>

<p style="margin-left:11%; margin-top: 1em"><b>$ENV, env
<br>
$ENV</b> is an object representing the environment variables
as set when the jq program started.</p>

<p style="margin-left:11%; margin-top: 1em"><b>env</b>
outputs an object representing jq&acute;s current
environment.</p>

<p style="margin-left:11%; margin-top: 1em">At the moment
there is no builtin for setting environment variables.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="23%">


<p>jq &acute;$ENV.PAGER&acute;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; &quot;less&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;env.PAGER&acute; <br>
null <br>
=&gt; &quot;less&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b>transpose</b>
<br>
Transpose a possibly jagged matrix (an array of arrays).
Rows are padded with nulls so the result is always
rectangular.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="21%">


<p>jq &acute;transpose&acute;</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%;">[[1], [2,3]] <br>
=&gt; [[1,2],[null,3]]</p>


<p style="margin-left:11%; margin-top: 1em"><b>bsearch(x)</b>
<br>
bsearch(x) conducts a binary search for x in the input
array. If the input is sorted and contains x, then
bsearch(x) will return its index in the array; otherwise, if
the array is sorted, it will return (&minus;1 &minus; ix)
where ix is an insertion point such that the array would
still be sorted after the insertion of x at ix. If the array
is not sorted, bsearch(x) will return an integer that is
probably of no interest.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="23%">


<p>jq &acute;bsearch(0)&acute;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%;">[0,1] <br>
=&gt; 0</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;bsearch(0)&acute; <br>
[1,2,3] <br>
=&gt; &minus;1</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;bsearch(4) as $ix | if $ix &lt; 0 then
.[&minus;(1+$ix)] = 4 else . end&acute; <br>
[1,2,3] <br>
=&gt; [1,2,3,4]</p>

<p style="margin-left:11%; margin-top: 1em"><b>String
interpolation &minus; \(foo)</b> <br>
Inside a string, you can put an expression inside parens
after a backslash. Whatever the expression returns will be
interpolated into the string.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>jq &acute;&quot;The input was \(.), which is one less
than \(.+1)&quot;&acute;</p></td></tr>
</table>

<p style="margin-left:17%;">42 <br>
=&gt; &quot;The input was 42, which is one less than
43&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Convert
to/from JSON</b> <br>
The <b>tojson</b> and <b>fromjson</b> builtins dump values
as JSON texts or parse JSON texts into values, respectively.
The tojson builtin differs from tostring in that tostring
returns strings unmodified, while tojson encodes strings as
JSON strings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="29%">


<p>jq &acute;[.[]|tostring]&acute;</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%;">[1, &quot;foo&quot;,
[&quot;foo&quot;]] <br>
=&gt;
[&quot;1&quot;,&quot;foo&quot;,&quot;[\&quot;foo\&quot;]&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[.[]|tojson]&acute; <br>
[1, &quot;foo&quot;, [&quot;foo&quot;]] <br>
=&gt;
[&quot;1&quot;,&quot;\&quot;foo\&quot;&quot;,&quot;[\&quot;foo\&quot;]&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[.[]|tojson|fromjson]&acute; <br>
[1, &quot;foo&quot;, [&quot;foo&quot;]] <br>
=&gt; [1,&quot;foo&quot;,[&quot;foo&quot;]]</p>

<p style="margin-left:11%; margin-top: 1em"><b>Format
strings and escaping</b> <br>
The <b>@foo</b> syntax is used to format and escape strings,
which is useful for building URLs, documents in a language
like HTML or XML, and so forth. <b>@foo</b> can be used as a
filter on its own, the possible escapings are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>@text</b>:</p></td>
<td width="2%"></td>
<td width="78%">


<p>Calls <b>tostring</b>, see that function for
details.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>@json</b>:</p></td>
<td width="2%"></td>
<td width="78%">


<p>Serializes the input as JSON.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>@html</b>:</p></td>
<td width="2%"></td>
<td width="78%">


<p>Applies HTML/XML escaping, by mapping the characters
<b>&lt;&gt;&amp;&acute;&quot;</b> to their entity
equivalents <b>&amp;lt;</b>, <b>&amp;gt;</b>,
<b>&amp;amp;</b>, <b>&amp;apos;</b>, <b>&amp;quot;</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>@uri</b>:</p></td>
<td width="2%"></td>
<td width="78%">


<p>Applies percent&minus;encoding, by mapping all reserved
URI characters to a <b>%XX</b> sequence.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>@csv</b>:</p></td>
<td width="2%"></td>
<td width="78%">


<p>The input must be an array, and it is rendered as CSV
with double quotes for strings, and quotes escaped by
repetition.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>@tsv</b>:</p></td>
<td width="2%"></td>
<td width="78%">


<p>The input must be an array, and it is rendered as TSV
(tab&minus;separated values). Each input array will be
printed as a single line. Fields are separated by a single
tab (ascii <b>0x09</b>). Input characters line&minus;feed
(ascii <b>0x0a</b>), carriage&minus;return (ascii
<b>0x0d</b>), tab (ascii <b>0x09</b>) and backslash (ascii
<b>0x5c</b>) will be output as escape sequences <b>\n</b>,
<b>\r</b>, <b>\t</b>, <b>\\</b> respectively.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>@sh</b>:</p></td>
<td width="2%"></td>
<td width="78%">


<p>The input is escaped suitable for use in a
command&minus;line for a POSIX shell. If the input is an
array, the output will be a series of space&minus;separated
strings.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>@base64</b>:</p>

<p style="margin-left:22%; margin-top: 1em">The input is
converted to base64 as specified by RFC 4648.</p>

<p style="margin-left:11%;"><b>@base64d</b>:</p>

<p style="margin-left:22%; margin-top: 1em">The inverse of
<b>@base64</b>, input is decoded as specified by RFC 4648.
Note: If the decoded string is not UTF&minus;8, the results
are undefined.</p>

<p style="margin-left:11%; margin-top: 1em">This syntax can
be combined with string interpolation in a useful way. You
can follow a <b>@foo</b> token with a string literal. The
contents of the string literal will <i>not</i> be escaped.
However, all interpolations made inside that string literal
will be escaped. For instance,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="75%">


<p>@uri
&quot;https://www.google.com/search?q=\(.search)&quot;</p> </td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">will produce
the following output for the input
<b>{&quot;search&quot;:&quot;what is jq?&quot;}</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="78%">



<p>&quot;https://www.google.com/search?q=what%20is%20jq%3F&quot;</p> </td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that the
slashes, question mark, etc. in the URL are not escaped, as
they were part of the string literal.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="15%">


<p>jq &acute;@html&acute;</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;This works if x &lt;
y&quot; <br>
=&gt; &quot;This works if x &amp;lt; y&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;@sh
&quot;echo \(.)&quot;&acute; <br>
&quot;O&acute;Hara&acute;s Ale&quot; <br>
=&gt; &quot;echo
&acute;O&acute;\\&acute;&acute;Hara&acute;\\&acute;&acute;s
Ale&acute;&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;@base64&acute; <br>
&quot;This is a message&quot; <br>
=&gt; &quot;VGhpcyBpcyBhIG1lc3NhZ2U=&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;@base64d&acute; <br>
&quot;VGhpcyBpcyBhIG1lc3NhZ2U=&quot; <br>
=&gt; &quot;This is a message&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Dates</b>
<br>
jq provides some basic date handling functionality, with
some high&minus;level and low&minus;level builtins. In all
cases these builtins deal exclusively with time in UTC.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>fromdateiso8601</b> builtin parses datetimes in the ISO
8601 format to a number of seconds since the Unix epoch
(1970&minus;01&minus;01T00:00:00Z). The <b>todateiso8601</b>
builtin does the inverse.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>fromdate</b> builtin parses datetime strings. Currently
<b>fromdate</b> only supports ISO 8601 datetime strings, but
in the future it will attempt to parse datetime strings in
more formats.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>todate</b> builtin is an alias for
<b>todateiso8601</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>now</b>
builtin outputs the current time, in seconds since the Unix
epoch.</p>


<p style="margin-left:11%; margin-top: 1em">Low&minus;level
jq interfaces to the C&minus;library time functions are also
provided: <b>strptime</b>, <b>strftime</b>,
<b>strflocaltime</b>, <b>mktime</b>, <b>gmtime</b>, and
<b>localtime</b>. Refer to your host operating
system&acute;s documentation for the format strings used by
<b>strptime</b> and <b>strftime</b>. Note: these are not
necessarily stable interfaces in jq, particularly as to
their localization functionality.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>gmtime</b> builtin consumes a number of seconds since the
Unix epoch and outputs a &quot;broken down time&quot;
representation of Greenwhich Meridian time as an array of
numbers representing (in this order): the year, the month
(zero&minus;based), the day of the month (one&minus;based),
the hour of the day, the minute of the hour, the second of
the minute, the day of the week, and the day of the year
&minus;&minus; all one&minus;based unless otherwise stated.
The day of the week number may be wrong on some systems for
dates before March 1st 1900, or after December 31 2099.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>localtime</b> builtin works like the <b>gmtime</b>
builtin, but using the local timezone setting.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>mktime</b> builtin consumes &quot;broken down time&quot;
representations of time output by <b>gmtime</b> and
<b>strptime</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>strptime(fmt)</b> builtin parses input strings matching
the <b>fmt</b> argument. The output is in the &quot;broken
down time&quot; representation consumed by <b>gmtime</b> and
output by <b>mktime</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>strftime(fmt)</b> builtin formats a time (GMT) with the
given format. The <b>strflocaltime</b> does the same, but
using the local timezone setting.</p>

<p style="margin-left:11%; margin-top: 1em">The format
strings for <b>strptime</b> and <b>strftime</b> are
described in typical C library documentation. The format
string for ISO 8601 datetime is
<b>&quot;%Y&minus;%m&minus;%dT%H:%M:%SZ&quot;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">jq may not
support some or all of this date functionality on some
systems. In particular, the <b>%u</b> and <b>%j</b>
specifiers for <b>strptime(fmt)</b> are not supported on
macOS.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="20%">


<p>jq &acute;fromdate&acute;</p></td>
<td width="63%">
</td></tr>
</table>


<p style="margin-left:17%;">&quot;2015&minus;03&minus;05T23:51:47Z&quot;
<br>
=&gt; 1425599507</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;strptime(&quot;%Y&minus;%m&minus;%dT%H:%M:%SZ&quot;)&acute;
<br>
&quot;2015&minus;03&minus;05T23:51:47Z&quot; <br>
=&gt; [2015,2,5,23,51,47,4,63]</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;strptime(&quot;%Y&minus;%m&minus;%dT%H:%M:%SZ&quot;)|mktime&acute;
<br>
&quot;2015&minus;03&minus;05T23:51:47Z&quot; <br>
=&gt; 1425599507</p>


<p style="margin-left:11%; margin-top: 1em"><b>SQL&minus;Style
Operators</b> <br>
jq provides a few SQL&minus;style operators. <br>
INDEX(stream; index_expression):</p>

<p style="margin-left:22%; margin-top: 1em">This builtin
produces an object whose keys are computed by the given
index expression applied to each value from the given
stream.</p>

<p style="margin-left:11%;">JOIN($idx; stream; idx_expr;
join_expr):</p>

<p style="margin-left:22%; margin-top: 1em">This builtin
joins the values from the given stream to the given index.
The index&acute;s keys are computed by applying the given
index expression to each value from the given stream. An
array of the value in the stream and the corresponding value
from the index is fed to the given join expression to
produce each result.</p>

<p style="margin-left:11%;">JOIN($idx; stream;
idx_expr):</p>

<p style="margin-left:22%; margin-top: 1em">Same as
<b>JOIN($idx; stream; idx_expr; .)</b>.</p>

<p style="margin-left:11%;">JOIN($idx; idx_expr):</p>

<p style="margin-left:22%; margin-top: 1em">This builtin
joins the input <b>.</b> to the given index, applying the
given index expression to <b>.</b> to compute the index key.
The join operation is as described above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>IN(s):</p></td>
<td width="2%"></td>
<td width="78%">


<p>This builtin outputs <b>true</b> if <b>.</b> appears in
the given stream, otherwise it outputs <b>false</b>.</p></td></tr>
</table>

<p style="margin-left:11%;">IN(source; s):</p>

<p style="margin-left:22%; margin-top: 1em">This builtin
outputs <b>true</b> if any value in the source stream
appears in the second stream, otherwise it outputs
<b>false</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>builtins</b>
<br>
Returns a list of all builtin functions in the format
<b>name/arity</b>. Since functions with the same name but
different arities are considered separate functions,
<b>all/0</b>, <b>all/1</b>, and <b>all/2</b> would all be
present in the list.</p>

<h2>CONDITIONALS AND COMPARISONS
<a name="CONDITIONALS AND COMPARISONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>==, !=</b>
<br>
The expression &acute;a == b&acute; will produce
&acute;true&acute; if the result of a and b are equal (that
is, if they represent equivalent JSON documents) and
&acute;false&acute; otherwise. In particular, strings are
never considered equal to numbers. If you&acute;re coming
from Javascript, jq&acute;s == is like Javascript&acute;s
=== &minus; considering values equal only when they have the
same type as well as the same value.</p>

<p style="margin-left:11%; margin-top: 1em">!= is &quot;not
equal&quot;, and &acute;a != b&acute; returns the opposite
value of &acute;a == b&acute;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="20%">


<p>jq &acute;.[] == 1&acute;</p></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:17%;">[1, 1.0, &quot;1&quot;,
&quot;banana&quot;] <br>
=&gt; true, true, false, false</p>


<p style="margin-left:11%; margin-top: 1em"><b>if&minus;then&minus;else
<br>
if A then B else C end</b> will act the same as <b>B</b> if
<b>A</b> produces a value other than false or null, but act
the same as <b>C</b> otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Checking for
false or null is a simpler notion of &quot;truthiness&quot;
than is found in Javascript or Python, but it means that
you&acute;ll sometimes have to be more explicit about the
condition you want: you can&acute;t test whether, e.g. a
string is empty using <b>if .name then A else B end</b>,
you&acute;ll need something more like <b>if (.name | length)
&gt; 0 then A else B end</b> instead.</p>

<p style="margin-left:11%; margin-top: 1em">If the
condition <b>A</b> produces multiple results, then <b>B</b>
is evaluated once for each result that is not false or null,
and <b>C</b> is evaluated once for each false or null.</p>

<p style="margin-left:11%; margin-top: 1em">More cases can
be added to an if using <b>elif A then B</b> syntax.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="28%">


<p>jq &acute;if . == 0 then</p></td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em">&quot;zero&quot;
elif . == 1 then &quot;one&quot; else &quot;many&quot;
end&acute; 2 =&gt; &quot;many&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>&gt;, &gt;=,
&lt;=, &lt;</b> <br>
The comparison operators <b>&gt;</b>, <b>&gt;=</b>,
<b>&lt;=</b>, <b>&lt;</b> return whether their left argument
is greater than, greater than or equal to, less than or
equal to or less than their right argument
(respectively).</p>

<p style="margin-left:11%; margin-top: 1em">The ordering is
the same as that described for <b>sort</b>, above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="15%">


<p>jq &acute;. &lt; 5&acute;</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%;">2 <br>
=&gt; true</p>


<p style="margin-left:11%; margin-top: 1em"><b>and/or/not</b>
<br>
jq supports the normal Boolean operators and/or/not. They
have the same standard of truth as if expressions &minus;
false and null are considered &quot;false values&quot;, and
anything else is a &quot;true value&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If an operand
of one of these operators produces multiple results, the
operator itself will produce a result for each input.</p>

<p style="margin-left:11%; margin-top: 1em"><b>not</b> is
in fact a builtin function rather than an operator, so it is
called as a filter to which things can be piped rather than
with special syntax, as in <b>.foo and .bar | not</b>.</p>

<p style="margin-left:11%; margin-top: 1em">These three
only produce the values &quot;true&quot; and
&quot;false&quot;, and so are only useful for genuine
Boolean operations, rather than the common Perl/Python/Ruby
idiom of &quot;value_that_may_be_null or default&quot;. If
you want to use this form of &quot;or&quot;, picking between
two values rather than evaluating a condition, see the
&quot;//&quot; operator below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="34%">


<p>jq &acute;42 and &quot;a string&quot;&acute;</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;(true, false) or false&acute; <br>
null <br>
=&gt; true, false</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;(true, true) and (true, false)&acute; <br>
null <br>
=&gt; true, false, true, false</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[true, false | not]&acute; <br>
null <br>
=&gt; [false, true]</p>

<p style="margin-left:11%; margin-top: 1em"><b>Alternative
operator: //</b> <br>
A filter of the form <b>a // b</b> produces the same results
as <b>a</b>, if <b>a</b> produces results other than
<b>false</b> and <b>null</b>. Otherwise, <b>a // b</b>
produces the same results as <b>b</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This is useful
for providing defaults: <b>.foo // 1</b> will evaluate to
<b>1</b> if there&acute;s no <b>.foo</b> element in the
input. It&acute;s similar to how <b>or</b> is sometimes used
in Python (jq&acute;s <b>or</b> operator is reserved for
strictly Boolean operations).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="23%">


<p>jq &acute;.foo // 42&acute;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;foo&quot;: 19} <br>
=&gt; 19</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.foo
// 42&acute; <br>
{} <br>
=&gt; 42</p>


<p style="margin-left:11%; margin-top: 1em"><b>try&minus;catch</b>
<br>
Errors can be caught by using <b>try EXP catch EXP</b>. The
first expression is executed, and if it fails then the
second is executed with the error message. The output of the
handler, if any, is output as if it had been the output of
the expression to try.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>try
EXP</b> form uses <b>empty</b> as the exception handler.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="58%">


<p>jq &acute;try .a catch &quot;. is not an
object&quot;&acute;</p> </td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:17%;">true <br>
=&gt; &quot;. is not an object&quot;</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;[.[]|try .a]&acute; <br>
[{}, true, {&quot;a&quot;:1}] <br>
=&gt; [null, 1]</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;try
error(&quot;some exception&quot;) catch .&acute; <br>
true <br>
=&gt; &quot;some exception&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Breaking out
of control structures</b> <br>
A convenient use of try/catch is to break out of control
structures like <b>reduce</b>, <b>foreach</b>, <b>while</b>,
and so on.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="80%">


<p># Repeat an expression until it raises &quot;break&quot;
as an</p></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:17%;"># error, then stop repeating
without re&minus;raising the error. <br>
# But if the error caught is not &quot;break&quot; then
re&minus;raise it. <br>
try repeat(exp) catch .==&quot;break&quot; then empty else
error;</p>

<p style="margin-left:11%; margin-top: 1em">jq has a syntax
for named lexical labels to &quot;break&quot; or &quot;go
(back) to&quot;:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="48%">


<p>label $out | ... break $out ...</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The <b>break
$label_name</b> expression will cause the program to to act
as though the nearest (to the left) <b>label $label_name</b>
produced <b>empty</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
relationship between the <b>break</b> and corresponding
<b>label</b> is lexical: the label has to be
&quot;visible&quot; from the break.</p>

<p style="margin-left:11%; margin-top: 1em">To break out of
a <b>reduce</b>, for example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>label $out | reduce .[] as $item (null; if .==false then
break $out else ... end)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
jq program produces a syntax error:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="15%">


<p>break $out</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">because no
label <b>$out</b> is visible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Error
Suppression / Optional Operator: ?</b> <br>
The <b>?</b> operator, used as <b>EXP?</b>, is shorthand for
<b>try EXP</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>jq &acute;[.[]|(.a)?]&acute;</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%;">[{}, true, {&quot;a&quot;:1}]
<br>
=&gt; [null, 1]</p>

<h2>REGULAR EXPRESSIONS (PCRE)
<a name="REGULAR EXPRESSIONS (PCRE)"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">jq uses the
Oniguruma regular expression library, as do php, ruby,
TextMate, Sublime Text, etc, so the description here will
focus on jq specifics.</p>

<p style="margin-left:11%; margin-top: 1em">The jq regex
filters are defined so that they can be used using one of
these patterns:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="37%">


<p>STRING | FILTER( REGEX )</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:17%;">STRING | FILTER( REGEX; FLAGS )
<br>
STRING | FILTER( [REGEX] ) <br>
STRING | FILTER( [REGEX, FLAGS] )</p>

<p style="margin-left:11%; margin-top: 1em">where: *
STRING, REGEX and FLAGS are jq strings and subject to jq
string interpolation; * REGEX, after string interpolation,
should be a valid PCRE regex; * FILTER is one of
<b>test</b>, <b>match</b>, or <b>capture</b>, as described
below.</p>

<p style="margin-left:11%; margin-top: 1em">FLAGS is a
string consisting of one of more of the supported flags:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>g</b> &minus; Global search (find all matches, not
just the first)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>i</b> &minus; Case insensitive search</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>m</b> &minus; Multi line mode (&acute;.&acute; will
match newlines)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>n</b> &minus; Ignore empty matches</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>p</b> &minus; Both s and m modes are enabled</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>s</b> &minus; Single line mode (&acute;^&acute;
&minus;&gt; &acute;\A&acute;, &acute;$&acute; &minus;&gt;
&acute;\Z&acute;)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>l</b> &minus; Find longest possible matches</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>x</b> &minus; Extended regex format (ignore
whitespace and comments)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">To match
whitespace in an x pattern use an escape such as \s,
e.g.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="31%">


<p>test( &quot;a\sb&quot;, &quot;x&quot; ).</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that
certain flags may also be specified within REGEX, e.g.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>jq &minus;n &acute;(&quot;test&quot;, &quot;TEst&quot;,
&quot;teST&quot;, &quot;TEST&quot;) | test(
&quot;(?i)te(?&minus;i)st&quot; )&acute;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">evaluates to:
true, true, false, false.</p>

<p style="margin-left:11%; margin-top: 1em"><b>test(val),
test(regex; flags)</b> <br>
Like <b>match</b>, but does not return match objects, only
<b>true</b> or <b>false</b> for whether or not the regex
matches the input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>jq &acute;test(&quot;foo&quot;)&acute;</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;foo&quot; <br>
=&gt; true</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.[] |
test(&quot;a b c # spaces are ignored&quot;;
&quot;ix&quot;)&acute; <br>
[&quot;xabcd&quot;, &quot;ABC&quot;] <br>
=&gt; true, true</p>

<p style="margin-left:11%; margin-top: 1em"><b>match(val),
match(regex; flags) <br>
match</b> outputs an object for each match it finds. Matches
have the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>offset</b> &minus; offset in UTF&minus;8 codepoints
from the beginning of the input</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>length</b> &minus; length in UTF&minus;8 codepoints
of the match</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>string</b> &minus; the string that it matched</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>captures</b> &minus; an array of objects representing
capturing groups.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Capturing group
objects have the following fields:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>offset</b> &minus; offset in UTF&minus;8 codepoints
from the beginning of the input</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>length</b> &minus; length in UTF&minus;8 codepoints
of this capturing group</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>string</b> &minus; the string that was captured</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><b>name</b> &minus; the name of the capturing group (or
<b>null</b> if it was unnamed)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Capturing
groups that did not match anything return an offset of
&minus;1</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="38%">


<p>jq &acute;match(&quot;(abc)+&quot;;
&quot;g&quot;)&acute;</p> </td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;abc abc&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;captures&quot;:
[{&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;name&quot;:
null}]}, {&quot;offset&quot;: 4, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;captures&quot;:
[{&quot;offset&quot;: 4, &quot;length&quot;: 3,
&quot;string&quot;: &quot;abc&quot;, &quot;name&quot;:
null}]}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;match(&quot;foo&quot;)&acute; <br>
&quot;foo bar foo&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;foo&quot;, &quot;captures&quot;:
[]}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;match([&quot;foo&quot;, &quot;ig&quot;])&acute; <br>
&quot;foo bar FOO&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 3,
&quot;string&quot;: &quot;foo&quot;, &quot;captures&quot;:
[]}, {&quot;offset&quot;: 8, &quot;length&quot;: 3,
&quot;string&quot;: &quot;FOO&quot;, &quot;captures&quot;:
[]}</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;match(&quot;foo (?&lt;bar123&gt;bar)? foo&quot;;
&quot;ig&quot;)&acute; <br>
&quot;foo bar foo foo foo&quot; <br>
=&gt; {&quot;offset&quot;: 0, &quot;length&quot;: 11,
&quot;string&quot;: &quot;foo bar foo&quot;,
&quot;captures&quot;: [{&quot;offset&quot;: 4,
&quot;length&quot;: 3, &quot;string&quot;: &quot;bar&quot;,
&quot;name&quot;: &quot;bar123&quot;}]},
{&quot;offset&quot;: 12, &quot;length&quot;: 8,
&quot;string&quot;: &quot;foo foo&quot;,
&quot;captures&quot;: [{&quot;offset&quot;: &minus;1,
&quot;length&quot;: 0, &quot;string&quot;: null,
&quot;name&quot;: &quot;bar123&quot;}]}</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;[
match(&quot;.&quot;; &quot;g&quot;)] | length&acute; <br>
&quot;abc&quot; <br>
=&gt; 3</p>


<p style="margin-left:11%; margin-top: 1em"><b>capture(val),
capture(regex; flags)</b> <br>
Collects the named captures in a JSON object, with the name
of each capture as the key, and the matched string as the
corresponding value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="63%">


<p>jq
&acute;capture(&quot;(?&lt;a&gt;[a&minus;z]+)&minus;(?&lt;n&gt;[0&minus;9]+)&quot;)&acute;</p> </td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:17%;">&quot;xyzzy&minus;14&quot; <br>
=&gt; { &quot;a&quot;: &quot;xyzzy&quot;, &quot;n&quot;:
&quot;14&quot; }</p>


<p style="margin-left:11%; margin-top: 1em"><b>scan(regex),
scan(regex; flags)</b> <br>
Emit a stream of the non&minus;overlapping substrings of the
input that match the regex in accordance with the flags, if
any have been specified. If there is no match, the stream is
empty. To capture all the matches for each input string, use
the idiom <b>[ expr ]</b>, e.g. <b>[ scan(regex) ]</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>split(regex;
flags)</b> <br>
For backwards compatibility, <b>split</b> splits on a
string, not a regex.</p>


<p style="margin-left:11%; margin-top: 1em"><b>splits(regex),
splits(regex; flags)</b> <br>
These provide the same results as their <b>split</b>
counterparts, but as a stream instead of an array.</p>

<p style="margin-left:11%; margin-top: 1em"><b>sub(regex;
tostring) sub(regex; string; flags)</b> <br>
Emit the string obtained by replacing the first match of
regex in the input string with <b>tostring</b>, after
interpolation. <b>tostring</b> should be a jq string, and
may contain references to named captures. The named captures
are, in effect, presented as a JSON object (as constructed
by <b>capture</b>) to <b>tostring</b>, so a reference to a
captured variable named &quot;x&quot; would take the form:
&quot;(.x)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>gsub(regex;
string), gsub(regex; string; flags) <br>
gsub</b> is like <b>sub</b> but all the
non&minus;overlapping occurrences of the regex are replaced
by the string, after interpolation.</p>

<h2>ADVANCED FEATURES
<a name="ADVANCED FEATURES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Variables are
an absolute necessity in most programming languages, but
they&acute;re relegated to an &quot;advanced feature&quot;
in jq.</p>

<p style="margin-left:11%; margin-top: 1em">In most
languages, variables are the only means of passing around
data. If you calculate a value, and you want to use it more
than once, you&acute;ll need to store it in a variable. To
pass a value to another part of the program, you&acute;ll
need that part of the program to define a variable (as a
function parameter, object member, or whatever) in which to
place the data.</p>

<p style="margin-left:11%; margin-top: 1em">It is also
possible to define functions in jq, although this is is a
feature whose biggest use is defining jq&acute;s standard
library (many jq functions such as <b>map</b> and
<b>find</b> are in fact written in jq).</p>

<p style="margin-left:11%; margin-top: 1em">jq has
reduction operators, which are very powerful but a bit
tricky. Again, these are mostly used internally, to define
some useful bits of jq&acute;s standard library.</p>

<p style="margin-left:11%; margin-top: 1em">It may not be
obvious at first, but jq is all about generators (yes, as
often found in other languages). Some utilities are provided
to help deal with generators.</p>

<p style="margin-left:11%; margin-top: 1em">Some minimal
I/O support (besides reading JSON from standard input, and
writing JSON to standard output) is available.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, there
is a module/library system.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Variable /
Symbolic Binding Operator: ... as $identifier | ...</b> <br>
In jq, all filters have an input and an output, so manual
plumbing is not necessary to pass a value from one part of a
program to the next. Many expressions, for instance <b>a +
b</b>, pass their input to two distinct subexpressions (here
<b>a</b> and <b>b</b> are both passed the same input), so
variables aren&acute;t usually necessary in order to use a
value twice.</p>

<p style="margin-left:11%; margin-top: 1em">For instance,
calculating the average value of an array of numbers
requires a few variables in most languages &minus; at least
one to hold the array, perhaps one for each element or for a
loop counter. In jq, it&acute;s simply <b>add / length</b>
&minus; the <b>add</b> expression is given the array and
produces its sum, and the <b>length</b> expression is given
the array and produces its length.</p>

<p style="margin-left:11%; margin-top: 1em">So,
there&acute;s generally a cleaner way to solve most problems
in jq than defining variables. Still, sometimes they do make
things easier, so jq lets you define variables using
<b>expression as $variable</b>. All variable names start
with <b>$</b>. Here&acute;s a slightly uglier version of the
array&minus;averaging example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="69%">


<p>length as $array_length | add / $array_length</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">We&acute;ll
need a more complicated problem to find a situation where
using variables actually makes our lives easier.</p>

<p style="margin-left:11%; margin-top: 1em">Suppose we have
an array of blog posts, with &quot;author&quot; and
&quot;title&quot; fields, and another object which is used
to map author usernames to real names. Our input looks
like:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="81%">


<p>{&quot;posts&quot;: [{&quot;title&quot;: &quot;Frist
psot&quot;, &quot;author&quot;: &quot;anon&quot;},</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;title&quot;: &quot;A
well&minus;written article&quot;, &quot;author&quot;:
&quot;person1&quot;}], <br>
&quot;realnames&quot;: {&quot;anon&quot;: &quot;Anonymous
Coward&quot;, <br>
&quot;person1&quot;: &quot;Person McPherson&quot;}}</p>

<p style="margin-left:11%; margin-top: 1em">We want to
produce the posts with the author field containing a real
name, as in:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="81%">


<p>{&quot;title&quot;: &quot;Frist psot&quot;,
&quot;author&quot;: &quot;Anonymous Coward&quot;}</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;title&quot;: &quot;A
well&minus;written article&quot;, &quot;author&quot;:
&quot;Person McPherson&quot;}</p>

<p style="margin-left:11%; margin-top: 1em">We use a
variable, $names, to store the realnames object, so that we
can refer to it later when looking up author usernames:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>.realnames as $names | .posts[] | {title, author:
$names[.author]}</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The expression
<b>exp as $x | ...</b> means: for each value of expression
<b>exp</b>, run the rest of the pipeline with the entire
original input, and with <b>$x</b> set to that value. Thus
<b>as</b> functions as something of a foreach loop.</p>

<p style="margin-left:11%; margin-top: 1em">Just as
<b>{foo}</b> is a handy way of writing <b>{foo: .foo}</b>,
so <b>{$foo}</b> is a handy way of writing
<b>{foo:$foo}</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Multiple
variables may be declared using a single <b>as</b>
expression by providing a pattern that matches the structure
of the input (this is known as
&quot;destructuring&quot;):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>. as {realnames: $names, posts: [$first, $second]} |
...</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The variable
declarations in array patterns (e.g., <b>. as [$first,
$second]</b>) bind to the elements of the array in from the
element at index zero on up, in order. When there is no
value at the index for an array pattern element, <b>null</b>
is bound to that variable.</p>

<p style="margin-left:11%; margin-top: 1em">Variables are
scoped over the rest of the expression that defines them,
so</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>.realnames as $names | (.posts[] | {title, author:
$names[.author]})</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">will work,
but</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>(.realnames as $names | .posts[]) | {title, author:
$names[.author]}</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em">won&acute;t.</p>

<p style="margin-left:11%; margin-top: 1em">For programming
language theorists, it&acute;s more accurate to say that jq
variables are lexically&minus;scoped bindings. In particular
there&acute;s no way to change the value of a binding; one
can only setup a new binding with the same name, but which
will not be visible where the old one was.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="48%">


<p>jq &acute;.bar as $x | .foo | . + $x&acute;</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;foo&quot;:10,
&quot;bar&quot;:200} <br>
=&gt; 210</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;. as
$i|[(.*2|. as $i| $i), $i]&acute; <br>
5 <br>
=&gt; [10,5]</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;. as
[$a, $b, {c: $c}] | $a + $b + $c&acute; <br>
[2, 3, {&quot;c&quot;: 4, &quot;d&quot;: 5}] <br>
=&gt; 9</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;.[]
as [$a, $b] | {a: $a, b: $b}&acute; <br>
[[0], [0, 1], [2, 1, 0]] <br>
=&gt; {&quot;a&quot;:0,&quot;b&quot;:null},
{&quot;a&quot;:0,&quot;b&quot;:1},
{&quot;a&quot;:2,&quot;b&quot;:1}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Defining
Functions</b> <br>
You can give a filter a name using &quot;def&quot;
syntax:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="32%">


<p>def increment: . + 1;</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">From then on,
<b>increment</b> is usable as a filter just like a builtin
function (in fact, this is how many of the builtins are
defined). A function may take arguments:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="34%">


<p>def map(f): [.[] | f];</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Arguments are
passed as <i>filters</i> (functions with no arguments),
<i>not</i> as values. The same argument may be referenced
multiple times with different inputs (here <b>f</b> is run
for each element of the input array). Arguments to a
function work more like callbacks than like value arguments.
This is important to understand. Consider:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="25%">


<p>def foo(f): f|f;</p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:17%;">5|foo(.*2)</p>

<p style="margin-left:11%; margin-top: 1em">The result will
be 20 because <b>f</b> is <b>.*2</b>, and during the first
invocation of <b>f .</b> will be 5, and the second time it
will be 10 (5 * 2), so the result will be 20. Function
arguments are filters, and filters expect an input when
invoked.</p>

<p style="margin-left:11%; margin-top: 1em">If you want the
value&minus;argument behaviour for defining simple
functions, you can just use a variable:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="60%">


<p>def addvalue(f): f as $f | map(. + $f);</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Or use the
short&minus;hand:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="34%">


<p>def addvalue($f): ...;</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">With either
definition, <b>addvalue(.foo)</b> will add the current
input&acute;s <b>.foo</b> field to each element of the
array. Do note that calling <b>addvalue(.[])</b> will cause
the <b>map(. + $f)</b> part to be evaluated once per value
in the value of <b>.</b> at the call site.</p>

<p style="margin-left:11%; margin-top: 1em">Multiple
definitions using the same function name are allowed. Each
re&minus;definition replaces the previous one for the same
number of function arguments, but only for references from
functions (or main program) subsequent to the
re&minus;definition. See also the section below on
scoping.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="77%">


<p>jq &acute;def addvalue(f): . + [f];
map(addvalue(.[0]))&acute;</p> </td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:17%;">[[1,2],[10,20]] <br>
=&gt; [[1,2,1], [10,20,10]]</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;def
addvalue(f): f as $x | map(. + $x); addvalue(.[0])&acute;
<br>
[[1,2],[10,20]] <br>
=&gt; [[1,2,1,2], [10,20,1,2]]</p>

<p style="margin-left:11%; margin-top: 1em"><b>Scoping</b>
<br>
There are two types of symbols in jq: value bindings
(a.k.a., &quot;variables&quot;), and functions. Both are
scoped lexically, with expressions being able to refer only
to symbols that have been defined &quot;to the left&quot; of
them. The only exception to this rule is that functions can
refer to themselves so as to be able to create recursive
functions.</p>

<p style="margin-left:11%; margin-top: 1em">For example, in
the following expression there is a binding which is visible
&quot;to the right&quot; of it, <b>... | .*3 as $times_three
| [. + $times_three] | ...</b>, but not &quot;to the
left&quot;. Consider this expression now, <b>... | (.*3 as
$times_three | [.+ $times_three]) | ...</b>: here the
binding <b>$times_three</b> is <i>not</i> visible past the
closing parenthesis.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Reduce</b>
<br>
The <b>reduce</b> syntax in jq allows you to combine all of
the results of an expression by accumulating them into a
single answer. As an example, we&acute;ll pass
<b>[3,2,1]</b> to this expression:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="52%">


<p>reduce .[] as $item (0; . + $item)</p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">For each result
that <b>.[]</b> produces, <b>. + $item</b> is run to
accumulate a running total, starting from 0. In this
example, <b>.[]</b> produces the results 3, 2, and 1, so the
effect is similar to running something like this:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="46%">


<p>0 | (3 as $item | . + $item) |</p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:17%;">(2 as $item | . + $item) | <br>
(1 as $item | . + $item)</p>

<p style="margin-left:17%; margin-top: 1em">jq
&acute;reduce .[] as $item (0; . + $item)&acute; <br>
[10,2,5,3] <br>
=&gt; 20</p>


<p style="margin-left:11%; margin-top: 1em"><b>isempty(exp)</b>
<br>
Returns true if <b>exp</b> produces no outputs, false
otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="29%">


<p>jq &acute;isempty(empty)&acute;</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; true</p>

<p style="margin-left:11%; margin-top: 1em"><b>limit(n;
exp)</b> <br>
The <b>limit</b> function extracts up to <b>n</b> outputs
from <b>exp</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="29%">


<p>jq &acute;[limit(3;.[])]&acute;</p></td>
<td width="54%">
</td></tr>
</table>

<p style="margin-left:17%;">[0,1,2,3,4,5,6,7,8,9] <br>
=&gt; [0,1,2]</p>


<p style="margin-left:11%; margin-top: 1em"><b>first(expr),
last(expr), nth(n; expr)</b> <br>
The <b>first(expr)</b> and <b>last(expr)</b> functions
extract the first and last values from <b>expr</b>,
respectively.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>nth(n;
expr)</b> function extracts the nth value output by
<b>expr</b>. This can be defined as <b>def nth(n; expr):
last(limit(n + 1; expr));</b>. Note that <b>nth(n; expr)</b>
doesn&acute;t support negative values of <b>n</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>jq &acute;[first(range(.)), last(range(.)), nth(./2;
range(.))]&acute;</p> </td></tr>
</table>

<p style="margin-left:17%;">10 <br>
=&gt; [0,9,5]</p>

<p style="margin-left:11%; margin-top: 1em"><b>first, last,
nth(n)</b> <br>
The <b>first</b> and <b>last</b> functions extract the first
and last values from any array at <b>.</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>nth(n)</b> function extracts the nth value of any array
at <b>.</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="57%">


<p>jq &acute;[range(.)]|[first, last, nth(5)]&acute;</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%;">10 <br>
=&gt; [0,9,5]</p>

<p style="margin-left:11%; margin-top: 1em"><b>foreach</b>
<br>
The <b>foreach</b> syntax is similar to <b>reduce</b>, but
intended to allow the construction of <b>limit</b> and
reducers that produce intermediate results (see
example).</p>

<p style="margin-left:11%; margin-top: 1em">The form is
<b>foreach EXP as $var (INIT; UPDATE; EXTRACT)</b>. Like
<b>reduce</b>, <b>INIT</b> is evaluated once to produce a
state value, then each output of <b>EXP</b> is bound to
<b>$var</b>, <b>UPDATE</b> is evaluated for each output of
<b>EXP</b> with the current state and with <b>$var</b>
visible. Each value output by <b>UPDATE</b> replaces the
previous state. Finally, <b>EXTRACT</b> is evaluated for
each new state to extract an output of <b>foreach</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This is mostly
useful only for constructing <b>reduce</b>&minus; and
<b>limit</b>&minus;like functions. But it is much more
general, as it allows for partial reductions (see the
example below).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>jq &acute;[foreach .[] as $item ([[],[]]; if $item ==
null then [[],.[0]] else [(.[0] + [$item]),[]] end; if $item
== null then .[1] else empty end)]&acute;</p></td></tr>
</table>


<p style="margin-left:17%;">[1,2,3,4,null,&quot;a&quot;,&quot;b&quot;,null]
<br>
=&gt; [[1,2,3,4],[&quot;a&quot;,&quot;b&quot;]]</p>


<p style="margin-left:11%; margin-top: 1em"><b>Recursion</b>
<br>
As described above, <b>recurse</b> uses recursion, and any
jq function can be recursive. The <b>while</b> builtin is
also implemented in terms of recursion.</p>

<p style="margin-left:11%; margin-top: 1em">Tail calls are
optimized whenever the expression to the left of the
recursive call outputs its last value. In practice this
means that the expression to the left of the recursive call
should not produce more than one output for each input.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>def recurse(f): def r: ., (f | select(. != null) | r);
r;</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">def while(cond;
update): <br>
def _while: <br>
if cond then ., (update | _while) else empty end; <br>
_while;</p>

<p style="margin-left:17%; margin-top: 1em">def
repeat(exp): <br>
def _repeat: <br>
exp, _repeat; <br>
_repeat;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Generators
and iterators</b> <br>
Some jq operators and functions are actually generators in
that they can produce zero, one, or more values for each
input, just as one might expect in other programming
languages that have generators. For example, <b>.[]</b>
generates all the values in its input (which must be an
array or an object), <b>range(0; 10)</b> generates the
integers between 0 and 10, and so on.</p>

<p style="margin-left:11%; margin-top: 1em">Even the comma
operator is a generator, generating first the values
generated by the expression to the left of the comma, then
for each of those, the values generate by the expression on
the right of the comma.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>empty</b> builtin is the generator that produces zero
outputs. The <b>empty</b> builtin backtracks to the
preceding generator expression.</p>

<p style="margin-left:11%; margin-top: 1em">All jq
functions can be generators just by using builtin
generators. It is also possible to define new generators
using only recursion and the comma operator. If the
recursive call(s) is(are) &quot;in tail position&quot; then
the generator will be efficient. In the example below the
recursive call by <b>_range</b> to itself is in tail
position. The example shows off three advanced topics: tail
recursion, generator construction, and
sub&minus;functions.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>jq &acute;def range(init; upto; by): def _range: if (by
&gt; 0 and . &lt; upto) or (by &lt; 0 and . &gt; upto) then
., ((.+by)|_range) else . end; if by == 0 then init else
init|_range end | select((by &gt; 0 and . &lt; upto) or (by
&lt; 0 and . &gt; upto)); range(0; 10; 3)&acute;</p></td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; 0, 3, 6, 9</p>

<p style="margin-left:17%; margin-top: 1em">jq &acute;def
while(cond; update): def _while: if cond then ., (update |
_while) else empty end; _while; [while(.&lt;100;
.*2)]&acute; <br>
1 <br>
=&gt; [1,2,4,8,16,32,64]</p>

<h2>MATH
<a name="MATH"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">jq currently
only has IEEE754 double&minus;precision (64&minus;bit)
floating point number support.</p>

<p style="margin-left:11%; margin-top: 1em">Besides simple
arithmetic operators such as <b>+</b>, jq also has most
standard math functions from the C math library. C math
functions that take a single input argument (e.g.,
<b>sin()</b>) are available as zero&minus;argument jq
functions. C math functions that take two input arguments
(e.g., <b>pow()</b>) are available as two&minus;argument jq
functions that ignore <b>.</b>. C math functions that take
three input arguments are available as three&minus;argument
jq functions that ignore <b>.</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Availability of
standard math functions depends on the availability of the
corresponding math functions in your operating system and C
math library. Unavailable math functions will be defined but
will raise an error.</p>


<p style="margin-left:11%; margin-top: 1em">One&minus;input
C math functions: <b>acos acosh asin asinh atan atanh cbrt
ceil cos cosh erf erfc exp exp10 exp2 expm1 fabs floor gamma
j0 j1 lgamma log log10 log1p log2 logb nearbyint pow10 rint
round significand sin sinh sqrt tan tanh tgamma trunc y0
y1</b>.</p>


<p style="margin-left:11%; margin-top: 1em">Two&minus;input
C math functions: <b>atan2 copysign drem fdim fmax fmin fmod
frexp hypot jn ldexp modf nextafter nexttoward pow remainder
scalb scalbln yn</b>.</p>


<p style="margin-left:11%; margin-top: 1em">Three&minus;input
C math functions: <b>fma</b>.</p>

<p style="margin-left:11%; margin-top: 1em">See your
system&acute;s manual for more information on each of
these.</p>

<h2>I/O
<a name="I/O"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">At this time jq
has minimal support for I/O, mostly in the form of control
over when inputs are read. Two builtins functions are
provided for this, <b>input</b> and <b>inputs</b>, that read
from the same sources (e.g., <b>stdin</b>, files named on
the command&minus;line) as jq itself. These two builtins,
and jq&acute;s own reading actions, can be interleaved with
each other.</p>

<p style="margin-left:11%; margin-top: 1em">Two builtins
provide minimal output capabilities, <b>debug</b>, and
<b>stderr</b>. (Recall that a jq program&acute;s output
values are always output as JSON texts on <b>stdout</b>.)
The <b>debug</b> builtin can have application&minus;specific
behavior, such as for executables that use the libjq C API
but aren&acute;t the jq executable itself. The <b>stderr</b>
builtin outputs its input in raw mode to stder with no
additional decoration, not even a newline.</p>

<p style="margin-left:11%; margin-top: 1em">Most jq
builtins are referentially transparent, and yield constant
and repeatable value streams when applied to constant
inputs. This is not true of I/O builtins.</p>

<p style="margin-left:11%; margin-top: 1em"><b>input</b>
<br>
Outputs one new input.</p>

<p style="margin-left:11%; margin-top: 1em"><b>inputs</b>
<br>
Outputs all remaining inputs, one by one.</p>

<p style="margin-left:11%; margin-top: 1em">This is
primarily useful for reductions over a program&acute;s
inputs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>debug</b>
<br>
Causes a debug message based on the input value to be
produced. The jq executable wraps the input value with
<b>[&quot;DEBUG:&quot;, &lt;input&minus;value&gt;]</b> and
prints that and a newline on stderr, compactly. This may
change in the future.</p>

<p style="margin-left:11%; margin-top: 1em"><b>stderr</b>
<br>
Prints its input in raw and compact mode to stderr with no
additional decoration, not even a newline.</p>


<p style="margin-left:11%; margin-top: 1em"><b>input_filename</b>
<br>
Returns the name of the file whose input is currently being
filtered. Note that this will not work well unless jq is
running in a UTF&minus;8 locale.</p>


<p style="margin-left:11%; margin-top: 1em"><b>input_line_number</b>
<br>
Returns the line number of the input currently being
filtered.</p>

<h2>STREAMING
<a name="STREAMING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">With the
<b>&minus;&minus;stream</b> option jq can parse input texts
in a streaming fashion, allowing jq programs to start
processing large JSON texts immediately rather than after
the parse completes. If you have a single JSON text that is
1GB in size, streaming it will allow you to process it much
more quickly.</p>

<p style="margin-left:11%; margin-top: 1em">However,
streaming isn&acute;t easy to deal with as the jq program
will have <b>[&lt;path&gt;, &lt;leaf&minus;value&gt;]</b>
(and a few other forms) as inputs.</p>

<p style="margin-left:11%; margin-top: 1em">Several
builtins are provided to make handling streams easier.</p>

<p style="margin-left:11%; margin-top: 1em">The examples
below use the streamed form of <b>[0,[1]]</b>, which is
<b>[[0],0],[[1,0],1],[[1,0]],[[1]]</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Streaming forms
include <b>[&lt;path&gt;, &lt;leaf&minus;value&gt;]</b> (to
indicate any scalar value, empty array, or empty object),
and <b>[&lt;path&gt;]</b> (to indicate the end of an array
or object). Future versions of jq run with
<b>&minus;&minus;stream</b> and <b>&minus;seq</b> may output
additional forms such as <b>[&quot;error message&quot;]</b>
when an input text fails to parse.</p>


<p style="margin-left:11%; margin-top: 1em"><b>truncate_stream(stream_expression)</b>
<br>
Consumes a number as input and truncates the corresponding
number of path elements from the left of the outputs of the
given streaming expression.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>jq
&acute;[1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]])]&acute;</p> </td></tr>
</table>

<p style="margin-left:17%;">1 <br>
=&gt; [[[0],2],[[0]]]</p>


<p style="margin-left:11%; margin-top: 1em"><b>fromstream(stream_expression)</b>
<br>
Outputs values corresponding to the stream
expression&acute;s outputs.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>jq
&acute;fromstream(1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]]))&acute;</p> </td></tr>
</table>

<p style="margin-left:17%;">null <br>
=&gt; [2]</p>


<p style="margin-left:11%; margin-top: 1em"><b>tostream</b>
<br>
The <b>tostream</b> builtin outputs the streamed form of its
input.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="74%">


<p>jq &acute;. as
$dot|fromstream($dot|tostream)|.==$dot&acute;</p> </td>
<td width="9%">
</td></tr>
</table>


<p style="margin-left:17%;">[0,[1,{&quot;a&quot;:1},{&quot;b&quot;:2}]]
<br>
=&gt; true</p>

<h2>ASSIGNMENT
<a name="ASSIGNMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Assignment
works a little differently in jq than in most programming
languages. jq doesn&acute;t distinguish between references
to and copies of something &minus; two objects or arrays are
either equal or not equal, without any further notion of
being &quot;the same object&quot; or &quot;not the same
object&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If an object
has two fields which are arrays, <b>.foo</b> and
<b>.bar</b>, and you append something to <b>.foo</b>, then
<b>.bar</b> will not get bigger, even if you&acute;ve
previously set <b>.bar = .foo</b>. If you&acute;re used to
programming in languages like Python, Java, Ruby,
Javascript, etc. then you can think of it as though jq does
a full deep copy of every object before it does the
assignment (for performance it doesn&acute;t actually do
that, but that&acute;s the general idea).</p>

<p style="margin-left:11%; margin-top: 1em">This means that
it&acute;s impossible to build circular values in jq (such
as an array whose first element is itself). This is quite
intentional, and ensures that anything a jq program can
produce can be represented in JSON.</p>

<p style="margin-left:11%; margin-top: 1em">All the
assignment operators in jq have path expressions on the
left&minus;hand side (LHS). The right&minus;hand side (RHS)
procides values to set to the paths named by the LHS path
expressions.</p>

<p style="margin-left:11%; margin-top: 1em">Values in jq
are always immutable. Internally, assignment works by using
a reduction to compute new, replacement values for <b>.</b>
that have had all the desired assignments applied to
<b>.</b>, then outputting the modified value. This might be
made clear by this example: <b>{a:{b:{c:1}}} | (.a.b|=3),
.</b>. This will output
<b>{&quot;a&quot;:{&quot;b&quot;:3}}</b> and
<b>{&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:1}}}</b>
because the last sub&minus;expression, <b>.</b>, sees the
original value, not the modified value.</p>

<p style="margin-left:11%; margin-top: 1em">Most users will
want to use modification assignment operators, such as
<b>|=</b> or <b>+=</b>, rather than <b>=</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
LHS of assignment operators refers to a value in <b>.</b>.
Thus <b>$var.foo = 1</b> won&acute;t work as expected
(<b>$var.foo</b> is not a valid or useful path expression in
<b>.</b>); use <b>$var | .foo = 1</b> instead.</p>

<p style="margin-left:11%; margin-top: 1em">Note too that
<b>.a,.b=0</b> does not set <b>.a</b> and <b>.b</b>, but
<b>(.a,.b)=0</b> sets both.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Update&minus;assignment:
|=</b> <br>
This is the &quot;update&quot; operator &acute;|=&acute;. It
takes a filter on the right&minus;hand side and works out
the new value for the property of <b>.</b> being assigned to
by running the old value through this expression. For
instance, (.foo, .bar) |= .+1 will build an object with the
&quot;foo&quot; field set to the input&acute;s
&quot;foo&quot; plus 1, and the &quot;bar&quot; field set to
the input&acute;s &quot;bar&quot; plus 1.</p>

<p style="margin-left:11%; margin-top: 1em">The
left&minus;hand side can be any general path expression; see
<b>path()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
left&minus;hand side of &acute;|=&acute; refers to a value
in <b>.</b>. Thus <b>$var.foo |= . + 1</b> won&acute;t work
as expected (<b>$var.foo</b> is not a valid or useful path
expression in <b>.</b>); use <b>$var | .foo |= . + 1</b>
instead.</p>

<p style="margin-left:11%; margin-top: 1em">If the
right&minus;hand side outputs no values (i.e.,
<b>empty</b>), then the left&minus;hand side path will be
deleted, as with <b>del(path)</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If the
right&minus;hand side outputs multiple values, only the
first one will be used (COMPATIBILITY NOTE: in jq 1.5 and
earlier releases, it used to be that only the last one was
used).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>jq &acute;(..|select(type==&quot;boolean&quot;)) |= if .
then 1 else 0 end&acute;</p></td></tr>
</table>


<p style="margin-left:17%;">[true,false,[5,true,[true,[false]],false]]
<br>
=&gt; [1,0,[5,1,[1,[0]],0]]</p>

<p style="margin-left:11%; margin-top: 1em"><b>Arithmetic
update&minus;assignment: +=, &minus;=, *=, /=, %=, //=</b>
<br>
jq has a few operators of the form <b>a op= b</b>, which are
all equivalent to <b>a |= . op b</b>. So, <b>+= 1</b> can be
used to increment values, being the same as <b>|= . +
1</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="21%">


<p>jq &acute;.foo += 1&acute;</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%;">{&quot;foo&quot;: 42} <br>
=&gt; {&quot;foo&quot;: 43}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Plain
assignment: =</b> <br>
This is the plain assignment operator. Unlike the others,
the input to the right&minus;hand&minus;side (RHS) is the
same as the input to the left&minus;hand&minus;side (LHS)
rather than the value at the LHS path, and all values output
by the RHS will be used (as shown below).</p>

<p style="margin-left:11%; margin-top: 1em">If the RHS of
&acute;=&acute; produces multiple values, then for each such
value jq will set the paths on the left&minus;hand side to
the value and then it will output the modified <b>.</b>. For
example, <b>(.a,.b)=range(2)</b> outputs
<b>{&quot;a&quot;:0,&quot;b&quot;:0}</b>, then
<b>{&quot;a&quot;:1,&quot;b&quot;:1}</b>. The
&quot;update&quot; assignment forms (see above) do not do
this.</p>

<p style="margin-left:11%; margin-top: 1em">This example
should show the difference between &acute;=&acute; and
&acute;|=&acute;:</p>

<p style="margin-left:11%; margin-top: 1em">Provide input
&acute;{&quot;a&quot;: {&quot;b&quot;: 10}, &quot;b&quot;:
20}&acute; to the programs:</p>

<p style="margin-left:11%; margin-top: 1em">.a = .b</p>

<p style="margin-left:11%; margin-top: 1em">.a |= .b</p>

<p style="margin-left:11%; margin-top: 1em">The former will
set the &quot;a&quot; field of the input to the
&quot;b&quot; field of the input, and produce the output
{&quot;a&quot;: 20, &quot;b&quot;: 20}. The latter will set
the &quot;a&quot; field of the input to the &quot;a&quot;
field&acute;s &quot;b&quot; field, producing {&quot;a&quot;:
10, &quot;b&quot;: 20}.</p>

<p style="margin-left:11%; margin-top: 1em">Another example
of the difference between &acute;=&acute; and
&acute;|=&acute;:</p>


<p style="margin-left:11%; margin-top: 1em">null|(.a,.b)=range(3)</p>

<p style="margin-left:11%; margin-top: 1em">outputs
&acute;{&quot;a&quot;:0,&quot;b&quot;:0}&acute;,
&acute;{&quot;a&quot;:1,&quot;b&quot;:1}&acute;, and
&acute;{&quot;a&quot;:2,&quot;b&quot;:2}&acute;, while</p>


<p style="margin-left:11%; margin-top: 1em">null|(.a,.b)|=range(3)</p>

<p style="margin-left:11%; margin-top: 1em">outputs just
&acute;{&quot;a&quot;:0,&quot;b&quot;:0}&acute;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Complex
assignments</b> <br>
Lots more things are allowed on the left&minus;hand side of
a jq assignment than in most languages. We&acute;ve already
seen simple field accesses on the left hand side, and
it&acute;s no surprise that array accesses work just as
well:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="45%">


<p>.posts[0].title = &quot;JQ Manual&quot;</p></td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">What may come
as a surprise is that the expression on the left may produce
multiple results, referring to different points in the input
document:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="65%">


<p>.posts[].comments |= . + [&quot;this is great&quot;]</p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">That example
appends the string &quot;this is great&quot; to the
&quot;comments&quot; array of each post in the input (where
the input is an object with a field &quot;posts&quot; which
is an array of posts).</p>

<p style="margin-left:11%; margin-top: 1em">When jq
encounters an assignment like &acute;a = b&acute;, it
records the &quot;path&quot; taken to select a part of the
input document while executing a. This path is then used to
find which part of the input to change while executing the
assignment. Any filter may be used on the left&minus;hand
side of an equals &minus; whichever paths it selects from
the input will be where the assignment is performed.</p>

<p style="margin-left:11%; margin-top: 1em">This is a very
powerful operation. Suppose we wanted to add a comment to
blog posts, using the same &quot;blog&quot; input above.
This time, we only want to comment on the posts written by
&quot;stedolan&quot;. We can find those posts using the
&quot;select&quot; function described earlier:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="61%">


<p>.posts[] | select(.author == &quot;stedolan&quot;)</p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The paths
provided by this operation point to each of the posts that
&quot;stedolan&quot; wrote, and we can comment on each of
them in the same way that we did before:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>(.posts[] | select(.author == &quot;stedolan&quot;) |
.comments) |=</p></td></tr>
</table>

<p style="margin-left:17%;">. + [&quot;terrible.&quot;]</p>

<h2>MODULES
<a name="MODULES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">jq has a
library/module system. Modules are files whose names end in
<b>.jq</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Modules
imported by a program are searched for in a default search
path (see below). The <b>import</b> and <b>include</b>
directives allow the importer to alter this path.</p>

<p style="margin-left:11%; margin-top: 1em">Paths in the a
search path are subject to various substitutions.</p>

<p style="margin-left:11%; margin-top: 1em">For paths
starting with &quot;~/&quot;, the user&acute;s home
directory is substituted for &quot;~&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">For paths
starting with &quot;$ORIGIN/&quot;, the path of the jq
executable is substituted for &quot;$ORIGIN&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">For paths
starting with &quot;./&quot; or paths that are
&quot;.&quot;, the path of the including file is substituted
for &quot;.&quot;. For top&minus;level programs given on the
command&minus;line, the current directory is used.</p>

<p style="margin-left:11%; margin-top: 1em">Import
directives can optionally specify a search path to which the
default is appended.</p>

<p style="margin-left:11%; margin-top: 1em">The default
search path is the search path given to the <b>&minus;L</b>
command&minus;line option, else <b>[&quot;~/.jq&quot;,
&quot;$ORIGIN/../lib/jq&quot;,
&quot;$ORIGIN/../lib&quot;]</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Null and empty
string path elements terminate search path processing.</p>

<p style="margin-left:11%; margin-top: 1em">A dependency
with relative path &quot;foo/bar&quot; would be searched for
in &quot;foo/bar.jq&quot; and &quot;foo/bar/bar.jq&quot; in
the given search path. This is intended to allow modules to
be placed in a directory along with, for example, version
control files, README files, and so on, but also to allow
for single&minus;file modules.</p>

<p style="margin-left:11%; margin-top: 1em">Consecutive
components with the same name are not allowed to avoid
ambiguities (e.g., &quot;foo/foo&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">For example,
with <b>&minus;L$HOME/.jq</b> a module <b>foo</b> can be
found in <b>$HOME/.jq/foo.jq</b> and
<b>$HOME/.jq/foo/foo.jq</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If
&quot;$HOME/.jq&quot; is a file, it is sourced into the main
program.</p>

<p style="margin-left:11%; margin-top: 1em"><b>import
RelativePathString as NAME [&lt;metadata&gt;];</b> <br>
Imports a module found at the given path relative to a
directory in a search path. A &quot;.jq&quot; suffix will be
added to the relative path string. The module&acute;s
symbols are prefixed with &quot;NAME::&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The optional
metadata must be a constant jq expression. It should be an
object with keys like &quot;homepage&quot; and so on. At
this time jq only uses the &quot;search&quot; key/value of
the metadata. The metadata is also made available to users
via the <b>modulemeta</b> builtin.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;search&quot; key in the metadata, if present, should
have a string or array value (array of strings); this is the
search path to be prefixed to the top&minus;level search
path.</p>

<p style="margin-left:11%; margin-top: 1em"><b>include
RelativePathString [&lt;metadata&gt;];</b> <br>
Imports a module found at the given path relative to a
directory in a search path as if it were included in place.
A &quot;.jq&quot; suffix will be added to the relative path
string. The module&acute;s symbols are imported into the
caller&acute;s namespace as if the module&acute;s content
had been included directly.</p>

<p style="margin-left:11%; margin-top: 1em">The optional
metadata must be a constant jq expression. It should be an
object with keys like &quot;homepage&quot; and so on. At
this time jq only uses the &quot;search&quot; key/value of
the metadata. The metadata is also made available to users
via the <b>modulemeta</b> builtin.</p>

<p style="margin-left:11%; margin-top: 1em"><b>import
RelativePathString as $NAME [&lt;metadata&gt;];</b> <br>
Imports a JSON file found at the given path relative to a
directory in a search path. A &quot;.json&quot; suffix will
be added to the relative path string. The file&acute;s data
will be available as <b>$NAME::NAME</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The optional
metadata must be a constant jq expression. It should be an
object with keys like &quot;homepage&quot; and so on. At
this time jq only uses the &quot;search&quot; key/value of
the metadata. The metadata is also made available to users
via the <b>modulemeta</b> builtin.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;search&quot; key in the metadata, if present, should
have a string or array value (array of strings); this is the
search path to be prefixed to the top&minus;level search
path.</p>

<p style="margin-left:11%; margin-top: 1em"><b>module
&lt;metadata&gt;;</b> <br>
This directive is entirely optional. It&acute;s not required
for proper operation. It serves only the purpose of
providing metadata that can be read with the
<b>modulemeta</b> builtin.</p>

<p style="margin-left:11%; margin-top: 1em">The metadata
must be a constant jq expression. It should be an object
with keys like &quot;homepage&quot;. At this time jq
doesn&acute;t use this metadata, but it is made available to
users via the <b>modulemeta</b> builtin.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modulemeta</b>
<br>
Takes a module name as input and outputs the module&acute;s
metadata as an object, with the module&acute;s imports
(including metadata) as an array value for the
&quot;deps&quot; key.</p>

<p style="margin-left:11%; margin-top: 1em">Programs can
use this to query a module&acute;s metadata, which they
could then use to, for example, search for, download, and
install missing dependencies.</p>

<h2>COLORS
<a name="COLORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To configure
alternative colors just set the <b>JQ_COLORS</b> environment
variable to colon&minus;delimited list of partial terminal
escape sequences like <b>&quot;1;31&quot;</b>, in this
order:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p>color for <b>null</b></p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p>color for <b>false</b></p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p>color for <b>true</b></p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p>color for numbers</p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p>color for strings</p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p>color for arrays</p></td>
<td width="57%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p>color for objects</p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The default
color scheme is the same as setting
<b>&quot;JQ_COLORS=1;30:0;39:0;39:0;39:0;32:1;39:1;39&quot;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This is not a
manual for VT100/ANSI escapes. However, each of these color
specifications should consist of two numbers separated by a
semi&minus;colon, where the first number is one of
these:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>1 (bright)</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>2 (dim)</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>4 (underscore)</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>5 (blink)</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>7 (reverse)</p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p>8 (hidden)</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">and the second
is one of these:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p>30 (black)</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p>31 (red)</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p>32 (green)</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p>33 (yellow)</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p>34 (blue)</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p>35 (magenta)</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p>36 (cyan)</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p>37 (white)</p></td>
<td width="65%">
</td></tr>
</table>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Presumably.
Report them or discuss them at:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="57%">


<p>https://github.com/stedolan/jq/issues</p></td>
<td width="26%">
</td></tr>
</table>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Stephen Dolan
<b>&lt;mu@netsoc.tcd.ie&gt;</b></p>
<hr>
</body>
</html>
