<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLREREF</title>

</head>
<body>
<h1>perlreref</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlreref
&minus; Perl Regular Expressions Reference</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is a quick
reference to Perl&rsquo;s regular expressions. For full
information see perlre and perlop, as well as the &quot;
<small>SEE ALSO&quot;</small> section in this document.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>OPERATORS</small></b>
<br>
&quot;=~&quot; determines to which variable the regex is
applied. In its absence, $_ is used.</p>

<p style="margin-left:11%; margin-top: 1em">$var =~
/foo/;</p>

<p style="margin-left:11%; margin-top: 1em">&quot;!~&quot;
determines to which variable the regex is applied, and
negates the result of the match; it returns false if the
match succeeds, and true if it fails.</p>

<p style="margin-left:11%; margin-top: 1em">$var !~
/foo/;</p>


<p style="margin-left:11%; margin-top: 1em">&quot;m/pattern/msixpogcdualn&quot;
searches a string for a pattern match, applying the given
options.</p>

<p style="margin-left:11%; margin-top: 1em">m Multiline
mode &minus; ^ and $ match internal lines <br>
s match as a Single line &minus; . matches \n <br>
i case&minus;Insensitive <br>
x eXtended legibility &minus; free whitespace and comments
<br>
p Preserve a copy of the matched string &minus; <br>
${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined. <br>
o compile pattern Once <br>
g Global &minus; all occurrences <br>
c don't reset pos on failed matches when using /g <br>
a restrict \d, \s, \w and [:posix:] to match ASCII only <br>
aa (two a's) also /i matches exclude ASCII/non&minus;ASCII
<br>
l match according to current locale <br>
u match according to Unicode rules <br>
d match according to native rules unless something indicates
<br>
Unicode <br>
n Non&minus;capture mode. Don't let () fill in $1, $2,
etc...</p>

<p style="margin-left:11%; margin-top: 1em">If
&rsquo;pattern&rsquo; is an empty string, the last
<i>successfully</i> matched regex is used. Delimiters other
than &rsquo;/&rsquo; may be used for both this operator and
the following ones. The leading &quot;m&quot; can be omitted
if the delimiter is &rsquo;/&rsquo;.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;qr/pattern/msixpodualn&quot;
lets you store a regex in a variable, or pass one around.
Modifiers as for &quot;m//&quot;, and are stored within the
regex.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;s/pattern/replacement/msixpogcedual&quot;
substitutes matches of &rsquo;pattern&rsquo; with
&rsquo;replacement&rsquo;. Modifiers as for &quot;m//&quot;,
with two additions:</p>

<p style="margin-left:11%; margin-top: 1em">e Evaluate
'replacement' as an expression <br>
r Return substitution and leave the original string
untouched.</p>


<p style="margin-left:11%; margin-top: 1em">&rsquo;e&rsquo;
may be specified multiple times. &rsquo;replacement&rsquo;
is interpreted as a double quoted string unless a
single-quote (&quot;'&quot;) is the delimiter.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;m?pattern?&quot;
is like &quot;m/pattern/&quot; but matches only once. No
alternate delimiters can be used. Must be reset with
<b>reset()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>SYNTAX</small></b>
<br>
\ Escapes the character immediately following it <br>
. Matches any single character except a newline (unless /s
is <br>
used) <br>
^ Matches at the beginning of the string (or line, if /m is
used) <br>
$ Matches at the end of the string (or line, if /m is used)
<br>
* Matches the preceding element 0 or more times <br>
+ Matches the preceding element 1 or more times <br>
? Matches the preceding element 0 or 1 times <br>
{...} Specifies a range of occurrences for the element
preceding it <br>
[...] Matches any one of the characters contained within the
brackets <br>
(...) Groups subexpressions for capturing to $1, $2... <br>
(?:...) Groups subexpressions without capturing (cluster)
<br>
| Matches either the subexpression preceding or following it
<br>
\g1 or \g{1}, \g2 ... Matches the text from the Nth group
<br>
\1, \2, \3 ... Matches the text from the Nth group <br>
\g&minus;1 or \g{&minus;1}, \g&minus;2 ... Matches the text
from the Nth previous group <br>
\g{name} Named backreference <br>
\k&lt;name&gt; Named backreference <br>
\k'name' Named backreference <br>
(?P=name) Named backreference (python syntax)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ESCAPE
SEQUENCES</small></b> <br>
These work as in normal strings.</p>

<p style="margin-left:11%; margin-top: 1em">\a Alarm (beep)
<br>
\e Escape <br>
\f Formfeed <br>
\n Newline <br>
\r Carriage return <br>
\t Tab <br>
\037 Char whose ordinal is the 3 octal digits, max \777 <br>
\o{2307} Char whose ordinal is the octal number,
unrestricted <br>
\x7f Char whose ordinal is the 2 hex digits, max \xFF <br>
\x{263a} Char whose ordinal is the hex number, unrestricted
<br>
\cx Control&minus;x <br>
\N{name} A named Unicode character or character sequence
<br>
\N{U+263D} A Unicode character by hex ordinal <br>
\l Lowercase next character <br>
\u Titlecase next character <br>
\L Lowercase until \E <br>
\U Uppercase until \E <br>
\F Foldcase until \E <br>
\Q Disable pattern metacharacters until \E <br>
\E End modification</p>

<p style="margin-left:11%; margin-top: 1em">For Titlecase,
see &quot;Titlecase&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This one works
differently from normal strings:</p>

<p style="margin-left:11%; margin-top: 1em">\b An
assertion, not backspace, except in a character class</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CHARACTER
CLASSES</small></b> <br>
[amy] Match 'a', 'm' or 'y' <br>
[f&minus;j] Dash specifies &quot;range&quot; <br>
[f&minus;j&minus;] Dash escaped or at start or end means
'dash' <br>
[^f&minus;j] Caret indicates &quot;match any character
_except_ these&quot;</p>

<p style="margin-left:11%; margin-top: 1em">The following
sequences (except &quot;\N&quot;) work within or without a
character class. The first six are locale aware, all are
Unicode aware. See perllocale and perlunicode for
details.</p>

<p style="margin-left:11%; margin-top: 1em">\d A digit <br>
\D A nondigit <br>
\w A word character <br>
\W A non&minus;word character <br>
\s A whitespace character <br>
\S A non&minus;whitespace character <br>
\h A horizontal whitespace <br>
\H A non horizontal whitespace <br>
\N A non newline (when not followed by '{NAME}';; <br>
not valid in a character class; equivalent to [^\n]; it's
<br>
like '.' without /s modifier) <br>
\v A vertical whitespace <br>
\V A non vertical whitespace <br>
\R A generic newline (?&gt;\v|\x0D\x0A) <br>
\pP Match P&minus;named (Unicode) property <br>
\p{...} Match Unicode property with name longer than 1
character <br>
\PP Match non&minus;P <br>
\P{...} Match lack of Unicode property with name longer than
1 char <br>
\X Match Unicode extended grapheme cluster</p>


<p style="margin-left:11%; margin-top: 1em"><small>POSIX</small>
character classes and their Unicode and Perl
equivalents:</p>

<p style="margin-left:11%; margin-top: 1em">ASCII&minus;
Full&minus; <br>
POSIX range range backslash <br>
[[:...:]] \p{...} \p{...} sequence Description <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
alnum PosixAlnum XPosixAlnum 'alpha' plus 'digit' <br>
alpha PosixAlpha XPosixAlpha Alphabetic characters <br>
ascii ASCII Any ASCII character <br>
blank PosixBlank XPosixBlank \h Horizontal whitespace; <br>
full&minus;range also <br>
written as <br>
\p{HorizSpace} (GNU <br>
extension) <br>
cntrl PosixCntrl XPosixCntrl Control characters <br>
digit PosixDigit XPosixDigit \d Decimal digits <br>
graph PosixGraph XPosixGraph 'alnum' plus 'punct' <br>
lower PosixLower XPosixLower Lowercase characters <br>
print PosixPrint XPosixPrint 'graph' plus 'space', <br>
but not any Controls <br>
punct PosixPunct XPosixPunct Punctuation and Symbols <br>
in ASCII&minus;range; just <br>
punct outside it <br>
space PosixSpace XPosixSpace \s Whitespace <br>
upper PosixUpper XPosixUpper Uppercase characters <br>
word PosixWord XPosixWord \w 'alnum' + Unicode marks <br>
+ connectors, like <br>
'_' (Perl extension) <br>
xdigit ASCII_Hex_Digit XPosixDigit Hexadecimal digit, <br>
ASCII&minus;range is <br>
[0&minus;9A&minus;Fa&minus;f]</p>

<p style="margin-left:11%; margin-top: 1em">Also, various
synonyms like &quot;\p{Alpha}&quot; for
&quot;\p{XPosixAlpha}&quot;; all listed in &quot;Properties
accessible through \p{} and \P{}&quot; in perluniprops</p>

<p style="margin-left:11%; margin-top: 1em">Within a
character class:</p>

<p style="margin-left:11%; margin-top: 1em">POSIX
traditional Unicode <br>
[:digit:] \d \p{Digit} <br>
[:^digit:] \D \P{Digit}</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ANCHORS</small></b>
<br>
All are zero-width assertions.</p>

<p style="margin-left:11%; margin-top: 1em">^ Match string
start (or line, if /m is used) <br>
$ Match string end (or line, if /m is used) or before
newline <br>
\b{} Match boundary of type specified within the braces <br>
\B{} Match wherever \b{} doesn't match <br>
\b Match word boundary (between \w and \W) <br>
\B Match except at word boundary (between \w and \w or \W
and \W) <br>
\A Match string start (regardless of /m) <br>
\Z Match string end (before optional newline) <br>
\z Match absolute string end <br>
\G Match where previous m//g left off <br>
\K Keep the stuff left of the \K, don't include it in
$&amp;</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>QUANTIFIERS</small></b>
<br>
Quantifiers are greedy by default and match the
<b>longest</b> leftmost.</p>

<p style="margin-left:11%; margin-top: 1em">Maximal Minimal
Possessive Allowed range <br>
&minus;&minus;&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
{n,m} {n,m}? {n,m}+ Must occur at least n times <br>
but no more than m times <br>
{n,} {n,}? {n,}+ Must occur at least n times <br>
{,n} {,n}? {,n}+ Must occur at most n times <br>
{n} {n}? {n}+ Must occur exactly n times <br>
* *? *+ 0 or more times (same as {0,}) <br>
+ +? ++ 1 or more times (same as {1,}) <br>
? ?? ?+ 0 or 1 time (same as {0,1})</p>

<p style="margin-left:11%; margin-top: 1em">The possessive
forms (new in Perl 5.10) prevent backtracking: what gets
matched by a pattern with a possessive quantifier will not
be backtracked into, even if that causes the whole match to
fail.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>EXTENDED
CONSTRUCTS</small></b> <br>
(?#text) A comment <br>
(?:...) Groups subexpressions without capturing (cluster)
<br>
(?pimsx&minus;imsx:...) Enable/disable option (as per m//
modifiers) <br>
(?=...) Zero&minus;width positive lookahead assertion <br>
(*pla:...) Same, starting in 5.32; experimentally in 5.28
<br>
(*positive_lookahead:...) Same, same versions as *pla <br>
(?!...) Zero&minus;width negative lookahead assertion <br>
(*nla:...) Same, starting in 5.32; experimentally in 5.28
<br>
(*negative_lookahead:...) Same, same versions as *nla <br>
(?&lt;=...) Zero&minus;width positive lookbehind assertion
<br>
(*plb:...) Same, starting in 5.32; experimentally in 5.28
<br>
(*positive_lookbehind:...) Same, same versions as *plb <br>
(?&lt;!...) Zero&minus;width negative lookbehind assertion
<br>
(*nlb:...) Same, starting in 5.32; experimentally in 5.28
<br>
(*negative_lookbehind:...) Same, same versions as *plb <br>
(?&gt;...) Grab what we can, prohibit backtracking <br>
(*atomic:...) Same, starting in 5.32; experimentally in 5.28
<br>
(?|...) Branch reset <br>
(?&lt;name&gt;...) Named capture <br>
(?'name'...) Named capture <br>
(?P&lt;name&gt;...) Named capture (python syntax) <br>
(?[...]) Extended bracketed character class <br>
(?{ code }) Embedded code, return value becomes $^R <br>
(??{ code }) Dynamic regex, return value used as regex <br>
(?N) Recurse into subpattern number N <br>
(?&minus;N), (?+N) Recurse into Nth previous/next subpattern
<br>
(?R), (?0) Recurse at the beginning of the whole pattern
<br>
(?&amp;name) Recurse into a named subpattern <br>
(?P&gt;name) Recurse into a named subpattern (python syntax)
<br>
(?(cond)yes|no) <br>
(?(cond)yes) Conditional expression, where
&quot;(cond)&quot; can be: <br>
(?=pat) lookahead; also (*pla:pat) <br>
(*positive_lookahead:pat) <br>
(?!pat) negative lookahead; also (*nla:pat) <br>
(*negative_lookahead:pat) <br>
(?&lt;=pat) lookbehind; also (*plb:pat) <br>
(*lookbehind:pat) <br>
(?&lt;!pat) negative lookbehind; also (*nlb:pat) <br>
(*negative_lookbehind:pat) <br>
(N) subpattern N has matched something <br>
(&lt;name&gt;) named subpattern has matched something <br>
('name') named subpattern has matched something <br>
(?{code}) code condition <br>
(R) true if recursing <br>
(RN) true if recursing into Nth subpattern <br>
(R&amp;name) true if recursing into named subpattern <br>
(DEFINE) always false, no no&minus;pattern allowed</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>VARIABLES</small></b>
<br>
$_ Default variable for operators to use <br>
$` Everything prior to matched string <br>
$&amp; Entire matched string <br>
$' Everything after to matched string <br>
${^PREMATCH} Everything prior to matched string <br>
${^MATCH} Entire matched string <br>
${^POSTMATCH} Everything after to matched string</p>

<p style="margin-left:11%; margin-top: 1em">Note to those
still using Perl 5.18 or earlier: The use of &quot;$`&quot;,
$&amp; or &quot;$'&quot; will slow down <b>all</b> regex use
within your program. Consult perlvar for
&quot;@&minus;&quot; to see equivalent expressions that
won&rsquo;t cause slow down. See also Devel::SawAmpersand.
Starting with Perl 5.10, you can also use the equivalent
variables &quot;${^PREMATCH}&quot;, &quot;${^MATCH}&quot;
and &quot;${^POSTMATCH}&quot;, but for them to be defined,
you have to specify the &quot;/p&quot; (preserve) modifier
on your regular expression. In Perl 5.20, the use of
&quot;$`&quot;, $&amp; and &quot;$'&quot; makes no speed
difference.</p>

<p style="margin-left:11%; margin-top: 1em">$1, $2 ... hold
the Xth captured expr <br>
$+ Last parenthesized pattern match <br>
$^N Holds the most recently closed capture <br>
$^R Holds the result of the last (?{...}) expr <br>
@&minus; Offsets of starts of groups. $&minus;[0] holds
start of whole match <br>
@+ Offsets of ends of groups. $+[0] holds end of whole match
<br>
%+ Named capture groups <br>
%&minus; Named capture groups, as array refs</p>

<p style="margin-left:11%; margin-top: 1em">Captured groups
are numbered according to their <i>opening</i> paren.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>FUNCTIONS</small></b>
<br>
lc Lowercase a string <br>
lcfirst Lowercase first char of a string <br>
uc Uppercase a string <br>
ucfirst Titlecase first char of a string <br>
fc Foldcase a string <br>
pos Return or set current match position <br>
quotemeta Quote metacharacters <br>
reset Reset m?pattern? status <br>
study Analyze string for optimizing matching <br>
split Use a regex to split a string into parts</p>

<p style="margin-left:11%; margin-top: 1em">The first five
of these are like the escape sequences &quot;\L&quot;,
&quot;\l&quot;, &quot;\U&quot;, &quot;\u&quot;, and
&quot;\F&quot;. For Titlecase, see &quot;Titlecase&quot;;
For Foldcase, see &quot;Foldcase&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>TERMINOLOGY</small></b>
<i><br>
Titlecase</i></p>

<p style="margin-left:11%; margin-top: 1em">Unicode concept
which most often is equal to uppercase, but for certain
characters like the German &quot;sharp s&quot; there is a
difference.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Foldcase</i></p>

<p style="margin-left:11%; margin-top: 1em">Unicode form
that is useful when comparing strings regardless of case, as
certain characters have complex one-to-many case mappings.
Primarily a variant of lowercase.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Iain Truskett.
Updated by the Perl 5 Porters.</p>

<p style="margin-left:11%; margin-top: 1em">This document
may be distributed under the same terms as Perl itself.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">perlretut for a tutorial on
regular expressions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perlrequick for a rapid tutorial.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perlre for more details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perlvar for details on the variables.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perlop for details on the operators.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perlfunc for details on the functions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perlfaq6 for FAQs on regular expressions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perlrebackslash for a reference on backslash
sequences.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perlrecharclass for a reference on character
classes.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The re module to alter behaviour and aid debugging.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>&quot;Debugging Regular Expressions&quot; in
perldebug</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>perluniintro, perlunicode, charnames and perllocale for
details on regexes and internationalisation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><i>Mastering Regular Expressions</i> by Jeffrey Friedl
(&lt;http://oreilly.com/catalog/9780596528126/&gt;) for a
thorough grounding and reference on the topic.</p></td></tr>
</table>

<h2>THANKS
<a name="THANKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">David P.C.
Wollmann, Richard Soderberg, Sean M. Burke, Tom
Christiansen, Jim Cromie, and Jeffrey Goff for useful
advice.</p>
<hr>
</body>
</html>
