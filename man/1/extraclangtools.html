<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:56 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EXTRACLANGTOOLS</title>

</head>
<body>
<h1>extraclangtools</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">extraclangtools
&minus; Extra Clang Tools Documentation</p>

<p style="margin-left:11%; margin-top: 1em">Welcome to the
clang&minus;tools&minus;extra project which contains extra
tools built using Clang's tooling APIs.</p>

<h2>EXTRA CLANG TOOLS 15.0.7 RELEASE NOTES
<a name="EXTRA CLANG TOOLS 15.0.7 RELEASE NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p style="margin-top: 1em"><i>Introduction</i></p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p><i>What's New in Extra Clang Tools 15.0.7?</i></p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%"></td>
<td width="2%"></td>
<td width="34%">


<p style="margin-top: 1em"><i>Major New Features</i></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p><i>Improvements to clangd</i></p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:17%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><i>Inlay hints</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p><i>Diagnostics</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p><i>Semantic Highlighting</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p><i>Hover</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p><i>Code completion</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p><i>Signature help</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p><i>Cross&minus;references</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p><i>Code Actions</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p><i>Miscellaneous</i></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%"></td>
<td width="48%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i>Improvements
to clang&minus;doc</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p style="margin-top: 1em"><i>Improvements to
clang&minus;query</i></p> </td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p><i>Improvements to clang&minus;rename</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p><i>Improvements to clang&minus;tidy</i></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:17%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="40%">


<p style="margin-top: 1em"><i>New checks</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p><i>New check aliases</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p><i>Changes in existing checks</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="40%">


<p><i>Removed checks</i></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="40%"></td>
<td width="40%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i>Improvements
to include&minus;fixer</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="54%">


<p style="margin-top: 1em"><i>Improvements to
clang&minus;include&minus;fixer</i></p> </td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="54%">


<p><i>Improvements to modularize</i></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="54%">


<p><i>Improvements to pp&minus;trace</i></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="54%">


<p><i>Clang&minus;tidy Visual Studio plugin</i></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Written by the
<i>LLVM Team</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>Introduction</b>
<br>
This document contains the release notes for the Extra Clang
Tools, part of the Clang release 15.0.7. Here we describe
the status of the Extra Clang Tools in some detail,
including major improvements from the previous release and
new feature work. All LLVM releases may be downloaded from
the <i>LLVM releases web site</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information about Clang or LLVM, including information about
the latest release, please see the <i>Clang Web Site</i> or
the <i>LLVM Web Site</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that if
you are reading this file from a Git checkout or the main
Clang web page, this document applies to the <i>next</i>
release, not the current one. To see the release notes for a
specific release, please see the <i>releases page</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What's New
in Extra Clang Tools 15.0.7?</b> <br>
Some of the major new features and improvements to Extra
Clang Tools are listed here. Generic improvements to Extra
Clang Tools as a whole or to its underlying infrastructure
are described first, followed by tool&minus;specific
sections.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Major New
Features</b> <br>
...</p>


<p style="margin-left:11%; margin-top: 1em"><b>Improvements
to clangd <br>
Inlay hints</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em"><b>Provide hints for:</b></p></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:25%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%"></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em">Lambda return types.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="72%">


<p>Forwarding functions using the underlying function
call.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Support for
standard LSP 3.17 inlay hints protocol.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em">Designator inlay hints are
enabled by default.</p></td>
<td width="15%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Diagnostics</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Improved Fix&minus;its of some
clang&minus;tidy checks when applied with clangd.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Clangd now produces diagnostics for forwarding functions
like make_unique.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Include cleaner analysis can be disabled with the
<b>Diagnostics.Includes.IgnoreHeader</b> config option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Include cleaner doesn&acirc;t diagnose exporting
headers.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>clang&minus;tidy and include cleaner diagnostics have
links to their documentation.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Semantic
Highlighting</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Semantic highlighting works for
tokens that span multiple lines.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Mutable reference parameters in function calls receive
<b>usedAsMutableReference</b> modifier.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Hover</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em">Hover displays desugared types
by default now.</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Code
completion</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="81%">


<p style="margin-top: 1em">Improved ranking/filtering for
ObjC method selectors.</p></td>
<td width="5%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="81%">


<p>Support for C++20 concepts and requires expressions.</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Signature
help</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Signature help for function
pointers.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Provides hints using underlying functions in forwarded
calls.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Cross&minus;references
<br>
Code Actions</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">New code action to generate ObjC
initializers.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>New code action to generate move/copy
constructors/assignments.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Extract to function works for methods in addition to
free functions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Related diagnostics are attached to code actions
response, if any.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Extract variable works in C and ObjC files.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fix to define outline when the parameter has a braced
initializer.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Miscellaneous</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Include fixer supports symbols
inside macro arguments.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Dependent autos are now deduced when there&acirc;s a
single instantiation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Support for symbols exported with using declarations in
all features.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed background&minus;indexing priority for M1
chips.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Indexing for standard library symbols.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>ObjC framework includes are spelled properly during
include insertion operations.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Improvements
to clang&minus;doc</b> <br>
The improvements are...</p>


<p style="margin-left:11%; margin-top: 1em"><b>Improvements
to clang&minus;query</b> <br>
The improvements are...</p>


<p style="margin-left:11%; margin-top: 1em"><b>Improvements
to clang&minus;rename</b> <br>
The improvements are...</p>


<p style="margin-left:11%; margin-top: 1em"><b>Improvements
to clang&minus;tidy</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Added trace code to help narrow
down any checks and the relevant source code that result in
crashes.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Clang&minus;tidy now consideres newlines as separators
of single elements in the <i>Checks</i> section in
<i>.clang&minus;tidy</i> configuration files. Where
previously a comma had to be used to distinguish elements in
this list from each other, newline characters now also work
as separators in the parsed YAML. That means it is advised
to use YAML's block style initiated by the pipe character
<i>|</i> for the <i>Checks</i> section in order to benefit
from the easier syntax that works without commas.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed a regression introduced in clang&minus;tidy
14.0.0, which prevented NOLINTs from suppressing diagnostics
associated with macro arguments. This fixes <i>Issue
55134</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Added an option &minus;verify&minus;config which will
check the config file to ensure each <i>Checks</i> and
<i>CheckOptions</i> entries are recognised.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>.clang&minus;tidy files can now use the more natural
dictionary syntax for specifying <i>CheckOptions</i>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>New
checks</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em">New
<i>bugprone&minus;shared&minus;ptr&minus;array&minus;mismatch</i>
check.</p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Finds
initializations of C++ shared pointers to non&minus;array
type that are initialized with an array.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em">New
<i>bugprone&minus;unchecked&minus;optional&minus;access</i>
check.</p> </td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Warns when the
code is unwrapping a <i>std::optional&lt;T&gt;</i>,
<i>absl::optional&lt;T&gt;</i>, or
<i>base::Optional&lt;T&gt;</i> object without assuring that
it contains a value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em">New
<i>misc&minus;confusable&minus;identifiers</i> check.</p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Detects
confusable Unicode identifiers.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em">New
<i>bugprone&minus;assignment&minus;in&minus;if&minus;condition</i>
check.</p> </td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Warns when
there is an assignment within an if statement condition
expression.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="51%">


<p style="margin-top: 1em">New
<i>misc&minus;const&minus;correctness</i> check.</p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Detects
unmodified local variables and suggest adding <b>const</b>
if the transformation is possible.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="52%">


<p style="margin-top: 1em">New
<i>modernize&minus;macro&minus;to&minus;enum</i> check.</p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Replaces groups
of adjacent macros with an unscoped anonymous enum.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="64%">


<p style="margin-top: 1em">New
<i>portability&minus;std&minus;allocator&minus;const</i>
check.</p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Report use of
<b>std::vector&lt;const T&gt;</b> (and similar containers of
const elements). These are not allowed in standard C++ due
to undefined <b>std::allocator&lt;const T&gt;</b>. They do
not compile with libstdc++ or MSVC. Future libc++ will
remove the extension (<i>D120996
&lt;https://reviews.llvm.org/D120996&gt;</i>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>New check
aliases</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">New alias
<i>cppcoreguidelines&minus;macro&minus;to&minus;enum</i> to
<i>modernize&minus;macro&minus;to&minus;enum</i> was
added.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Changes in
existing checks</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Fixed nonsensical suggestion of
<i>altera&minus;struct&minus;pack&minus;align</i> check for
empty structs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed a false positive in
<i>bugprone&minus;branch&minus;clone</i> when the branches
involve unknown expressions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed some false positives in
<i>bugprone&minus;infinite&minus;loop</i> involving
dependent expressions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed a crash in
<i>bugprone&minus;sizeof&minus;expression</i> when
<i>sizeof(...)</i> is compared against a
<i>__int128_t</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed bugs in
<i>bugprone&minus;use&minus;after&minus;move</i>:</p> </td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Treat a move in a lambda capture
as happening in the function that defines the lambda, not
within the body of the lambda (as we were previously doing
erroneously).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>Don't emit an erroneous warning on self&minus;moves.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Improved
<i>cert&minus;dcl58&minus;cpp</i> check.</p>

<p style="margin-left:14%; margin-top: 1em">The check now
detects explicit template specializations that are handled
specially.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Made
<i>cert&minus;oop57&minus;cpp</i> more sensitive by checking
for an arbitrary expression in the second argument of
<b>memset</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Made the fix&minus;it of
<i>cppcoreguidelines&minus;init&minus;variables</i> use
<b>false</b> to initialize boolean variables.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Improved
<i>cppcoreguidelines&minus;prefer&minus;member&minus;initializer</i>
check.</p> </td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Fixed an issue
when there was already an initializer in the constructor and
the check would try to create another initializer for the
same member.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Fixed a false positive in
<i>cppcoreguidelines&minus;virtual&minus;class&minus;destructor</i>
involving <b>final</b> classes. The check will not diagnose
classes marked <b>final</b>, since those cannot be used as
base classes, consequently, they can not violate the
rule.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed a crash in
<i>llvmlibc&minus;callee&minus;namespace</i> when executing
for C++ code that contain calls to advanced constructs, e.g.
overloaded operators.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed false positives in
<i>misc&minus;redundant&minus;expression</i>:</p> </td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Fixed a false positive involving
overloaded comparison operators.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>Fixed a false positive involving assignments in
conditions. This fixes <i>Issue 35853</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Fixed a false
positive in <i>misc&minus;unused&minus;parameters</i> where
invalid parameters were implicitly being treated as being
unused. This fixes <i>Issue 56152</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Fixed false positives in
<i>misc&minus;unused&minus;using&minus;decls</i> where
<i>using</i> statements bringing operators into the scope
where incorrectly marked as unused. This fixes <i>issue
55095</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed a false positive in
<i>modernize&minus;deprecated&minus;headers</i> involving
including C header files from C++ files wrapped by <b>extern
&quot;C&quot; { ... }</b> blocks. Such includes will be
ignored by now. By default now it doesn't warn for including
deprecated headers from header files, since that header file
might be used from C source files. By passing the
<b>CheckHeaderFile=true</b> option if header files of the
project only included by C++ source files.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Improved
<i>performance&minus;inefficient&minus;vector&minus;operation</i>
to work when the vector is a member of a structure.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed a crash in
<i>performance&minus;unnecessary&minus;value&minus;param</i>
when the specialization template has an unnecessary value
parameter. Removed the fix for a template.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed a crash in
<i>readability&minus;const&minus;return&minus;type</i> when
a pure virtual function overrided has a const return type.
Removed the fix for a virtual function.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Skipped addition of extra parentheses around member
accesses (<b>a.b</b>) in fix&minus;it for
<i>readability&minus;container&minus;data&minus;pointer</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed incorrect suggestions for
<i>readability&minus;container&minus;size&minus;empty</i>
when smart pointers are involved.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Fixed a false positive in
<i>readability&minus;non&minus;const&minus;parameter</i>
when the parameter is referenced by an lvalue.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Expanded
<i>readability&minus;simplify&minus;boolean&minus;expr</i>
to simplify expressions using DeMorgan's Theorem.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Removed
checks <br>
Improvements to include&minus;fixer</b> <br>
The improvements are...</p>


<p style="margin-left:11%; margin-top: 1em"><b>Improvements
to clang&minus;include&minus;fixer</b> <br>
The improvements are...</p>


<p style="margin-left:11%; margin-top: 1em"><b>Improvements
to modularize</b> <br>
The improvements are...</p>


<p style="margin-left:11%; margin-top: 1em"><b>Improvements
to pp&minus;trace</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Added <i>HashLoc</i> information
to <i>InclusionDirective</i> callback output.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Clang&minus;tidy
Visual Studio plugin</b></p>

<h2>CLANG-TIDY
<a name="CLANG-TIDY"></a>
</h2>


<p style="margin-left:11%;"><b>Contents</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p style="margin-top: 1em"><i>Clang&minus;Tidy</i></p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%"></td>
<td width="2%"></td>
<td width="51%">


<p style="margin-top: 1em"><i>Using
clang&minus;tidy</i></p> </td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="51%">


<p><i>Suppressing Undesired Diagnostics</i></p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">See also:</p>


<p style="margin-left:11%; margin-top: 1em"><b>Clang&minus;Tidy
Checks <br>
abseil&minus;cleanup&minus;ctad</b> <br>
Suggests switching the initialization pattern of
<b>absl::Cleanup</b> instances from the factory function to
class template argument deduction (CTAD), in C++17 and
higher.</p>
<pre style="margin-left:15%; margin-top: 1em">auto c1 = absl::MakeCleanup([] {});


const auto c2 = absl::MakeCleanup(std::function&lt;void()&gt;([] {}));</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>
<pre style="margin-left:15%; margin-top: 1em">absl::Cleanup c1 = [] {};


const absl::Cleanup c2 = std::function&lt;void()&gt;([] {});</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;duration&minus;addition</b>
<br>
Check for cases where addition should be performed in the
<b>absl::Time</b> domain. When adding two values, and one is
known to be an <b>absl::Time</b>, we can infer that the
other should be interpreted as an <b>absl::Duration</b> of a
similar scale, and make that inference explicit.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Addition in the integer domain
int x;
absl::Time t;
int result = absl::ToUnixSeconds(t) + x;


// Suggestion &minus; Addition in the absl::Time domain
int result = absl::ToUnixSeconds(t + absl::Seconds(x));</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;duration&minus;comparison</b>
<br>
Checks for comparisons which should be in the
<b>absl::Duration</b> domain instead of the floating point
or integer domains.</p>

<p style="margin-left:11%; margin-top: 1em">N.B.: In cases
where a <b>Duration</b> was being converted to an integer
and then compared against a floating&minus;point value,
truncation during the <b>Duration</b> conversion might yield
a different result. In practice this is very rare, and still
indicates a bug which should be fixed.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Comparison in the floating point domain
double x;
absl::Duration d;
if (x &lt; absl::ToDoubleSeconds(d)) ...

// Suggested &minus; Compare in the absl::Duration domain instead
if (absl::Seconds(x) &lt; d) ...


// Original &minus; Comparison in the integer domain
int x;
absl::Duration d;
if (x &lt; absl::ToInt64Microseconds(d)) ...


// Suggested &minus; Compare in the absl::Duration domain instead
if (absl::Microseconds(x) &lt; d) ...</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;duration&minus;conversion&minus;cast</b>
<br>
Checks for casts of <b>absl::Duration</b> conversion
functions, and recommends the right conversion function
instead.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Cast from a double to an integer
absl::Duration d;
int i = static_cast&lt;int&gt;(absl::ToDoubleSeconds(d));

// Suggested &minus; Use the integer conversion function directly.
int i = absl::ToInt64Seconds(d);


// Original &minus; Cast from a double to an integer
absl::Duration d;
double x = static_cast&lt;double&gt;(absl::ToInt64Seconds(d));


// Suggested &minus; Use the integer conversion function directly.
double x = absl::ToDoubleSeconds(d);</pre>


<p style="margin-left:11%; margin-top: 1em">Note: In the
second example, the suggested fix could yield a different
result, as the conversion to integer could truncate. In
practice, this is very rare, and you should use
<b>absl::Trunc</b> to perform this operation explicitly
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;duration&minus;division
<br>
absl::Duration</b> arithmetic works like it does with
integers. That means that division of two
<b>absl::Duration</b> objects returns an <b>int64</b> with
any fractional component truncated toward 0. See <i>this
link</i> for more information on arithmetic with
<b>absl::Duration</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>
<pre style="margin-left:15%; margin-top: 1em">absl::Duration d = absl::Seconds(3.5);
int64 sec1 = d / absl::Seconds(1);     // Truncates toward 0.
int64 sec2 = absl::ToInt64Seconds(d);  // Equivalent to division.
assert(sec1 == 3 &amp;&amp; sec2 == 3);


double dsec = d / absl::Seconds(1);  // WRONG: Still truncates toward 0.
assert(dsec == 3.0);</pre>


<p style="margin-left:11%; margin-top: 1em">If you want
floating&minus;point division, you should use either the
<b>absl::FDivDuration()</b> function, or one of the unit
conversion functions such as <b>absl::ToDoubleSeconds()</b>.
For example:</p>

<pre style="margin-left:15%; margin-top: 1em">absl::Duration d = absl::Seconds(3.5);
double dsec1 = absl::FDivDuration(d, absl::Seconds(1));  // GOOD: No truncation.
double dsec2 = absl::ToDoubleSeconds(d);                 // GOOD: No truncation.
assert(dsec1 == 3.5 &amp;&amp; dsec2 == 3.5);</pre>


<p style="margin-left:11%; margin-top: 1em">This check
looks for uses of <b>absl::Duration</b> division that is
done in a floating&minus;point context, and recommends the
use of a function that returns a floating&minus;point
value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;duration&minus;factory&minus;float</b>
<br>
Checks for cases where the floating&minus;point overloads of
various <b>absl::Duration</b> factory functions are called
when the more&minus;efficient integer versions could be used
instead.</p>

<p style="margin-left:11%; margin-top: 1em">This check will
not suggest fixes for literals which contain fractional
floating point values or non&minus;literals. It will suggest
removing superfluous casts.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Providing a floating&minus;point literal.
absl::Duration d = absl::Seconds(10.0);

// Suggested &minus; Use an integer instead.
absl::Duration d = absl::Seconds(10);


// Original &minus; Explicitly casting to a floating&minus;point type.
absl::Duration d = absl::Seconds(static_cast&lt;double&gt;(10));


// Suggested &minus; Remove the explicit cast
absl::Duration d = absl::Seconds(10);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;duration&minus;factory&minus;scale</b>
<br>
Checks for cases where arguments to <b>absl::Duration</b>
factory functions are scaled internally and could be changed
to a different factory function. This check also looks for
arguments with a zero value and suggests using
<b>absl::ZeroDuration()</b> instead.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Internal multiplication.
int x;
absl::Duration d = absl::Seconds(60 * x);

// Suggested &minus; Use absl::Minutes instead.
absl::Duration d = absl::Minutes(x);


// Original &minus; Internal division.
int y;
absl::Duration d = absl::Milliseconds(y / 1000.);

// Suggested &minus; Use absl:::Seconds instead.
absl::Duration d = absl::Seconds(y);


// Original &minus; Zero&minus;value argument.
absl::Duration d = absl::Hours(0);


// Suggested = Use absl::ZeroDuration instead
absl::Duration d = absl::ZeroDuration();</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;duration&minus;subtraction</b>
<br>
Checks for cases where subtraction should be performed in
the <b>absl::Duration</b> domain. When subtracting two
values, and the first one is known to be a conversion from
<b>absl::Duration</b>, we can infer that the second should
also be interpreted as an <b>absl::Duration</b>, and make
that inference explicit.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Subtraction in the double domain
double x;
absl::Duration d;
double result = absl::ToDoubleSeconds(d) &minus; x;

// Suggestion &minus; Subtraction in the absl::Duration domain instead
double result = absl::ToDoubleSeconds(d &minus; absl::Seconds(x));

// Original &minus; Subtraction of two Durations in the double domain
absl::Duration d1, d2;
double result = absl::ToDoubleSeconds(d1) &minus; absl::ToDoubleSeconds(d2);


// Suggestion &minus; Subtraction in the absl::Duration domain instead
double result = absl::ToDoubleSeconds(d1 &minus; d2);</pre>


<p style="margin-left:11%; margin-top: 1em">Note: As with
other <b>clang&minus;tidy</b> checks, it is possible that
multiple fixes may overlap (as in the case of nested
expressions), so not all occurrences can be transformed in
one run. In particular, this may occur for nested
subtraction expressions. Running <b>clang&minus;tidy</b>
multiple times will find and fix these overlaps.</p>


<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;duration&minus;unnecessary&minus;conversion</b>
<br>
Finds and fixes cases where <b>absl::Duration</b> values are
being converted to numeric types and back again.</p>


<p style="margin-left:11%; margin-top: 1em">Floating&minus;point
examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Conversion to double and back again
absl::Duration d1;
absl::Duration d2 = absl::Seconds(absl::ToDoubleSeconds(d1));

// Suggestion &minus; Remove unnecessary conversions
absl::Duration d2 = d1;

// Original &minus; Division to convert to double and back again
absl::Duration d2 = absl::Seconds(absl::FDivDuration(d1, absl::Seconds(1)));


// Suggestion &minus; Remove division and conversion
absl::Duration d2 = d1;</pre>


<p style="margin-left:11%; margin-top: 1em">Integer
examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Conversion to integer and back again
absl::Duration d1;
absl::Duration d2 = absl::Hours(absl::ToInt64Hours(d1));

// Suggestion &minus; Remove unnecessary conversions
absl::Duration d2 = d1;

// Original &minus; Integer division followed by conversion
absl::Duration d2 = absl::Seconds(d1 / absl::Seconds(1));


// Suggestion &minus; Remove division and conversion
absl::Duration d2 = d1;</pre>


<p style="margin-left:11%; margin-top: 1em">Unwrapping
scalar operations:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Multiplication by a scalar
absl::Duration d1;
absl::Duration d2 = absl::Seconds(absl::ToInt64Seconds(d1) * 2);


// Suggestion &minus; Remove unnecessary conversion
absl::Duration d2 = d1 * 2;</pre>


<p style="margin-left:11%; margin-top: 1em">Note:
Converting to an integer and back to an
<b>absl::Duration</b> might be a truncating operation if the
value is not aligned to the scale of conversion. In the rare
case where this is the intended result, callers should use
<b>absl::Trunc</b> to truncate explicitly.</p>


<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;faster&minus;strsplit&minus;delimiter</b>
<br>
Finds instances of <b>absl::StrSplit()</b> or
<b>absl::MaxSplits()</b> where the delimiter is a single
character string literal and replaces with a character. The
check will offer a suggestion to change the string literal
into a character. It will also catch code using
<b>absl::ByAnyChar()</b> for just a single character and
will transform that into a single character as well.</p>

<p style="margin-left:11%; margin-top: 1em">These changes
will give the same result, but using characters rather than
single character string literals is more efficient and
readable.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; the argument is a string literal.
for (auto piece : absl::StrSplit(str, &quot;B&quot;)) {

// Suggested &minus; the argument is a character, which causes the more efficient
// overload of absl::StrSplit() to be used.
for (auto piece : absl::StrSplit(str, 'B')) {


// Original &minus; the argument is a string literal inside absl::ByAnyChar call.
for (auto piece : absl::StrSplit(str, absl::ByAnyChar(&quot;B&quot;))) {

// Suggested &minus; the argument is a character, which causes the more efficient
// overload of absl::StrSplit() to be used and we do not need absl::ByAnyChar
// anymore.
for (auto piece : absl::StrSplit(str, 'B')) {


// Original &minus; the argument is a string literal inside absl::MaxSplits call.
for (auto piece : absl::StrSplit(str, absl::MaxSplits(&quot;B&quot;, 1))) {


// Suggested &minus; the argument is a character, which causes the more efficient
// overload of absl::StrSplit() to be used.
for (auto piece : absl::StrSplit(str, absl::MaxSplits('B', 1))) {</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;no&minus;internal&minus;dependencies</b>
<br>
Warns if code using Abseil depends on internal details. If
something is in a namespace that includes the word
&quot;internal&quot;, code is not allowed to depend upon it
because it's an implementation detail. They cannot friend
it, include it, you mention it or refer to it in any way.
Doing so violates Abseil's compatibility guidelines and may
result in breakage. See
<i>https://abseil.io/about/compatibility</i> for more
information.</p>

<p style="margin-left:11%; margin-top: 1em">The following
cases will result in warnings:</p>

<pre style="margin-left:15%; margin-top: 1em">absl::strings_internal::foo();
// warning triggered on this line
class foo {
  friend struct absl::container_internal::faa;
  // warning triggered on this line
};
absl::memory_internal::MakeUniqueResult();
// warning triggered on this line</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;no&minus;namespace</b>
<br>
Ensures code does not open <b>namespace absl</b> as that
violates Abseil's compatibility guidelines. Code should not
open <b>namespace absl</b> as that conflicts with Abseil's
compatibility guidelines and may result in breakage.</p>

<p style="margin-left:11%; margin-top: 1em">Any code that
uses:</p>

<pre style="margin-left:15%; margin-top: 1em">namespace absl {
 ...
}</pre>


<p style="margin-left:11%; margin-top: 1em">will be
prompted with a warning.</p>

<p style="margin-left:11%; margin-top: 1em">See <i>the full
Abseil compatibility guidelines</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;redundant&minus;strcat&minus;calls</b>
<br>
Suggests removal of unnecessary calls to <b>absl::StrCat</b>
when the result is being passed to another call to
<b>absl::StrCat</b> or <b>absl::StrAppend</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The extra calls
cause unnecessary temporary strings to be constructed.
Removing them makes the code smaller and faster.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">std::string s = absl::StrCat(&quot;A&quot;, absl::StrCat(&quot;B&quot;, absl::StrCat(&quot;C&quot;, &quot;D&quot;)));
//before

std::string s = absl::StrCat(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);
//after

absl::StrAppend(&amp;s, absl::StrCat(&quot;E&quot;, &quot;F&quot;, &quot;G&quot;));
//before


absl::StrAppend(&amp;s, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;);
//after</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;str&minus;cat&minus;append</b>
<br>
Flags uses of <b>absl::StrCat()</b> to append to a
<b>std::string</b>. Suggests <b>absl::StrAppend()</b> should
be used instead.</p>

<p style="margin-left:11%; margin-top: 1em">The extra calls
cause unnecessary temporary strings to be constructed.
Removing them makes the code smaller and faster.</p>

<pre style="margin-left:15%; margin-top: 1em">a = absl::StrCat(a, b); // Use absl::StrAppend(&amp;a, b) instead.</pre>


<p style="margin-left:11%; margin-top: 1em">Does not
diagnose cases where <b>absl::StrCat()</b> is used as a
template argument for a functor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;string&minus;find&minus;startswith</b>
<br>
Checks whether a <b>std::string::find()</b> or
<b>std::string::rfind()</b> result is compared with 0, and
suggests replacing with <b>absl::StartsWith()</b>. This is
both a readability and performance issue.</p>

<pre style="margin-left:15%; margin-top: 1em">string s = &quot;...&quot;;
if (s.find(&quot;Hello World&quot;) == 0) { /* do something */ }
if (s.rfind(&quot;Hello World&quot;, 0) == 0) { /* do something */ }</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>

<pre style="margin-left:15%; margin-top: 1em">string s = &quot;...&quot;;
if (absl::StartsWith(s, &quot;Hello World&quot;)) { /* do something */ }
if (absl::StartsWith(s, &quot;Hello World&quot;)) { /* do something */ }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
StringLikeClasses</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of names of string&minus;like classes. By default only
<b>std::basic_string</b> is considered. The list of methods
to considered is fixed.</p>

<p style="margin-left:11%;"><b>IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>


<p style="margin-left:11%;"><b>AbseilStringsMatchHeader</b></p>

<p style="margin-left:22%;">The location of Abseil's
<b>strings/match.h</b>. Defaults to
<b>absl/strings/match.h</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;string&minus;find&minus;str&minus;contains</b>
<br>
Finds <b>s.find(...) == string::npos</b> comparisons (for
various string&minus;like types) and suggests replacing with
<b>absl::StrContains()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This improves
readability and reduces the likelihood of accidentally
mixing <b>find()</b> and <b>npos</b> from different
string&minus;like types.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
&quot;string&minus;like types&quot; includes
<b>::std::basic_string</b>, <b>::std::basic_string_view</b>,
and <b>::absl::string_view</b>. See the StringLikeClasses
option to change this.</p>
<pre style="margin-left:15%; margin-top: 1em">std::string s = &quot;...&quot;;
if (s.find(&quot;Hello World&quot;) == std::string::npos) { /* do something */ }


absl::string_view a = &quot;...&quot;;
if (absl::string_view::npos != a.find(&quot;Hello World&quot;)) { /* do something */ }</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>
<pre style="margin-left:15%; margin-top: 1em">std::string s = &quot;...&quot;;
if (!absl::StrContains(s, &quot;Hello World&quot;)) { /* do something */ }


absl::string_view a = &quot;...&quot;;
if (absl::StrContains(a, &quot;Hello World&quot;)) { /* do something */ }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
StringLikeClasses</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of names of string&minus;like classes. By default includes
<b>::std::basic_string</b>, <b>::std::basic_string_view</b>,
and <b>::absl::string_view</b>.</p>

<p style="margin-left:11%;"><b>IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>


<p style="margin-left:11%;"><b>AbseilStringsMatchHeader</b></p>

<p style="margin-left:22%;">The location of Abseil's
<b>strings/match.h</b>. Defaults to
<b>absl/strings/match.h</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;time&minus;comparison</b>
<br>
Prefer comparisons in the <b>absl::Time</b> domain instead
of the integer domain.</p>

<p style="margin-left:11%; margin-top: 1em">N.B.: In cases
where an <b>absl::Time</b> is being converted to an integer,
alignment may occur. If the comparison depends on this
alignment, doing the comparison in the <b>absl::Time</b>
domain may yield a different result. In practice this is
very rare, and still indicates a bug which should be
fixed.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Original &minus; Comparison in the integer domain
int x;
absl::Time t;
if (x &lt; absl::ToUnixSeconds(t)) ...


// Suggested &minus; Compare in the absl::Time domain instead
if (absl::FromUnixSeconds(x) &lt; t) ...</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;time&minus;subtraction</b>
<br>
Finds and fixes <b>absl::Time</b> subtraction expressions to
do subtraction in the Time domain instead of the numeric
domain.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
cases of Time subtraction in which deduce additional type
information:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>When the result is an <b>absl::Duration</b> and the
first argument is an <b>absl::Time</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>When the second argument is a <b>absl::Time</b>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In the first
case, we must know the result of the operation, since
without that the second operand could be either an
<b>absl::Time</b> or an <b>absl::Duration</b>. In the second
case, the first operand <i>must</i> be an <b>absl::Time</b>,
because subtracting an <b>absl::Time</b> from an
<b>absl::Duration</b> is not defined.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">int x;
absl::Time t;

// Original &minus; absl::Duration result and first operand is an absl::Time.
absl::Duration d = absl::Seconds(absl::ToUnixSeconds(t) &minus; x);

// Suggestion &minus; Perform subtraction in the Time domain instead.
absl::Duration d = t &minus; absl::FromUnixSeconds(x);


// Original &minus; Second operand is an absl::Time.
int i = x &minus; absl::ToUnixSeconds(t);


// Suggestion &minus; Perform subtraction in the Time domain instead.
int i = absl::ToInt64Seconds(absl::FromUnixSeconds(x) &minus; t);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>abseil&minus;upgrade&minus;duration&minus;conversions</b>
<br>
Finds calls to <b>absl::Duration</b> arithmetic operators
and factories whose argument needs an explicit cast to
continue compiling after upcoming API changes.</p>

<p style="margin-left:11%; margin-top: 1em">The operators
<b>*=</b>, <b>/=</b>, <b>*</b>, and <b>/</b> for
<b>absl::Duration</b> currently accept an argument of class
type that is convertible to an arithmetic type. Such a call
currently converts the value to an <b>int64_t</b>, even in a
case such as <b>std::atomic&lt;float&gt;</b> that would
result in lossy conversion.</p>

<p style="margin-left:11%; margin-top: 1em">Additionally,
the <b>absl::Duration</b> factory functions
(<b>absl::Hours</b>, <b>absl::Minutes</b>, etc) currently
accept an <b>int64_t</b> or a floating&minus;point type.
Similar to the arithmetic operators, calls with an argument
of class type that is convertible to an arithmetic type go
through the <b>int64_t</b> path.</p>

<p style="margin-left:11%; margin-top: 1em">These operators
and factories will be changed to only accept arithmetic
types to prevent unintended behavior. After these changes
are released, passing an argument of class type will no
longer compile, even if the type is implicitly convertible
to an arithmetic type.</p>

<p style="margin-left:11%; margin-top: 1em">Here are
example fixes created by this check:</p>

<pre style="margin-left:15%; margin-top: 1em">std::atomic&lt;int&gt; a;
absl::Duration d = absl::Milliseconds(a);
d *= a;</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>

<pre style="margin-left:15%; margin-top: 1em">std::atomic&lt;int&gt; a;
absl::Duration d = absl::Milliseconds(static_cast&lt;int64_t&gt;(a));
d *= static_cast&lt;int64_t&gt;(a);</pre>


<p style="margin-left:11%; margin-top: 1em">Note that this
check always adds a cast to <b>int64_t</b> in order to
preserve the current behavior of user code. It is possible
that this uncovers unintended behavior due to types
implicitly convertible to a floating&minus;point type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>altera&minus;id&minus;dependent&minus;backward&minus;branch</b>
<br>
Finds ID&minus;dependent variables and fields that are used
within loops. This causes branches to occur inside the
loops, and thus leads to performance degradation.</p>
<pre style="margin-left:15%; margin-top: 1em">// The following code will produce a warning because this ID&minus;dependent
// variable is used in a loop condition statement.
int ThreadID = get_local_id(0);

// The following loop will produce a warning because the loop condition
// statement depends on an ID&minus;dependent variable.
for (int i = 0; i &lt; ThreadID; ++i) {
  std::cout &lt;&lt; i &lt;&lt; std::endl;
}


// The following loop will not produce a warning, because the ID&minus;dependent
// variable is not used in the loop condition statement.
for (int i = 0; i &lt; 100; ++i) {
  std::cout &lt;&lt; ThreadID &lt;&lt; std::endl;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Based on the
<i>Altera SDK for OpenCL: Best Practices Guide</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>altera&minus;kernel&minus;name&minus;restriction</b>
<br>
Finds kernel files and include directives whose filename is
<i>kernel.cl</i>, <i>Verilog.cl</i>, or <i>VHDL.cl</i>. The
check is case insensitive.</p>

<p style="margin-left:11%; margin-top: 1em">Such kernel
file names cause the offline compiler to generate
intermediate design files that have the same names as
certain internal files, which leads to a compilation
error.</p>

<p style="margin-left:11%; margin-top: 1em">Based on the
<i>Guidelines for Naming the Kernel</i> section in the
<i>Intel FPGA SDK for OpenCL Pro Edition: Programming
Guide</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>altera&minus;single&minus;work&minus;item&minus;barrier</b>
<br>
Finds OpenCL kernel functions that call a barrier function
but do not call an ID function (<b>get_local_id</b>,
<b>get_local_id</b>, <b>get_group_id</b>, or
<b>get_local_linear_id</b>).</p>

<p style="margin-left:11%; margin-top: 1em">These kernels
may be viable single work&minus;item kernels, but will be
forced to execute as NDRange kernels if using a newer
version of the Altera Offline Compiler (&gt;= v17.01).</p>

<p style="margin-left:11%; margin-top: 1em">If using an
older version of the Altera Offline Compiler, these kernel
functions will be treated as single work&minus;item kernels,
which could be inefficient or lead to errors if NDRange
semantics were intended.</p>

<p style="margin-left:11%; margin-top: 1em">Based on the
<i>Altera SDK for OpenCL: Best Practices Guide</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// error: function calls barrier but does not call an ID function.
void __kernel barrier_no_id(__global int * foo, int size) {
  for (int i = 0; i &lt; 100; i++) {
    foo[i] += 5;
  }
  barrier(CLK_GLOBAL_MEM_FENCE);
}

// ok: function calls barrier and an ID function.
void __kernel barrier_with_id(__global int * foo, int size) {
  for (int i = 0; i &lt; 100; i++) {
    int tid = get_global_id(0);
    foo[tid] += 5;
  }
  barrier(CLK_GLOBAL_MEM_FENCE);
}


// ok with AOC Version 17.01: the reqd_work_group_size turns this into
// an NDRange.
__attribute__((reqd_work_group_size(2,2,2)))
void __kernel barrier_with_id(__global int * foo, int size) {
  for (int i = 0; i &lt; 100; i++) {
    foo[tid] += 5;
  }
  barrier(CLK_GLOBAL_MEM_FENCE);
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
AOCVersion</b></p>

<p style="margin-left:22%;">Defines the version of the
Altera Offline Compiler. Defaults to <b>1600</b>
(corresponding to version 16.00).</p>


<p style="margin-left:11%; margin-top: 1em"><b>altera&minus;struct&minus;pack&minus;align</b>
<br>
Finds structs that are inefficiently packed or aligned, and
recommends packing and/or aligning of said structs as
needed.</p>

<p style="margin-left:11%; margin-top: 1em">Structs that
are not packed take up more space than they should, and
accessing structs that are not well aligned is
inefficient.</p>

<p style="margin-left:11%; margin-top: 1em">Fix&minus;its
are provided to fix both of these issues by inserting and/or
amending relevant struct attributes.</p>

<p style="margin-left:11%; margin-top: 1em">Based on the
<i>Altera SDK for OpenCL: Best Practices Guide</i>.</p>
<pre style="margin-left:15%; margin-top: 1em">// The following struct is originally aligned to 4 bytes, and thus takes up
// 12 bytes of memory instead of 10. Packing the struct will make it use
// only 10 bytes of memory, and aligning it to 16 bytes will make it
// efficient to access.
struct example {
  char a;    // 1 byte
  double b;  // 8 bytes
  char c;    // 1 byte
};

// The following struct is arranged in such a way that packing is not needed.
// However, it is aligned to 4 bytes instead of 8, and thus needs to be
// explicitly aligned.
struct implicitly_packed_example {
  char a;  // 1 byte
  char b;  // 1 byte
  char c;  // 1 byte
  char d;  // 1 byte
  int e;   // 4 bytes
};

// The following struct is explicitly aligned and packed.
struct good_example {
  char a;    // 1 byte
  double b;  // 8 bytes
  char c;    // 1 byte
} __attribute__((packed)) __attribute__((aligned(16));


// Explicitly aligning a struct to the wrong value will result in a warning.
// The following example should be aligned to 16 bytes, not 32.
struct badly_aligned_example {
  char a;    // 1 byte
  double b;  // 8 bytes
  char c;    // 1 byte
} __attribute__((packed)) __attribute__((aligned(32)));</pre>



<p style="margin-left:11%; margin-top: 1em"><b>altera&minus;unroll&minus;loops</b>
<br>
Finds inner loops that have not been unrolled, as well as
fully unrolled loops with unknown loop bounds or a large
number of iterations.</p>

<p style="margin-left:11%; margin-top: 1em">Unrolling inner
loops could improve the performance of OpenCL kernels.
However, if they have unknown loop bounds or a large number
of iterations, they cannot be fully unrolled, and should be
partially unrolled.</p>

<p style="margin-left:11%; margin-top: 1em">Notes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>This check is unable to determine the number of
iterations in a <b>while</b> or <b>do..while</b> loop; hence
if such a loop is fully unrolled, a note is emitted advising
the user to partially unroll instead.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>In <b>for</b> loops, our check only works with simple
arithmetic increments ( <b>+</b>, <b>&minus;</b>, <b>*</b>,
<b>/</b>). For all other increments, partial unrolling is
advised.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Depending on the exit condition, the calculations for
determining if the number of iterations is large may be off
by 1. This should not be an issue since the cut&minus;off is
generally arbitrary.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Based on the
<i>Altera SDK for OpenCL: Best Practices Guide</i>.</p>
<pre style="margin-left:15%; margin-top: 1em">for (int i = 0; i &lt; 10; i++) {  // ok: outer loops should not be unrolled
   int j = 0;
   do {  // warning: this inner do..while loop should be unrolled
      j++;
   } while (j &lt; 15);

   int k = 0;
   #pragma unroll
   while (k &lt; 20) {  // ok: this inner loop is already unrolled
      k++;
   }
}

int A[1000];
#pragma unroll
// warning: this loop is large and should be partially unrolled
for (int a : A) {
   printf(&quot;%d&quot;, a);
}

#pragma unroll 5
// ok: this loop is large, but is partially unrolled
for (int a : A) {
   printf(&quot;%d&quot;, a);
}

#pragma unroll
// warning: this loop is large and should be partially unrolled
for (int i = 0; i &lt; 1000; ++i) {
   printf(&quot;%d&quot;, i);
}

#pragma unroll 5
// ok: this loop is large, but is partially unrolled
for (int i = 0; i &lt; 1000; ++i) {
   printf(&quot;%d&quot;, i);
}

#pragma unroll
// warning: &lt;&lt; operator not supported, recommend partial unrolling
for (int i = 0; i &lt; 1000; i&lt;&lt;1) {
   printf(&quot;%d&quot;, i);
}

std::vector&lt;int&gt; someVector (100, 0);
int i = 0;
#pragma unroll
// note: loop may be large, recommend partial unrolling
while (i &lt; someVector.size()) {
   someVector[i]++;
}

#pragma unroll
// note: loop may be large, recommend partial unrolling
while (true) {
   printf(&quot;In loop&quot;);
}


#pragma unroll 5
// ok: loop may be large, but is partially unrolled
while (i &lt; someVector.size()) {
   someVector[i]++;
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
MaxLoopIterations</b></p>

<p style="margin-left:22%;">Defines the maximum number of
loop iterations that a fully unrolled loop can have. By
default, it is set to <i>100</i>.</p>

<p style="margin-left:22%; margin-top: 1em">In practice,
this refers to the integer value of the upper bound within
the loop statement's condition expression.</p>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;accept</b>
<br>
The usage of <b>accept()</b> is not recommended, it's better
to use <b>accept4()</b>. Without this flag, an opened
sensitive file descriptor would remain open across a
fork+exec to a lower&minus;privileged SELinux domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">accept(sockfd, addr, addrlen);

// becomes

accept4(sockfd, addr, addrlen, SOCK_CLOEXEC);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;accept4
<br>
accept4()</b> should include <b>SOCK_CLOEXEC</b> in its type
argument to avoid the file descriptor leakage. Without this
flag, an opened sensitive file would remain open across a
fork+exec to a lower&minus;privileged SELinux domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">accept4(sockfd, addr, addrlen, SOCK_NONBLOCK);

// becomes


accept4(sockfd, addr, addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;creat</b>
<br>
The usage of <b>creat()</b> is not recommended, it's better
to use <b>open()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">int fd = creat(path, mode);

// becomes


int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, mode);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;dup</b>
<br>
The usage of <b>dup()</b> is not recommended, it's better to
use <b>fcntl()</b>, which can set the
close&minus;on&minus;exec flag. Otherwise, an opened
sensitive file would remain open across a fork+exec to a
lower&minus;privileged SELinux domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">int fd = dup(oldfd);

// becomes

int fd = fcntl(oldfd, F_DUPFD_CLOEXEC);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;epoll&minus;create</b>
<br>
The usage of <b>epoll_create()</b> is not recommended, it's
better to use <b>epoll_create1()</b>, which allows
close&minus;on&minus;exec.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">epoll_create(size);

// becomes

epoll_create1(EPOLL_CLOEXEC);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;epoll&minus;create1
<br>
epoll_create1()</b> should include <b>EPOLL_CLOEXEC</b> in
its type argument to avoid the file descriptor leakage.
Without this flag, an opened sensitive file would remain
open across a fork+exec to a lower&minus;privileged SELinux
domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">epoll_create1(0);

// becomes

epoll_create1(EPOLL_CLOEXEC);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;fopen
<br>
fopen()</b> should include <b>e</b> in their mode string; so
<b>re</b> would be valid. This is equivalent to having set
<b>FD_CLOEXEC on</b> that descriptor.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">fopen(&quot;fn&quot;, &quot;r&quot;);

// becomes

fopen(&quot;fn&quot;, &quot;re&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;inotify&minus;init</b>
<br>
The usage of <b>inotify_init()</b> is not recommended, it's
better to use <b>inotify_init1()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">inotify_init();

// becomes

inotify_init1(IN_CLOEXEC);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;inotify&minus;init1
<br>
inotify_init1()</b> should include <b>IN_CLOEXEC</b> in its
type argument to avoid the file descriptor leakage. Without
this flag, an opened sensitive file would remain open across
a fork+exec to a lower&minus;privileged SELinux domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">inotify_init1(IN_NONBLOCK);

// becomes

inotify_init1(IN_NONBLOCK | IN_CLOEXEC);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;memfd&minus;create
<br>
memfd_create()</b> should include <b>MFD_CLOEXEC</b> in its
type argument to avoid the file descriptor leakage. Without
this flag, an opened sensitive file would remain open across
a fork+exec to a lower&minus;privileged SELinux domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">memfd_create(name, MFD_ALLOW_SEALING);

// becomes

memfd_create(name, MFD_ALLOW_SEALING | MFD_CLOEXEC);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;open</b>
<br>
A common source of security bugs is code that opens a file
without using the <b>O_CLOEXEC</b> flag. Without that flag,
an opened sensitive file would remain open across a
fork+exec to a lower&minus;privileged SELinux domain,
leaking that sensitive data. Open&minus;like functions
including <b>open()</b>, <b>openat()</b>, and
<b>open64()</b> should include <b>O_CLOEXEC</b> in their
flags argument.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">open(&quot;filename&quot;, O_RDWR);
open64(&quot;filename&quot;, O_RDWR);
openat(0, &quot;filename&quot;, O_RDWR);

// becomes


open(&quot;filename&quot;, O_RDWR | O_CLOEXEC);
open64(&quot;filename&quot;, O_RDWR | O_CLOEXEC);
openat(0, &quot;filename&quot;, O_RDWR | O_CLOEXEC);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;pipe</b>
<br>
This check detects usage of <b>pipe()</b>. Using
<b>pipe()</b> is not recommended, <b>pipe2()</b> is the
suggested replacement. The check also adds the O_CLOEXEC
flag that marks the file descriptor to be closed in child
processes. Without this flag a sensitive file descriptor can
be leaked to a child process, potentially into a
lower&minus;privileged SELinux domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">pipe(pipefd);</pre>


<p style="margin-left:11%; margin-top: 1em">Suggested
replacement:</p>

<pre style="margin-left:15%; margin-top: 1em">pipe2(pipefd, O_CLOEXEC);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;pipe2</b>
<br>
This check ensures that pipe2() is called with the O_CLOEXEC
flag. The check also adds the O_CLOEXEC flag that marks the
file descriptor to be closed in child processes. Without
this flag a sensitive file descriptor can be leaked to a
child process, potentially into a lower&minus;privileged
SELinux domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">pipe2(pipefd, O_NONBLOCK);</pre>


<p style="margin-left:11%; margin-top: 1em">Suggested
replacement:</p>

<pre style="margin-left:15%; margin-top: 1em">pipe2(pipefd, O_NONBLOCK | O_CLOEXEC);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>android&minus;cloexec&minus;socket
<br>
socket()</b> should include <b>SOCK_CLOEXEC</b> in its type
argument to avoid the file descriptor leakage. Without this
flag, an opened sensitive file would remain open across a
fork+exec to a lower&minus;privileged SELinux domain.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">socket(domain, type, SOCK_STREAM);

// becomes

socket(domain, type, SOCK_STREAM | SOCK_CLOEXEC);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>android&minus;comparison&minus;in&minus;temp&minus;failure&minus;retry</b>
<br>
Diagnoses comparisons that appear to be incorrectly placed
in the argument to the <b>TEMP_FAILURE_RETRY</b> macro.
Having such a use is incorrect in the vast majority of
cases, and will often silently defeat the purpose of the
<b>TEMP_FAILURE_RETRY</b> macro.</p>

<p style="margin-left:11%; margin-top: 1em">For context,
<b>TEMP_FAILURE_RETRY</b> is <i>a convenience macro</i>
provided by both glibc and Bionic. Its purpose is to
repeatedly run a syscall until it either succeeds, or fails
for reasons other than being interrupted.</p>

<p style="margin-left:11%; margin-top: 1em">Example buggy
usage looks like:</p>

<pre style="margin-left:15%; margin-top: 1em">char cs[1];
while (TEMP_FAILURE_RETRY(read(STDIN_FILENO, cs, sizeof(cs)) != 0)) {
  // Do something with cs.
}</pre>


<p style="margin-left:11%; margin-top: 1em">Because
TEMP_FAILURE_RETRY will check for whether the result <i>of
the comparison</i> is <b>&minus;1</b>, and retry if so.</p>

<p style="margin-left:11%; margin-top: 1em">If you
encounter this, the fix is simple: lift the comparison out
of the <b>TEMP_FAILURE_RETRY</b> argument, like so:</p>

<pre style="margin-left:15%; margin-top: 1em">char cs[1];
while (TEMP_FAILURE_RETRY(read(STDIN_FILENO, cs, sizeof(cs))) != 0) {
  // Do something with cs.
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
RetryMacros</b></p>

<p style="margin-left:22%;">A comma&minus;separated list of
the names of retry macros to be checked.</p>


<p style="margin-left:11%; margin-top: 1em"><b>boost&minus;use&minus;to&minus;string</b>
<br>
This check finds conversion from integer type like
<b>int</b> to <b>std::string</b> or <b>std::wstring</b>
using <b>boost::lexical_cast</b>, and replace it with calls
to <b>std::to_string</b> and <b>std::to_wstring</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It doesn't
replace conversion from floating points despite the
<b>to_string</b> overloads, because it would change the
behavior.</p>
<pre style="margin-left:15%; margin-top: 1em">auto str = boost::lexical_cast&lt;std::string&gt;(42);
auto wstr = boost::lexical_cast&lt;std::wstring&gt;(2137LL);


// Will be changed to
auto str = std::to_string(42);
auto wstr = std::to_wstring(2137LL);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;argument&minus;comment</b>
<br>
Checks that argument comments match parameter names.</p>

<p style="margin-left:11%; margin-top: 1em">The check
understands argument comments in the form
<b>/*parameter_name=*/</b> that are placed right before the
argument.</p>
<pre style="margin-left:15%; margin-top: 1em">void f(bool foo);

...


f(/*bar=*/true);
// warning: argument name 'bar' in comment does not match parameter name 'foo'</pre>


<p style="margin-left:11%; margin-top: 1em">The check tries
to detect typos and suggest automated fixes for them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
StrictMode</b></p>

<p style="margin-left:22%;">When <i>false</i> (default
value), the check will ignore leading and trailing
underscores and case when comparing names &minus;&minus;
otherwise they are taken into account.</p>


<p style="margin-left:11%;"><b>IgnoreSingleArgument</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will ignore the single argument.</p>

<p style="margin-left:11%;"><b>CommentBoolLiterals</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will add argument comments in the format
<b>/*ParameterName=*/</b> right before the boolean literal
argument.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(bool TurnKey, bool PressButton);

foo(true, false);</pre>

<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(bool TurnKey, bool PressButton);

foo(/*TurnKey=*/true, /*PressButton=*/false);</pre>


<p style="margin-left:11%;"><b>CommentIntegerLiterals</b></p>

<p style="margin-left:22%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the integer literal argument.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(int MeaningOfLife);

foo(42);</pre>

<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(int MeaningOfLife);

foo(/*MeaningOfLife=*/42);</pre>


<p style="margin-left:11%;"><b>CommentFloatLiterals</b></p>

<p style="margin-left:22%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the float/double literal argument.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(float Pi);

foo(3.14159);</pre>

<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(float Pi);

foo(/*Pi=*/3.14159);</pre>


<p style="margin-left:11%;"><b>CommentStringLiterals</b></p>

<p style="margin-left:22%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the string literal argument.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(const char *String);
void foo(const wchar_t *WideString);


foo(&quot;Hello World&quot;);
foo(L&quot;Hello World&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(const char *String);
void foo(const wchar_t *WideString);


foo(/*String=*/&quot;Hello World&quot;);
foo(/*WideString=*/L&quot;Hello World&quot;);</pre>



<p style="margin-left:11%;"><b>CommentCharacterLiterals</b></p>

<p style="margin-left:22%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the character literal argument.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(char *Character);

foo('A');</pre>

<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(char *Character);

foo(/*Character=*/'A');</pre>


<p style="margin-left:11%;"><b>CommentUserDefinedLiterals</b></p>

<p style="margin-left:22%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the user defined literal argument.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(double Distance);

double operator&quot;&quot; _km(long double);

foo(402.0_km);</pre>

<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(double Distance);

double operator&quot;&quot; _km(long double);

foo(/*Distance=*/402.0_km);</pre>

<p style="margin-left:11%;"><b>CommentNullPtrs</b></p>

<p style="margin-left:22%;">When true, the check will add
argument comments in the format <b>/*ParameterName=*/</b>
right before the nullptr literal argument.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(A* Value);

foo(nullptr);</pre>

<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(A* Value);

foo(/*Value=*/nullptr);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;assert&minus;side&minus;effect</b>
<br>
Finds <b>assert()</b> with side effect.</p>

<p style="margin-left:11%; margin-top: 1em">The condition
of <b>assert()</b> is evaluated only in debug builds so a
condition with side effect can cause different behavior in
debug / release builds.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
AssertMacros</b></p>

<p style="margin-left:22%;">A comma&minus;separated list of
the names of assert macros to be checked.</p>

<p style="margin-left:11%;"><b>CheckFunctionCalls</b></p>

<p style="margin-left:22%;">Whether to treat
non&minus;const member and non&minus;member functions as
they produce side effects. Disabled by default because it
can increase the number of false positive warnings.</p>

<p style="margin-left:11%;"><b>IgnoredFunctions</b></p>

<p style="margin-left:22%;">A semicolon&minus;separated
list of the names of functions or methods to be considered
as not having side&minus;effects. Regular expressions are
accepted, e.g. <i>[Rr]ef(erence)?$</i> matches every type
with suffix <i>Ref</i>, <i>ref</i>, <i>Reference</i> and
<i>reference</i>. The default is empty. If a name in the
list contains the sequence <i>::</i> it is matched against
the qualified typename (i.e. <i>namespace::Type</i>,
otherwise it is matched against only the type name (i.e.
<i>Type</i>).</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;assignment&minus;in&minus;if&minus;condition</b>
<br>
Finds assignments within conditions of <i>if</i> statements.
Such assignments are bug&minus;prone because they may have
been intended as equality tests.</p>

<p style="margin-left:11%; margin-top: 1em">This check
finds all assignments within <i>if</i> conditions, including
ones that are not flagged by <i>&minus;Wparentheses</i> due
to an extra set of parentheses, and including assignments
that call an overloaded <i>operator=()</i>. The identified
assignments violate <i>BARR group &quot;Rule
8.2.c&quot;</i>.</p>
<pre style="margin-left:15%; margin-top: 1em">int f = 3;
if(f = 4) { // This is identified by both `Wparentheses` and this check &minus; should it have been: `if (f == 4)` ?
  f = f + 1;
}


if((f == 5) || (f = 6)) { // the assignment here `(f = 6)` is identified by this check, but not by `&minus;Wparentheses`. Should it have been `(f == 6)` ?
  f = f + 2;
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;bad&minus;signal&minus;to&minus;kill&minus;thread</b>
<br>
Finds <b>pthread_kill</b> function calls when a thread is
terminated by raising <b>SIGTERM</b> signal and the signal
kills the entire process, not just the individual thread.
Use any signal except <b>SIGTERM</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule
<i>POS44&minus;C. Do not use signals to terminate
threads</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;bool&minus;pointer&minus;implicit&minus;conversion</b>
<br>
Checks for conditions based on implicit conversion from a
<b>bool</b> pointer to <b>bool</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">bool *p;
if (p) {
  // Never used in a pointer&minus;specific way.
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;branch&minus;clone</b>
<br>
Checks for repeated branches in <b>if/else if/else</b>
chains, consecutive repeated branches in <b>switch</b>
statements and identical true and false branches in
conditional operators.</p>

<pre style="margin-left:15%; margin-top: 1em">if (test_value(x)) {
  y++;
  do_something(x, y);
} else {
  y++;
  do_something(x, y);
}</pre>


<p style="margin-left:11%; margin-top: 1em">In this simple
example (which could arise e.g. as a copy&minus;paste error)
the <b>then</b> and <b>else</b> branches are identical and
the code is equivalent the following shorter and cleaner
code:</p>

<pre style="margin-left:15%; margin-top: 1em">test_value(x); // can be omitted unless it has side effects
y++;
do_something(x, y);</pre>


<p style="margin-left:11%; margin-top: 1em">If this is the
intended behavior, then there is no reason to use a
conditional statement; otherwise the issue can be solved by
fixing the branch that is handled incorrectly.</p>

<p style="margin-left:11%; margin-top: 1em">The check also
detects repeated branches in longer <b>if/else if/else</b>
chains where it would be even harder to notice the
problem.</p>

<p style="margin-left:11%; margin-top: 1em">In
<b>switch</b> statements the check only reports repeated
branches when they are consecutive, because it is relatively
common that the <b>case:</b> labels have some natural
ordering and rearranging them would decrease the readability
of the code. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">switch (ch) {
case 'a':
  return 10;
case 'A':
  return 10;
case 'b':
  return 11;
case 'B':
  return 11;
default:
  return 10;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Here the check
reports that the <b>'a'</b> and <b>'A'</b> branches are
identical (and that the <b>'b'</b> and <b>'B'</b> branches
are also identical), but does not report that the
<b>default:</b> branch is also identical to the first two
branches. If this is indeed the correct behavior, then it
could be implemented as:</p>

<pre style="margin-left:15%; margin-top: 1em">switch (ch) {
case 'a':
case 'A':
  return 10;
case 'b':
case 'B':
  return 11;
default:
  return 10;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Here the check
does not warn for the repeated <b>return 10;</b>, which is
good if we want to preserve that <b>'a'</b> is before
<b>'b'</b> and <b>default:</b> is the last branch.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, the
check also examines conditional operators and reports code
like:</p>

<pre style="margin-left:15%; margin-top: 1em">return test_value(x) ? x : x;</pre>


<p style="margin-left:11%; margin-top: 1em">Unlike if
statements, the check does not detect chains of conditional
operators.</p>

<p style="margin-left:11%; margin-top: 1em">Note: This
check also reports situations where branches become
identical only after preprocessing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;copy&minus;constructor&minus;init</b>
<br>
Finds copy constructors where the constructor doesn't call
the copy constructor of the base class.</p>

<pre style="margin-left:15%; margin-top: 1em">class Copyable {
public:
  Copyable() = default;
  Copyable(const Copyable &amp;) = default;
};
class X2 : public Copyable {
  X2(const X2 &amp;other) {} // Copyable(other) is missing
};</pre>


<p style="margin-left:11%; margin-top: 1em">Also finds copy
constructors where the constructor of the base class don't
have parameter.</p>

<pre style="margin-left:15%; margin-top: 1em">class X4 : public Copyable {
  X4(const X4 &amp;other) : Copyable() {} // other is missing
};</pre>


<p style="margin-left:11%; margin-top: 1em">The check also
suggests a fix&minus;its in some cases.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;dangling&minus;handle</b>
<br>
Detect dangling references in value handles like
<b>std::string_view</b>. These dangling references can be a
result of constructing handles from temporary values, where
the temporary is destroyed soon after the handle is
created.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">string_view View = string();  // View will dangle.
string A;
View = A + &quot;A&quot;;  // still dangle.

vector&lt;string_view&gt; V;
V.push_back(string());  // V[0] is dangling.
V.resize(3, string());  // V[1] and V[2] will also dangle.


string_view f() {
  // All these return values will dangle.
  return string();
  string S;
  return S;
  char Array[10]{};
  return Array;
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
HandleClasses</b></p>

<p style="margin-left:22%;">A semicolon&minus;separated
list of class names that should be treated as handles. By
default only <b>std::basic_string_view</b> and
<b>std::experimental::basic_string_view</b> are
considered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;dynamic&minus;static&minus;initializers</b>
<br>
Finds instances of static variables that are dynamically
initialized in header files.</p>

<p style="margin-left:11%; margin-top: 1em">This can pose
problems in certain multithreaded contexts. For example,
when disabling compiler generated synchronization
instructions for static variables initialized at runtime
(e.g. by <b>&minus;fno&minus;threadsafe&minus;statics</b>),
even if a particular project takes the necessary precautions
to prevent race conditions during initialization by
providing their own synchronization, header files included
from other projects may not. Therefore, such a check is
helpful for ensuring that disabling compiler generated
synchronization for static variable initialization will not
cause problems.</p>

<p style="margin-left:11%; margin-top: 1em">Consider the
following code:</p>

<pre style="margin-left:15%; margin-top: 1em">int foo() {
  static int k = bar();
  return k;
}</pre>


<p style="margin-left:11%; margin-top: 1em">When
synchronization of static initialization is disabled, if two
threads both call <i>foo</i> for the first time, there is
the possibility that <i>k</i> will be double initialized,
creating a race condition.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;easily&minus;swappable&minus;parameters</b>
<br>
Finds function definitions where parameters of convertible
types follow each other directly, making call sites prone to
calling the function with swapped (or badly ordered)
arguments.</p>

<pre style="margin-left:15%; margin-top: 1em">void drawPoint(int X, int Y) { /* ... */ }
FILE *open(const char *Dir, const char *Name, Flags Mode) { /* ... */ }</pre>


<p style="margin-left:11%; margin-top: 1em">A potential
call like <b>drawPoint(&minus;2, 5)</b> or
<b>openPath(&quot;a.txt&quot;, &quot;tmp&quot;, Read)</b> is
perfectly legal from the language's perspective, but might
not be what the developer of the function intended.</p>

<p style="margin-left:11%; margin-top: 1em">More elaborate
and type&minus;safe constructs, such as opaque typedefs or
strong types should be used instead, to prevent a mistaken
order of arguments.</p>
<pre style="margin-left:15%; margin-top: 1em">struct Coord2D { int X; int Y; };
void drawPoint(const Coord2D Pos) { /* ... */ }


FILE *open(const Path &amp;Dir, const Filename &amp;Name, Flags Mode) { /* ... */ }</pre>


<p style="margin-left:11%; margin-top: 1em">Due to the
potentially elaborate refactoring and API&minus;breaking
that is necessary to strengthen the type safety of a
project, no automatic fix&minus;its are offered.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
Extension/relaxation options</b> <br>
Relaxation (or extension) options can be used to broaden the
scope of the analysis and fine&minus;tune the enabling of
more mixes between types. Some mixes may depend on coding
style or preference specific to a project, however, it
should be noted that enabling <i>all</i> of these
relaxations model the way of mixing at call sites the most.
These options are expected to make the check report for more
functions, and report longer mixable ranges. <b><br>
QualifiersMix</b></p>

<p style="margin-left:22%;">Whether to consider parameters
of some <i>cvr&minus;qualified</i> <b>T</b> and a
differently <i>cvr&minus;qualified</i> <b>T</b> (i.e.
<b>T</b> and <b>const T</b>, <b>const T</b> and <b>volatile
T</b>, etc.) mixable between one another. If <i>false</i>,
the check will consider differently qualified types
unmixable. <i>True</i> turns the warnings on. Defaults to
<i>false</i>.</p>

<p style="margin-left:22%; margin-top: 1em">The following
example produces a diagnostic only if <i>QualifiersMix</i>
is enabled:</p>

<pre style="margin-left:26%; margin-top: 1em">void *memcpy(const void *Destination, void *Source, std::size_t N) { /* ... */ }</pre>



<p style="margin-left:11%;"><b>ModelImplicitConversions</b></p>

<p style="margin-left:22%;">Whether to consider parameters
of type <b>T</b> and <b>U</b> mixable if there exists an
implicit conversion from <b>T</b> to <b>U</b> and <b>U</b>
to <b>T</b>. If <i>false</i>, the check will not consider
implicitly convertible types for mixability. <i>True</i>
turns warnings for implicit conversions on. Defaults to
<i>true</i>.</p>

<p style="margin-left:22%; margin-top: 1em">The following
examples produce a diagnostic only if
<i>ModelImplicitConversions</i> is enabled:</p>

<pre style="margin-left:26%; margin-top: 1em">void fun(int Int, double Double) { /* ... */ }
void compare(const char *CharBuf, std::string String) { /* ... */ }</pre>



<p style="margin-left:22%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:26%;">Changing the qualifiers of an
expression's type (e.g. from <b>int</b> to <b>const int</b>)
is defined as an <i>implicit conversion</i> in the C++
Standard. However, the check separates this
decision&minus;making on the mixability of differently
qualified types based on whether <i>QualifiersMix</i> was
enabled.</p>

<p style="margin-left:26%; margin-top: 1em">For example,
the following code snippet will only produce a diagnostic if
<b>both</b> <i>QualifiersMix</i> and
<i>ModelImplicitConversions</i> are enabled:</p>

<pre style="margin-left:32%; margin-top: 1em">void fun2(int Int, const double Double) { /* ... */ }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Filtering
options</b> <br>
Filtering options can be used to lessen the size of the
diagnostics emitted by the checker, whether the aim is to
ignore certain constructs or dampen the noisiness. <b><br>
MinimumLength</b></p>

<p style="margin-left:22%;">The minimum length required
from an adjacent parameter sequence to be diagnosed.
Defaults to <i>2</i>. Might be any positive integer greater
or equal to <i>2</i>. If <i>0</i> or <i>1</i> is given, the
default value <i>2</i> will be used instead.</p>

<p style="margin-left:22%; margin-top: 1em">For example, if
<i>3</i> is specified, the examples above will not be
matched.</p>


<p style="margin-left:11%;"><b>IgnoredParameterNames</b></p>

<p style="margin-left:22%;">The list of parameter
<b>names</b> that should never be considered part of a
swappable adjacent parameter sequence. The value is a
<i>;</i>&minus;separated list of names. To ignore unnamed
parameters, add <i>&quot;&quot;</i> to the list verbatim
(not the empty string, but the two quotes, potentially
escaped!). <b>This option is case&minus;sensitive!</b></p>

<p style="margin-left:22%; margin-top: 1em">By default, the
following parameter names, and their Uppercase&minus;initial
variants are ignored: <i>&quot;&quot;</i> (unnamed
parameters), <i>iterator</i>, <i>begin</i>, <i>end</i>,
<i>first</i>, <i>last</i>, <i>lhs</i>, <i>rhs</i>.</p>


<p style="margin-left:11%;"><b>IgnoredParameterTypeSuffixes</b></p>

<p style="margin-left:22%;">The list of parameter <b>type
name suffixes</b> that should never be considered part of a
swappable adjacent parameter sequence. Parameters which
type, as written in the source code, end with an element of
this option will be ignored. The value is a
<i>;</i>&minus;separated list of names. <b>This option is
case&minus;sensitive!</b></p>

<p style="margin-left:22%; margin-top: 1em">By default, the
following, and their lowercase&minus;initial variants are
ignored: <i>bool</i>, <i>It</i>, <i>Iterator</i>,
<i>InputIt</i>, <i>ForwardIt</i>, <i>BidirIt</i>,
<i>RandomIt</i>, <i>random_iterator</i>, <i>ReverseIt</i>,
<i>reverse_iterator</i>, <i>reverse_const_iterator</i>,
<i>RandomIt</i>, <i>random_iterator</i>, <i>ReverseIt</i>,
<i>reverse_iterator</i>, <i>reverse_const_iterator</i>,
<i>Const_Iterator</i>, <i>ConstIterator</i>,
<i>const_reverse_iterator</i>, <i>ConstReverseIterator</i>.
In addition, <i>_Bool</i> (but not <i>_bool</i>) is also
part of the default value.</p>


<p style="margin-left:11%;"><b>SuppressParametersUsedTogether</b></p>

<p style="margin-left:22%;">Suppresses diagnostics about
parameters that are used together or in a similar fashion
inside the function's body. Defaults to <i>true</i>.
Specifying <i>false</i> will turn off the heuristics.</p>

<p style="margin-left:22%; margin-top: 1em">Currently, the
following heuristics are implemented which will suppress the
warning about the parameter pair involved:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>The parameters are used in the same expression, e.g.
<b>f(a, b)</b> or <b>a &lt; b</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>The parameters are further passed to the same function
to the same parameter of that function, of the same
overload. E.g. <b>f(a, 1)</b> and <b>f(b, 2)</b> to some
<b>f(T, int)</b>.</p></td></tr>
</table>


<p style="margin-left:25%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:29%;">The check does not perform
path&minus;sensitive analysis, and as such, &quot;same
function&quot; in this context means the same function
declaration. If the same member function of a type on two
distinct instances are called with the parameters, it will
still be regarded as &quot;same function&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em">The same member field is
accessed, or member method is called of the two parameters,
e.g. <b>a.foo()</b> and <b>b.foo()</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>Separate <b>return</b> statements return either of the
parameters on different code paths.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>NamePrefixSuffixSilenceDissimilarityTreshold</b></p>

<p style="margin-left:22%;">The number of characters two
parameter names might be different on <i>either</i> the head
or the tail end with the rest of the name the same so that
the warning about the two parameters are silenced. Defaults
to <i>1</i>. Might be any positive integer. If <i>0</i>, the
filtering heuristic based on the parameters' names is turned
off.</p>

<p style="margin-left:22%; margin-top: 1em">This option can
be used to silence warnings about parameters where the
naming scheme indicates that the order of those parameters
do not matter.</p>

<p style="margin-left:22%; margin-top: 1em">For example,
the parameters <b>LHS</b> and <b>RHS</b> are
1&minus;dissimilar suffixes of each other: <b>L</b> and
<b>R</b> is the different character, while <b>HS</b> is the
common suffix. Similarly, parameters <b>text1, text2,
text3</b> are 1&minus;dissimilar prefixes of each other,
with the numbers at the end being the dissimilar part. If
the value is at least <i>1</i>, such cases will not be
reported.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Limitations
<br>
This check is designed to check function signatures!</b></p>

<p style="margin-left:11%; margin-top: 1em">The check does
not investigate functions that are generated by the compiler
in a context that is only determined from a call site. These
cases include variadic functions, functions in C code that
do not have an argument list, and C++ template
instantiations. Most of these cases, which are otherwise
swappable from a caller's standpoint, have no way of getting
&quot;fixed&quot; at the definition point. In the case of
C++ templates, only primary template definitions and
explicit specializations are matched and analyzed.</p>

<p style="margin-left:11%; margin-top: 1em">None of the
following cases produce a diagnostic:</p>
<pre style="margin-left:15%; margin-top: 1em">int printf(const char *Format, ...) { /* ... */ }
int someOldCFunction() { /* ... */ }

template &lt;typename T, typename U&gt;
int add(T X, U Y) { return X + Y };

void theseAreNotWarnedAbout() {
    printf(&quot;%d %d\n&quot;, 1, 2);   // Two ints passed, they could be swapped.
    someOldCFunction(1, 2, 3); // Similarly, multiple ints passed.


    add(1, 2); // Instantiates 'add&lt;int, int&gt;', but that's not a user&minus;defined function.
}</pre>


<p style="margin-left:11%; margin-top: 1em">Due to the
limitation above, parameters which type are further
dependent upon template instantiations to <i>prove</i> that
they mix with another parameter's is not diagnosed.</p>
<pre style="margin-left:15%; margin-top: 1em">template &lt;typename T&gt;
struct Vector {
  typedef T element_type;
};

// Diagnosed: Explicit instantiation was done by the user, we can prove it
// is the same type.
void instantiated(int A, Vector&lt;int&gt;::element_type B) { /* ... */ }

// Diagnosed: The two parameter types are exactly the same.
template &lt;typename T&gt;
void exact(typename Vector&lt;T&gt;::element_type A,
           typename Vector&lt;T&gt;::element_type B) { /* ... */ }


// Skipped: The two parameters are both 'T' but we cannot prove this
// without actually instantiating.
template &lt;typename T&gt;
void falseNegative(T A, typename Vector&lt;T&gt;::element_type B) { /* ... */ }</pre>


<p style="margin-left:11%; margin-top: 1em">In the context
of <i>implicit conversions</i> (when
<i>ModelImplicitConversions</i> is enabled), the modelling
performed by the check warns if the parameters are swappable
and the swapped order matches implicit conversions. It does
not model whether there exists an unrelated third type from
which <i>both</i> parameters can be given in a function
call. This means that in the following example, even while
<b>strs()</b> clearly carries the possibility to be called
with swapped arguments (as long as the arguments are string
literals), will not be warned about.</p>
<pre style="margin-left:15%; margin-top: 1em">struct String {
    String(const char *Buf);
};

struct StringView {
    StringView(const char *Buf);
    operator const char *() const;
};

// Skipped: Directly swapping expressions of the two type cannot mix.
// (Note: StringView &minus;&gt; const char * &minus;&gt; String would be **two**
// user&minus;defined conversions, which is disallowed by the language.)
void strs(String Str, StringView SV) { /* ... */ }


// Diagnosed: StringView implicitly converts to and from a buffer.
void cStr(StringView SV, const char *Buf() { /* ... */ }</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;exception&minus;escape</b>
<br>
Finds functions which may throw an exception directly or
indirectly, but they should not. The functions which should
not throw exceptions are the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p>Destructors</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p>Move constructors</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p>Move assignment operators</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p>The <b>main()</b> functions</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p><b>swap()</b> functions</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p>Functions marked with <b>throw()</b> or
<b>noexcept</b></p> </td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p>Other functions given as option</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A destructor
throwing an exception may result in undefined behavior,
resource leaks or unexpected termination of the program.
Throwing move constructor or move assignment also may result
in undefined behavior or resource leak. The <b>swap()</b>
operations expected to be non throwing most of the cases and
they are always possible to implement in a non throwing way.
Non throwing <b>swap()</b> operations are also used to
create move operations. A throwing <b>main()</b> function
also results in unexpected termination.</p>

<p style="margin-left:11%; margin-top: 1em">WARNING! This
check may be expensive on large source files.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
FunctionsThatShouldNotThrow</b></p>

<p style="margin-left:22%;">Comma separated list containing
function names which should not throw. An example value for
this parameter can be <b>WinMain</b> which adds function
<b>WinMain()</b> in the Windows API to the list of the
functions which should not throw. Default value is an empty
string.</p>

<p style="margin-left:11%;"><b>IgnoredExceptions</b></p>

<p style="margin-left:22%;">Comma separated list containing
type names which are not counted as thrown exceptions in the
check. Default value is an empty string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;fold&minus;init&minus;type</b>
<br>
The check flags type mismatches in <i>folds</i> like
<b>std::accumulate</b> that might result in loss of
precision. <b>std::accumulate</b> folds an input range into
an initial value using the type of the latter, with
<b>operator+</b> by default. This can cause loss of
precision through:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Truncation: The following code uses a floating point
range and an int initial value, so truncation will happen at
every application of <b>operator+</b> and the result will be
<i>0</i>, which might not be what the user expected.</p></td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">auto a = {0.5f, 0.5f, 0.5f, 0.5f};
return std::accumulate(std::begin(a), std::end(a), 0);</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="68%">


<p style="margin-top: 1em">Overflow: The following code
also returns <i>0</i>.</p></td>
<td width="18%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">auto a = {65536LL * 65536 * 65536};
return std::accumulate(std::begin(a), std::end(a), 0);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;forward&minus;declaration&minus;namespace</b>
<br>
Checks if an unused forward declaration is in a wrong
namespace.</p>

<p style="margin-left:11%; margin-top: 1em">The check
inspects all unused forward declarations and checks if there
is any declaration/definition with the same name existing,
which could indicate that the forward declaration is in a
potentially wrong namespace.</p>

<pre style="margin-left:15%; margin-top: 1em">namespace na { struct A; }
namespace nb { struct A {}; }
nb::A a;
// warning : no definition found for 'A', but a definition with the same name
// 'A' found in another namespace 'nb::'</pre>


<p style="margin-left:11%; margin-top: 1em">This check can
only generate warnings, but it can't suggest a fix at this
point.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;forwarding&minus;reference&minus;overload</b>
<br>
The check looks for perfect forwarding constructors that can
hide copy or move constructors. If a non const lvalue
reference is passed to the constructor, the forwarding
reference parameter will be a better match than the const
reference parameter of the copy constructor, so the perfect
forwarding constructor will be called, which can be
confusing. For detailed description of this issue see: Scott
Meyers, Effective Modern C++, Item 26.</p>

<p style="margin-left:11%; margin-top: 1em">Consider the
following example:</p>
<pre style="margin-left:15%; margin-top: 1em">class Person {
public:
  // C1: perfect forwarding ctor
  template&lt;typename T&gt;
  explicit Person(T&amp;&amp; n) {}

  // C2: perfect forwarding ctor with parameter default value
  template&lt;typename T&gt;
  explicit Person(T&amp;&amp; n, int x = 1) {}

  // C3: perfect forwarding ctor guarded with enable_if
  template&lt;typename T, typename X = enable_if_t&lt;is_special&lt;T&gt;, void&gt;&gt;
  explicit Person(T&amp;&amp; n) {}

  // C4: variadic perfect forwarding ctor guarded with enable_if
  template&lt;typename... A,
    enable_if_t&lt;is_constructible_v&lt;tuple&lt;string, int&gt;, A&amp;&amp;...&gt;, int&gt; = 0&gt;
  explicit Person(A&amp;&amp;... a) {}


  // (possibly compiler generated) copy ctor
  Person(const Person&amp; rhs);
};</pre>


<p style="margin-left:11%; margin-top: 1em">The check warns
for constructors C1 and C2, because those can hide copy and
move constructors. We suppress warnings if the copy and the
move constructors are both disabled (deleted or private),
because there is nothing the perfect forwarding constructor
could hide in this case. We also suppress warnings for
constructors like C3 and C4 that are guarded with an
<b>enable_if</b>, assuming the programmer was aware of the
possible hiding.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Background</b>
<br>
For deciding whether a constructor is guarded with
enable_if, we consider the types of the constructor
parameters, the default values of template type parameters
and the types of non&minus;type template parameters with a
default literal value. If any part of these types is
<b>std::enable_if</b> or <b>std::enable_if_t</b>, we assume
the constructor is guarded.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;implicit&minus;widening&minus;of&minus;multiplication&minus;result</b>
<br>
The check diagnoses instances where a result of a
multiplication is implicitly widened, and suggests (with
fix&minus;it) to either silence the code by making widening
explicit, or to perform the multiplication in a wider type,
to avoid the widening afterwards.</p>

<p style="margin-left:11%; margin-top: 1em">This is mainly
useful when operating on very large buffers. For example,
consider:</p>

<pre style="margin-left:15%; margin-top: 1em">void zeroinit(char* base, unsigned width, unsigned height) {
  for(unsigned row = 0; row != height; ++row) {
    for(unsigned col = 0; col != width; ++col) {
      char* ptr = base + row * width + col;
      *ptr = 0;
    }
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">This is fine in
general, but if <b>width * height</b> overflows, you end up
wrapping back to the beginning of <b>base</b> instead of
processing the entire requested buffer.</p>

<p style="margin-left:11%; margin-top: 1em">Indeed, this
only matters for pretty large buffers (4GB+), but that can
happen very easily for example in image processing, where
for that to happen you &quot;only&quot; need a ~269MPix
image.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
UseCXXStaticCastsInCppSources</b></p>

<p style="margin-left:22%;">When suggesting fix&minus;its
for C++ code, should C++&minus;style
<b>static_cast&lt;&gt;()</b>'s be suggested, or
C&minus;style casts. Defaults to <b>true</b>.</p>


<p style="margin-left:11%;"><b>UseCXXHeadersInCppSources</b></p>

<p style="margin-left:22%;">When suggesting to include the
appropriate header in C++ code, should
<b>&lt;cstddef&gt;</b> header be suggested, or
<b>&lt;stddef.h&gt;</b>. Defaults to <b>true</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">long mul(int a, int b) {
  return a * b; // warning: performing an implicit widening conversion to type 'long' of a multiplication performed in type 'int'
}

char* ptr_add(char *base, int a, int b) {
  return base + a * b; // warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'
}


char ptr_subscript(char *base, int a, int b) {
  return base[a * b]; // warning: result of multiplication in type 'int' is used as a pointer offset after an implicit widening conversion to type 'ssize_t'
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;inaccurate&minus;erase</b>
<br>
Checks for inaccurate use of the <b>erase()</b> method.</p>

<p style="margin-left:11%; margin-top: 1em">Algorithms like
<b>remove()</b> do not actually remove any element from the
container but return an iterator to the first redundant
element at the end of the container. These redundant
elements must be removed using the <b>erase()</b> method.
This check warns when not all of the elements will be
removed due to using an inappropriate overload.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the following code erases only one element:</p>

<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;int&gt; xs;
...
xs.erase(std::remove(xs.begin(), xs.end(), 10));</pre>


<p style="margin-left:11%; margin-top: 1em">Call the
two&minus;argument overload of <b>erase()</b> to remove the
subrange:</p>

<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;int&gt; xs;
...
xs.erase(std::remove(xs.begin(), xs.end(), 10), xs.end());</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;incorrect&minus;roundings</b>
<br>
Checks the usage of patterns known to produce incorrect
rounding. Programmers often use:</p>

<pre style="margin-left:15%; margin-top: 1em">(int)(double_expression + 0.5)</pre>


<p style="margin-left:11%; margin-top: 1em">to round the
double expression to an integer. The problem with this:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>It is unnecessarily slow.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>It is incorrect. The number 0.499999975 (smallest
representable float number below 0.5) rounds to 1.0. Even
worse behavior for negative numbers where both &minus;0.5f
and &minus;1.4f both round to 0.0.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;infinite&minus;loop</b>
<br>
Finds obvious infinite loops (loops where the condition
variable is not changed at all).</p>

<p style="margin-left:11%; margin-top: 1em">Finding
infinite loops is well&minus;known to be impossible (halting
problem). However, it is possible to detect some obvious
infinite loops, for example, if the loop condition is not
changed. This check detects such loops. A loop is considered
infinite if it does not have any loop exit statement
(<b>break</b>, <b>continue</b>, <b>goto</b>, <b>return</b>,
<b>throw</b> or a call to a function called as
<b>[[noreturn]]</b>) and all of the following conditions
hold for every variable in the condition:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p style="margin-top: 1em">It is a local variable.</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p>It has no reference or pointer aliases.</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="60%">


<p>It is not a structure or class member.</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Furthermore,
the condition must not contain a function call to consider
the loop infinite since functions may return different
values for different calls.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the following loop is considered infinite <i>i</i> is not
changed in the body:</p>

<pre style="margin-left:15%; margin-top: 1em">int i = 0, j = 0;
while (i &lt; 10) {
  ++j;
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;integer&minus;division</b>
<br>
Finds cases where integer division in a floating point
context is likely to cause unintended loss of precision.</p>

<p style="margin-left:11%; margin-top: 1em">No reports are
made if divisions are part of the following expressions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em">operands of operators expecting
integral or bool types,</p></td>
<td width="2%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p>call expressions of integral or bool types, and</p></td>
<td width="2%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p>explicit cast expressions to integral or bool types,</p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">as these are
interpreted as signs of deliberateness from the
programmer.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">float floatFunc(float);
int intFunc(int);
double d;
int i = 42;

// Warn, floating&minus;point values expected.
d = 32 * 8 / (2 + i);
d = 8 * floatFunc(1 + 7 / 2);
d = i / (1 &lt;&lt; 4);

// OK, no integer division.
d = 32 * 8.0 / (2 + i);
d = 8 * floatFunc(1 + 7.0 / 2);
d = (double)i / (1 &lt;&lt; 4);


// OK, there are signs of deliberateness.
d = 1 &lt;&lt; (i / 2);
d = 9 + intFunc(6 * i / 32);
d = (int)(i / 32) &minus; 8;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;lambda&minus;function&minus;name</b>
<br>
Checks for attempts to get the name of a function from
within a lambda expression. The name of a lambda is always
something like <b>operator()</b>, which is almost never what
was intended.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">void FancyFunction() {
  [] { printf(&quot;Called from %s\n&quot;, __func__); }();
  [] { printf(&quot;Now called from %s\n&quot;, __FUNCTION__); }();
}</pre>


<p style="margin-left:11%; margin-top: 1em">Output:</p>

<pre style="margin-left:15%; margin-top: 1em">Called from operator()
Now called from operator()</pre>


<p style="margin-left:11%; margin-top: 1em">Likely intended
output:</p>

<pre style="margin-left:15%; margin-top: 1em">Called from FancyFunction
Now called from FancyFunction</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;macro&minus;parentheses</b>
<br>
Finds macros that can have unexpected behavior due to
missing parentheses.</p>

<p style="margin-left:11%; margin-top: 1em">Macros are
expanded by the preprocessor as&minus;is. As a result, there
can be unexpected behavior; operators may be evaluated in
unexpected order and unary operators may become binary
operators, etc.</p>

<p style="margin-left:11%; margin-top: 1em">When the
replacement list has an expression, it is recommended to
surround it with parentheses. This ensures that the macro
result is evaluated completely before it is used.</p>

<p style="margin-left:11%; margin-top: 1em">It is also
recommended to surround macro arguments in the replacement
list with parentheses. This ensures that the argument value
is calculated properly.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;macro&minus;repeated&minus;side&minus;effects</b>
<br>
Checks for repeated argument with side effects in
macros.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;misplaced&minus;operator&minus;in&minus;strlen&minus;in&minus;alloc</b>
<br>
Finds cases where <b>1</b> is added to the string in the
argument to <b>strlen()</b>, <b>strnlen()</b>,
<b>strnlen_s()</b>, <b>wcslen()</b>, <b>wcsnlen()</b>, and
<b>wcsnlen_s()</b> instead of the result and the value is
used as an argument to a memory allocation function
(<b>malloc()</b>, <b>calloc()</b>, <b>realloc()</b>,
<b>alloca()</b>) or the <b>new[]</b> operator in <i>C++</i>.
The check detects error cases even if one of these functions
(except the <b>new[]</b> operator) is called by a constant
function pointer. Cases where <b>1</b> is added both to the
parameter and the result of the <b>strlen()</b>&minus;like
function are ignored, as are cases where the whole addition
is surrounded by extra parentheses.</p>

<p style="margin-left:11%; margin-top: 1em"><i>C</i>
example code:</p>

<pre style="margin-left:15%; margin-top: 1em">void bad_malloc(char *str) {
  char *c = (char*) malloc(strlen(str + 1));
}</pre>


<p style="margin-left:11%; margin-top: 1em">The suggested
fix is to add <b>1</b> to the return value of
<b>strlen()</b> and not to its argument. In the example
above the fix would be</p>

<pre style="margin-left:15%; margin-top: 1em">char *c = (char*) malloc(strlen(str) + 1);</pre>


<p style="margin-left:11%; margin-top: 1em"><i>C++</i>
example code:</p>

<pre style="margin-left:15%; margin-top: 1em">void bad_new(char *str) {
  char *c = new char[strlen(str + 1)];
}</pre>


<p style="margin-left:11%; margin-top: 1em">As in the
<i>C</i> code with the <b>malloc()</b> function, the
suggested fix is to add <b>1</b> to the return value of
<b>strlen()</b> and not to its argument. In the example
above the fix would be</p>

<pre style="margin-left:15%; margin-top: 1em">char *c = new char[strlen(str) + 1];</pre>


<p style="margin-left:11%; margin-top: 1em">Example for
silencing the diagnostic:</p>

<pre style="margin-left:15%; margin-top: 1em">void bad_malloc(char *str) {
  char *c = (char*) malloc(strlen((str + 1)));
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;misplaced&minus;pointer&minus;arithmetic&minus;in&minus;alloc</b>
<br>
Finds cases where an integer expression is added to or
subtracted from the result of a memory allocation function
(<b>malloc()</b>, <b>calloc()</b>, <b>realloc()</b>,
<b>alloca()</b>) instead of its argument. The check detects
error cases even if one of these functions is called by a
constant function pointer.</p>

<p style="margin-left:11%; margin-top: 1em">Example
code:</p>

<pre style="margin-left:15%; margin-top: 1em">void bad_malloc(int n) {
  char *p = (char*) malloc(n) + 10;
}</pre>


<p style="margin-left:11%; margin-top: 1em">The suggested
fix is to add the integer expression to the argument of
<b>malloc</b> and not to its result. In the example above
the fix would be</p>

<pre style="margin-left:15%; margin-top: 1em">char *p = (char*) malloc(n + 10);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;misplaced&minus;widening&minus;cast</b>
<br>
This check will warn when there is a cast of a calculation
result to a bigger type. If the intention of the cast is to
avoid loss of precision then the cast is misplaced, and
there can be loss of precision. Otherwise the cast is
ineffective.</p>

<p style="margin-left:11%; margin-top: 1em">Example
code:</p>

<pre style="margin-left:15%; margin-top: 1em">long f(int x) {
    return (long)(x * 1000);
}</pre>


<p style="margin-left:11%; margin-top: 1em">The result <b>x
* 1000</b> is first calculated using <b>int</b> precision.
If the result exceeds <b>int</b> precision there is loss of
precision. Then the result is casted to <b>long</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If there is no
loss of precision then the cast can be removed or you can
explicitly cast to <b>int</b> instead.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
avoid loss of precision then put the cast in a proper
location, for instance:</p>

<pre style="margin-left:15%; margin-top: 1em">long f(int x) {
    return (long)x * 1000;
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Implicit
casts</b> <br>
Forgetting to place the cast at all is at least as dangerous
and at least as common as misplacing it. If
<i>CheckImplicitCasts</i> is enabled the check also detects
these cases, for instance:</p>

<pre style="margin-left:15%; margin-top: 1em">long f(int x) {
    return x * 1000;
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Floating
point</b> <br>
Currently warnings are only written for integer conversion.
No warning is written for this code:</p>

<pre style="margin-left:15%; margin-top: 1em">double f(float x) {
    return (double)(x * 10.0f);
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
CheckImplicitCasts</b></p>

<p style="margin-left:22%;">If <i>true</i>, enables
detection of implicit casts. Default is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;move&minus;forwarding&minus;reference</b>
<br>
Warns if <b>std::move</b> is called on a forwarding
reference, for example:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;typename T&gt;
void foo(T&amp;&amp; t) {
  bar(std::move(t));
}</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Forwarding
references</i> should typically be passed to
<b>std::forward</b> instead of <b>std::move</b>, and this is
the fix that will be suggested.</p>

<p style="margin-left:11%; margin-top: 1em">(A forwarding
reference is an rvalue reference of a type that is a deduced
function template argument.)</p>

<p style="margin-left:11%; margin-top: 1em">In this
example, the suggested fix would be</p>

<pre style="margin-left:15%; margin-top: 1em">bar(std::forward&lt;T&gt;(t));</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Background</b>
<br>
Code like the example above is sometimes written with the
expectation that <b>T&amp;&amp;</b> will always end up being
an rvalue reference, no matter what type is deduced for
<b>T</b>, and that it is therefore not possible to pass an
lvalue to <b>foo()</b>. However, this is not true. Consider
this example:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string s = &quot;Hello, world&quot;;
foo(s);</pre>


<p style="margin-left:11%; margin-top: 1em">This code
compiles and, after the call to <b>foo()</b>, <b>s</b> is
left in an indeterminate state because it has been moved
from. This may be surprising to the caller of <b>foo()</b>
because no <b>std::move</b> was used when calling
<b>foo()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The reason for
this behavior lies in the special rule for template argument
deduction on function templates like <b>foo()</b>
&minus;&minus; i.e. on function templates that take an
rvalue reference argument of a type that is a deduced
function template argument. (See section
[temp.deduct.call]/3 in the C++11 standard.)</p>

<p style="margin-left:11%; margin-top: 1em">If <b>foo()</b>
is called on an lvalue (as in the example above), then
<b>T</b> is deduced to be an lvalue reference. In the
example, <b>T</b> is deduced to be <b>std::string &amp;</b>.
The type of the argument <b>t</b> therefore becomes
<b>std::string&amp; &amp;&amp;</b>; by the reference
collapsing rules, this collapses to
<b>std::string&amp;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This means that
the <b>foo(s)</b> call passes <b>s</b> as an lvalue
reference, and <b>foo()</b> ends up moving <b>s</b> and
thereby placing it into an indeterminate state.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;multiple&minus;statement&minus;macro</b>
<br>
Detect multiple statement macros that are used in unbraced
conditionals. Only the first statement of the macro will be
inside the conditional and the other ones will be executed
unconditionally.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">#define INCREMENT_TWO(x, y) (x)++; (y)++
if (do_increment)
  INCREMENT_TWO(a, b);  // (b)++ will be executed unconditionally.</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;narrowing&minus;conversions</b>
<br>
The bugprone&minus;narrowing&minus;conversions check is an
alias, please see
<i>cppcoreguidelines&minus;narrowing&minus;conversions</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;no&minus;escape</b>
<br>
Finds pointers with the <b>noescape</b> attribute that are
captured by an asynchronously&minus;executed block. The
block arguments in <b>dispatch_async()</b> and
<b>dispatch_after()</b> are guaranteed to escape, so it is
an error if a pointer with the <b>noescape</b> attribute is
captured by one of these blocks.</p>

<p style="margin-left:11%; margin-top: 1em">The following
is an example of an invalid use of the <b>noescape</b>
attribute.</p>

<pre style="margin-left:22%; margin-top: 1em">void foo(__attribute__((noescape)) int *p) {
  dispatch_async(queue, ^{
    *p = 123;
  });
});</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;not&minus;null&minus;terminated&minus;result</b>
<br>
Finds function calls where it is possible to cause a not
null&minus;terminated result. Usually the proper length of a
string is <b>strlen(src) + 1</b> or equal length of this
expression, because the null terminator needs an extra
space. Without the null terminator it can result in
undefined behavior when the string is read.</p>

<p style="margin-left:11%; margin-top: 1em">The following
and their respective <b>wchar_t</b> based functions are
checked:</p>

<p style="margin-left:11%; margin-top: 1em"><b>memcpy</b>,
<b>memcpy_s</b>, <b>memchr</b>, <b>memmove</b>,
<b>memmove_s</b>, <b>strerror_s</b>, <b>strncmp</b>,
<b>strxfrm</b></p>

<p style="margin-left:11%; margin-top: 1em">The following
is a real&minus;world example where the programmer forgot to
increase the passed third argument, which is <b>size_t
length</b>. That is why the length of the allocated memory
is not enough to hold the null terminator.</p>

<pre style="margin-left:15%; margin-top: 1em">static char *stringCpy(const std::string &amp;str) {
  char *result = reinterpret_cast&lt;char *&gt;(malloc(str.size()));
  memcpy(result, str.data(), str.size());
  return result;
}</pre>


<p style="margin-left:11%; margin-top: 1em">In addition to
issuing warnings, fix&minus;it rewrites all the necessary
code. It also tries to adjust the capacity of the
destination array:</p>

<pre style="margin-left:15%; margin-top: 1em">static char *stringCpy(const std::string &amp;str) {
  char *result = reinterpret_cast&lt;char *&gt;(malloc(str.size() + 1));
  strcpy(result, str.data());
  return result;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Note: It cannot
guarantee to rewrite every of the path&minus;sensitive
memory allocations.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Transformation
rules of 'memcpy()'</b> <br>
It is possible to rewrite the <b>memcpy()</b> and
<b>memcpy_s()</b> calls as the following four functions:
<b>strcpy()</b>, <b>strncpy()</b>, <b>strcpy_s()</b>,
<b>strncpy_s()</b>, where the latter two are the safer
versions of the former two. It rewrites the <b>wchar_t</b>
based memory handler functions respectively.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Rewrite
based on the destination array</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If copy to the destination array cannot overflow [1] the
new function should be the older copy function (ending with
<b>cpy</b>), because it is more efficient than the safe
version.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If copy to the destination array can overflow [1] and
<i>WantToUseSafeFunctions</i> is set to <i>true</i> and it
is possible to obtain the capacity of the destination array
then the new function could be the safe version (ending with
<b>cpy_s</b>).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If the new function is could be safe version and C++
files are analyzed and the destination array is plain
<b>char</b>/<b>wchar_t</b> without <b>un/signed</b> then the
length of the destination array can be omitted.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If the new function is could be safe version and the
destination array is <b>un/signed</b> it needs to be casted
to plain <b>char *</b>/<b>wchar_t *</b>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>[1] It is possible to
overflow:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>If the capacity of the destination array is unknown.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>If the given length is equal to the destination array's
capacity.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Rewrite
based on the length of the source string</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">If the given length is
<b>strlen(source)</b> or equal length of this expression
then the new function should be the older copy function
(ending with <b>cpy</b>), as it is more efficient than the
safe version (ending with <b>cpy_s</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Otherwise we assume that the programmer wanted to copy
'N' characters, so the new function is
<b>ncpy</b>&minus;like which copies 'N' characters.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Transformations
with 'strlen()' or equal length of this expression</b> <br>
It transforms the <b>wchar_t</b> based memory and string
handler functions respectively (where only <b>strerror_s</b>
does not have <b>wchar_t</b> based alias).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Memory
handler functions <br>
memcpy</b> Please visit the <i>Transformation rules of
'memcpy()'</i> section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>memchr</b>
Usually there is a C&minus;style cast and it is needed to be
removed, because the new function <b>strchr</b>'s return
type is correct. The given length is going to be
removed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>memmove</b>
If safe functions are available the new function is
<b>memmove_s</b>, which has a new second argument which is
the length of the destination array, it is adjusted, and the
length of the source string is incremented by one. If safe
functions are not available the given length is incremented
by one.</p>


<p style="margin-left:11%; margin-top: 1em"><b>memmove_s</b>
The given length is incremented by one.</p>

<p style="margin-left:11%; margin-top: 1em"><b>String
handler functions <br>
strerror_s</b> The given length is incremented by one.</p>

<p style="margin-left:11%; margin-top: 1em"><b>strncmp</b>
If the third argument is the first or the second argument's
<b>length + 1</b> it has to be truncated without the <b>+
1</b> operation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>strxfrm</b>
The given length is incremented by one.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
WantToUseSafeFunctions</b></p>

<p style="margin-left:22%;">The value <i>true</i> specifies
that the target environment is considered to implement '_s'
suffixed memory and string handler functions which are safer
than older versions (e.g. 'memcpy_s()'). The default value
is <i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;parent&minus;virtual&minus;call</b>
<br>
Detects and fixes calls to grand&minus;...parent virtual
methods instead of calls to overridden parent's virtual
methods.</p>
<pre style="margin-left:15%; margin-top: 1em">struct A {
  int virtual foo() {...}
};

struct B: public A {
  int foo() override {...}
};


struct C: public B {
  int foo() override { A::foo(); }
//                     ^^^^^^^^
// warning: qualified name A::foo refers to a member overridden in subclass; did you mean 'B'?  [bugprone&minus;parent&minus;virtual&minus;call]
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;posix&minus;return</b>
<br>
Checks if any calls to <b>pthread_*</b> or <b>posix_*</b>
functions (except <b>posix_openpt</b>) expect negative
return values. These functions return either <b>0</b> on
success or an <b>errno</b> on failure, which is positive
only.</p>

<p style="margin-left:11%; margin-top: 1em">Example buggy
usage looks like:</p>

<pre style="margin-left:15%; margin-top: 1em">if (posix_fadvise(...) &lt; 0) {</pre>


<p style="margin-left:11%; margin-top: 1em">This will never
happen as the return value is always non&minus;negative. A
simple fix could be:</p>

<pre style="margin-left:15%; margin-top: 1em">if (posix_fadvise(...) &gt; 0) {</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;redundant&minus;branch&minus;condition</b>
<br>
Finds condition variables in nested <b>if</b> statements
that were also checked in the outer <b>if</b> statement and
were not changed.</p>

<p style="margin-left:11%; margin-top: 1em">Simple
example:</p>

<pre style="margin-left:15%; margin-top: 1em">bool onFire = isBurning();
if (onFire) {
  if (onFire)
    scream();
}</pre>


<p style="margin-left:11%; margin-top: 1em">Here
<i>onFire</i> is checked both in the outer <b>if</b> and the
inner <b>if</b> statement without a possible change between
the two checks. The check warns for this code and suggests
removal of the second checking of variable
<i>onFire</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The checker
also detects redundant condition checks if the condition
variable is an operand of a logical &quot;and&quot;
(<b>&amp;&amp;</b>) or a logical &quot;or&quot; (<b>||</b>)
operator:</p>
<pre style="margin-left:15%; margin-top: 1em">bool onFire = isBurning();
if (onFire) {
  if (onFire &amp;&amp; peopleInTheBuilding &gt; 0)
    scream();
}

bool onFire = isBurning();
if (onFire) {
  if (onFire || isCollapsing())
    scream();
}</pre>


<p style="margin-left:11%; margin-top: 1em">In the first
case (logical &quot;and&quot;) the suggested fix is to
remove the redundant condition variable and keep the other
side of the <b>&amp;&amp;</b>. In the second case (logical
&quot;or&quot;) the whole <b>if</b> is removed similarly to
the simple case on the top.</p>

<p style="margin-left:11%; margin-top: 1em">The condition
of the outer <b>if</b> statement may also be a logical
&quot;and&quot; (<b>&amp;&amp;</b>) expression:</p>

<pre style="margin-left:15%; margin-top: 1em">bool onFire = isBurning();
if (onFire &amp;&amp; fireFighters &lt; 10) {
  if (someOtherCondition()) {
    if (onFire)
      scream();
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">The error is
also detected if both the outer statement is a logical
&quot;and&quot; (<b>&amp;&amp;</b>) and the inner statement
is a logical &quot;and&quot; (<b>&amp;&amp;</b>) or
&quot;or&quot; (<b>||</b>). The inner <b>if</b> statement
does not have to be a direct descendant of the outer
one.</p>

<p style="margin-left:11%; margin-top: 1em">No error is
detected if the condition variable may have been changed
between the two checks:</p>

<pre style="margin-left:15%; margin-top: 1em">bool onFire = isBurning();
if (onFire) {
  tryToExtinguish(onFire);
  if (onFire &amp;&amp; peopleInTheBuilding &gt; 0)
    scream();
}</pre>


<p style="margin-left:11%; margin-top: 1em">Every possible
change is considered, thus if the condition variable is not
a local variable of the function, it is a volatile or it has
an alias (pointer or reference) then no warning is
issued.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Known
limitations</b> <br>
The <b>else</b> branch is not checked currently for negated
condition variable:</p>

<pre style="margin-left:15%; margin-top: 1em">bool onFire = isBurning();
if (onFire) {
  scream();
} else {
  if (!onFire) {
    continueWork();
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">The checker
currently only detects redundant checking of single
condition variables. More complex expressions are not
checked:</p>

<pre style="margin-left:15%; margin-top: 1em">if (peopleInTheBuilding == 1) {
  if (peopleInTheBuilding == 1) {
    doSomething();
  }
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;reserved&minus;identifier</b>
<i><br>
cert&minus;dcl37&minus;c</i> and
<i>cert&minus;dcl51&minus;cpp</i> redirect here as an alias
for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Checks for
usages of identifiers reserved for use by the
implementation.</p>

<p style="margin-left:11%; margin-top: 1em">The C and C++
standards both reserve the following names for such use:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>identifiers that begin with an underscore followed by an
uppercase letter;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>identifiers in the global namespace that begin with an
underscore.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The C standard
additionally reserves names beginning with a double
underscore, while the C++ standard strengthens this to
reserve names with a double underscore occurring
anywhere.</p>

<p style="margin-left:11%; margin-top: 1em">Violating the
naming rules above results in undefined behavior.</p>

<pre style="margin-left:15%; margin-top: 1em">namespace NS {
  void __f(); // name is not allowed in user code
  using _Int = int; // same with this
  #define cool__macro // also this
}
int _g(); // disallowed in global namespace only</pre>


<p style="margin-left:11%; margin-top: 1em">The check can
also be inverted, i.e. it can be configured to flag any
identifier that is _not_ a reserved identifier. This mode is
for use by e.g. standard library implementors, to ensure
they don't infringe on the user namespace.</p>

<p style="margin-left:11%; margin-top: 1em">This check does
not (yet) check for other reserved names, e.g. macro names
identical to language keywords, and names specifically
reserved by language standards, e.g. C++ 'zombie names' and
C future library directions.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to CERT C Coding Standard rule <i>DCL37&minus;C.
Do not declare or define a reserved identifier</i> as well
as its C++ counterpart, <i>DCL51&minus;CPP. Do not declare
or define a reserved identifier</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Options</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>Invert</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">If <i>true</i>, inverts the
check, i.e. flags names that are not reserved. Default is
<i>false</i>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>AllowedIdentifiers</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of names that the check ignores. Default is an empty
list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;shared&minus;ptr&minus;array&minus;mismatch</b>
<br>
Finds initializations of C++ shared pointers to
non&minus;array type that are initialized with an array.</p>

<p style="margin-left:11%; margin-top: 1em">If a shared
pointer <b>std::shared_ptr&lt;T&gt;</b> is initialized with
a new&minus;expression <b>new T[]</b> the memory is not
deallocated correctly. The pointer uses plain <b>delete</b>
in this case to deallocate the target memory. Instead a
<b>delete[]</b> call is needed. A
<b>std::shared_ptr&lt;T[]&gt;</b> calls the correct delete
operator.</p>

<p style="margin-left:11%; margin-top: 1em">The check
offers replacement of <b>shared_ptr&lt;T&gt;</b> to
<b>shared_ptr&lt;T[]&gt;</b> if it is used at a single
variable declaration (one variable in one statement).</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em">std::shared_ptr&lt;Foo&gt; x(new Foo[10]); // &minus;&gt; std::shared_ptr&lt;Foo[]&gt; x(new Foo[10]);
//                     ^ warning: shared pointer to non&minus;array is initialized with array [bugprone&minus;shared&minus;ptr&minus;array&minus;mismatch]
std::shared_ptr&lt;Foo&gt; x1(new Foo), x2(new Foo[10]); // no replacement
//                                   ^ warning: shared pointer to non&minus;array is initialized with array [bugprone&minus;shared&minus;ptr&minus;array&minus;mismatch]

std::shared_ptr&lt;Foo&gt; x3(new Foo[10], [](const Foo *ptr) { delete[] ptr; }); // no warning


struct S {
  std::shared_ptr&lt;Foo&gt; x(new Foo[10]); // no replacement in this case
  //                     ^ warning: shared pointer to non&minus;array is initialized with array [bugprone&minus;shared&minus;ptr&minus;array&minus;mismatch]
};</pre>


<p style="margin-left:11%; margin-top: 1em">This check
partially covers the CERT C++ Coding Standard rule
<i>MEM51&minus;CPP. Properly deallocate dynamically
allocated resources</i> However, only the
<b>std::shared_ptr</b> case is detected by this check.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;signal&minus;handler</b>
<br>
Finds functions registered as signal handlers that call non
asynchronous&minus;safe functions. Any function that cannot
be determined to be an asynchronous&minus;safe function call
is assumed to be non&minus;asynchronous&minus;safe by the
checker, including user functions for which only the
declaration is visible. User function calls with visible
definition are checked recursively. The check handles only C
code. Only the function names are considered and the fact
that the function is a system&minus;call, but no other
restrictions on the arguments passed to the functions (the
<b>signal</b> call is allowed without restrictions).</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule
<i>SIG30&minus;C. Call only asynchronous&minus;safe
functions within signal handlers</i> and has an alias name
<b>cert&minus;sig30&minus;c</b>. <b><br>
AsyncSafeFunctionSet</b></p>

<p style="margin-left:22%;">Selects which set of functions
is considered as asynchronous&minus;safe (and therefore
allowed in signal handlers). Value <b>minimal</b> selects a
minimal set that is defined in the CERT SIG30&minus;C rule
and includes functions <b>abort()</b>, <b>_Exit()</b>,
<b>quick_exit()</b> and <b>signal()</b>. Value <b>POSIX</b>
selects a larger set of functions that is listed in
POSIX.1&minus;2017 (see <i>this link</i> for more
information). The function <b>quick_exit</b> is not included
in the shown list. It is assumable that the reason is that
the list was not updated for C11. The checker includes
<b>quick_exit</b> in the set of safe functions. Functions
registered as exit handlers are not checked.</p>

<p style="margin-left:22%; margin-top: 1em">Default is
<b>POSIX</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;signed&minus;char&minus;misuse</b>
<i><br>
cert&minus;str34&minus;c</i> redirects here as an alias for
this check. For the CERT alias, the
<i>DiagnoseSignedUnsignedCharComparisons</i> option is set
to <i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Finds those
<b>signed char</b> &minus;&gt; integer conversions which
might indicate a programming error. The basic problem with
the <b>signed char</b>, that it might store the
non&minus;ASCII characters as negative values. This behavior
can cause a misunderstanding of the written code both when
an explicit and when an implicit conversion happens.</p>

<p style="margin-left:11%; margin-top: 1em">When the code
contains an explicit <b>signed char</b> &minus;&gt; integer
conversion, the human programmer probably expects that the
converted value matches with the character code (a value
from [0..255]), however, the actual value is in
[&minus;128..127] interval. To avoid this kind of
misinterpretation, the desired way of converting from a
<b>signed char</b> to an integer value is converting to
<b>unsigned char</b> first, which stores all the characters
in the positive [0..255] interval which matches the known
character codes.</p>

<p style="margin-left:11%; margin-top: 1em">In case of
implicit conversion, the programmer might not actually be
aware that a conversion happened and char value is used as
an integer. There are some use cases when this unawareness
might lead to a functionally imperfect code. For example,
checking the equality of a <b>signed char</b> and an
<b>unsigned char</b> variable is something we should avoid
in C++ code. During this comparison, the two variables are
converted to integers which have different value ranges. For
<b>signed char</b>, the non&minus;ASCII characters are
stored as a value in [&minus;128..&minus;1] interval, while
the same characters are stored in the [128..255] interval
for an <b>unsigned char</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It depends on
the actual platform whether plain <b>char</b> is handled as
<b>signed char</b> by default and so it is caught by this
check or not. To change the default behavior you can use
<b>&minus;funsigned&minus;char</b> and
<b>&minus;fsigned&minus;char</b> compilation options.</p>

<p style="margin-left:11%; margin-top: 1em">Currently, this
check warns in the following cases: &minus; <b>signed
char</b> is assigned to an integer variable &minus;
<b>signed char</b> and <b>unsigned char</b> are compared
with equality/inequality operator &minus; <b>signed char</b>
is converted to an integer in the array subscript</p>

<p style="margin-left:11%; margin-top: 1em">See also:
<i>STR34&minus;C. Cast characters to unsigned char before
converting to larger integer sizes</i></p>

<p style="margin-left:11%; margin-top: 1em">A good example
from the CERT description when a <b>char</b> variable is
used to read from a file that might contain non&minus;ASCII
characters. The problem comes up when the code uses the
<b>&minus;1</b> integer value as EOF, while the 255
character code is also stored as <b>&minus;1</b> in two's
complement form of char type. See a simple example of this
bellow. This code stops not only when it reaches the end of
the file, but also when it gets a character with the 255
code.</p>
<pre style="margin-left:15%; margin-top: 1em">#define EOF (&minus;1)

int read(void) {
  char CChar;
  int IChar = EOF;


  if (readChar(CChar)) {
    IChar = CChar;
  }
  return IChar;
}</pre>


<p style="margin-left:11%; margin-top: 1em">A proper way to
fix the code above is converting the <b>char</b> variable to
an <b>unsigned char</b> value first.</p>
<pre style="margin-left:15%; margin-top: 1em">#define EOF (&minus;1)

int read(void) {
  char CChar;
  int IChar = EOF;


  if (readChar(CChar)) {
    IChar = static_cast&lt;unsigned char&gt;(CChar);
  }
  return IChar;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Another use
case is checking the equality of two <b>char</b> variables
with different signedness. Inside the non&minus;ASCII value
range this comparison between a <b>signed char</b> and an
<b>unsigned char</b> always returns <b>false</b>.</p>

<pre style="margin-left:15%; margin-top: 1em">bool compare(signed char SChar, unsigned char USChar) {
  if (SChar == USChar)
    return true;
  return false;
}</pre>


<p style="margin-left:11%; margin-top: 1em">The easiest way
to fix this kind of comparison is casting one of the
arguments, so both arguments will have the same type.</p>

<pre style="margin-left:15%; margin-top: 1em">bool compare(signed char SChar, unsigned char USChar) {
  if (static_cast&lt;unsigned char&gt;(SChar) == USChar)
    return true;
  return false;
}</pre>


<p style="margin-left:11%;"><b>CharTypdefsToIgnore</b></p>

<p style="margin-left:22%;">A semicolon&minus;separated
list of typedef names. In this list, we can list typedefs
for <b>char</b> or <b>signed char</b>, which will be ignored
by the check. This is useful when a typedef introduces an
integer alias like <b>sal_Int8</b> or <b>int8_t</b>. In this
case, human misinterpretation is not an issue.</p>


<p style="margin-left:11%;"><b>DiagnoseSignedUnsignedCharComparisons</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on <b>signed char</b>/<b>unsigned char</b>
comparisons, otherwise these comparisons are ignored. By
default, this option is set to <i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;sizeof&minus;container</b>
<br>
The check finds usages of <b>sizeof</b> on expressions of
STL container types. Most likely the user wanted to use
<b>.size()</b> instead.</p>

<p style="margin-left:11%; margin-top: 1em">All
class/struct types declared in namespace <b>std::</b> having
a const <b>size()</b> method are considered containers, with
the exception of <b>std::bitset</b> and
<b>std::array</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">std::string s;
int a = 47 + sizeof(s); // warning: sizeof() doesn't return the size of the container. Did you mean .size()?

int b = sizeof(std::string); // no warning, probably intended.

std::string array_of_strings[10];
int c = sizeof(array_of_strings) / sizeof(array_of_strings[0]); // no warning, definitely intended.


std::array&lt;int, 3&gt; std_array;
int d = sizeof(std_array); // no warning, probably intended.</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;sizeof&minus;expression</b>
<br>
The check finds usages of <b>sizeof</b> expressions which
are most likely errors.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>sizeof</b> operator yields the size (in bytes) of its
operand, which may be an expression or the parenthesized
name of a type. Misuse of this operator may be leading to
errors and possible software vulnerabilities.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Suspicious
usage of 'sizeof(K)'</b> <br>
A common mistake is to query the <b>sizeof</b> of an integer
literal. This is equivalent to query the size of its type
(probably <b>int</b>). The intent of the programmer was
probably to simply get the integer and not its size.</p>

<pre style="margin-left:15%; margin-top: 1em">#define BUFLEN 42
char buf[BUFLEN];
memset(buf, 0, sizeof(BUFLEN));  // sizeof(42) ==&gt; sizeof(int)</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Suspicious
usage of 'sizeof(expr)'</b> <br>
In cases, where there is an enum or integer to represent a
type, a common mistake is to query the <b>sizeof</b> on the
integer or enum that represents the type that should be used
by <b>sizeof</b>. This results in the size of the integer
and not of the type the integer represents:</p>
<pre style="margin-left:15%; margin-top: 1em">enum data_type {
  FLOAT_TYPE,
  DOUBLE_TYPE
};

struct data {
  data_type type;
  void* buffer;
  data_type get_type() {
    return type;
  }
};


void f(data d, int numElements) {
  // should be sizeof(float) or sizeof(double), depending on d.get_type()
  int numBytes = numElements * sizeof(d.get_type());
  ...
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Suspicious
usage of 'sizeof(this)'</b> <br>
The <b>this</b> keyword is evaluated to a pointer to an
object of a given type. The expression <b>sizeof(this)</b>
is returning the size of a pointer. The programmer most
likely wanted the size of the object and not the size of the
pointer.</p>

<pre style="margin-left:15%; margin-top: 1em">class Point {
  [...]
  size_t size() { return sizeof(this); }  // should probably be sizeof(*this)
  [...]
};</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Suspicious
usage of 'sizeof(char*)'</b> <br>
There is a subtle difference between declaring a string
literal with <b>char* A = &quot;&quot;</b> and <b>char A[] =
&quot;&quot;</b>. The first case has the type <b>char*</b>
instead of the aggregate type <b>char[]</b>. Using
<b>sizeof</b> on an object declared with <b>char*</b> type
is returning the size of a pointer instead of the number of
characters (bytes) in the string literal.</p>

<pre style="margin-left:15%; margin-top: 1em">const char* kMessage = &quot;Hello World!&quot;;      // const char kMessage[] = &quot;...&quot;;
void getMessage(char* buf) {
  memcpy(buf, kMessage, sizeof(kMessage));  // sizeof(char*)
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Suspicious
usage of 'sizeof(A*)'</b> <br>
A common mistake is to compute the size of a pointer instead
of its pointee. These cases may occur because of explicit
cast or implicit conversion.</p>
<pre style="margin-left:15%; margin-top: 1em">int A[10];
memset(A, 0, sizeof(A + 0));


struct Point point;
memset(point, 0, sizeof(&amp;point));</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Suspicious
usage of 'sizeof(...)/sizeof(...)'</b> <br>
Dividing <b>sizeof</b> expressions is typically used to
retrieve the number of elements of an aggregate. This check
warns on incompatible or suspicious cases.</p>

<p style="margin-left:11%; margin-top: 1em">In the
following example, the entity has 10&minus;bytes and is
incompatible with the type <b>int</b> which has 4 bytes.</p>

<pre style="margin-left:15%; margin-top: 1em">char buf[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };  // sizeof(buf) =&gt; 10
void getMessage(char* dst) {
  memcpy(dst, buf, sizeof(buf) / sizeof(int));  // sizeof(int) =&gt; 4  [incompatible sizes]
}</pre>


<p style="margin-left:11%; margin-top: 1em">In the
following example, the expression <b>sizeof(Values)</b> is
returning the size of <b>char*</b>. One can easily be fooled
by its declaration, but in parameter declaration the size
'10' is ignored and the function is receiving a
<b>char*</b>.</p>

<pre style="margin-left:15%; margin-top: 1em">char OrderedValues[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
return CompareArray(char Values[10]) {
  return memcmp(OrderedValues, Values, sizeof(Values)) == 0;  // sizeof(Values) ==&gt; sizeof(char*) [implicit cast to char*]
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Suspicious
'sizeof' by 'sizeof' expression</b> <br>
Multiplying <b>sizeof</b> expressions typically makes no
sense and is probably a logic error. In the following
example, the programmer used <b>*</b> instead of
<b>/</b>.</p>

<pre style="margin-left:15%; margin-top: 1em">const char kMessage[] = &quot;Hello World!&quot;;
void getMessage(char* buf) {
  memcpy(buf, kMessage, sizeof(kMessage) * sizeof(char));  //  sizeof(kMessage) / sizeof(char)
}</pre>


<p style="margin-left:11%; margin-top: 1em">This check may
trigger on code using the arraysize macro. The following
code is working correctly but should be simplified by using
only the <b>sizeof</b> operator.</p>

<pre style="margin-left:15%; margin-top: 1em">extern Object objects[100];
void InitializeObjects() {
  memset(objects, 0, arraysize(objects) * sizeof(Object));  // sizeof(objects)
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Suspicious
usage of 'sizeof(sizeof(...))'</b> <br>
Getting the <b>sizeof</b> of a <b>sizeof</b> makes no sense
and is typically an error hidden through macros.</p>

<pre style="margin-left:15%; margin-top: 1em">#define INT_SZ sizeof(int)
int buf[] = { 42 };
void getInt(int* dst) {
  memcpy(dst, buf, sizeof(INT_SZ));  // sizeof(sizeof(int)) is suspicious.
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
WarnOnSizeOfConstant</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on an expression like <b>sizeof(CONSTANT)</b>.
Default is <i>true</i>.</p>


<p style="margin-left:11%;"><b>WarnOnSizeOfIntegerExpression</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on an expression like <b>sizeof(expr)</b> where
the expression results in an integer. Default is
<i>false</i>.</p>

<p style="margin-left:11%;"><b>WarnOnSizeOfThis</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on an expression like <b>sizeof(this)</b>. Default
is <i>true</i>.</p>


<p style="margin-left:11%;"><b>WarnOnSizeOfCompareToConstant</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on an expression like <b>sizeof(expr) &lt;= k</b>
for a suspicious constant <i>k</i> while <i>k</i> is
<i>0</i> or greater than <i>0x8000</i>. Default is
<i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;spuriously&minus;wake&minus;up&minus;functions</b>
<br>
Finds <b>cnd_wait</b>, <b>cnd_timedwait</b>, <b>wait</b>,
<b>wait_for</b>, or <b>wait_until</b> function calls when
the function is not invoked from a loop that checks whether
a condition predicate holds or the function has a condition
parameter.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>CON54&minus;CPP. Wrap functions that can spuriously wake
up in a loop</i>. and CERT C Coding Standard rule
<i>CON36&minus;C. Wrap functions that can spuriously wake up
in a loop</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;string&minus;constructor</b>
<br>
Finds string constructors that are suspicious and probably
errors.</p>

<p style="margin-left:11%; margin-top: 1em">A common
mistake is to swap parameters to the 'fill'
string&minus;constructor.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string str('x', 50); // should be str(50, 'x')</pre>


<p style="margin-left:11%; margin-top: 1em">Calling the
string&minus;literal constructor with a length bigger than
the literal is suspicious and adds extra random characters
to the string.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string(&quot;test&quot;, 200);   // Will include random characters after &quot;test&quot;.
std::string_view(&quot;test&quot;, 200);</pre>


<p style="margin-left:11%; margin-top: 1em">Creating an
empty string from constructors with parameters is considered
suspicious. The programmer should use the empty constructor
instead.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string(&quot;test&quot;, 0);   // Creation of an empty string.
std::string_view(&quot;test&quot;, 0);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
WarnOnLargeLength</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on a string with a length greater than
<i>LargeLengthThreshold</i>. Default is <i>true</i>.</p>


<p style="margin-left:11%;"><b>LargeLengthThreshold</b></p>

<p style="margin-left:22%;">An integer specifying the large
length threshold. Default is <i>0x800000</i>.</p>

<p style="margin-left:11%;"><b>StringNames</b></p>

<p style="margin-left:22%;">Default is
<i>::std::basic_string;::std::basic_string_view</i>.</p>


<p style="margin-left:22%; margin-top: 1em">Semicolon&minus;delimited
list of class names to apply this check to. By default
<i>::std::basic_string</i> applies to <b>std::string</b> and
<b>std::wstring</b>. Set to e.g.
<i>::std::basic_string;llvm::StringRef;QString</i> to
perform this check on custom classes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;string&minus;integer&minus;assignment</b>
<br>
The check finds assignments of an integer to
<b>std::basic_string&lt;CharT&gt;</b> (<b>std::string</b>,
<b>std::wstring</b>, etc.). The source of the problem is the
following assignment operator of
<b>std::basic_string&lt;CharT&gt;</b>:</p>

<pre style="margin-left:15%; margin-top: 1em">basic_string&amp; operator=( CharT ch );</pre>


<p style="margin-left:11%; margin-top: 1em">Numeric types
can be implicitly casted to character types.</p>

<pre style="margin-left:15%; margin-top: 1em">std::string s;
int x = 5965;
s = 6;
s = x;</pre>


<p style="margin-left:11%; margin-top: 1em">Use the
appropriate conversion functions or character literals.</p>

<pre style="margin-left:15%; margin-top: 1em">std::string s;
int x = 5965;
s = '6';
s = std::to_string(x);</pre>


<p style="margin-left:11%; margin-top: 1em">In order to
suppress false positives, use an explicit cast.</p>

<pre style="margin-left:15%; margin-top: 1em">std::string s;
s = static_cast&lt;char&gt;(6);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;string&minus;literal&minus;with&minus;embedded&minus;nul</b>
<br>
Finds occurrences of string literal with embedded NUL
character and validates their usage.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Invalid
escaping</b> <br>
Special characters can be escaped within a string literal by
using their hexadecimal encoding like <b>\x42</b>. A common
mistake is to escape them like this <b>\0x42</b> where the
<b>\0</b> stands for the NUL character.</p>

<pre style="margin-left:15%; margin-top: 1em">const char* Example[] = &quot;Invalid character: \0x12 should be \x12&quot;;
const char* Bytes[] = &quot;\x03\0x02\0x01\0x00\0xFF\0xFF\0xFF&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Truncated
literal</b> <br>
String&minus;like classes can manipulate strings with
embedded NUL as they are keeping track of the bytes and the
length. This is not the case for a <b>char*</b>
(NUL&minus;terminated) string.</p>

<p style="margin-left:11%; margin-top: 1em">A common
mistake is to pass a string&minus;literal with embedded NUL
to a string constructor expecting a NUL&minus;terminated
string. The bytes after the first NUL character are
truncated.</p>

<pre style="margin-left:15%; margin-top: 1em">std::string str(&quot;abc\0def&quot;);  // &quot;def&quot; is truncated
str += &quot;\0&quot;;                  // This statement is doing nothing
if (str == &quot;\0abc&quot;) return;   // This expression is always true</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;stringview&minus;nullptr</b>
<br>
Checks for various ways that the <b>const CharT*</b>
constructor of <b>std::basic_string_view</b> can be passed a
null argument and replaces them with the default constructor
in most cases. For the comparison operators, braced
initializer list does not compile so instead a call to
<b>.empty()</b> or the empty string literal are used, where
appropriate.</p>

<p style="margin-left:11%; margin-top: 1em">This prevents
code from invoking behavior which is unconditionally
undefined. The single&minus;argument <b>const CharT*</b>
constructor does not check for the null case before
dereferencing its input. The standard is slated to add an
explicitly&minus;deleted overload to catch some of these
cases: wg21.link/p2166</p>

<p style="margin-left:11%; margin-top: 1em">To catch the
additional cases of <b>NULL</b> (which expands to
<b>__null</b>) and <b>0</b>, first run the
<b>modernize&minus;use&minus;nullptr</b> check to convert
the callers to <b>nullptr</b>.</p>
<pre style="margin-left:15%; margin-top: 1em">std::string_view sv = nullptr;

sv = nullptr;

bool is_empty = sv == nullptr;
bool isnt_empty = sv != nullptr;

accepts_sv(nullptr);

accepts_sv({{}});  // A

accepts_sv({nullptr, 0});  // B</pre>

<p style="margin-left:11%; margin-top: 1em">is translated
into...</p>
<pre style="margin-left:15%; margin-top: 1em">std::string_view sv = {};

sv = {};

bool is_empty = sv.empty();
bool isnt_empty = !sv.empty();

accepts_sv(&quot;&quot;);

accepts_sv(&quot;&quot;);  // A

accepts_sv({nullptr, 0});  // B</pre>


<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">The source pattern with
trailing comment &quot;A&quot; selects the <b>(const
CharT*)</b> constructor overload and then
value&minus;initializes the pointer, causing a null
dereference. It happens to not include the <b>nullptr</b>
literal, but it is still within the scope of this ClangTidy
check.</p>


<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">The source pattern with
trailing comment &quot;B&quot; selects the <b>(const CharT*,
size_type)</b> constructor which is perfectly valid, since
the length argument is <b>0</b>. It is not changed by this
ClangTidy check.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;suspicious&minus;enum&minus;usage</b>
<br>
The checker detects various cases when an enum is probably
misused (as a bitmask ).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>When &quot;ADD&quot; or &quot;bitwise OR&quot; is used
between two enum which come from different types and these
types value ranges are not disjoint.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
cases will be investigated only using <i>StrictMode</i>. We
regard the enum as a (suspicious) bitmask if the three
conditions below are true at the same time:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">at most half of the elements of
the enum are non pow&minus;of&minus;2 numbers (because of
short enumerations)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>there is another non pow&minus;of&minus;2 number than
the enum constant representing all choices (the result
&quot;bitwise OR&quot; operation of all enum elements)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>enum type variable/enumconstant is used as an argument
of a <i>+</i> or &quot;bitwise OR &quot; operator</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">So whenever the
non pow&minus;of&minus;2 element is used as a bitmask
element we diagnose a misuse and give a warning.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">Investigating the right hand
side of <i>+=</i> and <i>|=</i> operator.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>Check only the enum value side of a <i>|</i> and
<i>+</i> operator if one of them is not enum val.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="85%">


<p>Check both side of <i>|</i> or <i>+</i> operator where
the enum values are from the same enum type.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">enum { A, B, C };
enum { D, E, F = 5 };
enum { G = 10, H = 11, I = 12 };

unsigned flag;
flag =
    A |
    H; // OK, disjoint value intervals in the enum types &minus;&gt;probably good use.
flag = B | F; // Warning, have common values so they are probably misused.

// Case 2:
enum Bitmask {
  A = 0,
  B = 1,
  C = 2,
  D = 4,
  E = 8,
  F = 16,
  G = 31 // OK, real bitmask.
};

enum Almostbitmask {
  AA = 0,
  BB = 1,
  CC = 2,
  DD = 4,
  EE = 8,
  FF = 16,
  GG // Problem, forgot to initialize.
};


unsigned flag = 0;
flag |= E; // OK.
flag |=
    EE; // Warning at the decl, and note that it was used here as a bitmask.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
StrictMode</b></p>

<p style="margin-left:22%;">Default value: 0. When
non&minus;null the suspicious bitmask usage will be
investigated additionally to the different enum usage
check.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;suspicious&minus;include</b>
<br>
The check detects various cases when an include refers to
what appears to be an implementation file, which often leads
to hard&minus;to&minus;track&minus;down ODR violations.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">#include &quot;Dinosaur.hpp&quot;     // OK, .hpp files tend not to have definitions.
#include &quot;Pterodactyl.h&quot;    // OK, .h files tend not to have definitions.
#include &quot;Velociraptor.cpp&quot; // Warning, filename is suspicious.
#include_next &lt;stdio.c&gt;     // Warning, filename is suspicious.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
HeaderFileExtensions</b></p>

<p style="margin-left:22%;">Default value:
<b>&quot;;h;hh;hpp;hxx&quot;</b> A semicolon&minus;separated
list of filename extensions of header files (the filename
extensions should not contain a &quot;.&quot; prefix). For
extension&minus;less header files, use an empty string or
leave an empty string between &quot;;&quot; if there are
other filename extensions.</p>


<p style="margin-left:11%;"><b>ImplementationFileExtensions</b></p>

<p style="margin-left:22%;">Default value:
<b>&quot;c;cc;cpp;cxx&quot;</b> Likewise, a
semicolon&minus;separated list of filename extensions of
implementation files.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;suspicious&minus;memory&minus;comparison</b>
<br>
Finds potentially incorrect calls to <b>memcmp()</b> based
on properties of the arguments. The following cases are
covered:</p>

<p style="margin-left:11%; margin-top: 1em"><b>Case 1:
Non&minus;standard&minus;layout type</b></p>

<p style="margin-left:11%; margin-top: 1em">Comparing the
object representations of non&minus;standard&minus;layout
objects may not properly compare the value
representations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Case 2:
Types with no unique object representation</b></p>

<p style="margin-left:11%; margin-top: 1em">Objects with
the same value may not have the same object representation.
This may be caused by padding or floating&minus;point
types.</p>

<p style="margin-left:11%; margin-top: 1em">See also:
<i>EXP42&minus;C. Do not compare padding data</i> and
<i>FLP37&minus;C. Do not use object representations to
compare floating&minus;point values</i></p>

<p style="margin-left:11%; margin-top: 1em">This check is
also related to and partially overlaps the CERT C++ Coding
Standard rules <i>OOP57&minus;CPP. Prefer special member
functions and overloaded operators to C Standard Library
functions</i> and <i>EXP62&minus;CPP. Do not access the bits
of an object representation that are not part of the
object's value representation</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;suspicious&minus;memset&minus;usage</b>
<br>
This check finds <b>memset()</b> calls with potential
mistakes in their arguments. Considering the function as
<b>void* memset(void* destination, int fill_value, size_t
byte_count)</b>, the following cases are covered:</p>

<p style="margin-left:11%; margin-top: 1em"><b>Case 1: Fill
value is a character ``'0'``</b></p>

<p style="margin-left:11%; margin-top: 1em">Filling up a
memory area with ASCII code 48 characters is not customary,
possibly integer zeroes were intended instead. The check
offers a replacement of <b>'0'</b> with <b>0</b>. Memsetting
character pointers with <b>'0'</b> is allowed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Case 2: Fill
value is truncated</b></p>

<p style="margin-left:11%; margin-top: 1em">Memset converts
<b>fill_value</b> to <b>unsigned char</b> before using it.
If <b>fill_value</b> is out of unsigned character range, it
gets truncated and memory will not contain the desired
pattern.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Case 3: Byte
count is zero</b></p>

<p style="margin-left:11%; margin-top: 1em">Calling memset
with a literal zero in its <b>byte_count</b> argument is
likely to be unintended and swapped with <b>fill_value</b>.
The check offers to swap these two arguments.</p>

<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check name: <b>runtime/memset</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo() {
  int i[5] = {1, 2, 3, 4, 5};
  int *ip = i;
  char c = '1';
  char *cp = &amp;c;
  int v = 0;

  // Case 1
  memset(ip, '0', 1); // suspicious
  memset(cp, '0', 1); // OK

  // Case 2
  memset(ip, 0xabcd, 1); // fill value gets truncated
  memset(ip, 0x00, 1);   // OK


  // Case 3
  memset(ip, sizeof(int), v); // zero length, potentially swapped
  memset(ip, 0, 1);           // OK
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;suspicious&minus;missing&minus;comma</b>
<br>
String literals placed side&minus;by&minus;side are
concatenated at translation phase 6 (after the
preprocessor). This feature is used to represent long string
literal on multiple lines.</p>

<p style="margin-left:11%; margin-top: 1em">For instance,
the following declarations are equivalent:</p>

<pre style="margin-left:15%; margin-top: 1em">const char* A[] = &quot;This is a test&quot;;
const char* B[] = &quot;This&quot; &quot; is a &quot;    &quot;test&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">A common
mistake done by programmers is to forget a comma between two
string literals in an array initializer list.</p>

<pre style="margin-left:15%; margin-top: 1em">const char* Test[] = {
  &quot;line 1&quot;,
  &quot;line 2&quot;     // Missing comma!
  &quot;line 3&quot;,
  &quot;line 4&quot;,
  &quot;line 5&quot;
};</pre>


<p style="margin-left:11%; margin-top: 1em">The array
contains the string &quot;line 2line3&quot; at offset 1
(i.e. Test[1]). Clang won't generate warnings at compile
time.</p>

<p style="margin-left:11%; margin-top: 1em">This check may
warn incorrectly on cases like:</p>

<pre style="margin-left:15%; margin-top: 1em">const char* SupportedFormat[] = {
  &quot;Error %s&quot;,
  &quot;Code &quot; PRIu64,   // May warn here.
  &quot;Warning %s&quot;,
};</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
SizeThreshold</b></p>

<p style="margin-left:22%;">An unsigned integer specifying
the minimum size of a string literal to be considered by the
check. Default is <b>5U</b>.</p>

<p style="margin-left:11%;"><b>RatioThreshold</b></p>

<p style="margin-left:22%;">A string specifying the maximum
threshold ratio [0, 1.0] of suspicious string literals to be
considered. Default is <b>&quot;.2&quot;</b>.</p>


<p style="margin-left:11%;"><b>MaxConcatenatedTokens</b></p>

<p style="margin-left:22%;">An unsigned integer specifying
the maximum number of concatenated tokens. Default is
<b>5U</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;suspicious&minus;semicolon</b>
<br>
Finds most instances of stray semicolons that unexpectedly
alter the meaning of the code. More specifically, it looks
for <b>if</b>, <b>while</b>, <b>for</b> and
<b>for&minus;range</b> statements whose body is a single
semicolon, and then analyzes the context of the code (e.g.
indentation) in an attempt to determine whether that is
intentional.</p>

<pre style="margin-left:15%; margin-top: 1em">if (x &lt; y);
{
  x++;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Here the body
of the <b>if</b> statement consists of only the semicolon at
the end of the first line, and <i>x</i> will be incremented
regardless of the condition.</p>

<pre style="margin-left:15%; margin-top: 1em">while ((line = readLine(file)) != NULL);
  processLine(line);</pre>


<p style="margin-left:11%; margin-top: 1em">As a result of
this code, <i>processLine()</i> will only be called once,
when the <b>while</b> loop with the empty body exits with
<i>line == NULL</i>. The indentation of the code indicates
the intention of the programmer.</p>

<pre style="margin-left:15%; margin-top: 1em">if (x &gt;= y);
x &minus;= y;</pre>


<p style="margin-left:11%; margin-top: 1em">While the
indentation does not imply any nesting, there is simply no
valid reason to have an <i>if</i> statement with an empty
body (but it can make sense for a loop). So this check
issues a warning for the code above.</p>

<p style="margin-left:11%; margin-top: 1em">To solve the
issue remove the stray semicolon or in case the empty body
is intentional, reflect this using code indentation or put
the semicolon in a new line. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">while (readWhitespace());
  Token t = readNextToken();</pre>


<p style="margin-left:11%; margin-top: 1em">Here the second
line is indented in a way that suggests that it is meant to
be the body of the <i>while</i> loop &minus; whose body is
in fact empty, because of the semicolon at the end of the
first line.</p>

<p style="margin-left:11%; margin-top: 1em">Either remove
the indentation from the second line:</p>

<pre style="margin-left:15%; margin-top: 1em">while (readWhitespace());
Token t = readNextToken();</pre>


<p style="margin-left:11%; margin-top: 1em">... or move the
semicolon from the end of the first line to a new line:</p>
<pre style="margin-left:15%; margin-top: 1em">while (readWhitespace())
  ;

  Token t = readNextToken();</pre>

<p style="margin-left:11%; margin-top: 1em">In this case
the check will assume that you know what you are doing, and
will not raise a warning.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;suspicious&minus;string&minus;compare</b>
<br>
Find suspicious usage of runtime string comparison
functions. This check is valid in C and C++.</p>

<p style="margin-left:11%; margin-top: 1em">Checks for
calls with implicit comparator and proposed to explicitly
add it.</p>

<pre style="margin-left:15%; margin-top: 1em">if (strcmp(...))       // Implicitly compare to zero
if (!strcmp(...))      // Won't warn
if (strcmp(...) != 0)  // Won't warn</pre>


<p style="margin-left:11%; margin-top: 1em">Checks that
compare function results (i.e., <b>strcmp</b>) are compared
to valid constant. The resulting value is</p>

<pre style="margin-left:15%; margin-top: 1em">&lt;  0    when lower than,
&gt;  0    when greater than,
== 0    when equals.</pre>


<p style="margin-left:11%; margin-top: 1em">A common
mistake is to compare the result to <i>1</i> or
<i>&minus;1</i>.</p>

<pre style="margin-left:15%; margin-top: 1em">if (strcmp(...) == &minus;1)  // Incorrect usage of the returned value.</pre>


<p style="margin-left:11%; margin-top: 1em">Additionally,
the check warns if the results value is implicitly cast to a
<i>suspicious</i> non&minus;integer type. It's happening
when the returned value is used in a wrong context.</p>

<pre style="margin-left:15%; margin-top: 1em">if (strcmp(...) &lt; 0.)  // Incorrect usage of the returned value.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
WarnOnImplicitComparison</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on implicit comparison. <i>true</i> by
default.</p>


<p style="margin-left:11%;"><b>WarnOnLogicalNotComparison</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on logical not comparison. <i>false</i> by
default.</p>


<p style="margin-left:11%;"><b>StringCompareLikeFunctions</b></p>

<p style="margin-left:22%;">A string specifying the
comma&minus;separated names of the extra string comparison
functions. Default is an empty string. The check will detect
the following string comparison functions:
<i>__builtin_memcmp</i>, <i>__builtin_strcasecmp</i>,
<i>__builtin_strcmp</i>, <i>__builtin_strncasecmp</i>,
<i>__builtin_strncmp</i>, <i>_mbscmp</i>, <i>_mbscmp_l</i>,
<i>_mbsicmp</i>, <i>_mbsicmp_l</i>, <i>_mbsnbcmp</i>,
<i>_mbsnbcmp_l</i>, <i>_mbsnbicmp</i>, <i>_mbsnbicmp_l</i>,
<i>_mbsncmp</i>, <i>_mbsncmp_l</i>, <i>_mbsnicmp</i>,
<i>_mbsnicmp_l</i>, <i>_memicmp</i>, <i>_memicmp_l</i>,
<i>_stricmp</i>, <i>_stricmp_l</i>, <i>_strnicmp</i>,
<i>_strnicmp_l</i>, <i>_wcsicmp</i>, <i>_wcsicmp_l</i>,
<i>_wcsnicmp</i>, <i>_wcsnicmp_l</i>, <i>lstrcmp</i>,
<i>lstrcmpi</i>, <i>memcmp</i>, <i>memicmp</i>,
<i>strcasecmp</i>, <i>strcmp</i>, <i>strcmpi</i>,
<i>stricmp</i>, <i>strncasecmp</i>, <i>strncmp</i>,
<i>strnicmp</i>, <i>wcscasecmp</i>, <i>wcscmp</i>,
<i>wcsicmp</i>, <i>wcsncmp</i>, <i>wcsnicmp</i>,
<i>wmemcmp</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;swapped&minus;arguments</b>
<br>
Finds potentially swapped arguments by looking at implicit
conversions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;terminating&minus;continue</b>
<br>
Detects <b>do while</b> loops with a condition always
evaluating to false that have a <b>continue</b> statement,
as this <b>continue</b> terminates the loop effectively.</p>

<pre style="margin-left:15%; margin-top: 1em">void f() {
do {
  // some code
  continue; // terminating continue
  // some other code
} while(false);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;throw&minus;keyword&minus;missing</b>
<br>
Warns about a potentially missing <b>throw</b> keyword. If a
temporary object is created, but the object's type derives
from (or is the same as) a class that has 'EXCEPTION',
'Exception' or 'exception' in its name, we can assume that
the programmer's intention was to throw that object.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(int i) {
  if (i &lt; 0) {
    // Exception is created but is not thrown.
    std::runtime_error(&quot;Unexpected argument&quot;);
  }
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;too&minus;small&minus;loop&minus;variable</b>
<br>
Detects those <b>for</b> loops that have a loop variable
with a &quot;too small&quot; type which means this type
can't represent all values which are part of the iteration
range.</p>

<pre style="margin-left:15%; margin-top: 1em">int main() {
  long size = 294967296l;
  for (short i = 0; i &lt; size; ++i) {}
}</pre>


<p style="margin-left:11%; margin-top: 1em">This <b>for</b>
loop is an infinite loop because the <b>short</b> type can't
represent all values in the <b>[0..size]</b> interval.</p>

<p style="margin-left:11%; margin-top: 1em">In a real use
case size means a container's size which depends on the user
input.</p>

<pre style="margin-left:15%; margin-top: 1em">int doSomething(const std::vector&amp; items) {
  for (short i = 0; i &lt; items.size(); ++i) {}
}</pre>


<p style="margin-left:11%; margin-top: 1em">This algorithm
works for a small amount of objects, but will lead to freeze
for a larger user input. <b><br>
MagnitudeBitsUpperLimit</b></p>

<p style="margin-left:22%;">Upper limit for the magnitude
bits of the loop variable. If it's set the check filters out
those catches in which the loop variable's type has more
magnitude bits as the specified upper limit. The default
value is 16. For example, if the user sets this option to 31
(bits), then a 32&minus;bit <b>unsigned int</b> is ignored
by the check, however a 32&minus;bit <b>int</b> is not (A
32&minus;bit <b>signed int</b> has 31 magnitude bits).</p>

<pre style="margin-left:15%; margin-top: 1em">int main() {
  long size = 294967296l;
  for (unsigned i = 0; i &lt; size; ++i) {} // no warning with MagnitudeBitsUpperLimit = 31 on a system where unsigned is 32&minus;bit
  for (int i = 0; i &lt; size; ++i) {} // warning with MagnitudeBitsUpperLimit = 31 on a system where int is 32&minus;bit
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;unchecked&minus;optional&minus;access</b>
<i><br>
Note</i>: This check uses a flow&minus;sensitive static
analysis to produce its results. Therefore, it may be more
resource intensive (RAM, CPU) than the average
clang&minus;tidy check.</p>

<p style="margin-left:11%; margin-top: 1em">This check
identifies unsafe accesses to values contained in
<b>std::optional&lt;T&gt;</b>,
<b>absl::optional&lt;T&gt;</b>, or
<b>base::Optional&lt;T&gt;</b> objects. Below we will refer
to all these types collectively as
<b>optional&lt;T&gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">An access to
the value of an <b>optional&lt;T&gt;</b> occurs when one of
its <b>value</b>, <b>operator*</b>, or
<b>operator&minus;&gt;</b> member functions is invoked. To
align with common misconceptions, the check considers these
member functions as equivalent, even though there are subtle
differences related to exceptions versus undefined behavior.
See go/optional&minus;style&minus;recommendations for more
information on that topic.</p>

<p style="margin-left:11%; margin-top: 1em">An access to
the value of an <b>optional&lt;T&gt;</b> is considered safe
if and only if code in the local scope (for example, a
function body) ensures that the <b>optional&lt;T&gt;</b> has
a value in all possible execution paths that can reach the
access. That should happen either through an explicit check,
using the <b>optional&lt;T&gt;::has_value</b> member
function, or by constructing the <b>optional&lt;T&gt;</b> in
a way that shows that it unambiguously holds a value (e.g
using <b>std::make_optional</b> which always returns a
populated <b>std::optional&lt;T&gt;</b>).</p>

<p style="margin-left:11%; margin-top: 1em">Below we list
some examples, starting with unsafe optional access
patterns, followed by safe access patterns.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unsafe
access patterns <br>
Access the value without checking if it exists</b> <br>
The check flags accesses to the value that are not locally
guarded by existence check:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(std::optional&lt;int&gt; opt) {
  use(*opt); // unsafe: it is unclear whether `opt` has a value.
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Access the
value in the wrong branch</b> <br>
The check is aware of the state of an optional object in
different branches of the code. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(std::optional&lt;int&gt; opt) {
  if (opt.has_value()) {
  } else {
    use(opt.value()); // unsafe: it is clear that `opt` does *not* have a value.
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Assume a
function result to be stable</b> <br>
The check is aware that function results might not be
stable. That is, consecutive calls to the same function
might return different values. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(Foo foo) {
  if (foo.opt().has_value()) {
    use(*foo.opt()); // unsafe: it is unclear whether `foo.opt()` has a value.
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Rely on
invariants of uncommon APIs</b> <br>
The check is unaware of invariants of uncommon APIs. For
example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(Foo foo) {
  if (foo.HasProperty(&quot;bar&quot;)) {
    use(*foo.GetProperty(&quot;bar&quot;)); // unsafe: it is unclear whether `foo.GetProperty(&quot;bar&quot;)` has a value.
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Check if a
value exists, then pass the optional to another function</b>
<br>
The check relies on local reasoning. The check and value
access must both happen in the same function. An access is
considered unsafe even if the caller of the function
performing the access ensures that the optional has a value.
For example:</p>
<pre style="margin-left:15%; margin-top: 1em">void g(std::optional&lt;int&gt; opt) {
  use(*opt); // unsafe: it is unclear whether `opt` has a value.
}


void f(std::optional&lt;int&gt; opt) {
  if (opt.has_value()) {
    g(opt);
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Safe access
patterns <br>
Check if a value exists, then access the value</b> <br>
The check recognizes all straightforward ways for checking
if a value exists and accessing the value contained in an
optional object. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(std::optional&lt;int&gt; opt) {
  if (opt.has_value()) {
    use(*opt);
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Check if a
value exists, then access the value from a copy</b> <br>
The criteria that the check uses is semantic, not syntactic.
It recognizes when a copy of the optional object being
accessed is known to have a value. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(std::optional&lt;int&gt; opt1) {
  if (opt1.has_value()) {
    std::optional&lt;int&gt; opt2 = opt1;
    use(*opt2);
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Ensure that
a value exists using common macros</b> <br>
The check is aware of common macros like <b>CHECK</b>,
<b>DCHECK</b>, and <b>ASSERT_THAT</b>. Those can be used to
ensure that an optional object has a value. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(std::optional&lt;int&gt; opt) {
  DCHECK(opt.has_value());
  use(*opt);
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Ensure that
a value exists, then access the value in a correlated
branch</b> <br>
The check is aware of correlated branches in the code and
can figure out when an optional object is ensured to have a
value on all execution paths that lead to an access. For
example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(std::optional&lt;int&gt; opt) {
  bool safe = false;
  if (opt.has_value() &amp;&amp; SomeOtherCondition()) {
    safe = true;
  }
  // ... more code...
  if (safe) {
    use(*opt);
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Stabilize
function results</b> <br>
Since function results are not assumed to be stable across
calls, it is best to store the result of the function call
in a local variable and use that variable to access the
value. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(Foo foo) {
  if (const auto&amp; foo_opt = foo.opt(); foo_opt.has_value()) {
    use(*foo_opt);
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Do not rely
on uncommon&minus;API invariants</b> <br>
When uncommon APIs guarantee that an optional has contents,
do not rely on it &minus;&minus; instead, check explicitly
that the optional object has a value. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(Foo foo) {
  if (const auto&amp; property = foo.GetProperty(&quot;bar&quot;)) {
    use(*property);
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">instead of the
<i>HasProperty</i>, <i>GetProperty</i> pairing we saw
above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Do not rely
on caller&minus;performed checks</b> <br>
If you know that all of a function's callers have checked
that an optional argument has a value, either change the
function to take the value directly or check the optional
again in the local scope of the callee. For example:</p>
<pre style="margin-left:15%; margin-top: 1em">void g(int val) {
  use(val);
}


void f(std::optional&lt;int&gt; opt) {
  if (opt.has_value()) {
    g(*opt);
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">and</p>
<pre style="margin-left:15%; margin-top: 1em">struct S {
  std::optional&lt;int&gt; opt;
  int x;
};

void g(const S &amp;s) {
  if (s.opt.has_value() &amp;&amp; s.x &gt; 10) {
    use(*s.opt);
}


void f(S s) {
  if (s.opt.has_value()) {
    g(s);
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Additional
notes <br>
Aliases created via using declarations</b> <br>
The check is aware of aliases of optional types that are
created via <b>using</b> declarations. For example:</p>
<pre style="margin-left:15%; margin-top: 1em">using OptionalInt = std::optional&lt;int&gt;;


void f(OptionalInt opt) {
  use(opt.value()); // unsafe: it is unclear whether `opt` has a value.
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Lambdas</b>
<br>
The check does not currently report unsafe optional acceses
in lambdas. A future version will expand the scope to
lambdas, following the rules outlined above. It is best to
follow the same principles when using optionals in
lambdas.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;undefined&minus;memory&minus;manipulation</b>
<br>
Finds calls of memory manipulation functions
<b>memset()</b>, <b>memcpy()</b> and <b>memmove()</b> on not
TriviallyCopyable objects resulting in undefined
behavior.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;undelegated&minus;constructor</b>
<br>
Finds creation of temporary objects in constructors that
look like a function call to another constructor of the same
class.</p>

<p style="margin-left:11%; margin-top: 1em">The user most
likely meant to use a delegating constructor or base class
initializer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;unhandled&minus;exception&minus;at&minus;new</b>
<br>
Finds calls to <b>new</b> with missing exception handler for
<b>std::bad_alloc</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Calls to
<b>new</b> may throw exceptions of type
<b>std::bad_alloc</b> that should be handled. Alternatively,
the nonthrowing form of <b>new</b> can be used. The check
verifies that the exception is handled in the function that
calls <b>new</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If a
nonthrowing version is used or the exception is allowed to
propagate out of the function no warning is generated.</p>

<p style="margin-left:11%; margin-top: 1em">The exception
handler is checked if it catches a <b>std::bad_alloc</b> or
<b>std::exception</b> exception type, or all exceptions
(catch&minus;all). The check assumes that any
user&minus;defined <b>operator new</b> is either
<b>noexcept</b> or may throw an exception of type
<b>std::bad_alloc</b> (or one derived from it). Other
exception class types are not taken into account.</p>
<pre style="margin-left:15%; margin-top: 1em">int *f() noexcept {
  int *p = new int[1000]; // warning: missing exception handler for allocation failure at 'new'
  // ...
  return p;
}
int *f1() { // not 'noexcept'
  int *p = new int[1000]; // no warning: exception can be handled outside
                          // of this function
  // ...
  return p;
}

int *f2() noexcept {
  try {
    int *p = new int[1000]; // no warning: exception is handled
    // ...
    return p;
  } catch (std::bad_alloc &amp;) {
    // ...
  }
  // ...
}


int *f3() noexcept {
  int *p = new (std::nothrow) int[1000]; // no warning: &quot;nothrow&quot; is used
  // ...
  return p;
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;unhandled&minus;self&minus;assignment</b>
<i><br>
cert&minus;oop54&minus;cpp</i> redirects here as an alias
for this check. For the CERT alias, the
<i>WarnOnlyIfThisHasSuspiciousField</i> option is set to
<i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Finds
user&minus;defined copy assignment operators which do not
protect the code against self&minus;assignment either by
checking self&minus;assignment explicitly or using the
copy&minus;and&minus;swap or the copy&minus;and&minus;move
method.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
this check searches only those classes which have any
pointer or C array field to avoid false positives. In case
of a pointer or a C array, it's likely that self&minus;copy
assignment breaks the object if the copy assignment operator
was not written with care.</p>

<p style="margin-left:11%; margin-top: 1em">See also:
<i>OOP54&minus;CPP. Gracefully handle self&minus;copy
assignment</i></p>

<p style="margin-left:11%; margin-top: 1em">A copy
assignment operator must prevent that self&minus;copy
assignment ruins the object state. A typical use case is
when the class has a pointer field and the copy assignment
operator first releases the pointed object and then tries to
assign it:</p>
<pre style="margin-left:15%; margin-top: 1em">class T {
int* p;

public:
  T(const T &amp;rhs) : p(rhs.p ? new int(*rhs.p) : nullptr) {}
  ~T() { delete p; }

  // ...


  T&amp; operator=(const T &amp;rhs) {
    delete p;
    p = new int(*rhs.p);
    return *this;
  }
};</pre>


<p style="margin-left:11%; margin-top: 1em">There are two
common C++ patterns to avoid this problem. The first is the
self&minus;assignment check:</p>
<pre style="margin-left:15%; margin-top: 1em">class T {
int* p;

public:
  T(const T &amp;rhs) : p(rhs.p ? new int(*rhs.p) : nullptr) {}
  ~T() { delete p; }

  // ...

  T&amp; operator=(const T &amp;rhs) {
    if(this == &amp;rhs)
      return *this;


    delete p;
    p = new int(*rhs.p);
    return *this;
  }
};</pre>


<p style="margin-left:11%; margin-top: 1em">The second one
is the copy&minus;and&minus;swap method when we create a
temporary copy (using the copy constructor) and then swap
this temporary object with <b>this</b>:</p>
<pre style="margin-left:15%; margin-top: 1em">class T {
int* p;

public:
  T(const T &amp;rhs) : p(rhs.p ? new int(*rhs.p) : nullptr) {}
  ~T() { delete p; }

  // ...

  void swap(T &amp;rhs) {
    using std::swap;
    swap(p, rhs.p);
  }


  T&amp; operator=(const T &amp;rhs) {
    T(rhs).swap(*this);
    return *this;
  }
};</pre>


<p style="margin-left:11%; margin-top: 1em">There is a
third pattern which is less common. Let's call it the
copy&minus;and&minus;move method when we create a temporary
copy (using the copy constructor) and then move this
temporary object into <b>this</b> (needs a move assignment
operator):</p>
<pre style="margin-left:15%; margin-top: 1em">class T {
int* p;

public:
  T(const T &amp;rhs) : p(rhs.p ? new int(*rhs.p) : nullptr) {}
  ~T() { delete p; }

  // ...

  T&amp; operator=(const T &amp;rhs) {
    T t = rhs;
    *this = std::move(t);
    return *this;
  }


  T&amp; operator=(T &amp;&amp;rhs) {
    p = rhs.p;
    rhs.p = nullptr;
    return *this;
  }
};</pre>



<p style="margin-left:11%;"><b>WarnOnlyIfThisHasSuspiciousField</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn only if the container class of the copy assignment
operator has any suspicious fields (pointer or C array).
This option is set to <i>true</i> by default.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;unused&minus;raii</b>
<br>
Finds temporaries that look like RAII objects.</p>

<p style="margin-left:11%; margin-top: 1em">The canonical
example for this is a scoped lock.</p>

<pre style="margin-left:15%; margin-top: 1em">{
  scoped_lock(&amp;global_mutex);
  critical_section();
}</pre>


<p style="margin-left:11%; margin-top: 1em">The destructor
of the scoped_lock is called before the
<b>critical_section</b> is entered, leaving it
unprotected.</p>

<p style="margin-left:11%; margin-top: 1em">We apply a
number of heuristics to reduce the false positive count of
this check:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Ignore code expanded from macros. Testing frameworks
make heavy use of this.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Ignore types with trivial destructors. They are very
unlikely to be RAII objects and there's no difference when
they are deleted.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Ignore objects at the end of a compound statement
(doesn't change behavior).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Ignore objects returned from a call.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;unused&minus;return&minus;value</b>
<br>
Warns on unused function return values. The checked
functions can be configured.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
CheckedFunctions</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of functions to check. The function is checked if the name
and scope matches, with any arguments. By default the
following functions are checked: <b>std::async,
std::launder, std::remove, std::remove_if, std::unique,
std::unique_ptr::release, std::basic_string::empty,
std::vector::empty, std::back_inserter, std::distance,
std::find, std::find_if, std::inserter, std::lower_bound,
std::make_pair, std::map::count, std::map::find,
std::map::lower_bound, std::multimap::equal_range,
std::multimap::upper_bound, std::set::count, std::set::find,
std::setfill, std::setprecision, std::setw,
std::upper_bound, std::vector::at, bsearch, ferror, feof,
isalnum, isalpha, isblank, iscntrl, isdigit, isgraph,
islower, isprint, ispunct, isspace, isupper, iswalnum,
iswprint, iswspace, isxdigit, memchr, memcmp, strcmp,
strcoll, strncmp, strpbrk, strrchr, strspn, strstr, wcscmp,
access, bind, connect, difftime, dlsym, fnmatch,
getaddrinfo, getopt, htonl, htons, iconv_open, inet_addr,
isascii, isatty, mmap, newlocale, openat, pathconf,
pthread_equal, pthread_getspecific, pthread_mutex_trylock,
readdir, readlink, recvmsg, regexec, scandir, semget,
setjmp, shm_open, shmget, sigismember, strcasecmp,
strsignal, ttyname</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>std::async()</b>. Not using the return value makes
the call synchronous.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>std::launder()</b>. Not using the return value
usually means that the function interface was misunderstood
by the programmer. Only the returned pointer is
&quot;laundered&quot;, not the argument.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>std::remove()</b>, <b>std::remove_if()</b> and
<b>std::unique()</b>. The returned iterator indicates the
boundary between elements to keep and elements to be
removed. Not using the return value means that the
information about which elements to remove is lost.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>std::unique_ptr::release()</b>. Not using the return
value can lead to resource leaks if the same pointer isn't
stored anywhere else. Often, ignoring the <b>release()</b>
return value indicates that the programmer confused the
function with <b>reset()</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>std::basic_string::empty()</b> and
<b>std::vector::empty()</b>. Not using the return value
often indicates that the programmer confused the function
with <b>clear()</b>.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><i>cert&minus;err33&minus;c</i>
is an alias of this check that checks a fixed and large set
of standard library functions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;use&minus;after&minus;move</b>
<br>
Warns if an object is used after it has been moved, for
example:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string str = &quot;Hello, world!\n&quot;;
std::vector&lt;std::string&gt; messages;
messages.emplace_back(std::move(str));
std::cout &lt;&lt; str;</pre>


<p style="margin-left:11%; margin-top: 1em">The last line
will trigger a warning that <b>str</b> is used after it has
been moved.</p>

<p style="margin-left:11%; margin-top: 1em">The check does
not trigger a warning if the object is reinitialized after
the move and before the use. For example, no warning will be
output for this code:</p>

<pre style="margin-left:15%; margin-top: 1em">messages.emplace_back(std::move(str));
str = &quot;Greetings, stranger!\n&quot;;
std::cout &lt;&lt; str;</pre>


<p style="margin-left:11%; margin-top: 1em">Subsections
below explain more precisely what exactly the check
considers to be a move, use, and reinitialization.</p>

<p style="margin-left:11%; margin-top: 1em">The check takes
control flow into account. A warning is only emitted if the
use can be reached from the move. This means that the
following code does not produce a warning:</p>

<pre style="margin-left:15%; margin-top: 1em">if (condition) {
  messages.emplace_back(std::move(str));
} else {
  std::cout &lt;&lt; str;
}</pre>


<p style="margin-left:11%; margin-top: 1em">On the other
hand, the following code does produce a warning:</p>

<pre style="margin-left:15%; margin-top: 1em">for (int i = 0; i &lt; 10; ++i) {
  std::cout &lt;&lt; str;
  messages.emplace_back(std::move(str));
}</pre>


<p style="margin-left:11%; margin-top: 1em">(The
use&minus;after&minus;move happens on the second iteration
of the loop.)</p>

<p style="margin-left:11%; margin-top: 1em">In some cases,
the check may not be able to detect that two branches are
mutually exclusive. For example (assuming that <b>i</b> is
an int):</p>

<pre style="margin-left:15%; margin-top: 1em">if (i == 1) {
  messages.emplace_back(std::move(str));
}
if (i == 2) {
  std::cout &lt;&lt; str;
}</pre>


<p style="margin-left:11%; margin-top: 1em">In this case,
the check will erroneously produce a warning, even though it
is not possible for both the move and the use to be
executed. More formally, the analysis is
<i>flow&minus;sensitive but not
path&minus;sensitive</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Silencing
erroneous warnings</b> <br>
An erroneous warning can be silenced by reinitializing the
object after the move:</p>

<pre style="margin-left:15%; margin-top: 1em">if (i == 1) {
  messages.emplace_back(std::move(str));
  str = &quot;&quot;;
}
if (i == 2) {
  std::cout &lt;&lt; str;
}</pre>


<p style="margin-left:11%; margin-top: 1em">If you want to
avoid the overhead of actually reinitializing the object,
you can create a dummy function that causes the check to
assume the object was reinitialized:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;class T&gt;
void IS_INITIALIZED(T&amp;) {}</pre>


<p style="margin-left:11%; margin-top: 1em">You can use
this as follows:</p>

<pre style="margin-left:15%; margin-top: 1em">if (i == 1) {
  messages.emplace_back(std::move(str));
}
if (i == 2) {
  IS_INITIALIZED(str);
  std::cout &lt;&lt; str;
}</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
not output a warning in this case because passing the object
to a function as a non&minus;const pointer or reference
counts as a reinitialization (see section
<i>Reinitialization</i> below).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unsequenced
moves, uses, and reinitializations</b> <br>
In many cases, C++ does not make any guarantees about the
order in which sub&minus;expressions of a statement are
evaluated. This means that in code like the following, it is
not guaranteed whether the use will happen before or after
the move:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(int i, std::vector&lt;int&gt; v);
std::vector&lt;int&gt; v = { 1, 2, 3 };
f(v[1], std::move(v));</pre>


<p style="margin-left:11%; margin-top: 1em">In this kind of
situation, the check will note that the use and move are
unsequenced.</p>

<p style="margin-left:11%; margin-top: 1em">The check will
also take sequencing rules into account when
reinitializations occur in the same statement as moves or
uses. A reinitialization is only considered to reinitialize
a variable if it is guaranteed to be evaluated after the
move and before the use.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Move</b>
<br>
The check currently only considers calls of <b>std::move</b>
on local variables or function parameters. It does not check
moves of member variables or global variables.</p>

<p style="margin-left:11%; margin-top: 1em">Any call of
<b>std::move</b> on a variable is considered to cause a move
of that variable, even if the result of <b>std::move</b> is
not passed to an rvalue reference parameter.</p>

<p style="margin-left:11%; margin-top: 1em">This means that
the check will flag a use&minus;after&minus;move even on a
type that does not define a move constructor or move
assignment operator. This is intentional. Developers may use
<b>std::move</b> on such a type in the expectation that the
type will add move semantics in the future. If such a
<b>std::move</b> has the potential to cause a
use&minus;after&minus;move, we want to warn about it even if
the type does not implement move semantics yet.</p>

<p style="margin-left:11%; margin-top: 1em">Furthermore, if
the result of <b>std::move</b> <i>is</i> passed to an rvalue
reference parameter, this will always be considered to cause
a move, even if the function that consumes this parameter
does not move from it, or if it does so only conditionally.
For example, in the following situation, the check will
assume that a move always takes place:</p>

<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;std::string&gt; messages;
void f(std::string &amp;&amp;str) {
  // Only remember the message if it isn't empty.
  if (!str.empty()) {
    messages.emplace_back(std::move(str));
  }
}
std::string str = &quot;&quot;;
f(std::move(str));</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
assume that the last line causes a move, even though, in
this particular case, it does not. Again, this is
intentional.</p>

<p style="margin-left:11%; margin-top: 1em">There is one
special case: A call to <b>std::move</b> inside a
<b>try_emplace</b> call is conservatively assumed not to
move. This is to avoid spurious warnings, as the check has
no way to reason about the <b>bool</b> returned by
<b>try_emplace</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When analyzing
the order in which moves, uses and reinitializations happen
(see section <i>Unsequenced moves, uses, and
reinitializations</i>), the move is assumed to occur in
whichever function the result of the <b>std::move</b> is
passed to.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Use</b> <br>
Any occurrence of the moved variable that is not a
reinitialization (see below) is considered to be a use.</p>

<p style="margin-left:11%; margin-top: 1em">An exception to
this are objects of type <b>std::unique_ptr</b>,
<b>std::shared_ptr</b> and <b>std::weak_ptr</b>, which have
defined move behavior (objects of these classes are
guaranteed to be empty after they have been moved from).
Therefore, an object of these classes will only be
considered to be used if it is dereferenced, i.e. if
<b>operator*</b>, <b>operator&minus;&gt;</b> or
<b>operator[]</b> (in the case of <b>std::unique_ptr&lt;T
[]&gt;</b>) is called on it.</p>

<p style="margin-left:11%; margin-top: 1em">If multiple
uses occur after a move, only the first of these is
flagged.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Reinitialization</b>
<br>
The check considers a variable to be reinitialized in the
following cases:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p style="margin-top: 1em">The variable occurs on the
left&minus;hand side of an assignment.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>The variable is passed to a function as a
non&minus;const pointer or non&minus;const lvalue reference.
(It is assumed that the variable may be an
out&minus;parameter for the function.)</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><b>clear()</b> or <b>assign()</b> is called on the
variable and the variable is of one of the standard
container types <b>basic_string</b>, <b>vector</b>,
<b>deque</b>, <b>forward_list</b>, <b>list</b>, <b>set</b>,
<b>map</b>, <b>multiset</b>, <b>multimap</b>,
<b>unordered_set</b>, <b>unordered_map</b>,
<b>unordered_multiset</b>, <b>unordered_multimap</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><b>reset()</b> is called on the variable and the
variable is of type <b>std::unique_ptr</b>,
<b>std::shared_ptr</b> or <b>std::weak_ptr</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>A member function marked with the
<b>[[clang::reinitializes]]</b> attribute is called on the
variable.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the variable
in question is a struct and an individual member variable of
that struct is written to, the check does not consider this
to be a reinitialization &minus;&minus; even if, eventually,
all member variables of the struct are written to. For
example:</p>

<pre style="margin-left:15%; margin-top: 1em">struct S {
  std::string str;
  int i;
};
S s = { &quot;Hello, world!\n&quot;, 42 };
S s_other = std::move(s);
s.str = &quot;Lorem ipsum&quot;;
s.i = 99;</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
not consider <b>s</b> to be reinitialized after the last
line; instead, the line that assigns to <b>s.str</b> will be
flagged as a use&minus;after&minus;move. This is intentional
as this pattern of reinitializing a struct is
error&minus;prone. For example, if an additional member
variable is added to <b>S</b>, it is easy to forget to add
the reinitialization for this additional member. Instead, it
is safer to assign to the entire struct in one go, and this
will also avoid the use&minus;after&minus;move warning.</p>


<p style="margin-left:11%; margin-top: 1em"><b>bugprone&minus;virtual&minus;near&minus;miss</b>
<br>
Warn if a function is a near miss (i.e. the name is very
similar and the function signature is the same) to a virtual
function from a base class.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em">struct Base {
  virtual void func();
};


struct Derived : Base {
  virtual void funk();
  // warning: 'Derived::funk' has a similar name and the same signature as virtual method 'Base::func'; did you mean to override it?
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;con36&minus;c</b>
<br>
The cert&minus;con36&minus;c check is an alias, please see
<i>bugprone&minus;spuriously&minus;wake&minus;up&minus;functions</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;con54&minus;cpp</b>
<br>
The cert&minus;con54&minus;cpp check is an alias, please see
<i>bugprone&minus;spuriously&minus;wake&minus;up&minus;functions</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl03&minus;c</b>
<br>
The cert&minus;dcl03&minus;c check is an alias, please see
<i>misc&minus;static&minus;assert</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl16&minus;c</b>
<br>
The cert&minus;dcl16&minus;c check is an alias, please see
<i>readability&minus;uppercase&minus;literal&minus;suffix</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl21&minus;cpp</b>
<br>
This check flags postfix <b>operator++</b> and
<b>operator&minus;&minus;</b> declarations if the return
type is not a const object. This also warns if the return
type is a reference type.</p>

<p style="margin-left:11%; margin-top: 1em">The object
returned by a postfix increment or decrement operator is
supposed to be a snapshot of the object's value prior to
modification. With such an implementation, any modifications
made to the resulting object from calling operator++(int)
would be modifying a temporary object. Thus, such an
implementation of a postfix increment or decrement operator
should instead return a const object, prohibiting accidental
mutation of a temporary object. Similarly, it is unexpected
for the postfix operator to return a reference to its
previous state, and any subsequent modifications would be
operating on a stale object.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard recommendation
DCL21&minus;CPP. Overloaded postfix increment and decrement
operators should return a const object. However, all of the
CERT recommendations have been removed from public view, and
so their justification for the behavior of this check
requires an account on their wiki to view.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl37&minus;c</b>
<br>
The cert&minus;dcl37&minus;c check is an alias, please see
<i>bugprone&minus;reserved&minus;identifier</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl50&minus;cpp</b>
<br>
This check flags all function definitions (but not
declarations) of C&minus;style variadic functions.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>DCL50&minus;CPP. Do not define a C&minus;style variadic
function</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl51&minus;cpp</b>
<br>
The cert&minus;dcl51&minus;cpp check is an alias, please see
<i>bugprone&minus;reserved&minus;identifier</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl54&minus;cpp</b>
<br>
The cert&minus;dcl54&minus;cpp check is an alias, please see
<i>misc&minus;new&minus;delete&minus;overloads</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl58&minus;cpp</b>
<br>
Modification of the <b>std</b> or <b>posix</b> namespace can
result in undefined behavior. This check warns for such
modifications. The <b>std</b> (or <b>posix</b>) namespace is
allowed to be extended with (class or function) template
specializations that depend on an user&minus;defined type (a
type that is not defined in the standard system
headers).</p>

<p style="margin-left:11%; margin-top: 1em">The check
detects the following (user provided) declarations in
namespace <b>std</b> or <b>posix</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Anything that is not a template
specialization.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Explicit specializations of any standard library
function template or class template, if it does not have any
user&minus;defined type as template argument.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Explicit specializations of any member function of a
standard library class template.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Explicit specializations of any member function template
of a standard library class or class template.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Explicit or partial specialization of any member class
template of a standard library class or class template.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">namespace std {
  int x; // warning: modification of 'std' namespace can result in undefined behavior [cert&minus;dcl58&minus;cpp]
}

namespace posix::a { // warning: modification of 'posix' namespace can result in undefined behavior
}

template &lt;&gt;
struct ::std::hash&lt;long&gt; { // warning: modification of 'std' namespace can result in undefined behavior
  unsigned long operator()(const long &amp;K) const {
    return K;
  }
};

struct MyData { long data; };

template &lt;&gt;
struct ::std::hash&lt;MyData&gt; { // no warning: specialization with user&minus;defined type
  unsigned long operator()(const MyData &amp;K) const {
    return K.data;
  }
};

namespace std {
  template &lt;&gt;
  void swap&lt;bool&gt;(bool &amp;a, bool &amp;b); // warning: modification of 'std' namespace can result in undefined behavior


  template &lt;&gt;
  bool less&lt;void&gt;::operator()&lt;MyData &amp;&amp;, MyData &amp;&amp;&gt;(MyData &amp;&amp;, MyData &amp;&amp;) const { // warning: modification of 'std' namespace can result in undefined behavior
    return true;
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>DCL58&minus;CPP. Do not modify the standard
namespaces</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;dcl59&minus;cpp</b>
<br>
The cert&minus;dcl59&minus;cpp check is an alias, please see
<i>google&minus;build&minus;namespaces</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;env33&minus;c</b>
<br>
This check flags calls to <b>system()</b>, <b>popen()</b>,
and <b>_popen()</b>, which execute a command processor. It
does not flag calls to <b>system()</b> with a null pointer
argument, as such a call checks for the presence of a
command processor but does not actually attempt to execute a
command.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule
<i>ENV33&minus;C. Do not call system()</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;err09&minus;cpp</b>
<br>
The cert&minus;err09&minus;cpp check is an alias, please see
<i>misc&minus;throw&minus;by&minus;value&minus;catch&minus;by&minus;reference</i>
for more information.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard recommendation
ERR09&minus;CPP. Throw anonymous temporaries. However, all
of the CERT recommendations have been removed from public
view, and so their justification for the behavior of this
check requires an account on their wiki to view.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;err33&minus;c</b>
<br>
Warns on unused function return values. Many of the standard
library functions return a value that indicates if the call
was successful. Ignoring the returned value can cause
unexpected behavior if an error has occured. The following
functions are checked:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p style="margin-top: 1em">aligned_alloc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>asctime_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>at_quick_exit()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>atexit()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>bsearch()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>bsearch_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>btowc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>c16rtomb()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>c32rtomb()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>calloc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>clock()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>cnd_broadcast()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>cnd_init()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>cnd_signal()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>cnd_timedwait()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>cnd_wait()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>ctime_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fclose()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fflush()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fgetc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fgetpos()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fgets()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fgetwc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fopen()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fopen_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fputc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fputs()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fputwc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fputws()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fread()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>freopen()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>freopen_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fseek()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fsetpos()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>ftell()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fwprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fwprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fwrite()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fwscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>fwscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>getc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>getchar()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>getenv()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>getenv_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>gets_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>getwc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>getwchar()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>gmtime()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>gmtime_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>localtime()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>localtime_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>malloc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mbrtoc16()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mbrtoc32()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mbsrtowcs()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mbsrtowcs_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mbstowcs()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mbstowcs_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>memchr()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mktime()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mtx_init()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mtx_lock()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mtx_timedlock()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mtx_trylock()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>mtx_unlock()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>printf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>putc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>putwc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>raise()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>realloc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>remove()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>rename()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>setlocale()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>setvbuf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>scanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>scanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>signal()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>snprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>snprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>sprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>sprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>sscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>sscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strchr()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strerror_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strftime()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strpbrk()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strrchr()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strstr()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtod()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtof()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtoimax()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtok()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtok_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtol()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtold()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtoll()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtoumax()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtoul()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strtoull()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>strxfrm()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>swprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>swprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>swscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>swscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>thrd_create()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>thrd_detach()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>thrd_join()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>thrd_sleep()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>time()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>timespec_get()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>tmpfile()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>tmpfile_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>tmpnam()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>tmpnam_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>tss_create()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>tss_get()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>tss_set()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>ungetc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>ungetwc()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vfprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vfprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vfscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vfscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vfwprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vfwprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vfwscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vfwscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vsnprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vsnprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vsprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vsprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vsscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vsscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vswprintf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vswprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vswscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vswscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vwprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vwscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>vwscanf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcrtomb()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcschr()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcsftime()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcspbrk()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcsrchr()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcsrtombs()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcsrtombs_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcsstr()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstod()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstof()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstoimax()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstok()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstok_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstol()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstold()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstoll()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstombs()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstombs_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstoumax()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstoul()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcstoull()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wcsxfrm()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wctob()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wctrans()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wctype()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wmemchr()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wprintf_s()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wscanf()</p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="23%">


<p>wscanf_s()</p></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This check is
an alias of check
<i>bugprone&minus;unused&minus;return&minus;value</i> with a
fixed set of functions.</p>

<p style="margin-left:11%; margin-top: 1em">The check
corresponds to a part of CERT C Coding Standard rule
<i>ERR33&minus;C. Detect and handle standard library
errors</i>. The list of checked functions is taken from the
rule, with following exception:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">The check can not differentiate
if a function is called with <b>NULL</b> argument. Therefore
the following functions are not checked: <b>mblen</b>,
<b>mbrlen</b>, <b>mbrtowc</b>, <b>mbtowc</b>, <b>wctomb</b>,
<b>wctomb_s</b></p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;err34&minus;c</b>
<br>
This check flags calls to string&minus;to&minus;number
conversion functions that do not verify the validity of the
conversion, such as <b>atoi()</b> or <b>scanf()</b>. It does
not flag calls to <b>strtol()</b>, or other, related
conversion functions that do perform better error
checking.</p>
<pre style="margin-left:15%; margin-top: 1em">#include &lt;stdlib.h&gt;

void func(const char *buff) {
  int si;


  if (buff) {
    si = atoi(buff); /* 'atoi' used to convert a string to an integer, but function will
                         not report conversion errors; consider using 'strtol' instead. */
  } else {
    /* Handle error */
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule
<i>ERR34&minus;C. Detect errors when converting a string to
a number</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;err52&minus;cpp</b>
<br>
This check flags all call expressions involving
<b>setjmp()</b> and <b>longjmp()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>ERR52&minus;CPP. Do not use setjmp() or
longjmp()</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;err58&minus;cpp</b>
<br>
This check flags all <b>static</b> or <b>thread_local</b>
variable declarations where the initializer for the object
may throw an exception.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>ERR58&minus;CPP. Handle all exceptions thrown before
main() begins executing</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;err60&minus;cpp</b>
<br>
This check flags all throw expressions where the exception
object is not nothrow copy constructible.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>ERR60&minus;CPP. Exception objects must be nothrow copy
constructible</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;err61&minus;cpp</b>
<br>
The cert&minus;err61&minus;cpp check is an alias, please see
<i>misc&minus;throw&minus;by&minus;value&minus;catch&minus;by&minus;reference</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;exp42&minus;c</b>
<br>
The cert&minus;exp42&minus;c check is an alias, please see
<i>bugprone&minus;suspicious&minus;memory&minus;comparison</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;fio38&minus;c</b>
<br>
The cert&minus;fio38&minus;c check is an alias, please see
<i>misc&minus;non&minus;copyable&minus;objects</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;flp30&minus;c</b>
<br>
This check flags <b>for</b> loops where the induction
expression has a floating&minus;point type.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule
<i>FLP30&minus;C. Do not use floating&minus;point variables
as loop counters</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;flp37&minus;c</b>
<br>
The cert&minus;flp37&minus;c check is an alias, please see
<i>bugprone&minus;suspicious&minus;memory&minus;comparison</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;mem57&minus;cpp</b>
<br>
This check flags uses of default <b>operator new</b> where
the type has extended alignment (an alignment greater than
the fundamental alignment). (The default <b>operator new</b>
is guaranteed to provide the correct alignment if the
requested alignment is less or equal to the fundamental
alignment). Only cases are detected (by design) where the
<b>operator new</b> is not user&minus;defined and is not a
placement new (the reason is that in these cases we assume
that the user provided the correct memory allocation).</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>MEM57&minus;CPP. Avoid using default operator new for
over&minus;aligned types</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;msc30&minus;c</b>
<br>
The cert&minus;msc30&minus;c check is an alias, please see
<i>cert&minus;msc50&minus;cpp</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;msc32&minus;c</b>
<br>
The cert&minus;msc32&minus;c check is an alias, please see
<i>cert&minus;msc51&minus;cpp</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;msc50&minus;cpp</b>
<br>
Pseudorandom number generators use mathematical algorithms
to produce a sequence of numbers with good statistical
properties, but the numbers produced are not genuinely
random. The <b>std::rand()</b> function takes a seed
(number), runs a mathematical operation on it and returns
the result. By manipulating the seed the result can be
predictable. This check warns for the usage of
<b>std::rand()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;msc51&minus;cpp</b>
<br>
This check flags all pseudo&minus;random number engines,
engine adaptor instantiations and <b>srand()</b> when
initialized or seeded with default argument, constant
expression or any user&minus;configurable type.
Pseudo&minus;random number engines seeded with a predictable
value may cause vulnerabilities e.g. in security protocols.
This is a CERT security rule, see <i>MSC51&minus;CPP. Ensure
your random number generator is properly seeded</i> and
<i>MSC32&minus;C. Properly seed pseudorandom number
generators</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo() {
  std::mt19937 engine1; // Diagnose, always generate the same sequence
  std::mt19937 engine2(1); // Diagnose
  engine1.seed(); // Diagnose
  engine2.seed(1); // Diagnose

  std::time_t t;
  engine1.seed(std::time(&amp;t)); // Diagnose, system time might be controlled by user


  int x = atoi(argv[1]);
  std::mt19937 engine3(x);  // Will not warn
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
DisallowedSeedTypes</b></p>

<p style="margin-left:22%;">A comma&minus;separated list of
the type names which are disallowed. Default values are
<b>time_t</b>, <b>std::time_t</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;oop11&minus;cpp</b>
<br>
The cert&minus;oop11&minus;cpp check is an alias, please see
<i>performance&minus;move&minus;constructor&minus;init</i>
for more information.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard recommendation
OOP11&minus;CPP. Do not copy&minus;initialize members or
base classes from a move constructor. However, all of the
CERT recommendations have been removed from public view, and
so their justification for the behavior of this check
requires an account on their wiki to view.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;oop54&minus;cpp</b>
<br>
The cert&minus;oop54&minus;cpp check is an alias, please see
<i>bugprone&minus;unhandled&minus;self&minus;assignment</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;oop57&minus;cpp</b></p>

<p style="margin-left:15%;">Flags use of the <i>C</i>
standard library functions <b>memset</b>, <b>memcpy</b> and
<b>memcmp</b> and similar derivatives on non&minus;trivial
types.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
MemSetNames</b></p>

<p style="margin-left:22%;">Specify extra functions to flag
that act similarly to <b>memset</b>. Specify names in a
semicolon delimited list. Default is an empty string. The
check will detect the following functions: <i>memset</i>,
<i>std::memset</i>.</p>

<p style="margin-left:11%;"><b>MemCpyNames</b></p>

<p style="margin-left:22%;">Specify extra functions to flag
that act similarly to <b>memcpy</b>. Specify names in a
semicolon delimited list. Default is an empty string. The
check will detect the following functions:
<i>std::memcpy</i>, <i>memcpy</i>, <i>std::memmove</i>,
<i>memmove</i>, <i>std::strcpy</i>, <i>strcpy</i>,
<i>memccpy</i>, <i>stpncpy</i>, <i>strncpy</i>.</p>

<p style="margin-left:11%;"><b>MemCmpNames</b></p>

<p style="margin-left:22%;">Specify extra functions to flag
that act similarly to <b>memcmp</b>. Specify names in a
semicolon delimited list. Default is an empty string. The
check will detect the following functions:
<i>std::memcmp</i>, <i>memcmp</i>, <i>std::strcmp</i>,
<i>strcmp</i>, <i>strncmp</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C++ Coding Standard rule
<i>OOP57&minus;CPP. Prefer special member functions and
overloaded operators to C Standard Library
functions</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;oop58&minus;cpp</b>
<br>
Finds assignments to the copied object and its direct or
indirect members in copy constructors and copy assignment
operators.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule
<i>OOP58&minus;CPP. Copy operations must not mutate the
source object</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;pos44&minus;c</b>
<br>
The cert&minus;pos44&minus;c check is an alias, please see
<i>bugprone&minus;bad&minus;signal&minus;to&minus;kill&minus;thread</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;pos47&minus;c</b>
<br>
The cert&minus;pos47&minus;c check is an alias, please see
<i>concurrency&minus;thread&minus;canceltype&minus;asynchronous</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;sig30&minus;c</b>
<br>
The cert&minus;sig30&minus;c check is an alias, please see
<i>bugprone&minus;signal&minus;handler</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cert&minus;str34&minus;c</b>
<br>
The cert&minus;str34&minus;c check is an alias, please see
<i>bugprone&minus;signed&minus;char&minus;misuse</i> for
more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.CallAndMessage</b>
<br>
The clang&minus;analyzer&minus;core.CallAndMessage check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.DivideZero</b>
<br>
The clang&minus;analyzer&minus;core.DivideZero check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.DynamicTypePropagation</b>
<br>
Generate dynamic type information</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.NonNullParamChecker</b>
<br>
The clang&minus;analyzer&minus;core.NonNullParamChecker
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.NullDereference</b>
<br>
The clang&minus;analyzer&minus;core.NullDereference check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.StackAddressEscape</b>
<br>
The clang&minus;analyzer&minus;core.StackAddressEscape check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.UndefinedBinaryOperatorResult</b>
<br>
The
clang&minus;analyzer&minus;core.UndefinedBinaryOperatorResult
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.VLASize</b>
<br>
The clang&minus;analyzer&minus;core.VLASize check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.uninitialized.ArraySubscript</b>
<br>
The
clang&minus;analyzer&minus;core.uninitialized.ArraySubscript
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.uninitialized.Assign</b>
<br>
The clang&minus;analyzer&minus;core.uninitialized.Assign
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.uninitialized.Branch</b>
<br>
The clang&minus;analyzer&minus;core.uninitialized.Branch
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.uninitialized.CapturedBlockVariable</b>
<br>
Check for blocks that capture uninitialized values</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;core.uninitialized.UndefReturn</b>
<br>
The
clang&minus;analyzer&minus;core.uninitialized.UndefReturn
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;cplusplus.InnerPointer</b>
<br>
Check for inner pointers of C++ containers used after
re/deallocation</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;cplusplus.Move</b>
<br>
The clang&minus;analyzer&minus;cplusplus.Move check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;cplusplus.NewDelete</b>
<br>
The clang&minus;analyzer&minus;cplusplus.NewDelete check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;cplusplus.NewDeleteLeaks</b>
<br>
The clang&minus;analyzer&minus;cplusplus.NewDeleteLeaks
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;deadcode.DeadStores</b>
<br>
The clang&minus;analyzer&minus;deadcode.DeadStores check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;nullability.NullPassedToNonnull</b>
<br>
The
clang&minus;analyzer&minus;nullability.NullPassedToNonnull
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;nullability.NullReturnedFromNonnull</b>
<br>
The
clang&minus;analyzer&minus;nullability.NullReturnedFromNonnull
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;nullability.NullableDereferenced</b>
<br>
The
clang&minus;analyzer&minus;nullability.NullableDereferenced
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;nullability.NullablePassedToNonnull</b>
<br>
The
clang&minus;analyzer&minus;nullability.NullablePassedToNonnull
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;nullability.NullableReturnedFromNonnull</b>
<br>
Warns when a nullable pointer is returned from a function
that has _Nonnull return type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.cplusplus.UninitializedObject</b>
<br>
The
clang&minus;analyzer&minus;optin.cplusplus.UninitializedObject
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.cplusplus.VirtualCall</b>
<br>
The clang&minus;analyzer&minus;optin.cplusplus.VirtualCall
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.mpi.MPI&minus;Checker</b>
<br>
The clang&minus;analyzer&minus;optin.mpi.MPI&minus;Checker
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.osx.OSObjectCStyleCast</b>
<br>
Checker for C&minus;style casts of OSObjects</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.osx.cocoa.localizability.EmptyLocalizationContextChecker</b>
<br>
The
clang&minus;analyzer&minus;optin.osx.cocoa.localizability.EmptyLocalizationContextChecker
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.osx.cocoa.localizability.NonLocalizedStringChecker</b>
<br>
The
clang&minus;analyzer&minus;optin.osx.cocoa.localizability.NonLocalizedStringChecker
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.performance.GCDAntipattern</b>
<br>
Check for performance anti&minus;patterns when using Grand
Central Dispatch</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.performance.Padding</b>
<br>
Check for excessively padded structs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;optin.portability.UnixAPI</b>
<br>
Finds implementation&minus;defined behavior in UNIX/Posix
functions</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.API</b>
<br>
The clang&minus;analyzer&minus;osx.API check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.MIG</b>
<br>
Find violations of the Mach Interface Generator calling
convention</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.NumberObjectConversion</b>
<br>
Check for erroneous conversions of objects representing
numbers into numbers</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.OSObjectRetainCount</b>
<br>
Check for leaks and improper reference count management for
OSObject</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.ObjCProperty</b>
<br>
Check for proper uses of Objective&minus;C properties</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.SecKeychainAPI</b>
<br>
The clang&minus;analyzer&minus;osx.SecKeychainAPI check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.AtSync</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.AtSync check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.AutoreleaseWrite</b>
<br>
Warn about potentially crashing writes to autoreleasing
objects from different autoreleasing pools in
Objective&minus;C</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.ClassRelease</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.ClassRelease check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.Dealloc</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.Dealloc check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.IncompatibleMethodTypes</b>
<br>
The
clang&minus;analyzer&minus;osx.cocoa.IncompatibleMethodTypes
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.Loops</b>
<br>
Improved modeling of loops using Cocoa collection types</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.MissingSuperCall</b>
<br>
Warn about Objective&minus;C methods that lack a necessary
call to super</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.NSAutoreleasePool</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.NSAutoreleasePool
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.NSError</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.NSError check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.NilArg</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.NilArg check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.NonNilReturnValue</b>
<br>
Model the APIs that are guaranteed to return a non&minus;nil
value</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.ObjCGenerics</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.ObjCGenerics check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.RetainCount</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.RetainCount check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.RunLoopAutoreleaseLeak</b>
<br>
Check for leaked memory in autorelease pools that will never
be drained</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.SelfInit</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.SelfInit check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.SuperDealloc</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.SuperDealloc check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.UnusedIvars</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.UnusedIvars check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.cocoa.VariadicMethodTypes</b>
<br>
The clang&minus;analyzer&minus;osx.cocoa.VariadicMethodTypes
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.coreFoundation.CFError</b>
<br>
The clang&minus;analyzer&minus;osx.coreFoundation.CFError
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.coreFoundation.CFNumber</b>
<br>
The clang&minus;analyzer&minus;osx.coreFoundation.CFNumber
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.coreFoundation.CFRetainRelease</b>
<br>
The
clang&minus;analyzer&minus;osx.coreFoundation.CFRetainRelease
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.coreFoundation.containers.OutOfBounds</b>
<br>
The
clang&minus;analyzer&minus;osx.coreFoundation.containers.OutOfBounds
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;osx.coreFoundation.containers.PointerSizedValues</b>
<br>
The
clang&minus;analyzer&minus;osx.coreFoundation.containers.PointerSizedValues
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.FloatLoopCounter</b>
<br>
The clang&minus;analyzer&minus;security.FloatLoopCounter
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.DeprecatedOrUnsafeBufferHandling</b>
<br>
The
clang&minus;analyzer&minus;security.insecureAPI.DeprecatedOrUnsafeBufferHandling
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.UncheckedReturn</b>
<br>
The
clang&minus;analyzer&minus;security.insecureAPI.UncheckedReturn
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.bcmp</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.bcmp
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.bcopy</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.bcopy
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.bzero</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.bzero
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.getpw</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.getpw
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.gets</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.gets
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.mkstemp</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.mkstemp
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.mktemp</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.mktemp
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.rand</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.rand
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.strcpy</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.strcpy
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;security.insecureAPI.vfork</b>
<br>
The clang&minus;analyzer&minus;security.insecureAPI.vfork
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;unix.API</b>
<br>
The clang&minus;analyzer&minus;unix.API check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;unix.Malloc</b>
<br>
The clang&minus;analyzer&minus;unix.Malloc check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;unix.MallocSizeof</b>
<br>
The clang&minus;analyzer&minus;unix.MallocSizeof check is an
alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;unix.MismatchedDeallocator</b>
<br>
The clang&minus;analyzer&minus;unix.MismatchedDeallocator
check is an alias, please see <i>Clang Static Analyzer
Available Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;unix.Vfork</b>
<br>
The clang&minus;analyzer&minus;unix.Vfork check is an alias,
please see <i>Clang Static Analyzer Available Checkers</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;unix.cstring.BadSizeArg</b>
<br>
The clang&minus;analyzer&minus;unix.cstring.BadSizeArg check
is an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;unix.cstring.NullArg</b>
<br>
The clang&minus;analyzer&minus;unix.cstring.NullArg check is
an alias, please see <i>Clang Static Analyzer Available
Checkers</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;valist.CopyToSelf</b>
<br>
Check for va_lists which are copied onto itself.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;valist.Uninitialized</b>
<br>
Check for usages of uninitialized (or already released)
va_lists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;analyzer&minus;valist.Unterminated</b>
<br>
Check for va_lists which are not released by a va_end
call.</p>


<p style="margin-left:11%; margin-top: 1em"><b>concurrency&minus;mt&minus;unsafe</b>
<br>
Checks for some thread&minus;unsafe functions against a
black list of known&minus;to&minus;be&minus;unsafe
functions. Usually they access static variables without
synchronization (e.g. gmtime(3)) or utilize signals in a
racy way. The set of functions to check is specified with
the <i>FunctionSet</i> option.</p>

<p style="margin-left:11%; margin-top: 1em">Note that using
some thread&minus;unsafe functions may be still valid in
concurrent programming if only a single thread is used (e.g.
setenv(3)), however, some functions may track a state in
global variables which would be clobbered by subsequent
(non&minus;parallel, but concurrent) calls to a related
function. E.g. the following code suffers from unprotected
accesses to a global state:</p>

<pre style="margin-left:15%; margin-top: 1em">// getnetent(3) maintains global state with DB connection, etc.
// If a concurrent green thread calls getnetent(3), the global state is corrupted.
netent = getnetent();
yield();
netent = getnetent();</pre>


<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">tm = gmtime(timep); // uses a global buffer

sleep(1); // implementation may use SIGALRM</pre>

<p style="margin-left:11%;"><b>FunctionSet</b></p>

<p style="margin-left:22%;">Specifies which functions in
libc should be considered thread&minus;safe, possible values
are <i>posix</i>, <i>glibc</i>, or <i>any</i>.</p>

<p style="margin-left:22%; margin-top: 1em"><i>posix</i>
means POSIX defined thread&minus;unsafe functions.
POSIX.1&minus;2001 in &quot;2.9.1 Thread&minus;Safety&quot;
defines that all functions specified in the standard are
thread&minus;safe except a predefined list of
thread&minus;unsafe functions.</p>

<p style="margin-left:22%; margin-top: 1em">Glibc defines
some of them as thread&minus;safe (e.g. dirname(3)), but
adds non&minus;POSIX thread&minus;unsafe ones (e.g.
getopt_long(3)). Glibc's list is compiled from GNU web
documentation with a search for MT&minus;Safe tag:
<i>https://www.gnu.org/software/libc/manual/html_node/POSIX&minus;Safety&minus;Concepts.html</i></p>

<p style="margin-left:22%; margin-top: 1em">If you want to
identify thread&minus;unsafe API for at least one libc or
unsure which libc will be used, use <i>any</i>
(default).</p>


<p style="margin-left:11%; margin-top: 1em"><b>concurrency&minus;thread&minus;canceltype&minus;asynchronous</b>
<br>
Finds <b>pthread_setcanceltype</b> function calls where a
thread's cancellation type is set to asynchronous.
Asynchronous cancellation type
(<b>PTHREAD_CANCEL_ASYNCHRONOUS</b>) is generally unsafe,
use type <b>PTHREAD_CANCEL_DEFERRED</b> instead which is the
default. Even with deferred cancellation, a cancellation
point in an asynchronous signal handler may still be acted
upon and the effect is as if it was an asynchronous
cancellation.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the CERT C Coding Standard rule
<i>POS47&minus;C. Do not use threads that can be canceled
asynchronously</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;avoid&minus;c&minus;arrays</b>
<br>
The cppcoreguidelines&minus;avoid&minus;c&minus;arrays check
is an alias, please see
<i>modernize&minus;avoid&minus;c&minus;arrays</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;avoid&minus;goto</b>
<br>
The usage of <b>goto</b> for control flow is error prone and
should be replaced with looping constructs. Only forward
jumps in nested loops are accepted.</p>

<p style="margin-left:11%; margin-top: 1em">This check
implements <i>ES.76</i> from the CppCoreGuidelines and
<i>6.3.1 from High Integrity C++</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information on why to avoid programming with <b>goto</b> you
can read the famous paper <i>A Case against the GO TO
Statement.</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The check
diagnoses <b>goto</b> for backward jumps in every language
mode. These should be replaced with <i>C/C++</i> looping
constructs.</p>
<pre style="margin-left:15%; margin-top: 1em">// Bad, handwritten for loop.
int i = 0;
// Jump label for the loop
loop_start:
do_some_operation();

if (i &lt; 100) {
  ++i;
  goto loop_start;
}


// Better
for(int i = 0; i &lt; 100; ++i)
  do_some_operation();</pre>


<p style="margin-left:11%; margin-top: 1em">Modern C++
needs <b>goto</b> only to jump out of nested loops.</p>
<pre style="margin-left:15%; margin-top: 1em">for(int i = 0; i &lt; 100; ++i) {
  for(int j = 0; j &lt; 100; ++j) {
    if (i * j &gt; 500)
      goto early_exit;
  }
}

early_exit:
some_operation();</pre>

<p style="margin-left:11%; margin-top: 1em">All other uses
of <b>goto</b> are diagnosed in <i>C++</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;avoid&minus;magic&minus;numbers</b>
<br>
The cppcoreguidelines&minus;avoid&minus;magic&minus;numbers
check is an alias, please see
<i>readability&minus;magic&minus;numbers</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;avoid&minus;non&minus;const&minus;global&minus;variables</b>
<br>
Finds non&minus;const global variables as described in
<i>I.2 of C++ Core Guidelines</i> . As <i>R.6 of C++ Core
Guidelines</i> is a duplicate of rule I.2 it also covers
that rule.</p>
<pre style="margin-left:15%; margin-top: 1em">char a;  // Warns!
const char b =  0;

namespace some_namespace
{
    char c;  // Warns!
    const char d = 0;
}

char * c_ptr1 = &amp;some_namespace::c;  // Warns!
char *const c_const_ptr = &amp;some_namespace::c;  // Warns!
char &amp; c_reference = some_namespace::c;  // Warns!


class Foo  // No Warnings inside Foo, only namespace scope is covered
{
public:
    char e = 0;
    const char f = 0;
protected:
    char g = 0;
private:
    char h = 0;
};</pre>


<p style="margin-left:11%; margin-top: 1em">Variables:
<b>a</b>, <b>c</b>, <b>c_ptr1</b>, <b>c_ptr2</b>,
<b>c_const_ptr</b> and <b>c_reference</b>, will all generate
warnings since they are either: a globally accessible
variable and non&minus;const, a pointer or reference
providing global access to non&minus;const data or both.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;c&minus;copy&minus;assignment&minus;signature</b>
<br>
The
cppcoreguidelines&minus;c&minus;copy&minus;assignment&minus;signature
check is an alias, please see
<i>misc&minus;unconventional&minus;assign&minus;operator</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;explicit&minus;virtual&minus;functions</b>
<br>
The
cppcoreguidelines&minus;explicit&minus;virtual&minus;functions
check is an alias, please see
<i>modernize&minus;use&minus;override</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;init&minus;variables</b>
<br>
Checks whether there are local variables that are declared
without an initial value. These may lead to unexpected
behavior if there is a code path that reads the variable
before assigning to it.</p>

<p style="margin-left:11%; margin-top: 1em">Only integers,
booleans, floats, doubles and pointers are checked. The fix
option initializes all detected values with the value of
zero. An exception is float and double types, which are
initialized to NaN.</p>

<p style="margin-left:11%; margin-top: 1em">As an example a
function that looks like this:</p>
<pre style="margin-left:15%; margin-top: 1em">void function() {
  int x;
  char *txt;
  double d;

  // Rest of the function.
}</pre>

<p style="margin-left:11%; margin-top: 1em">Would be
rewritten to look like this:</p>
<pre style="margin-left:15%; margin-top: 1em">#include &lt;math.h&gt;

void function() {
  int x = 0;
  char *txt = nullptr;
  double d = NAN;

  // Rest of the function.
}</pre>

<p style="margin-left:11%; margin-top: 1em">It warns for
the uninitialized enum case, but without a FixIt:</p>

<pre style="margin-left:15%; margin-top: 1em">enum A {A1, A2, A3};
enum A_c : char { A_c1, A_c2, A_c3 };
enum class B { B1, B2, B3 };
enum class B_i : int { B_i1, B_i2, B_i3 };
void function() {
  A a;     // Warning: variable 'a' is not initialized
  A_c a_c; // Warning: variable 'a_c' is not initialized
  B b;     // Warning: variable 'b' is not initialized
  B_i b_i; // Warning: variable 'b_i' is not initialized
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>

<p style="margin-left:11%;"><b>MathHeader</b></p>

<p style="margin-left:22%;">A string specifying the header
to include to get the definition of <i>NAN</i>. Default is
<i>&lt;math.h&gt;</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;interfaces&minus;global&minus;init</b>
<br>
This check flags initializers of globals that access extern
objects, and therefore can lead to
order&minus;of&minus;initialization problems.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Interfaces&quot; profile of the C++ Core
Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri&minus;global&minus;init</i></p>

<p style="margin-left:11%; margin-top: 1em">Note that
currently this does not flag calls to non&minus;constexpr
functions, and therefore globals could still be accessed
from functions themselves.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;macro&minus;to&minus;enum</b>
<br>
The cppcoreguidelines&minus;macro&minus;to&minus;enum check
is an alias, please see
<i>modernize&minus;macro&minus;to&minus;enum</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;macro&minus;usage</b>
<br>
Finds macro usage that is considered problematic because
better language constructs exist for the task.</p>

<p style="margin-left:11%; margin-top: 1em">The relevant
sections in the C++ Core Guidelines are <i>ES.31</i>, and
<i>ES.32</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">#define C 0
#define F1(x, y) ((a) &gt; (b) ? (a) : (b))
#define F2(...) (__VA_ARGS__)
#define COMMA ,
#define NORETURN [[noreturn]]
#define DEPRECATED attribute((deprecated))
#if LIB_EXPORTS
#define DLLEXPORTS __declspec(dllexport)
#else
#define DLLEXPORTS __declspec(dllimport)
#endif</pre>


<p style="margin-left:11%; margin-top: 1em">results in the
following warnings:</p>

<pre style="margin-left:15%; margin-top: 1em">4 warnings generated.
test.cpp:1:9: warning: macro 'C' used to declare a constant; consider using a 'constexpr' constant [cppcoreguidelines&minus;macro&minus;usage]
#define C 0
        ^
test.cpp:2:9: warning: function&minus;like macro 'F1' used; consider a 'constexpr' template function [cppcoreguidelines&minus;macro&minus;usage]
#define F1(x, y) ((a) &gt; (b) ? (a) : (b))
        ^
test.cpp:3:9: warning: variadic macro 'F2' used; consider using a 'constexpr' variadic template function [cppcoreguidelines&minus;macro&minus;usage]
#define F2(...) (__VA_ARGS__)
        ^</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
AllowedRegexp</b></p>

<p style="margin-left:22%;">A regular expression to filter
allowed macros. For example
<i>DEBUG*|LIBTORRENT*|TORRENT*|UNI*</i> could be applied to
filter <i>libtorrent</i>. Default value is
<i>^DEBUG_*</i>.</p>

<p style="margin-left:11%;"><b>CheckCapsOnly</b></p>

<p style="margin-left:22%;">Boolean flag to warn on all
macros except those with CAPS_ONLY names. This option is
intended to ease introduction of this check into older code
bases. Default value is <i>false</i>.</p>


<p style="margin-left:11%;"><b>IgnoreCommandLineMacros</b></p>

<p style="margin-left:22%;">Boolean flag to toggle ignoring
command&minus;line&minus;defined macros. Default value is
<i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;narrowing&minus;conversions</b>
<br>
Checks for silent narrowing conversions, e.g: <b>int i = 0;
i += 0.1;</b>. While the issue is obvious in this former
example, it might not be so in the following: <b>void
MyClass::f(double d) { int_member_ += d; }</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Expressions and statements&quot; profile
of the C++ Core Guidelines, corresponding to rule ES.46.
See</p>


<p style="margin-left:11%; margin-top: 1em"><i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es46&minus;avoid&minus;lossy&minus;narrowing&minus;truncating&minus;arithmetic&minus;conversions</i>.
<b><br>
We enforce only part of the guideline, more specifically, we
flag <br>
narrowing conversions from:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>an integer to a narrower integer (e.g. <b>char</b> to
<b>unsigned char</b>) if WarnOnIntegerNarrowingConversion
Option is set,</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>an integer to a narrower floating&minus;point (e.g.
<b>uint64_t</b> to <b>float</b>) if
WarnOnIntegerToFloatingPointNarrowingConversion Option is
set,</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>a floating&minus;point to an integer (e.g. <b>double</b>
to <b>int</b>),</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>a floating&minus;point to a narrower
floating&minus;point (e.g. <b>double</b> to <b>float</b>) if
WarnOnFloatingPointNarrowingConversion Option is set.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>This check will
flag:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>All narrowing conversions that are not marked by an
explicit cast (c&minus;style or <b>static_cast</b>). For
example: <b>int i = 0; i += 0.1;</b>, <b>void f(int);
f(0.1);</b>,</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>All applications of binary operators with a narrowing
conversions. For example: <b>int i; i+= 0.1;</b>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
WarnOnIntegerNarrowingConversion</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on narrowing integer conversion (e.g. <b>int</b>
to <b>size_t</b>). <i>true</i> by default.</p>


<p style="margin-left:11%;"><b>WarnOnIntegerToFloatingPointNarrowingConversion</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on narrowing integer to floating&minus;point
conversion (e.g. <b>size_t</b> to <b>double</b>).
<i>true</i> by default.</p>


<p style="margin-left:11%;"><b>WarnOnFloatingPointNarrowingConversion</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on narrowing floating point conversion (e.g.
<b>double</b> to <b>float</b>). <i>true</i> by default.</p>


<p style="margin-left:11%;"><b>WarnWithinTemplateInstantiation</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on narrowing conversions within template
instantiations. <i>false</i> by default.</p>


<p style="margin-left:11%;"><b>WarnOnEquivalentBitWidth</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on narrowing conversions that arise from casting
between types of equivalent bit width. (e.g. <i>int n =
uint(0);</i> or <i>long long n = double(0);</i>) <i>true</i>
by default.</p>


<p style="margin-left:11%;"><b>IgnoreConversionFromTypes</b></p>

<p style="margin-left:22%;">Narrowing conversions from any
type in this semicolon&minus;separated list will be ignored.
This may be useful to weed out commonly occurring, but less
commonly problematic assignments such as <i>int n =
std::vector&lt;char&gt;().size();</i> or <i>int n =
std::difference(it1, it2);</i>. The default list is empty,
but one suggested list for a legacy codebase would be
<i>size_t;ptrdiff_t;size_type;difference_type</i>.</p>

<p style="margin-left:11%;"><b>PedanticMode</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will warn on assigning a floating point constant to an
integer value even if the floating point value is exactly
representable in the destination type (e.g. <b>int i =
1.0;</b>). <i>false</i> by default.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FAQ</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>What does &quot;narrowing conversion from 'int' to
'float'&quot; mean?</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">An IEEE754
Floating Point number can represent all integer values in
the range [&minus;2^PrecisionBits, 2^PrecisionBits] where
PrecisionBits is the number of bits in the mantissa.</p>

<p style="margin-left:11%; margin-top: 1em">For
<b>float</b> this would be [&minus;2^23, 2^23], where
<b>int</b> can represent values in the range [&minus;2^31,
2^31&minus;1].</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="62%">


<p style="margin-top: 1em">What does
&quot;implementation&minus;defined&quot; mean?</p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">You may have
encountered messages like &quot;narrowing conversion from
'unsigned int' to signed type 'int' is
implementation&minus;defined&quot;. The C/C++ standard does
not mandate two's complement for signed integers, and so the
compiler is free to define what the semantics are for
converting an unsigned integer to signed integer. Clang's
implementation uses the two's complement format.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;no&minus;malloc</b>
<br>
This check handles C&minus;Style memory management using
<b>malloc()</b>, <b>realloc()</b>, <b>calloc()</b> and
<b>free()</b>. It warns about its use and tries to suggest
the use of an appropriate RAII object. Furthermore, it can
be configured to check against a user&minus;specified list
of functions that are used for memory management (e.g.
<b>posix_memalign()</b>). See <i>C++ Core
Guidelines</i>.</p>

<p style="margin-left:11%; margin-top: 1em">There is no
attempt made to provide fix&minus;it hints, since manual
resource management isn't easily transformed automatically
into RAII.</p>
<pre style="margin-left:15%; margin-top: 1em">// Warns each of the following lines.
// Containers like std::vector or std::string should be used.
char* some_string = (char*) malloc(sizeof(char) * 20);
char* some_string = (char*) realloc(sizeof(char) * 30);
free(some_string);

int* int_array = (int*) calloc(30, sizeof(int));


// Rather use a smartpointer or stack variable.
struct some_struct* s = (struct some_struct*) malloc(sizeof(struct some_struct));</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
Allocations</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of fully qualified names of memory allocation functions.
Defaults to <b>::malloc;::calloc</b>.</p>

<p style="margin-left:11%;"><b>Deallocations</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of fully qualified names of memory allocation functions.
Defaults to <b>::free</b>.</p>

<p style="margin-left:11%;"><b>Reallocations</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of fully qualified names of memory allocation functions.
Defaults to <b>::realloc</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;non&minus;private&minus;member&minus;variables&minus;in&minus;classes</b>
<br>
The
cppcoreguidelines&minus;non&minus;private&minus;member&minus;variables&minus;in&minus;classes
check is an alias, please see
<i>misc&minus;non&minus;private&minus;member&minus;variables&minus;in&minus;classes</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;owning&minus;memory</b>
<br>
This check implements the type&minus;based semantics of
<b>gsl::owner&lt;T*&gt;</b>, which allows static analysis on
code, that uses raw pointers to handle resources like
dynamic memory, but won't introduce RAII concepts.</p>

<p style="margin-left:11%; margin-top: 1em">The relevant
sections in the <i>C++ Core Guidelines</i> are I.11, C.33,
R.3 and GSL.Views The definition of a
<b>gsl::owner&lt;T*&gt;</b> is straight forward</p>

<pre style="margin-left:15%; margin-top: 1em">namespace gsl { template &lt;typename T&gt; owner = T; }</pre>


<p style="margin-left:11%; margin-top: 1em">It is therefore
simple to introduce the owner even without using an
implementation of the <i>Guideline Support Library</i>.</p>

<p style="margin-left:11%; margin-top: 1em">All checks are
purely type based and not (yet) flow sensitive.</p>

<p style="margin-left:11%; margin-top: 1em">The following
examples will demonstrate the correct and incorrect
initializations of owners, assignment is handled the same
way. Note that both <b>new</b> and
<b>malloc()</b>&minus;like resource functions are considered
to produce resources.</p>
<pre style="margin-left:15%; margin-top: 1em">// Creating an owner with factory functions is checked.
gsl::owner&lt;int*&gt; function_that_returns_owner() { return gsl::owner&lt;int*&gt;(new int(42)); }

// Dynamic memory must be assigned to an owner
int* Something = new int(42); // BAD, will be caught
gsl::owner&lt;int*&gt; Owner = new int(42); // Good
gsl::owner&lt;int*&gt; Owner = new int[42]; // Good as well

// Returned owner must be assigned to an owner
int* Something = function_that_returns_owner(); // Bad, factory function
gsl::owner&lt;int*&gt; Owner = function_that_returns_owner(); // Good, result lands in owner


// Something not a resource or owner should not be assigned to owners
int Stack = 42;
gsl::owner&lt;int*&gt; Owned = &amp;Stack; // Bad, not a resource assigned</pre>


<p style="margin-left:11%; margin-top: 1em">In the case of
dynamic memory as resource, only <b>gsl::owner&lt;T*&gt;</b>
variables are allowed to be deleted.</p>
<pre style="margin-left:15%; margin-top: 1em">// Example Bad, non&minus;owner as resource handle, will be caught.
int* NonOwner = new int(42); // First warning here, since new must land in an owner
delete NonOwner; // Second warning here, since only owners are allowed to be deleted


// Example Good, Ownership correctly stated
gsl::owner&lt;int*&gt; Owner = new int(42); // Good
delete Owner; // Good as well, statically enforced, that only owners get deleted</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
furthermore ensure, that functions, that expect a
<b>gsl::owner&lt;T*&gt;</b> as argument get called with
either a <b>gsl::owner&lt;T*&gt;</b> or a newly created
resource.</p>
<pre style="margin-left:15%; margin-top: 1em">void expects_owner(gsl::owner&lt;int*&gt; o) { delete o; }

// Bad Code
int NonOwner = 42;
expects_owner(&amp;NonOwner); // Bad, will get caught

// Good Code
gsl::owner&lt;int*&gt; Owner = new int(42);
expects_owner(Owner); // Good
expects_owner(new int(42)); // Good as well, recognized created resource

// Port legacy code for better resource&minus;safety
gsl::owner&lt;FILE*&gt; File = fopen(&quot;my_file.txt&quot;, &quot;rw+&quot;);
FILE* BadFile = fopen(&quot;another_file.txt&quot;, &quot;w&quot;); // Bad, warned

// ... use the file


fclose(File); // Ok, File is annotated as 'owner&lt;&gt;'
fclose(BadFile); // BadFile is not an 'owner&lt;&gt;', will be warned</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
LegacyResourceProducers</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of fully qualified names of legacy functions that create
resources but cannot introduce <b>gsl::owner&lt;&gt;</b>.
Defaults to
<b>::malloc;::aligned_alloc;::realloc;::calloc;::fopen;::freopen;::tmpfile</b>.</p>


<p style="margin-left:11%;"><b>LegacyResourceConsumers</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of fully qualified names of legacy functions expecting
resource owners as pointer arguments but cannot introduce
<b>gsl::owner&lt;&gt;</b>. Defaults to
<b>::free;::realloc;::freopen;::fclose</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Limitations</b>
<br>
Using <b>gsl::owner&lt;T*&gt;</b> in a typedef or alias is
not handled correctly.</p>

<pre style="margin-left:15%; margin-top: 1em">using heap_int = gsl::owner&lt;int*&gt;;
heap_int allocated = new int(42); // False positive!</pre>


<p style="margin-left:11%; margin-top: 1em">The
<b>gsl::owner&lt;T*&gt;</b> is declared as a templated type
alias. In template functions and classes, like in the
example below, the information of the type aliases gets
lost. Therefore using <b>gsl::owner&lt;T*&gt;</b> in a heavy
templated code base might lead to false positives.</p>

<p style="margin-left:11%; margin-top: 1em">Known code
constructs that do not get diagnosed correctly are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p><b>std::exchange</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="41%">


<p><b>std::vector&lt;gsl::owner&lt;T*&gt;&gt;</b></p></td>
<td width="45%">
</td></tr>
</table>
<pre style="margin-left:15%; margin-top: 1em">// This template function works as expected. Type information doesn't get lost.
template &lt;typename T&gt;
void delete_owner(gsl::owner&lt;T*&gt; owned_object) {
  delete owned_object; // Everything alright
}

gsl::owner&lt;int*&gt; function_that_returns_owner() { return gsl::owner&lt;int*&gt;(new int(42)); }

// Type deduction does not work for auto variables.
// This is caught by the check and will be noted accordingly.
auto OwnedObject = function_that_returns_owner(); // Type of OwnedObject will be int*

// Problematic function template that looses the typeinformation on owner
template &lt;typename T&gt;
void bad_template_function(T some_object) {
  // This line will trigger the warning, that a non&minus;owner is assigned to an owner
  gsl::owner&lt;T*&gt; new_owner = some_object;
}

// Calling the function with an owner still yields a false positive.
bad_template_function(gsl::owner&lt;int*&gt;(new int(42)));


// The same issue occurs with templated classes like the following.
template &lt;typename T&gt;
class OwnedValue {
public:
  const T getValue() const { return _val; }
private:
  T _val;
};


// Code, that yields a false positive.
OwnedValue&lt;gsl::owner&lt;int*&gt;&gt; Owner(new int(42)); // Type deduction yield T &minus;&gt; int *
// False positive, getValue returns int* and not gsl::owner&lt;int*&gt;
gsl::owner&lt;int*&gt; OwnedInt = Owner.getValue();</pre>


<p style="margin-left:11%; margin-top: 1em">Another
limitation of the current implementation is only the type
based checking. Suppose you have code like the
following:</p>
<pre style="margin-left:15%; margin-top: 1em">// Two owners with assigned resources
gsl::owner&lt;int*&gt; Owner1 = new int(42);
gsl::owner&lt;int*&gt; Owner2 = new int(42);


Owner2 = Owner1; // Conceptual Leak of initial resource of Owner2!
Owner1 = nullptr;</pre>


<p style="margin-left:11%; margin-top: 1em">The semantic of
a <b>gsl::owner&lt;T*&gt;</b> is mostly like a
<b>std::unique_ptr&lt;T&gt;</b>, therefore assignment of two
<b>gsl::owner&lt;T*&gt;</b> is considered a move, which
requires that the resource <b>Owner2</b> must have been
released before the assignment. This kind of condition could
be caught in later improvements of this check with
flowsensitive analysis. Currently, the <i>Clang Static
Analyzer</i> catches this bug for dynamic memory, but not
for general types of resources.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;prefer&minus;member&minus;initializer</b>
<br>
Finds member initializations in the constructor body which
can be converted into member initializers of the constructor
instead. This not only improves the readability of the code
but also positively affects its performance.
Class&minus;member assignments inside a control statement or
following the first control statement are ignored.</p>

<p style="margin-left:11%; margin-top: 1em">This check
implements <i>C.49</i> from the CppCoreGuidelines.</p>

<p style="margin-left:11%; margin-top: 1em">If the language
version is <i>C++ 11</i> or above, the constructor is the
default constructor of the class, the field is not a
bitfield (only in case of earlier language version than
<i>C++ 20</i>), furthermore the assigned value is a literal,
negated literal or <b>enum</b> constant then the preferred
place of the initialization is at the class member
declaration.</p>

<p style="margin-left:11%; margin-top: 1em">This latter
rule is <i>C.48</i> from CppCoreGuidelines.</p>

<p style="margin-left:11%; margin-top: 1em">Please note,
that this check does not enforce this latter rule for
initializations already implemented as member initializers.
For that purpose see check
<i>modernize&minus;use&minus;default&minus;member&minus;init</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
1</b></p>

<pre style="margin-left:15%;">class C {
  int n;
  int m;
public:
  C() {
    n = 1; // Literal in default constructor
    if (dice())
      return;
    m = 1;
  }
};</pre>


<p style="margin-left:11%; margin-top: 1em">Here <b>n</b>
can be initialized using a default member initializer,
unlike <b>m</b>, as <b>m</b>'s initialization follows a
control statement (<b>if</b>):</p>

<pre style="margin-left:15%; margin-top: 1em">class C {
  int n{1};
  int m;
public:
  C() {
    if (dice())
      return;
    m = 1;
  }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Example
2</b></p>

<pre style="margin-left:15%;">class C {
  int n;
  int m;
public:
  C(int nn, int mm) {
    n = nn; // Neither default constructor nor literal
    if (dice())
      return;
    m = mm;
  }
};</pre>


<p style="margin-left:11%; margin-top: 1em">Here <b>n</b>
can be initialized in the constructor initialization list,
unlike <b>m</b>, as <b>m</b>'s initialization follows a
control statement (<b>if</b>):</p>

<pre style="margin-left:15%; margin-top: 1em">C(int nn, int mm) : n(nn) {
  if (dice())
    return;
  m = mm;
}</pre>


<p style="margin-left:11%;"><b>UseAssignment</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i> (default is <i>false</i>), the check will
initialize members with an assignment. In this case the fix
of the first example looks like this:</p>

<pre style="margin-left:15%; margin-top: 1em">class C {
  int n = 1;
  int m;
public:
  C() {
    if (dice())
      return;
    m = 1;
  }
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;bounds&minus;array&minus;to&minus;pointer&minus;decay</b>
<br>
This check flags all array to pointer decays.</p>

<p style="margin-left:11%; margin-top: 1em">Pointers should
not be used as arrays. <b>span&lt;T&gt;</b> is a
bounds&minus;checked, safe alternative to using pointers to
access arrays.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Bounds safety&quot; profile of the C++
Core Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;bounds&minus;decay</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;bounds&minus;constant&minus;array&minus;index</b>
<br>
This check flags all array subscript expressions on static
arrays and <b>std::arrays</b> that either do not have a
constant integer expression index or are out of bounds (for
<b>std::array</b>). For out&minus;of&minus;bounds checking
of static arrays, see the <i>&minus;Warray&minus;bounds</i>
Clang diagnostic.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Bounds safety&quot; profile of the C++
Core Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;bounds&minus;arrayindex</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Optionally,
this check can generate fixes using <b>gsl::at</b> for
indexing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
GslHeader</b></p>

<p style="margin-left:22%;">The check can generate fixes
after this option has been set to the name of the include
file that contains <b>gsl::at()</b>, e.g.
<i>&quot;gsl/gsl.h&quot;</i>.</p>

<p style="margin-left:11%;"><b>IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;bounds&minus;pointer&minus;arithmetic</b>
<br>
This check flags all usage of pointer arithmetic, because it
could lead to an invalid pointer. Subtraction of two
pointers is not flagged by this check.</p>

<p style="margin-left:11%; margin-top: 1em">Pointers should
only refer to single objects, and pointer arithmetic is
fragile and easy to get wrong. <b>span&lt;T&gt;</b> is a
bounds&minus;checked, safe type for accessing arrays of
data.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Bounds safety&quot; profile of the C++
Core Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;bounds&minus;arithmetic</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;type&minus;const&minus;cast</b>
<br>
This check flags all uses of <b>const_cast</b> in C++
code.</p>

<p style="margin-left:11%; margin-top: 1em">Modifying a
variable that was declared const is undefined behavior, even
with <b>const_cast</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Type safety&quot; profile of the C++ Core
Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;type&minus;constcast</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;type&minus;cstyle&minus;cast</b>
<br>
This check flags all use of C&minus;style casts that perform
a <b>static_cast</b> downcast, <b>const_cast</b>, or
<b>reinterpret_cast</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Use of these
casts can violate type safety and cause the program to
access a variable that is actually of type X to be accessed
as if it were of an unrelated type Z. Note that a
C&minus;style <b>(T)expression</b> cast means to perform the
first of the following that is possible: a
<b>const_cast</b>, a <b>static_cast</b>, a
<b>static_cast</b> followed by a <b>const_cast</b>, a
<b>reinterpret_cast</b>, or a <b>reinterpret_cast</b>
followed by a <b>const_cast</b>. This rule bans
<b>(T)expression</b> only when used to perform an unsafe
cast.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Type safety&quot; profile of the C++ Core
Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;type&minus;cstylecast</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;type&minus;member&minus;init</b>
<br>
The check flags user&minus;defined constructor definitions
that do not initialize all fields that would be left in an
undefined state by default construction, e.g. builtins,
pointers and record types without user&minus;provided
default constructors containing at least one such type. If
these fields aren't initialized, the constructor will leave
some of the memory in an undefined state.</p>

<p style="margin-left:11%; margin-top: 1em">For C++11 it
suggests fixes to add in&minus;class field initializers. For
older versions it inserts the field initializers into the
constructor initializer list. It will also initialize any
direct base classes that need to be zeroed in the
constructor initializer list.</p>

<p style="margin-left:11%; margin-top: 1em">The check takes
assignment of fields in the constructor body into account
but generates false positives for fields initialized in
methods invoked in the constructor body.</p>

<p style="margin-left:11%; margin-top: 1em">The check also
flags variables with automatic storage duration that have
record types without a user&minus;provided constructor and
are not initialized. The suggested fix is to zero initialize
the variable via <b>{}</b> for C++11 and beyond or <b>=
{}</b> for older language versions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoreArrays</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will not warn about array members that are not
zero&minus;initialized during construction. For performance
critical code, it may be important to not initialize
fixed&minus;size array members. Default is <i>false</i>.</p>

<p style="margin-left:11%;"><b>UseAssignment</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will provide fix&minus;its with literal initializers (
<b>int i = 0;</b> ) instead of curly braces ( <b>int
i{};</b> ).</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Type safety&quot; profile of the C++ Core
Guidelines, corresponding to rule Type.6. See
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;type&minus;memberinit</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;type&minus;reinterpret&minus;cast</b>
<br>
This check flags all uses of <b>reinterpret_cast</b> in C++
code.</p>

<p style="margin-left:11%; margin-top: 1em">Use of these
casts can violate type safety and cause the program to
access a variable that is actually of type <b>X</b> to be
accessed as if it were of an unrelated type <b>Z</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Type safety&quot; profile of the C++ Core
Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;type&minus;reinterpretcast</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;type&minus;static&minus;cast&minus;downcast</b>
<br>
This check flags all usages of <b>static_cast</b>, where a
base class is casted to a derived class. In those cases, a
fix&minus;it is provided to convert the cast to a
<b>dynamic_cast</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Use of these
casts can violate type safety and cause the program to
access a variable that is actually of type <b>X</b> to be
accessed as if it were of an unrelated type <b>Z</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Type safety&quot; profile of the C++ Core
Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;type&minus;downcast</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;type&minus;union&minus;access</b>
<br>
This check flags all access to members of unions. Passing
unions as a whole is not flagged.</p>

<p style="margin-left:11%; margin-top: 1em">Reading from a
union member assumes that member was the last one written,
and writing to a union member assumes another member with a
nontrivial destructor had its destructor called. This is
fragile because it cannot generally be enforced to be safe
in the language and so relies on programmer discipline to
get it right.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Type safety&quot; profile of the C++ Core
Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;type&minus;unions</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;pro&minus;type&minus;vararg</b>
<br>
This check flags all calls to c&minus;style vararg functions
and all use of <b>va_arg</b>.</p>

<p style="margin-left:11%; margin-top: 1em">To allow for
SFINAE use of vararg functions, a call is not flagged if a
literal 0 is passed as the only vararg argument.</p>

<p style="margin-left:11%; margin-top: 1em">Passing to
varargs assumes the correct type will be read. This is
fragile because it cannot generally be enforced to be safe
in the language and so relies on programmer discipline to
get it right.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Type safety&quot; profile of the C++ Core
Guidelines, see
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Pro&minus;type&minus;varargs</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;slicing</b>
<br>
Flags slicing of member variables or vtable. Slicing happens
when copying a derived object into a base object: the
members of the derived object (both member variables and
virtual member functions) will be discarded. This can be
misleading especially for member function slicing, for
example:</p>
<pre style="margin-left:15%; margin-top: 1em">struct B { int a; virtual int f(); };
struct D : B { int b; int f() override; };

void use(B b) {  // Missing reference, intended?
  b.f();  // Calls B::f.
}

D d;
use(d);  // Slice.</pre>

<p style="margin-left:11%; margin-top: 1em">See the
relevant C++ Core Guidelines sections for details:
<i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es63&minus;dont&minus;slice
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c145&minus;access&minus;polymorphic&minus;objects&minus;through&minus;pointers&minus;and&minus;references</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;special&minus;member&minus;functions</b>
<br>
The check finds classes where some but not all of the
special member functions are defined.</p>

<p style="margin-left:11%; margin-top: 1em">By default the
compiler defines a copy constructor, copy assignment
operator, move constructor, move assignment operator and
destructor. The default can be suppressed by explicit
user&minus;definitions. The relationship between which
functions will be suppressed by definitions of other
functions is complicated and it is advised that all five are
defaulted or explicitly defined.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
defining a function with <b>= delete</b> is considered to be
a definition.</p>

<p style="margin-left:11%; margin-top: 1em">This rule is
part of the &quot;Constructors, assignments, and
destructors&quot; profile of the C++ Core Guidelines,
corresponding to rule C.21. See</p>


<p style="margin-left:11%; margin-top: 1em"><i>https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c21&minus;if&minus;you&minus;define&minus;or&minus;delete&minus;any&minus;default&minus;operation&minus;define&minus;or&minus;delete&minus;them&minus;all</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
AllowSoleDefaultDtor</b></p>

<p style="margin-left:22%;">When set to <i>true</i>
(default is <i>false</i>), this check doesn't flag classes
with a sole, explicitly defaulted destructor. An example for
such a class is:</p>

<pre style="margin-left:26%; margin-top: 1em">struct A {
  virtual ~A() = default;
};</pre>



<p style="margin-left:11%;"><b>AllowMissingMoveFunctions</b></p>

<p style="margin-left:22%;">When set to <i>true</i>
(default is <i>false</i>), this check doesn't flag classes
which define no move operations at all. It still flags
classes which define only one of either move constructor or
move assignment operator. With this option enabled, the
following class won't be flagged:</p>

<pre style="margin-left:26%; margin-top: 1em">struct A {
  A(const A&amp;);
  A&amp; operator=(const A&amp;);
  ~A();
};</pre>



<p style="margin-left:11%;"><b>AllowMissingMoveFunctionsWhenCopyIsDeleted</b></p>

<p style="margin-left:22%;">When set to <i>true</i>
(default is <i>false</i>), this check doesn't flag classes
which define deleted copy operations but don't define move
operations. This flag is related to Google C++ Style Guide
<i>https://google.github.io/styleguide/cppguide.html#Copyable_Movable_Types</i>.
With this option enabled, the following class won't be
flagged:</p>

<pre style="margin-left:26%; margin-top: 1em">struct A {
  A(const A&amp;) = delete;
  A&amp; operator=(const A&amp;) = delete;
  ~A();
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>cppcoreguidelines&minus;virtual&minus;class&minus;destructor</b>
<br>
Finds virtual classes whose destructor is neither public and
virtual nor protected and non&minus;virtual. A virtual
class's destructor should be specified in one of these ways
to prevent undefined behavior.</p>

<p style="margin-left:11%; margin-top: 1em">This check
implements <i>C.35</i> from the CppCoreGuidelines.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
check will diagnose a class with a virtual method regardless
of whether the class is used as a base class or not.</p>

<p style="margin-left:11%; margin-top: 1em">Fixes are
available for user&minus;declared and implicit destructors
that are either public and non&minus;virtual or protected
and virtual. No fixes are offered for private destructors.
There, the decision whether to make them private and virtual
or protected and non&minus;virtual depends on the use case
and is thus left to the user.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
For example, the following classes/structs get flagged by
the check since they violate guideline <b>C.35</b>:</p>
<pre style="margin-left:15%; margin-top: 1em">struct Foo {        // NOK, protected destructor should not be virtual
  virtual void f();
protected:
  virtual ~Foo(){}
};


class Bar {         // NOK, public destructor should be virtual
  virtual void f();
public:
  ~Bar(){}
};</pre>


<p style="margin-left:11%; margin-top: 1em">This would be
rewritten to look like this:</p>
<pre style="margin-left:15%; margin-top: 1em">struct Foo {        // OK, destructor is not virtual anymore
  virtual void f();
protected:
  ~Foo(){}
};


class Bar {         // OK, destructor is now virtual
  virtual void f();
public:
  virtual ~Bar(){}
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>darwin&minus;avoid&minus;spinlock</b>
<br>
Finds usages of <b>OSSpinlock</b>, which is deprecated due
to potential livelock problems.</p>

<p style="margin-left:11%; margin-top: 1em">This check will
detect following function invocations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="24%">


<p><b>OSSpinlockLock</b></p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="24%">


<p><b>OSSpinlockTry</b></p></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="24%">


<p><b>OSSpinlockUnlock</b></p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
corresponding information about the problem of
<b>OSSpinlock</b>:
<i>https://blog.postmates.com/why&minus;spinlocks&minus;are&minus;bad&minus;on&minus;ios&minus;b69fc5221058</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>darwin&minus;dispatch&minus;once&minus;nonstatic</b>
<br>
Finds declarations of <b>dispatch_once_t</b> variables
without static or global storage. The behavior of using
<b>dispatch_once_t</b> predicates with automatic or dynamic
storage is undefined by libdispatch, and should be
avoided.</p>

<p style="margin-left:11%; margin-top: 1em">It is a common
pattern to have functions initialize internal static or
global data once when the function runs, but programmers
have been known to miss the static on the
<b>dispatch_once_t</b> predicate, leading to an
uninitialized flag value at the mercy of the stack.</p>

<p style="margin-left:11%; margin-top: 1em">Programmers
have also been known to make <b>dispatch_once_t</b>
variables be members of structs or classes, with the intent
to lazily perform some expensive struct or class member
initialization only once; however, this violates the
libdispatch requirements.</p>

<p style="margin-left:11%; margin-top: 1em">See the
discussion section of <i>Apple's dispatch_once
documentation</i> for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>fuchsia&minus;default&minus;arguments&minus;calls</b>
<br>
Warns if a function or method is called with default
arguments.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
given the declaration:</p>

<pre style="margin-left:15%; margin-top: 1em">int foo(int value = 5) { return value; }</pre>


<p style="margin-left:11%; margin-top: 1em">A function call
expression that uses a default argument will be diagnosed.
Calling it without defaults will not cause a warning:</p>

<pre style="margin-left:15%; margin-top: 1em">foo();  // warning
foo(0); // no warning</pre>


<p style="margin-left:11%; margin-top: 1em">See the
features disallowed in Fuchsia at
<i>https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>fuchsia&minus;default&minus;arguments&minus;declarations</b>
<br>
Warns if a function or method is declared with default
parameters.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the declaration:</p>

<pre style="margin-left:15%; margin-top: 1em">int foo(int value = 5) { return value; }</pre>


<p style="margin-left:11%; margin-top: 1em">will cause a
warning.</p>

<p style="margin-left:11%; margin-top: 1em">See the
features disallowed in Fuchsia at
<i>https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>fuchsia&minus;header&minus;anon&minus;namespaces</b>
<br>
The fuchsia&minus;header&minus;anon&minus;namespaces check
is an alias, please see
<i>google&minus;build&minus;namespace</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>fuchsia&minus;multiple&minus;inheritance</b>
<br>
Warns if a class inherits from multiple classes that are not
pure virtual.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
declaring a class that inherits from multiple concrete
classes is disallowed:</p>
<pre style="margin-left:15%; margin-top: 1em">class Base_A {
public:
  virtual int foo() { return 0; }
};

class Base_B {
public:
  virtual int bar() { return 0; }
};


// Warning
class Bad_Child1 : public Base_A, Base_B {};</pre>


<p style="margin-left:11%; margin-top: 1em">A class that
inherits from a pure virtual is allowed:</p>
<pre style="margin-left:15%; margin-top: 1em">class Interface_A {
public:
  virtual int foo() = 0;
};

class Interface_B {
public:
  virtual int bar() = 0;
};


// No warning
class Good_Child1 : public Interface_A, Interface_B {
  virtual int foo() override { return 0; }
  virtual int bar() override { return 0; }
};</pre>


<p style="margin-left:11%; margin-top: 1em">See the
features disallowed in Fuchsia at
<i>https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>fuchsia&minus;overloaded&minus;operator</b>
<br>
Warns if an operator is overloaded, except for the
assignment (copy and move) operators.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>
<pre style="margin-left:15%; margin-top: 1em">int operator+(int);     // Warning


B &amp;operator=(const B &amp;Other);  // No warning
B &amp;operator=(B &amp;&amp;Other) // No warning</pre>


<p style="margin-left:11%; margin-top: 1em">See the
features disallowed in Fuchsia at
<i>https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>fuchsia&minus;statically&minus;constructed&minus;objects</b>
<br>
Warns if global, non&minus;trivial objects with static
storage are constructed, unless the object is statically
initialized with a <b>constexpr</b> constructor or has no
explicit constructor.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>
<pre style="margin-left:15%; margin-top: 1em">class A {};

class B {
public:
  B(int Val) : Val(Val) {}
private:
  int Val;
};

class C {
public:
  C(int Val) : Val(Val) {}
  constexpr C() : Val(0) {}

private:
  int Val;
};

static A a;         // No warning, as there is no explicit constructor
static C c(0);      // No warning, as constructor is constexpr

static B b(0);      // Warning, as constructor is not constexpr
static C c2(0, 1);  // Warning, as constructor is not constexpr

static int i;       // No warning, as it is trivial


extern int get_i();
static C(get_i())   // Warning, as the constructor is dynamically initialized</pre>


<p style="margin-left:11%; margin-top: 1em">See the
features disallowed in Fuchsia at
<i>https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>fuchsia&minus;trailing&minus;return</b>
<br>
Functions that have trailing returns are disallowed, except
for those using <b>decltype</b> specifiers and lambda with
otherwise unutterable return types.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>
<pre style="margin-left:15%; margin-top: 1em">// No warning
int add_one(const int arg) { return arg; }


// Warning
auto get_add_one() &minus;&gt; int (*)(const int) {
  return add_one;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Exceptions are
made for lambdas and <b>decltype</b> specifiers:</p>
<pre style="margin-left:15%; margin-top: 1em">// No warning
auto lambda = [](double x, double y) &minus;&gt; double {return x + y;};


// No warning
template &lt;typename T1, typename T2&gt;
auto fn(const T1 &amp;lhs, const T2 &amp;rhs) &minus;&gt; decltype(lhs + rhs) {
  return lhs + rhs;
}</pre>


<p style="margin-left:11%; margin-top: 1em">See the
features disallowed in Fuchsia at
<i>https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>fuchsia&minus;virtual&minus;inheritance</b>
<br>
Warns if classes are defined with virtual inheritance.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
classes should not be defined with virtual inheritance:</p>

<pre style="margin-left:15%; margin-top: 1em">class B : public virtual A {};   // warning</pre>


<p style="margin-left:11%; margin-top: 1em">See the
features disallowed in Fuchsia at
<i>https://fuchsia.googlesource.com/zircon/+/master/docs/cxx.md</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;build&minus;explicit&minus;make&minus;pair</b>
<br>
Check that <b>make_pair</b>'s template arguments are
deduced.</p>

<p style="margin-left:11%; margin-top: 1em">G++ 4.6 in
C++11 mode fails badly if <b>make_pair</b>'s template
arguments are specified explicitly, and such use isn't
intended in any case.</p>

<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check name: <i>build/explicit_make_pair</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;build&minus;namespaces</b>
<i><br>
cert&minus;dcl59&minus;cpp</i> redirects here as an alias
for this check.
<i>fuchsia&minus;header&minus;anon&minus;namespaces</i>
redirects here as an alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Finds anonymous
namespaces in headers.</p>


<p style="margin-left:11%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Namespaces</i></p>

<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check name: <i>build/namespaces</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
HeaderFileExtensions</b></p>

<p style="margin-left:22%;">A comma&minus;separated list of
filename extensions of header files (the filename extensions
should not include &quot;.&quot; prefix). Default is
&quot;h,hh,hpp,hxx&quot;. For header files without an
extension, use an empty string (if there are no other
desired extensions) or leave an empty element in the list.
E.g., &quot;h,hh,hpp,hxx,&quot; (note the trailing
comma).</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;build&minus;using&minus;namespace</b>
<br>
Finds <b>using namespace</b> directives.</p>

<p style="margin-left:11%; margin-top: 1em">The check
implements the following rule of the <i>Google C++ Style
Guide</i>:</p>

<p style="margin-left:15%;">You may not use a
using&minus;directive to make all names from a namespace
available.</p>

<pre style="margin-left:15%; margin-top: 1em">// Forbidden &minus;&minus; This pollutes the namespace.
using namespace foo;</pre>


<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check name: <i>build/namespaces</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;default&minus;arguments</b>
<br>
Checks that default arguments are not given for virtual
methods.</p>

<p style="margin-left:11%; margin-top: 1em">See
<i>https://google.github.io/styleguide/cppguide.html#Default_Arguments</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;explicit&minus;constructor</b>
<br>
Checks that constructors callable with a single argument and
conversion operators are marked explicit to avoid the risk
of unintentional implicit conversions.</p>

<p style="margin-left:11%; margin-top: 1em">Consider this
example:</p>
<pre style="margin-left:15%; margin-top: 1em">struct S {
  int x;
  operator bool() const { return true; }
};

bool f() {
  S a{1};
  S b{2};
  return a == b;
}</pre>

<p style="margin-left:11%; margin-top: 1em">The function
will return <b>true</b>, since the objects are implicitly
converted to <b>bool</b> before comparison, which is
unlikely to be the intent.</p>

<p style="margin-left:11%; margin-top: 1em">The check will
suggest inserting <b>explicit</b> before the constructor or
conversion operator declaration. However, copy and move
constructors should not be explicit, as well as constructors
taking a single <b>initializer_list</b> argument.</p>

<p style="margin-left:11%; margin-top: 1em">This code:</p>

<pre style="margin-left:15%; margin-top: 1em">struct S {
  S(int a);
  explicit S(const S&amp;);
  operator bool() const;
  ...</pre>


<p style="margin-left:11%; margin-top: 1em">will become</p>

<pre style="margin-left:15%; margin-top: 1em">struct S {
  explicit S(int a);
  S(const S&amp;);
  explicit operator bool() const;
  ...</pre>


<p style="margin-left:11%; margin-top: 1em">See
<i>https://google.github.io/styleguide/cppguide.html#Explicit_Constructors</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;global&minus;names&minus;in&minus;headers</b>
<br>
Flag global namespace pollution in header files. Right now
it only triggers on <b>using</b> declarations and
directives.</p>

<p style="margin-left:11%; margin-top: 1em">The relevant
style guide section is
<i>https://google.github.io/styleguide/cppguide.html#Namespaces</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
HeaderFileExtensions</b></p>

<p style="margin-left:22%;">A comma&minus;separated list of
filename extensions of header files (the filename extensions
should not contain &quot;.&quot; prefix). Default is
&quot;h&quot;. For header files without an extension, use an
empty string (if there are no other desired extensions) or
leave an empty element in the list. E.g.,
&quot;h,hh,hpp,hxx,&quot; (note the trailing comma).</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;objc&minus;avoid&minus;nsobject&minus;new</b>
<br>
Finds calls to <b>+new</b> or overrides of it, which are
prohibited by the Google Objective&minus;C style guide.</p>

<p style="margin-left:11%; margin-top: 1em">The Google
Objective&minus;C style guide forbids calling <b>+new</b> or
overriding it in class implementations, preferring
<b>+alloc</b> and <b>&minus;init</b> methods to instantiate
objects.</p>

<p style="margin-left:11%; margin-top: 1em">An example:</p>

<pre style="margin-left:15%; margin-top: 1em">NSDate *now = [NSDate new];
Foo *bar = [Foo new];</pre>


<p style="margin-left:11%; margin-top: 1em">Instead, code
should use <b>+alloc</b>/<b>&minus;init</b> or class factory
methods.</p>

<pre style="margin-left:15%; margin-top: 1em">NSDate *now = [NSDate date];
Foo *bar = [[Foo alloc] init];</pre>


<p style="margin-left:11%; margin-top: 1em">This check
corresponds to the Google Objective&minus;C Style Guide rule
<i>Do Not Use +new</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;objc&minus;avoid&minus;throwing&minus;exception</b>
<br>
Finds uses of throwing exceptions usages in
Objective&minus;C files.</p>

<p style="margin-left:11%; margin-top: 1em">For the same
reason as the Google C++ style guide, we prefer not throwing
exceptions from Objective&minus;C code.</p>

<p style="margin-left:11%; margin-top: 1em">The
corresponding C++ style guide rule:
<i>https://google.github.io/styleguide/cppguide.html#Exceptions</i></p>

<p style="margin-left:11%; margin-top: 1em">Instead, prefer
passing in <b>NSError **</b> and return <b>BOOL</b> to
indicate success or failure.</p>

<p style="margin-left:11%; margin-top: 1em">A
counterexample:</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; (void)readFile {
  if ([self isError]) {
    @throw [NSException exceptionWithName:...];
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">Instead,
returning an error via <b>NSError **</b> is preferred:</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; (BOOL)readFileWithError:(NSError **)error {
  if ([self isError]) {
    *error = [NSError errorWithDomain:...];
    return NO;
  }
  return YES;
}</pre>


<p style="margin-left:11%; margin-top: 1em">The
corresponding style guide rule:
<i>https://google.github.io/styleguide/objcguide.html#avoid&minus;throwing&minus;exceptions</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;objc&minus;function&minus;naming</b>
<br>
Finds function declarations in Objective&minus;C files that
do not follow the pattern described in the Google
Objective&minus;C Style Guide.</p>

<p style="margin-left:11%; margin-top: 1em">The
corresponding style guide rule can be found here:
<i>https://google.github.io/styleguide/objcguide.html#function&minus;names</i></p>

<p style="margin-left:11%; margin-top: 1em">All function
names should be in Pascal case. Functions whose storage
class is not static should have an appropriate prefix.</p>

<p style="margin-left:11%; margin-top: 1em">The following
code sample does not follow this pattern:</p>

<pre style="margin-left:15%; margin-top: 1em">static bool is_positive(int i) { return i &gt; 0; }
bool IsNegative(int i) { return i &lt; 0; }</pre>


<p style="margin-left:11%; margin-top: 1em">The sample
above might be corrected to the following code:</p>

<pre style="margin-left:15%; margin-top: 1em">static bool IsPositive(int i) { return i &gt; 0; }
bool *ABCIsNegative(int i) { return i &lt; 0; }</pre>



<p style="margin-left:11%; margin-top: 1em"><b>google&minus;objc&minus;global&minus;variable&minus;declaration</b>
<br>
Finds global variable declarations in Objective&minus;C
files that do not follow the pattern of variable names in
Google's Objective&minus;C Style Guide.</p>

<p style="margin-left:11%; margin-top: 1em">The
corresponding style guide rule:
<i>https://google.github.io/styleguide/objcguide.html#variable&minus;names</i></p>

<p style="margin-left:11%; margin-top: 1em">All the global
variables should follow the pattern of <b>g[A&minus;Z].*</b>
(variables) or <b>k[A&minus;Z].*</b> (constants). The check
will suggest a variable name that follows the pattern if it
can be inferred from the original name.</p>

<p style="margin-left:11%; margin-top: 1em">For code:</p>

<pre style="margin-left:15%; margin-top: 1em">static NSString* myString = @&quot;hello&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">The fix will
be:</p>

<pre style="margin-left:15%; margin-top: 1em">static NSString* gMyString = @&quot;hello&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">Another example
of constant:</p>

<pre style="margin-left:15%; margin-top: 1em">static NSString* const myConstString = @&quot;hello&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">The fix will
be:</p>

<pre style="margin-left:15%; margin-top: 1em">static NSString* const kMyConstString = @&quot;hello&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">However for
code that prefixed with non&minus;alphabetical characters
like:</p>

<pre style="margin-left:15%; margin-top: 1em">static NSString* __anotherString = @&quot;world&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
give a warning message but will not be able to suggest a
fix. The user needs to fix it on their own.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;readability&minus;avoid&minus;underscore&minus;in&minus;googletest&minus;name</b>
<br>
Checks whether there are underscores in googletest test and
test case names in test macros:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p><b>TEST</b></p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p><b>TEST_F</b></p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p><b>TEST_P</b></p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p><b>TYPED_TEST</b></p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p><b>TYPED_TEST_P</b></p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<b>FRIEND_TEST</b> macro is not included.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<pre style="margin-left:15%; margin-top: 1em">TEST(TestCaseName, Illegal_TestName) {}
TEST(Illegal_TestCaseName, TestName) {}</pre>


<p style="margin-left:11%; margin-top: 1em">would trigger
the check. <i>Underscores are not allowed</i> in test names
nor test case names.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>DISABLED_</b> prefix, which may be used to <i>disable
individual tests</i>, is ignored when checking test names,
but the rest of the rest of the test name is still
checked.</p>

<p style="margin-left:11%; margin-top: 1em">This check does
not propose any fixes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;readability&minus;braces&minus;around&minus;statements</b>
<br>
The
google&minus;readability&minus;braces&minus;around&minus;statements
check is an alias, please see
<i>readability&minus;braces&minus;around&minus;statements</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;readability&minus;casting</b>
<br>
Finds usages of C&minus;style casts.</p>


<p style="margin-left:11%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Casting</i></p>

<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check name: <i>readability/casting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This check is
similar to <b>&minus;Wold&minus;style&minus;cast</b>, but it
suggests automated fixes in some cases. The reported
locations should not be different from the ones generated by
<b>&minus;Wold&minus;style&minus;cast</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;readability&minus;function&minus;size</b>
<br>
The google&minus;readability&minus;function&minus;size check
is an alias, please see
<i>readability&minus;function&minus;size</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;readability&minus;namespace&minus;comments</b>
<br>
The google&minus;readability&minus;namespace&minus;comments
check is an alias, please see
<i>llvm&minus;namespace&minus;comment</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;readability&minus;todo</b>
<br>
Finds TODO comments without a username or bug number.</p>

<p style="margin-left:11%; margin-top: 1em">The relevant
style guide section is
<i>https://google.github.io/styleguide/cppguide.html#TODO_Comments</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check: <i>readability/todo</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;runtime&minus;int</b>
<br>
Finds uses of <b>short</b>, <b>long</b> and <b>long long</b>
and suggest replacing them with <b>u?intXX(_t)?</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
corresponding style guide rule:
<i>https://google.github.io/styleguide/cppguide.html#Integer_Types</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check: <i>runtime/int</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
UnsignedTypePrefix</b></p>

<p style="margin-left:22%;">A string specifying the
unsigned type prefix. Default is <i>uint</i>.</p>

<p style="margin-left:11%;"><b>SignedTypePrefix</b></p>

<p style="margin-left:22%;">A string specifying the signed
type prefix. Default is <i>int</i>.</p>

<p style="margin-left:11%;"><b>TypeSuffix</b></p>

<p style="margin-left:22%;">A string specifying the type
suffix. Default is an empty string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;runtime&minus;operator</b>
<br>
Finds overloads of unary <b>operator &amp;</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Operator_Overloading</i></p>

<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check name: <i>runtime/operator</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>google&minus;upgrade&minus;googletest&minus;case</b>
<br>
Finds uses of deprecated Google Test version 1.9 APIs with
names containing <b>case</b> and replaces them with
equivalent APIs with <b>suite</b>.</p>

<p style="margin-left:11%; margin-top: 1em">All names
containing <b>case</b> are being replaced to be consistent
with the meanings of &quot;test case&quot; and &quot;test
suite&quot; as used by the International Software Testing
Qualifications Board and ISO 29119.</p>

<p style="margin-left:11%; margin-top: 1em">The new names
are a part of Google Test version 1.9 (release pending). It
is recommended that users update their dependency to version
1.9 and then use this check to remove deprecated names.</p>

<p style="margin-left:11%; margin-top: 1em">The affected
APIs are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Member functions of <b>testing::Test</b>,
<b>testing::TestInfo</b>, <b>testing::TestEventListener</b>,
<b>testing::UnitTest</b>, and any type inheriting from these
types</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The macros <b>TYPED_TEST_CASE</b>,
<b>TYPED_TEST_CASE_P</b>, <b>REGISTER_TYPED_TEST_CASE_P</b>,
and <b>INSTANTIATE_TYPED_TEST_CASE_P</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The type alias <b>testing::TestCase</b></p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Examples of
fixes created by this check:</p>
<pre style="margin-left:15%; margin-top: 1em">class FooTest : public testing::Test {
public:
  static void SetUpTestCase();
  static void TearDownTestCase();
};

TYPED_TEST_CASE(BarTest, BarTypes);</pre>

<p style="margin-left:11%; margin-top: 1em">becomes</p>
<pre style="margin-left:15%; margin-top: 1em">class FooTest : public testing::Test {
public:
  static void SetUpTestSuite();
  static void TearDownTestSuite();
};

TYPED_TEST_SUITE(BarTest, BarTypes);</pre>

<p style="margin-left:11%; margin-top: 1em">For better
consistency of user code, the check renames both virtual and
non&minus;virtual member functions with matching names in
derived types. The check tries to provide only a warning
when a fix cannot be made safely, as is the case with some
template and macro uses.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;avoid&minus;c&minus;arrays</b>
<br>
The hicpp&minus;avoid&minus;c&minus;arrays check is an
alias, please see
<i>modernize&minus;avoid&minus;c&minus;arrays</i> for more
information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;avoid&minus;goto</b>
<br>
The <i>hicpp&minus;avoid&minus;goto</i> check is an alias to
<i>cppcoreguidelines&minus;avoid&minus;goto</i>. Rule
<i>6.3.1 High Integrity C++</i> requires that <b>goto</b>
only skips parts of a block and is not used for other
reasons.</p>

<p style="margin-left:11%; margin-top: 1em">Both coding
guidelines implement the same exception to the usage of
<b>goto</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;braces&minus;around&minus;statements</b>
<br>
The <i>hicpp&minus;braces&minus;around&minus;statements</i>
check is an alias, please see
<i>readability&minus;braces&minus;around&minus;statements</i>
for more information. It enforces the <i>rule 6.1.1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;deprecated&minus;headers</b>
<br>
The <i>hicpp&minus;deprecated&minus;headers</i> check is an
alias, please see
<i>modernize&minus;deprecated&minus;headers</i> for more
information. It enforces the <i>rule 1.3.3</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;exception&minus;baseclass</b>
<br>
Ensure that every value that in a <b>throw</b> expression is
an instance of <b>std::exception</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This enforces
<i>rule 15.1</i> of the High Integrity C++ Coding
Standard.</p>
<pre style="margin-left:15%; margin-top: 1em">class custom_exception {};

void throwing() noexcept(false) {
  // Problematic throw expressions.
  throw int(42);
  throw custom_exception();
}

class mathematical_error : public std::exception {};


void throwing2() noexcept(false) {
  // These kind of throws are ok.
  throw mathematical_error();
  throw std::runtime_error();
  throw std::exception();
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;explicit&minus;conversions</b>
<br>
This check is an alias for
<i>google&minus;explicit&minus;constructor</i>. Used to
enforce parts of <i>rule 5.4.1</i>. This check will enforce
that constructors and conversion operators are marked
<i>explicit</i>. Other forms of casting checks are
implemented in other places. The following checks can be
used to check for more forms of casting:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="72%">



<p style="margin-top: 1em"><i>cppcoreguidelines&minus;pro&minus;type&minus;static&minus;cast&minus;downcast</i></p> </td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="72%">



<p><i>cppcoreguidelines&minus;pro&minus;type&minus;reinterpret&minus;cast</i></p> </td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="72%">



<p><i>cppcoreguidelines&minus;pro&minus;type&minus;const&minus;cast</i></p> </td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="72%">



<p><i>cppcoreguidelines&minus;pro&minus;type&minus;cstyle&minus;cast</i></p> </td>
<td width="14%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;function&minus;size</b>
<br>
This check is an alias for
<i>readability&minus;function&minus;size</i>. Useful to
enforce multiple sections on function complexity.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p style="margin-top: 1em"><i>rule 8.2.2</i></p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p><i>rule 8.3.1</i></p></td>
<td width="71%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="15%">


<p><i>rule 8.3.2</i></p></td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;invalid&minus;access&minus;moved</b>
<br>
This check is an alias for
<i>bugprone&minus;use&minus;after&minus;move</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Implements
parts of the <i>rule 8.4.1</i> to check if moved&minus;from
objects are accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;member&minus;init</b>
<br>
This check is an alias for
<i>cppcoreguidelines&minus;pro&minus;type&minus;member&minus;init</i>.
Implements the check for <i>rule 12.4.2</i> to initialize
class members in the right order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;move&minus;const&minus;arg</b>
<br>
The <i>hicpp&minus;move&minus;const&minus;arg</i> check is
an alias, please see
<i>performance&minus;move&minus;const&minus;arg</i> for more
information. It enforces the <i>rule 17.3.1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;multiway&minus;paths&minus;covered</b>
<br>
This check discovers situations where code paths are not
fully&minus;covered. It furthermore suggests using <b>if</b>
instead of <b>switch</b> if the code will be more clear. The
<i>rule 6.1.2</i> and <i>rule 6.1.4</i> of the High
Integrity C++ Coding Standard are enforced.</p>


<p style="margin-left:11%; margin-top: 1em"><b>if&minus;else
if</b> chains that miss a final <b>else</b> branch might
lead to unexpected program execution and be the result of a
logical error. If the missing <b>else</b> branch is intended
you can leave it empty with a clarifying comment. This
warning can be noisy on some code bases, so it is disabled
by default.</p>
<pre style="margin-left:15%; margin-top: 1em">void f1() {
  int i = determineTheNumber();


   if(i &gt; 0) {
     // Some Calculation
   } else if (i &lt; 0) {
     // Precondition violated or something else.
   }
   // ...
}</pre>


<p style="margin-left:11%; margin-top: 1em">Similar
arguments hold for <b>switch</b> statements which do not
cover all possible code paths.</p>
<pre style="margin-left:15%; margin-top: 1em">// The missing default branch might be a logical error. It can be kept empty
// if there is nothing to do, making it explicit.
void f2(int i) {
  switch (i) {
  case 0: // something
    break;
  case 1: // something else
    break;
  }
  // All other numbers?
}


// Violates this rule as well, but already emits a compiler warning (&minus;Wswitch).
enum Color { Red, Green, Blue, Yellow };
void f3(enum Color c) {
  switch (c) {
  case Red: // We can't drive for now.
    break;
  case Green:  // We are allowed to drive.
    break;
  }
  // Other cases missing
}</pre>


<p style="margin-left:11%; margin-top: 1em">The <i>rule
6.1.4</i> requires every <b>switch</b> statement to have at
least two <b>case</b> labels other than a <i>default</i>
label. Otherwise, the <b>switch</b> could be better
expressed with an <b>if</b> statement. Degenerated
<b>switch</b> statements without any labels are caught as
well.</p>
<pre style="margin-left:15%; margin-top: 1em">// Degenerated switch that could be better written as `if`
int i = 42;
switch(i) {
  case 1: // do something here
  default: // do something else here
}

// Should rather be the following:
if (i == 1) {
  // do something here
}
else {
  // do something here
}

// A completely degenerated switch will be diagnosed.
int i = 42;
switch(i) {}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
WarnOnMissingElse</b></p>

<p style="margin-left:22%;">Boolean flag that activates a
warning for missing <b>else</b> branches. Default is
<i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;named&minus;parameter</b>
<br>
This check is an alias for
<i>readability&minus;named&minus;parameter</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Implements
<i>rule 8.2.1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;new&minus;delete&minus;operators</b>
<br>
This check is an alias for
<i>misc&minus;new&minus;delete&minus;overloads</i>.
Implements <i>rule 12.3.1</i> to ensure the <i>new</i> and
<i>delete</i> operators have the correct signature.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;no&minus;array&minus;decay</b>
<br>
The <i>hicpp&minus;no&minus;array&minus;decay</i> check is
an alias, please see
<i>cppcoreguidelines&minus;pro&minus;bounds&minus;array&minus;to&minus;pointer&minus;decay</i>
for more information. It enforces the <i>rule 4.1.1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;no&minus;assembler</b>
<br>
Check for assembler statements. No fix is offered.</p>

<p style="margin-left:11%; margin-top: 1em">Inline
assembler is forbidden by the <i>High Integrity C++ Coding
Standard</i> as it restricts the portability of code.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;no&minus;malloc</b>
<br>
The <i>hicpp&minus;no&minus;malloc</i> check is an alias,
please see <i>cppcoreguidelines&minus;no&minus;malloc</i>
for more information. It enforces the <i>rule 5.3.2</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;noexcept&minus;move</b>
<br>
This check is an alias for
<i>performance&minus;noexcept&minus;move&minus;constructor</i>.
Checks <i>rule 12.5.4</i> to mark move assignment and move
construction <i>noexcept</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;signed&minus;bitwise</b>
<br>
Finds uses of bitwise operations on signed integer types,
which may lead to undefined or implementation defined
behavior.</p>

<p style="margin-left:11%; margin-top: 1em">The according
rule is defined in the <i>High Integrity C++ Standard,
Section 5.6.1</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnorePositiveIntegerLiterals</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i>, the check will not warn on bitwise operations
with positive integer literals, e.g. <i>~0</i>, <i>2
&lt;&lt; 1</i>, etc. Default value is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;special&minus;member&minus;functions</b>
<br>
This check is an alias for
<i>cppcoreguidelines&minus;special&minus;member&minus;functions</i>.
Checks that special member functions have the correct
signature, according to <i>rule 12.5.7</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;static&minus;assert</b>
<br>
The <i>hicpp&minus;static&minus;assert</i> check is an
alias, please see <i>misc&minus;static&minus;assert</i> for
more information. It enforces the <i>rule 7.1.10</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;undelegated&minus;constructor</b>
<br>
This check is an alias for
<i>bugprone&minus;undelegated&minus;constructor</i>.
Partially implements <i>rule 12.4.5</i> to find misplaced
constructor calls inside a constructor.</p>

<pre style="margin-left:15%; margin-top: 1em">struct Ctor {
  Ctor();
  Ctor(int);
  Ctor(int, int);
  Ctor(Ctor *i) {
    // All Ctor() calls result in a temporary object
    Ctor(); // did you intend to call a delegated constructor?
    Ctor(0); // did you intend to call a delegated constructor?
    Ctor(1, 2); // did you intend to call a delegated constructor?
    foo();
  }
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;uppercase&minus;literal&minus;suffix</b>
<br>
The hicpp&minus;uppercase&minus;literal&minus;suffix check
is an alias, please see
<i>readability&minus;uppercase&minus;literal&minus;suffix</i>
for more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;use&minus;auto</b>
<br>
The <i>hicpp&minus;use&minus;auto</i> check is an alias,
please see <i>modernize&minus;use&minus;auto</i> for more
information. It enforces the <i>rule 7.1.8</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;use&minus;emplace</b>
<br>
The <i>hicpp&minus;use&minus;emplace</i> check is an alias,
please see <i>modernize&minus;use&minus;emplace</i> for more
information. It enforces the <i>rule 17.4.2</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;use&minus;equals&minus;default</b>
<br>
This check is an alias for
<i>modernize&minus;use&minus;equals&minus;default</i>.
Implements <i>rule 12.5.1</i> to explicitly default special
member functions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;use&minus;equals&minus;delete</b>
<br>
This check is an alias for
<i>modernize&minus;use&minus;equals&minus;delete</i>.
Implements <i>rule 12.5.1</i> to explicitly default or
delete special member functions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;use&minus;noexcept</b>
<br>
The <i>hicpp&minus;use&minus;noexcept</i> check is an alias,
please see <i>modernize&minus;use&minus;noexcept</i> for
more information. It enforces the <i>rule 1.3.5</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;use&minus;nullptr</b>
<br>
The <i>hicpp&minus;use&minus;nullptr</i> check is an alias,
please see <i>modernize&minus;use&minus;nullptr</i> for more
information. It enforces the <i>rule 2.5.3</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;use&minus;override</b>
<br>
This check is an alias for
<i>modernize&minus;use&minus;override</i>. Implements
<i>rule 10.2.1</i> to declare a virtual function
<i>override</i> when overriding.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hicpp&minus;vararg</b>
<br>
The <i>hicpp&minus;vararg</i> check is an alias, please see
<i>cppcoreguidelines&minus;pro&minus;type&minus;vararg</i>
for more information. It enforces the <i>rule
14.1.1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>linuxkernel&minus;must&minus;use&minus;errs</b>
<br>
Checks Linux kernel code to see if it uses the results from
the functions in <b>linux/err.h</b>. Also checks to see if
code uses the results from functions that directly return a
value from one of these error functions.</p>

<p style="margin-left:11%; margin-top: 1em">This is
important in the Linux kernel because <b>ERR_PTR</b>,
<b>PTR_ERR</b>, <b>IS_ERR</b>, <b>IS_ERR_OR_NULL</b>,
<b>ERR_CAST</b>, and <b>PTR_ERR_OR_ZERO</b> return values
must be checked, since positive pointers and negative error
codes are being used in the same context. These functions
are marked with <b>__attribute__((warn_unused_result))</b>,
but some kernel versions do not have this warning enabled
for clang.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">/* Trivial unused call to an ERR function */
PTR_ERR_OR_ZERO(some_function_call());

/* A function that returns ERR_PTR. */
void *fn() { ERR_PTR(&minus;EINVAL); }

/* An invalid use of fn. */
fn();</pre>


<p style="margin-left:11%; margin-top: 1em"><b>llvm&minus;else&minus;after&minus;return</b>
<br>
The llvm&minus;else&minus;after&minus;return check is an
alias, please see
<i>readability&minus;else&minus;after&minus;return</i> for
more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>llvm&minus;header&minus;guard</b>
<br>
Finds and fixes header guards that do not adhere to LLVM
style.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
HeaderFileExtensions</b></p>

<p style="margin-left:22%;">A comma&minus;separated list of
filename extensions of header files (the filename extensions
should not include &quot;.&quot; prefix). Default is
&quot;h,hh,hpp,hxx&quot;. For header files without an
extension, use an empty string (if there are no other
desired extensions) or leave an empty element in the list.
E.g., &quot;h,hh,hpp,hxx,&quot; (note the trailing
comma).</p>


<p style="margin-left:11%; margin-top: 1em"><b>llvm&minus;include&minus;order</b>
<br>
Checks the correct order of <b>#includes</b>.</p>

<p style="margin-left:11%; margin-top: 1em">See
<i>https://llvm.org/docs/CodingStandards.html#include&minus;style</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>llvm&minus;namespace&minus;comment</b>
<i><br>
google&minus;readability&minus;namespace&minus;comments</i>
redirects here as an alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Checks that
long namespaces have a closing comment.</p>


<p style="margin-left:11%; margin-top: 1em"><i>https://llvm.org/docs/CodingStandards.html#namespace&minus;indentation</i></p>


<p style="margin-left:11%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Namespaces</i></p>

<pre style="margin-left:15%; margin-top: 1em">namespace n1 {
void f();
}

// becomes

namespace n1 {
void f();
}  // namespace n1</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
ShortNamespaceLines</b></p>

<p style="margin-left:22%;">Requires the closing brace of
the namespace definition to be followed by a closing comment
if the body of the namespace has more than
<i>ShortNamespaceLines</i> lines of code. The value is an
unsigned integer that defaults to <i>1U</i>.</p>


<p style="margin-left:11%;"><b>SpacesBeforeComments</b></p>

<p style="margin-left:22%;">An unsigned integer specifying
the number of spaces before the comment closing a namespace
definition. Default is <i>1U</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>llvm&minus;prefer&minus;isa&minus;or&minus;dyn&minus;cast&minus;in&minus;conditionals</b>
<br>
Looks at conditionals and finds and replaces cases of
<b>cast&lt;&gt;</b>, which will assert rather than return a
null pointer, and <b>dyn_cast&lt;&gt;</b> where the return
value is not captured. Additionally, finds and replaces
cases that match the pattern <b>var &amp;&amp;
isa&lt;X&gt;(var)</b>, where <b>var</b> is evaluated
twice.</p>
<pre style="margin-left:15%; margin-top: 1em">// Finds these:
if (auto x = cast&lt;X&gt;(y)) {}
// is replaced by:
if (auto x = dyn_cast&lt;X&gt;(y)) {}

if (cast&lt;X&gt;(y)) {}
// is replaced by:
if (isa&lt;X&gt;(y)) {}

if (dyn_cast&lt;X&gt;(y)) {}
// is replaced by:
if (isa&lt;X&gt;(y)) {}

if (var &amp;&amp; isa&lt;T&gt;(var)) {}
// is replaced by:
if (isa_and_nonnull&lt;T&gt;(var.foo())) {}


// Other cases are ignored, e.g.:
if (auto f = cast&lt;Z&gt;(y)&minus;&gt;foo()) {}
if (cast&lt;Z&gt;(y)&minus;&gt;foo()) {}
if (X.cast(y)) {}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>llvm&minus;prefer&minus;register&minus;over&minus;unsigned</b>
<br>
Finds historical use of <b>unsigned</b> to hold vregs and
physregs and rewrites them to use <b>Register</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Currently this
works by finding all variables of unsigned integer type
whose initializer begins with an implicit cast from
<b>Register</b> to <b>unsigned</b>.</p>

<pre style="margin-left:15%; margin-top: 1em">void example(MachineOperand &amp;MO) {
  unsigned Reg = MO.getReg();
  ...
}</pre>


<p style="margin-left:11%; margin-top: 1em">becomes:</p>

<pre style="margin-left:15%; margin-top: 1em">void example(MachineOperand &amp;MO) {
  Register Reg = MO.getReg();
  ...
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>llvm&minus;qualified&minus;auto</b>
<br>
The llvm&minus;qualified&minus;auto check is an alias,
please see <i>readability&minus;qualified&minus;auto</i> for
more information.</p>


<p style="margin-left:11%; margin-top: 1em"><b>llvm&minus;twine&minus;local</b>
<br>
Looks for local <b>Twine</b> variables which are prone to
use after frees and should be generally avoided.</p>
<pre style="margin-left:15%; margin-top: 1em">static Twine Moo = Twine(&quot;bark&quot;) + &quot;bah&quot;;

// becomes


static std::string Moo = (Twine(&quot;bark&quot;) + &quot;bah&quot;).str();</pre>



<p style="margin-left:11%; margin-top: 1em"><b>llvmlibc&minus;callee&minus;namespace</b>
<br>
Checks all calls resolve to functions within
<b>__llvm_libc</b> namespace.</p>
<pre style="margin-left:15%; margin-top: 1em">namespace __llvm_libc {

// Allow calls with the fully qualified name.
__llvm_libc::strlen(&quot;hello&quot;);

// Allow calls to compiler provided functions.
(void)__builtin_abs(&minus;1);

// Bare calls are allowed as long as they resolve to the correct namespace.
strlen(&quot;world&quot;);

// Disallow calling into functions in the global namespace.
::strlen(&quot;!&quot;);

} // namespace __llvm_libc</pre>


<p style="margin-left:11%; margin-top: 1em"><b>llvmlibc&minus;implementation&minus;in&minus;namespace</b>
<br>
Checks that all declarations in the llvm&minus;libc
implementation are within the correct namespace.</p>
<pre style="margin-left:15%; margin-top: 1em">// Correct: implementation inside the correct namespace.
namespace __llvm_libc {
    void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char *src) {}
    // Namespaces within __llvm_libc namespace are allowed.
    namespace inner{
        int localVar = 0;
    }
    // Functions with C linkage are allowed.
    extern &quot;C&quot; void str_fuzz(){}
}

// Incorrect: implementation not in a namespace.
void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char *src) {}


// Incorrect: outer most namespace is not correct.
namespace something_else {
    void LLVM_LIBC_ENTRYPOINT(strcpy)(char *dest, const char *src) {}
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>llvmlibc&minus;restrict&minus;system&minus;libc&minus;headers</b>
<br>
Finds includes of system libc headers not provided by the
compiler within llvm&minus;libc implementations.</p>

<pre style="margin-left:15%; margin-top: 1em">#include &lt;stdio.h&gt;            // Not allowed because it is part of system libc.
#include &lt;stddef.h&gt;           // Allowed because it is provided by the compiler.
#include &quot;internal/stdio.h&quot;   // Allowed because it is NOT part of system libc.</pre>


<p style="margin-left:11%; margin-top: 1em">This check is
necessary because accidentally including system libc headers
can lead to subtle and hard to detect bugs. For example
consider a system libc whose <b>dirent</b> struct has
slightly different field ordering than llvm&minus;libc.
While this will compile successfully, this can cause issues
during runtime because they are ABI incompatible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
Includes</b></p>

<p style="margin-left:22%;">A string containing a comma
separated glob list of allowed include filenames. Similar to
the &minus;checks glob list for running clang&minus;tidy
itself, the two wildcard characters are <i>*</i> and
<i>&minus;</i>, to include and exclude globs, respectively.
The default is <i>&minus;*</i>, which disallows all
includes.</p>

<p style="margin-left:22%; margin-top: 1em">This can be
used to allow known safe includes such as Linux development
headers. See
<i>portability&minus;restrict&minus;system&minus;includes</i>
for more details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;confusable&minus;identifiers</b>
<br>
Warn about confusable identifiers, i.e. identifiers that are
visually close to each other, but use different Unicode
characters. This detects a potential attack described in
<i>CVE&minus;2021&minus;42574</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">int fo; // Initial character is U+0066 (LATIN SMALL LETTER F).
int &eth;o; // Initial character is U+1234 (SUPER COOL AWESOME UPPERCASE NOT LATIN F) not U+0066 (LATIN SMALL LETTER F).</pre>



<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;const&minus;correctness</b>
<br>
This check implements detection of local variables which
could be declared as <b>const</b> but are not. Declaring
variables as <b>const</b> is required or recommended by many
coding guidelines, such as: <i>CppCoreGuidelines ES.25</i>
and <i>AUTOSAR C++14 Rule A7&minus;1&minus;1 (6.7.1
Specifiers)</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that this check's analysis is type&minus;based only.
Variables that are not modified but used to create a
non&minus;const handle that might escape the scope are not
diagnosed as potential <b>const</b>.</p>

<pre style="margin-left:15%; margin-top: 1em">// Declare a variable, which is not ``const`` ...
int i = 42;
// but use it as read&minus;only. This means that `i` can be declared ``const``.
int result = i * i;       // Before transformation
int const result = i * i; // After transformation</pre>


<p style="margin-left:11%; margin-top: 1em">The check can
analyze values, pointers and references but not (yet)
pointees:</p>
<pre style="margin-left:15%; margin-top: 1em">// Normal values like built&minus;ins or objects.
int potential_const_int = 42;       // Before transformation
int const potential_const_int = 42; // After transformation
int copy_of_value = potential_const_int;

MyClass could_be_const;       // Before transformation
MyClass const could_be_const; // After transformation
could_be_const.const_qualified_method();

// References can be declared const as well.
int &amp;reference_value = potential_const_int;       // Before transformation
int const&amp; reference_value = potential_const_int; // After transformation
int another_copy = reference_value;


// The similar semantics of pointers are not (yet) analyzed.
int *pointer_variable = &amp;potential_const_int; // _NO_ 'const int *pointer_variable' suggestion.
int last_copy = *pointer_variable;</pre>


<p style="margin-left:11%; margin-top: 1em">The automatic
code transformation is only applied to variables that are
declared in single declarations. You may want to prepare
your code base with
<i>readability&minus;isolate&minus;declaration</i>
first.</p>

<p style="margin-left:11%; margin-top: 1em">Note that there
is the check
<i>cppcoreguidelines&minus;avoid&minus;non&minus;const&minus;global&minus;variables</i>
to enforce <b>const</b> correctness on all globals.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Known
Limitations</b> <br>
The check does not run on <i>C</i> code.</p>

<p style="margin-left:11%; margin-top: 1em">The check will
not analyze templated variables or variables that are
instantiation dependent. Different instantiations can result
in different <b>const</b> correctness properties and in
general it is not possible to find all instantiations of a
template. The template might be used differently in an
independent translation unit.</p>

<p style="margin-left:11%; margin-top: 1em">Pointees can
not be analyzed for constness yet. The following code shows
this limitation.</p>
<pre style="margin-left:15%; margin-top: 1em">// Declare a variable that will not be modified.
int constant_value = 42;

// Declare a pointer to that variable, that does not modify either, but misses 'const'.
// Could be 'const int *pointer_to_constant = &amp;constant_value;'
int *pointer_to_constant = &amp;constant_value;


// Usage:
int result = 520 * 120 * (*pointer_to_constant);</pre>


<p style="margin-left:11%; margin-top: 1em">This limitation
affects the capability to add <b>const</b> to methods which
is not possible, too.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
AnalyzeValues (default = true)</b></p>

<p style="margin-left:22%;">Enable or disable the analysis
of ordinary value variables, like <b>int i = 42;</b></p>
<pre style="margin-left:26%; margin-top: 1em">// Warning
int i = 42;
// No warning
int const i = 42;


// Warning
int a[] = {42, 42, 42};
// No warning
int const a[] = {42, 42, 42};</pre>


<p style="margin-left:11%;"><b>AnalyzeReferences (default =
true)</b></p>

<p style="margin-left:22%;">Enable or disable the analysis
of reference variables, like <b>int &amp;ref = i;</b></p>

<pre style="margin-left:26%; margin-top: 1em">int i = 42;
// Warning
int&amp; ref = i;
// No warning
int const&amp; ref = i;</pre>


<p style="margin-left:11%;"><b>WarnPointersAsValues
(default = false)</b></p>

<p style="margin-left:22%;">This option enables the
suggestion for <b>const</b> of the pointer itself. Pointer
values have two possibilities to be <b>const</b>, the
pointer and the value pointing to.</p>
<pre style="margin-left:26%; margin-top: 1em">int value = 42;


// Warning
const int * pointer_variable = &amp;value;
// No warning
const int *const pointer_variable = &amp;value;</pre>


<p style="margin-left:11%;"><b>TransformValues (default =
true)</b></p>

<p style="margin-left:22%;">Provides fixit&minus;hints for
value types that automatically add <b>const</b> if its a
single declaration.</p>
<pre style="margin-left:26%; margin-top: 1em">// Before
int value = 42;
// After
int const value = 42;

// Before
int a[] = {42, 42, 42};
// After
int const a[] = {42, 42, 42};


// Result is modified later in its life&minus;time. No diagnostic and fixit hint will be emitted.
int result = value * 3;
result &minus;= 10;</pre>


<p style="margin-left:11%;"><b>TransformReferences (default
= true)</b></p>

<p style="margin-left:22%;">Provides fixit&minus;hints for
reference types that automatically add <b>const</b> if its a
single declaration.</p>
<pre style="margin-left:26%; margin-top: 1em">// This variable could still be a constant. But because there is a non&minus;const reference to
// it, it can not be transformed (yet).
int value = 42;
// The reference 'ref_value' is not modified and can be made 'const int &amp;ref_value = value;'
// Before
int &amp;ref_value = value;
// After
int const &amp;ref_value = value;


// Result is modified later in its life&minus;time. No diagnostic and fixit hint will be emitted.
int result = ref_value * 3;
result &minus;= 10;</pre>


<p style="margin-left:11%;"><b>TransformPointersAsValues
(default = false)</b></p>

<p style="margin-left:22%;">Provides fixit&minus;hints for
pointers if their pointee is not changed. This does not
analyze if the value&minus;pointed&minus;to is
unchanged!</p>

<p style="margin-left:22%; margin-top: 1em">Requires
'WarnPointersAsValues' to be 'true'.</p>
<pre style="margin-left:26%; margin-top: 1em">int value = 42;

// Before
const int * pointer_variable = &amp;value;
// After
const int *const pointer_variable = &amp;value;

// Before
const int * a[] = {&amp;value, &amp;value};
// After
const int *const a[] = {&amp;value, &amp;value};

// Before
int *ptr_value = &amp;value;
// After
int *const ptr_value = &amp;value;

int result = 100 * (*ptr_value); // Does not modify the pointer itself.
// This modification of the pointee is still allowed and not diagnosed.
*ptr_value = 0;


// The following pointer may not become a 'int *const'.
int *changing_pointee = &amp;value;
changing_pointee = &amp;result;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;definitions&minus;in&minus;headers</b>
<br>
Finds non&minus;extern non&minus;inline function and
variable definitions in header files, which can lead to
potential ODR violations in case these headers are included
from multiple translation units.</p>
<pre style="margin-left:15%; margin-top: 1em">// Foo.h
int a = 1; // Warning: variable definition.
extern int d; // OK: extern variable.

namespace N {
  int e = 2; // Warning: variable definition.
}

// Warning: variable definition.
const char* str = &quot;foo&quot;;

// OK: internal linkage variable definitions are ignored for now.
// Although these might also cause ODR violations, we can be less certain and
// should try to keep the false&minus;positive rate down.
static int b = 1;
const int c = 1;
const char* const str2 = &quot;foo&quot;;
constexpr int k = 1;

// Warning: function definition.
int g() {
  return 1;
}

// OK: inline function definition is allowed to be defined multiple times.
inline int e() {
  return 1;
}

class A {
public:
  int f1() { return 1; } // OK: implicitly inline member function definition is allowed.
  int f2();

  static int d;
};

// Warning: not an inline member function definition.
int A::f2() { return 1; }

// OK: class static data member declaration is allowed.
int A::d = 1;

// OK: function template is allowed.
template&lt;typename T&gt;
T f3() {
  T a = 1;
  return a;
}

// Warning: full specialization of a function template is not allowed.
template &lt;&gt;
int f3() {
  int a = 1;
  return a;
}

template &lt;typename T&gt;
struct B {
  void f1();
};

// OK: member function definition of a class template is allowed.
template &lt;typename T&gt;
void B&lt;T&gt;::f1() {}

class CE {
  constexpr static int i = 5; // OK: inline variable definition.
};

inline int i = 5; // OK: inline variable definition.

constexpr int f10() { return 0; } // OK: constexpr function implies inline.


// OK: C++14 variable templates are inline.
template &lt;class T&gt;
constexpr T pi = T(3.1415926L);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
HeaderFileExtensions</b></p>

<p style="margin-left:22%;">A comma&minus;separated list of
filename extensions of header files (the filename extensions
should not include &quot;.&quot; prefix). Default is
&quot;h,hh,hpp,hxx&quot;. For header files without an
extension, use an empty string (if there are no other
desired extensions) or leave an empty element in the list.
E.g., &quot;h,hh,hpp,hxx,&quot; (note the trailing
comma).</p>


<p style="margin-left:11%;"><b>UseHeaderFileExtension</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will use the file extension to distinguish header files.
Default is <i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;misleading&minus;bidirectional</b>
<br>
Warn about unterminated bidirectional unicode sequence,
detecting potential attack as described in the <i>Trojan
Source</i> attack.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em">#include &lt;iostream&gt;


int main() {
    bool isAdmin = false;
    /*&acirc;&reg; } &acirc;&brvbar;if (isAdmin)&acirc;&copy; &acirc;&brvbar; begin admins only */
        std::cout &lt;&lt; &quot;You are an admin.\n&quot;;
    /* end admins only &acirc;&reg; { &acirc;&brvbar;*/
    return 0;
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;misleading&minus;identifier</b>
<br>
Finds identifiers that contain Unicode characters with
right&minus;to&minus;left direction, which can be confusing
as they may change the understanding of a whole statement
line, as described in <i>Trojan Source</i>.</p>

<p style="margin-left:11%; margin-top: 1em">An example of
such misleading code follows:</p>
<pre style="margin-left:15%; margin-top: 1em">#include &lt;stdio.h&gt;

short int &times; = (short int)0;
short int &times; = (short int)12345;


int main() {
  int &times; = &times;; // a local variable, set to zero?
  printf(&quot;&times; is %d\n&quot;, &times;);
  printf(&quot;&times; is %d\n&quot;, &times;);
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;misplaced&minus;const</b>
<br>
This check diagnoses when a <b>const</b> qualifier is
applied to a <b>typedef</b>/ <b>using</b> to a pointer type
rather than to the pointee, because such constructs are
often misleading to developers because the <b>const</b>
applies to the pointer rather than the pointee.</p>

<p style="margin-left:11%; margin-top: 1em">For instance,
in the following code, the resulting type is <b>int *
const</b> rather than <b>const int *</b>:</p>

<pre style="margin-left:15%; margin-top: 1em">typedef int *int_ptr;
void f(const int_ptr ptr) {
  *ptr = 0; // potentially quite unexpectedly the int can be modified here
  ptr = 0; // does not compile
}</pre>


<p style="margin-left:11%; margin-top: 1em">The check does
not diagnose when the underlying <b>typedef</b>/<b>using</b>
type is a pointer to a <b>const</b> type or a function
pointer type. This is because the <b>const</b> qualifier is
less likely to be mistaken because it would be redundant (or
disallowed) on the underlying pointee type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;new&minus;delete&minus;overloads</b>
<i><br>
cert&minus;dcl54&minus;cpp</i> redirects here as an alias
for this check.</p>

<p style="margin-left:11%; margin-top: 1em">The check flags
overloaded operator <b>new()</b> and operator
<b>delete()</b> functions that do not have a corresponding
free store function defined within the same scope. For
instance, the check will flag a class implementation of a
non&minus;placement operator <b>new()</b> when the class
does not also define a non&minus;placement operator
<b>delete()</b> function as well.</p>

<p style="margin-left:11%; margin-top: 1em">The check does
not flag implicitly&minus;defined operators, deleted or
private operators, or placement operators.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to CERT C++ Coding Standard rule
<i>DCL54&minus;CPP. Overload allocation and deallocation
functions as a pair in the same scope</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;no&minus;recursion</b>
<br>
Finds strongly connected functions (by analyzing the call
graph for SCC's (Strongly Connected Components) that are
loops), diagnoses each function in the cycle, and displays
one example of a possible call graph loop (recursion).</p>


<p style="margin-left:11%; margin-top: 1em">References:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>CERT C++ Coding Standard rule <i>DCL56&minus;CPP. Avoid
cycles during initialization of static objects</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>JPL Institutional Coding Standard for the C Programming
Language (JPL DOCID D&minus;60411) rule <i>2.4 Do not use
direct or indirect recursion</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>OpenCL Specification, Version 1.2 rule <i>6.9
Restrictions: i. Recursion is not supported.</i>.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em">Limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">The check does not handle calls
done through function pointers</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The check does not handle C++ destructors</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;non&minus;copyable&minus;objects</b>
<i><br>
cert&minus;fio38&minus;c</i> redirects here as an alias for
this check.</p>

<p style="margin-left:11%; margin-top: 1em">The check flags
dereferences and non&minus;pointer declarations of objects
that are not meant to be passed by value, such as C FILE
objects or POSIX <b>pthread_mutex_t</b> objects.</p>

<p style="margin-left:11%; margin-top: 1em">This check
corresponds to CERT C++ Coding Standard rule
<i>FIO38&minus;C. Do not copy a FILE object</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;non&minus;private&minus;member&minus;variables&minus;in&minus;classes</b>
<i><br>

cppcoreguidelines&minus;non&minus;private&minus;member&minus;variables&minus;in&minus;classes</i>
redirects here as an alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Finds classes
that contain non&minus;static data members in addition to
user&minus;declared non&minus;static member functions and
diagnose all data members declared with a
non&minus;<b>public</b> access specifier. The data members
should be declared as <b>private</b> and accessed through
member functions instead of exposed to derived classes or
class consumers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoreClassesWithAllMemberVariablesBeingPublic</b></p>

<p style="margin-left:22%;">Allows to completely ignore
classes if <b>all</b> the member variables in that class a
declared with a <b>public</b> access specifier.</p>


<p style="margin-left:11%;"><b>IgnorePublicMemberVariables</b></p>

<p style="margin-left:22%;">Allows to ignore (not diagnose)
<b>all</b> the member variables declared with a
<b>public</b> access specifier.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;redundant&minus;expression</b>
<br>
Detect redundant expressions which are typically errors due
to copy&minus;paste.</p>

<p style="margin-left:11%; margin-top: 1em">Depending on
the operator expressions may be</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p>redundant,</p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p>always <b>true</b>,</p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p>always <b>false</b>,</p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="49%">


<p>always a constant (zero or one).</p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">((x+1) | (x+1))             // (x+1) is redundant
(p&minus;&gt;x == p&minus;&gt;x)              // always true
(p&minus;&gt;x &lt; p&minus;&gt;x)               // always false
(speed &minus; speed + 1 == 12)   // speed &minus; speed is always zero</pre>



<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;static&minus;assert</b>
<i><br>
cert&minus;dcl03&minus;c</i> redirects here as an alias for
this check.</p>

<p style="margin-left:11%; margin-top: 1em">Replaces
<b>assert()</b> with <b>static_assert()</b> if the condition
is evaluable at compile time.</p>

<p style="margin-left:11%; margin-top: 1em">The condition
of <b>static_assert()</b> is evaluated at compile time which
is safer and more efficient.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;throw&minus;by&minus;value&minus;catch&minus;by&minus;reference</b>
<i><br>
cert&minus;err09&minus;cpp</i> redirects here as an alias
for this check. <i>cert&minus;err61&minus;cpp</i> redirects
here as an alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Finds
violations of the rule &quot;Throw by value, catch by
reference&quot; presented for example in &quot;C++ Coding
Standards&quot; by H. Sutter and A. Alexandrescu, as well as
the CERT C++ Coding Standard rule <i>ERR61&minus;CPP. Catch
exceptions by lvalue reference</i>. <b><br>
Exceptions:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>Throwing string literals will not be flagged despite
being a pointer. They are not susceptible to slicing and the
usage of string literals is idiomatic.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>Catching character pointers (<b>char</b>,
<b>wchar_t</b>, unicode character types) will not be flagged
to allow catching sting literals.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>Moved named values will not be flagged as not throwing
an anonymous temporary. In this case we can be sure that the
user knows that the object can't be accessed outside catch
blocks handling the error.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>Throwing function parameters will not be flagged as not
throwing an anonymous temporary. This allows helper
functions for throwing.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>Re&minus;throwing caught exception variables will not be
flagged as not throwing an anonymous temporary. Although
this can usually be done by just writing <b>throw;</b> it
happens often enough in real code.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
CheckThrowTemporaries</b></p>

<p style="margin-left:22%;">Triggers detection of
violations of the CERT recommendation ERR09&minus;CPP. Throw
anonymous temporaries. Default is <i>true</i>.</p>

<p style="margin-left:11%;"><b>WarnOnLargeObject</b></p>

<p style="margin-left:22%;">Also warns for any large,
trivial object caught by value. Catching a large object by
value is not dangerous but affects the performance
negatively. The maximum size of an object allowed to be
caught without warning can be set using the <i>MaxSize</i>
option. Default is <i>false</i>.</p>

<p style="margin-left:11%;"><b>MaxSize</b></p>

<p style="margin-left:22%;">Determines the maximum size of
an object allowed to be caught without warning. Only
applicable if <i>WarnOnLargeObject</i> is set to
<i>true</i>. If the option is set by the user to
<i>std::numeric_limits&lt;uint64_t&gt;::max()</i> then it
reverts to the default value. Default is the size of
<i>size_t</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;unconventional&minus;assign&minus;operator</b>
<br>
Finds declarations of assign operators with the wrong return
and/or argument types and definitions with good return type
but wrong <b>return</b> statements.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>The return type must be <b>Class&amp;</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>The assignment may be from the class type by value,
const lvalue reference, non&minus;const rvalue reference, or
from a completely different type (e.g. <b>int</b>).</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>Private and deleted operators are ignored.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>The operator must always return <b>*this</b>.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;uniqueptr&minus;reset&minus;release</b>
<br>
Find and replace <b>unique_ptr::reset(release())</b> with
<b>std::move()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">std::unique_ptr&lt;Foo&gt; x, y;
x.reset(y.release()); &minus;&gt; x = std::move(y);</pre>


<p style="margin-left:11%; margin-top: 1em">If <b>y</b> is
already rvalue, <b>std::move()</b> is not added. <b>x</b>
and <b>y</b> can also be
<b>std::unique_ptr&lt;Foo&gt;*</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;unused&minus;alias&minus;decls</b>
<br>
Finds unused namespace alias declarations.</p>

<pre style="margin-left:15%; margin-top: 1em">namespace my_namespace {
class C {};
}
namespace unused_alias = ::my_namespace;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;unused&minus;parameters</b>
<br>
Finds unused function parameters. Unused parameters may
signify a bug in the code (e.g. when a different parameter
is used instead). The suggested fixes either comment
parameter name out or remove the parameter completely, if
all callers of the function are in the same translation unit
and can be updated.</p>

<p style="margin-left:11%; margin-top: 1em">The check is
similar to the <b>&minus;Wunused&minus;parameter</b>
compiler diagnostic and can be used to prepare a codebase to
enabling of that diagnostic. By default the check is more
permissive (see <i>StrictMode</i>).</p>
<pre style="margin-left:15%; margin-top: 1em">void a(int i) { /*some code that doesn't use `i`*/ }

// becomes

void a(int  /*i*/) { /*some code that doesn't use `i`*/ }
static void staticFunctionA(int i);
static void staticFunctionA(int i) { /*some code that doesn't use `i`*/ }

// becomes


static void staticFunctionA()
static void staticFunctionA() { /*some code that doesn't use `i`*/ }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
StrictMode</b></p>

<p style="margin-left:22%;">When <i>false</i> (default
value), the check will ignore trivially unused parameters,
i.e. when the corresponding function has an empty body (and
in case of constructors &minus; no constructor
initializers). When the function body is empty, an unused
parameter is unlikely to be unnoticed by a human reader, and
there's basically no place for a bug to hide.</p>


<p style="margin-left:11%; margin-top: 1em"><b>misc&minus;unused&minus;using&minus;decls</b>
<br>
Finds unused <b>using</b> declarations.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">namespace n { class C; }
using n::C;  // Never actually used.</pre>



<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;avoid&minus;bind</b>
<br>
The check finds uses of <b>std::bind</b> and
<b>boost::bind</b> and replaces them with lambdas. Lambdas
will use value&minus;capture unless reference capture is
explicitly requested with <b>std::ref</b> or
<b>boost::ref</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It supports
arbitrary callables including member functions, function
objects, and free functions, and all variations thereof.
Anything that you can pass to the first argument of
<b>bind</b> should be diagnosable. Currently, the only known
case where a fix&minus;it is unsupported is when the same
placeholder is specified multiple times in the parameter
list.</p>

<p style="margin-left:11%; margin-top: 1em">Given:</p>

<pre style="margin-left:15%; margin-top: 1em">int add(int x, int y) { return x + y; }</pre>


<p style="margin-left:11%; margin-top: 1em">Then:</p>

<pre style="margin-left:15%; margin-top: 1em">void f() {
  int x = 2;
  auto clj = std::bind(add, x, _1);
}</pre>


<p style="margin-left:11%; margin-top: 1em">is replaced
by:</p>

<pre style="margin-left:15%; margin-top: 1em">void f() {
  int x = 2;
  auto clj = [=](auto &amp;&amp; arg1) { return add(x, arg1); };
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>std::bind</b>
can be hard to read and can result in larger object files
and binaries due to type information that will not be
produced by equivalent lambdas.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
PermissiveParameterList</b></p>

<p style="margin-left:22%;">If the option is set to
<i>true</i>, the check will append <b>auto&amp;&amp;...</b>
to the end of every placeholder parameter list. Without
this, it is possible for a fix&minus;it to perform an
incorrect transformation in the case where the result of the
<b>bind</b> is used in the context of a type erased functor
such as <b>std::function</b> which allows mismatched
arguments. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">int add(int x, int y) { return x + y; }
int foo() {
  std::function&lt;int(int,int)&gt; ignore_args = std::bind(add, 2, 2);
  return ignore_args(3, 3);
}</pre>


<p style="margin-left:11%; margin-top: 1em">is valid code,
and returns <i>4</i>. The actual values passed to
<b>ignore_args</b> are simply ignored. Without
<b>PermissiveParameterList</b>, this would be transformed
into</p>

<pre style="margin-left:15%; margin-top: 1em">int add(int x, int y) { return x + y; }
int foo() {
  std::function&lt;int(int,int)&gt; ignore_args = [] { return add(2, 2); }
  return ignore_args(3, 3);
}</pre>


<p style="margin-left:11%; margin-top: 1em">which will
<i>not</i> compile, since the lambda does not contain an
<b>operator()</b> that accepts 2 arguments. With permissive
parameter list, it instead generates</p>

<pre style="margin-left:15%; margin-top: 1em">int add(int x, int y) { return x + y; }
int foo() {
  std::function&lt;int(int,int)&gt; ignore_args = [](auto&amp;&amp;...) { return add(2, 2); }
  return ignore_args(3, 3);
}</pre>


<p style="margin-left:11%; margin-top: 1em">which is
correct.</p>

<p style="margin-left:11%; margin-top: 1em">This check
requires using C++14 or higher to run.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;avoid&minus;c&minus;arrays</b>
<i><br>
cppcoreguidelines&minus;avoid&minus;c&minus;arrays</i>
redirects here as an alias for this check.</p>


<p style="margin-left:11%; margin-top: 1em"><i>hicpp&minus;avoid&minus;c&minus;arrays</i>
redirects here as an alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Finds
C&minus;style array types and recommend to use
<b>std::array&lt;&gt;</b> / <b>std::vector&lt;&gt;</b>. All
types of C arrays are diagnosed.</p>

<p style="margin-left:11%; margin-top: 1em">However,
fix&minus;it are potentially dangerous in header files and
are therefore not emitted right now.</p>
<pre style="margin-left:15%; margin-top: 1em">int a[] = {1, 2}; // warning: do not declare C&minus;style arrays, use std::array&lt;&gt; instead

int b[1]; // warning: do not declare C&minus;style arrays, use std::array&lt;&gt; instead

void foo() {
  int c[b[0]]; // warning: do not declare C VLA arrays, use std::vector&lt;&gt; instead
}

template &lt;typename T, int Size&gt;
class array {
  T d[Size]; // warning: do not declare C&minus;style arrays, use std::array&lt;&gt; instead

  int e[1]; // warning: do not declare C&minus;style arrays, use std::array&lt;&gt; instead
};

array&lt;int[4], 2&gt; d; // warning: do not declare C&minus;style arrays, use std::array&lt;&gt; instead


using k = int[4]; // warning: do not declare C&minus;style arrays, use std::array&lt;&gt; instead</pre>


<p style="margin-left:11%; margin-top: 1em">However, the
<b>extern &quot;C&quot;</b> code is ignored, since it is
common to share such headers between C code, and C++
code.</p>
<pre style="margin-left:15%; margin-top: 1em">// Some header
extern &quot;C&quot; {

int f[] = {1, 2}; // not diagnosed

int j[1]; // not diagnosed

inline void bar() {
  {
    int j[j[0]]; // not diagnosed
  }
}

}</pre>

<p style="margin-left:11%; margin-top: 1em">Similarly, the
<b>main()</b> function is ignored. Its second and third
parameters can be either <b>char* argv[]</b> or <b>char**
argv</b>, but cannot be <b>std::array&lt;&gt;</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;concat&minus;nested&minus;namespaces</b>
<br>
Checks for use of nested namespaces such as <b>namespace a {
namespace b { ... } }</b> and suggests changing to the more
concise syntax introduced in C++17: <b>namespace a::b { ...
}</b>. Inline namespaces are not modified.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>
<pre style="margin-left:15%; margin-top: 1em">namespace n1 {
namespace n2 {
void t();
}
}


namespace n3 {
namespace n4 {
namespace n5 {
void t();
}
}
namespace n6 {
namespace n7 {
void t();
}
}
}</pre>


<p style="margin-left:11%; margin-top: 1em">Will be
modified to:</p>
<pre style="margin-left:15%; margin-top: 1em">namespace n1::n2 {
void t();
}


namespace n3 {
namespace n4::n5 {
void t();
}
namespace n6::n7 {
void t();
}
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;deprecated&minus;headers</b>
<br>
Some headers from C library were deprecated in C++ and are
no longer welcome in C++ codebases. Some have no effect in
C++. For more details refer to the C++ 14 Standard
[depr.c.headers] section.</p>

<p style="margin-left:11%; margin-top: 1em">This check
replaces C standard library headers with their C++
alternatives and removes redundant ones.</p>
<pre style="margin-left:15%; margin-top: 1em">// C++ source file...
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

// becomes

#include &lt;cassert&gt;
// No 'stdbool.h' here.</pre>

<p style="margin-left:11%; margin-top: 1em">Important note:
the Standard doesn't guarantee that the C++ headers declare
all the same functions in the global namespace. The check in
its current form can break the code that uses library
symbols from the global namespace.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;assert.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;complex.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;ctype.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;errno.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;fenv.h&gt;</i> // deprecated since C++11</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;float.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;inttypes.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;limits.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;locale.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;math.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;setjmp.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;signal.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;stdarg.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;stddef.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;stdint.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;stdio.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;stdlib.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;string.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;tgmath.h&gt;</i> // deprecated since C++11</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;time.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;uchar.h&gt;</i> // deprecated since C++11</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;wchar.h&gt;</i></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p><i>&lt;wctype.h&gt;</i></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the
specified standard is older than C++11 the check will only
replace headers deprecated before C++11, otherwise
&minus;&minus; every header that appeared in the previous
list.</p>

<p style="margin-left:11%; margin-top: 1em">These headers
don't have effect in C++:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p style="margin-top: 1em"><i>&lt;iso646.h&gt;</i></p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p><i>&lt;stdalign.h&gt;</i></p></td>
<td width="68%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p><i>&lt;stdbool.h&gt;</i></p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The checker
ignores <i>include</i> directives within <i>extern
&quot;C&quot; { ... }</i> blocks, since a library might want
to expose some API for C and C++ libraries.</p>

<pre style="margin-left:15%; margin-top: 1em">// C++ source file...
extern &quot;C&quot; {
#include &lt;assert.h&gt;  // Left intact.
#include &lt;stdbool.h&gt; // Left intact.
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
CheckHeaderFile</b></p>

<p style="margin-left:22%;"><i>clang&minus;tidy</i> cannot
know if the header file included by the currently analyzed
C++ source file is not included by any other C source files.
Hence, to omit false&minus;positives and wrong
fixit&minus;hints, we ignore emitting reports into header
files. One can set this option to <i>true</i> if they know
that the header files in the project are only used by C++
source file. Default is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;deprecated&minus;ios&minus;base&minus;aliases</b>
<br>
Detects usage of the deprecated member types of
<b>std::ios_base</b> and replaces those that have a
non&minus;deprecated equivalent.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-30332501.png" alt="Image grohtml-30332501.png"></p>


<p style="margin-left:11%;"><b>modernize&minus;loop&minus;convert</b>
<br>
This check converts <b>for(...; ...; ...)</b> loops to use
the new range&minus;based loops in C++11.</p>

<p style="margin-left:11%; margin-top: 1em">Three kinds of
loops can be converted:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Loops over statically allocated arrays.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Loops over containers, using iterators.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Loops over array&minus;like containers, using
<b>operator[]</b> and <b>at()</b>.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>MinConfidence
option <br>
risky</b> <br>
In loops where the container expression is more complex than
just a reference to a declared expression (a variable,
function, enum, etc.), and some part of it appears elsewhere
in the loop, we lower our confidence in the transformation
due to the increased risk of changing semantics.
Transformations for these loops are marked as <i>risky</i>,
and thus will only be converted if the minimum required
confidence level is set to <i>risky</i>.</p>
<pre style="margin-left:15%; margin-top: 1em">int arr[10][20];
int l = 5;

for (int j = 0; j &lt; 20; ++j)
  int k = arr[l][j] + l; // using l outside arr[l] is considered risky


for (int i = 0; i &lt; obj.getVector().size(); ++i)
  obj.foo(10); // using 'obj' is considered risky</pre>


<p style="margin-left:11%; margin-top: 1em">See
<i>Range&minus;based loops evaluate end() only once</i> for
an example of an incorrect transformation when the minimum
required confidence level is set to <i>risky</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>reasonable
(Default)</b> <br>
If a loop calls <b>.end()</b> or <b>.size()</b> after each
iteration, the transformation for that loop is marked as
<i>reasonable</i>, and thus will be converted if the
required confidence level is set to <i>reasonable</i>
(default) or lower.</p>

<pre style="margin-left:15%; margin-top: 1em">// using size() is considered reasonable
for (int i = 0; i &lt; container.size(); ++i)
  cout &lt;&lt; container[i];</pre>


<p style="margin-left:11%; margin-top: 1em"><b>safe</b>
<br>
Any other loops that do not match the above criteria to be
marked as <i>risky</i> or <i>reasonable</i> are marked
<i>safe</i>, and thus will be converted if the required
confidence level is set to <i>safe</i> or lower.</p>
<pre style="margin-left:15%; margin-top: 1em">int arr[] = {1,2,3};


for (int i = 0; i &lt; 3; ++i)
  cout &lt;&lt; arr[i];</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
Original:</p>
<pre style="margin-left:15%; margin-top: 1em">const int N = 5;
int arr[] = {1,2,3,4,5};
vector&lt;int&gt; v;
v.push_back(1);
v.push_back(2);
v.push_back(3);

// safe conversion
for (int i = 0; i &lt; N; ++i)
  cout &lt;&lt; arr[i];

// reasonable conversion
for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)
  cout &lt;&lt; *it;


// reasonable conversion
for (int i = 0; i &lt; v.size(); ++i)
  cout &lt;&lt; v[i];</pre>


<p style="margin-left:11%; margin-top: 1em">After applying
the check with minimum confidence level set to
<i>reasonable</i> (default):</p>
<pre style="margin-left:15%; margin-top: 1em">const int N = 5;
int arr[] = {1,2,3,4,5};
vector&lt;int&gt; v;
v.push_back(1);
v.push_back(2);
v.push_back(3);

// safe conversion
for (auto &amp; elem : arr)
  cout &lt;&lt; elem;

// reasonable conversion
for (auto &amp; elem : v)
  cout &lt;&lt; elem;


// reasonable conversion
for (auto &amp; elem : v)
  cout &lt;&lt; elem;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Reverse
Iterator Support</b> <br>
The converter is also capable of transforming iterator loops
which use <b>rbegin</b> and <b>rend</b> for looping
backwards over a container. Out of the box this will
automatically happen in C++20 mode using the <b>ranges</b>
library, however the check can be configured to work without
C++20 by specifying a function to reverse a range and
optionally the header file where that function lives.
<b><br>
UseCxx20ReverseRanges</b></p>

<p style="margin-left:22%;">When set to true convert loops
when in C++20 or later mode using
<b>std::ranges::reverse_view</b>. Default value is
<b>true</b>.</p>


<p style="margin-left:11%;"><b>MakeReverseRangeFunction</b></p>

<p style="margin-left:22%;">Specify the function used to
reverse an iterator pair, the function should accept a class
with <b>rbegin</b> and <b>rend</b> methods and return a
class with <b>begin</b> and <b>end</b> methods that call the
<b>rbegin</b> and <b>rend</b> methods respectively. Common
examples are <b>ranges::reverse_view</b> and
<b>llvm::reverse</b>. Default value is an empty string.</p>


<p style="margin-left:11%;"><b>MakeReverseRangeHeader</b></p>

<p style="margin-left:22%;">Specifies the header file where
<i>MakeReverseRangeFunction</i> is declared. For the
previous examples this option would be set to
<b>range/v3/view/reverse.hpp</b> and
<b>llvm/ADT/STLExtras.h</b> respectively. If this is an
empty string and <i>MakeReverseRangeFunction</i> is set, the
check will proceed on the assumption that the function is
already available in the translation unit. This can be
wrapped in angle brackets to signify to add the include as a
system include. Default value is an empty string.</p>

<p style="margin-left:11%;"><b>IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Limitations</b>
<br>
There are certain situations where the tool may erroneously
perform transformations that remove information and change
semantics. Users of the tool should be aware of the behavior
and limitations of the check outlined by the cases
below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Comments
inside loop headers</b> <br>
Comments inside the original loop header are ignored and
deleted when transformed.</p>

<pre style="margin-left:15%; margin-top: 1em">for (int i = 0; i &lt; N; /* This will be deleted */ ++i) { }</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Range&minus;based
loops evaluate end() only once</b> <br>
The C++11 range&minus;based for loop calls <b>.end()</b>
only once during the initialization of the loop. If in the
original loop <b>.end()</b> is called after each iteration
the semantics of the transformed loop may differ.</p>
<pre style="margin-left:15%; margin-top: 1em">// The following is semantically equivalent to the C++11 range&minus;based for loop,
// therefore the semantics of the header will not change.
for (iterator it = container.begin(), e = container.end(); it != e; ++it) { }


// Instead of calling .end() after each iteration, this loop will be
// transformed to call .end() only once during the initialization of the loop,
// which may affect semantics.
for (iterator it = container.begin(); it != container.end(); ++it) { }</pre>


<p style="margin-left:11%; margin-top: 1em">As explained
above, calling member functions of the container in the body
of the loop is considered <i>risky</i>. If the called member
function modifies the container the semantics of the
converted loop will differ due to <b>.end()</b> being called
only once.</p>

<pre style="margin-left:15%; margin-top: 1em">bool flag = false;
for (vector&lt;T&gt;::iterator it = vec.begin(); it != vec.end(); ++it) {
  // Add a copy of the first element to the end of the vector.
  if (!flag) {
    // This line makes this transformation 'risky'.
    vec.push_back(*it);
    flag = true;
  }
  cout &lt;&lt; *it;
}</pre>


<p style="margin-left:11%; margin-top: 1em">The original
code above prints out the contents of the container
including the newly added element while the converted loop,
shown below, will only print the original contents and not
the newly added element.</p>

<pre style="margin-left:15%; margin-top: 1em">bool flag = false;
for (auto &amp; elem : vec) {
  // Add a copy of the first element to the end of the vector.
  if (!flag) {
    // This line makes this transformation 'risky'
    vec.push_back(elem);
    flag = true;
  }
  cout &lt;&lt; elem;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Semantics will
also be affected if <b>.end()</b> has side effects. For
example, in the case where calls to <b>.end()</b> are logged
the semantics will change in the transformed loop if
<b>.end()</b> was originally called after each
iteration.</p>

<pre style="margin-left:15%; margin-top: 1em">iterator end() {
  num_of_end_calls++;
  return container.end();
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Overloaded
operator&minus;&gt;() with side effects</b> <br>
Similarly, if <b>operator&minus;&gt;()</b> was overloaded to
have side effects, such as logging, the semantics will
change. If the iterator's <b>operator&minus;&gt;()</b> was
used in the original loop it will be replaced with
<b>&lt;container element&gt;.&lt;member&gt;</b> instead due
to the implicit dereference as part of the range&minus;based
for loop. Therefore any side effect of the overloaded
<b>operator&minus;&gt;()</b> will no longer be
performed.</p>

<pre style="margin-left:15%; margin-top: 1em">for (iterator it = c.begin(); it != c.end(); ++it) {
  it&minus;&gt;func(); // Using operator&minus;&gt;()
}
// Will be transformed to:
for (auto &amp; elem : c) {
  elem.func(); // No longer using operator&minus;&gt;()
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Pointers and
references to containers</b> <br>
While most of the check's risk analysis is dedicated to
determining whether the iterator or container was modified
within the loop, it is possible to circumvent the analysis
by accessing and modifying the container through a pointer
or reference.</p>

<p style="margin-left:11%; margin-top: 1em">If the
container were directly used instead of using the pointer or
reference the following transformation would have only been
applied at the <i>risky</i> level since calling a member
function of the container is considered <i>risky</i>. The
check cannot identify expressions associated with the
container that are different than the one used in the loop
header, therefore the transformation below ends up being
performed at the <i>safe</i> level.</p>
<pre style="margin-left:15%; margin-top: 1em">vector&lt;int&gt; vec;

vector&lt;int&gt; *ptr = &amp;vec;
vector&lt;int&gt; &amp;ref = vec;


for (vector&lt;int&gt;::iterator it = vec.begin(), e = vec.end(); it != e; ++it) {
  if (!flag) {
    // Accessing and modifying the container is considered risky, but the risk
    // level is not raised here.
    ptr&minus;&gt;push_back(*it);
    ref.push_back(*it);
    flag = true;
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>OpenMP</b>
<br>
As range&minus;based for loops are only available since
OpenMP 5, this check should not be used on code with a
compatibility requirement of OpenMP prior to version 5. It
is <b>intentional</b> that this check does not make any
attempts to exclude incorrect diagnostics on OpenMP for
loops prior to OpenMP 5.</p>

<p style="margin-left:11%; margin-top: 1em">To prevent this
check to be applied (and to break) OpenMP for loops but
still be applied to non&minus;OpenMP for loops the usage of
<b>NOLINT</b> (see <i>Suppressing Undesired Diagnostics</i>)
on the specific for loops is recommended.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;macro&minus;to&minus;enum</b>
<br>
Replaces groups of adjacent macros with an unscoped
anonymous enum. Using an unscoped anonymous enum ensures
that everywhere the macro token was used previously, the
enumerator name may be safely used.</p>

<p style="margin-left:11%; margin-top: 1em">This check can
be used to enforce the C++ core guideline <i>Enum.1: Prefer
enumerations over macros</i>, within the constraints
outlined below.</p>

<p style="margin-left:11%; margin-top: 1em">Potential
macros for replacement must meet the following
constraints:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must expand only to integral literal tokens or
expressions of literal tokens. The expression may contain
any of the unary operators <b>&minus;</b>, <b>+</b>,
<b>~</b> or <b>!</b>, any of the binary operators <b>,</b>,
<b>&minus;</b>, <b>+</b>, <b>*</b>, <b>/</b>, <b>%</b>,
<b>&amp;</b>, <b>|</b>, <b>^</b>, <b>&lt;</b>, <b>&gt;</b>,
<b>&lt;=</b>, <b>&gt;=</b>, <b>==</b>, <b>!=</b>, <b>||</b>,
<b>&amp;&amp;</b>, <b>&lt;&lt;</b>, <b>&gt;&gt;</b> or
<b>&lt;=&gt;</b>, the ternary operator <b>?:</b> and its
<i>GNU extension</i>. Parenthesized expressions are also
recognized. This recognizes most valid expressions. In
particular, expressions with the <b>sizeof</b> operator are
not recognized.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must be defined on sequential source file lines,
or with only comment lines in between macro definitions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must all be defined in the same source file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must not be defined within a conditional
compilation block. (Conditional include guards are exempt
from this constraint.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must not be defined adjacent to other
preprocessor directives.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must not be used in any conditional preprocessing
directive.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must not be used as arguments to other
macros.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must not be undefined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macros must be defined at the top&minus;level, not
inside any declaration or definition.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Each cluster of
macros meeting the above constraints is presumed to be a set
of values suitable for replacement by an anonymous enum.
From there, a developer can give the anonymous enum a name
and continue refactoring to a scoped enum if desired.
Comments on the same line as a macro definition or between
subsequent macro definitions are preserved in the output. No
formatting is assumed in the provided replacements, although
clang&minus;tidy can optionally format all fixes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>WARNING:</b></p>

<p style="margin-left:15%;">Initializing expressions are
assumed to be valid initializers for an enum. C requires
that enum values fit into an <b>int</b>, but this may not be
the case for some accepted constant expressions. For
instance <b>1 &lt;&lt; 40</b> will not fit into an
<b>int</b> when the size of an <b>int</b> is 32 bits.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF


#define TM_NONE (&minus;1) // No method selected.
#define TM_ONE 1    // Use tailored method one.
#define TM_TWO 2    // Use tailored method two.  Method two
                    // is preferable to method one.
#define TM_THREE 3  // Use tailored method three.</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>
<pre style="margin-left:15%; margin-top: 1em">enum {
RED = 0xFF0000,
GREEN = 0x00FF00,
BLUE = 0x0000FF
};


enum {
TM_NONE = (&minus;1), // No method selected.
TM_ONE = 1,    // Use tailored method one.
TM_TWO = 2,    // Use tailored method two.  Method two
                    // is preferable to method one.
TM_THREE = 3  // Use tailored method three.
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;make&minus;shared</b>
<br>
This check finds the creation of <b>std::shared_ptr</b>
objects by explicitly calling the constructor and a
<b>new</b> expression, and replaces it with a call to
<b>std::make_shared</b>.</p>
<pre style="margin-left:15%; margin-top: 1em">auto my_ptr = std::shared_ptr&lt;MyPair&gt;(new MyPair(1, 2));

// becomes

auto my_ptr = std::make_shared&lt;MyPair&gt;(1, 2);</pre>

<p style="margin-left:11%; margin-top: 1em">This check also
finds calls to <b>std::shared_ptr::reset()</b> with a
<b>new</b> expression, and replaces it with a call to
<b>std::make_shared</b>.</p>
<pre style="margin-left:15%; margin-top: 1em">my_ptr.reset(new MyPair(1, 2));

// becomes

my_ptr = std::make_shared&lt;MyPair&gt;(1, 2);</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
MakeSmartPtrFunction</b></p>

<p style="margin-left:22%;">A string specifying the name of
make&minus;shared&minus;ptr function. Default is
<i>std::make_shared</i>.</p>


<p style="margin-left:11%;"><b>MakeSmartPtrFunctionHeader</b></p>

<p style="margin-left:22%;">A string specifying the
corresponding header of make&minus;shared&minus;ptr
function. Default is <i>memory</i>.</p>

<p style="margin-left:11%;"><b>IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>

<p style="margin-left:11%;"><b>IgnoreMacros</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>


<p style="margin-left:11%;"><b>IgnoreDefaultInitialization</b></p>

<p style="margin-left:22%;">If set to non&minus;zero, the
check does not suggest edits that will transform default
initialization into value initialization, as this can cause
performance regressions. Default is <i>1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;make&minus;unique</b>
<br>
This check finds the creation of <b>std::unique_ptr</b>
objects by explicitly calling the constructor and a
<b>new</b> expression, and replaces it with a call to
<b>std::make_unique</b>, introduced in C++14.</p>
<pre style="margin-left:15%; margin-top: 1em">auto my_ptr = std::unique_ptr&lt;MyPair&gt;(new MyPair(1, 2));

// becomes

auto my_ptr = std::make_unique&lt;MyPair&gt;(1, 2);</pre>

<p style="margin-left:11%; margin-top: 1em">This check also
finds calls to <b>std::unique_ptr::reset()</b> with a
<b>new</b> expression, and replaces it with a call to
<b>std::make_unique</b>.</p>
<pre style="margin-left:15%; margin-top: 1em">my_ptr.reset(new MyPair(1, 2));

// becomes

my_ptr = std::make_unique&lt;MyPair&gt;(1, 2);</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
MakeSmartPtrFunction</b></p>

<p style="margin-left:22%;">A string specifying the name of
make&minus;unique&minus;ptr function. Default is
<i>std::make_unique</i>.</p>


<p style="margin-left:11%;"><b>MakeSmartPtrFunctionHeader</b></p>

<p style="margin-left:22%;">A string specifying the
corresponding header of make&minus;unique&minus;ptr
function. Default is <i>&lt;memory&gt;</i>.</p>

<p style="margin-left:11%;"><b>IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>

<p style="margin-left:11%;"><b>IgnoreMacros</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>


<p style="margin-left:11%;"><b>IgnoreDefaultInitialization</b></p>

<p style="margin-left:22%;">If set to non&minus;zero, the
check does not suggest edits that will transform default
initialization into value initialization, as this can cause
performance regressions. Default is <i>1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;pass&minus;by&minus;value</b>
<br>
With move semantics added to the language and the standard
library updated with move constructors added for many types
it is now interesting to take an argument directly by value,
instead of by const&minus;reference, and then copy. This
check allows the compiler to take care of choosing the best
way to construct the copy.</p>

<p style="margin-left:11%; margin-top: 1em">The
transformation is usually beneficial when the calling code
passes an <i>rvalue</i> and assumes the move construction is
a cheap operation. This short example illustrates how the
construction of the value happens:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(std::string s);
std::string get_str();


void f(const std::string &amp;str) {
  foo(str);       // lvalue  &minus;&gt; copy construction
  foo(get_str()); // prvalue &minus;&gt; move construction
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">Currently, only constructors
are transformed to make use of pass&minus;by&minus;value.
Contributions that handle other situations are welcome!</p>


<p style="margin-left:11%; margin-top: 1em"><b>Pass&minus;by&minus;value
in constructors</b> <br>
Replaces the uses of const&minus;references constructor
parameters that are copied into class fields. The parameter
is then moved with <i>std::move()</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Since
<b>std::move()</b> is a library function declared in
<i>&lt;utility&gt;</i> it may be necessary to add this
include. The check will add the include directive when
necessary.</p>
<pre style="margin-left:15%; margin-top: 1em"> #include &lt;string&gt;

 class Foo {
 public:
&minus;  Foo(const std::string &amp;Copied, const std::string &amp;ReadOnly)
&minus;    : Copied(Copied), ReadOnly(ReadOnly)
+  Foo(std::string Copied, const std::string &amp;ReadOnly)
+    : Copied(std::move(Copied)), ReadOnly(ReadOnly)
   {}

 private:
   std::string Copied;
   const std::string &amp;ReadOnly;
 };

 std::string get_cwd();


 void f(const std::string &amp;Path) {
   // The parameter corresponding to 'get_cwd()' is move&minus;constructed. By
   // using pass&minus;by&minus;value in the Foo constructor we managed to avoid a
   // copy&minus;construction.
   Foo foo(get_cwd(), Path);
 }</pre>


<p style="margin-left:11%; margin-top: 1em">If the
parameter is used more than once no transformation is
performed since moved objects have an undefined state. It
means the following code will be left untouched:</p>
<pre style="margin-left:15%; margin-top: 1em">#include &lt;string&gt;

void pass(const std::string &amp;S);

struct Foo {
  Foo(const std::string &amp;S) : Str(S) {
    pass(S);
  }

  std::string Str;
};</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Known
limitations</b> <br>
A situation where the generated code can be wrong is when
the object referenced is modified before the assignment in
the init&minus;list through a &quot;hidden&quot;
reference.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em"> std::string s(&quot;foo&quot;);

 struct Base {
   Base() {
     s = &quot;bar&quot;;
   }
 };

 struct Derived : Base {
&minus;  Derived(const std::string &amp;S) : Field(S)
+  Derived(std::string S) : Field(std::move(S))
   { }

   std::string Field;
 };


 void f() {
&minus;  Derived d(s); // d.Field holds &quot;bar&quot;
+  Derived d(s); // d.Field holds &quot;foo&quot;
 }</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Note about
delayed template parsing</b> <br>
When delayed template parsing is enabled, constructors part
of templated contexts; templated constructors, constructors
in class templates, constructors of inner classes of
template classes, etc., are not transformed. Delayed
template parsing is enabled by default on Windows as a
Microsoft extension: <i>Clang Compiler User's Manual &minus;
Microsoft extensions</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Delayed
template parsing can be enabled using the
<i>&minus;fdelayed&minus;template&minus;parsing</i> flag and
disabled using
<i>&minus;fno&minus;delayed&minus;template&minus;parsing</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em">  template &lt;typename T&gt; class C {
    std::string S;

  public:
=  // using &minus;fdelayed&minus;template&minus;parsing (default on Windows)
=  C(const std::string &amp;S) : S(S) {}


+  // using &minus;fno&minus;delayed&minus;template&minus;parsing (default on non&minus;Windows systems)
+  C(std::string S) : S(std::move(S)) {}
  };</pre>


<p style="margin-left:11%; margin-top: 1em"><b>SEE
ALSO:</b></p>

<p style="margin-left:15%;">For more information about the
pass&minus;by&minus;value idiom, read: <i>Want Speed? Pass
by Value</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>

<p style="margin-left:11%;"><b>ValuesOnly</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
only warns about copied parameters that are already passed
by value. Default is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;raw&minus;string&minus;literal</b>
<br>
This check selectively replaces string literals containing
escaped characters with raw string literals.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">const char *const Quotes{&quot;embedded \&quot;quotes\&quot;&quot;};
const char *const Paragraph{&quot;Line one.\nLine two.\nLine three.\n&quot;};
const char *const SingleLine{&quot;Single line.\n&quot;};
const char *const TrailingSpace{&quot;Look here &minus;&gt; \n&quot;};
const char *const Tab{&quot;One\tTwo\n&quot;};
const char *const Bell{&quot;Hello!\a  And welcome!&quot;};
const char *const Path{&quot;C:\\Program Files\\Vendor\\Application.exe&quot;};
const char *const RegEx{&quot;\\w\\([a&minus;z]\\)&quot;};</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>

<pre style="margin-left:15%; margin-top: 1em">const char *const Quotes{R&quot;(embedded &quot;quotes&quot;)&quot;};
const char *const Paragraph{&quot;Line one.\nLine two.\nLine three.\n&quot;};
const char *const SingleLine{&quot;Single line.\n&quot;};
const char *const TrailingSpace{&quot;Look here &minus;&gt; \n&quot;};
const char *const Tab{&quot;One\tTwo\n&quot;};
const char *const Bell{&quot;Hello!\a  And welcome!&quot;};
const char *const Path{R&quot;(C:\Program Files\Vendor\Application.exe)&quot;};
const char *const RegEx{R&quot;(\w\([a&minus;z]\))&quot;};</pre>


<p style="margin-left:11%; margin-top: 1em">The presence of
any of the following escapes can cause the string to be
converted to a raw string literal: <b>\\</b>, <b>\'</b>,
<b>\&quot;</b>, <b>\?</b>, and octal or hexadecimal escapes
for printable ASCII characters.</p>

<p style="margin-left:11%; margin-top: 1em">A string
literal containing only escaped newlines is a common way of
writing lines of text output. Introducing physical newlines
with raw string literals in this case is likely to impede
readability. These string literals are left unchanged.</p>

<p style="margin-left:11%; margin-top: 1em">An escaped
horizontal tab, form feed, or vertical tab prevents the
string literal from being converted. The presence of a
horizontal tab, form feed or vertical tab in source code is
not visually obvious.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;redundant&minus;void&minus;arg</b>
<br>
Find and remove redundant <b>void</b> argument lists.
<b><br>
Examples:</b></p>


<p align="center" style="margin-top: 1em"><b><img src="grohtml-30332502.png" alt="Image grohtml-30332502.png"></b></p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;replace&minus;auto&minus;ptr</b>
<br>
This check replaces the uses of the deprecated class
<b>std::auto_ptr</b> by <b>std::unique_ptr</b> (introduced
in C++11). The transfer of ownership, done by the
copy&minus;constructor and the assignment operator, is
changed to match <b>std::unique_ptr</b> usage by using
explicit calls to <b>std::move()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Migration
example:</p>
<pre style="margin-left:15%; margin-top: 1em">&minus;void take_ownership_fn(std::auto_ptr&lt;int&gt; int_ptr);
+void take_ownership_fn(std::unique_ptr&lt;int&gt; int_ptr);

 void f(int x) {
&minus;  std::auto_ptr&lt;int&gt; a(new int(x));
&minus;  std::auto_ptr&lt;int&gt; b;
+  std::unique_ptr&lt;int&gt; a(new int(x));
+  std::unique_ptr&lt;int&gt; b;


&minus;  b = a;
&minus;  take_ownership_fn(b);
+  b = std::move(a);
+  take_ownership_fn(std::move(b));
 }</pre>


<p style="margin-left:11%; margin-top: 1em">Since
<b>std::move()</b> is a library function declared in
<b>&lt;utility&gt;</b> it may be necessary to add this
include. The check will add the include directive when
necessary.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Known
Limitations</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>If headers modification is not activated or if a header
is not allowed to be changed this check will produce broken
code (compilation error), where the headers' code will stay
unchanged while the code using them will be changed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Client code that declares a reference to an
<b>std::auto_ptr</b> coming from code that can't be migrated
(such as a header coming from a 3 <small>rd</small> party
library) will produce a compilation error after migration.
This is because the type of the reference will be changed to
<b>std::unique_ptr</b> but the type returned by the library
won't change, binding a reference to <b>std::unique_ptr</b>
from an <b>std::auto_ptr</b>. This pattern doesn't make much
sense and usually <b>std::auto_ptr</b> are stored by value
(otherwise what is the point in using them instead of a
reference or a pointer?).</p></td></tr>
</table>
<pre style="margin-left:15%; margin-top: 1em"> // &lt;3rd&minus;party header...&gt;
 std::auto_ptr&lt;int&gt; get_value();
 const std::auto_ptr&lt;int&gt; &amp; get_ref();

 // &lt;calling code (with migration)...&gt;
&minus;std::auto_ptr&lt;int&gt; a(get_value());
+std::unique_ptr&lt;int&gt; a(get_value()); // ok, unique_ptr constructed from auto_ptr


&minus;const std::auto_ptr&lt;int&gt; &amp; p = get_ptr();
+const std::unique_ptr&lt;int&gt; &amp; p = get_ptr(); // won't compile</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em">Non&minus;instantiated templates
aren't modified.</p></td>
<td width="20%">
</td></tr>
</table>
<pre style="margin-left:15%; margin-top: 1em">template &lt;typename X&gt;
void f() {
    std::auto_ptr&lt;X&gt; p;
}


// only 'f&lt;int&gt;()' (or similar) will trigger the replacement.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;replace&minus;disallow&minus;copy&minus;and&minus;assign&minus;macro</b>
<br>
Finds macro expansions of
<b>DISALLOW_COPY_AND_ASSIGN(Type)</b> and replaces them with
a deleted copy constructor and a deleted assignment
operator.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
<b>delete</b> keyword was introduced in C++11 it was common
practice to declare a copy constructor and an assignment
operator as private members. This effectively makes them
unusable to the public API of a class.</p>

<p style="margin-left:11%; margin-top: 1em">With the advent
of the <b>delete</b> keyword in C++11 we can abandon the
<b>private</b> access of the copy constructor and the
assignment operator and delete the methods entirely.</p>

<p style="margin-left:11%; margin-top: 1em">When running
this check on a code like this:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
private:
  DISALLOW_COPY_AND_ASSIGN(Foo);
};</pre>


<p style="margin-left:11%; margin-top: 1em">It will be
transformed to this:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
private:
  Foo(const Foo &amp;) = delete;
  const Foo &amp;operator=(const Foo &amp;) = delete;
};</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Known
Limitations</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Notice that the migration example above leaves the
<b>private</b> access specification untouched. You might
want to run the check
<i>modernize&minus;use&minus;equals&minus;delete</i> to get
warnings for deleted functions in private sections.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
MacroName</b></p>

<p style="margin-left:22%;">A string specifying the macro
name whose expansion will be replaced. Default is
<i>DISALLOW_COPY_AND_ASSIGN</i>.</p>

<p style="margin-left:11%; margin-top: 1em">See:
<i>https://en.cppreference.com/w/cpp/language/function#Deleted_functions</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;replace&minus;random&minus;shuffle</b>
<br>
This check will find occurrences of
<b>std::random_shuffle</b> and replace it with
<b>std::shuffle</b>. In C++17 <b>std::random_shuffle</b>
will no longer be available and thus we need to replace
it.</p>

<p style="margin-left:11%; margin-top: 1em">Below are two
examples of what kind of occurrences will be found and two
examples of what it will be replaced with.</p>
<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;int&gt; v;

// First example
std::random_shuffle(vec.begin(), vec.end());


// Second example
std::random_shuffle(vec.begin(), vec.end(), randomFunc);</pre>


<p style="margin-left:11%; margin-top: 1em">Both of these
examples will be replaced with:</p>

<pre style="margin-left:15%; margin-top: 1em">std::shuffle(vec.begin(), vec.end(), std::mt19937(std::random_device()()));</pre>


<p style="margin-left:11%; margin-top: 1em">The second
example will also receive a warning that <b>randomFunc</b>
is no longer supported in the same way as before so if the
user wants the same functionality, the user will need to
change the implementation of the <b>randomFunc</b>.</p>

<p style="margin-left:11%; margin-top: 1em">One thing to be
aware of here is that <b>std::random_device</b> is quite
expensive to initialize. So if you are using the code in a
performance critical place, you probably want to initialize
it elsewhere. Another thing is that the seeding quality of
the suggested fix is quite poor: <b>std::mt19937</b> has an
internal state of 624 32&minus;bit integers, but is only
seeded with a single integer. So if you require higher
quality randomness, you should consider seeding better, for
example:</p>

<pre style="margin-left:15%; margin-top: 1em">std::shuffle(v.begin(), v.end(), []() {
  std::mt19937::result_type seeds[std::mt19937::state_size];
  std::random_device device;
  std::uniform_int_distribution&lt;typename std::mt19937::result_type&gt; dist;
  std::generate(std::begin(seeds), std::end(seeds), [&amp;] { return dist(device); });
  std::seed_seq seq(std::begin(seeds), std::end(seeds));
  return std::mt19937(seq);
}());</pre>



<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;return&minus;braced&minus;init&minus;list</b>
<br>
Replaces explicit calls to the constructor in a return with
a braced initializer list. This way the return type is not
needlessly duplicated in the function definition and the
return statement.</p>
<pre style="margin-left:15%; margin-top: 1em">Foo bar() {
  Baz baz;
  return Foo(baz);
}

// transforms to:

Foo bar() {
  Baz baz;
  return {baz};
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;shrink&minus;to&minus;fit</b>
<br>
Replace copy and swap tricks on shrinkable containers with
the <b>shrink_to_fit()</b> method call.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>shrink_to_fit()</b> method is more readable and more
effective than the copy and swap trick to reduce the
capacity of a shrinkable container. Note that, the
<b>shrink_to_fit()</b> method is only available in C++11 and
up.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;unary&minus;static&minus;assert</b>
<br>
The check diagnoses any <b>static_assert</b> declaration
with an empty string literal and provides a fix&minus;it to
replace the declaration with a single&minus;argument
<b>static_assert</b> declaration.</p>

<p style="margin-left:11%; margin-top: 1em">The check is
only applicable for C++17 and later code.</p>

<p style="margin-left:11%; margin-top: 1em">The following
code:</p>

<pre style="margin-left:15%; margin-top: 1em">void f_textless(int a) {
  static_assert(sizeof(a) &lt;= 10, &quot;&quot;);
}</pre>


<p style="margin-left:11%; margin-top: 1em">is replaced
by:</p>

<pre style="margin-left:15%; margin-top: 1em">void f_textless(int a) {
  static_assert(sizeof(a) &lt;= 10);
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;auto</b>
<br>
This check is responsible for using the <b>auto</b> type
specifier for variable declarations to <i>improve code
readability and maintainability</i>. For example:</p>
<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;int&gt;::iterator I = my_container.begin();

// transforms to:

auto I = my_container.begin();</pre>

<p style="margin-left:11%; margin-top: 1em">The <b>auto</b>
type specifier will only be introduced in situations where
the variable type matches the type of the initializer
expression. In other words <b>auto</b> should deduce the
same type that was originally spelled in the source.
However, not every situation should be transformed:</p>
<pre style="margin-left:15%; margin-top: 1em">int val = 42;
InfoStruct &amp;I = SomeObject.getInfo();

// Should not become:

auto val = 42;
auto &amp;I = SomeObject.getInfo();</pre>

<p style="margin-left:11%; margin-top: 1em">In this example
using <b>auto</b> for builtins doesn't improve readability.
In other situations it makes the code less
self&minus;documenting impairing readability and
maintainability. As a result, <b>auto</b> is used only
introduced in specific situations described below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Iterators</b>
<br>
Iterator type specifiers tend to be long and used
frequently, especially in loop constructs. Since the
functions generating iterators have a common format, the
type specifier can be replaced without obscuring the meaning
of code while improving readability and maintainability.</p>
<pre style="margin-left:15%; margin-top: 1em">for (std::vector&lt;int&gt;::iterator I = my_container.begin(),
                                E = my_container.end();
     I != E; ++I) {
}

// becomes


for (auto I = my_container.begin(), E = my_container.end(); I != E; ++I) {
}</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
only replace iterator type&minus;specifiers when all of the
following conditions are satisfied:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The iterator is for one of the standard containers in
<b>std</b> namespace:</p></td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em"><b>array</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>deque</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>forward_list</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>list</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>vector</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>map</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>multimap</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>set</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>multiset</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>unordered_map</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>unordered_multimap</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>unordered_set</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>unordered_multiset</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>queue</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>priority_queue</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><b>stack</b></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%"></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">The iterator is
one of the possible iterator types for standard
containers:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p style="margin-top: 1em"><b>iterator</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p><b>reverse_iterator</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p><b>const_iterator</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p><b>const_reverse_iterator</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="34%"></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">In addition to
using iterator types directly, typedefs or other ways of
referring to those types are also allowed. However,
implementation&minus;specific types for which a type like
<b>std::vector&lt;int&gt;::iterator</b> is itself a typedef
will not be transformed. Consider the following
examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// The following direct uses of iterator types will be transformed.
std::vector&lt;int&gt;::iterator I = MyVec.begin();
{
  using namespace std;
  list&lt;int&gt;::iterator I = MyList.begin();
}

// The type specifier for J would transform to auto since it's a typedef
// to a standard iterator type.
typedef std::map&lt;int, std::string&gt;::const_iterator map_iterator;
map_iterator J = MyMap.begin();


// The following implementation&minus;specific iterator type for which
// std::vector&lt;int&gt;::iterator could be a typedef would not be transformed.
__gnu_cxx::__normal_iterator&lt;int*, std::vector&gt; K = MyVec.begin();</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">The initializer for the variable
being declared is not a braced initializer list. Otherwise,
use of <b>auto</b> would cause the type of the variable to
be deduced as <b>std::initializer_list</b>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>New
expressions</b> <br>
Frequently, when a pointer is declared and initialized with
<b>new</b>, the pointee type is written twice: in the
declaration type and in the <b>new</b> expression. In this
case, the declaration type can be replaced with <b>auto</b>
improving readability and maintainability.</p>
<pre style="margin-left:15%; margin-top: 1em">TypeName *my_pointer = new TypeName(my_param);

// becomes

auto *my_pointer = new TypeName(my_param);</pre>

<p style="margin-left:11%; margin-top: 1em">The check will
also replace the declaration type in multiple declarations,
if the following conditions are satisfied:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">All declared variables have the
same type (i.e. all of them are pointers to the same
type).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>All declared variables are initialized with a <b>new</b>
expression.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The types of all the new expressions are the same than
the pointee of the declaration type.</p></td></tr>
</table>
<pre style="margin-left:15%; margin-top: 1em">TypeName *my_first_pointer = new TypeName, *my_second_pointer = new TypeName;

// becomes


auto *my_first_pointer = new TypeName, *my_second_pointer = new TypeName;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Cast
expressions</b> <br>
Frequently, when a variable is declared and initialized with
a cast, the variable type is written twice: in the
declaration type and in the cast expression. In this case,
the declaration type can be replaced with <b>auto</b>
improving readability and maintainability.</p>
<pre style="margin-left:15%; margin-top: 1em">TypeName *my_pointer = static_cast&lt;TypeName&gt;(my_param);

// becomes


auto *my_pointer = static_cast&lt;TypeName&gt;(my_param);</pre>


<p style="margin-left:11%; margin-top: 1em">The check
handles <b>static_cast</b>, <b>dynamic_cast</b>,
<b>const_cast</b>, <b>reinterpret_cast</b>, functional
casts, C&minus;style casts and function templates that
behave as casts, such as <b>llvm::dyn_cast</b>,
<b>boost::lexical_cast</b> and <b>gsl::narrow_cast</b>.
Calls to function templates are considered to behave as
casts if the first template argument is explicit and is a
type, and the function returns that type, or a pointer or
reference to it.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Known
Limitations</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">If the initializer is an
explicit conversion constructor, the check will not replace
the type specifier even though it would be safe to do
so.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>User&minus;defined iterators are not handled at this
time.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
MinTypeNameLength</b></p>

<p style="margin-left:22%;">If the option is set to
non&minus;zero (default <i>5</i>), the check will ignore
type names having a length less than the option value. The
option affects expressions only, not iterators. Spaces
between multi&minus;lexeme type names (<b>long int</b>) are
considered as one. If the <i>RemoveStars</i> option (see
below) is set to <i>true</i>, then <b>*s</b> in the type are
also counted as a part of the type name.</p>
<pre style="margin-left:15%; margin-top: 1em">// MinTypeNameLength = 0, RemoveStars=0

int a = static_cast&lt;int&gt;(foo());            // &minus;&minus;&minus;&gt; auto a = ...
// length(bool *) = 4
bool *b = new bool;                         // &minus;&minus;&minus;&gt; auto *b = ...
unsigned c = static_cast&lt;unsigned&gt;(foo());  // &minus;&minus;&minus;&gt; auto c = ...

// MinTypeNameLength = 5, RemoveStars=0

int a = static_cast&lt;int&gt;(foo());                 // &minus;&minus;&minus;&gt; int  a = ...
bool b = static_cast&lt;bool&gt;(foo());               // &minus;&minus;&minus;&gt; bool b = ...
bool *pb = static_cast&lt;bool*&gt;(foo());            // &minus;&minus;&minus;&gt; bool *pb = ...
unsigned c = static_cast&lt;unsigned&gt;(foo());       // &minus;&minus;&minus;&gt; auto c = ...
// length(long &lt;on&minus;or&minus;more&minus;spaces&gt; int) = 8
long int d = static_cast&lt;long int&gt;(foo());       // &minus;&minus;&minus;&gt; auto d = ...

// MinTypeNameLength = 5, RemoveStars=1


int a = static_cast&lt;int&gt;(foo());                 // &minus;&minus;&minus;&gt; int  a = ...
// length(int * * ) = 5
int **pa = static_cast&lt;int**&gt;(foo());            // &minus;&minus;&minus;&gt; auto pa = ...
bool b = static_cast&lt;bool&gt;(foo());               // &minus;&minus;&minus;&gt; bool b = ...
bool *pb = static_cast&lt;bool*&gt;(foo());            // &minus;&minus;&minus;&gt; auto pb = ...
unsigned c = static_cast&lt;unsigned&gt;(foo());       // &minus;&minus;&minus;&gt; auto c = ...
long int d = static_cast&lt;long int&gt;(foo());       // &minus;&minus;&minus;&gt; auto d = ...</pre>


<p style="margin-left:11%;"><b>RemoveStars</b></p>

<p style="margin-left:22%;">If the option is set to
<i>true</i> (default is <i>false</i>), the check will remove
stars from the non&minus;typedef pointer types when
replacing type names with <b>auto</b>. Otherwise, the check
will leave stars. For example:</p>
<pre style="margin-left:15%; margin-top: 1em">TypeName *my_first_pointer = new TypeName, *my_second_pointer = new TypeName;

// RemoveStars = 0

auto *my_first_pointer = new TypeName, *my_second_pointer = new TypeName;

// RemoveStars = 1


auto my_first_pointer = new TypeName, my_second_pointer = new TypeName;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;bool&minus;literals</b>
<br>
Finds integer literals which are cast to <b>bool</b>.</p>
<pre style="margin-left:15%; margin-top: 1em">bool p = 1;
bool f = static_cast&lt;bool&gt;(1);
std::ios_base::sync_with_stdio(0);
bool x = p ? 1 : 0;

// transforms to


bool p = true;
bool f = true;
std::ios_base::sync_with_stdio(false);
bool x = p ? true : false;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoreMacros</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;default</b>
<br>
This check has been renamed to
<i>modernize&minus;use&minus;equals&minus;default</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;default&minus;member&minus;init</b>
<br>
This check converts constructors' member initializers into
the new default member initializers in C++11. Other member
initializers that match the default member initializer are
removed. This can reduce repeated code or allow use of '=
default'.</p>
<pre style="margin-left:15%; margin-top: 1em">struct A {
  A() : i(5), j(10.0) {}
  A(int i) : i(i), j(10.0) {}
  int i;
  double j;
};

// becomes


struct A {
  A() {}
  A(int i) : i(i) {}
  int i{5};
  double j{10.0};
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">Only converts member
initializers for built&minus;in types, enums, and pointers.
The
<i>readability&minus;redundant&minus;member&minus;init</i>
check will remove redundant member initializers for
classes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
UseAssignment</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i> (default is <i>false</i>), the check will
initialize members with an assignment. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">struct A {
  A() {}
  A(int i) : i(i) {}
  int i = 5;
  double j = 10.0;
};</pre>


<p style="margin-left:11%;"><b>IgnoreMacros</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about members declared inside macros.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;emplace</b>
<br>
The check flags insertions to an STL&minus;style container
done by calling the <b>push_back</b> method with an
explicitly&minus;constructed temporary of the container
element type. In this case, the corresponding
<b>emplace_back</b> method results in less verbose and
potentially more efficient code. Right now the check doesn't
support <b>push_front</b> and <b>insert</b>. It also doesn't
support <b>insert</b> functions for associative containers
because replacing <b>insert</b> with <b>emplace</b> may
result in <i>speed regression</i>, but it might get support
with some addition flag in the future.</p>

<p style="margin-left:11%; margin-top: 1em">By default only
<b>std::vector</b>, <b>std::deque</b>, <b>std::list</b> are
considered. This list can be modified using the
<i>ContainersWithPushBack</i> option.</p>

<p style="margin-left:11%; margin-top: 1em">This check also
reports when an <b>emplace</b>&minus;like method is
improperly used, for example using <b>emplace_back</b> while
also calling a constructor. This creates a temporary that
requires at best a move and at worst a copy. Almost all
<b>emplace</b>&minus;like functions in the STL are covered
by this, with <b>try_emplace</b> on <b>std::map</b> and
<b>std::unordered_map</b> being the exception as it behaves
slightly differently than all the others. More containers
can be added with the <i>EmplacyFunctions</i> option, so
long as the container defines a <b>value_type</b> type, and
the <b>emplace</b>&minus;like functions construct a
<b>value_type</b> object.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;MyClass&gt; v;
v.push_back(MyClass(21, 37));
v.emplace_back(MyClass(21, 37));

std::vector&lt;std::pair&lt;int, int&gt;&gt; w;


w.push_back(std::pair&lt;int, int&gt;(21, 37));
w.push_back(std::make_pair(21L, 37L));
w.emplace_back(std::make_pair(21L, 37L));</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;MyClass&gt; v;
v.emplace_back(21, 37);
v.emplace_back(21, 37);


std::vector&lt;std::pair&lt;int, int&gt;&gt; w;
w.emplace_back(21, 37);
w.emplace_back(21L, 37L);
w.emplace_back(21L, 37L);</pre>


<p style="margin-left:11%; margin-top: 1em">By default, the
check is able to remove unnecessary <b>std::make_pair</b>
and <b>std::make_tuple</b> calls from <b>push_back</b> calls
on containers of <b>std::pair</b> and <b>std::tuple</b>.
Custom tuple&minus;like types can be modified by the
<i>TupleTypes</i> option; custom make functions can be
modified by the <i>TupleMakeFunctions</i> option.</p>

<p style="margin-left:11%; margin-top: 1em">The other
situation is when we pass arguments that will be converted
to a type inside a container.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;boost::optional&lt;std::string&gt; &gt; v;
v.push_back(&quot;abc&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;boost::optional&lt;std::string&gt; &gt; v;
v.emplace_back(&quot;abc&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">In some cases
the transformation would be valid, but the code wouldn't be
exception safe. In this case the calls of <b>push_back</b>
won't be replaced.</p>

<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;std::unique_ptr&lt;int&gt;&gt; v;
v.push_back(std::unique_ptr&lt;int&gt;(new int(0)));
auto *ptr = new int(1);
v.push_back(std::unique_ptr&lt;int&gt;(ptr));</pre>


<p style="margin-left:11%; margin-top: 1em">This is because
replacing it with <b>emplace_back</b> could cause a leak of
this pointer if <b>emplace_back</b> would throw exception
before emplacement (e.g. not enough memory to add a new
element).</p>

<p style="margin-left:11%; margin-top: 1em">For more info
read item 42 &minus; &quot;Consider emplacement instead of
insertion.&quot; of Scott Meyers &quot;Effective Modern
C++&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The default
smart pointers that are considered are
<b>std::unique_ptr</b>, <b>std::shared_ptr</b>,
<b>std::auto_ptr</b>. To specify other smart pointers or
other classes use the <i>SmartPointers</i> option.</p>

<p style="margin-left:11%; margin-top: 1em">Check also
doesn't fire if any argument of the constructor call would
be:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>a bit&minus;field (bit&minus;fields can't bind to
rvalue/universal reference)</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>a <b>new</b> expression (to avoid leak)</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>if the argument would be converted via
derived&minus;to&minus;base cast.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This check
requires C++11 or higher to run.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
ContainersWithPushBack</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of class names of custom containers that support
<b>push_back</b>.</p>


<p style="margin-left:11%;"><b>IgnoreImplicitConstructors</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will ignore implicitly constructed arguments of
<b>push_back</b>, e.g.</p>

<pre style="margin-left:26%; margin-top: 1em">std::vector&lt;std::string&gt; v;
v.push_back(&quot;a&quot;); // Ignored when IgnoreImplicitConstructors is `true`.</pre>


<p style="margin-left:22%; margin-top: 1em">Default is
<i>false</i>.</p>

<p style="margin-left:11%;"><b>SmartPointers</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of class names of custom smart pointers.</p>

<p style="margin-left:11%;"><b>TupleTypes</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of <b>std::tuple</b>&minus;like class names.</p>

<p style="margin-left:11%;"><b>TupleMakeFunctions</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of <b>std::make_tuple</b>&minus;like function names. Those
function calls will be removed from <b>push_back</b> calls
and turned into <b>emplace_back</b>.</p>

<p style="margin-left:11%;"><b>EmplacyFunctions</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of containers without their template parameters and some
<b>emplace</b>&minus;like method of the container. Example:
<b>vector::emplace_back</b>. Those methods will be checked
for improper use and the check will report when a temporary
is unnecessarily created.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">std::vector&lt;MyTuple&lt;int, bool, char&gt;&gt; x;
x.push_back(MakeMyTuple(1, false, 'x'));
x.emplace_back(MakeMyTuple(1, false, 'x'));</pre>


<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>

<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;MyTuple&lt;int, bool, char&gt;&gt; x;
x.emplace_back(1, false, 'x');
x.emplace_back(1, false, 'x');</pre>


<p style="margin-left:11%; margin-top: 1em">when
<i>TupleTypes</i> is set to <b>MyTuple</b>,
<i>TupleMakeFunctions</i> is set to <b>MakeMyTuple</b>, and
<i>EmplacyFunctions</i> is set to
<b>vector::emplace_back</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;equals&minus;default</b>
<br>
This check replaces default bodies of special member
functions with <b>= default;</b>. The explicitly defaulted
function declarations enable more opportunities in
optimization, because the compiler might treat explicitly
defaulted functions as trivial.</p>
<pre style="margin-left:15%; margin-top: 1em">struct A {
  A() {}
  ~A();
};
A::~A() {}

// becomes


struct A {
  A() = default;
  ~A();
};
A::~A() = default;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">Move&minus;constructor and
move&minus;assignment operator are not supported yet.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoreMacros</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;equals&minus;delete</b>
<br>
This check marks unimplemented private special member
functions with <b>= delete</b>. To avoid
false&minus;positives, this check only applies in a
translation unit that has all other member functions
implemented.</p>
<pre style="margin-left:15%; margin-top: 1em">struct A {
private:
  A(const A&amp;);
  A&amp; operator=(const A&amp;);
};

// becomes


struct A {
private:
  A(const A&amp;) = delete;
  A&amp; operator=(const A&amp;) = delete;
};</pre>


<p style="margin-left:11%;"><b>IgnoreMacros</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about functions declared inside macros.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;nodiscard</b>
<br>
Adds <b>[[nodiscard]]</b> attributes (introduced in C++17)
to member functions in order to highlight at compile time
which return values should not be ignored.</p>

<p style="margin-left:11%; margin-top: 1em">Member
functions need to satisfy the following conditions to be
considered by this check:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>no <b>[[nodiscard]]</b>, <b>[[noreturn]]</b>,
<b>__attribute__((warn_unused_result))</b>,
<b>[[clang::warn_unused_result]]</b> nor
<b>[[gcc::warn_unused_result]]</b> attribute,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>non&minus;void return type,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>non&minus;template return types,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>const member function,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>non&minus;variadic functions,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>no non&minus;const reference parameters,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>no pointer parameters,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>no template parameters,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>no template function parameters,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>not be a member of a class with mutable member
variables,</p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>no Lambdas,</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>no conversion functions.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Such functions
have no means of altering any state or passing values other
than via the return type. Unless the member functions are
altering state via some external call (e.g. I/O).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">bool empty() const;
bool empty(int i) const;</pre>


<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>

<pre style="margin-left:15%; margin-top: 1em">[[nodiscard]] bool empty() const;
[[nodiscard]] bool empty(int i) const;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
ReplacementString</b></p>

<p style="margin-left:22%;">Specifies a macro to use
instead of <b>[[nodiscard]]</b>. This is useful when
maintaining source code that needs to compile with a
pre&minus;C++17 compiler.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">bool empty() const;
bool empty(int i) const;</pre>


<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>

<pre style="margin-left:15%; margin-top: 1em">NO_DISCARD bool empty() const;
NO_DISCARD bool empty(int i) const;</pre>


<p style="margin-left:11%; margin-top: 1em">if the
<i>ReplacementString</i> option is set to
<i>NO_DISCARD</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">If the <i>ReplacementString</i>
is not a C++ attribute, but instead a macro, then that macro
must be defined in scope or the fix&minus;it will not be
applied.</p>


<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">For alternative
<b>__attribute__</b> syntax options to mark functions as
<b>[[nodiscard]]</b> in non&minus;c++17 source code. See
<i>https://clang.llvm.org/docs/AttributeReference.html#nodiscard&minus;warn&minus;unused&minus;result</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;noexcept</b>
<br>
This check replaces deprecated dynamic exception
specifications with the appropriate noexcept specification
(introduced in C++11). By default this check will replace
<b>throw()</b> with <b>noexcept</b>, and
<b>throw(&lt;exception&gt;[,...])</b> or <b>throw(...)</b>
with <b>noexcept(false)</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">void foo() throw();
void bar() throw(int) {}</pre>


<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() noexcept;
void bar() noexcept(false) {}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
ReplacementString</b></p>

<p style="margin-left:22%;">Users can use
<i>ReplacementString</i> to specify a macro to use instead
of <b>noexcept</b>. This is useful when maintaining source
code that uses custom exception specification marking other
than <b>noexcept</b>. Fix&minus;it hints will only be
generated for non&minus;throwing specifications.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">void bar() throw(int);
void foo() throw();</pre>


<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>

<pre style="margin-left:15%; margin-top: 1em">void bar() throw(int);  // No fix&minus;it generated.
void foo() NOEXCEPT;</pre>


<p style="margin-left:11%; margin-top: 1em">if the
<i>ReplacementString</i> option is set to <i>NOEXCEPT</i>.
<b><br>
UseNoexceptFalse</b></p>

<p style="margin-left:11%; margin-top: 1em">Enabled by
default, disabling will generate fix&minus;it hints that
remove throwing dynamic exception specs, e.g.,
<b>throw(&lt;something&gt;)</b>, completely without
providing a replacement text, except for destructors and
delete operators that are <b>noexcept(true)</b> by
default.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>

<pre style="margin-left:15%;">void foo() throw(int) {}


struct bar {
  void foobar() throw(int);
  void operator delete(void *ptr) throw(int);
  void operator delete[](void *ptr) throw(int);
  ~bar() throw(int);
}</pre>


<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo() {}


struct bar {
  void foobar();
  void operator delete(void *ptr) noexcept(false);
  void operator delete[](void *ptr) noexcept(false);
  ~bar() noexcept(false);
}</pre>


<p style="margin-left:11%; margin-top: 1em">if the
<i>UseNoexceptFalse</i> option is set to <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;nullptr</b>
<br>
The check converts the usage of null pointer constants (e.g.
<b>NULL</b>, <b>0</b>) to use the new C++11 <b>nullptr</b>
keyword.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>

<pre style="margin-left:15%;">void assignment() {
  char *a = NULL;
  char *b = 0;
  char c = 0;
}

int *ret_ptr() {
  return 0;
}</pre>

<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>
<pre style="margin-left:15%; margin-top: 1em">void assignment() {
  char *a = nullptr;
  char *b = nullptr;
  char c = 0;
}

int *ret_ptr() {
  return nullptr;
}</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
NullMacros</b></p>

<p style="margin-left:22%;">Comma&minus;separated list of
macro names that will be transformed along with <b>NULL</b>.
By default this check will only replace the <b>NULL</b>
macro and will skip any similar user&minus;defined
macros.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">#define MY_NULL (void*)0
void assignment() {
  void *p = MY_NULL;
}</pre>


<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>

<pre style="margin-left:15%; margin-top: 1em">#define MY_NULL NULL
void assignment() {
  int *p = nullptr;
}</pre>


<p style="margin-left:11%; margin-top: 1em">if the
<i>NullMacros</i> option is set to <b>MY_NULL</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;override</b>
<br>
Adds <b>override</b> (introduced in C++11) to overridden
virtual functions and removes <b>virtual</b> from those
functions as it is not required.</p>

<p style="margin-left:11%; margin-top: 1em"><b>virtual</b>
on non base class implementations was used to help indicate
to the user that a function was virtual. C++ compilers did
not use the presence of this to signify an overridden
function.</p>

<p style="margin-left:11%; margin-top: 1em">In C++ 11
<b>override</b> and <b>final</b> keywords were introduced to
allow overridden functions to be marked appropriately. Their
presence allows compilers to verify that an overridden
function correctly overrides a base class
implementation.</p>

<p style="margin-left:11%; margin-top: 1em">This can be
useful as compilers can generate a compile time error
when:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>The base class implementation function signature
changes.</p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>The user has not created the override with the correct
signature.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoreDestructors</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, this
check will not diagnose destructors. Default is
<i>false</i>.</p>


<p style="margin-left:11%;"><b>AllowOverrideAndFinal</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, this
check will not diagnose <b>override</b> as redundant with
<b>final</b>. This is useful when code will be compiled by a
compiler with warning/error checking flags requiring
<b>override</b> explicitly on overridden members, such as
<b>gcc &minus;Wsuggest&minus;override</b>/<b>gcc
&minus;Werror=suggest&minus;override</b>. Default is
<i>false</i>.</p>

<p style="margin-left:11%;"><b>OverrideSpelling</b></p>

<p style="margin-left:22%;">Specifies a macro to use
instead of <b>override</b>. This is useful when maintaining
source code that also needs to compile with a
pre&minus;C++11 compiler.</p>

<p style="margin-left:11%;"><b>FinalSpelling</b></p>

<p style="margin-left:22%;">Specifies a macro to use
instead of <b>final</b>. This is useful when maintaining
source code that also needs to compile with a
pre&minus;C++11 compiler.</p>


<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">For more information on the use
of <b>override</b> see
<i>https://en.cppreference.com/w/cpp/language/override</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;trailing&minus;return&minus;type</b>
<br>
Rewrites function signatures to use a trailing return type
(introduced in C++11). This transformation is purely
stylistic. The return type before the function name is
replaced by <b>auto</b> and inserted after the function
parameter list (and qualifiers).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">int f1();
inline int f2(int arg) noexcept;
virtual float f3() const &amp;&amp; = delete;</pre>


<p style="margin-left:11%; margin-top: 1em">transforms
to:</p>

<pre style="margin-left:15%; margin-top: 1em">auto f1() &minus;&gt; int;
inline auto f2(int arg) &minus;&gt; int noexcept;
virtual auto f3() const &amp;&amp; &minus;&gt; float = delete;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Known
Limitations</b> <br>
The following categories of return types cannot be rewritten
currently:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p>function pointers</p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p>member function pointers</p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="37%">


<p>member pointers</p></td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Unqualified
names in the return type might erroneously refer to
different entities after the rewrite. Preventing such errors
requires a full lookup of all unqualified names present in
the return type in the scope of the trailing return type
location. This location includes e.g. function parameter
names and members of the enclosing class (including all
inherited classes). Such a lookup is currently not
implemented.</p>

<p style="margin-left:11%; margin-top: 1em">Given the
following piece of code</p>

<pre style="margin-left:15%; margin-top: 1em">struct S { long long value; };
S f(unsigned S) { return {S * 2}; }
class CC {
  int S;
  struct S m();
};
S CC::m() { return {0}; }</pre>


<p style="margin-left:11%; margin-top: 1em">a careless
rewrite would produce the following output:</p>

<pre style="margin-left:15%; margin-top: 1em">struct S { long long value; };
auto f(unsigned S) &minus;&gt; S { return {S * 2}; } // error
class CC {
  int S;
  auto m() &minus;&gt; struct S;
};
auto CC::m() &minus;&gt; S { return {0}; } // error</pre>


<p style="margin-left:11%; margin-top: 1em">This code fails
to compile because the S in the context of f refers to the
equally named function parameter. Similarly, the S in the
context of m refers to the equally named class member. The
check can currently only detect and avoid a clash with a
function parameter name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;transparent&minus;functors</b>
<br>
Prefer transparent functors to non&minus;transparent ones.
When using transparent functors, the type does not need to
be repeated. The code is easier to read, maintain and less
prone to errors. It is not possible to introduce unwanted
conversions.</p>
<pre style="margin-left:15%; margin-top: 1em">// Non&minus;transparent functor
std::map&lt;int, std::string, std::greater&lt;int&gt;&gt; s;

// Transparent functor.
std::map&lt;int, std::string, std::greater&lt;&gt;&gt; s;


// Non&minus;transparent functor
using MyFunctor = std::less&lt;MyType&gt;;</pre>


<p style="margin-left:11%; margin-top: 1em">It is not
always a safe transformation though. The following case will
be untouched to preserve the semantics.</p>

<pre style="margin-left:15%; margin-top: 1em">// Non&minus;transparent functor
std::map&lt;const char *, std::string, std::greater&lt;std::string&gt;&gt; s;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
SafeMode</b></p>

<p style="margin-left:22%;">If the option is set to
<i>true</i>, the check will not diagnose cases where using a
transparent functor cannot be guaranteed to produce
identical results as the original code. The default value
for this option is <i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This check
requires using C++14 or higher to run.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;uncaught&minus;exceptions</b>
<br>
This check will warn on calls to
<b>std::uncaught_exception</b> and replace them with calls
to <b>std::uncaught_exceptions</b>, since
<b>std::uncaught_exception</b> was deprecated in C++17.</p>

<p style="margin-left:11%; margin-top: 1em">Below are a few
examples of what kind of occurrences will be found and what
they will be replaced with.</p>
<pre style="margin-left:15%; margin-top: 1em">#define MACRO1 std::uncaught_exception
#define MACRO2 std::uncaught_exception

int uncaught_exception() {
  return 0;
}

int main() {
  int res;

  res = uncaught_exception();
  // No warning, since it is not the deprecated function from namespace std

  res = MACRO2();
  // Warning, but will not be replaced

  res = std::uncaught_exception();
  // Warning and replaced

  using std::uncaught_exception;
  // Warning and replaced


  res = uncaught_exception();
  // Warning and replaced
}</pre>


<p style="margin-left:11%; margin-top: 1em">After applying
the fixes the code will look like the following:</p>
<pre style="margin-left:15%; margin-top: 1em">#define MACRO1 std::uncaught_exception
#define MACRO2 std::uncaught_exception

int uncaught_exception() {
  return 0;
}

int main() {
  int res;

  res = uncaught_exception();

  res = MACRO2();

  res = std::uncaught_exceptions();

  using std::uncaught_exceptions;

  res = uncaught_exceptions();
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>modernize&minus;use&minus;using</b>
<br>
The check converts the usage of <b>typedef</b> with
<b>using</b> keyword.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">typedef int variable;

class Class{};
typedef void (Class::* MyPtrType)() const;

typedef struct { int a; } R_t, *R_p;</pre>

<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">using variable = int;

class Class{};
using MyPtrType = void (Class::*)() const;

using R_t = struct { int a; };
using R_p = R_t*;</pre>

<p style="margin-left:11%; margin-top: 1em">This check
requires using C++11 or higher to run.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoreMacros</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>mpi&minus;buffer&minus;deref</b>
<br>
This check verifies if a buffer passed to an MPI (Message
Passing Interface) function is sufficiently dereferenced.
Buffers should be passed as a single pointer or array. As
MPI function signatures specify <b>void *</b> for their
buffer types, insufficiently dereferenced buffers can be
passed, like for example as double pointers or
multidimensional arrays, without a compiler warning
emitted.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// A double pointer is passed to the MPI function.
char *buf;
MPI_Send(&amp;buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);

// A multidimensional array is passed to the MPI function.
short buf[1][1];
MPI_Send(buf, 1, MPI_SHORT, 0, 0, MPI_COMM_WORLD);


// A pointer to an array is passed to the MPI function.
short *buf[1];
MPI_Send(buf, 1, MPI_SHORT, 0, 0, MPI_COMM_WORLD);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>mpi&minus;type&minus;mismatch</b>
<br>
This check verifies if buffer type and MPI (Message Passing
Interface) datatype pairs match for used MPI functions. All
MPI datatypes defined by the MPI standard (3.1) are verified
by this check. User defined typedefs, custom MPI datatypes
and null pointer constants are skipped, in the course of
verification.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em">// In this case, the buffer type matches MPI datatype.
char buf;
MPI_Send(&amp;buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);


// In the following case, the buffer type does not match MPI datatype.
int buf;
MPI_Send(&amp;buf, 1, MPI_CHAR, 0, 0, MPI_COMM_WORLD);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>objc&minus;assert&minus;equals</b>
<br>
Finds improper usages of <i>XCTAssertEqual</i> and
<i>XCTAssertNotEqual</i> and replaces them with
<i>XCTAssertEqualObjects</i> or
<i>XCTAssertNotEqualObjects</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This makes
tests less fragile, as many improperly rely on pointer
equality for strings that have equal values. This assumption
is not guarantted by the language.</p>


<p style="margin-left:11%; margin-top: 1em"><b>objc&minus;avoid&minus;nserror&minus;init</b>
<br>
Finds improper initialization of <b>NSError</b> objects.</p>

<p style="margin-left:11%; margin-top: 1em">According to
Apple developer document, we should always use factory
method <b>errorWithDomain:code:userInfo:</b> to create new
NSError objects instead of <b>[NSError alloc] init]</b>.
Otherwise it will lead to a warning message during
runtime.</p>

<p style="margin-left:11%; margin-top: 1em">The
corresponding information about <b>NSError</b> creation:
<i>https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/CreateCustomizeNSError/CreateCustomizeNSError.html</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>objc&minus;dealloc&minus;in&minus;category</b>
<br>
Finds implementations of <b>&minus;dealloc</b> in
Objective&minus;C categories. The category implementation
will override any <b>&minus;dealloc</b> in the class
implementation, potentially causing issues.</p>

<p style="margin-left:11%; margin-top: 1em">Classes
implement <b>&minus;dealloc</b> to perform important actions
to deallocate an object. If a category on the class
implements <b>&minus;dealloc</b>, it will override the
class's implementation and unexpected deallocation behavior
may occur.</p>


<p style="margin-left:11%; margin-top: 1em"><b>objc&minus;forbidden&minus;subclassing</b>
<br>
Finds Objective&minus;C classes which are subclasses of
classes which are not designed to be subclassed.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
includes a list of Objective&minus;C classes which are
publicly documented as not supporting subclassing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">Instead of using this check,
for code under your control, you should add
<b>__attribute__((objc_subclassing_restricted))</b> before
your <b>@interface</b> declarations to ensure the compiler
prevents others from subclassing your Objective&minus;C
classes. See
<i>https://clang.llvm.org/docs/AttributeReference.html#objc&minus;subclassing&minus;restricted</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
ForbiddenSuperClassNames</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of names of Objective&minus;C classes which do not support
subclassing.</p>

<p style="margin-left:22%; margin-top: 1em">Defaults to
<i>ABNewPersonViewController;ABPeoplePickerNavigationController;ABPersonViewController;ABUnknownPersonViewController;NSHashTable;NSMapTable;NSPointerArray;NSPointerFunctions;NSTimer;UIActionSheet;UIAlertView;UIImagePickerController;UITextInputMode;UIWebView</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>objc&minus;missing&minus;hash</b>
<br>
Finds Objective&minus;C implementations that implement
<b>&minus;isEqual:</b> without also appropriately
implementing <b>&minus;hash</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Apple
documentation highlights that objects that are equal must
have the same hash value:
<i>https://developer.apple.com/documentation/objectivec/1418956&minus;nsobject/1418795&minus;isequal?language=objc</i></p>

<p style="margin-left:11%; margin-top: 1em">Note that the
check only verifies the presence of <b>&minus;hash</b> in
scenarios where its omission could result in unexpected
behavior. The verification of the implementation of
<b>&minus;hash</b> is the responsibility of the developer,
e.g., through the addition of unit tests to verify the
implementation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>objc&minus;nsinvocation&minus;argument&minus;lifetime</b>
<br>
Finds calls to <b>NSInvocation</b> methods under ARC that
don't have proper argument object lifetimes. When passing
Objective&minus;C objects as parameters to the
<b>NSInvocation</b> methods <b>getArgument:atIndex:</b> and
<b>getReturnValue:</b>, the values are copied by value into
the argument pointer, which leads to incorrect releasing
behavior if the object pointers are not declared
<b>__unsafe_unretained</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For code:</p>
<pre style="margin-left:15%; margin-top: 1em">id arg;
[invocation getArgument:&amp;arg atIndex:2];


__strong id returnValue;
[invocation getReturnValue:&amp;returnValue];</pre>


<p style="margin-left:11%; margin-top: 1em">The fix will
be:</p>
<pre style="margin-left:15%; margin-top: 1em">__unsafe_unretained id arg;
[invocation getArgument:&amp;arg atIndex:2];


__unsafe_unretained id returnValue;
[invocation getReturnValue:&amp;returnValue];</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
warn on being passed instance variable references that have
lifetimes other than <b>__unsafe_unretained</b>, but does
not propose a fix:</p>

<pre style="margin-left:15%; margin-top: 1em">// &quot;id _returnValue&quot; is declaration of instance variable of class.
[invocation getReturnValue:&amp;self&minus;&gt;_returnValue];</pre>



<p style="margin-left:11%; margin-top: 1em"><b>objc&minus;property&minus;declaration</b>
<br>
Finds property declarations in Objective&minus;C files that
do not follow the pattern of property names in Apple's
programming guide. The property name should be in the format
of Lower Camel Case.</p>

<p style="margin-left:11%; margin-top: 1em">For code:</p>

<pre style="margin-left:15%; margin-top: 1em">@property(nonatomic, assign) int LowerCamelCase;</pre>


<p style="margin-left:11%; margin-top: 1em">The fix will
be:</p>

<pre style="margin-left:15%; margin-top: 1em">@property(nonatomic, assign) int lowerCamelCase;</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
only fix 'CamelCase' to 'camelCase'. In some other cases we
will only provide warning messages since the property name
could be complicated. Users will need to come up with a
proper name by their own.</p>

<p style="margin-left:11%; margin-top: 1em">This check also
accepts special acronyms as prefixes or suffixes. Such
prefixes or suffixes will suppress the Lower Camel Case
check according to the guide:
<i>https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281&minus;1002931&minus;BBCFHEAB</i></p>

<p style="margin-left:11%; margin-top: 1em">For a full list
of well&minus;known acronyms:
<i>https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285&minus;BCIHCGAE</i></p>

<p style="margin-left:11%; margin-top: 1em">The
corresponding style rule:
<i>https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284&minus;1001757</i></p>

<p style="margin-left:11%; margin-top: 1em">The check will
also accept property declared in category with a prefix of
lowercase letters followed by a '_' to avoid naming
conflict. For example:</p>

<pre style="margin-left:15%; margin-top: 1em">@property(nonatomic, assign) int abc_lowerCamelCase;</pre>


<p style="margin-left:11%; margin-top: 1em">The
corresponding style rule:
<i>https://developer.apple.com/library/content/qa/qa1908/_index.html</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>objc&minus;super&minus;self</b>
<br>
Finds invocations of <b>&minus;self</b> on super instances
in initializers of subclasses of <b>NSObject</b> and
recommends calling a superclass initializer instead.</p>

<p style="margin-left:11%; margin-top: 1em">Invoking
<b>&minus;self</b> on super instances in initializers is a
common programmer error when the programmer's original
intent is to call a superclass initializer. Failing to call
a superclass initializer breaks initializer chaining and can
result in invalid object initialization.</p>


<p style="margin-left:11%; margin-top: 1em"><b>openmp&minus;exception&minus;escape</b>
<br>
Analyzes OpenMP Structured Blocks and checks that no
exception escapes out of the Structured Block it was thrown
in.</p>

<p style="margin-left:11%; margin-top: 1em">As per the
OpenMP specification, a structured block is an executable
statement, possibly compound, with a single entry at the top
and a single exit at the bottom. Which means, <b>throw</b>
may not be used to 'exit' out of the structured block. If an
exception is not caught in the same structured block it was
thrown in, the behavior is undefined.</p>

<p style="margin-left:11%; margin-top: 1em">FIXME: this
check does not model SEH, <b>setjmp</b>/<b>longjmp</b>.</p>

<p style="margin-left:11%; margin-top: 1em">WARNING! This
check may be expensive on large source files.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoredExceptions</b></p>

<p style="margin-left:22%;">Comma&minus;separated list
containing type names which are not counted as thrown
exceptions in the check. Default value is an empty
string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>openmp&minus;use&minus;default&minus;none</b>
<br>
Finds OpenMP directives that are allowed to contain a
<b>default</b> clause, but either don't specify it or the
clause is specified but with the kind other than
<b>none</b>, and suggests to use the <b>default(none)</b>
clause.</p>

<p style="margin-left:11%; margin-top: 1em">Using
<b>default(none)</b> clause forces developers to explicitly
specify data sharing attributes for the variables referenced
in the construct, thus making it obvious which variables are
referenced, and what is their data sharing attribute, thus
increasing readability and possibly making errors easier to
spot.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>

<pre style="margin-left:15%;">// ``for`` directive cannot have ``default`` clause, no diagnostics.
void n0(const int a) {
#pragma omp for
  for (int b = 0; b &lt; a; b++)
    ;
}

// ``parallel`` directive.

// ``parallel`` directive can have ``default`` clause, but said clause is not
// specified, diagnosed.
void p0_0() {
#pragma omp parallel
  ;
  // WARNING: OpenMP directive ``parallel`` does not specify ``default``
  //          clause. Consider specifying ``default(none)`` clause.
}

// ``parallel`` directive can have ``default`` clause, and said clause is
// specified, with ``none`` kind, all good.
void p0_1() {
#pragma omp parallel default(none)
  ;
}

// ``parallel`` directive can have ``default`` clause, and said clause is
// specified, but with ``shared`` kind, which is not ``none``, diagnose.
void p0_2() {
#pragma omp parallel default(shared)
  ;
  // WARNING: OpenMP directive ``parallel`` specifies ``default(shared)``
  //          clause. Consider using ``default(none)`` clause instead.
}


// ``parallel`` directive can have ``default`` clause, and said clause is
// specified, but with ``firstprivate`` kind, which is not ``none``, diagnose.
void p0_3() {
#pragma omp parallel default(firstprivate)
  ;
  // WARNING: OpenMP directive ``parallel`` specifies ``default(firstprivate)``
  //          clause. Consider using ``default(none)`` clause instead.
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;faster&minus;string&minus;find</b>
<br>
Optimize calls to <b>std::string::find()</b> and friends
when the needle passed is a single character string literal.
The character literal overload is more efficient.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">str.find(&quot;A&quot;);

// becomes

str.find('A');</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
StringLikeClasses</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of names of string&minus;like classes. By default only
<b>::std::basic_string</b> and
<b>::std::basic_string_view</b> are considered. The check
will only consider member functions named <b>find</b>,
<b>rfind</b>, <b>find_first_of</b>,
<b>find_first_not_of</b>, <b>find_last_of</b>, or
<b>find_last_not_of</b> within these classes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;for&minus;range&minus;copy</b>
<br>
Finds C++11 for ranges where the loop variable is copied in
each iteration but it would suffice to obtain it by const
reference.</p>

<p style="margin-left:11%; margin-top: 1em">The check is
only applied to loop variables of types that are expensive
to copy which means they are not trivially copyable or have
a non&minus;trivial copy constructor or destructor.</p>

<p style="margin-left:11%; margin-top: 1em">To ensure that
it is safe to replace the copy with a const reference the
following heuristic is employed:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The loop variable is const qualified.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>The loop variable is not const, but only const methods
or operators are invoked on it, or it is used as const
reference or value argument in constructors or function
calls.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
WarnOnAllAutoCopies</b></p>

<p style="margin-left:22%;">When <i>true</i>, warns on any
use of <i>auto</i> as the type of the range&minus;based for
loop variable. Default is <i>false</i>.</p>

<p style="margin-left:11%;"><b>AllowedTypes</b></p>

<p style="margin-left:22%;">A semicolon&minus;separated
list of names of types allowed to be copied in each
iteration. Regular expressions are accepted, e.g.
<i>[Rr]ef(erence)?$</i> matches every type with suffix
<i>Ref</i>, <i>ref</i>, <i>Reference</i> and
<i>reference</i>. The default is empty. If a name in the
list contains the sequence <i>::</i> it is matched against
the qualified typename (i.e. <i>namespace::Type</i>,
otherwise it is matched against only the type name (i.e.
<i>Type</i>).</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;implicit&minus;cast&minus;in&minus;loop</b>
<br>
This check has been renamed to
<i>performance&minus;implicit&minus;conversion&minus;in&minus;loop</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;implicit&minus;conversion&minus;in&minus;loop</b>
<br>
This warning appears in a range&minus;based loop with a loop
variable of const ref type where the type of the variable
does not match the one returned by the iterator. This means
that an implicit conversion happens, which can for example
result in expensive deep copies.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">map&lt;int, vector&lt;string&gt;&gt; my_map;
for (const pair&lt;int, vector&lt;string&gt;&gt;&amp; p : my_map) {}
// The iterator type is in fact pair&lt;const int, vector&lt;string&gt;&gt;, which means
// that the compiler added a conversion, resulting in a copy of the vectors.</pre>


<p style="margin-left:11%; margin-top: 1em">The easiest
solution is usually to use <b>const auto&amp;</b> instead of
writing the type manually.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;inefficient&minus;algorithm</b>
<br>
Warns on inefficient use of STL algorithms on associative
containers.</p>

<p style="margin-left:11%; margin-top: 1em">Associative
containers implement some of the algorithms as methods which
should be preferred to the algorithms in the algorithm
header. The methods can take advantage of the order of the
elements.</p>
<pre style="margin-left:15%; margin-top: 1em">std::set&lt;int&gt; s;
auto it = std::find(s.begin(), s.end(), 43);

// becomes

auto it = s.find(43);
std::set&lt;int&gt; s;
auto c = std::count(s.begin(), s.end(), 43);

// becomes

auto c = s.count(43);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;inefficient&minus;string&minus;concatenation</b>
<br>
This check warns about the performance overhead arising from
concatenating strings using the <b>operator+</b>, for
instance:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string a(&quot;Foo&quot;), b(&quot;Bar&quot;);
a = a + b;</pre>


<p style="margin-left:11%; margin-top: 1em">Instead of this
structure you should use <b>operator+=</b> or
<b>std::string</b>'s (<b>std::basic_string</b>) class member
function <b>append()</b>. For instance:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string a(&quot;Foo&quot;), b(&quot;Baz&quot;);
for (int i = 0; i &lt; 20000; ++i) {
    a = a + &quot;Bar&quot; + b;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Could be
rewritten in a greatly more efficient way like:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string a(&quot;Foo&quot;), b(&quot;Baz&quot;);
for (int i = 0; i &lt; 20000; ++i) {
    a.append(&quot;Bar&quot;).append(b);
}</pre>


<p style="margin-left:11%; margin-top: 1em">And this can be
rewritten too:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(const std::string&amp;) {}
std::string a(&quot;Foo&quot;), b(&quot;Baz&quot;);
void g() {
    f(a + &quot;Bar&quot; + b);
}</pre>


<p style="margin-left:11%; margin-top: 1em">In a slightly
more efficient way like:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(const std::string&amp;) {}
std::string a(&quot;Foo&quot;), b(&quot;Baz&quot;);
void g() {
    f(std::string(a).append(&quot;Bar&quot;).append(b));
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
StrictMode</b></p>

<p style="margin-left:22%;">When <i>false</i>, the check
will only check the string usage in <b>while</b>, <b>for</b>
and <b>for&minus;range</b> statements. Default is
<i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;inefficient&minus;vector&minus;operation</b>
<br>
Finds possible inefficient <b>std::vector</b> operations
(e.g. <b>push_back</b>, <b>emplace_back</b>) that may cause
unnecessary memory reallocations.</p>

<p style="margin-left:11%; margin-top: 1em">It can also
find calls that add element to protobuf repeated field in a
loop without calling Reserve() before the loop. Calling
Reserve() first can avoid unnecessary memory
reallocations.</p>

<p style="margin-left:11%; margin-top: 1em">Currently, the
check only detects following kinds of loops with a single
statement body:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="57%">


<p>Counter&minus;based for loops start with 0:</p></td>
<td width="29%">
</td></tr>
</table>
<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;int&gt; v;
for (int i = 0; i &lt; n; ++i) {
  v.push_back(n);
  // This will trigger the warning since the push_back may cause multiple
  // memory reallocations in v. This can be avoid by inserting a 'reserve(n)'
  // statement before the for statement.
}


SomeProto p;
for (int i = 0; i &lt; n; ++i) {
  p.add_xxx(n);
  // This will trigger the warning since the add_xxx may cause multiple memory
  // reallocations. This can be avoid by inserting a
  // 'p.mutable_xxx().Reserve(n)' statement before the for statement.
}</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">For&minus;range loops like
<b>for (range&minus;declaration : range_expression)</b>, the
type of <b>range_expression</b> can be <b>std::vector</b>,
<b>std::array</b>, <b>std::deque</b>, <b>std::set</b>,
<b>std::unordered_set</b>, <b>std::map</b>,
<b>std::unordered_set</b>:</p> </td></tr>
</table>
<pre style="margin-left:15%; margin-top: 1em">std::vector&lt;int&gt; data;
std::vector&lt;int&gt; v;


for (auto element : data) {
  v.push_back(element);
  // This will trigger the warning since the 'push_back' may cause multiple
  // memory reallocations in v. This can be avoid by inserting a
  // 'reserve(data.size())' statement before the for statement.
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
VectorLikeClasses</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of names of vector&minus;like classes. By default only
<b>::std::vector</b> is considered.</p>

<p style="margin-left:11%;"><b>EnableProto</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will also warn on inefficient operations for proto repeated
fields. Otherwise, the check only warns on inefficient
vector operations. Default is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;move&minus;const&minus;arg</b>
<br>
The check warns</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>if <b>std::move()</b> is called with a constant
argument,</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>if <b>std::move()</b> is called with an argument of a
trivially&minus;copyable type,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>if the result of <b>std::move()</b> is passed as a const
reference argument.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In all three
cases, the check will suggest a fix that removes the
<b>std::move()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Here are
examples of each of the three cases:</p>
<pre style="margin-left:15%; margin-top: 1em">const string s;
return std::move(s);  // Warning: std::move of the const variable has no effect

int x;
return std::move(x);  // Warning: std::move of the variable of a trivially&minus;copyable type has no effect


void f(const string &amp;s);
string s;
f(std::move(s));  // Warning: passing result of std::move as a const reference argument; no move will actually happen</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
CheckTriviallyCopyableMove</b></p>

<p style="margin-left:22%;">If <i>true</i>, enables
detection of trivially copyable types that do not have a
move constructor. Default is <i>true</i>.</p>

<p style="margin-left:11%;"><b>CheckMoveToConstRef</b></p>

<p style="margin-left:22%;">If <i>true</i>, enables
detection of <i>std::move()</i> passed as a const reference
argument. Default is <i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;move&minus;constructor&minus;init</b>
<br>
&quot;cert&minus;oop11&minus;cpp&quot; redirects here as an
alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">The check flags
user&minus;defined move constructors that have a
ctor&minus;initializer initializing a member or base class
through a copy constructor instead of a move
constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;no&minus;automatic&minus;move</b>
<br>
Finds local variables that cannot be automatically moved due
to constness.</p>

<p style="margin-left:11%; margin-top: 1em">Under
<i>certain conditions</i>, local values are automatically
moved out when returning from a function. A common mistake
is to declare local <b>lvalue</b> variables <b>const</b>,
which prevents the move.</p>

<p style="margin-left:11%; margin-top: 1em">Example
<i>[1]</i>:</p>
<pre style="margin-left:15%; margin-top: 1em">StatusOr&lt;std::vector&lt;int&gt;&gt; Cool() {
  std::vector&lt;int&gt; obj = ...;
  return obj;  // calls StatusOr::StatusOr(std::vector&lt;int&gt;&amp;&amp;)
}


StatusOr&lt;std::vector&lt;int&gt;&gt; NotCool() {
  const std::vector&lt;int&gt; obj = ...;
  return obj;  // calls `StatusOr::StatusOr(const std::vector&lt;int&gt;&amp;)`
}</pre>


<p style="margin-left:11%; margin-top: 1em">The former
version (<b>Cool</b>) should be preferred over the latter
(<b>Uncool</b>) as it will avoid allocations and potentially
large memory copies.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Semantics</b>
<br>
In the example above, <b>StatusOr::StatusOr(T&amp;&amp;)</b>
have the same semantics as long as the copy and move
constructors for <b>T</b> have the same semantics. Note that
there is no guarantee that <b>S::S(T&amp;&amp;)</b> and
<b>S::S(const T&amp;)</b> have the same semantics for any
single <b>S</b>, so we're not providing automated fixes for
this check, and judgement should be exerted when making the
suggested changes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;Wreturn&minus;std&minus;move</b>
<br>
Another case where the move cannot happen is the
following:</p>

<pre style="margin-left:15%; margin-top: 1em">StatusOr&lt;std::vector&lt;int&gt;&gt; Uncool() {
  std::vector&lt;int&gt;&amp;&amp; obj = ...;
  return obj;  // calls `StatusOr::StatusOr(const std::vector&lt;int&gt;&amp;)`
}</pre>


<p style="margin-left:11%; margin-top: 1em">In that case
the fix is more consensual: just <i>return
std::move(obj)</i>. This is handled by the
<i>&minus;Wreturn&minus;std&minus;move</i> warning.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;no&minus;int&minus;to&minus;ptr</b>
<br>
Diagnoses every integer to pointer cast.</p>

<p style="margin-left:11%; margin-top: 1em">While casting
an (integral) pointer to an integer is obvious &minus; you
just get the integral value of the pointer, casting an
integer to an (integral) pointer is deceivingly different.
While you will get a pointer with that integral value, if
you got that integral value via a
pointer&minus;to&minus;integer cast originally, the new
pointer will lack the provenance information from the
original pointer.</p>

<p style="margin-left:11%; margin-top: 1em">So while
(integral) pointer to integer casts are effectively
no&minus;ops, and are transparent to the optimizer, integer
to (integral) pointer casts are <i>NOT</i> transparent, and
may conceal information from optimizer.</p>

<p style="margin-left:11%; margin-top: 1em">While that may
be the intention, it is not always so. For example, let's
take a look at a routine to align the pointer up to the
multiple of 16: The obvious, naive implementation for that
is:</p>

<pre style="margin-left:15%; margin-top: 1em">char* src(char* maybe_underbiased_ptr) {
  uintptr_t maybe_underbiased_intptr = (uintptr_t)maybe_underbiased_ptr;
  uintptr_t aligned_biased_intptr = maybe_underbiased_intptr + 15;
  uintptr_t aligned_intptr = aligned_biased_intptr &amp; (~15);
  return (char*)aligned_intptr; // warning: avoid integer to pointer casts [performance&minus;no&minus;int&minus;to&minus;ptr]
}</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
rightfully diagnose that cast.</p>

<p style="margin-left:11%; margin-top: 1em">But when
provenance concealment is not the goal of the code, but an
accident, this example can be rewritten as follows, without
using integer to pointer cast:</p>

<pre style="margin-left:15%; margin-top: 1em">char*
tgt(char* maybe_underbiased_ptr) {
    uintptr_t maybe_underbiased_intptr = (uintptr_t)maybe_underbiased_ptr;
    uintptr_t aligned_biased_intptr = maybe_underbiased_intptr + 15;
    uintptr_t aligned_intptr = aligned_biased_intptr &amp; (~15);
    uintptr_t bias = aligned_intptr &minus; maybe_underbiased_intptr;
    return maybe_underbiased_ptr + bias;
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;noexcept&minus;move&minus;constructor</b>
<br>
The check flags user&minus;defined move constructors and
assignment operators not marked with <b>noexcept</b> or
marked with <b>noexcept(expr)</b> where <b>expr</b>
evaluates to <b>false</b> (but is not a <b>false</b> literal
itself).</p>

<p style="margin-left:11%; margin-top: 1em">Move
constructors of all the types used with STL containers, for
example, need to be declared <b>noexcept</b>. Otherwise STL
will choose copy constructors instead. The same is valid for
move assignment operations.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;trivially&minus;destructible</b>
<br>
Finds types that could be made trivially&minus;destructible
by removing out&minus;of&minus;line defaulted destructor
declarations.</p>

<pre style="margin-left:15%; margin-top: 1em">struct A: TrivialType {
  ~A(); // Makes A non&minus;trivially&minus;destructible.
  TrivialType trivial_fields;
};
A::~A() = default;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;type&minus;promotion&minus;in&minus;math&minus;fn</b>
<br>
Finds calls to C math library functions (from <b>math.h</b>
or, in C++, <b>cmath</b>) with implicit <b>float</b> to
<b>double</b> promotions.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
warns on <b>::sin(0.f)</b>, because this function's
parameter is a double. You probably meant to call
<b>std::sin(0.f)</b> (in C++), or <b>sinf(0.f)</b> (in
C).</p>
<pre style="margin-left:15%; margin-top: 1em">float a;
asin(a);

// becomes

float a;
std::asin(a);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;unnecessary&minus;copy&minus;initialization</b>
<br>
Finds local variable declarations that are initialized using
the copy constructor of a non&minus;trivially&minus;copyable
type but it would suffice to obtain a const reference.</p>

<p style="margin-left:11%; margin-top: 1em">The check is
only applied if it is safe to replace the copy by a const
reference. This is the case when the variable is const
qualified or when it is only used as a const, i.e. only
const methods or operators are invoked on it, or it is used
as const reference or value argument in constructors or
function calls.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em">const string&amp; constReference();
void Function() {
  // The warning will suggest making this a const reference.
  const string UnnecessaryCopy = constReference();
}

struct Foo {
  const string&amp; name() const;
};
void Function(const Foo&amp; foo) {
  // The warning will suggest making this a const reference.
  string UnnecessaryCopy1 = foo.name();
  UnnecessaryCopy1.find(&quot;bar&quot;);


  // The warning will suggest making this a const reference.
  string UnnecessaryCopy2 = UnnecessaryCopy1;
  UnnecessaryCopy2.find(&quot;bar&quot;);
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
AllowedTypes</b></p>

<p style="margin-left:22%;">A semicolon&minus;separated
list of names of types allowed to be initialized by copying.
Regular expressions are accepted, e.g.
<i>[Rr]ef(erence)?$</i> matches every type with suffix
<i>Ref</i>, <i>ref</i>, <i>Reference</i> and
<i>reference</i>. The default is empty. If a name in the
list contains the sequence <i>::</i> it is matched against
the qualified typename (i.e. <i>namespace::Type</i>,
otherwise it is matched against only the type name (i.e.
<i>Type</i>).</p>


<p style="margin-left:11%;"><b>ExcludedContainerTypes</b></p>

<p style="margin-left:22%;">A semicolon&minus;separated
list of names of types whose methods are allowed to return
the const reference the variable is copied from. When an
expensive to copy variable is copy initialized by the return
value from a type on this list the check does not trigger.
This can be used to exclude types known to be const
incorrect or where the lifetime or immutability of returned
references is not tied to mutations of the container. An
example are view types that don't own the underlying data.
Like for <i>AllowedTypes</i> above, regular expressions are
accepted and the inclusion of <i>::</i> determines whether
the qualified typename is matched or not.</p>


<p style="margin-left:11%; margin-top: 1em"><b>performance&minus;unnecessary&minus;value&minus;param</b>
<br>
Flags value parameter declarations of expensive to copy
types that are copied for each invocation but it would
suffice to pass them by const reference.</p>

<p style="margin-left:11%; margin-top: 1em">The check is
only applied to parameters of types that are expensive to
copy which means they are not trivially copyable or have a
non&minus;trivial copy constructor or destructor.</p>

<p style="margin-left:11%; margin-top: 1em">To ensure that
it is safe to replace the value parameter with a const
reference the following heuristic is employed:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>the parameter is const qualified;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>the parameter is not const, but only const methods or
operators are invoked on it, or it is used as const
reference or value argument in constructors or function
calls.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em">void f(const string Value) {
  // The warning will suggest making Value a reference.
}


void g(ExpensiveToCopy Value) {
  // The warning will suggest making Value a const reference.
  Value.ConstMethd();
  ExpensiveToCopy Copy(Value);
}</pre>


<p style="margin-left:11%; margin-top: 1em">If the
parameter is not const, only copied or assigned once and has
a non&minus;trivial move&minus;constructor or
move&minus;assignment operator respectively the check will
suggest to move it.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">void setValue(string Value) {
  Field = Value;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Will
become:</p>
<pre style="margin-left:15%; margin-top: 1em">#include &lt;utility&gt;


void setValue(string Value) {
  Field = std::move(Value);
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IncludeStyle</b></p>

<p style="margin-left:22%;">A string specifying which
include&minus;style is used, <i>llvm</i> or <i>google</i>.
Default is <i>llvm</i>.</p>

<p style="margin-left:11%;"><b>AllowedTypes</b></p>

<p style="margin-left:22%;">A semicolon&minus;separated
list of names of types allowed to be passed by value.
Regular expressions are accepted, e.g.
<i>[Rr]ef(erence)?$</i> matches every type with suffix
<i>Ref</i>, <i>ref</i>, <i>Reference</i> and
<i>reference</i>. The default is empty. If a name in the
list contains the sequence <i>::</i> it is matched against
the qualified typename (i.e. <i>namespace::Type</i>,
otherwise it is matched against only the type name (i.e.
<i>Type</i>).</p>


<p style="margin-left:11%; margin-top: 1em"><b>portability&minus;restrict&minus;system&minus;includes</b>
<br>
Checks to selectively allow or disallow a configurable list
of system headers.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<p style="margin-left:11%; margin-top: 1em">In order to
<b>only</b> allow <i>zlib.h</i> from the system you would
set the options to <i>&minus;*,zlib.h</i>.</p>

<pre style="margin-left:15%; margin-top: 1em">#include &lt;curses.h&gt;       // Bad: disallowed system header.
#include &lt;openssl/ssl.h&gt;  // Bad: disallowed system header.
#include &lt;zlib.h&gt;         // Good: allowed system header.
#include &quot;src/myfile.h&quot;   // Good: non&minus;system header always allowed.</pre>


<p style="margin-left:11%; margin-top: 1em">In order to
allow everything <b>except</b> <i>zlib.h</i> from the system
you would set the options to <i>*,&minus;zlib.h</i>.</p>

<pre style="margin-left:15%; margin-top: 1em">#include &lt;curses.h&gt;       // Good: allowed system header.
#include &lt;openssl/ssl.h&gt;  // Good: allowed system header.
#include &lt;zlib.h&gt;         // Bad: disallowed system header.
#include &quot;src/myfile.h&quot;   // Good: non&minus;system header always allowed.</pre>


<p style="margin-left:11%; margin-top: 1em">Since the
options support globbing you can use wildcarding to allow
groups of headers.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&minus;*,openssl/*.h</i>
will allow all openssl headers but disallow any others.</p>

<pre style="margin-left:15%; margin-top: 1em">#include &lt;curses.h&gt;       // Bad: disallowed system header.
#include &lt;openssl/ssl.h&gt;  // Good: allowed system header.
#include &lt;openssl/rsa.h&gt;  // Good: allowed system header.
#include &lt;zlib.h&gt;         // Bad: disallowed system header.
#include &quot;src/myfile.h&quot;   // Good: non&minus;system header always allowed.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
Includes</b></p>

<p style="margin-left:22%;">A string containing a comma
separated glob list of allowed include filenames. Similar to
the &minus;checks glob list for running clang&minus;tidy
itself, the two wildcard characters are <i>*</i> and
<i>&minus;</i>, to include and exclude globs, respectively.
The default is <i>*</i>, which allows all includes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>portability&minus;simd&minus;intrinsics</b>
<br>
Finds SIMD intrinsics calls and suggests
<b>std::experimental::simd</b> (- <i>P0214</i>)
alternatives.</p>

<p style="margin-left:11%; margin-top: 1em">If the option
<i>Suggest</i> is set to <i>true</i>, for</p>

<pre style="margin-left:15%; margin-top: 1em">_mm_add_epi32(a, b); // x86
vec_add(a, b);       // Power</pre>


<p style="margin-left:11%; margin-top: 1em">the check
suggests an alternative: <b>operator+</b> on
<b>std::experimental::simd</b> objects.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, it
just complains the intrinsics are non&minus;portable (and
there are <i>P0214</i> alternatives).</p>

<p style="margin-left:11%; margin-top: 1em">Many
architectures provide SIMD operations (e.g. x86 SSE/AVX,
Power AltiVec/VSX, ARM NEON). It is common that SIMD code
implementing the same algorithm, is written in multiple
target&minus;dispatching pieces to optimize for different
architectures or micro&minus;architectures.</p>

<p style="margin-left:11%; margin-top: 1em">The C++
standard proposal <i>P0214</i> and its extensions cover many
common SIMD operations. By migrating from
target&minus;dependent intrinsics to <i>P0214</i>
operations, the SIMD code can be simplified and pieces for
different targets can be unified.</p>

<p style="margin-left:11%; margin-top: 1em">Refer to
<i>P0214</i> for introduction and motivation for the
data&minus;parallel standard library.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
Suggest</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i> (default is <i>false</i>), the check will
suggest <i>P0214</i> alternatives, otherwise it only points
out the intrinsic function is non&minus;portable.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>Std</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>The namespace used to suggest <i>P0214</i> alternatives.
If not specified, <i>std::</i> for <i>&minus;std=c++20</i>
and <i>std::experimental::</i> for
<i>&minus;std=c++11</i>.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>portability&minus;std&minus;allocator&minus;const</b>
<br>
Report use of <b>std::vector&lt;const T&gt;</b> (and similar
containers of const elements). These are not allowed in
standard C++, and should usually be
<b>std::vector&lt;T&gt;</b> instead.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Per C++
<b>[allocator.requirements.general]</b>: &quot;T is any
cv&minus;unqualified object type&quot;,
<b>std::allocator&lt;const T&gt;</b> is undefined. Many
standard containers use <b>std::allocator</b> by default and
therefore their <b>const T</b> instantiations are
undefined.</p>

<p style="margin-left:11%; margin-top: 1em">libc++ defines
<b>std::allocator&lt;const T&gt;</b> as an extension which
will be removed in the future.</p>

<p style="margin-left:11%; margin-top: 1em">libstdc++ and
MSVC do not support <b>std::allocator&lt;const
T&gt;</b>:</p>
<pre style="margin-left:15%; margin-top: 1em">// libstdc++ has a better diagnostic since https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48101
std::deque&lt;const int&gt; deque; // error: static assertion failed: std::deque must have a non&minus;const, non&minus;volatile value_type
std::set&lt;const int&gt; set; // error: static assertion failed: std::set must have a non&minus;const, non&minus;volatile value_type
std::vector&lt;int* const&gt; vector; // error: static assertion failed: std::vector must have a non&minus;const, non&minus;volatile value_type


// MSVC
// error C2338: static_assert failed: 'The C++ Standard forbids containers of const elements because allocator&lt;const T&gt; is ill&minus;formed.'</pre>


<p style="margin-left:11%; margin-top: 1em">Code bases only
compiled with libc++ may accrue such undefined usage. This
check finds such code and prevents backsliding while
clean&minus;up is ongoing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;avoid&minus;const&minus;params&minus;in&minus;decls</b>
<br>
Checks whether a function declaration has parameters that
are top level <b>const</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>const</b>
values in declarations do not affect the signature of a
function, so they should not be put there.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(const string);   // Bad: const is top level.
void f(const string&amp;);  // Good: const is not top level.</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;braces&minus;around&minus;statements</b>
<i><br>

google&minus;readability&minus;braces&minus;around&minus;statements</i>
redirects here as an alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Checks that
bodies of <b>if</b> statements and loops (<b>for</b>, <b>do
while</b>, and <b>while</b>) are inside braces.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">if (condition)
  statement;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">if (condition) {
  statement;
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
ShortStatementLines</b></p>

<p style="margin-left:22%;">Defines the minimal number of
lines that the statement should have in order to trigger
this check.</p>

<p style="margin-left:22%; margin-top: 1em">The number of
lines is counted from the end of condition or initial
keyword (<b>do</b>/<b>else</b>) until the last line of the
inner statement. Default value <i>0</i> means that braces
will be added to all statements (not having them
already).</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;const&minus;return&minus;type</b>
<br>
Checks for functions with a <b>const</b>&minus;qualified
return type and recommends removal of the <b>const</b>
keyword. Such use of <i>const</i> is usually superfluous,
and can prevent valuable compiler optimizations. Does not
(yet) fix trailing return types.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">const int foo();
const Clazz foo();
Clazz *const foo();</pre>


<p style="margin-left:11%; margin-top: 1em">Note that this
applies strictly to top&minus;level qualification, which
excludes pointers or references to const values. For
example, these are fine:</p>

<pre style="margin-left:15%; margin-top: 1em">const int* foo();
const int&amp; foo();
const Clazz* foo();</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;container&minus;contains</b>
<br>
Finds usages of <b>container.count()</b> and
<b>container.find() == container.end()</b> which should be
replaced by a call to the <b>container.contains()</b> method
introduced in C++ 20.</p>

<p style="margin-left:11%; margin-top: 1em">Whether an
element is contained inside a container should be checked
with <b>contains</b> instead of <b>count</b>/<b>find</b>
because <b>contains</b> conveys the intent more clearly.
Furthermore, for containers which permit multiple entries
per key (<b>multimap</b>, <b>multiset</b>, ...),
<b>contains</b> is more efficient than <b>count</b> because
<b>count</b> has to do unnecessary additional work.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-30332503.png" alt="Image grohtml-30332503.png"></p>

<p style="margin-left:11%;">This check applies to
<b>std::set</b>, <b>std::unordered_set</b>, <b>std::map</b>,
<b>std::unordered_map</b> and the corresponding
multi&minus;key variants. It is only active for C++20 and
later, as the <b>contains</b> method was only added in
C++20.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;container&minus;data&minus;pointer</b>
<br>
Finds cases where code could use <b>data()</b> rather than
the address of the element at index 0 in a container. This
pattern is commonly used to materialize a pointer to the
backing data of a container. <b>std::vector</b> and
<b>std::string</b> provide a <b>data()</b> accessor to
retrieve the data pointer which should be preferred.</p>

<p style="margin-left:11%; margin-top: 1em">This also
ensures that in the case that the container is empty, the
data pointer access does not perform an errant memory
access.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;container&minus;size&minus;empty</b>
<br>
Checks whether a call to the <b>size()</b> method can be
replaced with a call to <b>empty()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The emptiness
of a container should be checked using the <b>empty()</b>
method instead of the <b>size()</b> method. It is not
guaranteed that <b>size()</b> is a constant&minus;time
function, and it is generally more efficient and also shows
clearer intent to use <b>empty()</b>. Furthermore some
containers may implement the <b>empty()</b> method but not
implement the <b>size()</b> method. Using <b>empty()</b>
whenever possible makes it easier to switch to another
container in the future.</p>

<p style="margin-left:11%; margin-top: 1em">The check
issues warning if a container has <b>size()</b> and
<b>empty()</b> methods matching following signatures:</p>

<pre style="margin-left:15%; margin-top: 1em">size_type size() const;
bool empty() const;</pre>



<p style="margin-left:11%; margin-top: 1em"><i>size_type</i>
can be any kind of integer type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;convert&minus;member&minus;functions&minus;to&minus;static</b>
<br>
Finds non&minus;static member functions that can be made
<b>static</b> because the functions don't use
<b>this</b>.</p>

<p style="margin-left:11%; margin-top: 1em">After applying
modifications as suggested by the check, running the check
again might find more opportunities to mark member functions
<b>static</b>.</p>

<p style="margin-left:11%; margin-top: 1em">After making a
member function <b>static</b>, you might want to run the
check
<i>readability&minus;static&minus;accessed&minus;through&minus;instance</i>
to replace calls like <b>Instance.method()</b> by
<b>Class::method()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;delete&minus;null&minus;pointer</b>
<br>
Checks the <b>if</b> statements where a pointer's existence
is checked and then deletes the pointer. The check is
unnecessary as deleting a null pointer has no effect.</p>

<pre style="margin-left:15%; margin-top: 1em">int *p;
if (p)
  delete p;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;duplicate&minus;include</b>
<br>
Looks for duplicate includes and removes them. The check
maintains a list of included files and looks for duplicates.
If a macro is defined or undefined then the list of included
files is cleared.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>

<pre style="margin-left:15%; margin-top: 1em">#include &lt;memory&gt;
#include &lt;vector&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">Because of the
intervening macro definitions, this code remains
unchanged:</p>
<pre style="margin-left:15%; margin-top: 1em">#undef NDEBUG
#include &quot;assertion.h&quot;
// ...code with assertions enabled


#define NDEBUG
#include &quot;assertion.h&quot;
// ...code with assertions disabled</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;else&minus;after&minus;return</b>
<i><br>
LLVM Coding Standards</i> advises to reduce indentation
where possible and where it makes understanding code easier.
Early exit is one of the suggested enforcements of that.
Please do not use <b>else</b> or <b>else if</b> after
something that interrupts control flow &minus; like
<b>return</b>, <b>break</b>, <b>continue</b>,
<b>throw</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
piece of code illustrates how the check works. This piece of
code:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(int Value) {
  int Local = 0;
  for (int i = 0; i &lt; 42; i++) {
    if (Value == 1) {
      return;
    } else {
      Local++;
    }

    if (Value == 2)
      continue;
    else
      Local++;


    if (Value == 3) {
      throw 42;
    } else {
      Local++;
    }
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">Would be
transformed into:</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(int Value) {
  int Local = 0;
  for (int i = 0; i &lt; 42; i++) {
    if (Value == 1) {
      return;
    }
    Local++;

    if (Value == 2)
      continue;
    Local++;


    if (Value == 3) {
      throw 42;
    }
    Local++;
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
WarnOnUnfixable</b></p>

<p style="margin-left:22%;">When <i>true</i>, emit a
warning for cases where the check can't output a
Fix&minus;It. These can occur with declarations inside the
<b>else</b> branch that would have an extended lifetime if
the <b>else</b> branch was removed. Default value is
<i>true</i>.</p>


<p style="margin-left:11%;"><b>WarnOnConditionVariables</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will attempt to refactor a variable defined inside the
condition of the <b>if</b> statement that is used in the
<b>else</b> branch defining them just before the <b>if</b>
statement. This can only be done if the <b>if</b> statement
is the last statement in its parent's scope. Default value
is <i>true</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LLVM
alias</b> <br>
There is an alias of this check called
llvm&minus;else&minus;after&minus;return. In that version
the options <i>WarnOnUnfixable</i> and
<i>WarnOnConditionVariables</i> are both set to <i>false</i>
by default.</p>

<p style="margin-left:11%; margin-top: 1em">This check
helps to enforce this <i>LLVM Coding Standards
recommendation</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;function&minus;cognitive&minus;complexity</b>
<br>
Checks function Cognitive Complexity metric.</p>

<p style="margin-left:11%; margin-top: 1em">The metric is
implemented as per the <i>COGNITIVE COMPLEXITY by
SonarSource</i> specification version 1.2 (19 April
2017).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
Threshold</b></p>

<p style="margin-left:22%;">Flag functions with Cognitive
Complexity exceeding this number. The default is
<i>25</i>.</p>


<p style="margin-left:11%;"><b>DescribeBasicIncrements</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, then for
each function exceeding the complexity threshold the check
will issue additional diagnostics on every piece of code
(loop, <i>if</i> statement, etc.) which contributes to that
complexity. See also the examples below. Default is
<i>true</i>.</p>

<p style="margin-left:11%;"><b>IgnoreMacros</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will ignore code inside macros. Note, that also any
macro arguments are ignored, even if they should count to
the complexity. As this might change in the future, this
option isn't guaranteed to be forward&minus;compatible.
Default is <i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Building
blocks</b> <br>
There are three basic building blocks of a Cognitive
Complexity metric:</p>


<p style="margin-left:11%; margin-top: 1em"><b>Increment</b>
<br>
The following structures increase the function's Cognitive
Complexity metric (by <i>1</i>):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p>Conditional operators:</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%"></td>
<td width="2%"></td>
<td width="29%">


<p style="margin-top: 1em"><b>if()</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b>else if()</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b>else</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b>cond ? true : false</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%"></td>
<td width="49%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>switch()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p style="margin-top: 1em">Loops:</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%"></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><b>for()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p>C++11 range&minus;based <b>for()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p><b>while()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p><b>do while()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%"></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><b>catch
()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em"><b>goto LABEL</b>, <b>goto
*(&amp;&amp;LABEL))</b>,</p> </td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="58%">


<p>sequences of binary logical operators:</p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="2%"></td>
<td width="2%"></td>
<td width="30%">


<p style="margin-top: 1em"><b>boolean1 || boolean2</b></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="18%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="30%">


<p><b>boolean1 &amp;&amp; boolean2</b></p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Nesting
level</b> <br>
While by itself the nesting level does not change the
function's Cognitive Complexity metric, it is tracked, and
is used by the next, third building block. The following
structures increase the nesting level (by <i>1</i>):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p style="margin-top: 1em">Conditional operators:</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%"></td>
<td width="2%"></td>
<td width="29%">


<p style="margin-top: 1em"><b>if()</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b>else if()</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b>else</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b>cond ? true : false</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%"></td>
<td width="49%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>switch()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p style="margin-top: 1em">Loops:</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%"></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><b>for()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p>C++11 range&minus;based <b>for()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p><b>while()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p><b>do while()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%"></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><b>catch
()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="26%">


<p style="margin-top: 1em">Nested functions:</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%"></td>
<td width="2%"></td>
<td width="20%">


<p style="margin-top: 1em">C++11 Lambda</p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p>Nested <b>class</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p>Nested <b>struct</b></p></td>
<td width="58%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="20%"></td>
<td width="58%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">GNU statement
expression</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em">Apple Block Declaration</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Nesting
increment</b> <br>
This is where the previous basic building block, <i>Nesting
level</i>, matters. The following structures increase the
function's Cognitive Complexity metric by the current
<i>Nesting level</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="34%">


<p style="margin-top: 1em">Conditional operators:</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%"></td>
<td width="2%"></td>
<td width="29%">


<p style="margin-top: 1em"><b>if()</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%">


<p><b>cond ? true : false</b></p></td>
<td width="49%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="29%"></td>
<td width="49%">
</td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>switch()</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p style="margin-top: 1em">Loops:</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%"></td>
<td width="2%"></td>
<td width="35%">


<p style="margin-top: 1em"><b>for()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p>C++11 range&minus;based <b>for()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p><b>while()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%">


<p><b>do while()</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="35%"></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em"><b>catch
()</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Examples</b>
<br>
The simplest case. This function has Cognitive Complexity of
<i>0</i>.</p>

<pre style="margin-left:15%; margin-top: 1em">void function0() {}</pre>


<p style="margin-left:11%; margin-top: 1em">Slightly better
example. This function has Cognitive Complexity of
<i>1</i>.</p>

<pre style="margin-left:15%; margin-top: 1em">int function1(bool var) {
  if(var) // +1, nesting level +1
    return 42;
  return 0;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Full example.
This function has Cognitive Complexity of <i>3</i>.</p>
<pre style="margin-left:15%; margin-top: 1em">int function3(bool var1, bool var2) {
  if(var1) { // +1, nesting level +1
    if(var2)  // +2 (1 + current nesting level of 1), nesting level +1
      return 42;
  }

  return 0;
}</pre>

<p style="margin-left:11%; margin-top: 1em">In the last
example, the check will flag <i>function3</i> if the option
Threshold is set to <i>2</i> or smaller. If the option
DescribeBasicIncrements is set to <i>true</i>, it will
additionally flag the two <i>if</i> statements with the
amounts by which they increase to the complexity of the
function and the current nesting level.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Limitations
<br>
The metric is implemented with two notable
exceptions:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><i>preprocessor conditionals</i> (<b>#ifdef</b>,
<b>#if</b>, <b>#elif</b>, <b>#else</b>, <b>#endif</b>) are
not accounted for.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><i>each method in a recursion cycle</i> is not accounted
for. It can't be fully implemented, because
cross&minus;translational&minus;unit analysis would be
needed, which is currently not possible in
clang&minus;tidy.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;function&minus;size</b>
<i><br>
google&minus;readability&minus;function&minus;size</i>
redirects here as an alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Checks for
large functions based on various metrics.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
LineThreshold</b></p>

<p style="margin-left:22%;">Flag functions exceeding this
number of lines. The default is <i>&minus;1</i> (ignore the
number of lines).</p>

<p style="margin-left:11%;"><b>StatementThreshold</b></p>

<p style="margin-left:22%;">Flag functions exceeding this
number of statements. This may differ significantly from the
number of lines for macro&minus;heavy code. The default is
<i>800</i>.</p>

<p style="margin-left:11%;"><b>BranchThreshold</b></p>

<p style="margin-left:22%;">Flag functions exceeding this
number of control statements. The default is <i>&minus;1</i>
(ignore the number of branches).</p>

<p style="margin-left:11%;"><b>ParameterThreshold</b></p>

<p style="margin-left:22%;">Flag functions that exceed a
specified number of parameters. The default is
<i>&minus;1</i> (ignore the number of parameters).</p>

<p style="margin-left:11%;"><b>NestingThreshold</b></p>

<p style="margin-left:22%;">Flag compound statements which
create next nesting level after <i>NestingThreshold</i>.
This may differ significantly from the expected value for
macro&minus;heavy code. The default is <i>&minus;1</i>
(ignore the nesting level).</p>

<p style="margin-left:11%;"><b>VariableThreshold</b></p>

<p style="margin-left:22%;">Flag functions exceeding this
number of variables declared in the body. The default is
<i>&minus;1</i> (ignore the number of variables). Please
note that function parameters and variables declared in
lambdas, GNU Statement Expressions, and nested class inline
functions are not counted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;identifier&minus;length</b>
<br>
This check finds variables and function parameters whose
length are too short. The desired name length is
configurable.</p>

<p style="margin-left:11%; margin-top: 1em">Special cases
are supported for loop counters and for exception variable
names.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options</b>
<br>
The following options are described below:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>MinimumVariableNameLength</i>,
<i>IgnoredVariableNames</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>MinimumParameterNameLength</i>,
<i>IgnoredParameterNames</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>MinimumLoopCounterNameLength</i>,
<i>IgnoredLoopCounterNames</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>MinimumExceptionNameLength</i>,
<i>IgnoredExceptionVariableNames</i></p> </td></tr>
</table>


<p style="margin-left:11%;"><b>MinimumVariableNameLength</b></p>

<p style="margin-left:22%;">All variables (other than loop
counter, exception names and function parameters) are
expected to have at least a length of
<i>MinimumVariableNameLength</i> (default is <i>3</i>).
Setting it to <i>0</i> or <i>1</i> disables the check
entirely.</p>

<pre style="margin-left:26%; margin-top: 1em">int doubler(int x)   // warns that x is too short
{
   return 2 * x;
}</pre>


<p style="margin-left:22%; margin-top: 1em">This check does
not have any fix suggestions in the general case since
variable names have semantic value.</p>


<p style="margin-left:11%;"><b>IgnoredVariableNames</b></p>

<p style="margin-left:22%;">Specifies a regular expression
for variable names that are to be ignored. The default value
is empty, thus no names are ignored.</p>


<p style="margin-left:11%;"><b>MinimumParameterNameLength</b></p>

<p style="margin-left:22%;">All function parameter names
are expected to have a length of at least
<i>MinimumParameterNameLength</i> (default is <i>3</i>).
Setting it to <i>0</i> or <i>1</i> disables the check
entirely.</p>

<pre style="margin-left:26%; margin-top: 1em">int i = 42;    // warns that 'i' is too short</pre>


<p style="margin-left:22%; margin-top: 1em">This check does
not have any fix suggestions in the general case since
variable names have semantic value.</p>


<p style="margin-left:11%;"><b>IgnoredParameterNames</b></p>

<p style="margin-left:22%;">Specifies a regular expression
for parameters that are to be ignored. The default value is
<i>^[n]$</i> for historical reasons.</p>


<p style="margin-left:11%;"><b>MinimumLoopCounterNameLength</b></p>

<p style="margin-left:22%;">Loop counter variables are
expected to have a length of at least
<i>MinimumLoopCounterNameLength</i> characters (default is
<i>2</i>). Setting it to <i>0</i> or <i>1</i> disables the
check entirely.</p>

<pre style="margin-left:26%; margin-top: 1em">// This warns that 'q' is too short.
for (int q = 0; q &lt; size; ++ q) {
   // ...
}</pre>



<p style="margin-left:11%;"><b>IgnoredLoopCounterNames</b></p>

<p style="margin-left:22%;">Specifies a regular expression
for counter names that are to be ignored. The default value
is <i>^[ijk_]$</i>; the first three symbols for historical
reasons and the last one since it is frequently used as a
&quot;don't care&quot; value, specifically in tools such as
Google Benchmark.</p>

<pre style="margin-left:26%; margin-top: 1em">// This does not warn by default, for historical reasons.
for (int i = 0; i &lt; size; ++ i) {
    // ...
}</pre>



<p style="margin-left:11%;"><b>MinimumExceptionNameLength</b></p>

<p style="margin-left:22%;">Exception clause variables are
expected to have a length of at least
<i>MinimumExceptionNameLength</i> (default is <i>2</i>).
Setting it to <i>0</i> or <i>1</i> disables the check
entirely.</p>

<pre style="margin-left:26%; margin-top: 1em">try {
    // ...
}
// This warns that 'e' is too short.
catch (const std::exception&amp; x) {
    // ...
}</pre>



<p style="margin-left:11%;"><b>IgnoredExceptionVariableNames</b></p>

<p style="margin-left:22%;">Specifies a regular expression
for exception variable names that are to be ignored. The
default value is <i>^[e]$</i> mainly for historical
reasons.</p>

<pre style="margin-left:26%; margin-top: 1em">try {
    // ...
}
// This does not warn by default, for historical reasons.
catch (const std::exception&amp; e) {
    // ...
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;identifier&minus;naming</b>
<br>
Checks for identifiers naming style mismatch.</p>

<p style="margin-left:11%; margin-top: 1em">This check will
try to enforce coding guidelines on the identifiers naming.
It supports one of the following casing types and tries to
convert from one to another if a mismatch is detected</p>

<p style="margin-left:11%; margin-top: 1em">Casing types
include:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="27%">


<p><b>lower_case</b>,</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="27%">


<p><b>UPPER_CASE</b>,</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="27%">


<p><b>camelBack</b>,</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="27%">


<p><b>CamelCase</b>,</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="27%">


<p><b>camel_Snake_Back</b>,</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="27%">


<p><b>Camel_Snake_Case</b>,</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="27%">


<p><b>aNy_CasE</b>.</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">It also
supports a fixed prefix and suffix that will be prepended or
appended to the identifiers, regardless of the casing.</p>

<p style="margin-left:11%; margin-top: 1em">Many
configuration options are available, in order to be able to
create different rules for different kinds of identifiers.
In general, the rules are falling back to a more generic
rule if the specific case is not configured.</p>

<p style="margin-left:11%; margin-top: 1em">The naming of
virtual methods is reported where they occur in the base
class, but not where they are overridden, as it can't be
fixed locally there. This also applies for
pseudo&minus;override patterns like CRTP.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options</b>
<br>
The following options are described below:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p style="margin-top: 1em"><i>AbstractClassCase</i>,
<i>AbstractClassPrefix</i>, <i>AbstractClassSuffix</i>,
<i>AbstractClassIgnoredRegexp</i>,
<i>AbstractClassHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>AggressiveDependentMemberLookup</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ClassCase</i>, <i>ClassPrefix</i>,
<i>ClassSuffix</i>, <i>ClassIgnoredRegexp</i>,
<i>ClassHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ClassConstantCase</i>, <i>ClassConstantPrefix</i>,
<i>ClassConstantSuffix</i>,
<i>ClassConstantIgnoredRegexp</i>,
<i>ClassConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ClassMemberCase</i>, <i>ClassMemberPrefix</i>,
<i>ClassMemberSuffix</i>, <i>ClassMemberIgnoredRegexp</i>,
<i>ClassMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ClassMethodCase</i>, <i>ClassMethodPrefix</i>,
<i>ClassMethodSuffix</i>,
<i>ClassMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ConstantCase</i>, <i>ConstantPrefix</i>,
<i>ConstantSuffix</i>, <i>ConstantIgnoredRegexp</i>,
<i>ConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ConstantMemberCase</i>, <i>ConstantMemberPrefix</i>,
<i>ConstantMemberSuffix</i>,
<i>ConstantMemberIgnoredRegexp</i>,
<i>ConstantMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ConstantParameterCase</i>,
<i>ConstantParameterPrefix</i>,
<i>ConstantParameterSuffix</i>,
<i>ConstantParameterIgnoredRegexp</i>,
<i>ConstantParameterHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ConstantPointerParameterCase</i>,
<i>ConstantPointerParameterPrefix</i>,
<i>ConstantPointerParameterSuffix</i>,
<i>ConstantPointerParameterIgnoredRegexp</i>,
<i>ConstantPointerParameterHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ConstexprFunctionCase</i>,
<i>ConstexprFunctionPrefix</i>,
<i>ConstexprFunctionSuffix</i>,
<i>ConstexprFunctionIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ConstexprMethodCase</i>,
<i>ConstexprMethodPrefix</i>, <i>ConstexprMethodSuffix</i>,
<i>ConstexprMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ConstexprVariableCase</i>,
<i>ConstexprVariablePrefix</i>,
<i>ConstexprVariableSuffix</i>,
<i>ConstexprVariableIgnoredRegexp</i>,
<i>ConstexprVariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>EnumCase</i>, <i>EnumPrefix</i>, <i>EnumSuffix</i>,
<i>EnumIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>EnumConstantCase</i>, <i>EnumConstantPrefix</i>,
<i>EnumConstantSuffix</i>, <i>EnumConstantIgnoredRegexp</i>,
<i>EnumConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>FunctionCase</i>, <i>FunctionPrefix</i>,
<i>FunctionSuffix</i>, <i>FunctionIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>GetConfigPerFile</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>GlobalConstantCase</i>, <i>GlobalConstantPrefix</i>,
<i>GlobalConstantSuffix</i>,
<i>GlobalConstantIgnoredRegexp</i>,
<i>GlobalConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>GlobalConstantPointerCase</i>,
<i>GlobalConstantPointerPrefix</i>,
<i>GlobalConstantPointerSuffix</i>,
<i>GlobalConstantPointerIgnoredRegexp</i>,
<i>GlobalConstantPointerHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>GlobalFunctionCase</i>, <i>GlobalFunctionPrefix</i>,
<i>GlobalFunctionSuffix</i>,
<i>GlobalFunctionIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>GlobalPointerCase</i>, <i>GlobalPointerPrefix</i>,
<i>GlobalPointerSuffix</i>,
<i>GlobalPointerIgnoredRegexp</i>,
<i>GlobalPointerHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>GlobalVariableCase</i>, <i>GlobalVariablePrefix</i>,
<i>GlobalVariableSuffix</i>,
<i>GlobalVariableIgnoredRegexp</i>,
<i>GlobalVariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>IgnoreMainLikeFunctions</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>InlineNamespaceCase</i>,
<i>InlineNamespacePrefix</i>, <i>InlineNamespaceSuffix</i>,
<i>InlineNamespaceIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>LocalConstantCase</i>, <i>LocalConstantPrefix</i>,
<i>LocalConstantSuffix</i>,
<i>LocalConstantIgnoredRegexp</i>,
<i>LocalConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>LocalConstantPointerCase</i>,
<i>LocalConstantPointerPrefix</i>,
<i>LocalConstantPointerSuffix</i>,
<i>LocalConstantPointerIgnoredRegexp</i>,
<i>LocalConstantPointerHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>LocalPointerCase</i>, <i>LocalPointerPrefix</i>,
<i>LocalPointerSuffix</i>, <i>LocalPointerIgnoredRegexp</i>,
<i>LocalPointerHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>LocalVariableCase</i>, <i>LocalVariablePrefix</i>,
<i>LocalVariableSuffix</i>,
<i>LocalVariableIgnoredRegexp</i>,
<i>LocalVariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>MacroDefinitionCase</i>,
<i>MacroDefinitionPrefix</i>, <i>MacroDefinitionSuffix</i>,
<i>MacroDefinitionIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>MemberCase</i>, <i>MemberPrefix</i>,
<i>MemberSuffix</i>, <i>MemberIgnoredRegexp</i>,
<i>MemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>MethodCase</i>, <i>MethodPrefix</i>,
<i>MethodSuffix</i>, <i>MethodIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>NamespaceCase</i>, <i>NamespacePrefix</i>,
<i>NamespaceSuffix</i>, <i>NamespaceIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ParameterCase</i>, <i>ParameterPrefix</i>,
<i>ParameterSuffix</i>, <i>ParameterIgnoredRegexp</i>,
<i>ParameterHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ParameterPackCase</i>, <i>ParameterPackPrefix</i>,
<i>ParameterPackSuffix</i>,
<i>ParameterPackIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>PointerParameterCase</i>,
<i>PointerParameterPrefix</i>,
<i>PointerParameterSuffix</i>,
<i>PointerParameterIgnoredRegexp</i>,
<i>PointerParameterHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>PrivateMemberCase</i>, <i>PrivateMemberPrefix</i>,
<i>PrivateMemberSuffix</i>,
<i>PrivateMemberIgnoredRegexp</i>,
<i>PrivateMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>PrivateMethodCase</i>, <i>PrivateMethodPrefix</i>,
<i>PrivateMethodSuffix</i>,
<i>PrivateMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ProtectedMemberCase</i>,
<i>ProtectedMemberPrefix</i>, <i>ProtectedMemberSuffix</i>,
<i>ProtectedMemberIgnoredRegexp</i>,
<i>ProtectedMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ProtectedMethodCase</i>,
<i>ProtectedMethodPrefix</i>, <i>ProtectedMethodSuffix</i>,
<i>ProtectedMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>PublicMemberCase</i>, <i>PublicMemberPrefix</i>,
<i>PublicMemberSuffix</i>, <i>PublicMemberIgnoredRegexp</i>,
<i>PublicMemberHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>PublicMethodCase</i>, <i>PublicMethodPrefix</i>,
<i>PublicMethodSuffix</i>,
<i>PublicMethodIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ScopedEnumConstantCase</i>,
<i>ScopedEnumConstantPrefix</i>,
<i>ScopedEnumConstantSuffix</i>,
<i>ScopedEnumConstantIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>StaticConstantCase</i>, <i>StaticConstantPrefix</i>,
<i>StaticConstantSuffix</i>,
<i>StaticConstantIgnoredRegexp</i>,
<i>StaticConstantHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>StaticVariableCase</i>, <i>StaticVariablePrefix</i>,
<i>StaticVariableSuffix</i>,
<i>StaticVariableIgnoredRegexp</i>,
<i>StaticVariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>StructCase</i>, <i>StructPrefix</i>,
<i>StructSuffix</i>, <i>StructIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>TemplateParameterCase</i>,
<i>TemplateParameterPrefix</i>,
<i>TemplateParameterSuffix</i>,
<i>TemplateParameterIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>TemplateTemplateParameterCase</i>,
<i>TemplateTemplateParameterPrefix</i>,
<i>TemplateTemplateParameterSuffix</i>,
<i>TemplateTemplateParameterIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>TypeAliasCase</i>, <i>TypeAliasPrefix</i>,
<i>TypeAliasSuffix</i>, <i>TypeAliasIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>TypedefCase</i>, <i>TypedefPrefix</i>,
<i>TypedefSuffix</i>, <i>TypedefIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>TypeTemplateParameterCase</i>,
<i>TypeTemplateParameterPrefix</i>,
<i>TypeTemplateParameterSuffix</i>,
<i>TypeTemplateParameterIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>UnionCase</i>, <i>UnionPrefix</i>,
<i>UnionSuffix</i>, <i>UnionIgnoredRegexp</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>ValueTemplateParameterCase</i>,
<i>ValueTemplateParameterPrefix</i>,
<i>ValueTemplateParameterSuffix</i>,
<i>ValueTemplateParameterIgnoredRegexp</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>VariableCase</i>, <i>VariablePrefix</i>,
<i>VariableSuffix</i>, <i>VariableIgnoredRegexp</i>,
<i>VariableHungarianPrefix</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>VirtualMethodCase</i>, <i>VirtualMethodPrefix</i>,
<i>VirtualMethodSuffix</i>,
<i>VirtualMethodIgnoredRegexp</i></p> </td></tr>
</table>

<p style="margin-left:11%;"><b>AbstractClassCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure abstract class names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>AbstractClassPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure abstract class names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>AbstractClassIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for abstract class names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>AbstractClassSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure abstract class names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>AbstractClassHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>AbstractClassCase of <b>lower_case</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>AbstractClassPrefix of <b>pre_</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>AbstractClassSuffix of <b>_post</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>AbstractClassHungarianPrefix of <b>On</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms abstract class names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class ABSTRACT_CLASS {
public:
  ABSTRACT_CLASS();
};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class pre_abstract_class_post {
public:
  pre_abstract_class_post();
};</pre>



<p style="margin-left:11%;"><b>AggressiveDependentMemberLookup</b></p>

<p style="margin-left:22%;">When set to <i>true</i> the
check will look in dependent base classes for dependent
member references that need changing. This can lead to
errors with template specializations so the default value is
<i>false</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ClassMemberCase of <b>lower_case</b></p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">template &lt;typename T&gt;
struct Base {
  T BadNamedMember;
};


template &lt;typename T&gt;
struct Derived : Base&lt;T&gt; {
  void reset() {
    this&minus;&gt;BadNamedMember = 0;
  }
};</pre>


<p style="margin-left:11%; margin-top: 1em">After if
AggressiveDependentMemberLookup is <i>false</i>:</p>
<pre style="margin-left:15%; margin-top: 1em">template &lt;typename T&gt;
struct Base {
  T bad_named_member;
};


template &lt;typename T&gt;
struct Derived : Base&lt;T&gt; {
  void reset() {
    this&minus;&gt;BadNamedMember = 0;
  }
};</pre>


<p style="margin-left:11%; margin-top: 1em">After if
AggressiveDependentMemberLookup is <i>true</i>:</p>
<pre style="margin-left:15%; margin-top: 1em">template &lt;typename T&gt;
struct Base {
  T bad_named_member;
};


template &lt;typename T&gt;
struct Derived : Base&lt;T&gt; {
  void reset() {
    this&minus;&gt;bad_named_member = 0;
  }
};</pre>


<p style="margin-left:11%;"><b>ClassCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>ClassPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:11%;"><b>ClassIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for class names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>ClassSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class names will add the suffix with the given value
(regardless of casing).</p>


<p style="margin-left:11%;"><b>ClassHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>ClassCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>ClassPrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>ClassSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>ClassHungarianPrefix of <b>On</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms class names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class FOO {
public:
  FOO();
  ~FOO();
};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class pre_foo_post {
public:
  pre_foo_post();
  ~pre_foo_post();
};</pre>


<p style="margin-left:11%;"><b>ClassConstantCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class constant names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>ClassConstantPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class constant names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ClassConstantIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for class constant names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>ClassConstantSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class constant names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ClassConstantHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>ClassConstantCase of <b>lower_case</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>ClassConstantPrefix of <b>pre_</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>ClassConstantSuffix of <b>_post</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>ClassConstantHungarianPrefix of <b>On</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms class constant names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class FOO {
public:
  static const int CLASS_CONSTANT;
};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class FOO {
public:
  static const int pre_class_constant_post;
};</pre>


<p style="margin-left:11%;"><b>ClassMemberCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class member names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>ClassMemberPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ClassMemberIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for class member names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>ClassMemberSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class member names will add the suffix with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ClassMemberHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>ClassMemberCase of <b>lower_case</b></p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>ClassMemberPrefix of <b>pre_</b></p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>ClassMemberSuffix of <b>_post</b></p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>ClassMemberHungarianPrefix of <b>On</b></p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms class member names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class FOO {
public:
  static int CLASS_CONSTANT;
};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class FOO {
public:
  static int pre_class_constant_post;
};</pre>


<p style="margin-left:11%;"><b>ClassMethodCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class method names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>ClassMethodPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ClassMethodIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for class method names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>ClassMethodSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure class method names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ClassMethodCase of <b>lower_case</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ClassMethodPrefix of <b>pre_</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ClassMethodSuffix of <b>_post</b></p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms class method names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class FOO {
public:
  int CLASS_MEMBER();
};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class FOO {
public:
  int pre_class_member_post();
};</pre>


<p style="margin-left:11%;"><b>ConstantCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>ConstantPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstantIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for constant names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>ConstantSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant names will add the suffix with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstantHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstantCase of <b>lower_case</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstantPrefix of <b>pre_</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstantSuffix of <b>_post</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>ConstantHungarianPrefix of <b>On</b></p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms constant names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void function() { unsigned const MyConst_array[] = {1, 2, 3}; }</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void function() { unsigned const pre_myconst_array_post[] = {1, 2, 3}; }</pre>


<p style="margin-left:11%;"><b>ConstantMemberCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant member names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>ConstantMemberPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstantMemberIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for constant member names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>ConstantMemberSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant member names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstantMemberHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>ConstantMemberCase of <b>lower_case</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>ConstantMemberPrefix of <b>pre_</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>ConstantMemberSuffix of <b>_post</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>ConstantMemberHungarianPrefix of <b>On</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms constant member names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
  char const MY_ConstMember_string[4] = &quot;123&quot;;
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
  char const pre_my_constmember_string_post[4] = &quot;123&quot;;
}</pre>



<p style="margin-left:11%;"><b>ConstantParameterCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant parameter names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>ConstantParameterPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant parameter names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstantParameterIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for constant parameter names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>ConstantParameterSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant parameter names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstantParameterHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="59%">


<p>ConstantParameterCase of <b>lower_case</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="59%">


<p>ConstantParameterPrefix of <b>pre_</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="59%">


<p>ConstantParameterSuffix of <b>_post</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="59%">


<p>ConstantParameterHungarianPrefix of <b>On</b></p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms constant parameter names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void GLOBAL_FUNCTION(int PARAMETER_1, int const pre_const_parameter_post);</pre>



<p style="margin-left:11%;"><b>ConstantPointerParameterCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant pointer parameter names conform to the
selected casing.</p>


<p style="margin-left:11%;"><b>ConstantPointerParameterPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant pointer parameter names will add the
prefixed with the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstantPointerParameterIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for constant pointer parameter names matching
this regular expression.</p>


<p style="margin-left:11%;"><b>ConstantPointerParameterSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constant pointer parameter names will add the suffix
with the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstantPointerParameterHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="70%">


<p>ConstantPointerParameterCase of <b>lower_case</b></p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="70%">


<p>ConstantPointerParameterPrefix of <b>pre_</b></p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="70%">


<p>ConstantPointerParameterSuffix of <b>_post</b></p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="70%">


<p>ConstantPointerParameterHungarianPrefix of <b>On</b></p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms constant pointer parameter names as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void GLOBAL_FUNCTION(int const *CONST_parameter);</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void GLOBAL_FUNCTION(int const *pre_const_parameter_post);</pre>



<p style="margin-left:11%;"><b>ConstexprFunctionCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr function names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>ConstexprFunctionPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr function names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstexprFunctionIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for constexpr function names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>ConstexprFunctionSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr function names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>ConstexprFunctionCase of <b>lower_case</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>ConstexprFunctionPrefix of <b>pre_</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>ConstexprFunctionSuffix of <b>_post</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms constexpr function names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">constexpr int CE_function() { return 3; }</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">constexpr int pre_ce_function_post() { return 3; }</pre>


<p style="margin-left:11%;"><b>ConstexprMethodCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr method names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>ConstexprMethodPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstexprMethodIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for constexpr method names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>ConstexprMethodSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>ConstexprMethodCase of <b>lower_case</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>ConstexprMethodPrefix of <b>pre_</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>ConstexprMethodSuffix of <b>_post</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms constexpr method names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
public:
  constexpr int CST_expr_Method() { return 2; }
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
public:
  constexpr int pre_cst_expr_method_post() { return 2; }
}</pre>



<p style="margin-left:11%;"><b>ConstexprVariableCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr variable names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>ConstexprVariablePrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr variable names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstexprVariableIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for constexpr variable names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>ConstexprVariableSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure constexpr variable names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ConstexprVariableHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="59%">


<p>ConstexprVariableCase of <b>lower_case</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="59%">


<p>ConstexprVariablePrefix of <b>pre_</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="59%">


<p>ConstexprVariableSuffix of <b>_post</b></p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="59%">


<p>ConstexprVariableHungarianPrefix of <b>On</b></p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms constexpr variable names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">constexpr int ConstExpr_variable = MyConstant;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">constexpr int pre_constexpr_variable_post = MyConstant;</pre>


<p style="margin-left:11%;"><b>EnumCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure enumeration names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>EnumPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure enumeration names will add the prefixed with the
given value (regardless of casing).</p>

<p style="margin-left:11%;"><b>EnumIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for enumeration names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>EnumSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure enumeration names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>EnumCase of <b>lower_case</b></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>EnumPrefix of <b>pre_</b></p></td>
<td width="48%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="34%">


<p>EnumSuffix of <b>_post</b></p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms enumeration names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">enum FOO { One, Two, Three };</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">enum pre_foo_post { One, Two, Three };</pre>


<p style="margin-left:11%;"><b>EnumConstantCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure enumeration constant names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>EnumConstantPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure enumeration constant names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>EnumConstantIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for enumeration constant names matching this
regular expression.</p>

<p style="margin-left:11%;"><b>EnumConstantSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure enumeration constant names will add the suffix with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>EnumConstantHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>EnumConstantCase of <b>lower_case</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>EnumConstantPrefix of <b>pre_</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>EnumConstantSuffix of <b>_post</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>EnumConstantHungarianPrefix of <b>On</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms enumeration constant names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">enum FOO { One, Two, Three };</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">enum FOO { pre_One_post, pre_Two_post, pre_Three_post };</pre>


<p style="margin-left:11%;"><b>FunctionCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure function names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>FunctionPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure function names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>FunctionIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for function names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>FunctionSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure function names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>FunctionCase of <b>lower_case</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>FunctionPrefix of <b>pre_</b></p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="40%">


<p>FunctionSuffix of <b>_post</b></p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms function names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">char MY_Function_string();</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">char pre_my_function_string_post();</pre>


<p style="margin-left:11%;"><b>GetConfigPerFile</b></p>

<p style="margin-left:22%;">When <i>true</i> the check will
look for the configuration for where an identifier is
declared. Useful for when included header files use a
different style. Default value is <i>true</i>.</p>

<p style="margin-left:11%;"><b>GlobalConstantCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global constant names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>GlobalConstantPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global constant names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalConstantIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for global constant names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>GlobalConstantSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global constant names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalConstantHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalConstantCase of <b>lower_case</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalConstantPrefix of <b>pre_</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalConstantSuffix of <b>_post</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalConstantHungarianPrefix of <b>On</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms global constant names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">unsigned const MyConstGlobal_array[] = {1, 2, 3};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">unsigned const pre_myconstglobal_array_post[] = {1, 2, 3};</pre>



<p style="margin-left:11%;"><b>GlobalConstantPointerCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global constant pointer names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>GlobalConstantPointerPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global constant pointer names will add the prefixed
with the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalConstantPointerIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for global constant pointer names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>GlobalConstantPointerSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global constant pointer names will add the suffix
with the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalConstantPointerHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p>GlobalConstantPointerCase of <b>lower_case</b></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p>GlobalConstantPointerPrefix of <b>pre_</b></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p>GlobalConstantPointerSuffix of <b>_post</b></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="65%">


<p>GlobalConstantPointerHungarianPrefix of <b>On</b></p></td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms global constant pointer names as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">int *const MyConstantGlobalPointer = nullptr;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">int *const pre_myconstantglobalpointer_post = nullptr;</pre>


<p style="margin-left:11%;"><b>GlobalFunctionCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global function names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>GlobalFunctionPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global function names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalFunctionIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for global function names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>GlobalFunctionSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global function names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>GlobalFunctionCase of <b>lower_case</b></p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>GlobalFunctionPrefix of <b>pre_</b></p></td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="50%">


<p>GlobalFunctionSuffix of <b>_post</b></p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms global function names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void pre_global_function_post(int PARAMETER_1, int const CONST_parameter);</pre>


<p style="margin-left:11%;"><b>GlobalPointerCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global pointer names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>GlobalPointerPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global pointer names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalPointerIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for global pointer names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>GlobalPointerSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global pointer names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalPointerHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>GlobalPointerCase of <b>lower_case</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>GlobalPointerPrefix of <b>pre_</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>GlobalPointerSuffix of <b>_post</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>GlobalPointerHungarianPrefix of <b>On</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms global pointer names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">int *GLOBAL3;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">int *pre_global3_post;</pre>


<p style="margin-left:11%;"><b>GlobalVariableCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global variable names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>GlobalVariablePrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global variable names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalVariableIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for global variable names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>GlobalVariableSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure global variable names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>GlobalVariableHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalVariableCase of <b>lower_case</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalVariablePrefix of <b>pre_</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalVariableSuffix of <b>_post</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>GlobalVariableHungarianPrefix of <b>On</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms global variable names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">int GLOBAL3;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">int pre_global3_post;</pre>



<p style="margin-left:11%;"><b>IgnoreMainLikeFunctions</b></p>

<p style="margin-left:22%;">When set to <i>true</i>
functions that have a similar signature to <b>main</b> or
<b>wmain</b> won't enforce checks on the names of their
parameters. Default value is <i>false</i>.</p>

<p style="margin-left:11%;"><b>InlineNamespaceCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure inline namespaces names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>InlineNamespacePrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure inline namespaces names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>InlineNamespaceIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for inline namespaces names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>InlineNamespaceSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure inline namespaces names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>InlineNamespaceCase of <b>lower_case</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>InlineNamespacePrefix of <b>pre_</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>InlineNamespaceSuffix of <b>_post</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms inline namespaces names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">namespace FOO_NS {
inline namespace InlineNamespace {
...
}
} // namespace FOO_NS</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">namespace FOO_NS {
inline namespace pre_inlinenamespace_post {
...
}
} // namespace FOO_NS</pre>


<p style="margin-left:11%;"><b>LocalConstantCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local constant names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>LocalConstantPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local constant names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>LocalConstantIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for local constant names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>LocalConstantSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local constant names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>LocalConstantHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalConstantCase of <b>lower_case</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalConstantPrefix of <b>pre_</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalConstantSuffix of <b>_post</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalConstantHungarianPrefix of <b>On</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms local constant names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() { int const local_Constant = 3; }</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() { int const pre_local_constant_post = 3; }</pre>



<p style="margin-left:11%;"><b>LocalConstantPointerCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local constant pointer names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>LocalConstantPointerPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local constant pointer names will add the prefixed
with the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>LocalConstantPointerIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for local constant pointer names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>LocalConstantPointerSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local constant pointer names will add the suffix with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>LocalConstantPointerHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="64%">


<p>LocalConstantPointerCase of <b>lower_case</b></p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="64%">


<p>LocalConstantPointerPrefix of <b>pre_</b></p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="64%">


<p>LocalConstantPointerSuffix of <b>_post</b></p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="64%">


<p>LocalConstantPointerHungarianPrefix of <b>On</b></p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms local constant pointer names as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() { int const *local_Constant = 3; }</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() { int const *pre_local_constant_post = 3; }</pre>


<p style="margin-left:11%;"><b>LocalPointerCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local pointer names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>LocalPointerPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local pointer names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>LocalPointerIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for local pointer names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>LocalPointerSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local pointer names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>LocalPointerHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>LocalPointerCase of <b>lower_case</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>LocalPointerPrefix of <b>pre_</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>LocalPointerSuffix of <b>_post</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>LocalPointerHungarianPrefix of <b>On</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms local pointer names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() { int *local_Constant; }</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() { int *pre_local_constant_post; }</pre>


<p style="margin-left:11%;"><b>LocalVariableCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local variable names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>LocalVariablePrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local variable names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>LocalVariableIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for local variable names matching this regular
expression.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>LocalVariableCase of <b>CamelCase</b></p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>LocalVariableIgnoredRegexp of <b>\w{1,2}</b></p></td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Will exclude
variables with a length less than or equal to 2 from the
camel case check applied to other variables. <b><br>
LocalVariableSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure local variable names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>LocalVariableHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalVariableCase of <b>lower_case</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalVariablePrefix of <b>pre_</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalVariableSuffix of <b>_post</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>LocalVariableHungarianPrefix of <b>On</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms local variable names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() { int local_Constant; }</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo() { int pre_local_constant_post; }</pre>


<p style="margin-left:11%;"><b>MacroDefinitionCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure macro definitions conform to the selected casing.</p>


<p style="margin-left:11%;"><b>MacroDefinitionPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure macro definitions will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>MacroDefinitionIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for macro definitions matching this regular
expression.</p>


<p style="margin-left:11%;"><b>MacroDefinitionSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure macro definitions will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>MacroDefinitionCase of <b>lower_case</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>MacroDefinitionPrefix of <b>pre_</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>MacroDefinitionSuffix of <b>_post</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms macro definitions as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">#define MY_MacroDefinition</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">#define pre_my_macro_definition_post</pre>


<p style="margin-left:11%; margin-top: 1em">Note: This will
not warn on builtin macros or macros defined on the command
line using the <b>&minus;D</b> flag. <b><br>
MemberCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure member names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>MemberPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure member names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:11%;"><b>MemberIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for member names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>MemberSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure member names will add the suffix with the given value
(regardless of casing).</p>


<p style="margin-left:11%;"><b>MemberHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>MemberCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>MemberPrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>MemberSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>MemberHungarianPrefix of <b>On</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms member names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
  char MY_ConstMember_string[4];
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
  char pre_my_constmember_string_post[4];
}</pre>


<p style="margin-left:11%;"><b>MethodCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure method names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>MethodPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure method names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:11%;"><b>MethodIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for method names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>MethodSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure method names will add the suffix with the given value
(regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="37%">


<p>MethodCase of <b>lower_case</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="37%">


<p>MethodPrefix of <b>pre_</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="37%">


<p>MethodSuffix of <b>_post</b></p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms method names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
  char MY_Method_string();
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
  char pre_my_method_string_post();
}</pre>


<p style="margin-left:11%;"><b>NamespaceCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure namespace names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>NamespacePrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure namespace names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>NamespaceIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for namespace names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>NamespaceSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure namespace names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>NamespaceCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>NamespacePrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>NamespaceSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms namespace names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">namespace FOO_NS {
...
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">namespace pre_foo_ns_post {
...
}</pre>


<p style="margin-left:11%;"><b>ParameterCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure parameter names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>ParameterPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure parameter names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ParameterIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for parameter names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>ParameterSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure parameter names will add the suffix with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ParameterHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>ParameterCase of <b>lower_case</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>ParameterPrefix of <b>pre_</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>ParameterSuffix of <b>_post</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>ParameterHungarianPrefix of <b>On</b></p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms parameter names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void GLOBAL_FUNCTION(int pre_parameter_post, int const CONST_parameter);</pre>


<p style="margin-left:11%;"><b>ParameterPackCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure parameter pack names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>ParameterPackPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure parameter pack names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ParameterPackIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for parameter pack names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>ParameterPackSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure parameter pack names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>ParameterPackCase of <b>lower_case</b></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>ParameterPackPrefix of <b>pre_</b></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>ParameterPackSuffix of <b>_post</b></p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms parameter pack names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;typename... TYPE_parameters&gt; {
  void FUNCTION(int... TYPE_parameters);
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;typename... TYPE_parameters&gt; {
  void FUNCTION(int... pre_type_parameters_post);
}</pre>



<p style="margin-left:11%;"><b>PointerParameterCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure pointer parameter names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>PointerParameterPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure pointer parameter names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>PointerParameterIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for pointer parameter names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>PointerParameterSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure pointer parameter names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>PointerParameterHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>PointerParameterCase of <b>lower_case</b></p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>PointerParameterPrefix of <b>pre_</b></p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>PointerParameterSuffix of <b>_post</b></p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="57%">


<p>PointerParameterHungarianPrefix of <b>On</b></p></td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms pointer parameter names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">void FUNCTION(int *PARAMETER);</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">void FUNCTION(int *pre_parameter_post);</pre>


<p style="margin-left:11%;"><b>PrivateMemberCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure private member names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>PrivateMemberPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure private member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>PrivateMemberIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for private member names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>PrivateMemberSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure private member names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>PrivateMemberHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>PrivateMemberCase of <b>lower_case</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>PrivateMemberPrefix of <b>pre_</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>PrivateMemberSuffix of <b>_post</b></p></td>
<td width="29%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="53%">


<p>PrivateMemberHungarianPrefix of <b>On</b></p></td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms private member names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
private:
  int Member_Variable;
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
private:
  int pre_member_variable_post;
}</pre>


<p style="margin-left:11%;"><b>PrivateMethodCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure private method names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>PrivateMethodPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure private method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>PrivateMethodIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for private method names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>PrivateMethodSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure private method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>PrivateMethodCase of <b>lower_case</b></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>PrivateMethodPrefix of <b>pre_</b></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>PrivateMethodSuffix of <b>_post</b></p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms private method names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
private:
  int Member_Method();
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
private:
  int pre_member_method_post();
}</pre>


<p style="margin-left:11%;"><b>ProtectedMemberCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure protected member names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>ProtectedMemberPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure protected member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ProtectedMemberIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for protected member names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>ProtectedMemberSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure protected member names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ProtectedMemberHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>ProtectedMemberCase of <b>lower_case</b></p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>ProtectedMemberPrefix of <b>pre_</b></p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>ProtectedMemberSuffix of <b>_post</b></p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="56%">


<p>ProtectedMemberHungarianPrefix of <b>On</b></p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms protected member names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
protected:
  int Member_Variable;
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
protected:
  int pre_member_variable_post;
}</pre>


<p style="margin-left:11%;"><b>ProtectedMethodCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure protected method names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>ProtectedMethodPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure protected method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ProtectedMethodIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for protected method names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>ProtectedMethodSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure protected method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>ProtectedMethodCase of <b>lower_case</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>ProtectedMethodPrefix of <b>pre_</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>ProtectedMethodSuffix of <b>_post</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms protect method names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
protected:
  int Member_Method();
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
protected:
  int pre_member_method_post();
}</pre>


<p style="margin-left:11%;"><b>PublicMemberCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure public member names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>PublicMemberPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure public member names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>PublicMemberIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for public member names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>PublicMemberSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure public member names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>PublicMemberHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>PublicMemberCase of <b>lower_case</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>PublicMemberPrefix of <b>pre_</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>PublicMemberSuffix of <b>_post</b></p></td>
<td width="31%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="51%">


<p>PublicMemberHungarianPrefix of <b>On</b></p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms public member names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
public:
  int Member_Variable;
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
public:
  int pre_member_variable_post;
}</pre>


<p style="margin-left:11%;"><b>PublicMethodCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure public method names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>PublicMethodPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure public method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>PublicMethodIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for public method names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>PublicMethodSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure public method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>PublicMethodCase of <b>lower_case</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>PublicMethodPrefix of <b>pre_</b></p></td>
<td width="35%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="47%">


<p>PublicMethodSuffix of <b>_post</b></p></td>
<td width="35%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms public method names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
public:
  int Member_Method();
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
public:
  int pre_member_method_post();
}</pre>



<p style="margin-left:11%;"><b>ScopedEnumConstantCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure scoped enum constant names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>ScopedEnumConstantPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure scoped enum constant names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ScopedEnumConstantIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for scoped enum constant names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>ScopedEnumConstantSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure scoped enum constant names will add the suffix with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ScopedEnumConstantHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="60%">


<p>ScopedEnumConstantCase of <b>lower_case</b></p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="60%">


<p>ScopedEnumConstantPrefix of <b>pre_</b></p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="60%">


<p>ScopedEnumConstantSuffix of <b>_post</b></p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="60%">


<p>ScopedEnumConstantHungarianPrefix of <b>On</b></p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms enumeration constant names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">enum class FOO { One, Two, Three };</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">enum class FOO { pre_One_post, pre_Two_post, pre_Three_post };</pre>


<p style="margin-left:11%;"><b>StaticConstantCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure static constant names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>StaticConstantPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure static constant names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>StaticConstantIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for static constant names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>StaticConstantSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure static constant names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>StaticConstantHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>StaticConstantCase of <b>lower_case</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>StaticConstantPrefix of <b>pre_</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>StaticConstantSuffix of <b>_post</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>StaticConstantHungarianPrefix of <b>On</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms static constant names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">static unsigned const MyConstStatic_array[] = {1, 2, 3};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">static unsigned const pre_myconststatic_array_post[] = {1, 2, 3};</pre>


<p style="margin-left:11%;"><b>StaticVariableCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure static variable names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>StaticVariablePrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure static variable names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>StaticVariableIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for static variable names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>StaticVariableSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure static variable names will add the suffix with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>StaticVariableHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>StaticVariableCase of <b>lower_case</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>StaticVariablePrefix of <b>pre_</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>StaticVariableSuffix of <b>_post</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>StaticVariableHungarianPrefix of <b>On</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms static variable names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">static unsigned MyStatic_array[] = {1, 2, 3};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">static unsigned pre_mystatic_array_post[] = {1, 2, 3};</pre>


<p style="margin-left:11%;"><b>StructCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure struct names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>StructPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure struct names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:11%;"><b>StructIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for struct names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>StructSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure struct names will add the suffix with the given value
(regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="37%">


<p>StructCase of <b>lower_case</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="37%">


<p>StructPrefix of <b>pre_</b></p></td>
<td width="45%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="37%">


<p>StructSuffix of <b>_post</b></p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms struct names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">struct FOO {
  FOO();
  ~FOO();
};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">struct pre_foo_post {
  pre_foo_post();
  ~pre_foo_post();
};</pre>



<p style="margin-left:11%;"><b>TemplateParameterCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure template parameter names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>TemplateParameterPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure template parameter names will add the prefixed with
the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>TemplateParameterIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for template parameter names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>TemplateParameterSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure template parameter names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>TemplateParameterCase of <b>lower_case</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>TemplateParameterPrefix of <b>pre_</b></p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="54%">


<p>TemplateParameterSuffix of <b>_post</b></p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms template parameter names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;typename T&gt; class Foo {};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;typename pre_t_post&gt; class Foo {};</pre>



<p style="margin-left:11%;"><b>TemplateTemplateParameterCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure template template parameter names conform to the
selected casing.</p>


<p style="margin-left:11%;"><b>TemplateTemplateParameterPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure template template parameter names will add the
prefixed with the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>TemplateTemplateParameterIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for template template parameter names matching
this regular expression.</p>


<p style="margin-left:11%;"><b>TemplateTemplateParameterSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure template template parameter names will add the suffix
with the given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="67%">


<p>TemplateTemplateParameterCase of <b>lower_case</b></p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="67%">


<p>TemplateTemplateParameterPrefix of <b>pre_</b></p></td>
<td width="15%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="67%">


<p>TemplateTemplateParameterSuffix of <b>_post</b></p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms template template parameter names as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;template &lt;typename&gt; class TPL_parameter, int COUNT_params,
          typename... TYPE_parameters&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;template &lt;typename&gt; class pre_tpl_parameter_post, int COUNT_params,
          typename... TYPE_parameters&gt;</pre>


<p style="margin-left:11%;"><b>TypeAliasCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure type alias names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>TypeAliasPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure type alias names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>TypeAliasIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for type alias names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>TypeAliasSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure type alias names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>TypeAliasCase of <b>lower_case</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>TypeAliasPrefix of <b>pre_</b></p></td>
<td width="40%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="42%">


<p>TypeAliasSuffix of <b>_post</b></p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms type alias names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">using MY_STRUCT_TYPE = my_structure;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">using pre_my_struct_type_post = my_structure;</pre>


<p style="margin-left:11%;"><b>TypedefCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure typedef names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>TypedefPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure typedef names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>TypedefIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for typedef names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>TypedefSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure typedef names will add the suffix with the given
value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>TypedefCase of <b>lower_case</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>TypedefPrefix of <b>pre_</b></p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="39%">


<p>TypedefSuffix of <b>_post</b></p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms typedef names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">typedef int MYINT;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">typedef int pre_myint_post;</pre>



<p style="margin-left:11%;"><b>TypeTemplateParameterCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure type template parameter names conform to the selected
casing.</p>


<p style="margin-left:11%;"><b>TypeTemplateParameterPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure type template parameter names will add the prefixed
with the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>TypeTemplateParameterIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for type template names matching this regular
expression.</p>


<p style="margin-left:11%;"><b>TypeTemplateParameterSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure type template parameter names will add the suffix
with the given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="60%">


<p>TypeTemplateParameterCase of <b>lower_case</b></p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="60%">


<p>TypeTemplateParameterPrefix of <b>pre_</b></p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="60%">


<p>TypeTemplateParameterSuffix of <b>_post</b></p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms type template parameter names as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;template &lt;typename&gt; class TPL_parameter, int COUNT_params,
          typename... TYPE_parameters&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;template &lt;typename&gt; class TPL_parameter, int COUNT_params,
          typename... pre_type_parameters_post&gt;</pre>


<p style="margin-left:11%;"><b>UnionCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure union names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>UnionPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure union names will add the prefixed with the given
value (regardless of casing).</p>

<p style="margin-left:11%;"><b>UnionIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for union names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>UnionSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure union names will add the suffix with the given value
(regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="36%">


<p>UnionCase of <b>lower_case</b></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="36%">


<p>UnionPrefix of <b>pre_</b></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="36%">


<p>UnionSuffix of <b>_post</b></p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms union names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">union FOO {
  int a;
  char b;
};</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">union pre_foo_post {
  int a;
  char b;
};</pre>



<p style="margin-left:11%;"><b>ValueTemplateParameterCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure value template parameter names conform to the
selected casing.</p>


<p style="margin-left:11%;"><b>ValueTemplateParameterPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure value template parameter names will add the prefixed
with the given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>ValueTemplateParameterIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for value template parameter names matching this
regular expression.</p>


<p style="margin-left:11%;"><b>ValueTemplateParameterSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure value template parameter names will add the suffix
with the given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="62%">


<p>ValueTemplateParameterCase of <b>lower_case</b></p></td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="62%">


<p>ValueTemplateParameterPrefix of <b>pre_</b></p></td>
<td width="20%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="62%">


<p>ValueTemplateParameterSuffix of <b>_post</b></p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms value template parameter names as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;template &lt;typename&gt; class TPL_parameter, int COUNT_params,
          typename... TYPE_parameters&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">template &lt;template &lt;typename&gt; class TPL_parameter, int pre_count_params_post,
          typename... TYPE_parameters&gt;</pre>


<p style="margin-left:11%;"><b>VariableCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable names conform to the selected casing.</p>

<p style="margin-left:11%;"><b>VariablePrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable names will add the prefixed with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>VariableIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for variable names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>VariableSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable names will add the suffix with the given
value (regardless of casing).</p>


<p style="margin-left:11%;"><b>VariableHungarianPrefix</b></p>

<p style="margin-left:22%;">When enabled, the check ensures
that the declared identifier will have a Hungarian notation
prefix based on the declared type.</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>VariableCase of <b>lower_case</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>VariablePrefix of <b>pre_</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>VariableSuffix of <b>_post</b></p></td>
<td width="37%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="45%">


<p>VariableHungarianPrefix of <b>On</b></p></td>
<td width="37%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms variable names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">unsigned MyVariable;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">unsigned pre_myvariable_post;</pre>


<p style="margin-left:11%;"><b>VirtualMethodCase</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure virtual method names conform to the selected
casing.</p>

<p style="margin-left:11%;"><b>VirtualMethodPrefix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure virtual method names will add the prefixed with the
given value (regardless of casing).</p>


<p style="margin-left:11%;"><b>VirtualMethodIgnoredRegexp</b></p>

<p style="margin-left:22%;">Identifier naming checks won't
be enforced for virtual method names matching this regular
expression.</p>

<p style="margin-left:11%;"><b>VirtualMethodSuffix</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure virtual method names will add the suffix with the
given value (regardless of casing).</p>

<p style="margin-left:11%; margin-top: 1em">For example
using values of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>VirtualMethodCase of <b>lower_case</b></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>VirtualMethodPrefix of <b>pre_</b></p></td>
<td width="34%">
</td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="48%">


<p>VirtualMethodSuffix of <b>_post</b></p></td>
<td width="34%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Identifies
and/or transforms virtual method names as follows:</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
public:
  virtual int MemberFunction();
}</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">class Foo {
public:
  virtual int pre_member_function_post();
}</pre>


<p style="margin-left:11%; margin-top: 1em"><b>The default
mapping table of Hungarian Notation</b> <br>
In Hungarian notation, a variable name starts with a group
of lower&minus;case letters which are mnemonics for the type
or purpose of that variable, followed by whatever name the
programmer has chosen; this last part is sometimes
distinguished as the given name. The first character of the
given name can be capitalized to separate it from the type
indicators (see also CamelCase). Otherwise the case of this
character denotes scope.</p>

<p style="margin-left:11%; margin-top: 1em">The following
table is the default mapping table of Hungarian Notation
which maps Decl to its prefix string. You can also have your
own style in config file.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-30332504.png" alt="Image grohtml-30332504.png"></p>

<p style="margin-left:11%;"><b>There are more trivial
options for Hungarian Notation: <br>
HungarianNotation.General.*</b></p>

<p style="margin-left:22%;">Options are not belonging to
any specific Decl.</p>


<p style="margin-left:11%;"><b>HungarianNotation.CString.*</b></p>

<p style="margin-left:22%;">Options for
NULL&minus;terminated string.</p>


<p style="margin-left:11%;"><b>HungarianNotation.DerivedType.*</b></p>

<p style="margin-left:22%;">Options for derived types.</p>


<p style="margin-left:11%;"><b>HungarianNotation.PrimitiveType.*</b></p>

<p style="margin-left:22%;">Options for primitive
types.</p>


<p style="margin-left:11%;"><b>HungarianNotation.UserDefinedType.*</b></p>

<p style="margin-left:22%;">Options for user&minus;defined
types.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options for
Hungarian Notation</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.General.TreatStructAsClass</i></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.DerivedType.Array</i></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.DerivedType.Pointer</i></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">



<p><i>HungarianNotation.DerivedType.FunctionPointer</i></p> </td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.CString.CharPrinter</i></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.CString.CharArray</i></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.CString.WideCharPrinter</i></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.CString.WideCharArray</i></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.PrimitiveType.*</i></p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p><i>HungarianNotation.UserDefinedType.*</i></p></td>
<td width="17%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>HungarianNotation.General.TreatStructAsClass</b></p>

<p style="margin-left:22%;">When defined, the check will
treat naming of struct as a class. The default value is
<i>false</i>.</p>


<p style="margin-left:11%;"><b>HungarianNotation.DerivedType.Array</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>a</i>.</p>


<p style="margin-left:11%;"><b>HungarianNotation.DerivedType.Pointer</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>p</i>.</p>


<p style="margin-left:11%;"><b>HungarianNotation.DerivedType.FunctionPointer</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>fn</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">// Array
int DataArray[2] = {0};

// Pointer
void *DataBuffer = NULL;


// FunctionPointer
typedef void (*FUNC_PTR)();
FUNC_PTR FuncPtr = NULL;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">// Array
int aDataArray[2] = {0};

// Pointer
void *pDataBuffer = NULL;


// FunctionPointer
typedef void (*FUNC_PTR)();
FUNC_PTR fnFuncPtr = NULL;</pre>



<p style="margin-left:11%;"><b>HungarianNotation.CString.CharPrinter</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>sz</i>.</p>


<p style="margin-left:11%;"><b>HungarianNotation.CString.CharArray</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>sz</i>.</p>


<p style="margin-left:11%;"><b>HungarianNotation.CString.WideCharPrinter</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>wsz</i>.</p>


<p style="margin-left:11%;"><b>HungarianNotation.CString.WideCharArray</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name will add the prefix with the given
string. The default prefix is <i>wsz</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">// CharPrinter
const char *NamePtr = &quot;Name&quot;;

// CharArray
const char NameArray[] = &quot;Name&quot;;

// WideCharPrinter
const wchar_t *WideNamePtr = L&quot;Name&quot;;


// WideCharArray
const wchar_t WideNameArray[] = L&quot;Name&quot;;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">// CharPrinter
const char *szNamePtr = &quot;Name&quot;;

// CharArray
const char szNameArray[] = &quot;Name&quot;;

// WideCharPrinter
const wchar_t *wszWideNamePtr = L&quot;Name&quot;;


// WideCharArray
const wchar_t wszWideNameArray[] = L&quot;Name&quot;;</pre>



<p style="margin-left:11%;"><b>HungarianNotation.PrimitiveType.*</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name of involved primitive types will add
the prefix with the given string. The default prefixes are
defined in the default mapping table.</p>


<p style="margin-left:11%;"><b>HungarianNotation.UserDefinedType.*</b></p>

<p style="margin-left:22%;">When defined, the check will
ensure variable name of involved primitive types will add
the prefix with the given string. The default prefixes are
defined in the default mapping table.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>

<pre style="margin-left:15%; margin-top: 1em">int8_t   ValueI8      = 0;
int16_t  ValueI16     = 0;
int32_t  ValueI32     = 0;
int64_t  ValueI64     = 0;
uint8_t  ValueU8      = 0;
uint16_t ValueU16     = 0;
uint32_t ValueU32     = 0;
uint64_t ValueU64     = 0;
float    ValueFloat   = 0.0;
double   ValueDouble  = 0.0;
ULONG    ValueUlong   = 0;
DWORD    ValueDword   = 0;</pre>


<p style="margin-left:11%; margin-top: 1em">After:</p>

<pre style="margin-left:15%; margin-top: 1em">int8_t   i8ValueI8    = 0;
int16_t  i16ValueI16  = 0;
int32_t  i32ValueI32  = 0;
int64_t  i64ValueI64  = 0;
uint8_t  u8ValueU8    = 0;
uint16_t u16ValueU16  = 0;
uint32_t u32ValueU32  = 0;
uint64_t u64ValueU64  = 0;
float    fValueFloat  = 0.0;
double   dValueDouble = 0.0;
ULONG    ulValueUlong = 0;
DWORD    dwValueDword = 0;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;implicit&minus;bool&minus;cast</b>
<br>
This check has been renamed to
<i>readability&minus;implicit&minus;bool&minus;conversion</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;implicit&minus;bool&minus;conversion</b>
<br>
This check can be used to find implicit conversions between
built&minus;in types and booleans. Depending on use case, it
may simply help with readability of the code, or in some
cases, point to potential bugs which remain unnoticed due to
implicit conversions.</p>

<p style="margin-left:11%; margin-top: 1em">The following
is a real&minus;world example of bug which was hiding behind
implicit <b>bool</b> conversion:</p>
<pre style="margin-left:15%; margin-top: 1em">class Foo {
  int m_foo;

public:
  void setFoo(bool foo) { m_foo = foo; } // warning: implicit conversion bool &minus;&gt; int
  int getFoo() { return m_foo; }
};


void use(Foo&amp; foo) {
  bool value = foo.getFoo(); // warning: implicit conversion int &minus;&gt; bool
}</pre>


<p style="margin-left:11%; margin-top: 1em">This code is
the result of unsuccessful refactoring, where type of
<b>m_foo</b> changed from <b>bool</b> to <b>int</b>. The
programmer forgot to change all occurrences of <b>bool</b>,
and the remaining code is no longer correct, yet it still
compiles without any visible warnings.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
issuing warnings, fix&minus;it hints are provided to help
solve the reported issues. This can be used for improving
readability of code, for example:</p>
<pre style="margin-left:15%; margin-top: 1em">void conversionsToBool() {
  float floating;
  bool boolean = floating;
  // ^ propose replacement: bool boolean = floating != 0.0f;

  int integer;
  if (integer) {}
  // ^ propose replacement: if (integer != 0) {}

  int* pointer;
  if (!pointer) {}
  // ^ propose replacement: if (pointer == nullptr) {}

  while (1) {}
  // ^ propose replacement: while (true) {}
}

void functionTakingInt(int param);

void conversionsFromBool() {
  bool boolean;
  functionTakingInt(boolean);
  // ^ propose replacement: functionTakingInt(static_cast&lt;int&gt;(boolean));


  functionTakingInt(true);
  // ^ propose replacement: functionTakingInt(1);
}</pre>


<p style="margin-left:11%; margin-top: 1em">In general, the
following conversion types are checked:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>integer expression/literal to boolean (conversion from a
single bit bitfield to boolean is explicitly allowed, since
there's no ambiguity / information loss in this case),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>floating expression/literal to boolean,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>pointer/pointer to member/<b>nullptr</b>/<b>NULL</b> to
boolean,</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>boolean expression/literal to integer (conversion from
boolean to a single bit bitfield is explicitly allowed),</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>boolean expression/literal to floating.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The rules for
generating fix&minus;it hints are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">in case of conversions from
other built&minus;in type to bool, an explicit comparison is
proposed to make it clear what exactly is being
compared:</p> </td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>bool boolean = floating;</b>
is changed to <b>bool boolean = floating == 0.0f;</b>,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>for other types, appropriate literals are used
(<b>0</b>, <b>0u</b>, <b>0.0f</b>, <b>0.0</b>,
<b>nullptr</b>),</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">in case of
negated expressions conversion to bool, the proposed
replacement with comparison is simplified:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p style="margin-top: 1em"><b>if (!pointer)</b> is changed
to <b>if (pointer == nullptr)</b>,</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%"></td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">in case of
conversions from bool to other built&minus;in types, an
explicit <b>static_cast</b> is proposed to make it clear
that a conversion is taking place:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int integer = boolean;</b> is
changed to <b>int integer =
static_cast&lt;int&gt;(boolean);</b>,</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">if the
conversion is performed on type literals, an equivalent
literal is proposed, according to what type is actually
expected, for example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>functionTakingBool(0);</b> is
changed to <b>functionTakingBool(false);</b>,</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p><b>functionTakingInt(true);</b> is changed to
<b>functionTakingInt(1);</b>,</p> </td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>for other types, appropriate literals are used
(<b>false</b>, <b>true</b>, <b>0</b>, <b>1</b>, <b>0u</b>,
<b>1u</b>, <b>0.0f</b>, <b>1.0f</b>, <b>0.0</b>,
<b>1.0f</b>).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Some additional
accommodations are made for pre&minus;C++11 dialects:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><b>false</b> literal conversion
to pointer is detected,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>instead of <b>nullptr</b> literal, <b>0</b> is proposed
as replacement.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Occurrences of
implicit conversions inside macros and template
instantiations are deliberately ignored, as it is not clear
how to deal with such cases.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
AllowIntegerConditions</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will allow conditional integer conversions. Default is
<i>false</i>.</p>


<p style="margin-left:11%;"><b>AllowPointerConditions</b></p>

<p style="margin-left:22%;">When <i>true</i>, the check
will allow conditional pointer conversions. Default is
<i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;inconsistent&minus;declaration&minus;parameter&minus;name</b>
<br>
Find function declarations which differ in parameter
names.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>
<pre style="margin-left:15%; margin-top: 1em">// in foo.hpp:
void foo(int a, int b, int c);


// in foo.cpp:
void foo(int d, int e, int f); // warning</pre>


<p style="margin-left:11%; margin-top: 1em">This check
should help to enforce consistency in large projects, where
it often happens that a definition of function is
refactored, changing the parameter names, but its
declaration in header file is not updated. With this check,
we can easily find and correct such inconsistencies, keeping
declaration and definition always in sync.</p>

<p style="margin-left:11%; margin-top: 1em">Unnamed
parameters are allowed and are not taken into account when
comparing function declarations, for example:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo(int a);
void foo(int); // no warning</pre>


<p style="margin-left:11%; margin-top: 1em">One name is
also allowed to be a case&minus;insensitive prefix/suffix of
the other:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo(int count);
void foo(int count_input) { // no warning
  int count = adjustCount(count_input);
}</pre>


<p style="margin-left:11%; margin-top: 1em">To help with
refactoring, in some cases fix&minus;it hints are generated
to align parameter names to a single naming convention. This
works with the assumption that the function definition is
the most up&minus;to&minus;date version, as it directly
references parameter names in its body. Example:</p>

<pre style="margin-left:15%; margin-top: 1em">void foo(int a); // warning and fix&minus;it hint (replace &quot;a&quot; to &quot;b&quot;)
int foo(int b) { return b + 2; } // definition with use of &quot;b&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">In the case of
multiple redeclarations or function template
specializations, a warning is issued for every redeclaration
or specialization inconsistent with the definition or the
first declaration seen in a translation unit. <b><br>
IgnoreMacros</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about names declared inside macros.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>Strict</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>If this option is set to <i>true</i> (default is
<i>false</i>), then names must match exactly (or be
absent).</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;isolate&minus;declaration</b>
<br>
Detects local variable declarations declaring more than one
variable and tries to refactor the code to one statement per
declaration.</p>

<p style="margin-left:11%; margin-top: 1em">The automatic
code&minus;transformation will use the same indentation as
the original for every created statement and add a line
break after each statement. It keeps the order of the
variable declarations consistent, too.</p>

<pre style="margin-left:15%; margin-top: 1em">void f() {
  int * pointer = nullptr, value = 42, * const const_ptr = &amp;value;
  // This declaration will be diagnosed and transformed into:
  // int * pointer = nullptr;
  // int value = 42;
  // int * const const_ptr = &amp;value;
}</pre>


<p style="margin-left:11%; margin-top: 1em">The check
excludes places where it is necessary or common to declare
multiple variables in one statement and there is no other
way supported in the language. Please note that structured
bindings are not considered.</p>
<pre style="margin-left:15%; margin-top: 1em">// It is not possible to transform this declaration and doing the declaration
// before the loop will increase the scope of the variable 'Begin' and 'End'
// which is undesirable.
for (int Begin = 0, End = 100; Begin &lt; End; ++Begin);
if (int Begin = 42, Result = some_function(Begin); Begin == Result);


// It is not possible to transform this declaration because the result is
// not functionality preserving as 'j' and 'k' would not be part of the
// 'if' statement anymore.
if (SomeCondition())
  int i = 42, j = 43, k = function(i,j);</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Limitations</b>
<br>
Global variables and member variables are excluded.</p>

<p style="margin-left:11%; margin-top: 1em">The check
currently does not support the automatic transformation of
member&minus;pointer&minus;types.</p>
<pre style="margin-left:15%; margin-top: 1em">struct S {
  int a;
  const int b;
  void f() {}
};


void f() {
  // Only a diagnostic message is emitted
  int S::*p = &amp;S::a, S::*const q = &amp;S::a;
}</pre>


<p style="margin-left:11%; margin-top: 1em">Furthermore,
the transformation is very cautious when it detects various
kinds of macros or preprocessor directives in the range of
the statement. In this case the transformation will not
happen to avoid unexpected side&minus;effects due to
macros.</p>
<pre style="margin-left:15%; margin-top: 1em">#define NULL 0
#define MY_NICE_TYPE int **
#define VAR_NAME(name) name##__LINE__
#define A_BUNCH_OF_VARIABLES int m1 = 42, m2 = 43, m3 = 44;

void macros() {
  int *p1 = NULL, *p2 = NULL;
  // Will be transformed to
  // int *p1 = NULL;
  // int *p2 = NULL;

  MY_NICE_TYPE p3, v1, v2;
  // Won't be transformed, but a diagnostic is emitted.

  int VAR_NAME(v3),
      VAR_NAME(v4),
      VAR_NAME(v5);
  // Won't be transformed, but a diagnostic is emitted.

  A_BUNCH_OF_VARIABLES
  // Won't be transformed, but a diagnostic is emitted.


  int Unconditional,
#if CONFIGURATION
      IfConfigured = 42,
#else
      IfConfigured = 0;
#endif
  // Won't be transformed, but a diagnostic is emitted.
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;magic&minus;numbers</b>
<br>
Detects magic numbers, integer or floating point literals
that are embedded in code and not introduced via constants
or symbols.</p>

<p style="margin-left:11%; margin-top: 1em">Many coding
guidelines advise replacing the magic values with symbolic
constants to improve readability. Here are a few
references:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p style="margin-top: 1em"><i>Rule ES.45: Avoid &quot;magic
constants&quot;; use symbolic constants in C++ Core
Guidelines</i></p> </td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>Rule 5.1.1 Use symbolic names instead of literal
values in code in High Integrity C++</i></p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>Item 17 in &quot;C++ Coding Standards: 101 Rules,
Guidelines and Best Practices&quot; by Herb Sutter and
Andrei Alexandrescu</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>Chapter 17 in &quot;Clean Code &minus; A handbook of
agile software craftsmanship.&quot; by Robert C. Martin</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>Rule 20701 in &quot;TRAIN REAL TIME DATA PROTOCOL Coding
Rules&quot; by Armin&minus;Hagen Weiss, Bombardier</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p><i>http://wiki.c2.com/?MagicNumber</i></p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Examples of
magic values:</p>
<pre style="margin-left:15%; margin-top: 1em">double circleArea = 3.1415926535 * radius * radius;

double totalCharge = 1.08 * itemPrice;

int getAnswer() {
   return &minus;3; // FILENOTFOUND
}


for (int mm = 1; mm &lt;= 12; ++mm) {
   std::cout &lt;&lt; month[mm] &lt;&lt; '\n';
}</pre>


<p style="margin-left:11%; margin-top: 1em">Example with
magic values refactored:</p>
<pre style="margin-left:15%; margin-top: 1em">double circleArea = M_PI * radius * radius;

const double TAX_RATE = 0.08;  // or make it variable and read from a file

double totalCharge = (1.0 + TAX_RATE) * itemPrice;

int getAnswer() {
   return E_FILE_NOT_FOUND;
}


for (int mm = 1; mm &lt;= MONTHS_IN_A_YEAR; ++mm) {
   std::cout &lt;&lt; month[mm] &lt;&lt; '\n';
}</pre>


<p style="margin-left:11%; margin-top: 1em">For integral
literals by default only <i>0</i> and <i>1</i> (and
<i>&minus;1</i>) integer values are accepted without a
warning. This can be overridden with the
<i>IgnoredIntegerValues</i> option. Negative values are
accepted if their absolute value is present in the
<i>IgnoredIntegerValues</i> list.</p>

<p style="margin-left:11%; margin-top: 1em">As a special
case for integral values, all powers of two can be accepted
without warning by enabling the
<i>IgnorePowersOf2IntegerValues</i> option.</p>

<p style="margin-left:11%; margin-top: 1em">For floating
point literals by default the <i>0.0</i> floating point
value is accepted without a warning. The set of ignored
floating point literals can be configured using the
<i>IgnoredFloatingPointValues</i> option. For each value in
that set, the given string value is converted to a
floating&minus;point value representation used by the target
architecture. If a floating&minus;point literal value
compares equal to one of the converted values, then that
literal is not diagnosed by this check. Because
floating&minus;point equality is used to determine whether
to diagnose or not, the user needs to be aware of the
details of floating&minus;point representations for any
values that cannot be precisely represented for their target
architecture.</p>

<p style="margin-left:11%; margin-top: 1em">For each value
in the <i>IgnoredFloatingPointValues</i> set, both the
single&minus;precision form and double&minus;precision form
are accepted (for example, if 3.14 is in the set, neither
3.14f nor 3.14 will produce a warning).</p>

<p style="margin-left:11%; margin-top: 1em">Scientific
notation is supported for both source code input and option.
Alternatively, the check for the floating point numbers can
be disabled for all floating point values by enabling the
<i>IgnoreAllFloatingPointValues</i> option.</p>

<p style="margin-left:11%; margin-top: 1em">Since values
<i>0</i> and <i>0.0</i> are so common as the base counter of
loops, or initialization values for sums, they are always
accepted without warning, even if not present in the
respective ignored values list.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoredIntegerValues</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of magic positive integers that will be accepted without a
warning. Default values are <i>{1, 2, 3, 4}</i>, and
<i>0</i> is accepted unconditionally.</p>


<p style="margin-left:11%;"><b>IgnorePowersOf2IntegerValues</b></p>

<p style="margin-left:22%;">Boolean value indicating
whether to accept all powers&minus;of&minus;two integer
values without warning. Default value is <i>false</i>.</p>


<p style="margin-left:11%;"><b>IgnoredFloatingPointValues</b></p>

<p style="margin-left:22%;">Semicolon&minus;separated list
of magic positive floating point values that will be
accepted without a warning. Default values are <i>{1.0,
100.0}</i> and <i>0.0</i> is accepted unconditionally.</p>


<p style="margin-left:11%;"><b>IgnoreAllFloatingPointValues</b></p>

<p style="margin-left:22%;">Boolean value indicating
whether to accept all floating point values without warning.
Default value is <i>false</i>.</p>


<p style="margin-left:11%;"><b>IgnoreBitFieldsWidths</b></p>

<p style="margin-left:22%;">Boolean value indicating
whether to accept magic numbers as bit field widths without
warning. This is useful for example for register definitions
which are generated from hardware specifications. Default
value is <i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;make&minus;member&minus;function&minus;const</b>
<br>
Finds non&minus;static member functions that can be made
<b>const</b> because the functions don't use <b>this</b> in
a non&minus;const way.</p>

<p style="margin-left:11%; margin-top: 1em">This check
tries to annotate methods according to <i>logical
constness</i> (not physical constness). Therefore, it will
suggest to add a <b>const</b> qualifier to a non&minus;const
method only if this method does something that is already
possible though the public interface on a <b>const</b>
pointer to the object:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p>reading a public member variable</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p>calling a public const&minus;qualified member
function</p> </td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p>returning const&minus;qualified <b>this</b></p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="74%">


<p>passing const&minus;qualified <b>this</b> as a
parameter.</p> </td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This check will
also suggest to add a <b>const</b> qualifier to a
non&minus;const method if this method uses private data and
functions in a limited number of ways where logical
constness and physical constness coincide:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="63%">


<p style="margin-top: 1em">reading a member variable of
builtin type</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Specifically,
this check will not suggest to add a <b>const</b> to a
non&minus;const method if the method reads a private member
variable of pointer type because that allows to modify the
pointee which might not preserve logical constness. For the
same reason, it does not allow to call private member
functions or member functions on private member
variables.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
this check ignores functions that</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">are declared <b>virtual</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>contain a <b>const_cast</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>are templated or part of a class template</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>have an empty body</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>do not (implicitly) use <b>this</b> at all (see
<i>readability&minus;convert&minus;member&minus;functions&minus;to&minus;static</i>).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
real&minus;world examples will be preserved by the
check:</p>
<pre style="margin-left:15%; margin-top: 1em">class E1 {
  Pimpl &amp;getPimpl() const;
public:
  int &amp;get() {
    // Calling a private member function disables this check.
    return getPimpl()&minus;&gt;i;
  }
  ...
};


class E2 {
public:
  const int *get() const;
  // const_cast disables this check.
  S *get() {
    return const_cast&lt;int*&gt;(const_cast&lt;const C*&gt;(this)&minus;&gt;get());
  }
  ...
};</pre>


<p style="margin-left:11%; margin-top: 1em">After applying
modifications as suggested by the check, running the check
again might find more opportunities to mark member functions
<b>const</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;misleading&minus;indentation</b>
<br>
Correct indentation helps to understand code. Mismatch of
the syntactical structure and the indentation of the code
may hide serious problems. Missing braces can also make it
significantly harder to read the code, therefore it is
important to use braces.</p>

<p style="margin-left:11%; margin-top: 1em">The way to
avoid dangling else is to always check that an <b>else</b>
belongs to the <b>if</b> that begins in the same column.</p>

<p style="margin-left:11%; margin-top: 1em">You can omit
braces when your inner part of e.g. an <b>if</b> statement
has only one statement in it. Although in that case you
should begin the next statement in the same column with the
<b>if</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">// Dangling else:
if (cond1)
  if (cond2)
    foo1();
else
  foo2();  // Wrong indentation: else belongs to if(cond2) statement.


// Missing braces:
if (cond1)
  foo1();
  foo2();  // Not guarded by if(cond1).</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Limitations</b>
<br>
Note that this check only works as expected when the tabs or
spaces are used consistently and not mixed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;misplaced&minus;array&minus;index</b>
<br>
This check warns for unusual array index syntax.</p>

<p style="margin-left:11%; margin-top: 1em">The following
code has unusual array index syntax:</p>

<pre style="margin-left:15%; margin-top: 1em">void f(int *X, int Y) {
  Y[X] = 0;
}</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>

<pre style="margin-left:15%; margin-top: 1em">void f(int *X, int Y) {
  X[Y] = 0;
}</pre>


<p style="margin-left:11%;"><b>The check warns about such
unusual syntax for readability reasons:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>There are programmers that are not familiar with this
unusual syntax.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>It is possible that variables are mixed up.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;named&minus;parameter</b>
<br>
Find functions with unnamed arguments.</p>

<p style="margin-left:11%; margin-top: 1em">The check
implements the following rule originating in the Google C++
Style Guide:</p>


<p style="margin-left:11%; margin-top: 1em"><i>https://google.github.io/styleguide/cppguide.html#Function_Declarations_and_Definitions</i></p>

<p style="margin-left:11%; margin-top: 1em">All parameters
should be named, with identical names in the declaration and
implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Corresponding
cpplint.py check name: <i>readability/function</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;non&minus;const&minus;parameter</b>
<br>
The check finds function parameters of a pointer type that
could be changed to point to a constant type instead.</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>const</b> is used properly, many mistakes can be avoided.
Advantages when using <b>const</b> properly:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">prevent unintentional
modification of data;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>get additional warnings such as using uninitialized
data;</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>make it easier for developers to see possible side
effects.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">This check is
not strict about constness, it only warns when the constness
will make the function interface safer.</p>
<pre style="margin-left:15%; margin-top: 1em">// warning here; the declaration &quot;const char *p&quot; would make the function
// interface safer.
char f1(char *p) {
  return *p;
}

// no warning; the declaration could be more const &quot;const int * const p&quot; but
// that does not make the function interface safer.
int f2(const int *p) {
  return *p;
}

// no warning; making x const does not make the function interface safer
int f3(int x) {
  return x;
}

// no warning; Technically, *p can be const (&quot;const struct S *p&quot;). But making
// *p const could be misleading. People might think that it's safe to pass
// const data to this function.
struct S { int *a; int *b; };
int f3(struct S *p) {
  *(p&minus;&gt;a) = 0;
}


// no warning; p is referenced by an lvalue.
void f4(int *p) {
  int &amp;x = *p;
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;qualified&minus;auto</b>
<br>
Adds pointer qualifications to <b>auto</b>&minus;typed
variables that are deduced to pointers.</p>

<p style="margin-left:11%; margin-top: 1em"><i>LLVM Coding
Standards</i> advises to make it obvious if a <b>auto</b>
typed variable is a pointer. This check will transform
<b>auto</b> to <b>auto *</b> when the type is deduced to be
a pointer.</p>

<pre style="margin-left:15%; margin-top: 1em">for (auto Data : MutatablePtrContainer) {
  change(*Data);
}
for (auto Data : ConstantPtrContainer) {
  observe(*Data);
}</pre>


<p style="margin-left:11%; margin-top: 1em">Would be
transformed into:</p>

<pre style="margin-left:15%; margin-top: 1em">for (auto *Data : MutatablePtrContainer) {
  change(*Data);
}
for (const auto *Data : ConstantPtrContainer) {
  observe(*Data);
}</pre>


<p style="margin-left:11%; margin-top: 1em">Note <b>const
volatile</b> qualified types will retain their <b>const</b>
and <b>volatile</b> qualifiers. Pointers to pointers will
not be fully qualified.</p>

<pre style="margin-left:15%; margin-top: 1em">const auto Foo = cast&lt;int *&gt;(Baz1);
const auto Bar = cast&lt;const int *&gt;(Baz2);
volatile auto FooBar = cast&lt;int *&gt;(Baz3);
auto BarFoo = cast&lt;int **&gt;(Baz4);</pre>


<p style="margin-left:11%; margin-top: 1em">Would be
transformed into:</p>

<pre style="margin-left:15%; margin-top: 1em">auto *const Foo = cast&lt;int *&gt;(Baz1);
const auto *const Bar = cast&lt;const int *&gt;(Baz2);
auto *volatile FooBar = cast&lt;int *&gt;(Baz3);
auto *BarFoo = cast&lt;int **&gt;(Baz4);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
AddConstToQualified</b></p>

<p style="margin-left:22%;">When set to <i>true</i> the
check will add const qualifiers variables defined as <b>auto
*</b> or <b>auto &amp;</b> when applicable. Default value is
<i>true</i>.</p>

<pre style="margin-left:15%; margin-top: 1em">auto Foo1 = cast&lt;const int *&gt;(Bar1);
auto *Foo2 = cast&lt;const int *&gt;(Bar2);
auto &amp;Foo3 = cast&lt;const int &amp;&gt;(Bar3);</pre>


<p style="margin-left:11%; margin-top: 1em">If
AddConstToQualified is set to <i>false</i>, it will be
transformed into:</p>

<pre style="margin-left:15%; margin-top: 1em">const auto *Foo1 = cast&lt;const int *&gt;(Bar1);
auto *Foo2 = cast&lt;const int *&gt;(Bar2);
auto &amp;Foo3 = cast&lt;const int &amp;&gt;(Bar3);</pre>


<p style="margin-left:11%; margin-top: 1em">Otherwise it
will be transformed into:</p>

<pre style="margin-left:15%; margin-top: 1em">const auto *Foo1 = cast&lt;const int *&gt;(Bar1);
const auto *Foo2 = cast&lt;const int *&gt;(Bar2);
const auto &amp;Foo3 = cast&lt;const int &amp;&gt;(Bar3);</pre>


<p style="margin-left:11%; margin-top: 1em">Note in the
LLVM alias, the default value is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;access&minus;specifiers</b>
<br>
Finds classes, structs, and unions containing redundant
member (field and method) access specifiers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">class Foo {
public:
  int x;
  int y;
public:
  int z;
protected:
  int a;
public:
  int c;
}</pre>


<p style="margin-left:11%; margin-top: 1em">In the example
above, the second <b>public</b> declaration can be removed
without any changes of behavior.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
CheckFirstDeclaration</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will also diagnose if the first access specifier
declaration is redundant (e.g. <b>private</b> inside
<b>class</b>, or <b>public</b> inside <b>struct</b> or
<b>union</b>). Default is <i>false</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>


<pre style="margin-left:15%;">struct Bar {
public:
  int x;
}</pre>


<p style="margin-left:11%; margin-top: 1em">If
<i>CheckFirstDeclaration</i> option is enabled, a warning
about redundant access specifier will be emitted, because
<b>public</b> is the default member access for structs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;control&minus;flow</b>
<br>
This check looks for procedures (functions returning no
value) with <b>return</b> statements at the end of the
function. Such <b>return</b> statements are redundant.</p>

<p style="margin-left:11%; margin-top: 1em">Loop statements
(<b>for</b>, <b>while</b>, <b>do while</b>) are checked for
redundant <b>continue</b> statements at the end of the loop
body.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">The following
function <i>f</i> contains a redundant <b>return</b>
statement:</p>

<pre style="margin-left:15%; margin-top: 1em">extern void g();
void f() {
  g();
  return;
}</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>

<pre style="margin-left:15%; margin-top: 1em">extern void g();
void f() {
  g();
}</pre>


<p style="margin-left:11%; margin-top: 1em">The following
function <i>k</i> contains a redundant <b>continue</b>
statement:</p>

<pre style="margin-left:15%; margin-top: 1em">void k() {
  for (int i = 0; i &lt; 10; ++i) {
    continue;
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>

<pre style="margin-left:15%; margin-top: 1em">void k() {
  for (int i = 0; i &lt; 10; ++i) {
  }
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;declaration</b>
<br>
Finds redundant variable and function declarations.</p>

<pre style="margin-left:15%; margin-top: 1em">extern int X;
extern int X;</pre>


<p style="margin-left:11%; margin-top: 1em">becomes</p>

<pre style="margin-left:15%; margin-top: 1em">extern int X;</pre>


<p style="margin-left:11%; margin-top: 1em">Such redundant
declarations can be removed without changing program
behavior. They can for instance be unintentional left overs
from previous refactorings when code has been moved around.
Having redundant declarations could in worst case mean that
there are typos in the code that cause bugs.</p>

<p style="margin-left:11%; margin-top: 1em">Normally the
code can be automatically fixed, <b>clang&minus;tidy</b> can
remove the second declaration. However there are 2 cases
when you need to fix the code manually:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>When the declarations are in different header files;</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="80%">


<p>When multiple variables are declared together.</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoreMacros</b></p>

<p style="margin-left:22%;">If set to <i>true</i>, the
check will not give warnings inside macros. Default is
<i>true</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;function&minus;ptr&minus;dereference</b>
<br>
Finds redundant dereferences of a function pointer.</p>

<p style="margin-left:11%; margin-top: 1em">Before:</p>
<pre style="margin-left:15%; margin-top: 1em">int f(int,int);
int (*p)(int, int) = &amp;f;

int i = (**p)(10, 50);</pre>

<p style="margin-left:11%; margin-top: 1em">After:</p>
<pre style="margin-left:15%; margin-top: 1em">int f(int,int);
int (*p)(int, int) = &amp;f;

int i = (*p)(10, 50);</pre>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;member&minus;init</b>
<br>
Finds member initializations that are unnecessary because
the same default constructor would be called if they were
not present.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example</b></p>

<pre style="margin-left:15%;">// Explicitly initializing the member s is unnecessary.
class Foo {
public:
  Foo() : s() {}

private:
  std::string s;
};</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
IgnoreBaseInCopyConstructors</b></p>

<p style="margin-left:22%;">Default is <i>false</i>.</p>

<p style="margin-left:22%; margin-top: 1em">When
<i>true</i>, the check will ignore unnecessary base class
initializations within copy constructors, since some
compilers issue warnings/errors when base classes are not
explicitly initialized in copy constructors. For example,
<b>gcc</b> with <b>&minus;Wextra</b> or
<b>&minus;Werror=extra</b> issues warning or error <b>base
class 'Bar' should be explicitly initialized in the copy
constructor</b> if <b>Bar()</b> were removed in the
following example:</p>

<pre style="margin-left:15%; margin-top: 1em">// Explicitly initializing member s and base class Bar is unnecessary.
struct Foo : public Bar {
  // Remove s() below. If IgnoreBaseInCopyConstructors!=0, keep Bar().
  Foo(const Foo&amp; foo) : Bar(), s() {}
  std::string s;
};</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;preprocessor</b>
<br>
Finds potentially redundant preprocessor directives. At the
moment the following cases are detected:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><i>#ifdef</i> .. <i>#endif</i> pairs which are nested
inside an outer pair with the same condition. For
example:</p> </td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">#ifdef FOO
#ifdef FOO // inner ifdef is considered redundant
void f();
#endif
#endif</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="71%">


<p style="margin-top: 1em">Same for <i>#ifndef</i> ..
<i>#endif</i> pairs. For example:</p></td>
<td width="15%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">#ifndef FOO
#ifndef FOO // inner ifndef is considered redundant
void f();
#endif
#endif</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em"><i>#ifndef</i> inside an
<i>#ifdef</i> with the same condition:</p></td>
<td width="11%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">#ifdef FOO
#ifndef FOO // inner ifndef is considered redundant
void f();
#endif
#endif</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p style="margin-top: 1em"><i>#ifdef</i> inside an
<i>#ifndef</i> with the same condition:</p></td>
<td width="11%">
</td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">#ifndef FOO
#ifdef FOO // inner ifdef is considered redundant
void f();
#endif
#endif</pre>



<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><i>#if</i> .. <i>#endif</i>
pairs which are nested inside an outer pair with the same
condition. For example:</p></td></tr>
</table>

<pre style="margin-left:15%; margin-top: 1em">#define FOO 4
#if FOO == 4
#if FOO == 4 // inner if is considered redundant
void f();
#endif
#endif</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;smartptr&minus;get</b>
<br>
Find and remove redundant calls to smart pointer's
<b>.get()</b> method.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">ptr.get()&minus;&gt;Foo()  ==&gt;  ptr&minus;&gt;Foo()
*ptr.get()  ==&gt;  *ptr
*ptr&minus;&gt;get()  ==&gt;  **ptr
if (ptr.get() == nullptr) ... =&gt; if (ptr == nullptr) ...</pre>


<p style="margin-left:11%;"><b>IgnoreMacros</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about calls inside macros.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;string&minus;cstr</b>
<br>
Finds unnecessary calls to <b>std::string::c_str()</b> and
<b>std::string::data()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;redundant&minus;string&minus;init</b>
<br>
Finds unnecessary string initializations.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Examples</b></p>

<pre style="margin-left:15%;">// Initializing string with empty string literal is unnecessary.
std::string a = &quot;&quot;;
std::string b(&quot;&quot;);

// becomes

std::string a;
std::string b;

// Initializing a string_view with an empty string literal produces an
// instance that compares equal to string_view().
std::string_view a = &quot;&quot;;
std::string_view b(&quot;&quot;);

// becomes
std::string_view a;
std::string_view b;</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
StringNames</b></p>

<p style="margin-left:22%;">Default is
<i>::std::basic_string;::std::basic_string_view</i>.</p>


<p style="margin-left:22%; margin-top: 1em">Semicolon&minus;delimited
list of class names to apply this check to. By default
<i>::std::basic_string</i> applies to <b>std::string</b> and
<b>std::wstring</b>. Set to e.g.
<i>::std::basic_string;llvm::StringRef;QString</i> to
perform this check on custom classes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;simplify&minus;boolean&minus;expr</b>
<br>
Looks for boolean expressions involving boolean constants
and simplifies them to use the appropriate boolean
expression directly. Simplifies boolean expressions by
application of DeMorgan's Theorem.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-30332505.png" alt="Image grohtml-30332505.png"></p>

<p style="margin-left:11%;"><b>The resulting expression e
is modified as follows:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Unnecessary parentheses around the expression are
removed.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Negated applications of <b>!</b> are eliminated.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Negated applications of comparison operators are changed
to use the opposite condition.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>4.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Implicit conversions of pointers, including pointers to
members, to <b>bool</b> are replaced with explicit
comparisons to <b>nullptr</b> in C++11 or <b>NULL</b> in
C++98/03.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>5.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Implicit casts to <b>bool</b> are replaced with explicit
casts to <b>bool</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>6.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Object expressions with <b>explicit operator bool</b>
conversion operators are replaced with explicit casts to
<b>bool</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>7.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Implicit conversions of integral types to <b>bool</b>
are replaced with explicit comparisons to <b>0</b>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>Examples:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="74%">


<p>The ternary assignment <b>bool b = (i &lt; 0) ? true :
false;</b> has redundant parentheses and becomes <b>bool b =
i &lt; 0;</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="74%">


<p>The conditional return <b>if (!b) return false; return
true;</b> has an implied double negation and becomes
<b>return b;</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="74%">


<p>The conditional return <b>if (i &lt; 0) return false;
return true;</b> becomes <b>return i &gt;= 0;</b>.</p></td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">The conditional
return <b>if (i != 0) return false; return true;</b> becomes
<b>return i == 0;</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="1%"></td>
<td width="74%">


<p style="margin-top: 1em">The conditional return <b>if (p)
return true; return false;</b> has an implicit conversion of
a pointer to <b>bool</b> and becomes <b>return p !=
nullptr;</b>.</p> </td></tr>
</table>

<p style="margin-left:26%; margin-top: 1em">The ternary
assignment <b>bool b = (i &amp; 1) ? true : false;</b> has
an implicit conversion of <b>i &amp; 1</b> to <b>bool</b>
and becomes <b>bool b = (i &amp; 1) != 0;</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p style="margin-top: 1em">5.</p></td>
<td width="1%"></td>
<td width="74%">


<p style="margin-top: 1em">The conditional return <b>if (i
&amp; 1) return true; else return false;</b> has an implicit
conversion of an integer quantity <b>i &amp; 1</b> to
<b>bool</b> and becomes <b>return (i &amp; 1) != 0;</b></p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>6.</p></td>
<td width="1%"></td>
<td width="74%">


<p>Given <b>struct X { explicit operator bool(); };</b>,
and an instance <b>x</b> of <b>struct X</b>, the conditional
return <b>if (x) return true; return false;</b> becomes
<b>return static_cast&lt;bool&gt;(x);</b></p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
ChainedConditionalReturn</b></p>

<p style="margin-left:22%;">If <i>true</i>, conditional
boolean return statements at the end of an <b>if/else if</b>
chain will be transformed. Default is <i>false</i>.</p>


<p style="margin-left:11%;"><b>ChainedConditionalAssignment</b></p>

<p style="margin-left:22%;">If <i>true</i>, conditional
boolean assignments at the end of an <b>if/else if</b> chain
will be transformed. Default is <i>false</i>.</p>

<p style="margin-left:11%;"><b>SimplifyDeMorgan</b></p>

<p style="margin-left:22%;">If <i>true</i>, DeMorgan's
Theorem will be applied to simplify negated conjunctions and
disjunctions. Default is <i>true</i>.</p>


<p style="margin-left:11%;"><b>SimplifyDeMorganRelaxed</b></p>

<p style="margin-left:22%;">If <i>true</i>,
<i>SimplifyDeMorgan</i> will also transform negated
conjunctions and disjunctions where there is no negation on
either operand. This option has no effect if
<i>SimplifyDeMorgan</i> is <i>false</i>. Default is
<i>false</i>.</p>

<p style="margin-left:22%; margin-top: 1em">When
Enabled:</p>

<pre style="margin-left:26%; margin-top: 1em">bool X = !(A &amp;&amp; B)
bool Y = !(A || B)</pre>


<p style="margin-left:22%; margin-top: 1em">Would be
transformed to:</p>

<pre style="margin-left:26%; margin-top: 1em">bool X = !A || !B
bool Y = !A &amp;&amp; !B</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;simplify&minus;subscript&minus;expr</b>
<br>
This check simplifies subscript expressions. Currently this
covers calling <b>.data()</b> and immediately doing an array
subscript operation to obtain a single element, in which
case simply calling <b>operator[]</b> suffice.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<pre style="margin-left:15%; margin-top: 1em">std::string s = ...;
char c = s.data()[i];  // char c = s[i];</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Options</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>Types</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>The list of type(s) that triggers this check. Default is
<i>::std::basic_string;::std::basic_string_view;::std::vector;::std::array</i></p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;static&minus;accessed&minus;through&minus;instance</b>
<br>
Checks for member expressions that access static members
through instances, and replaces them with uses of the
appropriate qualified&minus;id.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:11%; margin-top: 1em">The following
code:</p>
<pre style="margin-left:15%; margin-top: 1em">struct C {
  static void foo();
  static int x;
};

C *c1 = new C();
c1&minus;&gt;foo();
c1&minus;&gt;x;</pre>

<p style="margin-left:11%; margin-top: 1em">is changed
to:</p>

<pre style="margin-left:15%; margin-top: 1em">C *c1 = new C();
C::foo();
C::x;</pre>



<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;static&minus;definition&minus;in&minus;anonymous&minus;namespace</b>
<br>
Finds static function and variable definitions in anonymous
namespace.</p>

<p style="margin-left:11%; margin-top: 1em">In this case,
<b>static</b> is redundant, because anonymous namespace
limits the visibility of definitions to a single translation
unit.</p>

<pre style="margin-left:15%; margin-top: 1em">namespace {
  static int a = 1; // Warning.
  static const int b = 1; // Warning.
  namespace inner {
    static int c = 1; // Warning.
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">The check will
apply a fix by removing the redundant <b>static</b>
qualifier.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;string&minus;compare</b>
<br>
Finds string comparisons using the compare method.</p>

<p style="margin-left:11%; margin-top: 1em">A common
mistake is to use the string's <b>compare</b> method instead
of using the equality or inequality operators. The compare
method is intended for sorting functions and thus returns a
negative number, a positive number or zero depending on the
lexicographical relationship between the strings compared.
If an equality or inequality check can suffice, that is
recommended. This is recommended to avoid the risk of
incorrect interpretation of the return value and to simplify
the code. The string equality and inequality operators can
also be faster than the <b>compare</b> method due to early
termination.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>
<pre style="margin-left:15%; margin-top: 1em">std::string str1{&quot;a&quot;};
std::string str2{&quot;b&quot;};

// use str1 != str2 instead.
if (str1.compare(str2)) {
}

// use str1 == str2 instead.
if (!str1.compare(str2)) {
}

// use str1 == str2 instead.
if (str1.compare(str2) == 0) {
}

// use str1 != str2 instead.
if (str1.compare(str2) != 0) {
}

// use str1 == str2 instead.
if (0 == str1.compare(str2)) {
}

// use str1 != str2 instead.
if (0 != str1.compare(str2)) {
}


// Use str1 == &quot;foo&quot; instead.
if (str1.compare(&quot;foo&quot;) == 0) {
}</pre>


<p style="margin-left:11%; margin-top: 1em">The above code
examples show the list of if&minus;statements that this
check will give a warning for. All of them uses
<b>compare</b> to check if equality or inequality of two
strings instead of using the correct operators.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;suspicious&minus;call&minus;argument</b>
<br>
Finds function calls where the arguments passed are provided
out of order, based on the difference between the argument
name and the parameter names of the function.</p>

<p style="margin-left:11%; margin-top: 1em">Given a
function call <b>f(foo, bar);</b> and a function signature
<b>void f(T tvar, U uvar)</b>, the arguments <b>foo</b> and
<b>bar</b> are swapped if <b>foo</b> (the argument name) is
more similar to <b>uvar</b> (the other parameter) than
<b>tvar</b> (the parameter it is currently passed to) <b>and
bar</b> is more similar to <b>tvar</b> than <b>uvar</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Warnings might
indicate either that the arguments are swapped, or that the
names' cross&minus;similarity might hinder code
comprehension.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Heuristics</b>
<br>
The following heuristics are implemented in the check. If
<b>any</b> of the enabled heuristics deem the arguments to
be provided out of order, a warning will be issued.</p>

<p style="margin-left:11%; margin-top: 1em">The heuristics
themselves are implemented by considering pairs of strings,
and are symmetric, so in the following there is no
distinction on which string is the argument name and which
string is the parameter name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Equality</b>
<br>
The most trivial heuristic, which compares the two strings
for case&minus;insensitive equality.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Abbreviation</b>
<br>
Common abbreviations can be specified which will deem the
strings similar if the abbreviated and the abbreviation
stand together. For example, if <b>src</b> is registered as
an abbreviation for <b>source</b>, then the following code
example will be warned about.</p>
<pre style="margin-left:15%; margin-top: 1em">void foo(int source, int x);

foo(b, src);</pre>

<p style="margin-left:11%; margin-top: 1em">The
abbreviations to recognise can be configured with the
<i>Abbreviations</i> check option. This heuristic is
case&minus;insensitive.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Prefix</b>
<br>
The <i>prefix</i> heuristic reports if one of the strings is
a sufficiently long prefix of the other string, e.g.
<b>target</b> to <b>targetPtr</b>. The similarity percentage
is the length ratio of the prefix to the longer string, in
the previous example, it would be <i>6 / 9 =
66.66...</i>%.</p>

<p style="margin-left:11%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>25</i>% dissimilar and above <i>30</i>%
similar. This heuristic is case&minus;insensitive.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Suffix</b>
<br>
Analogous to the <i>Prefix</i> heuristic. In the case of
<b>oldValue</b> and <b>value</b> compared, the similarity
percentage is <i>8 / 5 = 62.5</i>%.</p>

<p style="margin-left:11%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>25</i>% dissimilar and above <i>30</i>%
similar. This heuristic is case&minus;insensitive.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Substring</b>
<br>
The substring heuristic combines the prefix and the suffix
heuristic, and tries to find the <i>longest common
substring</i> in the two strings provided. The similarity
percentage is the ratio of the found longest common
substring against the <i>longer</i> of the two input
strings. For example, given <b>val</b> and <b>rvalue</b>,
the similarity is <i>3 / 6 = 50</i>%. If no characters are
common in the two string, <i>0</i>%.</p>

<p style="margin-left:11%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>40</i>% dissimilar and above <i>50</i>%
similar. This heuristic is case&minus;insensitive.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Levenshtein
distance (as</b> <i>Levenshtein</i><b>)</b> <br>
The <i>Levenshtein distance</i> describes how many
single&minus;character changes (additions, changes, or
removals) must be applied to transform one string into
another.</p>

<p style="margin-left:11%; margin-top: 1em">The Levenshtein
distance is translated into a similarity percentage by
dividing it with the length of the <i>longer</i> string, and
taking its complement with regards to <i>100</i>%. For
example, given <b>something</b> and <b>anything</b>, the
distance is <i>4</i> edits, and the similarity percentage is
<i>100</i>% <i>&minus; 4 / 9 = 55.55...</i>%.</p>

<p style="margin-left:11%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>50</i>% dissimilar and above <i>66</i>%
similar. This heuristic is case&minus;sensitive.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Jaro&minus;&minus;Winkler
distance (as</b> <i>JaroWinkler</i><b>)</b> <br>
The <i>Jaro&minus;&minus;Winkler distance</i> is an edit
distance like the Levenshtein distance. It is calculated
from the amount of common characters that are sufficiently
close to each other in position, and
to&minus;be&minus;changed characters. The original
definition of Jaro has been extended by Winkler to weigh
prefix similarities more. The similarity percentage is
expressed as an average of the common and non&minus;common
characters against the length of both strings.</p>

<p style="margin-left:11%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>75</i>% dissimilar and above <i>85</i>%
similar. This heuristic is case&minus;insensitive.</p>


<p style="margin-left:11%; margin-top: 1em"><b>S&Atilde;&cedil;rensen&minus;&minus;Dice
coefficient (as</b> <i>Dice</i><b>)</b> <br>
The <i>S&Atilde;&cedil;rensen&minus;&minus;Dice
coefficient</i> was originally defined to measure the
similarity of two sets. Formally, the coefficient is
calculated by dividing <i>2 * #(intersection)</i> with
<i>#(set1) + #(set2)</i>, where <i>#()</i> is the
cardinality function of sets. This metric is applied to
strings by creating bigrams (substring sequences of length
2) of the two strings and using the set of bigrams for the
two strings as the two sets.</p>

<p style="margin-left:11%; margin-top: 1em">This heuristic
can be configured with <i>bounds</i>. The default bounds
are: below <i>60</i>% dissimilar and above <i>70</i>%
similar. This heuristic is case&minus;insensitive.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
MinimumIdentifierNameLength</b></p>

<p style="margin-left:22%;">Sets the minimum required
length the argument and parameter names need to have. Names
shorter than this length will be ignored. Defaults to
<i>3</i>.</p>

<p style="margin-left:11%;"><b>Abbreviations</b></p>

<p style="margin-left:22%;">For the <b>Abbreviation</b>
heuristic (<i>see here</i>), this option configures the
abbreviations in the
<i>&quot;abbreviation=abbreviated_value&quot;</i> format.
The option is a string, with each value joined by
<i>&quot;;&quot;</i>.</p>

<p style="margin-left:22%; margin-top: 1em">By default, the
following abbreviations are set:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>addr=address</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>arr=array</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>attr=attribute</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>buf=buffer</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>cl=client</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>cnt=count</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>col=column</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>cpy=copy</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>dest=destination</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>dist=distance</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>dst=distance</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>elem=element</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>hght=height</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>i=index</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>idx=index</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>len=length</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>ln=line</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>lst=list</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>nr=number</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>num=number</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>pos=position</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>ptr=pointer</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>ref=reference</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>src=source</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>srv=server</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>stmt=statement</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>str=string</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>val=value</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>var=variable</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>vec=vector</i></p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="25%">


<p><i>wdth=width</i></p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
configuration options for each implemented heuristic (see
above) is constructed dynamically. In the following,
<i>&lt;HeuristicName&gt;</i> refers to one of the keys from
the heuristics implemented. <b><br>
&lt;HeuristicName&gt;</b></p>

<p style="margin-left:22%;"><i>True</i> or <i>False</i>,
whether a particular heuristic, such as <i>Equality</i> or
<i>Levenshtein</i> is enabled.</p>

<p style="margin-left:22%; margin-top: 1em">Defaults to
<i>True</i> for every heuristic.</p>


<p style="margin-left:11%;"><b>&lt;HeuristicName&gt;DissimilarBelow,
&lt;HeuristicName&gt;SimilarAbove</b></p>

<p style="margin-left:22%;">A value between <i>0</i> and
<i>100</i>, expressing a percentage. The bounds set what
percentage of similarity the heuristic must deduce for the
two identifiers to be considered similar or dissimilar by
the check.</p>

<p style="margin-left:22%; margin-top: 1em">Given arguments
<b>arg1</b> and <b>arg2</b> passed to <b>param1</b> and
<b>param2</b>, respectively, the bounds check is performed
in the following way: If the similarity of the currently
passed argument order (<b>arg1</b> to <b>param1</b>) is
<b>below</b> the <i>DissimilarBelow</i> threshold, and the
similarity of the suggested swapped order (<b>arg1</b> to
<b>param2</b>) is <b>above</b> the <i>SimilarAbove</i>
threshold, the swap is reported.</p>

<p style="margin-left:22%; margin-top: 1em">For the
defaults of each heuristic, <i>see above</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Name
synthesis</b> <br>
When comparing the argument names and parameter names, the
following logic is used to gather the names for
comparison:</p>

<p style="margin-left:11%; margin-top: 1em">Parameter names
are the identifiers as written in the source code.</p>

<p style="margin-left:11%; margin-top: 1em">Argument names
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>If a variable is passed, the variable's name.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>If a subsequent function call's return value is used as
argument, the called function's name.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="1%"></td>
<td width="82%">


<p>Otherwise, empty string.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Empty argument
or parameter names are ignored by the heuristics.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;uniqueptr&minus;delete&minus;release</b>
<br>
Replace <b>delete &lt;unique_ptr&gt;.release()</b> with
<b>&lt;unique_ptr&gt; = nullptr</b>. The latter is shorter,
simpler and does not require use of raw pointer APIs.</p>
<pre style="margin-left:15%; margin-top: 1em">std::unique_ptr&lt;int&gt; P;
delete P.release();

// becomes

std::unique_ptr&lt;int&gt; P;
P = nullptr;</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
PreferResetCall</b></p>

<p style="margin-left:22%;">If <i>true</i>, refactor by
calling the reset member function instead of assigning to
<b>nullptr</b>. Default value is <i>false</i>.</p>
<pre style="margin-left:26%; margin-top: 1em">std::unique_ptr&lt;int&gt; P;
delete P.release();

// becomes

std::unique_ptr&lt;int&gt; P;
P.reset();</pre>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;uppercase&minus;literal&minus;suffix</b>
<i><br>
cert&minus;dcl16&minus;c</i> redirects here as an alias for
this check. By default, only the suffixes that begin with
<b>l</b> (<b>l</b>, <b>ll</b>, <b>lu</b>, <b>llu</b>, but
not <b>u</b>, <b>ul</b>, <b>ull</b>) are diagnosed by that
alias.</p>


<p style="margin-left:11%; margin-top: 1em"><i>hicpp&minus;uppercase&minus;literal&minus;suffix</i>
redirects here as an alias for this check.</p>

<p style="margin-left:11%; margin-top: 1em">Detects when
the integral literal or floating point (decimal or
hexadecimal) literal has a non&minus;uppercase suffix and
provides a fix&minus;it hint with the uppercase suffix.</p>

<p style="margin-left:11%; margin-top: 1em">All valid
combinations of suffixes are supported.</p>
<pre style="margin-left:15%; margin-top: 1em">auto x = 1;  // OK, no suffix.

auto x = 1u; // warning: integer literal suffix 'u' is not upper&minus;case

auto x = 1U; // OK, suffix is uppercase.

...</pre>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
NewSuffixes</b></p>

<p style="margin-left:22%;">Optionally, a list of the
destination suffixes can be provided. When the suffix is
found, a case&minus;insensitive lookup in that list is made,
and if a replacement is found that is different from the
current suffix, then the diagnostic is issued. This allows
for fine&minus;grained control of what suffixes to consider
and what their replacements should be.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
Given a list <i>L;uL</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><b>l</b> &minus;&gt; <b>L</b></p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><b>L</b> will be kept as is.</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><b>ul</b> &minus;&gt; <b>uL</b></p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><b>Ul</b> &minus;&gt; <b>uL</b></p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><b>UL</b> &minus;&gt; <b>uL</b></p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><b>uL</b> will be kept as is.</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><b>ull</b> will be kept as is, since it is not in the
list</p> </td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p>and so on.</p></td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>IgnoreMacros</b></p>

<p style="margin-left:22%;">If this option is set to
<i>true</i> (default is <i>true</i>), the check will not
warn about literal suffixes inside macros.</p>


<p style="margin-left:11%; margin-top: 1em"><b>readability&minus;use&minus;anyofallof</b>
<br>
Finds range&minus;based for loops that can be replaced by a
call to <b>std::any_of</b> or <b>std::all_of</b>. In C++ 20
mode, suggests <b>std::ranges::any_of</b> or
<b>std::ranges::all_of</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<pre style="margin-left:15%; margin-top: 1em">bool all_even(std::vector&lt;int&gt; V) {
  for (int I : V) {
    if (I % 2)
      return false;
  }
  return true;
  // Replace loop by
  // return std::ranges::all_of(V, [](int I) { return I % 2 == 0; });
}</pre>



<p style="margin-left:11%; margin-top: 1em"><b>zircon&minus;temporary&minus;objects</b>
<br>
Warns on construction of specific temporary objects in the
Zircon kernel. If the object should be flagged, If the
object should be flagged, the fully qualified type name must
be explicitly passed to the check.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
given the list of classes &quot;Foo&quot; and
&quot;NS::Bar&quot;, all of the following will trigger the
warning:</p>
<pre style="margin-left:15%; margin-top: 1em">Foo();
Foo F = Foo();
func(Foo());

namespace NS {

Bar();

}</pre>

<p style="margin-left:11%; margin-top: 1em">With the same
list, the following will not trigger the warning:</p>
<pre style="margin-left:15%; margin-top: 1em">Foo F;                 // Non&minus;temporary construction okay
Foo F(param);          // Non&minus;temporary construction okay
Foo *F = new Foo();    // New construction okay


Bar();                 // Not NS::Bar, so okay
NS::Bar B;             // Non&minus;temporary construction okay</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
objects must be explicitly specified in order to be flagged,
and so objects that inherit a specified object will not be
flagged.</p>

<p style="margin-left:11%; margin-top: 1em">This check
matches temporary objects without regard for inheritance and
so a prohibited base class type does not similarly prohibit
derived class types.</p>

<pre style="margin-left:15%; margin-top: 1em">class Derived : Foo {} // Derived is not explicitly disallowed
Derived();             // and so temporary construction is okay</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Options</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>Names</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>A semi&minus;colon&minus;separated list of
fully&minus;qualified names of C++ classes that should not
be constructed as temporaries. Default is empty.</p></td></tr>
</table>


<p align="center" style="margin-top: 1em"><img src="grohtml-30332506.png" alt="Image grohtml-30332506.png"></p>

<p style="margin-left:11%;"><b>Aliases..</b></p>


<p align="center"><b><img src="grohtml-30332507.png" alt="Image grohtml-30332507.png"></b></p>

<p style="margin-left:11%;"><b>Clang&minus;tidy IDE/Editor
Integrations</b> <br>
Apart from being a standalone tool, <b>clang&minus;tidy</b>
is integrated into various IDEs, code analyzers, and
editors. We recommend using <i>clangd</i> which integrates
<b>clang&minus;tidy</b> and <i>is available</i> in most
major editors through plugins (Vim, Emacs, Visual Studio
Code, Sublime Text and <i>more</i>).</p>

<p style="margin-left:11%; margin-top: 1em">The following
table shows the most well&minus;known
<b>clang&minus;tidy</b> integrations in detail.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-30332508.png" alt="Image grohtml-30332508.png"></p>

<p style="margin-left:11%;"><b>IDEs</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>CLion</i>
2017.2 and later <i>integrates clang&minus;tidy</i> as an
extension to the built&minus;in code analyzer. Starting from
2018.2 EAP, CLion allows using <b>clang&minus;tidy</b> via
Clangd. Inspections and applicable quick&minus;fixes are
performed on the fly, and checks can be configured in
standard command line format. In this integration, you can
switch to the <b>clang&minus;tidy</b> binary different from
the bundled one, pass the configuration in
<b>.clang&minus;tidy</b> files instead of using the IDE
settings, and configure options for particular checks.</p>


<p style="margin-left:11%; margin-top: 1em"><i>KDevelop</i>
with the <i>kdev&minus;clang&minus;tidy</i> plugin, starting
from version 5.1, performs static analysis using
<b>clang&minus;tidy</b>. The plugin launches the
<b>clang&minus;tidy</b> binary from the specified location
and parses its output to provide a list of issues.</p>


<p style="margin-left:11%; margin-top: 1em"><i>QtCreator</i>
4.6 integrates <b>clang&minus;tidy</b> warnings into the
editor diagnostics under the <i>Clang Code Model</i>. To
employ <b>clang&minus;tidy</b> inspection in QtCreator, you
need to create a copy of one of the presets and choose the
checks to be performed. Since QtCreator 4.7
project&minus;wide analysis is possible with the <i>Clang
Tools</i> analyzer.</p>

<p style="margin-left:11%; margin-top: 1em"><i>MS Visual
Studio</i> has a native <i>clang&minus;tidy&minus;vs</i>
plugin and also can integrate <b>clang&minus;tidy</b> by
means of three other tools. The <i>ReSharper C++</i>
extension, version 2017.3 and later, provides seamless
<b>clang&minus;tidy</b> integration: checks and
quick&minus;fixes run alongside native inspections. Apart
from that, ReSharper C++ incorporates
<b>clang&minus;tidy</b> as a separate step of its code
clean&minus;up process. <i>Visual Assist</i> build 2210
includes a subset of <b>clang&minus;tidy</b> checklist to
inspect the code as you edit. Another way to bring
<b>clang&minus;tidy</b> functionality to Visual Studio is
the <i>Clang Power Tools</i> plugin, which includes most of
the <b>clang&minus;tidy</b> checks and runs them during
compilation or as a separate step of code analysis.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Editors</b></p>


<p style="margin-left:11%; margin-top: 1em"><i>Emacs24</i>,
when expanded with the <i>Flycheck</i> plugin, incorporates
the <b>clang&minus;tidy</b> inspection into the syntax
analyzer. For <i>Vim</i>, you can use <i>Syntastic</i>,
which includes <b>clang&minus;tidy</b>, or <i>A.L.E.</i>, a
lint engine that applies <b>clang&minus;tidy</b> along with
other linters.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Analyzers</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;tidy</b>
is integrated in <i>CPPDepend</i> starting from version
2018.1 and <i>CPPCheck</i> 1.82. CPPCheck integration lets
you import Visual Studio solutions and run the
<b>clang&minus;tidy</b> inspection on them. The
<i>CodeChecker</i> application of version 5.3 or later,
which also comes as a <i>plugin</i> for Eclipse, supports
<b>clang&minus;tidy</b> as a static analysis instrument and
allows to use a custom <b>clang&minus;tidy</b> binary.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Getting
Involved <br>
clang&minus;tidy</b> has several own checks and can run
Clang static analyzer checks, but its power is in the
ability to easily write custom checks.</p>

<p style="margin-left:11%; margin-top: 1em">Checks are
organized in modules, which can be linked into
<b>clang&minus;tidy</b> with minimal or no code changes in
<b>clang&minus;tidy</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Checks can plug
into the analysis on the preprocessor level using
<i>PPCallbacks</i> or on the AST level using <i>AST
Matchers</i>. When an error is found, checks can report them
in a way similar to how Clang diagnostics work. A
fix&minus;it hint can be attached to a diagnostic
message.</p>

<p style="margin-left:11%; margin-top: 1em">The interface
provided by <b>clang&minus;tidy</b> makes it easy to write
useful and precise checks in just a few lines of code. If
you have an idea for a good check, the rest of this document
explains how to do this. <b><br>
There are a few tools particularly useful when developing
clang&minus;tidy <br>
checks:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>add_new_check.py</b> is a script to automate the
process of adding a new check, it will create the check,
update the CMake file and create a test;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>rename_check.py</b> does what the script name
suggests, renames an existing check;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>pp&minus;trace</b> logs method calls on
<i>PPCallbacks</i> for a source file and is invaluable in
understanding the preprocessor mechanism;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><b>clang&minus;query</b> is invaluable for interactive
prototyping of AST matchers and exploration of the Clang
AST;</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p><i>clang&minus;check</i> with the
<b>&minus;ast&minus;dump</b> (and optionally
<b>&minus;ast&minus;dump&minus;filter</b>) provides a
convenient way to dump AST of a C++ program.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If CMake is
configured with <b>CLANG_TIDY_ENABLE_STATIC_ANALYZER=NO</b>,
<b>clang&minus;tidy</b> will not be built with support for
the <b>clang&minus;analyzer&minus;*</b> checks or the
<b>mpi&minus;*</b> checks.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Choosing the
Right Place for your Check</b> <br>
If you have an idea of a check, you should decide whether it
should be implemented as a:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><i>Clang diagnostic</i>: if the
check is generic enough, targets code patterns that most
probably are bugs (rather than style or readability issues),
can be implemented effectively and with extremely low false
positive rate, it may make a good Clang diagnostic.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><i>Clang static analyzer check</i>: if the check
requires some sort of control flow analysis, it should
probably be implemented as a static analyzer check.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><i>clang&minus;tidy check</i> is a good choice for
linter&minus;style checks, checks that are related to a
certain coding style, checks that address code readability,
etc.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Preparing
your Workspace</b> <br>
If you are new to LLVM development, you should read the
<i>Getting Started with the LLVM System</i>, <i>Using Clang
Tools</i> and <i>How To Setup Clang Tooling For LLVM</i>
documents to check out and build LLVM, Clang and Clang Extra
Tools with CMake.</p>

<p style="margin-left:11%; margin-top: 1em">Once you are
done, change to the
<b>llvm/clang&minus;tools&minus;extra</b> directory, and
let's start!</p>

<p style="margin-left:11%; margin-top: 1em">When you
<i>configure the CMake build</i>, make sure that you enable
the <b>clang</b> and <b>clang&minus;tools&minus;extra</b>
projects to build <b>clang&minus;tidy</b>. Because your new
check will have associated documentation, you will also want
to install <i>Sphinx</i> and enable it in the CMake
configuration. To save build time of the core Clang
libraries you may want to only enable the <b>X86</b> target
in the CMake configuration.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
Directory Structure <br>
clang&minus;tidy</b> source code resides in the
<b>llvm/clang&minus;tools&minus;extra</b> directory and is
structured as follows:</p>

<pre style="margin-left:15%; margin-top: 1em">clang&minus;tidy/                       # Clang&minus;tidy core.
|&minus;&minus; ClangTidy.h                   # Interfaces for users.
|&minus;&minus; ClangTidyCheck.h              # Interfaces for checks.
|&minus;&minus; ClangTidyModule.h             # Interface for clang&minus;tidy modules.
|&minus;&minus; ClangTidyModuleRegistry.h     # Interface for registering of modules.
   ...
|&minus;&minus; google/                       # Google clang&minus;tidy module.
|&minus;+
  |&minus;&minus; GoogleTidyModule.cpp
  |&minus;&minus; GoogleTidyModule.h
        ...
|&minus;&minus; llvm/                         # LLVM clang&minus;tidy module.
|&minus;+
  |&minus;&minus; LLVMTidyModule.cpp
  |&minus;&minus; LLVMTidyModule.h
        ...
|&minus;&minus; objc/                         # Objective&minus;C clang&minus;tidy module.
|&minus;+
  |&minus;&minus; ObjCTidyModule.cpp
  |&minus;&minus; ObjCTidyModule.h
        ...
|&minus;&minus; tool/                         # Sources of the clang&minus;tidy binary.
        ...
test/clang&minus;tidy/                  # Integration tests.
    ...
unittests/clang&minus;tidy/             # Unit tests.
|&minus;&minus; ClangTidyTest.h
|&minus;&minus; GoogleModuleTest.cpp
|&minus;&minus; LLVMModuleTest.cpp
|&minus;&minus; ObjCModuleTest.cpp
    ...</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Writing a
clang&minus;tidy Check</b> <br>
So you have an idea of a useful check for
<b>clang&minus;tidy</b>.</p>

<p style="margin-left:11%; margin-top: 1em">First, if
you're not familiar with LLVM development, read through the
<i>Getting Started with LLVM</i> document for instructions
on setting up your workflow and the <i>LLVM Coding
Standards</i> document to familiarize yourself with the
coding style used in the project. For code reviews we mostly
use <i>LLVM Phabricator</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Next, you need
to decide which module the check belongs to. Modules are
located in subdirectories of <i>clang&minus;tidy/</i> and
contain checks targeting a certain aspect of code quality
(performance, readability, etc.), certain coding style or
standard (Google, LLVM, CERT, etc.) or a widely used API
(e.g. MPI). Their names are the same as the
user&minus;facing check group names described
<i>above</i>.</p>

<p style="margin-left:11%; margin-top: 1em">After choosing
the module and the name for the check, run the
<b>clang&minus;tidy/add_new_check.py</b> script to create
the skeleton of the check and plug it to
<b>clang&minus;tidy</b>. It's the recommended way of adding
new checks.</p>

<p style="margin-left:11%; margin-top: 1em">If we want to
create a
<i>readability&minus;awesome&minus;function&minus;names</i>,
we would run:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;tidy/add_new_check.py readability awesome&minus;function&minus;names</pre>


<p style="margin-left:11%;"><b>The add_new_check.py script
will:</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>create the class for your check inside the specified
module's directory and register it in the module and in the
build system;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>create a lit test file in the
<b>test/clang&minus;tidy/</b> directory;</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="75%">


<p>create a documentation file and include it into the
<b>docs/clang&minus;tidy/checks/list.rst</b>.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Let's see in
more detail at the check class definition:</p>
<pre style="margin-left:15%; margin-top: 1em">...

#include &quot;../ClangTidyCheck.h&quot;

namespace clang {
namespace tidy {
namespace readability {

...
class AwesomeFunctionNamesCheck : public ClangTidyCheck {
public:
  AwesomeFunctionNamesCheck(StringRef Name, ClangTidyContext *Context)
      : ClangTidyCheck(Name, Context) {}
  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
  void check(const ast_matchers::MatchFinder::MatchResult &amp;Result) override;
};

} // namespace readability
} // namespace tidy
} // namespace clang

...</pre>

<p style="margin-left:11%; margin-top: 1em">Constructor of
the check receives the <b>Name</b> and <b>Context</b>
parameters, and must forward them to the
<b>ClangTidyCheck</b> constructor.</p>

<p style="margin-left:11%; margin-top: 1em">In our case the
check needs to operate on the AST level and it overrides the
<b>registerMatchers</b> and <b>check</b> methods. If we
wanted to analyze code on the preprocessor level, we'd need
instead to override the <b>registerPPCallbacks</b>
method.</p>

<p style="margin-left:11%; margin-top: 1em">In the
<b>registerMatchers</b> method we create an AST Matcher (see
<i>AST Matchers</i> for more information) that will find the
pattern in the AST that we want to inspect. The results of
the matching are passed to the <b>check</b> method, which
can further inspect them and report diagnostics.</p>
<pre style="margin-left:15%; margin-top: 1em">using namespace ast_matchers;

void AwesomeFunctionNamesCheck::registerMatchers(MatchFinder *Finder) {
  Finder&minus;&gt;addMatcher(functionDecl().bind(&quot;x&quot;), this);
}


void AwesomeFunctionNamesCheck::check(const MatchFinder::MatchResult &amp;Result) {
  const auto *MatchedDecl = Result.Nodes.getNodeAs&lt;FunctionDecl&gt;(&quot;x&quot;);
  if (!MatchedDecl&minus;&gt;getIdentifier() || MatchedDecl&minus;&gt;getName().startswith(&quot;awesome_&quot;))
    return;
  diag(MatchedDecl&minus;&gt;getLocation(), &quot;function %0 is insufficiently awesome&quot;)
      &lt;&lt; MatchedDecl
      &lt;&lt; FixItHint::CreateInsertion(MatchedDecl&minus;&gt;getLocation(), &quot;awesome_&quot;);
}</pre>


<p style="margin-left:11%; margin-top: 1em">(If you want to
see an example of a useful check, look at
<i>clang&minus;tidy/google/ExplicitConstructorCheck.h</i>
and
<i>clang&minus;tidy/google/ExplicitConstructorCheck.cpp</i>).</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
interact with macros or preprocessor directives, you will
want to override the method <b>registerPPCallbacks</b>. The
<b>add_new_check.py</b> script does not generate an override
for this method in the starting point for your new
check.</p>

<p style="margin-left:11%; margin-top: 1em">If your check
applies only under a specific set of language options, be
sure to override the method
<b>isLanguageVersionSupported</b> to reflect that.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Check
development tips</b> <br>
Writing your first check can be a daunting task,
particularly if you are unfamiliar with the LLVM and Clang
code bases. Here are some suggestions for orienting yourself
in the codebase and working on your check incrementally.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Guide to
useful documentation</b> <br>
Many of the support classes created for LLVM are used by
Clang, such as <i>StringRef</i> and <i>SmallVector</i>.
These and other commonly used classes are described in the
<i>Important and useful LLVM APIs</i> and <i>Picking the
Right Data Structure for the Task</i> sections of the
<i>LLVM Programmer's Manual</i>. You don't need to memorize
all the details of these classes; the generated <i>doxygen
documentation</i> has everything if you need it. In the
header <i>LLVM/ADT/STLExtras.h</i> you'll find useful
versions of the STL algorithms that operate on LLVM
containers, such as <i>llvm::all_of</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Clang is
implemented on top of LLVM and introduces its own set of
classes that you will interact with while writing your
check. When a check issues diagnostics and fix&minus;its,
these are associated with locations in the source code.
Source code locations, source files, ranges of source
locations and the <i>SourceManager</i> class provide the
mechanisms for describing such locations. These and other
topics are described in the <i>&quot;Clang&quot; CFE
Internals Manual</i>. Whereas the doxygen generated
documentation serves as a reference to the internals of
Clang, this document serves as a guide to other developers.
Topics in that manual of interest to a check developer
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em"><i>The Clang &quot;Basic&quot;
Library</i> for information about diagnostics, fix&minus;it
hints and source locations.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><i>The Lexer and Preprocessor Library</i> for
information about tokens, lexing (transforming characters
into tokens) and the preprocessor.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p><i>The AST Library</i> for information about how C++
source statements are represented as an abstract syntax tree
(AST).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Most checks
will interact with C++ source code via the AST. Some checks
will interact with the preprocessor. The input source file
is lexed and preprocessed and then parsed into the AST. Once
the AST is fully constructed, the check is run by applying
the check's registered AST matchers against the AST and
invoking the check with the set of matched nodes from the
AST. Monitoring the actions of the preprocessor is detached
from the AST construction, but a check can collect
information during preprocessing for later use by the check
when nodes are matched by the AST.</p>

<p style="margin-left:11%; margin-top: 1em">Every syntactic
(and sometimes semantic) element of the C++ source code is
represented by different classes in the AST. You select the
portions of the AST you're interested in by composing AST
matcher functions. You will want to study carefully the
<i>AST Matcher Reference</i> to understand the relationship
between the different matcher functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using the
Transformer library</b> <br>
The Transformer library allows you to write a check that
transforms source code by expressing the transformation as a
<b>RewriteRule</b>. The Transformer library provides
functions for composing edits to source code to create
rewrite rules. Unless you need to perform low&minus;level
source location manipulation, you may want to consider
writing your check with the Transformer library. The
<i>Clang Transformer Tutorial</i> describes the Transformer
library in detail.</p>

<p style="margin-left:11%; margin-top: 1em">To use the
Transformer library, make the following changes to the code
generated by the <b>add_new_check.py</b> script:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Include
<b>../utils/TransformerClangTidyCheck.h</b> instead of
<b>../ClangTidyCheck.h</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Change the base class of your check from
<b>ClangTidyCheck</b> to
<b>TransformerClangTidyCheck</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Delete the override of the <b>registerMatchers</b> and
<b>check</b> methods in your check class.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Write a function that creates the <b>RewriteRule</b> for
your check.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Call the function in your check's constructor to pass
the rewrite rule to <b>TransformerClangTidyCheck</b>'s
constructor.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Developing
your check incrementally</b> <br>
The best way to develop your check is to start with the
simple test cases and increase complexity incrementally. The
test file created by the <b>add_new_check.py</b> script is a
starting point for your test cases. A rough outline of the
process looks like this:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Write a test case for your
check.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Prototype matchers on the test file using
<b>clang&minus;query</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Capture the working matchers in the
<b>registerMatchers</b> method.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Issue the necessary diagnostics and fix&minus;its in the
<b>check</b> method.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Add the necessary <b>CHECK&minus;MESSAGES</b> and
<b>CHECK&minus;FIXES</b> annotations to your test case to
validate the diagnostics and fix&minus;its.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Build the target <b>check&minus;clang&minus;tool</b> to
confirm the test passes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Repeat the process until all aspects of your check are
covered by tests.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The quickest
way to prototype your matcher is to use
<b>clang&minus;query</b> to interactively build up your
matcher. For complicated matchers, build up a matching
expression incrementally and use <b>clang&minus;query</b>'s
<b>let</b> command to save named matching expressions to
simplify your matcher. Just like breaking up a huge function
into smaller chunks with intention&minus;revealing names can
help you understand a complex algorithm, breaking up a
matcher into smaller matchers with intention&minus;revealing
names can help you understand a complicated matcher. Once
you have a working matcher, the C++ API will be virtually
identical to your interactively constructed matcher. You can
use local variables to preserve your
intention&minus;revealing names that you applied to nested
matchers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Creating
private matchers</b> <br>
Sometimes you want to match a specific aspect of the AST
that isn't provided by the existing AST matchers. You can
create your own private matcher using the same
infrastructure as the public matchers. A private matcher can
simplify the processing in your <b>check</b> method by
eliminating complex hand&minus;crafted AST traversal of the
matched nodes. Using the private matcher allows you to
select the desired portions of the AST directly in the
matcher and refer to it by a bound name in the <b>check</b>
method.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unit testing
helper code</b> <br>
Private custom matchers are a good example of auxiliary
support code for your check that can be tested with a unit
test. It will be easier to test your matchers or other
support classes by writing a unit test than by writing a
<b>FileCheck</b> integration test. The
<b>ASTMatchersTests</b> target contains unit tests for the
public AST matcher classes and is a good source of testing
idioms for matchers.</p>

<p style="margin-left:11%; margin-top: 1em">You can build
the Clang&minus;tidy unit tests by building the
<b>ClangTidyTests</b> target. Test targets in LLVM and Clang
are excluded from the &quot;build all&quot; style action of
IDE&minus;based CMake generators, so you need to explicitly
build the target for the unit tests to be built.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Making your
check robust</b> <br>
Once you've covered your check with the basic &quot;happy
path&quot; scenarios, you'll want to torture your check with
as many edge cases as you can cover in order to ensure your
check is robust. Running your check on a large code base,
such as Clang/LLVM, is a good way to catch things you forgot
to account for in your matchers. However, the LLVM code base
may be insufficient for testing purposes as it was developed
against a particular set of coding styles and quality
measures. The larger the corpus of code the check is tested
against, the higher confidence the community will have in
the check's efficacy and false positive rate.</p>

<p style="margin-left:11%; margin-top: 1em">Some
suggestions to ensure your check is robust:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Create header files that contain
code matched by your check.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Validate that fix&minus;its are properly applied to test
header files with <b>clang&minus;tidy</b>. You will need to
perform this test manually until automated support for
checking messages and fix&minus;its is added to the
<b>check_clang_tidy.py</b> script.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Define macros that contain code matched by your
check.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Define template classes that contain code matched by
your check.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Define template specializations that contain code
matched by your check.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Test your check under both Windows and Linux
environments.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Watch out for high false positive rates. Ideally, a
check would have no false positives, but given that matching
against an AST is not control&minus; or data flow&minus;
sensitive, a number of false positives are expected. The
higher the false positive rate, the less likely the check
will be adopted in practice. Mechanisms should be put in
place to help the user manage false positives.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>There are two primary mechanisms for managing false
positives: supporting a code pattern which allows the
programmer to silence the diagnostic in an ad hoc manner and
check configuration options to control the behavior of the
check.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Consider supporting a code pattern to allow the
programmer to silence the diagnostic whenever such a code
pattern can clearly express the programmer's intent. For
example, allowing an explicit cast to <b>void</b> to silence
an unused variable diagnostic.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Consider adding check configuration options to allow the
user to opt into more aggressive checking behavior without
burdening users for the common high&minus;confidence
cases.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Documenting
your check</b> <br>
The <b>add_new_check.py</b> script creates entries in the
<i>release notes</i>, the list of checks and a new file for
the check documentation itself. It is recommended that you
have a concise summation of what your check does in a single
sentence that is repeated in the release notes, as the first
sentence in the doxygen comments in the header file for your
check class and as the first sentence of the check
documentation. Avoid the phrase &quot;this check&quot; in
your check summation and check documentation.</p>

<p style="margin-left:11%; margin-top: 1em">If your check
relates to a published coding guideline (C++ Core
Guidelines, MISRA, etc.) or style guide, provide links to
the relevant guideline or style guide sections in your check
documentation.</p>

<p style="margin-left:11%; margin-top: 1em">Provide enough
examples of the diagnostics and fix&minus;its provided by
the check so that a user can easily understand what will
happen to their code when the check is run. If there are
exceptions or limitations to your check, document them
thoroughly. This will help users understand the scope of the
diagnostics and fix&minus;its provided by the check.</p>

<p style="margin-left:11%; margin-top: 1em">Building the
target <b>docs&minus;clang&minus;tools&minus;html</b> will
run the Sphinx documentation generator and create
documentation HTML files in the
tools/clang/tools/extra/docs/html directory in your build
tree. Make sure that your check is correctly shown in the
release notes and the list of checks. Make sure that the
formatting and structure of your check's documentation looks
correct.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Registering
your Check</b> <br>
(The <b>add_new_check.py</b> script takes care of
registering the check in an existing module. If you want to
create a new module or know the details, read on.)</p>

<p style="margin-left:11%; margin-top: 1em">The check
should be registered in the corresponding module with a
distinct name:</p>

<pre style="margin-left:15%; margin-top: 1em">class MyModule : public ClangTidyModule {
 public:
  void addCheckFactories(ClangTidyCheckFactories &amp;CheckFactories) override {
    CheckFactories.registerCheck&lt;ExplicitConstructorCheck&gt;(
        &quot;my&minus;explicit&minus;constructor&quot;);
  }
};</pre>


<p style="margin-left:11%; margin-top: 1em">Now we need to
register the module in the <b>ClangTidyModuleRegistry</b>
using a statically initialized variable:</p>

<pre style="margin-left:15%; margin-top: 1em">static ClangTidyModuleRegistry::Add&lt;MyModule&gt; X(&quot;my&minus;module&quot;,
                                                &quot;Adds my lint checks.&quot;);</pre>


<p style="margin-left:11%; margin-top: 1em">When using LLVM
build system, we need to use the following hack to ensure
the module is linked into the <b>clang&minus;tidy</b>
binary:</p>

<p style="margin-left:11%; margin-top: 1em">Add this near
the <b>ClangTidyModuleRegistry::Add&lt;MyModule&gt;</b>
variable:</p>

<pre style="margin-left:15%; margin-top: 1em">// This anchor is used to force the linker to link in the generated object file
// and thus register the MyModule.
volatile int MyModuleAnchorSource = 0;</pre>


<p style="margin-left:11%; margin-top: 1em">And this to the
main translation unit of the <b>clang&minus;tidy</b> binary
(or the binary you link the <b>clang&minus;tidy</b> library
in) <b>clang&minus;tidy/tool/ClangTidyMain.cpp</b>:</p>

<pre style="margin-left:15%; margin-top: 1em">// This anchor is used to force the linker to link the MyModule.
extern volatile int MyModuleAnchorSource;
static int MyModuleAnchorDestination = MyModuleAnchorSource;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Configuring
Checks</b> <br>
If a check needs configuration options, it can access
check&minus;specific options using the
<b>Options.get&lt;Type&gt;(&quot;SomeOption&quot;,
DefaultValue)</b> call in the check constructor. In this
case the check should also override the
<b>ClangTidyCheck::storeOptions</b> method to make the
options provided by the check discoverable. This method lets
<b>clang&minus;tidy</b> know which options the check
implements and what the current values are (e.g. for the
<b>&minus;dump&minus;config</b> command line option).</p>
<pre style="margin-left:15%; margin-top: 1em">class MyCheck : public ClangTidyCheck {
  const unsigned SomeOption1;
  const std::string SomeOption2;

public:
  MyCheck(StringRef Name, ClangTidyContext *Context)
    : ClangTidyCheck(Name, Context),
      SomeOption(Options.get(&quot;SomeOption1&quot;, &minus;1U)),
      SomeOption(Options.get(&quot;SomeOption2&quot;, &quot;some default&quot;)) {}


  void storeOptions(ClangTidyOptions::OptionMap &amp;Opts) override {
    Options.store(Opts, &quot;SomeOption1&quot;, SomeOption1);
    Options.store(Opts, &quot;SomeOption2&quot;, SomeOption2);
  }
  ...</pre>


<p style="margin-left:11%; margin-top: 1em">Assuming the
check is registered with the name
&quot;my&minus;check&quot;, the option can then be set in a
<b>.clang&minus;tidy</b> file in the following way:</p>

<pre style="margin-left:15%; margin-top: 1em">CheckOptions:
  my&minus;check.SomeOption1: 123
  my&minus;check.SomeOption2: 'some other value'</pre>


<p style="margin-left:11%; margin-top: 1em">If you need to
specify check options on a command line, you can use the
inline YAML format:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;tidy &minus;config=&quot;{CheckOptions: {a: b, x: y}}&quot; ...</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Testing
Checks</b> <br>
To run tests for <b>clang&minus;tidy</b>, build the
<b>check&minus;clang&minus;tools</b> target. For instance,
if you configured your CMake build with the ninja project
generator, use the command:</p>

<pre style="margin-left:15%; margin-top: 1em">$ ninja check&minus;clang&minus;tools</pre>



<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;tidy</b>
checks can be tested using either unit tests or <i>lit</i>
tests. Unit tests may be more convenient to test complex
replacements with strict checks. <i>Lit</i> tests allow
using partial text matching and regular expressions which
makes them more suitable for writing compact tests for
diagnostic messages.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>check_clang_tidy.py</b> script provides an easy way to
test both diagnostic messages and fix&minus;its. It filters
out <b>CHECK</b> lines from the test file, runs
<b>clang&minus;tidy</b> and verifies messages and fixes with
two separate <i>FileCheck</i> invocations: once with
FileCheck's directive prefix set to
<b>CHECK&minus;MESSAGES</b>, validating the diagnostic
messages, and once with the directive prefix set to
<b>CHECK&minus;FIXES</b>, running against the fixed code
(i.e., the code after generated fix&minus;its are applied).
In particular, <b>CHECK&minus;FIXES:</b> can be used to
check that code was not modified by fix&minus;its, by
checking that it is present unchanged in the fixed code. The
full set of <i>FileCheck</i> directives is available (e.g.,
<b>CHECK&minus;MESSAGES&minus;SAME:</b>,
<b>CHECK&minus;MESSAGES&minus;NOT:</b>), though typically
the basic <b>CHECK</b> forms (<b>CHECK&minus;MESSAGES</b>
and <b>CHECK&minus;FIXES</b>) are sufficient for
clang&minus;tidy tests. Note that the <i>FileCheck</i>
documentation mostly assumes the default prefix
(<b>CHECK</b>), and hence describes the directive as
<b>CHECK:</b>, <b>CHECK&minus;SAME:</b>,
<b>CHECK&minus;NOT:</b>, etc. Replace <b>CHECK</b> by either
<b>CHECK&minus;FIXES</b> or <b>CHECK&minus;MESSAGES</b> for
clang&minus;tidy tests.</p>

<p style="margin-left:11%; margin-top: 1em">An additional
check enabled by <b>check_clang_tidy.py</b> ensures that if
<i>CHECK&minus;MESSAGES:</i> is used in a file then every
warning or error must have an associated CHECK in that file.
Or, you can use <b>CHECK&minus;NOTES:</b> instead, if you
want to <b>also</b> ensure that all the notes are
checked.</p>

<p style="margin-left:11%; margin-top: 1em">To use the
<b>check_clang_tidy.py</b> script, put a .cpp file with the
appropriate <b>RUN</b> line in the
<b>test/clang&minus;tidy</b> directory. Use
<b>CHECK&minus;MESSAGES:</b> and <b>CHECK&minus;FIXES:</b>
lines to write checks against diagnostic messages and fixed
code.</p>

<p style="margin-left:11%; margin-top: 1em">It's advised to
make the checks as specific as possible to avoid checks
matching to incorrect parts of the input. Use
<b>[[@LINE+X]]</b>/<b>[[@LINE&minus;X]]</b> substitutions
and distinct function and variable names in the test
code.</p>

<p style="margin-left:11%; margin-top: 1em">Here's an
example of a test using the <b>check_clang_tidy.py</b>
script (the full source code is at
<i>test/clang&minus;tidy/checkers/google/readability&minus;casting.cpp</i>):</p>

<pre style="margin-left:15%; margin-top: 1em">// RUN: %check_clang_tidy %s google&minus;readability&minus;casting %t


void f(int a) {
  int b = (int)a;
  // CHECK&minus;MESSAGES: :[[@LINE&minus;1]]:11: warning: redundant cast to the same type [google&minus;readability&minus;casting]
  // CHECK&minus;FIXES: int b = a;
}</pre>


<p style="margin-left:11%; margin-top: 1em">To check more
than one scenario in the same test file use
<b>&minus;check&minus;suffix=SUFFIX&minus;NAME</b> on
<b>check_clang_tidy.py</b> command line or
<b>&minus;check&minus;suffixes=SUFFIX&minus;NAME&minus;1,SUFFIX&minus;NAME&minus;2,...</b>.
With <b>&minus;check&minus;suffix[es]=SUFFIX&minus;NAME</b>
you need to replace your <b>CHECK&minus;*</b> directives
with <b>CHECK&minus;MESSAGES&minus;SUFFIX&minus;NAME</b> and
<b>CHECK&minus;FIXES&minus;SUFFIX&minus;NAME</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Here's an
example:</p>

<pre style="margin-left:15%; margin-top: 1em">// RUN: %check_clang_tidy &minus;check&minus;suffix=USING&minus;A %s misc&minus;unused&minus;using&minus;decls %t &minus;&minus; &minus;&minus; &minus;DUSING_A
// RUN: %check_clang_tidy &minus;check&minus;suffix=USING&minus;B %s misc&minus;unused&minus;using&minus;decls %t &minus;&minus; &minus;&minus; &minus;DUSING_B
// RUN: %check_clang_tidy %s misc&minus;unused&minus;using&minus;decls %t
...
// CHECK&minus;MESSAGES&minus;USING&minus;A: :[[@LINE&minus;8]]:10: warning: using decl 'A' {{.*}}
// CHECK&minus;MESSAGES&minus;USING&minus;B: :[[@LINE&minus;7]]:10: warning: using decl 'B' {{.*}}
// CHECK&minus;MESSAGES: :[[@LINE&minus;6]]:10: warning: using decl 'C' {{.*}}
// CHECK&minus;FIXES&minus;USING&minus;A&minus;NOT: using a::A;$
// CHECK&minus;FIXES&minus;USING&minus;B&minus;NOT: using a::B;$
// CHECK&minus;FIXES&minus;NOT: using a::C;$</pre>


<p style="margin-left:11%; margin-top: 1em">There are many
dark corners in the C++ language, and it may be difficult to
make your check work perfectly in all cases, especially if
it issues fix&minus;it hints. The most frequent pitfalls are
macros and templates:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="1%"></td>
<td width="85%">


<p style="margin-top: 1em">code written in a macro
body/template definition may have a different meaning
depending on the macro expansion/template instantiation;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p>multiple macro expansions/template instantiations may
result in the same code being inspected by the check
multiple times (possibly, with different meanings, see 1),
and the same warning (or a slightly different one) may be
issued by the check multiple times; <b>clang&minus;tidy</b>
will deduplicate _identical_ warnings, but if the warnings
are slightly different, all of them will be shown to the
user (and used for applying fixes, if any);</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="1%"></td>
<td width="85%">


<p>making replacements to a macro body/template definition
may be fine for some macro expansions/template
instantiations, but easily break some other
expansions/instantiations.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If you need
multiple files to exercise all the aspects of your check, it
is recommended you place them in a subdirectory named for
the check under the <b>Inputs</b> directory for the module
containing your check. This keeps the test directory from
getting cluttered.</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
validate how your check interacts with system header files,
a set of simulated system header files is located in the
<b>checkers/Inputs/Headers</b> directory. The path to this
directory is available in a lit test with the variable
<b>%clang_tidy_headers</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Out&minus;of&minus;tree
check plugins</b> <br>
Developing an out&minus;of&minus;tree check as a plugin
largely follows the steps outlined above. The plugin is a
shared library whose code lives outside the clang&minus;tidy
build system. Build and link this shared library against
LLVM as done for other kinds of Clang plugins.</p>

<p style="margin-left:11%; margin-top: 1em">The plugin can
be loaded by passing <i>&minus;load</i> to
<i>clang&minus;tidy</i> in addition to the names of the
checks to enable.</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;tidy &minus;&minus;checks=&minus;*,my&minus;explicit&minus;constructor &minus;list&minus;checks &minus;load myplugin.so</pre>


<p style="margin-left:11%; margin-top: 1em">There is no
expectations regarding ABI and API stability, so the plugin
must be compiled against the version of clang&minus;tidy
that will be loading the plugin.</p>

<p style="margin-left:11%; margin-top: 1em">The plugins can
use threads, TLS, or any other facilities available to
in&minus;tree code which is accessible from the external
headers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Running
clang&minus;tidy on LLVM</b> <br>
To test a check it's best to try it out on a larger code
base. LLVM and Clang are the natural targets as you already
have the source code around. The most convenient way to run
<b>clang&minus;tidy</b> is with a compile command database;
CMake can automatically generate one, for a description of
how to enable it see <i>How To Setup Clang Tooling For
LLVM</i>. Once <b>compile_commands.json</b> is in place and
a working version of <b>clang&minus;tidy</b> is in
<b>PATH</b> the entire code base can be analyzed with
<b>clang&minus;tidy/tool/run&minus;clang&minus;tidy.py</b>.
The script executes <b>clang&minus;tidy</b> with the default
set of checks on every translation unit in the compile
command database and displays the resulting warnings and
errors. The script provides multiple configuration
flags.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">The default set of checks can be
overridden using the <b>&minus;checks</b> argument, taking
the identical format as <b>clang&minus;tidy</b> does. For
example
<b>&minus;checks=&minus;*,modernize&minus;use&minus;override</b>
will run the <b>modernize&minus;use&minus;override</b> check
only.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>To restrict the files examined you can provide one or
more regex arguments that the file names are matched
against. <b>run&minus;clang&minus;tidy.py
clang&minus;tidy/.*Check\.cpp</b> will only analyze
clang&minus;tidy checks. It may also be necessary to
restrict the header files that warnings are displayed from
using the <b>&minus;header&minus;filter</b> flag. It has the
same behavior as the corresponding <b>clang&minus;tidy</b>
flag.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>To apply suggested fixes <b>&minus;fix</b> can be passed
as an argument. This gathers all changes in a temporary
directory and applies them. Passing <b>&minus;format</b>
will run clang&minus;format over changed lines.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>On checks
profiling <br>
clang&minus;tidy</b> can collect per&minus;check profiling
info, and output it for each processed source file
(translation unit).</p>

<p style="margin-left:11%; margin-top: 1em">To enable
profiling info collection, use the
<b>&minus;enable&minus;check&minus;profile</b> argument. The
timings will be output to <b>stderr</b> as a table. Example
output:</p>
<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;tidy &minus;enable&minus;check&minus;profile &minus;checks=&minus;*,readability&minus;function&minus;size source.cpp
===&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;===
                          clang&minus;tidy checks profiling
===&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;===
  Total Execution Time: 1.0282 seconds (1.0258 wall clock)


   &minus;&minus;&minus;User Time&minus;&minus;&minus;   &minus;&minus;System Time&minus;&minus;   &minus;&minus;User+System&minus;&minus;   &minus;&minus;&minus;Wall Time&minus;&minus;&minus;  &minus;&minus;&minus; Name &minus;&minus;&minus;
   0.9136 (100.0%)   0.1146 (100.0%)   1.0282 (100.0%)   1.0258 (100.0%)  readability&minus;function&minus;size
   0.9136 (100.0%)   0.1146 (100.0%)   1.0282 (100.0%)   1.0258 (100.0%)  Total</pre>


<p style="margin-left:11%; margin-top: 1em">It can also
store that data as JSON files for further processing.
Example output:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;tidy &minus;enable&minus;check&minus;profile &minus;store&minus;check&minus;profile=. &minus;checks=&minus;*,readability&minus;function&minus;size source.cpp
$ # Note that there won't be timings table printed to the console.
$ ls /tmp/out/
20180516161318717446360&minus;source.cpp.json
$ cat 20180516161318717446360&minus;source.cpp.json
{
&quot;file&quot;: &quot;/path/to/source.cpp&quot;,
&quot;timestamp&quot;: &quot;2018&minus;05&minus;16 16:13:18.717446360&quot;,
&quot;profile&quot;: {
  &quot;time.clang&minus;tidy.readability&minus;function&minus;size.wall&quot;: 1.0421266555786133e+00,
  &quot;time.clang&minus;tidy.readability&minus;function&minus;size.user&quot;: 9.2088400000005421e&minus;01,
  &quot;time.clang&minus;tidy.readability&minus;function&minus;size.sys&quot;: 1.2418899999999974e&minus;01
}
}</pre>


<p style="margin-left:11%; margin-top: 1em">There is only
one argument that controls profile storage:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="44%">



<p style="margin-top: 1em"><b>&minus;store&minus;check&minus;profile=&lt;prefix&gt;</b></p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">By default
reports are printed in tabulated format to stderr. When this
option is passed, these per&minus;TU profiles are instead
stored as JSON. If the prefix is not an absolute path, it is
considered to be relative to the directory from where you
have run <b>clang&minus;tidy</b>. All <b>.</b> and <b>..</b>
patterns in the path are collapsed, and symlinks are
resolved.</p>

<p style="margin-left:14%; margin-top: 1em">Example: Let's
suppose you have a source file named <b>example.cpp</b>,
located in the <b>/source</b> directory. Only the input
filename is used, not the full path to the source file.
Additionally, it is prefixed with the current timestamp.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">If you specify
<b>&minus;store&minus;check&minus;profile=/tmp</b>, then the
profile will be saved to <b>/tmp/&lt;ISO8601&minus;like
timestamp&gt;&minus;example.cpp.json</b></p> </td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>If you run <b>clang&minus;tidy</b> from within
<b>/foo</b> directory, and specify
<b>&minus;store&minus;check&minus;profile=.</b>, then the
profile will still be saved to
<b>/foo/&lt;ISO8601&minus;like
timestamp&gt;&minus;example.cpp.json</b></p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;tidy</b>
is a clang&minus;based C++ &quot;linter&quot; tool. Its
purpose is to provide an extensible framework for diagnosing
and fixing typical programming errors, like style
violations, interface misuse, or bugs that can be deduced
via static analysis. <b>clang&minus;tidy</b> is modular and
provides a convenient interface for writing new checks.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
clang&minus;tidy <br>
clang&minus;tidy</b> is a <i>LibTooling</i>&minus;based
tool, and it's easier to work with if you set up a compile
command database for your project (for an example of how to
do this, see <i>How To Setup Tooling For LLVM</i>). You can
also specify compilation options on the command line after
<b>&minus;&minus;</b>:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;tidy test.cpp &minus;&minus; &minus;Imy_project/include &minus;DMY_DEFINES ...</pre>



<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;tidy</b>
has its own checks and can also run Clang Static Analyzer
checks. Each check has a name and the checks to run can be
chosen using the <b>&minus;checks=</b> option, which
specifies a comma&minus;separated list of positive and
negative (prefixed with <b>&minus;</b>) globs. Positive
globs add subsets of checks, and negative globs remove them.
For example,</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;tidy test.cpp &minus;checks=&minus;*,clang&minus;analyzer&minus;*,&minus;clang&minus;analyzer&minus;cplusplus*</pre>


<p style="margin-left:11%; margin-top: 1em">will disable
all default checks (<b>&minus;*</b>) and enable all
<b>clang&minus;analyzer&minus;*</b> checks except for
<b>clang&minus;analyzer&minus;cplusplus*</b> ones.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;list&minus;checks</b> option lists all the enabled
checks. When used without <b>&minus;checks=</b>, it shows
checks enabled by default. Use <b>&minus;checks=*</b> to see
all available checks or with any other value of
<b>&minus;checks=</b> to see which checks are enabled by
this value.</p>

<p style="margin-left:11%; margin-top: 1em">There are
currently the following groups of checks:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-30332509.png" alt="Image grohtml-30332509.png"></p>

<p style="margin-left:11%;">Clang diagnostics are treated
in a similar way as check diagnostics. Clang diagnostics are
displayed by <b>clang&minus;tidy</b> and can be filtered out
using the <b>&minus;checks=</b> option. However, the
<b>&minus;checks=</b> option does not affect compilation
arguments, so it cannot turn on Clang warnings which are not
already turned on in the build configuration. The
<b>&minus;warnings&minus;as&minus;errors=</b> option
upgrades any warnings emitted under the
<b>&minus;checks=</b> flag to errors (but it does not enable
any checks itself).</p>

<p style="margin-left:11%; margin-top: 1em">Clang
diagnostics have check names starting with
<b>clang&minus;diagnostic&minus;</b>. Diagnostics which have
a corresponding warning option, are named
<b>clang&minus;diagnostic&minus;&lt;warning&minus;option&gt;</b>,
e.g. Clang warning controlled by
<b>&minus;Wliteral&minus;conversion</b> will be reported
with check name
<b>clang&minus;diagnostic&minus;literal&minus;conversion</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;fix</b> flag instructs <b>clang&minus;tidy</b> to
fix found errors if supported by corresponding checks.</p>

<p style="margin-left:11%; margin-top: 1em">An overview of
all the command&minus;line options:</p>
<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;tidy &minus;&minus;help
USAGE: clang&minus;tidy [options] &lt;source0&gt; [... &lt;sourceN&gt;]

OPTIONS:

Generic Options:

  &minus;&minus;help                         &minus; Display available options (&minus;&minus;help&minus;hidden for more)
  &minus;&minus;help&minus;list                    &minus; Display list of available options (&minus;&minus;help&minus;list&minus;hidden for more)
  &minus;&minus;version                      &minus; Display the version of this program

clang&minus;tidy options:

  &minus;&minus;checks=&lt;string&gt;              &minus;
                                   Comma&minus;separated list of globs with optional '&minus;'
                                   prefix. Globs are processed in order of
                                   appearance in the list. Globs without '&minus;'
                                   prefix add checks with matching names to the
                                   set, globs with the '&minus;' prefix remove checks
                                   with matching names from the set of enabled
                                   checks. This option's value is appended to the
                                   value of the 'Checks' option in .clang&minus;tidy
                                   file, if any.
  &minus;&minus;config=&lt;string&gt;              &minus;
                                   Specifies a configuration in YAML/JSON format:
                                     &minus;config=&quot;{Checks: '*',
                                               CheckOptions: {x, y}}&quot;
                                   When the value is empty, clang&minus;tidy will
                                   attempt to find a file named .clang&minus;tidy for
                                   each source file in its parent directories.
  &minus;&minus;config&minus;file=&lt;string&gt;         &minus;
                                  Specify the path of .clang&minus;tidy or custom config file:
                                    e.g. &minus;&minus;config&minus;file=/some/path/myTidyConfigFile
                                  This option internally works exactly the same way as
                                    &minus;&minus;config option after reading specified config file.
                                  Use either &minus;&minus;config&minus;file or &minus;&minus;config, not both.
  &minus;&minus;dump&minus;config                  &minus;
                                   Dumps configuration in the YAML format to
                                   stdout. This option can be used along with a
                                   file name (and '&minus;&minus;' if the file is outside of a
                                   project with configured compilation database).
                                   The configuration used for this file will be
                                   printed.
                                   Use along with &minus;checks=* to include
                                   configuration of all checks.
  &minus;&minus;enable&minus;check&minus;profile         &minus;
                                   Enable per&minus;check timing profiles, and print a
                                   report to stderr.
  &minus;&minus;explain&minus;config               &minus;
                                   For each enabled check explains, where it is
                                   enabled, i.e. in clang&minus;tidy binary, command
                                   line or a specific configuration file.
  &minus;&minus;export&minus;fixes=&lt;filename&gt;      &minus;
                                   YAML file to store suggested fixes in. The
                                   stored fixes can be applied to the input source
                                   code with clang&minus;apply&minus;replacements.
  &minus;&minus;extra&minus;arg=&lt;string&gt;           &minus; Additional argument to append to the compiler command line.
                                   Can be used several times.
  &minus;&minus;extra&minus;arg&minus;before=&lt;string&gt;    &minus; Additional argument to prepend to the compiler command line.
                                   Can be used several times.
  &minus;&minus;fix                          &minus;
                                   Apply suggested fixes. Without &minus;fix&minus;errors
                                   clang&minus;tidy will bail out if any compilation
                                   errors were found.
  &minus;&minus;fix&minus;errors                   &minus;
                                   Apply suggested fixes even if compilation
                                   errors were found. If compiler errors have
                                   attached fix&minus;its, clang&minus;tidy will apply them as
                                   well.
  &minus;&minus;fix&minus;notes                    &minus;
                                   If a warning has no fix, but a single fix can
                                   be found through an associated diagnostic note,
                                   apply the fix.
                                   Specifying this flag will implicitly enable the
                                   '&minus;&minus;fix' flag.
  &minus;&minus;format&minus;style=&lt;string&gt;        &minus;
                                   Style for formatting code around applied fixes:
                                     &minus; 'none' (default) turns off formatting
                                     &minus; 'file' (literally 'file', not a placeholder)
                                       uses .clang&minus;format file in the closest parent
                                       directory
                                     &minus; '{ &lt;json&gt; }' specifies options inline, e.g.
                                       &minus;format&minus;style='{BasedOnStyle: llvm, IndentWidth: 8}'
                                     &minus; 'llvm', 'google', 'webkit', 'mozilla'
                                   See clang&minus;format documentation for the up&minus;to&minus;date
                                   information about formatting styles and options.
                                   This option overrides the 'FormatStyle` option in
                                   .clang&minus;tidy file, if any.
  &minus;&minus;header&minus;filter=&lt;string&gt;       &minus;
                                   Regular expression matching the names of the
                                   headers to output diagnostics from. Diagnostics
                                   from the main file of each translation unit are
                                   always displayed.
                                   Can be used together with &minus;line&minus;filter.
                                   This option overrides the 'HeaderFilterRegex'
                                   option in .clang&minus;tidy file, if any.
  &minus;&minus;line&minus;filter=&lt;string&gt;         &minus;
                                   List of files with line ranges to filter the
                                   warnings. Can be used together with
                                   &minus;header&minus;filter. The format of the list is a
                                   JSON array of objects:
                                     [
                                       {&quot;name&quot;:&quot;file1.cpp&quot;,&quot;lines&quot;:[[1,3],[5,7]]},
                                       {&quot;name&quot;:&quot;file2.h&quot;}
                                     ]
  &minus;&minus;list&minus;checks                  &minus;
                                   List all enabled checks and exit. Use with
                                   &minus;checks=* to list all available checks.
  &minus;load=&lt;plugin&gt;                 &minus;
                                   Load the dynamic object ``plugin``. This
                                   object should register new static analyzer
                                   or clang&minus;tidy passes. Once loaded, the
                                   object will add new command line options
                                   to run various analyses. To see the new
                                   complete list of passes, use the
                                   :option:`&minus;&minus;list&minus;checks` and
                                   :option:`&minus;load` options together.
  &minus;p &lt;string&gt;                    &minus; Build path
  &minus;&minus;quiet                        &minus;
                                   Run clang&minus;tidy in quiet mode. This suppresses
                                   printing statistics about ignored warnings and
                                   warnings treated as errors if the respective
                                   options are specified.
  &minus;&minus;store&minus;check&minus;profile=&lt;prefix&gt; &minus;
                                   By default reports are printed in tabulated
                                   format to stderr. When this option is passed,
                                   these per&minus;TU profiles are instead stored as JSON.
  &minus;&minus;system&minus;headers               &minus; Display the errors from system headers.
  &minus;&minus;use&minus;color                    &minus;
                                  Use colors in diagnostics. If not set, colors
                                  will be used if the terminal connected to
                                  standard output supports colors.
                                  This option overrides the 'UseColor' option in
                                  .clang&minus;tidy file, if any.
  &minus;&minus;verify&minus;config                &minus;
                                   Check the config files to ensure each check and
                                   option is recognized.
  &minus;&minus;vfsoverlay=&lt;filename&gt;        &minus;
                                   Overlay the virtual filesystem described by file
                                   over the real file system.
  &minus;&minus;warnings&minus;as&minus;errors=&lt;string&gt;  &minus;
                                   Upgrades warnings to errors. Same format as
                                   '&minus;checks'.
                                   This option's value is appended to the value of
                                   the 'WarningsAsErrors' option in .clang&minus;tidy
                                   file, if any.

&minus;p &lt;build&minus;path&gt; is used to read a compile command database.

        For example, it can be a CMake build directory in which a file named
        compile_commands.json exists (use &minus;DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        CMake option to get this output). When no build path is specified,
        a search for compile_commands.json will be attempted through all
        parent paths of the first input file . See:
        https://clang.llvm.org/docs/HowToSetupToolingForLLVM.html for an
        example of setting up Clang Tooling on a source tree.

&lt;source0&gt; ... specify the paths of source files. These paths are
        looked up in the compile command database. If the path of a file is
        absolute, it needs to point into CMake's source tree. If the path is
        relative, the current working directory needs to be in the CMake
        source tree and the file must be in a subdirectory of the current
        working directory. &quot;./&quot; prefixes in the relative files will be
        automatically removed, but the rest of a relative path must be a
        suffix of a path in the compile command database.


Configuration files:
  clang&minus;tidy attempts to read configuration for each source file from a
  .clang&minus;tidy file located in the closest parent directory of the source
  file. If InheritParentConfig is true in a config file, the configuration file
  in the parent directory (if any exists) will be taken and current config file
  will be applied on top of the parent one. If any configuration options have
  a corresponding command&minus;line option, command&minus;line option takes precedence.
  The effective configuration can be inspected using &minus;dump&minus;config:


    $ clang&minus;tidy &minus;dump&minus;config
    &minus;&minus;&minus;
    Checks:              '&minus;*,some&minus;check'
    WarningsAsErrors:    ''
    HeaderFilterRegex:   ''
    FormatStyle:         none
    InheritParentConfig: true
    User:                user
    CheckOptions:
      some&minus;check.SomeOption: 'some value'
    ...</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Suppressing
Undesired Diagnostics <br>
clang&minus;tidy</b> diagnostics are intended to call out
code that does not adhere to a coding standard, or is
otherwise problematic in some way. However, if the code is
known to be correct, it may be useful to silence the
warning. Some clang&minus;tidy checks provide a
check&minus;specific way to silence the diagnostics, e.g.
<i>bugprone&minus;use&minus;after&minus;move</i> can be
silenced by re&minus;initializing the variable after it has
been moved out,
<i>bugprone&minus;string&minus;integer&minus;assignment</i>
can be suppressed by explicitly casting the integer to
<b>char</b>,
<i>readability&minus;implicit&minus;bool&minus;conversion</i>
can also be suppressed by using explicit casts, etc.</p>

<p style="margin-left:11%; margin-top: 1em">If a specific
suppression mechanism is not available for a certain
warning, or its use is not desired for some reason,
<b>clang&minus;tidy</b> has a generic mechanism to suppress
diagnostics using <b>NOLINT</b>, <b>NOLINTNEXTLINE</b>, and
<b>NOLINTBEGIN</b> ... <b>NOLINTEND</b> comments.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>NOLINT</b> comment instructs <b>clang&minus;tidy</b> to
ignore warnings on the <i>same line</i> (it doesn't apply to
a function, a block of code or any other language construct;
it applies to the line of code it is on). If introducing the
comment on the same line would change the formatting in an
undesired way, the <b>NOLINTNEXTLINE</b> comment allows
suppressing clang&minus;tidy warnings on the <i>next
line</i>. The <b>NOLINTBEGIN</b> and <b>NOLINTEND</b>
comments allow suppressing clang&minus;tidy warnings on
<i>multiple lines</i> (affecting all lines between the two
comments).</p>

<p style="margin-left:11%; margin-top: 1em">All comments
can be followed by an optional list of check names in
parentheses (see below for the formal syntax). The list of
check names supports globbing, with the same format and
semantics as for enabling checks. Note: negative globs are
ignored here, as they would effectively re&minus;activate
the warning.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>
<pre style="margin-left:15%; margin-top: 1em">class Foo {
  // Suppress all the diagnostics for the line
  Foo(int param); // NOLINT

  // Consider explaining the motivation to suppress the warning
  Foo(char param); // NOLINT: Allow implicit conversion from `char`, because &lt;some valid reason&gt;

  // Silence only the specified checks for the line
  Foo(double param); // NOLINT(google&minus;explicit&minus;constructor, google&minus;runtime&minus;int)

  // Silence all checks from the `google` module
  Foo(bool param); // NOLINT(google*)

  // Silence all checks ending with `&minus;avoid&minus;c&minus;arrays`
  int array[10]; // NOLINT(*&minus;avoid&minus;c&minus;arrays)

  // Silence only the specified diagnostics for the next line
  // NOLINTNEXTLINE(google&minus;explicit&minus;constructor, google&minus;runtime&minus;int)
  Foo(bool param);

  // Silence all checks from the `google` module for the next line
  // NOLINTNEXTLINE(google*)
  Foo(bool param);

  // Silence all checks ending with `&minus;avoid&minus;c&minus;arrays` for the next line
  // NOLINTNEXTLINE(*&minus;avoid&minus;c&minus;arrays)
  int array[10];

  // Silence only the specified checks for all lines between the BEGIN and END
  // NOLINTBEGIN(google&minus;explicit&minus;constructor, google&minus;runtime&minus;int)
  Foo(short param);
  Foo(long param);
  // NOLINTEND(google&minus;explicit&minus;constructor, google&minus;runtime&minus;int)

  // Silence all checks from the `google` module for all lines between the BEGIN and END
  // NOLINTBEGIN(google*)
  Foo(bool param);
  // NOLINTEND(google*)


  // Silence all checks ending with `&minus;avoid&minus;c&minus;arrays` for all lines between the BEGIN and END
  // NOLINTBEGIN(*&minus;avoid&minus;c&minus;arrays)
  int array[10];
  // NOLINTEND(*&minus;avoid&minus;c&minus;arrays)
};</pre>


<p style="margin-left:11%; margin-top: 1em">The formal
syntax of <b>NOLINT</b>, <b>NOLINTNEXTLINE</b>, and
<b>NOLINTBEGIN</b> ... <b>NOLINTEND</b> is the
following:</p>
<pre style="margin-left:15%; margin-top: 1em">lint&minus;comment:
  lint&minus;command
  lint&minus;command lint&minus;args

lint&minus;args:
<b>  (</b> check&minus;name&minus;list<b> )

</b>check&minus;name&minus;list:
<i>  check&minus;name
</i>  check&minus;name&minus;list<b> ,</b><i> check&minus;name


</i>lint&minus;command:
<b>  NOLINT
  NOLINTNEXTLINE
  NOLINTBEGIN
  NOLINTEND</b></pre>


<p style="margin-left:11%; margin-top: 1em"><b>Note that
whitespaces between
NOLINT/NOLINTNEXTLINE/NOLINTBEGIN/NOLINTEND and the opening
parenthesis are not allowed (in this case the comment will
be treated just as
NOLINT/NOLINTNEXTLINE/NOLINTBEGIN/NOLINTEND), whereas in the
check names list (inside the parentheses), whitespaces can
be used and will be ignored.</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>All
NOLINTBEGIN comments must be paired by an equal number of
NOLINTEND comments. Moreover, a pair of comments must have
matching arguments &minus;&minus; for example,
NOLINTBEGIN(check&minus;name) can be paired with
NOLINTEND(check&minus;name) but not with NOLINTEND</b>
<i>(zero arguments)</i><b>. clang&minus;tidy will generate a
clang&minus;tidy&minus;nolint error diagnostic if any
NOLINTBEGIN/NOLINTEND comment violates these
requirements.</b></p>

<h2>CLANG-INCLUDE-FIXER
<a name="CLANG-INCLUDE-FIXER"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Contents</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="29%">



<p style="margin-top: 1em"><i>Clang&minus;Include&minus;Fixer</i></p> </td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="8%">


<p style="margin-top: 1em"><i>Setup</i></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em"><i>Creating a Symbol Index From
a Compilation Database</i></p></td>
<td width="2%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><i>Integrate with Vim</i></p></td>
<td width="2%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%">


<p><i>Integrate with Emacs</i></p></td>
<td width="2%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="78%"></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><i>How it
Works</i></p>

<p style="margin-left:11%; margin-top: 1em">One of the
major nuisances of C++ compared to other languages is the
manual management of <b>#include</b> directives in any file.
<b>clang&minus;include&minus;fixer</b> addresses one aspect
of this problem by providing an automated way of adding
<b>#include</b> directives for missing symbols in one
translation unit.</p>

<p style="margin-left:11%; margin-top: 1em">While inserting
missing <b>#include</b>,
<b>clang&minus;include&minus;fixer</b> adds missing
namespace qualifiers to all instances of an unidentified
symbol if the symbol is missing some prefix namespace
qualifiers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Setup</b>
<br>
To use <b>clang&minus;include&minus;fixer</b> two databases
are required. Both can be generated with existing tools.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Compilation database. Contains
the compiler commands for any given file in a project and
can be generated by CMake, see <i>How To Setup Tooling For
LLVM</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Symbol index. Contains all symbol information in a
project to match a given identifier to a header file.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Ideally both
databases (<b>compile_commands.json</b> and
<b>find_all_symbols_db.yaml</b>) are linked into the root of
the source tree they correspond to. Then the
<b>clang&minus;include&minus;fixer</b> can automatically
pick them up if called with a source file from that tree.
Note that by default <b>compile_commands.json</b> as
generated by CMake does not include header files, so only
implementation files can be handled by tools.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Creating a
Symbol Index From a Compilation Database</b> <br>
The include fixer contains
<b>find&minus;all&minus;symbols</b>, a tool to create a
symbol database in YAML format from a compilation database
by parsing all source files listed in it. The following list
of commands shows how to set up a database for LLVM, any
project built by CMake should follow similar steps.</p>

<pre style="margin-left:15%; margin-top: 1em">$ cd path/to/llvm&minus;build
$ ninja find&minus;all&minus;symbols // build find&minus;all&minus;symbols tool.
$ ninja clang&minus;include&minus;fixer // build clang&minus;include&minus;fixer tool.
$ ls compile_commands.json # Make sure compile_commands.json exists.
  compile_commands.json
$ path/to/llvm/source/clang&minus;tools&minus;extra/clang&minus;include&minus;fixer/find&minus;all&minus;symbols/tool/run&minus;find&minus;all&minus;symbols.py
  ... wait as clang indexes the code base ...
$ ln &minus;s $PWD/find_all_symbols_db.yaml path/to/llvm/source/ # Link database into the source tree.
$ ln &minus;s $PWD/compile_commands.json path/to/llvm/source/ # Also link compilation database if it's not there already.
$ cd path/to/llvm/source
$ /path/to/clang&minus;include&minus;fixer &minus;db=yaml path/to/file/with/missing/include.cpp
  Added #include &quot;foo.h&quot;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Integrate
with Vim</b> <br>
To run <i>clang&minus;include&minus;fixer</i> on a
potentially unsaved buffer in Vim. Add the following key
binding to your <b>.vimrc</b>:</p>

<pre style="margin-left:15%; margin-top: 1em">noremap &lt;leader&gt;cf :pyf path/to/llvm/source/clang&minus;tools&minus;extra/clang&minus;include&minus;fixer/tool/clang&minus;include&minus;fixer.py&lt;cr&gt;</pre>


<p style="margin-left:11%; margin-top: 1em">This enables
<i>clang&minus;include&minus;fixer</i> for NORMAL and VISUAL
mode. Change <i>&lt;leader&gt;cf</i> to another binding if
you need clang&minus;include&minus;fixer on a different key.
The <i>&lt;leader&gt; key</i> is a reference to a specific
key defined by the mapleader variable and is bound to
backslash by default.</p>

<p style="margin-left:11%; margin-top: 1em">Make sure vim
can find <b>clang&minus;include&minus;fixer</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Add the path to
<b>clang&minus;include&minus;fixer</b> to the PATH
environment variable.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Or set <b>g:clang_include_fixer_path</b> in vimrc:
<b>let
g:clang_include_fixer_path=path/to/clang&minus;include&minus;fixer</b></p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">You can
customize the number of headers being shown by setting
<b>let
g:clang_include_fixer_maximum_suggested_headers=5</b></p>

<p style="margin-left:11%; margin-top: 1em">Customized
settings in <i>.vimrc</i>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_path =
&quot;clang&minus;include&minus;fixer&quot;</b></p> </td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Set
clang&minus;include&minus;fixer binary file path.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="84%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_maximum_suggested_headers = 3</b></p></td>
<td width="2%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Set the maximum
number of <b>#includes</b> to show. Default is 3.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_increment_num = 5</b></p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Set the
increment number of #includes to show every time when
pressing <b>m</b>. Default is 5.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="69%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_jump_to_include = 0</b></p></td>
<td width="17%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Set to 1 if you
want to jump to the new inserted <b>#include</b> line.
Default is 0.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="61%">


<p style="margin-top: 1em"><b>let
g:clang_include_fixer_query_mode = 0</b></p></td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Set to 1 if you
want to insert <b>#include</b> for the symbol under the
cursor. Default is 0. Compared to normal mode, this mode
won't parse the source file and only search the symbol from
database, which is faster than normal mode.</p>

<p style="margin-left:11%; margin-top: 1em">See
<b>clang&minus;include&minus;fixer.py</b> for more
details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Integrate
with Emacs</b> <br>
To run <i>clang&minus;include&minus;fixer</i> on a
potentially unsaved buffer in Emacs. Ensure that Emacs finds
<b>clang&minus;include&minus;fixer.el</b> by adding the
directory containing the file to the <b>load&minus;path</b>
and requiring the <i>clang&minus;include&minus;fixer</i> in
your <b>.emacs</b>:</p>

<pre style="margin-left:15%; margin-top: 1em">(add&minus;to&minus;list 'load&minus;path &quot;path/to/llvm/source/clang&minus;tools&minus;extra/clang&minus;include&minus;fixer/tool/&quot;
(require 'clang&minus;include&minus;fixer)</pre>


<p style="margin-left:11%; margin-top: 1em">Within Emacs
the tool can be invoked with the command <b>M&minus;x
clang&minus;include&minus;fixer</b>. This will insert the
header that defines the first undefined symbol; if there is
more than one header that would define the symbol, the user
is prompted to select one.</p>

<p style="margin-left:11%; margin-top: 1em">To include the
header that defines the symbol at point, run <b>M&minus;x
clang&minus;include&minus;fixer&minus;at&minus;point</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Make sure Emacs
can find <b>clang&minus;include&minus;fixer</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Either add the parent directory
of <b>clang&minus;include&minus;fixer</b> to the PATH
environment variable, or customize the Emacs user option
<b>clang&minus;include&minus;fixer&minus;executable</b> to
point to the file name of the program.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>How it
Works</b> <br>
To get the most information out of Clang at parse time,
<b>clang&minus;include&minus;fixer</b> runs in tandem with
the parse and receives callbacks from Clang's semantic
analysis. In particular it reuses the existing support for
typo corrections. Whenever Clang tries to correct a
potential typo it emits a callback to the include fixer
which then looks for a corresponding file. At this point
rich lookup information is still available, which is not
available in the AST at a later stage.</p>

<p style="margin-left:11%; margin-top: 1em">The identifier
that should be typo corrected is then sent to the database,
if a header file is returned it is added as an include
directive at the top of the file.</p>

<p style="margin-left:11%; margin-top: 1em">Currently
<b>clang&minus;include&minus;fixer</b> only inserts a single
include at a time to avoid getting caught in follow&minus;up
errors. If multiple <i>#include</i> additions are desired
the program can be rerun until a fix&minus;point is
reached.</p>

<h2>MODULARIZE USER&rsquo;S MANUAL
<a name="MODULARIZE USER&rsquo;S MANUAL"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Modularize
Usage <br>
modularize [&lt;modularize&minus;options&gt;]
[&lt;module&minus;map&gt;|&lt;include&minus;files&minus;list&gt;]*
[&lt;front&minus;end&minus;options&gt;...]</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>&lt;modularize&minus;options&gt;</b>
is a place&minus;holder for options specific to modularize,
which are described below in <i>Modularize Command Line
Options</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&lt;module&minus;map&gt;</b>
specifies the path of a file name for an existing module
map. The module map must be well&minus;formed in terms of
syntax. Modularize will extract the header file names from
the map. Only normal headers are checked, assuming headers
marked &quot;private&quot;, &quot;textual&quot;, or
&quot;exclude&quot; are not to be checked as a
top&minus;level include, assuming they either are included
by other headers which are checked, or they are not suitable
for modules.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&lt;include&minus;files&minus;list&gt;</b>
specifies the path of a file name for a file containing the
newline&minus;separated list of headers to check with
respect to each other. Lines beginning with '#' and empty
lines are ignored. Header file names followed by a colon and
other space&minus;separated file names will include those
extra files as dependencies. The file names can be relative
or full paths, but must be on the same line. For
example:</p>

<pre style="margin-left:15%; margin-top: 1em">header1.h
header2.h
header3.h: header1.h header2.h</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
unless a <b>&minus;prefix (header path)</b> option is
specified, non&minus;absolute file paths in the header list
file will be relative to the header list file directory. Use
&minus;prefix to specify a different directory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&lt;front&minus;end&minus;options&gt;</b>
is a place&minus;holder for regular Clang front&minus;end
arguments, which must follow the
&lt;include&minus;files&minus;list&gt;. Note that by
default, modularize assumes .h files contain C++ source, so
if you are using a different language, you might need to use
a <b>&minus;x</b> option to tell Clang that the header
contains another language, i.e.: <b>&minus;x c</b></p>

<p style="margin-left:11%; margin-top: 1em">Note also that
because modularize does not use the clang driver, you will
likely need to pass in additional compiler front&minus;end
arguments to match those passed in by default by the
driver.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Modularize
Command Line Options <br>
&minus;prefix=&lt;header&minus;path&gt;</b></p>

<p style="margin-left:22%;">Prepend the given path to
non&minus;absolute file paths in the header list file. By
default, headers are assumed to be relative to the header
list file directory. Use <b>&minus;prefix</b> to specify a
different directory.</p>


<p style="margin-left:11%;"><b>&minus;module&minus;map&minus;path=&lt;module&minus;map&minus;path&gt;</b></p>

<p style="margin-left:22%;">Generate a module map and
output it to the given file. See the description in
<i>Module Map Generation</i>.</p>


<p style="margin-left:11%;"><b>&minus;problem&minus;files&minus;list=&lt;problem&minus;files&minus;list&minus;file&minus;name&gt;</b></p>

<p style="margin-left:22%;">For use only with module map
assistant. Input list of files that have problems with
respect to modules. These will still be included in the
generated module map, but will be marked as
&quot;excluded&quot; headers.</p>


<p style="margin-left:11%;"><b>&minus;root&minus;module=&lt;root&minus;name&gt;</b></p>

<p style="margin-left:22%;">Put modules generated by the
&minus;module&minus;map&minus;path option in an enclosing
module with the given name. See the description in <i>Module
Map Generation</i>.</p>


<p style="margin-left:11%;"><b>&minus;block&minus;check&minus;header&minus;list&minus;only</b></p>

<p style="margin-left:22%;">Limit the
#include&minus;inside&minus;extern&minus;or&minus;namespace&minus;block
check to only those headers explicitly listed in the header
list. This is a work&minus;around for avoiding error
messages for private includes that purposefully get included
inside blocks.</p>


<p style="margin-left:11%;"><b>&minus;no&minus;coverage&minus;check</b></p>

<p style="margin-left:22%;">Don't do the coverage check for
a module map.</p>


<p style="margin-left:11%;"><b>&minus;coverage&minus;check&minus;only</b></p>

<p style="margin-left:22%;">Only do the coverage check for
a module map.</p>


<p style="margin-left:11%;"><b>&minus;display&minus;file&minus;lists</b></p>

<p style="margin-left:22%;">Display lists of good files (no
compile errors), problem files, and a combined list with
problem files preceded by a '#'. This can be used to quickly
determine which files have problems. The latter combined
list might be useful in starting to modularize a set of
headers. You can start with a full list of headers, use
&minus;display&minus;file&minus;lists option, and then use
the combined list as your intermediate list,
uncommenting&minus;out headers as you fix them.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modularize</b>
is a standalone tool that checks whether a set of headers
provides the consistent definitions required to use modules.
For example, it detects whether the same entity (say, a NULL
macro or size_t typedef) is defined in multiple headers or
whether a header produces different definitions under
different circumstances. These conditions cause modules
built from the headers to behave poorly, and should be fixed
before introducing a module map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>modularize</b>
also has an assistant mode option for generating a module
map file based on the provided header list. The generated
file is a functional module map that can be used as a
starting point for a module.map file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Getting
Started</b> <br>
To build from source:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>Read <i>Getting Started with the LLVM System</i> and
<i>Clang Tools Documentation</i> for information on getting
sources for LLVM, Clang, and Clang Extra Tools.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>Getting Started with the LLVM System</i> and
<i>Building LLVM with CMake</i> give directions for how to
build. With sources all checked out into the right place the
LLVM build will build Clang Extra Tools and their
dependencies automatically.</p></td></tr>
</table>

<p style="margin-left:15%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p style="margin-top: 1em">If using CMake, you can also use
the <b>modularize</b> target to build just the modularize
tool and its dependencies.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Before
continuing, take a look at <i>Modularize Usage</i> to see
how to invoke modularize.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What
Modularize Checks</b> <br>
Modularize will check for the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">Duplicate global type and
variable definitions</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Duplicate macro definitions</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Macro instances, 'defined(macro)', or #if, #elif,
#ifdef, #ifndef conditions that evaluate differently in a
header</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>#include directives inside 'extern &quot;C/C++&quot; {}'
or 'namespace (name) {}' blocks</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Module map header coverage completeness (in the case of
a module map input only)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Modularize will
do normal C/C++ parsing, reporting normal errors and
warnings, but will also report special error messages like
the following:</p>
<pre style="margin-left:15%; margin-top: 1em">error: '(symbol)' defined at multiple locations:
   (file):(row):(column)
   (file):(row):(column)


error: header '(file)' has different contents depending on how it was included</pre>


<p style="margin-left:11%; margin-top: 1em">The latter
might be followed by messages like the following:</p>

<pre style="margin-left:15%; margin-top: 1em">note: '(symbol)' in (file) at (row):(column) not always provided</pre>


<p style="margin-left:11%; margin-top: 1em">Checks will
also be performed for macro expansions, defined(macro)
expressions, and preprocessor conditional directives that
evaluate inconsistently, and can produce error messages like
the following:</p>

<pre style="margin-left:15%; margin-top: 1em"> (...)/SubHeader.h:11:5:
#if SYMBOL == 1
    ^
error: Macro instance 'SYMBOL' has different values in this header,
       depending on how it was included.
  'SYMBOL' expanded to: '1' with respect to these inclusion paths:
    (...)/Header1.h
      (...)/SubHeader.h
(...)/SubHeader.h:3:9:
#define SYMBOL 1
        ^
Macro defined here.
  'SYMBOL' expanded to: '2' with respect to these inclusion paths:
    (...)/Header2.h
        (...)/SubHeader.h
(...)/SubHeader.h:7:9:
#define SYMBOL 2
        ^
Macro defined here.</pre>


<p style="margin-left:11%; margin-top: 1em">Checks will
also be performed for '#include' directives that are nested
inside 'extern &quot;C/C++&quot; {}' or 'namespace (name)
{}' blocks, and can produce error message like the
following:</p>

<pre style="margin-left:15%; margin-top: 1em">IncludeInExtern.h:2:3:
#include &quot;Empty.h&quot;
^
error: Include directive within extern &quot;C&quot; {}.
IncludeInExtern.h:1:1:
extern &quot;C&quot; {
^
The &quot;extern &quot;C&quot; {}&quot; block is here.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Module Map
Coverage Check</b> <br>
The coverage check uses the Clang library to read and parse
the module map file. Starting at the module map file
directory, or just the include paths, if specified, it will
collect the names of all the files it considers headers (no
extension, .h, or .inc&minus;&minus;if you need more, modify
the isHeader function). It then compares the headers against
those referenced in the module map, either explicitly named,
or implicitly named via an umbrella directory or umbrella
file, as parsed by the ModuleMap object. If headers are
found which are not referenced or covered by an umbrella
directory or file, warning messages will be produced, and
this program will return an error code of 1. If no problems
are found, an error code of 0 is returned.</p>

<p style="margin-left:11%; margin-top: 1em">Note that in
the case of umbrella headers, this tool invokes the compiler
to preprocess the file, and uses a callback to collect the
header files included by the umbrella header or any of its
nested includes. If any front end options are needed for
these compiler invocations, these can be included on the
command line after the module map file argument.</p>

<p style="margin-left:11%; margin-top: 1em">Warning message
have the form:</p>

<p style="margin-left:15%;">warning: module.modulemap does
not account for file: Level3A.h</p>

<p style="margin-left:11%; margin-top: 1em">Note that for
the case of the module map referencing a file that does not
exist, the module map parser in Clang will (at the time of
this writing) display an error message.</p>

<p style="margin-left:11%; margin-top: 1em">To limit the
checks <b>modularize</b> does to just the module map
coverage check, use the
<b>&minus;coverage&minus;check&minus;only option</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<pre style="margin-left:15%; margin-top: 1em">modularize &minus;coverage&minus;check&minus;only module.modulemap</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Module Map
Generation</b> <br>
If you specify the
<b>&minus;module&minus;map&minus;path=&lt;module map
file&gt;</b>, <b>modularize</b> will output a module map
based on the input header list. A module will be created for
each header. Also, if the header in the header list is a
partial path, a nested module hierarchy will be created in
which a module will be created for each subdirectory
component in the header path, with the header itself
represented by the innermost module. If other headers use
the same subdirectories, they will be enclosed in these same
modules also.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
for the header list:</p>

<pre style="margin-left:15%; margin-top: 1em">SomeTypes.h
SomeDecls.h
SubModule1/Header1.h
SubModule1/Header2.h
SubModule2/Header3.h
SubModule2/Header4.h
SubModule2.h</pre>


<p style="margin-left:11%; margin-top: 1em">The following
module map will be generated:</p>
<pre style="margin-left:15%; margin-top: 1em">// Output/NoProblemsAssistant.txt
// Generated by: modularize &minus;module&minus;map&minus;path=Output/NoProblemsAssistant.txt \
     &minus;root&minus;module=Root NoProblemsAssistant.modularize


module SomeTypes {
  header &quot;SomeTypes.h&quot;
  export *
}
module SomeDecls {
  header &quot;SomeDecls.h&quot;
  export *
}
module SubModule1 {
  module Header1 {
    header &quot;SubModule1/Header1.h&quot;
    export *
  }
  module Header2 {
    header &quot;SubModule1/Header2.h&quot;
    export *
  }
}
module SubModule2 {
  module Header3 {
    header &quot;SubModule2/Header3.h&quot;
    export *
  }
  module Header4 {
    header &quot;SubModule2/Header4.h&quot;
    export *
  }
  header &quot;SubModule2.h&quot;
  export *
}</pre>


<p style="margin-left:11%; margin-top: 1em">An optional
<b>&minus;root&minus;module=&lt;root&minus;name&gt;</b>
option can be used to cause a root module to be created
which encloses all the modules.</p>

<p style="margin-left:11%; margin-top: 1em">An optional
<b>&minus;problem&minus;files&minus;list=&lt;problem&minus;file&minus;name&gt;</b>
can be used to input a list of files to be excluded, perhaps
as a temporary stop&minus;gap measure until problem headers
can be fixed.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
with the same header list from above:</p>
<pre style="margin-left:15%; margin-top: 1em">// Output/NoProblemsAssistant.txt
// Generated by: modularize &minus;module&minus;map&minus;path=Output/NoProblemsAssistant.txt \
     &minus;root&minus;module=Root NoProblemsAssistant.modularize


module Root {
  module SomeTypes {
    header &quot;SomeTypes.h&quot;
    export *
  }
  module SomeDecls {
    header &quot;SomeDecls.h&quot;
    export *
  }
  module SubModule1 {
    module Header1 {
      header &quot;SubModule1/Header1.h&quot;
      export *
    }
    module Header2 {
      header &quot;SubModule1/Header2.h&quot;
      export *
    }
  }
  module SubModule2 {
    module Header3 {
      header &quot;SubModule2/Header3.h&quot;
      export *
    }
    module Header4 {
      header &quot;SubModule2/Header4.h&quot;
      export *
    }
    header &quot;SubModule2.h&quot;
    export *
  }
}</pre>


<p style="margin-left:11%; margin-top: 1em">Note that
headers with dependents will be ignored with a warning, as
the Clang module mechanism doesn't support headers the rely
on other headers to be included first.</p>

<p style="margin-left:11%; margin-top: 1em">The module map
format defines some keywords which can't be used in module
names. If a header has one of these names, an underscore
('_') will be prepended to the name. For example, if the
header name is <b>header.h</b>, because <b>header</b> is a
keyword, the module name will be <b>_header</b>. For a list
of the module map keywords, please see: <i>Lexical
structure</i></p>

<h2>PP-TRACE USER&rsquo;S MANUAL
<a name="PP-TRACE USER&rsquo;S MANUAL"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i><b>pp&minus;trace</b></i>
is a standalone tool that traces preprocessor activity. It's
also used as a test of Clang's PPCallbacks interface. It
runs a given source file through the Clang preprocessor,
displaying selected information from callback functions
overridden in a <i>PPCallbacks</i> derivation. The output is
in a high&minus;level YAML format, described in
<i>pp&minus;trace Output Format</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pp&minus;trace
Usage <br>
Command Line Format <br>
pp&minus;trace [&lt;pp&minus;trace&minus;options&gt;]
&lt;source&minus;file&gt; [&minus;&minus;
&lt;front&minus;end&minus;options&gt;]</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>&lt;pp&minus;trace&minus;options&gt;</b>
is a place&minus;holder for options specific to
pp&minus;trace, which are described below in <i>Command Line
Options</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&lt;source&minus;file&gt;</b>
specifies the source file to run through the
preprocessor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&lt;front&minus;end&minus;options&gt;</b>
is a place&minus;holder for regular <i>Clang Compiler
Options</i>, which must follow the
&lt;source&minus;file&gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Command Line
Options <br>
&minus;callbacks
&lt;comma&minus;separated&minus;globs&gt;</b></p>

<p style="margin-left:22%;">This option specifies a
comma&minus;separated list of globs describing the list of
callbacks that should be traced. Globs are processed in
order of appearance. Positive globs add matched callbacks to
the set, netative globs (those with the '&minus;' prefix)
remove callacks from the set.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>FileChanged</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>FileSkipped</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>InclusionDirective</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>moduleImport</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>EndOfMainFile</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>Ident</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaDirective</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaComment</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaDetectMismatch</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaDebug</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaMessage</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaDiagnosticPush</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaDiagnosticPop</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaDiagnostic</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaOpenCLExtension</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaWarning</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaWarningPush</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>PragmaWarningPop</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>MacroExpands</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>MacroDefined</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>MacroUndefined</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>Defined</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>SourceRangeSkipped</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>If</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>Elif</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>Ifdef</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>Ifndef</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>Else</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p>Endif</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;output
&lt;output&minus;file&gt;</b></p>

<p style="margin-left:22%;">By default, pp&minus;trace
outputs the trace information to stdout. Use this option to
output the trace information to a file.</p>


<p style="margin-left:11%; margin-top: 1em"><b>pp&minus;trace
Output Format</b> <br>
The pp&minus;trace output is formatted as YAML. See
<i>https://yaml.org/</i> for general YAML information. It's
arranged as a sequence of information about the callback
call, including the callback name and argument information,
for example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus;&minus;&minus;
&minus; Callback: Name
  Argument1: Value1
  Argument2: Value2
(etc.)
...</pre>


<p style="margin-left:11%; margin-top: 1em">With real
data::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus;&minus;&minus;
&minus; Callback: FileChanged
  Loc: &quot;c:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;include.cpp:1:1&quot;
  Reason: EnterFile
  FileType: C_User
  PrevFID: (invalid)
  (etc.)
&minus; Callback: FileChanged
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;include.cpp:5:1&quot;
  Reason: ExitFile
  FileType: C_User
  PrevFID: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/Input/Level1B.h&quot;
&minus; Callback: EndOfMainFile
...</pre>


<p style="margin-left:11%; margin-top: 1em">In all but one
case (MacroDirective) the &quot;Argument&quot; scalars have
the same name as the argument in the corresponding
PPCallbacks callback function.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Callback
Details</b> <br>
The following sections describe the purpose and output
format for each callback.</p>

<p style="margin-left:11%; margin-top: 1em">Click on the
callback name in the section heading to see the Doxygen
documentation for the callback.</p>

<p style="margin-left:11%; margin-top: 1em">The argument
descriptions table describes the callback argument
information displayed.</p>

<p style="margin-left:11%; margin-top: 1em">The Argument
Name field in most (but not all) cases is the same name as
the callback function parameter.</p>

<p style="margin-left:11%; margin-top: 1em">The Argument
Value Syntax field describes the values that will be
displayed for the argument value. It uses an ad hoc
representation that mixes literal and symbolic
representations. Enumeration member symbols are shown as the
actual enum member in a (member1|member2|...) form. A name
in parentheses can either represent a place holder for the
described value, or confusingly, it might be a literal, such
as (null), for a null pointer. Locations are shown as quoted
only to avoid confusing the documentation generator.</p>

<p style="margin-left:11%; margin-top: 1em">The Clang C++
Type field is the type from the callback function
declaration.</p>

<p style="margin-left:11%; margin-top: 1em">The description
describes the argument or what is displayed for it.</p>

<p style="margin-left:11%; margin-top: 1em">Note that in
some cases, such as when a structure pointer is an argument
value, only some key member or members are shown to
represent the value, instead of trying to display all
members of the structure.</p>


<p style="margin-left:11%; margin-top: 1em"><i>FileChanged</i>
<b>Callback</b> <br>
FileChanged is called when the preprocessor enters or exits
a file, both the top level file being compiled, as well as
any #include directives. It will also be called as a result
of a system header pragma or in internal renaming of a
file.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325010.png" alt="Image grohtml-303325010.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: FileChanged
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;include.cpp:1:1&quot;
  Reason: EnterFile
  FileType: C_User
  PrevFID: (invalid)</pre>



<p style="margin-left:11%; margin-top: 1em"><i>FileSkipped</i>
<b>Callback</b> <br>
FileSkipped is called when a source file is skipped as the
result of header guard optimization.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325011.png" alt="Image grohtml-303325011.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: FileSkipped
  ParentFile: &quot;/path/filename.h&quot;
  FilenameTok: &quot;filename.h&quot;
  FileType: C_User</pre>



<p style="margin-left:11%; margin-top: 1em"><i>InclusionDirective</i>
<b>Callback</b> <br>
InclusionDirective is called when an inclusion directive of
any kind (#include&lt;/code&gt;, #import&lt;/code&gt;, etc.)
has been processed, regardless of whether the inclusion will
actually result in an inclusion.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325012.png" alt="Image grohtml-303325012.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: InclusionDirective
  HashLoc: &quot;D:/Clang/llvmnewmod/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;include.cpp:4:1&quot;
  IncludeTok: include
  FileName: &quot;Input/Level1B.h&quot;
  IsAngled: false
  FilenameRange: &quot;Input/Level1B.h&quot;
  File: &quot;D:/Clang/llvmnewmod/clang&minus;tools&minus;extra/test/pp&minus;trace/Input/Level1B.h&quot;
  SearchPath: &quot;D:/Clang/llvmnewmod/clang&minus;tools&minus;extra/test/pp&minus;trace&quot;
  RelativePath: &quot;Input/Level1B.h&quot;
  Imported: (null)</pre>



<p style="margin-left:11%; margin-top: 1em"><i>moduleImport</i>
<b>Callback</b> <br>
moduleImport is called when there was an explicit
module&minus;import syntax.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325013.png" alt="Image grohtml-303325013.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: moduleImport
  ImportLoc: &quot;d:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;modules.cpp:4:2&quot;
  Path: [{Name: Level1B, Loc: &quot;d:/Clang/llvmnewmod/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;modules.cpp:4:9&quot;}, {Name: Level2B, Loc: &quot;d:/Clang/llvmnewmod/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;modules.cpp:4:17&quot;}]
  Imported: Level2B</pre>



<p style="margin-left:11%; margin-top: 1em"><i>EndOfMainFile</i>
<b>Callback</b> <br>
EndOfMainFile is called when the end of the main file is
reached.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325014.png" alt="Image grohtml-303325014.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: EndOfMainFile</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Ident</i>
<b>Callback</b> <br>
Ident is called when a #ident or #sccs directive is
read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325015.png" alt="Image grohtml-303325015.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: Ident
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;ident.cpp:3:1&quot;
  str: &quot;$Id$&quot;</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaDirective</i>
<b>Callback</b> <br>
PragmaDirective is called when start reading any pragma
directive.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325016.png" alt="Image grohtml-303325016.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaDirective
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  Introducer: PIK_HashPragma</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaComment</i>
<b>Callback</b> <br>
PragmaComment is called when a #pragma comment directive is
read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325017.png" alt="Image grohtml-303325017.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaComment
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  Kind: library
  Str: kernel32.lib</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaDetectMismatch</i>
<b>Callback</b> <br>
PragmaDetectMismatch is called when a #pragma
detect_mismatch directive is read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325018.png" alt="Image grohtml-303325018.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaDetectMismatch
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  Name: name
  Value: value</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaDebug</i>
<b>Callback</b> <br>
PragmaDebug is called when a #pragma clang __debug directive
is read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325019.png" alt="Image grohtml-303325019.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaDebug
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  DebugType: warning</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaMessage</i>
<b>Callback</b> <br>
PragmaMessage is called when a #pragma message directive is
read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325020.png" alt="Image grohtml-303325020.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaMessage
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  Namespace: &quot;GCC&quot;
  Kind: PMK_Message
  Str: The message text.</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaDiagnosticPush</i>
<b>Callback</b> <br>
PragmaDiagnosticPush is called when a #pragma gcc diagnostic
push directive is read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325021.png" alt="Image grohtml-303325021.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaDiagnosticPush
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  Namespace: &quot;GCC&quot;</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaDiagnosticPop</i>
<b>Callback</b> <br>
PragmaDiagnosticPop is called when a #pragma gcc diagnostic
pop directive is read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325022.png" alt="Image grohtml-303325022.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaDiagnosticPop
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  Namespace: &quot;GCC&quot;</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaDiagnostic</i>
<b>Callback</b> <br>
PragmaDiagnostic is called when a #pragma gcc diagnostic
directive is read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325023.png" alt="Image grohtml-303325023.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaDiagnostic
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  Namespace: &quot;GCC&quot;
  mapping: MAP_WARNING
  Str: WarningName</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaOpenCLExtension</i>
<b>Callback</b> <br>
PragmaOpenCLExtension is called when OpenCL extension is
either disabled or enabled with a pragma.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325024.png" alt="Image grohtml-303325024.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaOpenCLExtension
  NameLoc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:10&quot;
  Name: Name
  StateLoc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:18&quot;
  State: 1</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaWarning</i>
<b>Callback</b> <br>
PragmaWarning is called when a #pragma warning directive is
read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325025.png" alt="Image grohtml-303325025.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaWarning
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  WarningSpec: disable
  Ids: 1,2,3</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaWarningPush</i>
<b>Callback</b> <br>
PragmaWarningPush is called when a #pragma warning(push)
directive is read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325026.png" alt="Image grohtml-303325026.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaWarningPush
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;
  Level: 1</pre>



<p style="margin-left:11%; margin-top: 1em"><i>PragmaWarningPop</i>
<b>Callback</b> <br>
PragmaWarningPop is called when a #pragma warning(pop)
directive is read.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325027.png" alt="Image grohtml-303325027.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: PragmaWarningPop
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;pragma.cpp:3:1&quot;</pre>



<p style="margin-left:11%; margin-top: 1em"><i>MacroExpands</i>
<b>Callback</b> <br>
MacroExpands is called when ::HandleMacroExpandedIdentifier
when a macro invocation is found.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325028.png" alt="Image grohtml-303325028.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: MacroExpands
  MacroNameTok: X_IMPL
  MacroDirective: MD_Define
  Range: [(nonfile), (nonfile)]
  Args: [a &lt;plus&gt; y, b]</pre>



<p style="margin-left:11%; margin-top: 1em"><i>MacroDefined</i>
<b>Callback</b> <br>
MacroDefined is called when a macro definition is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325029.png" alt="Image grohtml-303325029.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: MacroDefined
  MacroNameTok: X_IMPL
  MacroDirective: MD_Define</pre>



<p style="margin-left:11%; margin-top: 1em"><i>MacroUndefined</i>
<b>Callback</b> <br>
MacroUndefined is called when a macro #undef is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325030.png" alt="Image grohtml-303325030.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: MacroUndefined
  MacroNameTok: X_IMPL
  MacroDirective: MD_Define</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Defined</i>
<b>Callback</b> <br>
Defined is called when the 'defined' operator is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325031.png" alt="Image grohtml-303325031.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: Defined
  MacroNameTok: MACRO
  MacroDirective: (null)
  Range: [&quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:8:5&quot;, &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:8:19&quot;]</pre>



<p style="margin-left:11%; margin-top: 1em"><i>SourceRangeSkipped</i>
<b>Callback</b> <br>
SourceRangeSkipped is called when a source range is
skipped.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325032.png" alt="Image grohtml-303325032.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: SourceRangeSkipped
  Range: [&quot;:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:8:2&quot;, &quot;:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:9:2&quot;]</pre>


<p style="margin-left:11%; margin-top: 1em"><i>If</i>
<b>Callback</b> <br>
If is called when an #if is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325033.png" alt="Image grohtml-303325033.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: If
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:8:2&quot;
  ConditionRange: [&quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:8:4&quot;, &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:9:1&quot;]
  ConditionValue: false</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Elif</i>
<b>Callback</b> <br>
Elif is called when an #elif is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325034.png" alt="Image grohtml-303325034.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: Elif
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:10:2&quot;
  ConditionRange: [&quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:10:4&quot;, &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:11:1&quot;]
  ConditionValue: false
  IfLoc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:8:2&quot;</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Ifdef</i>
<b>Callback</b> <br>
Ifdef is called when an #ifdef is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325035.png" alt="Image grohtml-303325035.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: Ifdef
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;conditional.cpp:3:1&quot;
  MacroNameTok: MACRO
  MacroDirective: MD_Define</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Ifndef</i>
<b>Callback</b> <br>
Ifndef is called when an #ifndef is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325036.png" alt="Image grohtml-303325036.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: Ifndef
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;conditional.cpp:3:1&quot;
  MacroNameTok: MACRO
  MacroDirective: MD_Define</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Else</i>
<b>Callback</b> <br>
Else is called when an #else is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325037.png" alt="Image grohtml-303325037.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: Else
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:10:2&quot;
  IfLoc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:8:2&quot;</pre>


<p style="margin-left:11%; margin-top: 1em"><i>Endif</i>
<b>Callback</b> <br>
Endif is called when an #endif is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Argument
descriptions:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-303325038.png" alt="Image grohtml-303325038.png"></p>

<p style="margin-left:11%;">Example::</p>

<pre style="margin-left:15%; margin-top: 1em">&minus; Callback: Endif
  Loc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:10:2&quot;
  IfLoc: &quot;D:/Clang/llvm/clang&minus;tools&minus;extra/test/pp&minus;trace/pp&minus;trace&minus;macro.cpp:8:2&quot;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Building
pp&minus;trace</b> <br>
To build from source:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="1%"></td>
<td width="85%">


<p>Read <i>Getting Started with the LLVM System</i> and
<i>Clang Tools Documentation</i> for information on getting
sources for LLVM, Clang, and Clang Extra Tools.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="1%"></td>
<td width="85%">


<p><i>Getting Started with the LLVM System</i> and
<i>Building LLVM with CMake</i> give directions for how to
build. With sources all checked out into the right place the
LLVM build will build Clang Extra Tools and their
dependencies automatically.</p></td></tr>
</table>

<p style="margin-left:15%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="82%">


<p style="margin-top: 1em">If using CMake, you can also use
the <b>pp&minus;trace</b> target to build just the
pp&minus;trace tool and its dependencies.</p></td></tr>
</table>

<h2>CLANG-RENAME
<a name="CLANG-RENAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Contents</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="18%">


<p style="margin-top: 1em"><i>Clang&minus;Rename</i></p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%"></td>
<td width="2%"></td>
<td width="28%">


<p style="margin-top: 1em"><i>Using
Clang&minus;Rename</i></p> </td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Vim Integration</i></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="28%">


<p><i>Emacs Integration</i></p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">See also:</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;rename</b>
is a C++ refactoring tool. Its purpose is to perform
efficient renaming actions in large&minus;scale projects
such as renaming classes, functions, variables, arguments,
namespaces etc.</p>

<p style="margin-left:11%; margin-top: 1em">The tool is in
a very early development stage, so you might encounter bugs
and crashes. Submitting reports with information about how
to reproduce the issue to <i>the LLVM bugtracker</i> will
definitely help the project. If you have any ideas or
suggestions, you might want to put a feature request
there.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
Clang&minus;Rename <br>
clang&minus;rename</b> is a <i>LibTooling</i>&minus;based
tool, and it's easier to work with if you set up a compile
command database for your project (for an example of how to
do this see <i>How To Setup Tooling For LLVM</i>). You can
also specify compilation options on the command line after
<i>&minus;&minus;</i>:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;rename &minus;offset=42 &minus;new&minus;name=foo test.cpp &minus;&minus; &minus;Imy_project/include &minus;DMY_DEFINES ...</pre>


<p style="margin-left:11%; margin-top: 1em">To get an
offset of a symbol in a file run</p>

<pre style="margin-left:15%; margin-top: 1em">$ grep &minus;FUbo 'foo' file.cpp</pre>


<p style="margin-left:11%; margin-top: 1em">The tool
currently supports renaming actions inside a single
translation unit only. It is planned to extend the tool's
functionality to support multi&minus;TU renaming actions in
the future.</p>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;rename</b>
also aims to be easily integrated into popular text editors,
such as Vim and Emacs, and improve the workflow of
users.</p>

<p style="margin-left:11%; margin-top: 1em">Although a
command line interface exists, it is highly recommended to
use the text editor interface instead for better
experience.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
identify one or more symbols to be renamed by giving the
fully qualified name:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;rename &minus;qualified&minus;name=foo &minus;new&minus;name=bar test.cpp</pre>


<p style="margin-left:11%; margin-top: 1em">Renaming
multiple symbols at once is supported, too. However,
<b>clang&minus;rename</b> doesn't accept both
<i>&minus;offset</i> and <i>&minus;qualified&minus;name</i>
at the same time. So, you can either specify multiple
<i>&minus;offset</i> or
<i>&minus;qualified&minus;name</i>.</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;rename &minus;offset=42 &minus;new&minus;name=bar1 &minus;offset=150 &minus;new&minus;name=bar2 test.cpp</pre>


<p style="margin-left:11%; margin-top: 1em">or</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;rename &minus;qualified&minus;name=foo1 &minus;new&minus;name=bar1 &minus;qualified&minus;name=foo2 &minus;new&minus;name=bar2 test.cpp</pre>


<p style="margin-left:11%; margin-top: 1em">Alternatively,
{offset | qualified&minus;name} / new&minus;name pairs can
be put into a YAML file:</p>

<pre style="margin-left:15%; margin-top: 1em">&minus;&minus;&minus;
&minus; Offset:         42
  NewName:        bar1
&minus; Offset:         150
  NewName:        bar2
...</pre>


<p style="margin-left:11%; margin-top: 1em">or</p>

<pre style="margin-left:15%; margin-top: 1em">&minus;&minus;&minus;
&minus; QualifiedName:  foo1
  NewName:        bar1
&minus; QualifiedName:  foo2
  NewName:        bar2
...</pre>


<p style="margin-left:11%; margin-top: 1em">That way you
can avoid spelling out all the names as command line
arguments:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;rename &minus;input=test.yaml test.cpp</pre>



<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;rename</b>
offers the following options:</p>
<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;rename &minus;&minus;help
USAGE: clang&minus;rename [subcommand] [options] &lt;source0&gt; [... &lt;sourceN&gt;]

OPTIONS:

Generic Options:

  &minus;help                      &minus; Display available options (&minus;help&minus;hidden for more)
  &minus;help&minus;list                 &minus; Display list of available options (&minus;help&minus;list&minus;hidden for more)
  &minus;version                   &minus; Display the version of this program

clang&minus;rename common options:


  &minus;export&minus;fixes=&lt;filename&gt;   &minus; YAML file to store suggested fixes in.
  &minus;extra&minus;arg=&lt;string&gt;        &minus; Additional argument to append to the compiler command line
                               Can be used several times.
  &minus;extra&minus;arg&minus;before=&lt;string&gt; &minus; Additional argument to prepend to the compiler command line
                               Can be used several times.
  &minus;force                     &minus; Ignore nonexistent qualified names.
  &minus;i                         &minus; Overwrite edited &lt;file&gt;s.
  &minus;input=&lt;string&gt;            &minus; YAML file to load oldname&minus;newname pairs from.
  &minus;new&minus;name=&lt;string&gt;         &minus; The new name to change the symbol to.
  &minus;offset=&lt;uint&gt;             &minus; Locates the symbol by offset as opposed to &lt;line&gt;:&lt;column&gt;.
  &minus;p &lt;string&gt;                &minus; Build path
  &minus;pl                        &minus; Print the locations affected by renaming to stderr.
  &minus;pn                        &minus; Print the found symbol's name prior to renaming to stderr.
  &minus;qualified&minus;name=&lt;string&gt;   &minus; The fully qualified name of the symbol.</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Vim
Integration</b> <br>
You can call <b>clang&minus;rename</b> directly from Vim! To
set up <b>clang&minus;rename</b> integration for Vim see
<i>clang/tools/clang&minus;rename/clang&minus;rename.py</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that <b>you have to save all buffers, in which the
replacement will happen before running the tool</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Once installed,
you can point your cursor to symbols you want to rename,
press <i>&lt;leader&gt;cr</i> and type new desired name. The
<i>&lt;leader&gt; key</i> is a reference to a specific key
defined by the mapleader variable and is bound to backslash
by default.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Emacs
Integration</b> <br>
You can also use <b>clang&minus;rename</b> while using
Emacs! To set up <b>clang&minus;rename</b> integration for
Emacs see
<i>clang&minus;rename/tool/clang&minus;rename.el</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Once installed,
you can point your cursor to symbols you want to rename,
press <i>M&minus;X</i>, type <i>clang&minus;rename</i> and
new desired name.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that <b>you have to save all buffers, in which the
replacement will happen before running the tool</b>.</p>

<h2>CLANG-DOC
<a name="CLANG-DOC"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Contents</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="14%">


<p style="margin-top: 1em"><i>Clang&minus;Doc</i></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:14%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%"></td>
<td width="2%"></td>
<td width="20%">


<p style="margin-top: 1em"><i>Use</i></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p><i>Output</i></p></td>
<td width="63%">
</td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="20%">


<p><i>Configuration</i></p></td>
<td width="63%">
</td></tr>
</table>

<p style="margin-left:17%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="11%">


<p style="margin-top: 1em"><i>Options</i></p></td>
<td width="69%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>clang&minus;doc</b>
is a tool for generating C and C++ documentation from source
code and comments.</p>

<p style="margin-left:11%; margin-top: 1em">The tool is in
a very early development stage, so you might encounter bugs
and crashes. Submitting reports with information about how
to reproduce the issue to <i>the LLVM bug tracker</i> will
definitely help the project. If you have any ideas or
suggestions, please to put a feature request there.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Use <br>
clang&minus;doc</b> is a <i>LibTooling</i>&minus;based tool,
and so requires a compile command database for your project
(for an example of how to do this see <i>How To Setup
Tooling For LLVM</i>).</p>

<p style="margin-left:11%; margin-top: 1em">By default, the
tool will run on all files listed in the given compile
commands database:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;doc /path/to/compile_commands.json</pre>


<p style="margin-left:11%; margin-top: 1em">The tool can
also be used on a single file or multiple files if a build
path is passed with the <b>&minus;p</b> flag.</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;doc /path/to/file.cpp &minus;p /path/to/build</pre>


<p style="margin-left:11%; margin-top: 1em"><b>Output <br>
clang&minus;doc</b> produces a directory of documentation.
One file is produced for each namespace and record in the
project source code, containing all documentation (including
contained functions, methods, and enums) for that item.</p>

<p style="margin-left:11%; margin-top: 1em">The
top&minus;level directory is configurable through the
<b>output</b> flag:</p>

<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;doc &minus;output=output/directory/ compile_commands.json</pre>



<p style="margin-left:11%; margin-top: 1em"><b>Configuration</b>
<br>
Configuration for <b>clang&minus;doc</b> is currently
limited to command&minus;line options. In the future, it may
develop the ability to use a configuration file, but no such
efforts are currently in progress.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Options <br>
clang&minus;doc</b> offers the following options:</p>
<pre style="margin-left:15%; margin-top: 1em">$ clang&minus;doc &minus;&minus;help
USAGE: clang&minus;doc [options] &lt;source0&gt; [... &lt;sourceN&gt;]

OPTIONS:

Generic Options:

  &minus;help                      &minus; Display available options (&minus;help&minus;hidden for more)
  &minus;help&minus;list                 &minus; Display list of available options (&minus;help&minus;list&minus;hidden for more)
  &minus;version                   &minus; Display the version of this program

clang&minus;doc options:


  &minus;&minus;doxygen                   &minus; Use only doxygen&minus;style comments to generate docs.
  &minus;&minus;extra&minus;arg=&lt;string&gt;        &minus; Additional argument to append to the compiler command line
                                Can be used several times.
  &minus;&minus;extra&minus;arg&minus;before=&lt;string&gt; &minus; Additional argument to prepend to the compiler command line
                                Can be used several times.
  &minus;&minus;format=&lt;value&gt;            &minus; Format for outputted docs.
    =yaml                     &minus;   Documentation in YAML format.
    =md                       &minus;   Documentation in MD format.
    =html                     &minus;   Documentation in HTML format.
  &minus;&minus;ignore&minus;map&minus;errors         &minus; Continue if files are not mapped correctly.
  &minus;&minus;output=&lt;string&gt;           &minus; Directory for outputting generated files.
  &minus;p &lt;string&gt;                 &minus; Build path
  &minus;&minus;project&minus;name=&lt;string&gt;     &minus; Name of project.
  &minus;&minus;public                    &minus; Document only public declarations.
  &minus;&minus;repository=&lt;string&gt;       &minus;
                                URL of repository that hosts code.
                                Used for links to definition locations.
  &minus;&minus;source&minus;root=&lt;string&gt;      &minus;
                                Directory where processed files are stored.
                                Links to definition locations will only be
                                generated if the file is in this dir.
  &minus;&minus;stylesheets=&lt;string&gt;      &minus; CSS stylesheets to extend the default styles.</pre>


<p style="margin-left:11%; margin-top: 1em">The following
flags should only be used if <b>format</b> is set to
<b>html</b>: &minus; <b>repository</b> &minus;
<b>source&minus;root</b> &minus; <b>stylesheets</b></p>

<p style="margin-left:11%; margin-top: 1em">The Doxygen
documentation describes the <b>internal</b> software that
makes up the tools of clang&minus;tools&minus;extra, not the
<b>external</b> use of these tools. The Doxygen
documentation contains no instructions about how to use the
tools, only the APIs that make up the software. For usage
instructions, please see the user's guide or reference
manual for each tool.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="32%">


<p style="margin-top: 1em"><i>Doxygen documentation</i></p></td>
<td width="54%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b></p>

<p style="margin-left:15%;">This documentation is generated
directly from the source code with doxygen. Since the tools
of clang&minus;tools&minus;extra are constantly under active
development, what you're about to read is out of date!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="17%">


<p style="margin-top: 1em"><i>Index</i></p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="17%">


<p><i>Search Page</i></p></td>
<td width="69%">
</td></tr>
</table>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Clang
Team</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">2007-2023, The
Clang Team</p>
<hr>
</body>
</html>
