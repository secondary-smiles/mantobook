<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:58 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLGIT</title>

</head>
<body>
<h1>perlgit</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlgit &minus;
Detailed information about git and the Perl repository</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
provides details on using git to develop Perl. If you are
just interested in working on a quick patch, see perlhack
first. This document is intended for people who are regular
contributors to Perl, including those with write access to
the git repository.</p>

<h2>CLONING THE REPOSITORY
<a name="CLONING THE REPOSITORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All of
Perl&rsquo;s source code is kept centrally in a Git
repository at <i>github.com</i>.</p>

<p style="margin-left:11%; margin-top: 1em">You can make a
read-only clone of the repository by running:</p>

<p style="margin-left:11%; margin-top: 1em">% git clone
git@github.com:Perl/perl5.git perl</p>

<p style="margin-left:11%; margin-top: 1em">If you cannot
use that for firewall reasons, you can also clone via
http:</p>

<p style="margin-left:11%; margin-top: 1em">% git clone
https://github.com/Perl/perl5.git perl</p>

<h2>WORKING WITH THE REPOSITORY
<a name="WORKING WITH THE REPOSITORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Once you have
changed into the repository directory, you can inspect it.
After a clone the repository will contain a single local
branch, which will be the current branch as well, as
indicated by the asterisk.</p>

<p style="margin-left:11%; margin-top: 1em">% git branch
<br>
* blead</p>

<p style="margin-left:11%; margin-top: 1em">Using the
&minus;a switch to &quot;branch&quot; will also show the
remote tracking branches in the repository:</p>

<p style="margin-left:11%; margin-top: 1em">% git branch
&minus;a <br>
* blead <br>
origin/HEAD <br>
origin/blead <br>
...</p>

<p style="margin-left:11%; margin-top: 1em">The branches
that begin with &quot;origin&quot; correspond to the
&quot;git remote&quot; that you cloned from (which is named
&quot;origin&quot;). Each branch on the remote will be
exactly tracked by these branches. You should
<small>NEVER</small> do work on these remote tracking
branches. You only ever do work in a local branch. Local
branches can be configured to automerge (on pull) from a
designated remote tracking branch. This is the case with the
default branch &quot;blead&quot; which will be configured to
merge from the remote tracking branch
&quot;origin/blead&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You can see
recent commits:</p>

<p style="margin-left:11%; margin-top: 1em">% git log</p>

<p style="margin-left:11%; margin-top: 1em">And pull new
changes from the repository, and update your local
repository (must be clean first)</p>

<p style="margin-left:11%; margin-top: 1em">% git pull</p>

<p style="margin-left:11%; margin-top: 1em">Assuming we are
on the branch &quot;blead&quot; immediately after a pull,
this command would be more or less equivalent to:</p>

<p style="margin-left:11%; margin-top: 1em">% git fetch
<br>
% git merge origin/blead</p>

<p style="margin-left:11%; margin-top: 1em">In fact if you
want to update your local repository without touching your
working directory you do:</p>

<p style="margin-left:11%; margin-top: 1em">% git fetch</p>

<p style="margin-left:11%; margin-top: 1em">And if you want
to update your remote-tracking branches for all defined
remotes simultaneously you can do</p>

<p style="margin-left:11%; margin-top: 1em">% git remote
update</p>

<p style="margin-left:11%; margin-top: 1em">Neither of
these last two commands will update your working directory,
however both will update the remote-tracking branches in
your repository.</p>

<p style="margin-left:11%; margin-top: 1em">To make a local
branch of a remote branch:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
&minus;b maint&minus;5.10 origin/maint&minus;5.10</p>

<p style="margin-left:11%; margin-top: 1em">To switch back
to blead:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
blead</p>

<p style="margin-left:11%; margin-top: 1em"><b>Finding out
your status</b> <br>
The most common git command you will use will probably
be</p>

<p style="margin-left:11%; margin-top: 1em">% git
status</p>

<p style="margin-left:11%; margin-top: 1em">This command
will produce as output a description of the current state of
the repository, including modified files and unignored
untracked files, and in addition it will show things like
what files have been staged for the next commit, and usually
some useful information about how to change things. For
instance the following:</p>

<p style="margin-left:11%; margin-top: 1em">% git status
<br>
On branch blead <br>
Your branch is ahead of 'origin/blead' by 1 commit. <br>
Changes to be committed: <br>
(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
<br>
modified: pod/perlgit.pod <br>
Changes not staged for commit: <br>
(use &quot;git add &lt;file&gt;...&quot; to update what will
be committed) <br>
(use &quot;git checkout &minus;&minus; &lt;file&gt;...&quot;
to discard changes in working <br>
directory) <br>
modified: pod/perlgit.pod <br>
Untracked files: <br>
(use &quot;git add &lt;file&gt;...&quot; to include in what
will be committed) <br>
deliberate.untracked</p>

<p style="margin-left:11%; margin-top: 1em">This shows that
there were changes to this document staged for commit, and
that there were further changes in the working directory not
yet staged. It also shows that there was an untracked file
in the working directory, and as you can see shows how to
change all of this. It also shows that there is one commit
on the working branch &quot;blead&quot; which has not been
pushed to the &quot;origin&quot; remote yet.
<b><small>NOTE</small></b> : This output is also what you
see as a template if you do not provide a message to
&quot;git commit&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Patch
workflow</b> <br>
First, please read perlhack for details on hacking the Perl
core. That document covers many details on how to create a
good patch.</p>

<p style="margin-left:11%; margin-top: 1em">If you already
have a Perl repository, you should ensure that you&rsquo;re
on the <i>blead</i> branch, and your repository is up to
date:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
blead <br>
% git pull</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s
preferable to patch against the latest blead version, since
this is where new development occurs for all changes other
than critical bug fixes. Critical bug fix patches should be
made against the relevant maint branches, or should be
submitted with a note indicating all the branches where the
fix should be applied.</p>

<p style="margin-left:11%; margin-top: 1em">Now that we
have everything up to date, we need to create a temporary
new branch for these changes and switch into it:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
&minus;b orange</p>

<p style="margin-left:11%; margin-top: 1em">which is the
short form of</p>

<p style="margin-left:11%; margin-top: 1em">% git branch
orange <br>
% git checkout orange</p>

<p style="margin-left:11%; margin-top: 1em">Creating a
topic branch makes it easier for the maintainers to rebase
or merge back into the master blead for a more linear
history. If you don&rsquo;t work on a topic branch the
maintainer has to manually cherry pick your changes onto
blead before they can be applied.</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;ll
get you scolded on perl5&minus;porters, so don&rsquo;t do
that. Be Awesome.</p>

<p style="margin-left:11%; margin-top: 1em">Then make your
changes. For example, if Leon Brocard changes his name to
Orange Brocard, we should change his name in the
<small>AUTHORS</small> file:</p>

<p style="margin-left:11%; margin-top: 1em">% perl
&minus;pi &minus;e 's{Leon Brocard}{Orange Brocard}'
AUTHORS</p>

<p style="margin-left:11%; margin-top: 1em">You can see
what files are changed:</p>

<p style="margin-left:11%; margin-top: 1em">% git status
<br>
On branch orange <br>
Changes to be committed: <br>
(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
<br>
modified: AUTHORS</p>

<p style="margin-left:11%; margin-top: 1em">And you can see
the changes:</p>

<p style="margin-left:11%; margin-top: 1em">% git diff <br>
diff &minus;&minus;git a/AUTHORS b/AUTHORS <br>
index 293dd70..722c93e 100644 <br>
&minus;&minus;&minus; a/AUTHORS <br>
+++ b/AUTHORS <br>
@@ &minus;541,7 +541,7 @@ Lars Hecking
&lt;lhecking@nmrc.ucc.ie&gt; <br>
Laszlo Molnar &lt;laszlo.molnar@eth.ericsson.se&gt; <br>
Leif Huhn &lt;leif@hale.dkstat.com&gt; <br>
Len Johnson &lt;lenjay@ibm.net&gt; <br>
&minus;Leon Brocard &lt;acme@astray.com&gt; <br>
+Orange Brocard &lt;acme@astray.com&gt; <br>
Les Peters &lt;lpeters@aol.net&gt; <br>
Lesley Binks &lt;lesley.binks@gmail.com&gt; <br>
Lincoln D. Stein &lt;lstein@cshl.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Now commit your
change locally:</p>

<p style="margin-left:11%; margin-top: 1em">% git commit
&minus;a &minus;m 'Rename Leon Brocard to Orange Brocard'
<br>
Created commit 6196c1d: Rename Leon Brocard to Orange
Brocard <br>
1 files changed, 1 insertions(+), 1 deletions(&minus;)</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;&minus;a&quot; option is used to include all files
that git tracks that you have changed. If at this time, you
only want to commit some of the files you have worked on,
you can omit the &quot;&minus;a&quot; and use the command
&quot;git&nbsp;add&nbsp;<i>FILE&nbsp;...</i>&quot; before
doing the commit.
&quot;git&nbsp;add&nbsp;&minus;&minus;interactive&quot;
allows you to even just commit portions of files instead of
all the changes in them.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;&minus;m&quot; option is used to specify the commit
message. If you omit it, git will open a text editor for you
to compose the message interactively. This is useful when
the changes are more complex than the sample given here,
and, depending on the editor, to know that the first line of
the commit message doesn&rsquo;t exceed the 50 character
legal maximum. See &quot;Commit message&quot; in perlhack
for more information about what makes a good commit
message.</p>

<p style="margin-left:11%; margin-top: 1em">Once
you&rsquo;ve finished writing your commit message and exited
your editor, git will write your change to disk and tell you
something like this:</p>

<p style="margin-left:11%; margin-top: 1em">Created commit
daf8e63: explain git status and stuff about remotes <br>
1 files changed, 83 insertions(+), 3 deletions(&minus;)</p>

<p style="margin-left:11%; margin-top: 1em">If you re-run
&quot;git status&quot;, you should see something like
this:</p>

<p style="margin-left:11%; margin-top: 1em">% git status
<br>
On branch orange <br>
Untracked files: <br>
(use &quot;git add &lt;file&gt;...&quot; to include in what
will be committed) <br>
deliberate.untracked <br>
nothing added to commit but untracked files present (use
&quot;git add&quot; to <br>
track)</p>

<p style="margin-left:11%; margin-top: 1em">When in doubt,
before you do anything else, check your status and read it
carefully, many questions are answered directly by the git
status output.</p>

<p style="margin-left:11%; margin-top: 1em">You can examine
your last commit with:</p>

<p style="margin-left:11%; margin-top: 1em">% git show
HEAD</p>

<p style="margin-left:11%; margin-top: 1em">and if you are
not happy with either the description or the patch itself
you can fix it up by editing the files once more and then
issue:</p>

<p style="margin-left:11%; margin-top: 1em">% git commit
&minus;a &minus;&minus;amend</p>

<p style="margin-left:11%; margin-top: 1em">Now, create a
fork on GitHub to push your branch to, and add it as a
remote if you haven&rsquo;t already, as described in the
GitHub documentation at
&lt;https://help.github.com/en/articles/working&minus;with&minus;forks&gt;:</p>

<p style="margin-left:11%; margin-top: 1em">% git remote
add fork git@github.com:MyUser/perl5.git</p>

<p style="margin-left:11%; margin-top: 1em">And push the
branch to your fork:</p>

<p style="margin-left:11%; margin-top: 1em">% git push
&minus;u fork orange</p>

<p style="margin-left:11%; margin-top: 1em">You should now
submit a Pull Request ( <small>PR</small> ) on GitHub from
the new branch to blead. For more information, see the
GitHub documentation at
&lt;https://help.github.com/en/articles/creating&minus;a&minus;pull&minus;request&minus;from&minus;a&minus;fork&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
send patch files to perl5&minus;porters@perl.org
&lt;mailto:perl5-porters@perl.org&gt; directly if the patch
is not ready to be applied, but intended for discussion.</p>

<p style="margin-left:11%; margin-top: 1em">To create a
patch file for all your local changes:</p>

<p style="margin-left:11%; margin-top: 1em">% git
format&minus;patch &minus;M blead.. <br>

0001&minus;Rename&minus;Leon&minus;Brocard&minus;to&minus;Orange&minus;Brocard.patch</p>

<p style="margin-left:11%; margin-top: 1em">Or for a lot of
changes, e.g. from a topic branch:</p>

<p style="margin-left:11%; margin-top: 1em">% git
format&minus;patch &minus;&minus;stdout &minus;M blead..
&gt; topic&minus;branch&minus;changes.patch</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
delete your temporary branch, you may do so with:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
blead <br>
% git branch &minus;d orange <br>
error: The branch 'orange' is not an ancestor of your
current HEAD. <br>
If you are sure you want to delete it, run 'git branch
&minus;D orange'. <br>
% git branch &minus;D orange <br>
Deleted branch orange.</p>

<p style="margin-left:11%; margin-top: 1em"><b>A note on
derived files</b> <br>
Be aware that many files in the distribution are
derivative--avoid patching them, because git won&rsquo;t see
the changes to them, and the build process will overwrite
them. Patch the originals instead. Most utilities (like
perldoc) are in this category, i.e. patch
<i>utils/perldoc.PL</i> rather than <i>utils/perldoc</i>.
Similarly, don&rsquo;t create patches for files under
<i>$src_root/ext</i> from their copies found in
<i>$install_root/lib</i>. If you are unsure about the proper
location of a file that may have gotten copied while
building the source distribution, consult the
<i><small>MANIFEST</small></i> .</p>

<p style="margin-left:11%; margin-top: 1em"><b>Cleaning a
working directory</b> <br>
The command &quot;git clean&quot; can with varying arguments
be used as a replacement for &quot;make clean&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To reset your
working directory to a pristine condition you can do:</p>

<p style="margin-left:11%; margin-top: 1em">% git clean
&minus;dxf</p>

<p style="margin-left:11%; margin-top: 1em">However, be
aware this will delete <small>ALL</small> untracked content.
You can use</p>

<p style="margin-left:11%; margin-top: 1em">% git clean
&minus;Xf</p>

<p style="margin-left:11%; margin-top: 1em">to remove all
ignored untracked files, such as build and test byproduct,
but leave any manually created files alone.</p>

<p style="margin-left:11%; margin-top: 1em">If you only
want to cancel some uncommitted edits, you can use &quot;git
checkout&quot; and give it a list of files to be reverted,
or &quot;git checkout &minus;f&quot; to revert them all.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
cancel one or several commits, you can use &quot;git
reset&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Bisecting</b>
<br>
&quot;git&quot; provides a built-in way to determine which
commit should be blamed for introducing a given bug.
&quot;git bisect&quot; performs a binary search of history
to locate the first failing commit. It is fast, powerful and
flexible, but requires some setup and to automate the
process an auxiliary shell script is needed.</p>

<p style="margin-left:11%; margin-top: 1em">The core
provides a wrapper program, <i>Porting/bisect.pl</i>, which
attempts to simplify as much as possible, making bisecting
as simple as running a Perl one-liner. For example, if you
want to know when this became an error:</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;e
'my $a := 2'</p>

<p style="margin-left:11%; margin-top: 1em">you simply run
this:</p>


<p style="margin-left:11%; margin-top: 1em">.../Porting/bisect.pl
&minus;e 'my $a := 2;'</p>

<p style="margin-left:11%; margin-top: 1em">Using
<i>Porting/bisect.pl</i>, with one command (and no other
files) it&rsquo;s easy to find out</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Which commit caused this example code to break?</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Which commit caused this example code to start
working?</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Which commit added the first file to match this
regex?</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Which commit removed the last file to match this
regex?</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">usually without
needing to know which versions of perl to use as start and
end revisions, as <i>Porting/bisect.pl</i> automatically
searches to find the earliest stable version for which the
test case passes. Run &quot;Porting/bisect.pl
&minus;&minus;help&quot; for the full documentation,
including how to set the &quot;Configure&quot; and build
time options.</p>

<p style="margin-left:11%; margin-top: 1em">If you require
more flexibility than <i>Porting/bisect.pl</i> has to offer,
you&rsquo;ll need to run &quot;git bisect&quot; yourself.
It&rsquo;s most useful to use &quot;git bisect run&quot; to
automate the building and testing of perl revisions. For
this you&rsquo;ll need a shell script for &quot;git&quot; to
call to test a particular revision. An example script is
<i>Porting/bisect&minus;example.sh</i>, which you should
copy <b>outside</b> of the repository, as the bisect process
will reset the state to a clean checkout as it runs. The
instructions below assume that you copied it as <i>~/run</i>
and then edited it as appropriate.</p>

<p style="margin-left:11%; margin-top: 1em">You first enter
in bisect mode with:</p>

<p style="margin-left:11%; margin-top: 1em">% git bisect
start</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
the bug is present on &quot;HEAD&quot; but wasn&rsquo;t in
5.10.0, &quot;git&quot; will learn about this when you
enter:</p>

<p style="margin-left:11%; margin-top: 1em">% git bisect
bad <br>
% git bisect good perl&minus;5.10.0 <br>
Bisecting: 853 revisions left to test after this</p>

<p style="margin-left:11%; margin-top: 1em">This results in
checking out the median commit between &quot;HEAD&quot; and
&quot;perl&minus;5.10.0&quot;. You can then run the
bisecting process with:</p>

<p style="margin-left:11%; margin-top: 1em">% git bisect
run ~/run</p>

<p style="margin-left:11%; margin-top: 1em">When the first
bad commit is isolated, &quot;git bisect&quot; will tell you
so:</p>


<p style="margin-left:11%; margin-top: 1em">ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5
is first bad commit <br>
commit ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5 <br>
Author: Dave Mitchell &lt;davem@fdisolutions.com&gt; <br>
Date: Sat Feb 9 14:56:23 2008 +0000 <br>
[perl #49472] Attributes + Unknown Error <br>
... <br>
bisect run success</p>

<p style="margin-left:11%; margin-top: 1em">You can peek
into the bisecting process with &quot;git bisect log&quot;
and &quot;git bisect visualize&quot;. &quot;git bisect
reset&quot; will get you out of bisect mode.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that the first &quot;good&quot; state must be an ancestor of
the first &quot;bad&quot; state. If you want to search for
the commit that <i>solved</i> some bug, you have to negate
your test case (i.e. exit with 1 if <small>OK</small> and 0
if not) and still mark the lower bound as &quot;good&quot;
and the upper as &quot;bad&quot;. The &quot;first bad
commit&quot; has then to be understood as the &quot;first
commit where the bug is solved&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;git help
bisect&quot; has much more information on how you can tweak
your binary searches.</p>

<p style="margin-left:11%; margin-top: 1em">Following
bisection you may wish to configure, build and test perl at
commits identified by the bisection process. Sometimes,
particularly with older perls, &quot;make&quot; may fail
during this process. In this case you may be able to patch
the source code at the older commit point. To do so, please
follow the suggestions provided in &quot;Building perl at
older commits&quot; in perlhack.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Topic
branches and rewriting history</b> <br>
Individual committers should create topic branches under
<b>yourname</b>/<b>some_descriptive_name</b>:</p>

<p style="margin-left:11%; margin-top: 1em">%
branch=&quot;$yourname/$some_descriptive_name&quot; <br>
% git checkout &minus;b $branch <br>
... do local edits, commits etc ... <br>
% git push origin &minus;u $branch</p>

<p style="margin-left:11%; margin-top: 1em">Should you be
stuck with an ancient version of git (prior to 1.7), then
&quot;git push&quot; will not have the &quot;&minus;u&quot;
switch, and you have to replace the last step with the
following sequence:</p>

<p style="margin-left:11%; margin-top: 1em">% git push
origin $branch:refs/heads/$branch <br>
% git config branch.$branch.remote origin <br>
% git config branch.$branch.merge refs/heads/$branch</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
make changes to someone else&rsquo;s topic branch, you
should check with its creator before making any change to
it.</p>

<p style="margin-left:11%; margin-top: 1em">You might
sometimes find that the original author has edited the
branch&rsquo;s history. There are lots of good reasons for
this. Sometimes, an author might simply be rebasing the
branch onto a newer source point. Sometimes, an author might
have found an error in an early commit which they wanted to
fix before merging the branch to blead.</p>

<p style="margin-left:11%; margin-top: 1em">Currently the
master repository is configured to forbid non-fast-forward
merges. This means that the branches within can not be
rebased and pushed as a single step.</p>

<p style="margin-left:11%; margin-top: 1em">The only way
you will ever be allowed to rebase or modify the history of
a pushed branch is to delete it and push it as a new branch
under the same name. Please think carefully about doing
this. It may be better to sequentially rename your branches
so that it is easier for others working with you to
cherry-pick their local changes onto the new version. (
<small>XXX:</small> needs explanation).</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
rebase a personal topic branch, you will have to delete your
existing topic branch and push as a new version of it. You
can do this via the following formula (see the explanation
about &quot;refspec&quot;&rsquo;s in the git push
documentation for details) after you have rebased your
branch:</p>

<p style="margin-left:11%; margin-top: 1em"># first rebase
<br>
% git checkout $user/$topic <br>
% git fetch <br>
% git rebase origin/blead <br>
# then &quot;delete&minus;and&minus;push&quot; <br>
% git push origin :$user/$topic <br>
% git push origin $user/$topic</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE:</small></b>
it is forbidden at the repository level to delete any of the
&quot;primary&quot; branches. That is any branch matching
&quot;m!^(blead|maint|perl)!&quot;. Any attempt to do so
will result in git producing an error like this:</p>

<p style="margin-left:11%; margin-top: 1em">% git push
origin :blead <br>
*** It is forbidden to delete blead/maint branches in this
repository <br>
error: hooks/update exited with error code 1 <br>
error: hook declined to update refs/heads/blead <br>
To ssh://perl5.git.perl.org/perl <br>
! [remote rejected] blead (hook declined) <br>
error: failed to push some refs to
'ssh://perl5.git.perl.org/perl'</p>

<p style="margin-left:11%; margin-top: 1em">As a matter of
policy we do <b>not</b> edit the history of the blead and
maint&minus;* branches. If a typo (or worse) sneaks into a
commit to blead or maint&minus;*, we&rsquo;ll fix it in
another commit. The only types of updates allowed on these
branches are &quot;fast-forwards&quot;, where all history is
preserved.</p>

<p style="margin-left:11%; margin-top: 1em">Annotated tags
in the canonical perl.git repository will never be deleted
or modified. Think long and hard about whether you want to
push a local tag to perl.git before doing so. (Pushing
simple tags is not allowed.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Grafts</b>
<br>
The perl history contains one mistake which was not caught
in the conversion: a merge was recorded in the history
between blead and maint&minus;5.10 where no merge actually
occurred. Due to the nature of git, this is now impossible
to fix in the public repository. You can remove this
mis-merge locally by adding the following line to your
&quot;.git/info/grafts&quot; file:</p>


<p style="margin-left:11%; margin-top: 1em">296f12bbbbaa06de9be9d09d3dcf8f4528898a49
434946e0cb7a32589ed92d18008aaa1d88515930</p>

<p style="margin-left:11%; margin-top: 1em">It is
particularly important to have this graft line if any
bisecting is done in the area of the &quot;merge&quot; in
question.</p>

<h2>WRITE ACCESS TO THE GIT REPOSITORY
<a name="WRITE ACCESS TO THE GIT REPOSITORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Once you have
write access, you will need to modify the <small>URL</small>
for the origin remote to enable pushing. Edit
<i>.git/config</i> with the <b>git&minus;config</b>(1)
command:</p>

<p style="margin-left:11%; margin-top: 1em">% git config
remote.origin.url git@github.com:Perl/perl5.git</p>

<p style="margin-left:11%; margin-top: 1em">You can also
set up your user name and e&minus;mail address. Most people
do this once globally in their <i>~/.gitconfig</i> by doing
something like:</p>

<p style="margin-left:11%; margin-top: 1em">% git config
&minus;&minus;global user.name &quot;AEvar Arnfjoer`
Bjarmason&quot; <br>
% git config &minus;&minus;global user.email
avarab@gmail.com</p>

<p style="margin-left:11%; margin-top: 1em">However, if
you&rsquo;d like to override that just for perl, execute
something like the following in <i>perl</i>:</p>

<p style="margin-left:11%; margin-top: 1em">% git config
user.email avar@cpan.org</p>

<p style="margin-left:11%; margin-top: 1em">It is also
possible to keep &quot;origin&quot; as a git remote, and add
a new remote for ssh access:</p>

<p style="margin-left:11%; margin-top: 1em">% git remote
add camel git@github.com:Perl/perl5.git</p>

<p style="margin-left:11%; margin-top: 1em">This allows you
to update your local repository by pulling from
&quot;origin&quot;, which is faster and doesn&rsquo;t
require you to authenticate, and to push your changes back
with the &quot;camel&quot; remote:</p>

<p style="margin-left:11%; margin-top: 1em">% git fetch
camel <br>
% git push camel</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;fetch&quot; command just updates the &quot;camel&quot;
refs, as the objects themselves should have been fetched
when pulling from &quot;origin&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Working with
Github pull requests</b> <br>
Pull requests typically originate from outside of the
&quot;Perl/perl.git&quot; repository, so if you want to test
or work with it locally a vanilla &quot;git fetch&quot; from
the &quot;Perl/perl5.git&quot; repository won&rsquo;t fetch
it.</p>

<p style="margin-left:11%; margin-top: 1em">However Github
does provide a mechanism to fetch a pull request to a local
branch. They are available on Github remotes under
&quot;pull/&quot;, so you can use &quot;git fetch
pull/<i>PRID</i>/head:<i>localname</i>&quot; to make a local
copy. eg. to fetch pull request 9999 to the local branch
&quot;local&minus;branch&minus;name&quot; run:</p>

<p style="margin-left:11%; margin-top: 1em">git fetch
origin pull/9999/head:local&minus;branch&minus;name</p>

<p style="margin-left:11%; margin-top: 1em">and then:</p>

<p style="margin-left:11%; margin-top: 1em">git checkout
local&minus;branch&minus;name</p>

<p style="margin-left:11%; margin-top: 1em">Note: this
branch is not rebased on &quot;blead&quot;, so instead of
the checkout above, you might want:</p>

<p style="margin-left:11%; margin-top: 1em">git rebase
origin/blead local&minus;branch&minus;name</p>

<p style="margin-left:11%; margin-top: 1em">which rebases
&quot;local&minus;branch&minus;name&quot; on
&quot;blead&quot;, and checks it out.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively
you can configure the remote to fetch all pull requests as
remote-tracking branches. To do this edit the remote in
<i>.git/config</i>, for example if your github remote is
&quot;origin&quot; you&rsquo;d have:</p>

<p style="margin-left:11%; margin-top: 1em">[remote
&quot;origin&quot;] <br>
url = git@github.com:/Perl/perl5.git <br>
fetch = +refs/heads/*:refs/remotes/origin/*</p>

<p style="margin-left:11%; margin-top: 1em">Add a line to
map the remote pull request branches to remote-tracking
branches:</p>

<p style="margin-left:11%; margin-top: 1em">[remote
&quot;origin&quot;] <br>
url = git@github.com:/Perl/perl5.git <br>
fetch = +refs/heads/*:refs/remotes/origin/* <br>
fetch = +refs/pull/*/head:refs/remotes/origin/pull/*</p>

<p style="margin-left:11%; margin-top: 1em">and then do a
fetch as normal:</p>

<p style="margin-left:11%; margin-top: 1em">git fetch
origin</p>

<p style="margin-left:11%; margin-top: 1em">This will
create a remote-tracking branch for every pull request,
including closed requests.</p>

<p style="margin-left:11%; margin-top: 1em">To remove those
remote-tracking branches, remove the line added above and
prune:</p>

<p style="margin-left:11%; margin-top: 1em">git fetch
&minus;p origin # or git remote prune origin</p>

<p style="margin-left:11%; margin-top: 1em"><b>Accepting a
patch</b> <br>
If you have received a patch file generated using the above
section, you should try out the patch.</p>

<p style="margin-left:11%; margin-top: 1em">First we need
to create a temporary new branch for these changes and
switch into it:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
&minus;b experimental</p>

<p style="margin-left:11%; margin-top: 1em">Patches that
were formatted by &quot;git format&minus;patch&quot; are
applied with &quot;git am&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">% git am
0001&minus;Rename&minus;Leon&minus;Brocard&minus;to&minus;Orange&minus;Brocard.patch
<br>
Applying Rename Leon Brocard to Orange Brocard</p>

<p style="margin-left:11%; margin-top: 1em">Note that some
<small>UNIX</small> mail systems can mess with text
attachments containing &rsquo;From &rsquo;. This will fix
them up:</p>

<p style="margin-left:11%; margin-top: 1em">% perl
&minus;pi &minus;e's/^&gt;From /From /' \ <br>

0001&minus;Rename&minus;Leon&minus;Brocard&minus;to&minus;Orange&minus;Brocard.patch</p>

<p style="margin-left:11%; margin-top: 1em">If just a raw
diff is provided, it is also possible use this two-step
process:</p>

<p style="margin-left:11%; margin-top: 1em">% git apply
bugfix.diff <br>
% git commit &minus;a &minus;m &quot;Some fixing&quot; \
<br>
&minus;&minus;author=&quot;That Guy
&lt;that.guy@internets.com&gt;&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Now we can
inspect the change:</p>

<p style="margin-left:11%; margin-top: 1em">% git show HEAD
<br>
commit b1b3dab48344cff6de4087efca3dbd63548ab5e2 <br>
Author: Leon Brocard &lt;acme@astray.com&gt; <br>
Date: Fri Dec 19 17:02:59 2008 +0000 <br>
Rename Leon Brocard to Orange Brocard <br>
diff &minus;&minus;git a/AUTHORS b/AUTHORS <br>
index 293dd70..722c93e 100644 <br>
&minus;&minus;&minus; a/AUTHORS <br>
+++ b/AUTHORS <br>
@@ &minus;541,7 +541,7 @@ Lars Hecking
&lt;lhecking@nmrc.ucc.ie&gt; <br>
Laszlo Molnar &lt;laszlo.molnar@eth.ericsson.se&gt; <br>
Leif Huhn &lt;leif@hale.dkstat.com&gt; <br>
Len Johnson &lt;lenjay@ibm.net&gt; <br>
&minus;Leon Brocard &lt;acme@astray.com&gt; <br>
+Orange Brocard &lt;acme@astray.com&gt; <br>
Les Peters &lt;lpeters@aol.net&gt; <br>
Lesley Binks &lt;lesley.binks@gmail.com&gt; <br>
Lincoln D. Stein &lt;lstein@cshl.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">If you are a
committer to Perl and you think the patch is good, you can
then merge it into blead then push it out to the main
repository:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
blead <br>
% git merge experimental <br>
% git push origin blead</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
delete your temporary branch, you may do so with:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
blead <br>
% git branch &minus;d experimental <br>
error: The branch 'experimental' is not an ancestor of your
current <br>
HEAD. If you are sure you want to delete it, run 'git branch
&minus;D <br>
experimental'. <br>
% git branch &minus;D experimental <br>
Deleted branch experimental.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Committing
to blead</b> <br>
The &rsquo;blead&rsquo; branch will become the next
production release of Perl.</p>

<p style="margin-left:11%; margin-top: 1em">Before pushing
<i>any</i> local change to blead, it&rsquo;s incredibly
important that you do a few things, lest other committers
come after you with pitchforks and torches:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Make sure you have a good commit
message. See &quot;Commit message&quot; in perlhack for
details.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Run the test suite. You might not think that one typo
fix would break a test file. You&rsquo;d be wrong.
Here&rsquo;s an example of where not running the suite
caused problems. A patch was submitted that added a couple
of tests to an existing <i>.t</i>. It couldn&rsquo;t
possibly affect anything else, so no need to test beyond the
single affected <i>.t</i>, right? But, the submitter&rsquo;s
email address had changed since the last of their
submissions, and this caused other tests to fail. Running
the test target given in the next item would have caught
this problem.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If you don&rsquo;t run the full test suite, at least
&quot;make test_porting&quot;. This will run basic sanity
checks. To see which sanity checks, have a look in
<i>t/porting</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If you make any changes that affect miniperl or core
routines that have different code paths for miniperl, be
sure to run &quot;make minitest&quot;. This will catch
problems that even the full test suite will not catch
because it runs a subset of tests under miniperl rather than
perl.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>On merging
and rebasing</b> <br>
Simple, one-off commits pushed to the &rsquo;blead&rsquo;
branch should be simple commits that apply cleanly. In other
words, you should make sure your work is committed against
the current position of blead, so that you can push back to
the master repository without merging.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes,
blead will move while you&rsquo;re building or testing your
changes. When this happens, your push will be rejected with
a message like this:</p>

<p style="margin-left:11%; margin-top: 1em">To
ssh://perl5.git.perl.org/perl.git <br>
! [rejected] blead &minus;&gt; blead
(non&minus;fast&minus;forward) <br>
error: failed to push some refs to
'ssh://perl5.git.perl.org/perl.git' <br>
To prevent you from losing history,
non&minus;fast&minus;forward updates were <br>
rejected Merge the remote changes (e.g. 'git pull') before
pushing <br>
again. See the 'Note about fast&minus;forwards' section of
'git push &minus;&minus;help' <br>
for details.</p>

<p style="margin-left:11%; margin-top: 1em">When this
happens, you can just <i>rebase</i> your work against the
new position of blead, like this (assuming your remote for
the master repository is &quot;p5p&quot;):</p>

<p style="margin-left:11%; margin-top: 1em">% git fetch p5p
<br>
% git rebase p5p/blead</p>

<p style="margin-left:11%; margin-top: 1em">You will see
your commits being re-applied, and you will then be able to
push safely. More information about rebasing can be found in
the documentation for the <b>git&minus;rebase</b>(1)
command.</p>

<p style="margin-left:11%; margin-top: 1em">For larger sets
of commits that only make sense together, or that would
benefit from a summary of the set&rsquo;s purpose, you
should use a merge commit. You should perform your work on a
topic branch, which you should regularly rebase against
blead to ensure that your code is not broken by blead
moving. When you have finished your work, please perform a
final rebase and test. Linear history is something that gets
lost with every commit on blead, but a final rebase makes
the history linear again, making it easier for future
maintainers to see what has happened. Rebase as follows
(assuming your work was on the branch
&quot;committer/somework&quot;):</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
committer/somework <br>
% git rebase blead</p>

<p style="margin-left:11%; margin-top: 1em">Then you can
merge it into master like this:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
blead <br>
% git merge &minus;&minus;no&minus;ff
&minus;&minus;no&minus;commit committer/somework <br>
% git commit &minus;a</p>

<p style="margin-left:11%; margin-top: 1em">The switches
above deserve explanation.
&quot;&minus;&minus;no&minus;ff&quot; indicates that even if
all your work can be applied linearly against blead, a merge
commit should still be prepared. This ensures that all your
work will be shown as a side branch, with all its commits
merged into the mainstream blead by the merge commit.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;&minus;&minus;no&minus;commit&quot;
means that the merge commit will be <i>prepared</i> but not
<i>committed</i>. The commit is then actually performed when
you run the next command, which will bring up your editor to
describe the commit. Without
&quot;&minus;&minus;no&minus;commit&quot;, the commit would
be made with nearly no useful message, which would greatly
diminish the value of the merge commit as a placeholder for
the work&rsquo;s description.</p>

<p style="margin-left:11%; margin-top: 1em">When describing
the merge commit, explain the purpose of the branch, and
keep in mind that this description will probably be used by
the eventual release engineer when reviewing the next
perldelta document.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Committing
to maintenance versions</b> <br>
Maintenance versions should only be altered to add critical
bug fixes, see perlpolicy.</p>

<p style="margin-left:11%; margin-top: 1em">To commit to a
maintenance version of perl, you need to create a local
tracking branch:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
&minus;&minus;track &minus;b maint&minus;5.005
origin/maint&minus;5.005</p>

<p style="margin-left:11%; margin-top: 1em">This creates a
local branch named &quot;maint&minus;5.005&quot;, which
tracks the remote branch
&quot;origin/maint&minus;5.005&quot;. Then you can pull,
commit, merge and push as before.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
cherry-pick commits from blead and another branch, by using
the &quot;git cherry&minus;pick&quot; command. It is
recommended to use the <b>&minus;x</b> option to &quot;git
cherry&minus;pick&quot; in order to record the
<small>SHA1</small> of the original commit in the new commit
message.</p>

<p style="margin-left:11%; margin-top: 1em">Before pushing
any change to a maint version, make sure you&rsquo;ve
satisfied the steps in &quot;Committing to blead&quot;
above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using a
smoke-me branch to test changes</b> <br>
Sometimes a change affects code paths which you cannot test
on the OSes which are directly available to you and it would
be wise to have users on other OSes test the change before
you commit it to blead.</p>

<p style="margin-left:11%; margin-top: 1em">Fortunately,
there is a way to get your change smoke-tested on various
OSes: push it to a &quot;smoke-me&quot; branch and wait for
certain automated smoke-testers to report the results from
their OSes. A &quot;smoke-me&quot; branch is identified by
the branch name: specifically, as seen on github.com it must
be a local branch whose first name component is precisely
&quot;smoke&minus;me&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The procedure
for doing this is roughly as follows (using the example of
tonyc&rsquo;s smoke-me branch called win32stat):</p>

<p style="margin-left:11%; margin-top: 1em">First, make a
local branch and switch to it:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
&minus;b win32stat</p>

<p style="margin-left:11%; margin-top: 1em">Make some
changes, build perl and test your changes, then commit them
to your local branch. Then push your local branch to a
remote smoke-me branch:</p>

<p style="margin-left:11%; margin-top: 1em">% git push
origin win32stat:smoke&minus;me/tonyc/win32stat</p>

<p style="margin-left:11%; margin-top: 1em">Now you can
switch back to blead locally:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
blead</p>

<p style="margin-left:11%; margin-top: 1em">and continue
working on other things while you wait a day or two, keeping
an eye on the results reported for your smoke-me branch at
&lt;http://perl.develop&minus;help.com/?b=smoke&minus;me/tonyc/win32state&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">If all is well
then update your blead branch:</p>

<p style="margin-left:11%; margin-top: 1em">% git pull</p>

<p style="margin-left:11%; margin-top: 1em">then checkout
your smoke-me branch once more and rebase it on blead:</p>

<p style="margin-left:11%; margin-top: 1em">% git rebase
blead win32stat</p>

<p style="margin-left:11%; margin-top: 1em">Now switch back
to blead and merge your smoke-me branch into it:</p>

<p style="margin-left:11%; margin-top: 1em">% git checkout
blead <br>
% git merge win32stat</p>

<p style="margin-left:11%; margin-top: 1em">As described
earlier, if there are many changes on your smoke-me branch
then you should prepare a merge commit in which to give an
overview of those changes by using the following command
instead of the last command above:</p>

<p style="margin-left:11%; margin-top: 1em">% git merge
win32stat &minus;&minus;no&minus;ff
&minus;&minus;no&minus;commit</p>

<p style="margin-left:11%; margin-top: 1em">You should now
build perl and test your (merged) changes one last time
(ideally run the whole test suite, but failing that at least
run the <i>t/porting/*.t</i> tests) before pushing your
changes as usual:</p>

<p style="margin-left:11%; margin-top: 1em">% git push
origin blead</p>

<p style="margin-left:11%; margin-top: 1em">Finally, you
should then delete the remote smoke-me branch:</p>

<p style="margin-left:11%; margin-top: 1em">% git push
origin :smoke&minus;me/tonyc/win32stat</p>

<p style="margin-left:11%; margin-top: 1em">(which is
likely to produce a warning like this, which can be
ignored:</p>

<p style="margin-left:11%; margin-top: 1em">remote: fatal:
ambiguous argument <br>
'refs/heads/smoke&minus;me/tonyc/win32stat': <br>
unknown revision or path not in the working tree. <br>
remote: Use '&minus;&minus;' to separate paths from
revisions</p>

<p style="margin-left:11%; margin-top: 1em">) and then
delete your local branch:</p>

<p style="margin-left:11%; margin-top: 1em">% git branch
&minus;d win32stat</p>
<hr>
</body>
</html>
