<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:58 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLDEBGUTS</title>

</head>
<body>
<h1>perldebguts</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perldebguts
&minus; Guts of Perl debugging</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is not
perldebug, which tells you how to use the debugger. This
manpage describes low-level details concerning the
debugger&rsquo;s internals, which range from difficult to
impossible to understand for anyone who isn&rsquo;t
incredibly intimate with Perl&rsquo;s guts. Caveat
lector.</p>

<h2>Debugger Internals
<a name="Debugger Internals"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perl has
special debugging hooks at compile-time and run-time used to
create debugging environments. These hooks are not to be
confused with the <i>perl &minus;Dxxx</i> command described
in perlrun, which is usable only if a special Perl is built
per the instructions in the <i><small>INSTALL</small></i>
file in the Perl source tree.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
whenever you call Perl&rsquo;s built-in &quot;caller&quot;
function from the package &quot;DB&quot;, the arguments that
the corresponding stack frame was called with are copied to
the @DB::args array. These mechanisms are enabled by calling
Perl with the <b>&minus;d</b> switch. Specifically, the
following additional features are enabled (cf.
&quot;$^P&quot; in perlvar):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Perl inserts the contents of $ENV{PERL5DB} (or
&quot;BEGIN {require 'perl5db.pl'}&quot; if not present)
before the first line of your program.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Each array &quot;@{&quot;_&lt;$filename&quot;}&quot;
holds the lines of $filename for a file compiled by Perl.
The same is also true for &quot;eval&quot;ed strings that
contain subroutines, or which are currently being executed.
The $filename for &quot;eval&quot;ed strings looks like
&quot;(eval 34)&quot;.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Values in this
array are magical in numeric context: they compare equal to
zero only if the line is not breakable.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Each hash
&quot;%{&quot;_&lt;$filename&quot;}&quot; contains
breakpoints and actions keyed by line number. Individual
entries (as opposed to the whole hash) are settable. Perl
only cares about Boolean true here, although the values used
by <i>perl5db.pl</i> have the form
&quot;$break_condition\0$action&quot;.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The same holds
for evaluated strings that contain subroutines, or which are
currently being executed. The $filename for
&quot;eval&quot;ed strings looks like &quot;(eval
34)&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Each scalar
&quot;${&quot;_&lt;$filename&quot;}&quot; contains
$filename. This is also the case for evaluated strings that
contain subroutines, or which are currently being executed.
The $filename for &quot;eval&quot;ed strings looks like
&quot;(eval 34)&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>After each &quot;require&quot;d file is compiled, but
before it is executed,
&quot;DB::postponed(*{&quot;_&lt;$filename&quot;})&quot; is
called if the subroutine &quot;DB::postponed&quot; exists.
Here, the $filename is the expanded name of the
&quot;require&quot;d file, as found in the values of
%INC.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>After each subroutine &quot;subname&quot; is compiled,
the existence of $DB::postponed{subname} is checked. If this
key exists, &quot;DB::postponed(subname)&quot; is called if
the &quot;DB::postponed&quot; subroutine also exists.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A hash %DB::sub is maintained, whose keys are subroutine
names and whose values have the form
&quot;filename:startline&minus;endline&quot;.
&quot;filename&quot; has the form &quot;(eval 34)&quot; for
subroutines defined inside &quot;eval&quot;s.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>When the execution of your program reaches a point that
can hold a breakpoint, the &quot;DB::DB()&quot; subroutine
is called if any of the variables $DB::trace, $DB::single,
or $DB::signal is true. These variables are not
&quot;local&quot;izable. This feature is disabled when
executing inside &quot;DB::DB()&quot;, including functions
called from it unless &quot;$^D &amp; (1&lt;&lt;30)&quot; is
true.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>When execution of the program reaches a subroutine call,
a call to &amp;DB::sub(<i>args</i>) is made instead, with
$DB::sub set to identify the called subroutine. (This
doesn&rsquo;t happen if the calling subroutine was compiled
in the &quot;DB&quot; package.) $DB::sub normally holds the
name of the called subroutine, if it has a name by which it
can be looked up. Failing that, $DB::sub will hold a
reference to the called subroutine. Either way, the
&amp;DB::sub subroutine can use $DB::sub as a reference by
which to call the called subroutine, which it will normally
want to do.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If the call is
to an lvalue subroutine, and &amp;DB::lsub is defined
&amp;DB::lsub(<i>args</i>) is called instead, otherwise
falling back to &amp;DB::sub(<i>args</i>).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">When execution of the program
uses &quot;goto&quot; to enter a non-XS subroutine and the
0x80 bit is set in $^P, a call to &amp;DB::goto is made,
with $DB::sub set to identify the subroutine being entered.
The call to &amp;DB::goto does not replace the
&quot;goto&quot;; the requested subroutine will still be
entered once &amp;DB::goto has returned. $DB::sub normally
holds the name of the subroutine being entered, if it has
one. Failing that, $DB::sub will hold a reference to the
subroutine being entered. Unlike when &amp;DB::sub is
called, it is not guaranteed that $DB::sub can be used as a
reference to operate on the subroutine being entered.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that if
&amp;DB::sub needs external data for it to work, no
subroutine call is possible without it. As an example, the
standard debugger&rsquo;s &amp;DB::sub depends on the
$DB::deep variable (it defines how many levels of recursion
deep into the debugger you can go before a mandatory break).
If $DB::deep is not defined, subroutine calls are not
possible, even though &amp;DB::sub exists.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Writing Your
Own Debugger</b> <i><br>
Environment Variables</i></p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;PERL5DB&quot; environment variable can be used to
define a debugger. For example, the minimal
&quot;working&quot; debugger (it actually doesn&rsquo;t do
anything) consists of one line:</p>

<p style="margin-left:11%; margin-top: 1em">sub DB::DB
{}</p>

<p style="margin-left:11%; margin-top: 1em">It can easily
be defined like this:</p>

<p style="margin-left:11%; margin-top: 1em">$
PERL5DB=&quot;sub DB::DB {}&quot; perl &minus;d
your&minus;script</p>

<p style="margin-left:11%; margin-top: 1em">Another brief
debugger, slightly more useful, can be created with only the
line:</p>

<p style="margin-left:11%; margin-top: 1em">sub DB::DB
{print ++$i; scalar &lt;STDIN&gt;}</p>

<p style="margin-left:11%; margin-top: 1em">This debugger
prints a number which increments for each statement
encountered and waits for you to hit a newline before
continuing to the next statement.</p>

<p style="margin-left:11%; margin-top: 1em">The following
debugger is actually useful:</p>

<p style="margin-left:11%; margin-top: 1em">{ <br>
package DB; <br>
sub DB {} <br>
sub sub {print ++$i, &quot; $sub\n&quot;; &amp;$sub} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">It prints the
sequence number of each subroutine call and the name of the
called subroutine. Note that &amp;DB::sub is being compiled
into the package &quot;DB&quot; through the use of the
&quot;package&quot; directive.</p>

<p style="margin-left:11%; margin-top: 1em">When it starts,
the debugger reads your rc file (<i>./.perldb</i> or
<i>~/.perldb</i> under Unix), which can set important
options. (A subroutine (&amp;afterinit) can be defined here
as well; it is executed after the debugger completes its own
initialization.)</p>

<p style="margin-left:11%; margin-top: 1em">After the rc
file is read, the debugger reads the
<small>PERLDB_OPTS</small> environment variable and uses it
to set debugger options. The contents of this variable are
treated as if they were the argument of an &quot;o ...&quot;
debugger command (q.v. in &quot;Configurable Options&quot;
in perldebug).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Debugger
Internal Variables</i></p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the file and subroutine-related variables mentioned above,
the debugger also maintains various magical internal
variables.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">@DB::dbline is an alias for
&quot;@{&quot;::_&lt;current_file&quot;}&quot;, which holds
the lines of the currently-selected file (compiled by Perl),
either explicitly chosen with the debugger&rsquo;s
&quot;f&quot; command, or implicitly by flow of
execution.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Values in this
array are magical in numeric context: they compare equal to
zero only if the line is not breakable.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">%DB::dbline is an alias for
&quot;%{&quot;::_&lt;current_file&quot;}&quot;, which
contains breakpoints and actions keyed by line number in the
currently-selected file, either explicitly chosen with the
debugger&rsquo;s &quot;f&quot; command, or implicitly by
flow of execution.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">As previously
noted, individual entries (as opposed to the whole hash) are
settable. Perl only cares about Boolean true here, although
the values used by <i>perl5db.pl</i> have the form
&quot;$break_condition\0$action&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Debugger
Customization Functions</i></p>

<p style="margin-left:11%; margin-top: 1em">Some functions
are provided to simplify customization.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">See &quot;Configurable
Options&quot; in perldebug for a description of options
parsed by &quot;DB::parse_options(string)&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>&quot;DB::dump_trace(skip[,count])&quot; skips the
specified number of frames and returns a list containing
information about the calling frames (all of them, if
&quot;count&quot; is missing). Each entry is reference to a
hash with keys &quot;context&quot; (either &quot;.&quot;,
&quot;$&quot;, or &quot;@&quot;), &quot;sub&quot;
(subroutine name, or info about &quot;eval&quot;),
&quot;args&quot; (&quot;undef&quot; or a reference to an
array), &quot;file&quot;, and &quot;line&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>&quot;DB::print_trace(FH, skip[, count[, short]])&quot;
prints formatted info about caller frames. The last two
functions may be convenient as arguments to
&quot;&lt;&quot;, &quot;&lt;&lt;&quot; commands.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that any
variables and functions that are not documented in this
manpages (or in perldebug) are considered for internal use
only, and as such are subject to change without notice.</p>

<h2>Frame Listing Output Examples
<a name="Frame Listing Output Examples"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
&quot;frame&quot; option can be used to control the output
of frame information. For example, contrast this expression
trace:</p>

<p style="margin-left:11%; margin-top: 1em">$ perl
&minus;de 42 <br>
Stack dump during die enabled outside of evals. <br>
Loading DB routines from perl5db.pl patch level 0.94 <br>
Emacs support available. <br>
Enter h or 'h h' for help. <br>
main::(&minus;e:1): 0 <br>
DB&lt;1&gt; sub foo { 14 } <br>
DB&lt;2&gt; sub bar { 3 } <br>
DB&lt;3&gt; t print foo() * bar() <br>
main::((eval 172):3): print foo() + bar(); <br>
main::foo((eval 168):2): <br>
main::bar((eval 170):2): <br>
42</p>

<p style="margin-left:11%; margin-top: 1em">with this one,
once the &quot;o&quot;ption &quot;frame=2&quot; has been
set:</p>

<p style="margin-left:11%; margin-top: 1em">DB&lt;4&gt; o
f=2 <br>
frame = '2' <br>
DB&lt;5&gt; t print foo() * bar() <br>
3: foo() * bar() <br>
entering main::foo <br>
2: sub foo { 14 }; <br>
exited main::foo <br>
entering main::bar <br>
2: sub bar { 3 }; <br>
exited main::bar <br>
42</p>

<p style="margin-left:11%; margin-top: 1em">By way of
demonstration, we present below a laborious listing
resulting from setting your &quot;PERLDB_OPTS&quot;
environment variable to the value &quot;f=n N&quot;, and
running <i>perl &minus;d &minus;V</i> from the command line.
Examples using various values of &quot;n&quot; are shown to
give you a feel for the difference between settings. Long
though it may be, this is not a complete listing, but only
excerpts.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="31%">


<p style="margin-top: 1em">entering main::BEGIN</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:17%;">entering Config::BEGIN <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
Package lib/Config.pm. <br>
entering Config::TIEHASH <br>
entering Exporter::import <br>
entering Exporter::export <br>
entering Config::myconfig <br>
entering Config::FETCH <br>
entering Config::FETCH <br>
entering Config::FETCH <br>
entering Config::FETCH</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="4%"></td>
<td width="31%">


<p style="margin-top: 1em">entering main::BEGIN</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:17%;">entering Config::BEGIN <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
exited Config::BEGIN <br>
Package lib/Config.pm. <br>
entering Config::TIEHASH <br>
exited Config::TIEHASH <br>
entering Exporter::import <br>
entering Exporter::export <br>
exited Exporter::export <br>
exited Exporter::import <br>
exited main::BEGIN <br>
entering Config::myconfig <br>
entering Config::FETCH <br>
exited Config::FETCH <br>
entering Config::FETCH <br>
exited Config::FETCH <br>
entering Config::FETCH</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="4%"></td>
<td width="56%">


<p style="margin-top: 1em">in $=main::BEGIN() from
/dev/null:0</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%;">in $=Config::BEGIN() from
lib/Config.pm:2 <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
Package lib/Config.pm. <br>
in $=Config::TIEHASH('Config') from lib/Config.pm:644 <br>
in $=Exporter::import('Config', 'myconfig', 'config_vars')
from /dev/null:0 <br>
in $=Exporter::export('Config', 'main', 'myconfig',
'config_vars') from li <br>
in @=Config::myconfig() from /dev/null:0 <br>
in $=Config::FETCH(ref(Config), 'package') from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), 'baserev') from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), 'PERL_VERSION') from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), 'osname') from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), 'osvers') from
lib/Config.pm:574</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="4%"></td>
<td width="56%">


<p style="margin-top: 1em">in $=main::BEGIN() from
/dev/null:0</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%;">in $=Config::BEGIN() from
lib/Config.pm:2 <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
out $=Config::BEGIN() from lib/Config.pm:0 <br>
Package lib/Config.pm. <br>
in $=Config::TIEHASH('Config') from lib/Config.pm:644 <br>
out $=Config::TIEHASH('Config') from lib/Config.pm:644 <br>
in $=Exporter::import('Config', 'myconfig', 'config_vars')
from /dev/null:0 <br>
in $=Exporter::export('Config', 'main', 'myconfig',
'config_vars') from lib/ <br>
out $=Exporter::export('Config', 'main', 'myconfig',
'config_vars') from lib/ <br>
out $=Exporter::import('Config', 'myconfig', 'config_vars')
from /dev/null:0 <br>
out $=main::BEGIN() from /dev/null:0 <br>
in @=Config::myconfig() from /dev/null:0 <br>
in $=Config::FETCH(ref(Config), 'package') from
lib/Config.pm:574 <br>
out $=Config::FETCH(ref(Config), 'package') from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), 'baserev') from
lib/Config.pm:574 <br>
out $=Config::FETCH(ref(Config), 'baserev') from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), 'PERL_VERSION') from
lib/Config.pm:574 <br>
out $=Config::FETCH(ref(Config), 'PERL_VERSION') from
lib/Config.pm:574 <br>
in $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from
lib/Config.pm:574</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">5.</p></td>
<td width="4%"></td>
<td width="56%">


<p style="margin-top: 1em">in $=main::BEGIN() from
/dev/null:0</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%;">in $=Config::BEGIN() from
lib/Config.pm:2 <br>
Package lib/Exporter.pm. <br>
Package lib/Carp.pm. <br>
out $=Config::BEGIN() from lib/Config.pm:0 <br>
Package lib/Config.pm. <br>
in $=Config::TIEHASH('Config') from lib/Config.pm:644 <br>
out $=Config::TIEHASH('Config') from lib/Config.pm:644 <br>
in $=Exporter::import('Config', 'myconfig', 'config_vars')
from /dev/null:0 <br>
in $=Exporter::export('Config', 'main', 'myconfig',
'config_vars') from lib/E <br>
out $=Exporter::export('Config', 'main', 'myconfig',
'config_vars') from lib/E <br>
out $=Exporter::import('Config', 'myconfig', 'config_vars')
from /dev/null:0 <br>
out $=main::BEGIN() from /dev/null:0 <br>
in @=Config::myconfig() from /dev/null:0 <br>
in $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from
lib/Config.pm:574 <br>
out $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from
lib/Config.pm:574 <br>
in $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from
lib/Config.pm:574 <br>
out $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from
lib/Config.pm:574</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">6.</p></td>
<td width="4%"></td>
<td width="60%">


<p style="margin-top: 1em">in $=CODE(0x15eca4)() from
/dev/null:0</p> </td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:17%;">in $=CODE(0x182528)() from
lib/Config.pm:2 <br>
Package lib/Exporter.pm. <br>
out $=CODE(0x182528)() from lib/Config.pm:0 <br>
scalar context return from CODE(0x182528): undef <br>
Package lib/Config.pm. <br>
in $=Config::TIEHASH('Config') from lib/Config.pm:628 <br>
out $=Config::TIEHASH('Config') from lib/Config.pm:628 <br>
scalar context return from Config::TIEHASH: empty hash <br>
in $=Exporter::import('Config', 'myconfig', 'config_vars')
from /dev/null:0 <br>
in $=Exporter::export('Config', 'main', 'myconfig',
'config_vars') from lib/Exporter.pm:171 <br>
out $=Exporter::export('Config', 'main', 'myconfig',
'config_vars') from lib/Exporter.pm:171 <br>
scalar context return from Exporter::export: '' <br>
out $=Exporter::import('Config', 'myconfig', 'config_vars')
from /dev/null:0 <br>
scalar context return from Exporter::import: ''</p>

<p style="margin-left:11%; margin-top: 1em">In all cases
shown above, the line indentation shows the call tree. If
bit 2 of &quot;frame&quot; is set, a line is printed on exit
from a subroutine as well. If bit 4 is set, the arguments
are printed along with the caller info. If bit 8 is set, the
arguments are printed even if they are tied or references.
If bit 16 is set, the return value is printed, too.</p>

<p style="margin-left:11%; margin-top: 1em">When a package
is compiled, a line like this</p>

<p style="margin-left:11%; margin-top: 1em">Package
lib/Carp.pm.</p>

<p style="margin-left:11%; margin-top: 1em">is printed with
proper indentation.</p>

<h2>Debugging Regular Expressions
<a name="Debugging Regular Expressions"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are two
ways to enable debugging output for regular expressions.</p>

<p style="margin-left:11%; margin-top: 1em">If your perl is
compiled with &quot;&minus;DDEBUGGING&quot;, you may use the
<b>&minus;Dr</b> flag on the command line, and
&quot;&minus;Drv&quot; for more verbose information.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, one
can &quot;use re 'debug'&quot;, which has effects at both
compile time and run time. Since Perl 5.9.5, this pragma is
lexically scoped.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Compile-time
Output</b> <br>
The debugging output at compile time looks like this:</p>

<p style="margin-left:11%; margin-top: 1em">Compiling REx
'[bc]d(ef*g)+h[ij]k$' <br>
size 45 Got 364 bytes for offset annotations. <br>
first at 1 <br>
rarest char g at 0 <br>
rarest char d at 0 <br>
1: ANYOF[bc](12) <br>
12: EXACT &lt;d&gt;(14) <br>
14: CURLYX[0] {1,32767}(28) <br>
16: OPEN1(18) <br>
18: EXACT &lt;e&gt;(20) <br>
20: STAR(23) <br>
21: EXACT &lt;f&gt;(0) <br>
23: EXACT &lt;g&gt;(25) <br>
25: CLOSE1(27) <br>
27: WHILEM[1/1](0) <br>
28: NOTHING(29) <br>
29: EXACT &lt;h&gt;(31) <br>
31: ANYOF[ij](42) <br>
42: EXACT &lt;k&gt;(44) <br>
44: EOL(45) <br>
45: END(0) <br>
anchored 'de' at 1 floating 'gh' at 3..2147483647 (checking
floating) <br>
stclass 'ANYOF[bc]' minlen 7 <br>
Offsets: [45] <br>
1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
<br>
0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1]
0[0] <br>
11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
<br>
0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0] <br>
Omitting $` $&amp; $' support.</p>

<p style="margin-left:11%; margin-top: 1em">The first line
shows the pre-compiled form of the regex. The second shows
the size of the compiled form (in arbitrary units, usually
4&minus;byte words) and the total number of bytes allocated
for the offset/length table, usually 4+&quot;size&quot;*8.
The next line shows the label <i>id</i> of the first node
that does a match.</p>

<p style="margin-left:11%; margin-top: 1em">The</p>

<p style="margin-left:11%; margin-top: 1em">anchored 'de'
at 1 floating 'gh' at 3..2147483647 (checking floating) <br>
stclass 'ANYOF[bc]' minlen 7</p>

<p style="margin-left:11%; margin-top: 1em">line (split
into two lines above) contains optimizer information. In the
example shown, the optimizer found that the match should
contain a substring &quot;de&quot; at offset 1, plus
substring &quot;gh&quot; at some offset between 3 and
infinity. Moreover, when checking for these substrings (to
abandon impossible matches quickly), Perl will check for the
substring &quot;gh&quot; before checking for the substring
&quot;de&quot;. The optimizer may also use the knowledge
that the match starts (at the &quot;first&quot; <i>id</i>)
with a character class, and no string shorter than 7
characters can possibly match.</p>

<p style="margin-left:11%; margin-top: 1em">The fields of
interest which may appear in this line are <br>
&quot;anchored&quot; <i><small>STRING</small></i>
&quot;at&quot; <i><small>POS</small></i> <br>
&quot;floating&quot; <i><small>STRING</small></i>
&quot;at&quot; <i><small>POS1..POS2</small></i></p>

<p style="margin-left:17%;">See above.</p>

<p style="margin-left:11%;">&quot;matching
floating/anchored&quot;</p>

<p style="margin-left:17%;">Which substring to check
first.</p>

<p style="margin-left:11%;">&quot;minlen&quot;</p>

<p style="margin-left:17%;">The minimal length of the
match.</p>

<p style="margin-left:11%;">&quot;stclass&quot;
<i><small>TYPE</small></i></p>

<p style="margin-left:17%;">Type of first matching
node.</p>

<p style="margin-left:11%;">&quot;noscan&quot;</p>

<p style="margin-left:17%;">Don&rsquo;t scan for the found
substrings.</p>

<p style="margin-left:11%;">&quot;isall&quot;</p>

<p style="margin-left:17%;">Means that the optimizer
information is all that the regular expression contains, and
thus one does not need to enter the regex engine at all.</p>

<p style="margin-left:11%;">&quot;GPOS&quot;</p>

<p style="margin-left:17%;">Set if the pattern contains
&quot;\G&quot;.</p>

<p style="margin-left:11%;">&quot;plus&quot;</p>

<p style="margin-left:17%;">Set if the pattern starts with
a repeated char (as in &quot;x+y&quot;).</p>

<p style="margin-left:11%;">&quot;implicit&quot;</p>

<p style="margin-left:17%;">Set if the pattern starts with
&quot;.*&quot;.</p>

<p style="margin-left:11%;">&quot;with eval&quot;</p>

<p style="margin-left:17%;">Set if the pattern contain
eval-groups, such as &quot;(?{ code })&quot; and &quot;(??{
code })&quot;.</p>

<p style="margin-left:11%;">&quot;anchored(TYPE)&quot;</p>

<p style="margin-left:17%;">If the pattern may match only
at a handful of places, with &quot;TYPE&quot; being
&quot;SBOL&quot;, &quot;MBOL&quot;, or &quot;GPOS&quot;. See
the table below.</p>

<p style="margin-left:11%; margin-top: 1em">If a substring
is known to match at end-of-line only, it may be followed by
&quot;$&quot;, as in &quot;floating 'k'$&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
optimizer-specific information is used to avoid entering (a
slow) regex engine on strings that will not definitely
match. If the &quot;isall&quot; flag is set, a call to the
regex engine may be avoided even when the optimizer found an
appropriate place for the match.</p>

<p style="margin-left:11%; margin-top: 1em">Above the
optimizer section is the list of <i>nodes</i> of the
compiled form of the regex. Each line has format</p>

<p style="margin-left:11%; margin-top: 1em">&quot;
&quot;<i>id</i>: <i><small>TYPE</small> OPTIONAL-INFO</i>
(<i>next-id</i>)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Types of
Nodes</b> <br>
Here are the current possible types, with short
descriptions:</p>

<p style="margin-left:11%; margin-top: 1em"># TYPE
arg&minus;description [regnode&minus;struct&minus;suffix]
[longjump&minus;len] DESCRIPTION <br>
# Exit points <br>
END no End of program. <br>
SUCCEED no Return from a subroutine, basically. <br>
# Line Start Anchors: <br>
SBOL no Match &quot;&quot; at beginning of line: /^/, /\A/
<br>
MBOL no Same, assuming multiline: /^/m <br>
# Line End Anchors: <br>
SEOL no Match &quot;&quot; at end of line: /$/ <br>
MEOL no Same, assuming multiline: /$/m <br>
EOS no Match &quot;&quot; at end of string: /\z/ <br>
# Match Start Anchors: <br>
GPOS no Matches where last m//g left off. <br>
# Word Boundary Opcodes: <br>
BOUND no Like BOUNDA for non&minus;utf8, otherwise like <br>
BOUNDU <br>
BOUNDL no Like BOUND/BOUNDU, but \w and \W are <br>
defined by current locale <br>
BOUNDU no Match &quot;&quot; at any boundary of a given type
<br>
using /u rules. <br>
BOUNDA no Match &quot;&quot; at any boundary between \w\W or
<br>
\W\w, where \w is [_a&minus;zA&minus;Z0&minus;9] <br>
NBOUND no Like NBOUNDA for non&minus;utf8, otherwise like
<br>
BOUNDU <br>
NBOUNDL no Like NBOUND/NBOUNDU, but \w and \W are <br>
defined by current locale <br>
NBOUNDU no Match &quot;&quot; at any non&minus;boundary of a
given <br>
type using using /u rules. <br>
NBOUNDA no Match &quot;&quot; betweeen any \w\w or \W\W,
where <br>
\w is [_a&minus;zA&minus;Z0&minus;9] <br>
# [Special] alternatives: <br>
REG_ANY no Match any one character (except newline). <br>
SANY no Match any one character. <br>
ANYOF sv Match character in (or not in) this class, <br>
charclass single char match only <br>
ANYOFD sv Like ANYOF, but /d is in effect <br>
charclass <br>
ANYOFL sv Like ANYOF, but /l is in effect <br>
charclass <br>
ANYOFPOSIXL sv Like ANYOFL, but matches [[:posix:]] <br>
charclass_ classes <br>
posixl <br>
ANYOFH sv 1 Like ANYOF, but only has &quot;High&quot;
matches, <br>
none in the bitmap; the flags field <br>
contains the lowest matchable UTF&minus;8 start <br>
byte <br>
ANYOFHb sv 1 Like ANYOFH, but all matches share the same
<br>
UTF&minus;8 start byte, given in the flags field <br>
ANYOFHr sv 1 Like ANYOFH, but the flags field contains <br>
packed bounds for all matchable UTF&minus;8 start <br>
bytes. <br>
ANYOFHs sv 1 Like ANYOFHb, but has a string field that <br>
gives the leading matchable UTF&minus;8 bytes; <br>
flags field is len <br>
ANYOFR packed 1 Matches any character in the range given by
<br>
its packed args: upper 12 bits is the max <br>
delta from the base lower 20; the flags <br>
field contains the lowest matchable UTF&minus;8 <br>
start byte <br>
ANYOFRb packed 1 Like ANYOFR, but all matches share the same
<br>
UTF&minus;8 start byte, given in the flags field <br>
ANYOFM byte 1 Like ANYOF, but matches an invariant byte <br>
as determined by the mask and arg <br>
NANYOFM byte 1 complement of ANYOFM <br>
# POSIX Character Classes: <br>
POSIXD none Some [[:class:]] under /d; the FLAGS field <br>
gives which one <br>
POSIXL none Some [[:class:]] under /l; the FLAGS field <br>
gives which one <br>
POSIXU none Some [[:class:]] under /u; the FLAGS field <br>
gives which one <br>
POSIXA none Some [[:class:]] under /a; the FLAGS field <br>
gives which one <br>
NPOSIXD none complement of POSIXD, [[:^class:]] <br>
NPOSIXL none complement of POSIXL, [[:^class:]] <br>
NPOSIXU none complement of POSIXU, [[:^class:]] <br>
NPOSIXA none complement of POSIXA, [[:^class:]] <br>
CLUMP no Match any extended grapheme cluster <br>
sequence <br>
# Alternation <br>
# BRANCH The set of branches constituting a single choice
are <br>
# hooked together with their &quot;next&quot; pointers,
since <br>
# precedence prevents anything being concatenated to <br>
# any individual branch. The &quot;next&quot; pointer of the
last <br>
# BRANCH in a choice points to the thing following the <br>
# whole choice. This is also where the final
&quot;next&quot; <br>
# pointer of each individual branch points; each branch <br>
# starts with the operand node of a BRANCH node. <br>
# <br>
BRANCH node Match this alternative, or the next... <br>
# Literals <br>
EXACT str Match this string (flags field is the <br>
length). <br>
# In a long string node, the U32 argument is the length, and
is <br>
# immediately followed by the string. <br>
LEXACT len:str 1 Match this long string (preceded by length;
<br>
flags unused). <br>
EXACTL str Like EXACT, but /l is in effect (used so <br>
locale&minus;related warnings can be checked for) <br>
EXACTF str Like EXACT, but match using /id rules; <br>
(string not UTF&minus;8, ASCII folded; non&minus;ASCII <br>
not) <br>
EXACTFL str Like EXACT, but match using /il rules; <br>
(string not likely to be folded) <br>
EXACTFU str Like EXACT, but match using /iu rules; <br>
(string folded) <br>
EXACTFAA str Like EXACT, but match using /iaa rules; <br>
(string folded except MICRO in non&minus;UTF8 <br>
patterns; doesn't contain SHARP S unless <br>
UTF&minus;8; folded length &lt;= unfolded) <br>
EXACTFAA_NO_TRIE str Like EXACTFAA, (string not UTF&minus;8,
folded <br>
except: MICRO, SHARP S; folded length &lt;= <br>
unfolded, not currently trie&minus;able) <br>
EXACTFUP str Like EXACT, but match using /iu rules; <br>
(string not UTF&minus;8, folded except MICRO: <br>
hence Problematic) <br>
EXACTFLU8 str Like EXACTFU, but use /il, UTF&minus;8,
(string <br>
is folded, and everything in it is above <br>
255 <br>
EXACT_REQ8 str Like EXACT, but only UTF&minus;8 encoded
targets <br>
can match <br>
LEXACT_REQ8 len:str 1 Like LEXACT, but only UTF&minus;8
encoded targets <br>
can match <br>
EXACTFU_REQ8 str Like EXACTFU, but only UTF&minus;8 encoded
<br>
targets can match <br>
EXACTFU_S_EDGE str /di rules, but nothing in it precludes
/ui, <br>
except begins and/or ends with [Ss]; <br>
(string not UTF&minus;8; compile&minus;time only) <br>
# New charclass like patterns <br>
LNBREAK none generic newline pattern <br>
# Trie Related <br>
# Behave the same as A|LIST|OF|WORDS would. The '..C'
variants <br>
# have inline charclass data (ascii only), the 'C' store it
in the <br>
# structure. <br>
TRIE trie 1 Match many EXACT(F[ALU]?)? at once. <br>
flags==type <br>
TRIEC trie Same as TRIE, but with embedded charclass <br>
charclass data <br>
AHOCORASICK trie 1 Aho Corasick stclass. flags==type <br>
AHOCORASICKC trie Same as AHOCORASICK, but with embedded
<br>
charclass charclass data <br>
# Do nothing types <br>
NOTHING no Match empty string. <br>
# A variant of above which delimits a group, thus stops
optimizations <br>
TAIL no Match empty string. Can jump here from <br>
outside. <br>
# Loops <br>
# STAR,PLUS '?', and complex '*' and '+', are implemented as
<br>
# circular BRANCH structures. Simple cases <br>
# (one character per match) are implemented with STAR <br>
# and PLUS for speed and to minimize recursive plunges. <br>
# <br>
STAR node Match this (simple) thing 0 or more times. <br>
PLUS node Match this (simple) thing 1 or more times. <br>
CURLY sv 2 Match this simple thing {n,m} times. <br>
CURLYN no 2 Capture next&minus;after&minus;this simple thing
<br>
CURLYM no 2 Capture this medium&minus;complex thing {n,m}
<br>
times. <br>
CURLYX sv 2 Match this complex thing {n,m} times. <br>
# This terminator creates a loop structure for CURLYX <br>
WHILEM no Do curly processing and see if rest <br>
matches. <br>
# Buffer related <br>
# OPEN,CLOSE,GROUPP ...are numbered at compile time. <br>
OPEN num 1 Mark this point in input as start of #n. <br>
CLOSE num 1 Close corresponding OPEN of #n. <br>
SROPEN none Same as OPEN, but for script run <br>
SRCLOSE none Close preceding SROPEN <br>
REF num 1 Match some already matched string <br>
REFF num 1 Match already matched string, using /di <br>
rules. <br>
REFFL num 1 Match already matched string, using /li <br>
rules. <br>
REFFU num 1 Match already matched string, usng /ui. <br>
REFFA num 1 Match already matched string, using /aai <br>
rules. <br>
# Named references. Code in regcomp.c assumes that these all
are after <br>
# the numbered references <br>
REFN no&minus;sv 1 Match some already matched string <br>
REFFN no&minus;sv 1 Match already matched string, using /di
<br>
rules. <br>
REFFLN no&minus;sv 1 Match already matched string, using /li
<br>
rules. <br>
REFFUN num 1 Match already matched string, using /ui <br>
rules. <br>
REFFAN num 1 Match already matched string, using /aai <br>
rules. <br>
# Support for long RE <br>
LONGJMP off 1 1 Jump far away. <br>
BRANCHJ off 1 1 BRANCH with long offset. <br>
# Special Case Regops <br>
IFMATCH off 1 1 Succeeds if the following matches;
non&minus;zero <br>
flags &quot;f&quot;, next_off &quot;o&quot; means lookbehind
<br>
assertion starting &quot;f..(f&minus;o)&quot; characters
<br>
before current <br>
UNLESSM off 1 1 Fails if the following matches;
non&minus;zero <br>
flags &quot;f&quot;, next_off &quot;o&quot; means lookbehind
<br>
assertion starting &quot;f..(f&minus;o)&quot; characters
<br>
before current <br>
SUSPEND off 1 1 &quot;Independent&quot; sub&minus;RE. <br>
IFTHEN off 1 1 Switch, should be preceded by switcher. <br>
GROUPP num 1 Whether the group matched. <br>
# The heavy worker <br>
EVAL evl/flags Execute some Perl code. <br>
2L <br>
# Modifiers <br>
MINMOD no Next operator is not greedy. <br>
LOGICAL no Next opcode should set the flag only. <br>
# This is not used yet <br>
RENUM off 1 1 Group with independently numbered parens. <br>
# Regex Subroutines <br>
GOSUB num/ofs 2L recurse to paren arg1 at (signed) ofs arg2
<br>
# Special conditionals <br>
GROUPPN no&minus;sv 1 Whether the group matched. <br>
INSUBP num 1 Whether we are in a specific recurse. <br>
DEFINEP none 1 Never execute directly. <br>
# Backtracking Verbs <br>
ENDLIKE none Used only for the type field of verbs <br>
OPFAIL no&minus;sv 1 Same as (?!), but with verb arg <br>
ACCEPT no&minus;sv/num Accepts the current matched string,
with <br>
2L verbar <br>
# Verbs With Arguments <br>
VERB no&minus;sv 1 Used only for the type field of verbs
<br>
PRUNE no&minus;sv 1 Pattern fails at this startpoint if
no&minus; <br>
backtracking through this <br>
MARKPOINT no&minus;sv 1 Push the current location for
rollback by <br>
cut. <br>
SKIP no&minus;sv 1 On failure skip forward (to the mark)
<br>
before retrying <br>
COMMIT no&minus;sv 1 Pattern fails outright if backtracking
<br>
through this <br>
CUTGROUP no&minus;sv 1 On failure go to the next alternation
in <br>
the group <br>
# Control what to keep in $&amp;. <br>
KEEPS no $&amp; begins here. <br>
# Validate that lookbehind IFMATCH and UNLESSM end at the
right place <br>
LOOKBEHIND_END no Return from lookbehind (IFMATCH/UNLESSM)
<br>
and validate position <br>
# SPECIAL REGOPS <br>
# This is not really a node, but an optimized away piece of
a &quot;long&quot; <br>
# node. To simplify debugging output, we mark it as if it
were a node <br>
OPTIMIZED off Placeholder for dump. <br>
# Special opcode with the property that no opcode in a
compiled program <br>
# will ever be of this type. Thus it can be used as a flag
value that <br>
# no other opcode has been seen. END is used similarly, in
that an END <br>
# node cant be optimized. So END implies
&quot;unoptimizable&quot; and PSEUDO <br>
# mean &quot;not seen anything to optimize yet&quot;. <br>
PSEUDO off Pseudo opcode for internal use. <br>
REGEX_SET depth p Regex set, temporary node used in
pre&minus; <br>
optimization compilation</p>

<p style="margin-left:11%; margin-top: 1em">Following the
optimizer information is a dump of the offset/length table,
here split across several lines:</p>

<p style="margin-left:11%; margin-top: 1em">Offsets: [45]
<br>
1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
<br>
0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1]
0[0] <br>
11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
<br>
0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]</p>

<p style="margin-left:11%; margin-top: 1em">The first line
here indicates that the offset/length table contains 45
entries. Each entry is a pair of integers, denoted by
&quot;offset[length]&quot;. Entries are numbered starting
with 1, so entry #1 here is &quot;1[4]&quot; and entry #12
is &quot;5[1]&quot;. &quot;1[4]&quot; indicates that the
node labeled &quot;1:&quot; (the &quot;1: ANYOF[bc]&quot;)
begins at character position 1 in the pre-compiled form of
the regex, and has a length of 4 characters.
&quot;5[1]&quot; in position 12 indicates that the node
labeled &quot;12:&quot; (the &quot;12: EXACT
&lt;d&gt;&quot;) begins at character position 5 in the
pre-compiled form of the regex, and has a length of 1
character. &quot;12[1]&quot; in position 14 indicates that
the node labeled &quot;14:&quot; (the &quot;14: CURLYX[0]
{1,32767}&quot;) begins at character position 12 in the
pre-compiled form of the regex, and has a length of 1
character&minus;&minus;&minus;that is, it corresponds to the
&quot;+&quot; symbol in the precompiled regex.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;0[0]&quot;
items indicate that there is no corresponding node.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Run-time
Output</b> <br>
First of all, when doing a match, one may get no run-time
output even if debugging is enabled. This means that the
regex engine was never entered and that all of the job was
therefore done by the optimizer.</p>

<p style="margin-left:11%; margin-top: 1em">If the regex
engine was entered, the output may look like this:</p>

<p style="margin-left:11%; margin-top: 1em">Matching
'[bc]d(ef*g)+h[ij]k$' against 'abcdefg__gh__' <br>
Setting an EVAL scope, savestack=3 <br>
2 &lt;ab&gt; &lt;cdefg__gh_&gt; | 1: ANYOF <br>
3 &lt;abc&gt; &lt;defg__gh_&gt; | 11: EXACT &lt;d&gt; <br>
4 &lt;abcd&gt; &lt;efg__gh_&gt; | 13: CURLYX {1,32767} <br>
4 &lt;abcd&gt; &lt;efg__gh_&gt; | 26: WHILEM <br>
0 out of 1..32767 cc=effff31c <br>
4 &lt;abcd&gt; &lt;efg__gh_&gt; | 15: OPEN1 <br>
4 &lt;abcd&gt; &lt;efg__gh_&gt; | 17: EXACT &lt;e&gt; <br>
5 &lt;abcde&gt; &lt;fg__gh_&gt; | 19: STAR <br>
EXACT &lt;f&gt; can match 1 times out of 32767... <br>
Setting an EVAL scope, savestack=3 <br>
6 &lt;bcdef&gt; &lt;g__gh__&gt; | 22: EXACT &lt;g&gt; <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 24: CLOSE1 <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 26: WHILEM <br>
1 out of 1..32767 cc=effff31c <br>
Setting an EVAL scope, savestack=12 <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 15: OPEN1 <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 17: EXACT &lt;e&gt; <br>
restoring \1 to 4(4)..7 <br>
failed, try continuation... <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 27: NOTHING <br>
7 &lt;bcdefg&gt; &lt;__gh__&gt; | 28: EXACT &lt;h&gt; <br>
failed... <br>
failed...</p>

<p style="margin-left:11%; margin-top: 1em">The most
significant information in the output is about the
particular <i>node</i> of the compiled regex that is
currently being tested against the target string. The format
of these lines is</p>

<p style="margin-left:11%; margin-top: 1em">&quot;
&quot;<i>STRING-OFFSET</i> &lt;<i>PRE-STRING</i>&gt;
&lt;<i>POST-STRING</i>&gt; | <i><small>ID</small></i> :
<i><small>TYPE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">The
<i><small>TYPE</small></i> info is indented with respect to
the backtracking level. Other incidental information appears
interspersed within.</p>

<h2>Debugging Perl Memory Usage
<a name="Debugging Perl Memory Usage"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perl is a
profligate wastrel when it comes to memory use. There is a
saying that to estimate memory usage of Perl, assume a
reasonable algorithm for memory allocation, multiply that
estimate by 10, and while you still may miss the mark, at
least you won&rsquo;t be quite so astonished. This is not
absolutely true, but may provide a good grasp of what
happens.</p>

<p style="margin-left:11%; margin-top: 1em">Assume that an
integer cannot take less than 20 bytes of memory, a float
cannot take less than 24 bytes, a string cannot take less
than 32 bytes (all these examples assume 32&minus;bit
architectures, the result are quite a bit worse on
64&minus;bit architectures). If a variable is accessed in
two of three different ways (which require an integer, a
float, or a string), the memory footprint may increase yet
another 20 bytes. A sloppy <b>malloc</b>(3) implementation
can inflate these numbers dramatically.</p>

<p style="margin-left:11%; margin-top: 1em">On the opposite
end of the scale, a declaration like</p>

<p style="margin-left:11%; margin-top: 1em">sub foo;</p>

<p style="margin-left:11%; margin-top: 1em">may take up to
500 bytes of memory, depending on which release of Perl
you&rsquo;re running.</p>

<p style="margin-left:11%; margin-top: 1em">Anecdotal
estimates of source-to-compiled code bloat suggest an
eightfold increase. This means that the compiled form of
reasonable (normally commented, properly indented etc.) code
will take about eight times more space in memory than the
code took on disk.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>&minus;DL</b> command-line switch is obsolete since circa
Perl 5.6.0 (it was available only if Perl was built with
&quot;&minus;DDEBUGGING&quot;). The switch was used to track
Perl&rsquo;s memory allocations and possible memory leaks.
These days the use of malloc debugging tools like
<i>Purify</i> or <i>valgrind</i> is suggested instead. See
also &quot; <small>PERL_MEM_LOG&quot;</small> in
perlhacktips.</p>

<p style="margin-left:11%; margin-top: 1em">One way to find
out how much memory is being used by Perl data structures is
to install the Devel::Size module from <small>CPAN:</small>
it gives you the minimum number of bytes required to store a
particular data structure. Please be mindful of the
difference between the <b>size()</b> and
<b>total_size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If Perl has
been compiled using Perl&rsquo;s malloc you can analyze Perl
memory usage by setting $ENV{
<small>PERL_DEBUG_MSTATS</small> }.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
$ENV{PERL_DEBUG_MSTATS}</b> <br>
If your perl is using Perl&rsquo;s <b>malloc()</b> and was
compiled with the necessary switches (this is the default),
then it will print memory usage statistics after compiling
your code when &quot;$ENV{PERL_DEBUG_MSTATS} &gt; 1&quot;,
and before termination of the program when
&quot;$ENV{PERL_DEBUG_MSTATS} &gt;= 1&quot;. The report
format is similar to the following example:</p>

<p style="margin-left:11%; margin-top: 1em">$
PERL_DEBUG_MSTATS=2 perl &minus;e &quot;require Carp&quot;
<br>
Memory allocation statistics after compilation: (buckets
4(4)..8188(8192) <br>
14216 free: 130 117 28 7 9 0 2 2 1 0 0 <br>
437 61 36 0 5 <br>
60924 used: 125 137 161 55 7 8 6 16 2 0 1 <br>
74 109 304 84 20 <br>
Total sbrk(): 77824/21:119. Odd ends: pad+heads+chain+tail:
0+636+0+2048. <br>
Memory allocation statistics after execution: (buckets
4(4)..8188(8192) <br>
30888 free: 245 78 85 13 6 2 1 3 2 0 1 <br>
315 162 39 42 11 <br>
175816 used: 265 176 1112 111 26 22 11 27 2 1 1 <br>
196 178 1066 798 39 <br>
Total sbrk(): 215040/47:145. Odd ends: pad+heads+chain+tail:
0+2192+0+6144.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to ask for such a statistic at arbitrary points in your
execution using the <b>mstat()</b> function out of the
standard Devel::Peek module.</p>

<p style="margin-left:11%; margin-top: 1em">Here is some
explanation of that format: <br>
&quot;buckets SMALLEST(APPROX)..GREATEST(APPROX)&quot;</p>

<p style="margin-left:17%;">Perl&rsquo;s <b>malloc()</b>
uses bucketed allocations. Every request is rounded up to
the closest bucket size available, and a bucket is taken
from the pool of buckets of that size.</p>

<p style="margin-left:17%; margin-top: 1em">The line above
describes the limits of buckets currently in use. Each
bucket has two sizes: memory footprint and the maximal size
of user data that can fit into this bucket. Suppose in the
above example that the smallest bucket were size 4. The
biggest bucket would have usable size 8188, and the memory
footprint would be 8192.</p>

<p style="margin-left:17%; margin-top: 1em">In a Perl built
for debugging, some buckets may have negative usable size.
This means that these buckets cannot (and will not) be used.
For larger buckets, the memory footprint may be one page
greater than a power of 2. If so, the corresponding power of
two is printed in the &quot;APPROX&quot; field above.</p>

<p style="margin-left:11%;">Free/Used</p>

<p style="margin-left:17%;">The 1 or 2 rows of numbers
following that correspond to the number of buckets of each
size between &quot;SMALLEST&quot; and &quot;GREATEST&quot;.
In the first row, the sizes (memory footprints) of buckets
are powers of two--or possibly one page greater. In the
second row, if present, the memory footprints of the buckets
are between the memory footprints of two buckets
&quot;above&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">For example,
suppose under the previous example, the memory footprints
were</p>

<p style="margin-left:17%; margin-top: 1em">free: 8 16 32
64 128 256 512 1024 2048 4096 8192 <br>
4 12 24 48 80</p>

<p style="margin-left:17%; margin-top: 1em">With a
non&minus;&quot;DEBUGGING&quot; perl, the buckets starting
from 128 have a 4&minus;byte overhead, and thus an
8192&minus;long bucket may take up to 8188&minus;byte
allocations.</p>

<p style="margin-left:11%;">&quot;Total sbrk():
SBRKed/SBRKs:CONTINUOUS&quot;</p>

<p style="margin-left:17%;">The first two fields give the
total amount of memory perl <b>sbrk</b>(2)ed (ess-broken?
:&minus;) and number of <b>sbrk</b>(2)s used. The third
number is what perl thinks about continuity of returned
chunks. So long as this number is positive, <b>malloc()</b>
will assume that it is probable that <b>sbrk</b>(2) will
provide continuous memory.</p>

<p style="margin-left:17%; margin-top: 1em">Memory
allocated by external libraries is not counted.</p>

<p style="margin-left:11%;">&quot;pad: 0&quot;</p>

<p style="margin-left:17%;">The amount of <b>sbrk</b>(2)ed
memory needed to keep buckets aligned.</p>

<p style="margin-left:11%;">&quot;heads: 2192&quot;</p>

<p style="margin-left:17%;">Although memory overhead of
bigger buckets is kept inside the bucket, for smaller
buckets, it is kept in separate areas. This field gives the
total size of these areas.</p>

<p style="margin-left:11%;">&quot;chain: 0&quot;</p>

<p style="margin-left:17%;"><b>malloc()</b> may want to
subdivide a bigger bucket into smaller buckets. If only a
part of the deceased bucket is left unsubdivided, the rest
is kept as an element of a linked list. This field gives the
total size of these chunks.</p>

<p style="margin-left:11%;">&quot;tail: 6144&quot;</p>

<p style="margin-left:17%;">To minimize the number of
<b>sbrk</b>(2)s, <b>malloc()</b> asks for more memory. This
field gives the size of the yet unused part, which is
<b>sbrk</b>(2)ed, but never touched.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perldebug,
perl5db.pl, perlguts, perlrun, re, and Devel::DProf.</p>
<hr>
</body>
</html>
