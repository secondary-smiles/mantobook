<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:56 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>pahole</title>

</head>
<body>
<h1>pahole</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">pahole &minus;
Shows, manipulates data structure layout and pretty prints
raw data.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>pahole</b>
[<i>options</i>] <i>files</i></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i><b>pahole</b></i>
shows data structure layouts encoded in debugging
information formats, DWARF, CTF and BTF being supported.</p>

<p style="margin-left:11%; margin-top: 1em">This is useful
for, among other things: optimizing important data
structures by reducing its size, figuring out what is the
field sitting at an offset from the start of a data
structure, investigating ABI changes and more generally
understanding a new codebase you have to work with.</p>

<p style="margin-left:11%; margin-top: 1em">It also uses
these structure layouts to pretty print data feed to its
standard input, e.g.:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
--header elf64_hdr --prettify
/lib/modules/5.8.0-rc6+/build/vmlinux <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_ident = { 127, 69, 76, 70, 2, 1, 1, 0, 0, 0, 0, 0, 0,
0, 0, 0 },</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_type = 2,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_machine = 62,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_version = 1,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_entry = 16777216,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_phoff = 64,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_shoff = 604653784,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_flags = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_ehsize = 64,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_phentsize = 56,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_phnum = 5,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_shentsize = 64,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_shnum = 80,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>.e_shstrndx = 79,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">See the PRETTY
PRINTING section for further examples and documentation.</p>

<p style="margin-left:11%; margin-top: 1em">The files must
have associated debugging information. This information may
be inside the file itself, in ELF sections, or in another
file.</p>

<p style="margin-left:11%; margin-top: 1em">One way to have
this information is to specify the <b>&minus;g</b> option to
the compiler when building it. When this is done the
information will be stored in an ELF section. For the DWARF
debugging information format this, adds, among others, the
<b>.debug_info</b> ELF section. For CTF it is found in just
one ELF section, <b>.SUNW_ctf</b>. BTF comes in at least the
<b>.BTF</b> ELF section, and may come also with the
<b>.BTF.ext</b> ELF section.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>debuginfo</b> packages available in most Linux
distributions are also supported by <b>pahole</b>, where the
debugging information is available in a separate file.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
<b>pahole</b> shows the layout of all named structs in the
files specified.</p>

<p style="margin-left:11%; margin-top: 1em">If no files are
specified, then it will look if the /sys/kernel/btf/vmlinux
is present, using the BTF information present in it about
the running kernel, i.e. this works:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
list_head <br>
struct list_head {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>struct list_head * next; /* 0 8 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>struct list_head * prev; /* 8 8 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* size: 16, cachelines: 1, members: 2 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* last cacheline: 16 bytes */</p></td></tr>
</table>

<p style="margin-left:11%;">}; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">If BTF is not
present and no file is passed, then a vmlinux that matches
the build-id for the running kernel will be looked up in the
usual places, including where the kernel debuginfo packages
put it, looking for DWARF info instead.</p>

<p style="margin-left:11%; margin-top: 1em">See the
EXAMPLES section for more usage suggestions.</p>

<p style="margin-left:11%; margin-top: 1em">It also pretty
prints whatever is fed to its standard input, according to
the type specified, see the EXAMPLE session.</p>

<p style="margin-left:11%; margin-top: 1em">Use --count to
state how many records should be pretty printed.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">pahole supports
the following options. <b><br>
&minus;C, &minus;&minus;class_name=CLASS_NAMES</b></p>

<p style="margin-left:22%;">Show just these classes. This
can be a comma separated list of class names or file URLs
(e.g.: file://class_list.txt)</p>

<p style="margin-left:11%;"><b>&minus;c,
&minus;&minus;cacheline_size=SIZE</b></p>

<p style="margin-left:22%;">Set cacheline size to SIZE
bytes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>&minus;&minus;sort</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Sort the output by type name, maybe this will grow to
allow sorting by other criteria.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">This is mostly
needed so that pretty printing from BTF and DWARF can be
comparable when using using multiple threads to load DWARF
data, when the order that the types in the compile units is
processed is not deterministic.</p>


<p style="margin-left:11%;"><b>&minus;&minus;compile</b></p>

<p style="margin-left:22%;">Generate compileable code, with
all definitions for all types, i.e.:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
--compile &gt; vmlinux.h</p>

<p style="margin-left:11%; margin-top: 1em">Produces a
header that can be included in a C source file and built. In
the example provided it will use the BTF info if available,
otherwise will look for a DWARF file matching the running
kernel build-id. <b><br>
&minus;&minus;skip_emitting_atomic_typedefs</b></p>

<p style="margin-left:22%;">Do not emit &rsquo;typedef
_Atomic int atomic_int&rsquo; &amp; friends when used with
options like --compile. Use it if the compiler provides
these already, as of circa 2022 with gcc 12.2.1 those are
not encoded in DWARF so to generate compilable code we need
emit those typedefs for the atomic types used in the data
structures being emitted from debugging information.</p>


<p style="margin-left:11%;"><b>&minus;&minus;count=COUNT</b></p>

<p style="margin-left:22%;">Pretty print the first COUNT
records from input.</p>


<p style="margin-left:11%;"><b>&minus;&minus;skip=COUNT</b></p>

<p style="margin-left:22%;">Skip COUNT input records.</p>

<p style="margin-left:11%;"><b>&minus;E,
&minus;&minus;expand_types</b></p>

<p style="margin-left:22%;">Expand class members. Useful to
find in what member of inner structs where an offset from
the beginning of a struct is.</p>

<p style="margin-left:11%;"><b>&minus;F,
&minus;&minus;format_path</b></p>

<p style="margin-left:22%;">Allows specifying a list of
debugging formats to try, in order. Right now this includes
&quot;btf&quot;, &quot;ctf&quot; and &quot;dwarf&quot;. The
default format path used is equivalent to &quot;-F
dwarf,btf,ctf&quot;.</p>


<p style="margin-left:11%;"><b>&minus;&minus;hashbits=BITS</b></p>

<p style="margin-left:22%;">Allows specifying the number of
bits for the debugging format loader to use. The only one
affected so far is the &quot;dwarf&quot; one, its default
now is 15, the maximum for it is now 21 bits. Tweak it to
see if it improves performance as the kernel evolves and
more types and functions have to be loaded.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>&minus;&minus;hex</b></p></td>
<td width="4%"></td>
<td width="60%">


<p>Print offsets and sizes in hexadecimal.</p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>&minus;r,
&minus;&minus;rel_offset</b></p>

<p style="margin-left:22%;">Show relative offsets of
members in inner structs.</p>

<p style="margin-left:11%;"><b>&minus;p,
&minus;&minus;expand_pointers</b></p>

<p style="margin-left:22%;">Expand class pointer
members.</p>

<p style="margin-left:11%;"><b>&minus;R,
&minus;&minus;reorganize</b></p>

<p style="margin-left:22%;">Reorganize struct, demoting and
combining bitfields, moving members to remove alignment
holes and padding.</p>

<p style="margin-left:11%;"><b>&minus;S,
&minus;&minus;show_reorg_steps</b></p>

<p style="margin-left:22%;">Show the struct layout at each
reorganization step.</p>

<p style="margin-left:11%;"><b>&minus;i,
&minus;&minus;contains=CLASS_NAME</b></p>

<p style="margin-left:22%;">Show classes that contains
CLASS_NAME.</p>

<p style="margin-left:11%;"><b>&minus;a,
&minus;&minus;anon_include</b></p>

<p style="margin-left:22%;">Include anonymous classes.</p>

<p style="margin-left:11%;"><b>&minus;A,
&minus;&minus;nested_anon_include</b></p>

<p style="margin-left:22%;">Include nested (inside other
structs) anonymous classes.</p>

<p style="margin-left:11%;"><b>&minus;B,
&minus;&minus;bit_holes=NR_HOLES</b></p>

<p style="margin-left:22%;">Show only structs at least
NR_HOLES bit holes.</p>

<p style="margin-left:11%;"><b>&minus;d,
&minus;&minus;recursive</b></p>

<p style="margin-left:22%;">Recursive mode, affects several
other flags.</p>

<p style="margin-left:11%;"><b>&minus;D,
&minus;&minus;decl_exclude=PREFIX</b></p>

<p style="margin-left:22%;">exclude classes declared in
files with PREFIX.</p>

<p style="margin-left:11%;"><b>&minus;f,
&minus;&minus;find_pointers_to=CLASS_NAME</b></p>

<p style="margin-left:22%;">Find pointers to
CLASS_NAME.</p>

<p style="margin-left:11%;"><b>&minus;H,
&minus;&minus;holes=NR_HOLES</b></p>

<p style="margin-left:22%;">Show only structs with at least
NR_HOLES holes.</p>

<p style="margin-left:11%;"><b>&minus;I,
&minus;&minus;show_decl_info</b></p>

<p style="margin-left:22%;">Show the file and line number
where the tags were defined, if available in the debugging
information.</p>


<p style="margin-left:11%;"><b>&minus;&minus;skip_encoding_btf_vars</b></p>

<p style="margin-left:22%;">Do not encode VARs in BTF.</p>


<p style="margin-left:11%;"><b>&minus;&minus;skip_encoding_btf_decl_tag</b></p>

<p style="margin-left:22%;">Do not encode decl tags in
BTF.</p>


<p style="margin-left:11%;"><b>&minus;&minus;skip_encoding_btf_enum64</b></p>

<p style="margin-left:22%;">Do not encode enum64 in
BTF.</p>


<p style="margin-left:11%;"><b>&minus;&minus;skip_encoding_btf_type_tag</b></p>

<p style="margin-left:22%;">Do not encode type tags in
BTF.</p>


<p style="margin-left:11%;"><b>&minus;&minus;skip_encoding_btf_inconsistent_proto</b></p>

<p style="margin-left:22%;">Do not encode functions with
multiple inconsistent prototypes or unexpected register use
for their parameters, where the registers used do not match
calling conventions.</p>

<p style="margin-left:11%;"><b>&minus;j,
&minus;&minus;jobs=N</b></p>

<p style="margin-left:22%;">Run N jobs in parallel.
Defaults to number of online processors + 10% (like the
&rsquo;ninja&rsquo; build system) if no argument is
specified.</p>

<p style="margin-left:11%;"><b>&minus;J,
&minus;&minus;btf_encode</b></p>

<p style="margin-left:22%;">Encode BTF information from
DWARF, used in the Linux kernel build process when
CONFIG_DEBUG_INFO_BTF=y is present, introduced in Linux
v5.2. Used to implement features such as BPF CO-RE (Compile
Once - Run Everywhere).</p>

<p style="margin-left:22%; margin-top: 1em">See
<i>https://nakryiko.com/posts/bpf-portability-and-co-re/</i>.</p>


<p style="margin-left:11%;"><b>&minus;&minus;btf_encode_detached=FILENAME</b></p>

<p style="margin-left:22%;">Same thing as -J/--btf_encode,
but storing the raw BTF info into a separate file.</p>


<p style="margin-left:11%;"><b>&minus;&minus;btf_encode_force</b></p>

<p style="margin-left:22%;">Ignore those symbols found
invalid when encoding BTF.</p>


<p style="margin-left:11%;"><b>&minus;&minus;btf_base=PATH</b></p>

<p style="margin-left:22%;">Path to the base BTF file, for
instance: vmlinux when encoding kernel module BTF
information. This may be inferred when asking for a
/sys/kernel/btf/MODULE, when it will be autoconfigured to
&quot;/sys/kernel/btf/vmlinux&quot;.</p>


<p style="margin-left:11%;"><b>&minus;&minus;btf_gen_floats</b></p>

<p style="margin-left:22%;">Allow producing BTF_KIND_FLOAT
entries in systems where the vmlinux DWARF information has
float types.</p>


<p style="margin-left:11%;"><b>&minus;&minus;btf_gen_optimized</b></p>

<p style="margin-left:22%;">Generate BTF for functions with
optimization-related suffixes (.isra, .constprop).</p>


<p style="margin-left:11%;"><b>&minus;&minus;btf_gen_all</b></p>

<p style="margin-left:22%;">Allow using all the BTF
features supported by pahole.</p>

<p style="margin-left:11%;"><b>&minus;l,
&minus;&minus;show_first_biggest_size_base_type_member</b></p>

<p style="margin-left:22%;">Show first biggest size
base_type member.</p>

<p style="margin-left:11%;"><b>&minus;m,
&minus;&minus;nr_methods</b></p>

<p style="margin-left:22%;">Show number of methods of all
classes, i.e. the number of functions have arguments that
are pointers to a given class.</p>

<p style="margin-left:22%; margin-top: 1em">To get the
number of methods for an specific class, please use:</p>

<p style="margin-left:22%; margin-top: 1em">$ pahole
--nr_methods | grep -w sock <br>
sock 1005 <br>
$</p>

<p style="margin-left:22%; margin-top: 1em">In the above
example it used the BTF information in
/sys/kernel/btf/vmlinux.</p>

<p style="margin-left:11%;"><b>&minus;M,
&minus;&minus;show_only_data_members</b></p>

<p style="margin-left:22%;">Show only the members that use
space in the class layout. C++ methods will be
suppressed.</p>

<p style="margin-left:11%;"><b>&minus;n,
&minus;&minus;nr_members</b></p>

<p style="margin-left:22%;">Show number of members.</p>

<p style="margin-left:11%;"><b>&minus;N,
&minus;&minus;class_name_len</b></p>

<p style="margin-left:22%;">Show size of classes.</p>

<p style="margin-left:11%;"><b>&minus;O,
&minus;&minus;dwarf_offset=OFFSET</b></p>

<p style="margin-left:22%;">Show tag with DWARF OFFSET.</p>

<p style="margin-left:11%;"><b>&minus;P,
&minus;&minus;packable</b></p>

<p style="margin-left:22%;">Show only structs that has
holes that can be packed if members are reorganized, for
instance when using the <b>&minus;&minus;reorganize</b>
option.</p>

<p style="margin-left:11%;"><b>&minus;P,
&minus;&minus;with_flexible_array</b></p>

<p style="margin-left:22%;">Show only structs that have a
flexible array.</p>

<p style="margin-left:11%;"><b>&minus;q,
&minus;&minus;quiet</b></p>

<p style="margin-left:22%;">Be quieter.</p>

<p style="margin-left:11%;"><b>&minus;s,
&minus;&minus;sizes</b></p>

<p style="margin-left:22%;">Show size of classes.</p>

<p style="margin-left:11%;"><b>&minus;t,
&minus;&minus;separator=SEP</b></p>

<p style="margin-left:22%;">Use SEP as the field
separator.</p>

<p style="margin-left:11%;"><b>&minus;T,
&minus;&minus;nr_definitions</b></p>

<p style="margin-left:22%;">Show how many times struct was
defined.</p>

<p style="margin-left:11%;"><b>&minus;u,
&minus;&minus;defined_in</b></p>

<p style="margin-left:22%;">Show CUs where CLASS_NAME (-C)
is defined.</p>


<p style="margin-left:11%;"><b>&minus;&minus;flat_arrays</b></p>

<p style="margin-left:22%;">Flatten arrays, so that
array[10][2] becomes array[20]. Useful when generating from
both CTF/BTF and DWARF encodings for the same binary for
testing purposes.</p>


<p style="margin-left:11%;"><b>&minus;&minus;suppress_aligned_attribute</b></p>

<p style="margin-left:22%;">Suppress forced alignment
markers, so that one can compare BTF or CTF output, that
don&rsquo;t have that info, to output from DWARF &gt;=
5.</p>


<p style="margin-left:11%;"><b>&minus;&minus;suppress_force_paddings</b></p>

<p style="margin-left:22%; margin-top: 1em">Suppress
bitfield forced padding at the end of structs, as this
requires something like DWARF&rsquo;s DW_AT_alignment, so
that one can compare BTF or CTF output, that don&rsquo;t
have that info.</p>


<p style="margin-left:11%;"><b>&minus;&minus;suppress_packed</b></p>

<p style="margin-left:22%; margin-top: 1em">Suppress the
output of the inference of __attribute__((__packed__)), so
that one can compare BTF or CTF output, the inference
algorithm uses things like DW_AT_alignment, so until it is
improved to infer that as well for BTF, allow disabling this
output.</p>


<p style="margin-left:11%;"><b>&minus;&minus;fixup_silly_bitfields</b></p>

<p style="margin-left:22%;">Converts silly bitfields such
as &quot;int foo:32&quot; to plain &quot;int foo&quot;.</p>

<p style="margin-left:11%;"><b>&minus;V,
&minus;&minus;verbose</b></p>

<p style="margin-left:22%;">be verbose</p>


<p style="margin-left:11%;"><b>&minus;&minus;ptr_table_stats</b></p>

<p style="margin-left:22%;">Print statistics about
ptr_table data structures, used to hold all the types, tags
and functions data structures, for development tuning of
such tables, tuned for a typical 2021 vmlinux file.</p>

<p style="margin-left:11%;"><b>&minus;w,
&minus;&minus;word_size=WORD_SIZE</b></p>

<p style="margin-left:22%;">Change the arch word size to
WORD_SIZE.</p>

<p style="margin-left:11%;"><b>&minus;x,
&minus;&minus;exclude=PREFIX</b></p>

<p style="margin-left:22%;">Exclude PREFIXed classes.</p>

<p style="margin-left:11%;"><b>&minus;X,
&minus;&minus;cu_exclude=PREFIX</b></p>

<p style="margin-left:22%;">Exclude PREFIXed compilation
units.</p>


<p style="margin-left:11%;"><b>&minus;&minus;lang=languages</b></p>

<p style="margin-left:22%;">Only process compilation units
built from source code written in the specified
languages.</p>

<p style="margin-left:22%; margin-top: 1em">Supported
languages:</p>

<p style="margin-left:22%; margin-top: 1em">ada83, ada95,
asm, bliss, c, c89, c99, c11, c++, c++03, c++11, c++14,
cobol74, <br>
cobol85, d, dylan, fortran77, fortran90, fortran95,
fortran03, fortran08, <br>
go, haskell, java, julia, modula2, modula3, objc, objc++,
ocaml, opencl, <br>
pascal83, pli, python, renderscript, rust, swift, upc</p>

<p style="margin-left:22%; margin-top: 1em">The linux
kernel, for instance, is written in &rsquo;c89&rsquo; circa
2022, use that in filters.</p>


<p style="margin-left:22%; margin-top: 1em"><b>&minus;&minus;lang_exclude=languages</b>
Don&rsquo;t process compilation units built from source code
written in the specified languages.</p>

<p style="margin-left:22%; margin-top: 1em">To filter out
compilation units written in Rust, for instance, use:</p>

<p style="margin-left:22%; margin-top: 1em">pahole -j
--btf_encode --lang_exclude rust</p>

<p style="margin-left:11%;"><b>&minus;y,
&minus;&minus;prefix_filter=PREFIX</b></p>

<p style="margin-left:22%;">Include PREFIXed classes.</p>

<p style="margin-left:11%;"><b>&minus;z,
&minus;&minus;hole_size_ge=HOLE_SIZE</b></p>

<p style="margin-left:22%;">Show only structs with at least
one hole greater or equal to HOLE_SIZE.</p>


<p style="margin-left:11%;"><b>&minus;&minus;structs</b></p>

<p style="margin-left:22%;">Show only structs, all the
other filters apply, i.e. to show just the sizes of all
structs combine --structs with --sizes, etc.</p>


<p style="margin-left:11%;"><b>&minus;&minus;packed</b></p>

<p style="margin-left:22%;">Show only packed structs, all
the other filters apply, i.e. to show just the sizes of all
packed structs combine --packed with --sizes, etc.</p>


<p style="margin-left:11%;"><b>&minus;&minus;unions</b></p>

<p style="margin-left:22%;">Show only unions, all the other
filters apply, i.e. to show just the sizes of all unions
combine --union with --sizes, etc.</p>


<p style="margin-left:11%;"><b>&minus;&minus;version</b></p>

<p style="margin-left:22%;">Show a traditional string
version, i.e.: &quot;v1.18&quot;.</p>


<p style="margin-left:11%;"><b>&minus;&minus;numeric_version</b></p>

<p style="margin-left:22%;">Show a numeric only version,
suitable for use in Makefiles and scripts where one wants to
know what if the installed version has some feature, i.e.:
118 instead of &quot;v1.18&quot;.</p>


<p style="margin-left:11%;"><b>&minus;&minus;kabi_prefix=STRING</b></p>

<p style="margin-left:22%;">When the prefix of the string
is STRING, treat the string as STRING.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To enable the
generation of debugging information in the Linux kernel
build process select CONFIG_DEBUG_INFO. This can be done
using make menuconfig by this path: &quot;Kernel
Hacking&quot; -&gt; &quot;Compile-time checks and compiler
options&quot; -&gt; &quot;Compile the kernel with debug
info&quot;. Consider as well enabling CONFIG_DEBUG_INFO_BTF
by going thru the aforementioned menuconfig path and then
selecting &quot;Generate BTF typeinfo&quot;. Most modern
distributions with eBPF support should come with that in all
its kernels, greatly facilitating the use of pahole.</p>

<p style="margin-left:11%; margin-top: 1em">Many
distributions also come with debuginfo packages, so just
enable it in your package manager repository configuration
and install the kernel-debuginfo, or any other userspace
program written in a language that the compiler generates
debuginfo (C, C++, for instance).</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All the
examples here use either /sys/kernel/btf/vmlinux, if
present, or lookup a vmlinux file matching the running
kernel, using the build-id info found in /sys/kernel/notes
to make sure it matches.</p>

<p style="margin-left:11%; margin-top: 1em">Show a
type:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole -C
__u64 <br>
typedef long long unsigned int __u64; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">Works as well
if the only argument is a type name:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
raw_spinlock_t <br>
typedef struct raw_spinlock raw_spinlock_t; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">Multiple types
can be passed, separated by commas:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
raw_spinlock_t,raw_spinlock <br>
struct raw_spinlock {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>arch_spinlock_t raw_lock; /* 0 4 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>/* size: 4, cachelines: 1, members: 1 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>/* last cacheline: 4 bytes */</p></td></tr>
</table>

<p style="margin-left:11%;">}; <br>
typedef struct raw_spinlock raw_spinlock_t; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">Types can be
expanded:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole -E
raw_spinlock <br>
struct raw_spinlock { <br>
/* typedef arch_spinlock_t */ struct qspinlock { <br>
union { <br>
/* typedef atomic_t */ struct { <br>
int counter; /* 0 4 */ <br>
} val; /* 0 4 */ <br>
struct { <br>
/* typedef u8 -&gt; __u8 */ unsigned char locked; /* 0 1 */
<br>
/* typedef u8 -&gt; __u8 */ unsigned char pending; /* 1 1 */
<br>
}; /* 0 2 */ <br>
struct { <br>
/* typedef u16 -&gt; __u16 */ short unsigned int
locked_pending; /* 0 2 */ <br>
/* typedef u16 -&gt; __u16 */ short unsigned int tail; /* 2
2 */ <br>
}; /* 0 4 */ <br>
}; /* 0 4 */ <br>
} raw_lock; /* 0 4 */</p>

<p style="margin-left:11%; margin-top: 1em">/* size: 4,
cachelines: 1, members: 1 */ <br>
/* last cacheline: 4 bytes */ <br>
}; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">When decoding
OOPSes you may want to see the offsets and sizes in
hexadecimal:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole --hex
thread_struct <br>
struct thread_struct { <br>
struct desc_struct tls_array[3]; /* 0 0x18 */ <br>
long unsigned int sp; /* 0x18 0x8 */ <br>
short unsigned int es; /* 0x20 0x2 */ <br>
short unsigned int ds; /* 0x22 0x2 */ <br>
short unsigned int fsindex; /* 0x24 0x2 */ <br>
short unsigned int gsindex; /* 0x26 0x2 */ <br>
long unsigned int fsbase; /* 0x28 0x8 */ <br>
long unsigned int gsbase; /* 0x30 0x8 */ <br>
struct perf_event * ptrace_bps[4]; /* 0x38 0x20 */ <br>
/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago ---
*/ <br>
long unsigned int debugreg6; /* 0x58 0x8 */ <br>
long unsigned int ptrace_dr7; /* 0x60 0x8 */ <br>
long unsigned int cr2; /* 0x68 0x8 */ <br>
long unsigned int trap_nr; /* 0x70 0x8 */ <br>
long unsigned int error_code; /* 0x78 0x8 */ <br>
/* --- cacheline 2 boundary (128 bytes) --- */ <br>
struct io_bitmap * io_bitmap; /* 0x80 0x8 */ <br>
long unsigned int iopl_emul; /* 0x88 0x8 */ <br>
mm_segment_t addr_limit; /* 0x90 0x8 */ <br>
unsigned int sig_on_uaccess_err:1; /* 0x98: 0 0x4 */ <br>
unsigned int uaccess_err:1; /* 0x98:0x1 0x4 */</p>

<p style="margin-left:11%; margin-top: 1em">/* XXX 30 bits
hole, try to pack */ <br>
/* XXX 36 bytes hole, try to pack */</p>

<p style="margin-left:11%; margin-top: 1em">/* ---
cacheline 3 boundary (192 bytes) --- */ <br>
struct fpu fpu; /* 0xc0 0x1040 */</p>

<p style="margin-left:11%; margin-top: 1em">/* size: 4352,
cachelines: 68, members: 20 */ <br>
/* sum members: 4312, holes: 1, sum holes: 36 */ <br>
/* sum bitfield members: 2 bits, bit holes: 1, sum bit
holes: 30 bits */ <br>
}; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">OK, I know the
offset that causes its a &rsquo;struct thread_struct&rsquo;
and that the offset is 0x178, so must be in that
&rsquo;fpu&rsquo; struct... No problem, expand &rsquo;struct
thread_struct&rsquo; and combine with <b>grep</b>:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole --hex
-E thread_struct | egrep &rsquo;(0x178|struct fpu)&rsquo;
-B4 -A4 <br>
/* XXX 30 bits hole, try to pack */ <br>
/* XXX 36 bytes hole, try to pack */</p>

<p style="margin-left:11%; margin-top: 1em">/* ---
cacheline 3 boundary (192 bytes) --- */ <br>
struct fpu { <br>
unsigned int last_cpu; /* 0xc0 0x4 */</p>

<p style="margin-left:11%; margin-top: 1em">/* XXX 4 bytes
hole, try to pack */</p>

<p style="margin-left:11%; margin-top: 1em">-- <br>
/* typedef u8 -&gt; __u8 */ unsigned char alimit; /* 0x171
0x1 */</p>

<p style="margin-left:11%; margin-top: 1em">/* XXX 6 bytes
hole, try to pack */</p>

<p style="margin-left:11%; margin-top: 1em">struct
math_emu_info * info; /* <i>0x178</i> 0x8 */ <br>
/* --- cacheline 6 boundary (384 bytes) --- */ <br>
/* typedef u32 -&gt; __u32 */ unsigned int entry_eip; /*
0x180 0x4 */ <br>
} soft; /* 0x100 0x88 */ <br>
struct xregs_state { <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">Want to know
where &rsquo;struct thread_struct&rsquo; is defined in the
kernel sources?</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole -I
thread_struct | head -2 <br>
/* Used at: /sys/kernel/btf/vmlinux */ <br>
/* &lt;0&gt; (null):0 */ <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">Not present in
BTF, so use DWARF, takes a little bit longer, and assuming
it finds the matching vmlinux file:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
-Fdwarf -I thread_struct | head -2 <br>
/* Used at: /home/acme/git/linux/arch/x86/kernel/head64.c */
<br>
/* &lt;3333&gt;
/home/acme/git/linux/arch/x86/include/asm/processor.h:485 */
<br>
$</p>

<p style="margin-left:11%; margin-top: 1em">To find the
biggest data structures in the Linux kernel:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole -s |
sort -k2 -nr | head -5 <br>
cmp_data 290904 1 <br>
dec_datas 274520 1 <br>
cpu_entry_area 217088 0 <br>
pglist_data 172928 4 <br>
saved_cmdlines_buffer 131104 1 <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">The second
column is the size in bytes and the third is the number of
alignment holes in that structure.</p>

<p style="margin-left:11%; margin-top: 1em">Show data
structures that have a raw spinlock and are related to the
RCU mechanism:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
--contains raw_spinlock_t --prefix rcu <br>
rcu_node <br>
rcu_data <br>
rcu_state <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">To see that in
context, combine it with <i>grep</i>:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
rcu_state | grep raw_spinlock_t -B1 -A5</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* --- cacheline 52 boundary (3328 bytes) --- */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>raw_spinlock_t ofl_lock; /* 3328 4 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* size: 3392, cachelines: 53, members: 35 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* sum members: 3250, holes: 7, sum holes: 82 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* padding: 60 */</p></td></tr>
</table>

<p style="margin-left:11%;">}; <br>
$</p>

<h2>PRETTY PRINTING
<a name="PRETTY PRINTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">pahole can also
use the data structure types to pretty print raw data
specified via --prettify. To consume raw data from the
standard input, just use &rsquo;--prettify -&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">It can also
pretty print raw data from stdin according to the type
specified:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole -C
modversion_info drivers/scsi/sg.ko <br>
struct modversion_info { <br>
long unsigned int crc; /* 0 8 */ <br>
char name[56]; /* 8 56 */</p>

<p style="margin-left:11%; margin-top: 1em">/* size: 64,
cachelines: 1, members: 2 */ <br>
}; <br>
$ <br>
$ objcopy -O binary --only-section=__versions
drivers/scsi/sg.ko versions <br>
$ <br>
$ ls -la versions <br>
-rw-rw-r--. 1 acme acme 7616 Jun 25 11:33 versions <br>
$ <br>
$ pahole --count 3 -C modversion_info drivers/scsi/sg.ko
--prettify versions <br>
{ <br>
.crc = 0x8dabd84, <br>
.name = &quot;module_layout&quot;, <br>
}, <br>
{ <br>
.crc = 0x45e4617b, <br>
.name = &quot;no_llseek&quot;, <br>
}, <br>
{ <br>
.crc = 0xa23fae8c, <br>
.name = &quot;param_ops_int&quot;, <br>
}, <br>
$ <br>
$ pahole --skip 1 --count 2 -C modversion_info
drivers/scsi/sg.ko --prettify - &lt; versions <br>
{ <br>
.crc = 0x45e4617b, <br>
.name = &quot;no_llseek&quot;, <br>
}, <br>
{ <br>
.crc = 0xa23fae8c, <br>
.name = &quot;param_ops_int&quot;, <br>
}, <br>
$ <br>
This is equivalent to:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
--seek_bytes 64 --count 1 -C modversion_info
drivers/scsi/sg.ko --prettify versions <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.crc = 0x45e4617b,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.name = &quot;no_llseek&quot;,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
$ <b><br>
&minus;C, &minus;&minus;class_name=CLASS_NAME</b></p>

<p style="margin-left:22%;">Pretty print according to this
class. Arguments may be passed to it to affect how the
pretty printing is performed, e.g.:</p>

<p style="margin-left:11%; margin-top: 1em">-C
&rsquo;perf_event_header(sizeof,type,type_enum=perf_event_type,filter=type==PERF_RECORD_EXIT)&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">This would
select the &rsquo;struct perf_event_header&rsquo; as the
type to use to pretty print records states that the
&rsquo;size&rsquo; field in that struct should be used to
figure out the size of the record (variable sized records),
that the &rsquo;enum perf_event_type&rsquo; should be used
to pretty print the numeric value in
perf_event_header-&gt;type and furthermore that it should be
used to heuristically look for structs with the same name
(lowercase) of the enum entry that is converted from the
type field, using it to pretty print instead of the base
&rsquo;perf_event_header&rsquo; type. See the PRETTY
PRINTING EXAMPLES section below.</p>

<p style="margin-left:11%; margin-top: 1em">Furthermore the
&rsquo;filter=&rsquo; part can be used, so far with only the
&rsquo;==&rsquo; operator to filter based on the
&rsquo;type&rsquo; field and converting the string
&rsquo;PERF_RECORD_EXIT&rsquo; to a number according to
type_enum.</p>

<p style="margin-left:11%; margin-top: 1em">The
&rsquo;sizeof&rsquo; arg defaults to the &rsquo;size&rsquo;
member name, if the name is different, one can use <br>
&rsquo;sizeof=sz&rsquo; form, ditto for
&rsquo;type=other_member_name&rsquo; field, that defaults to
&rsquo;type&rsquo;.</p>

<h2>PRETTY PRINTING EXAMPLES
<a name="PRETTY PRINTING EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Looking at the
ELF header for a vmlinux file, using BTF, first lets
discover the ELF header type:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
--sizes | grep -i elf | grep -i _h</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p>elf64_hdr</p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>64</p></td>
<td width="69%">


<p>0</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p>elf32_hdr</p></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">


<p>52</p></td>
<td width="69%">


<p>0</p></td></tr>
</table>

<p style="margin-left:11%;">$</p>

<p style="margin-left:11%; margin-top: 1em">Now we can use
this to show the first record from offset zero:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole -C
elf64_hdr --count 1 --prettify
/lib/modules/5.8.0-rc3+/build/vmlinux <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_ident = { 127, 69, 76, 70, 2, 1, 1, 0, 0, 0, 0, 0, 0,
0, 0, 0 },</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_type = 2,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_machine = 62,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_version = 1,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_entry = 16777216,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_phoff = 64,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_shoff = 775923840,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_flags = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_ehsize = 64,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_phentsize = 56,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_phnum = 5,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_shentsize = 64,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_shnum = 80,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.e_shstrndx = 79,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">This is
equivalent to:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
--header elf64_hdr --prettify
/lib/modules/5.8.0-rc3+/build/vmlinux</p>

<p style="margin-left:11%; margin-top: 1em">The --header
option also allows reference in other command line options
to fields in the header. This is useful when one wants to
show multiple records in a file and the range where those
fields are located is specified in header fields, such as
for perf.data files:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole --hex
~/bin/perf --header perf_file_header --prettify perf.data
<br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.magic = 0x32454c4946524550,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.size = 0x68,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.attr_size = 0x88,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.attrs = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.offset = 0xa8,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 0x88,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.data = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.offset = 0x130,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 0x588,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.event_types = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.offset = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.adds_features = { 0x16717ffc, 0, 0, 0 },</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">So to display
the cgroups records in the perf_file_header.data section we
can use:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
~/bin/perf --header=perf_file_header --seek_bytes
&rsquo;$header.data.offset&rsquo;
--size_bytes=&rsquo;$header.data.size&rsquo; -C
&rsquo;perf_event_header(sizeof,type,type_enum=perf_event_type,filter=type==PERF_RECORD_CGROUP)&rsquo;
--prettify perf.data <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CGROUP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 40,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.id = 1,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.path = &quot;/&quot;,</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CGROUP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 48,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.id = 1553,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.path = &quot;/system.slice&quot;,</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CGROUP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 48,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.id = 8,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.path = &quot;/machine.slice&quot;,</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CGROUP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 128,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.id = 7828,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.path =
&quot;/machine.slice/libpod-42be8e8d4eb9d22405845005f0d04ea398548dccc934a150fbaa3c1f1f9492c2.scope&quot;,</p> </td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CGROUP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 88,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.id = 13,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.path =
&quot;/machine.slice/machine-qemu\x2d1\x2drhel6.sandy.scope&quot;,</p> </td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">For the common
case of the header having a member that has the
&rsquo;offset&rsquo; and &rsquo;size&rsquo; members, it is
possible to use this more compact form:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
~/bin/perf --header=perf_file_header --range=data -C
&rsquo;perf_event_header(sizeof,type,type_enum=perf_event_type,filter=type==PERF_RECORD_CGROUP)&rsquo;
--prettify perf.data</p>

<p style="margin-left:11%; margin-top: 1em">This uses
~/bin/perf to get the type definitions, the defines
&rsquo;struct perf_file_header&rsquo; as the header, then
seeks &rsquo;$header.data.offset&rsquo; bytes from the start
of the file, and considers &rsquo;$header.data.size&rsquo;
bytes worth of such records. The filter expression may omit
a common prefix, in this case it could additionally be
equivalently written as both
&rsquo;filter=type==CGROUP&rsquo; or the
&rsquo;filter=&rsquo; can also be omitted, getting as
compact as &rsquo;type==CGROUP&rsquo;:</p>

<p style="margin-left:11%; margin-top: 1em">If we look
at:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
~/bin/perf -C perf_event_header <br>
struct perf_event_header {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>__u32 type; /* 0 4 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>__u16 misc; /* 4 2 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>__u16 size; /* 6 2 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* size: 8, cachelines: 1, members: 3 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* last cacheline: 8 bytes */</p></td></tr>
</table>

<p style="margin-left:11%;">}; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">And:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
~/bin/perf -C perf_event_type <br>
enum perf_event_type {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_MMAP = 1,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_LOST = 2,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_COMM = 3,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_EXIT = 4,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_THROTTLE = 5,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_UNTHROTTLE = 6,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_FORK = 7,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_READ = 8,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_SAMPLE = 9,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_MMAP2 = 10,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_AUX = 11,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_ITRACE_START = 12,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_LOST_SAMPLES = 13,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_SWITCH = 14,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_SWITCH_CPU_WIDE = 15,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_NAMESPACES = 16,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_KSYMBOL = 17,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_BPF_EVENT = 18,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_CGROUP = 19,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_TEXT_POKE = 20,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PERF_RECORD_MAX = 21,</p></td></tr>
</table>

<p style="margin-left:11%;">}; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">And
furthermore:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
~/bin/perf -C perf_record_cgroup <br>
struct perf_record_cgroup {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>struct perf_event_header header; /* 0 8 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>__u64 id; /* 8 8 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>char path[4096]; /* 16 4096 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* size: 4112, cachelines: 65, members: 3 */</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* last cacheline: 16 bytes */</p></td></tr>
</table>

<p style="margin-left:11%;">}; <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">Then we can see
how the perf_event_header.type could be converted from a
__u32 to a string (PERF_RECORD_CGROUP). If we remove that
type_enum=perf_event_type, we will lose the conversion of
&rsquo;struct perf_event_header&rsquo; to the more
descriptive &rsquo;struct perf_record_cgroup&rsquo;, and
also the beautification of the header.type field:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
~/bin/perf --header=perf_file_header --seek_bytes
&rsquo;$header.data.offset&rsquo;
--size_bytes=&rsquo;$header.data.size&rsquo; -C
&rsquo;perf_event_header(sizeof,type,filter=type==19)&rsquo;
--prettify perf.data <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.type = 19,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.size = 40,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.type = 19,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.size = 48,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.type = 19,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.size = 48,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.type = 19,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.size = 128,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.type = 19,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.size = 88,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">Some of the
records are not found in
&rsquo;type_enum=perf_event_type&rsquo; so some of the
records don&rsquo;t get converted to a type that fully shows
its contents. For perf we know that those are in another
enumeration, &rsquo;enum perf_user_event_type&rsquo;, so,
for these cases, we can create a &rsquo;virtual enum&rsquo;,
i.e. the sum of two enums and then get all those entries
decoded and properly casted, first few records with just
&rsquo;enum perf_event_type&rsquo;:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
~/bin/perf --header=perf_file_header --seek_bytes
&rsquo;$header.data.offset&rsquo;
--size_bytes=&rsquo;$header.data.size&rsquo; -C
&rsquo;perf_event_header(sizeof,type,type_enum=perf_event_type)&rsquo;
--count 4 --prettify perf.data <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.type = 79,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.size = 32,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.type = 73,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.size = 40,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.type = 74,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>.size = 32,</p></td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CGROUP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 40,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.id = 1,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.path = &quot;/&quot;,</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">Now with both
enumerations, i.e. with
&rsquo;type_enum=perf_event_type+perf_user_event_type&rsquo;:</p>

<p style="margin-left:11%; margin-top: 1em">$ pahole
~/bin/perf --header=perf_file_header --seek_bytes
&rsquo;$header.data.offset&rsquo;
--size_bytes=&rsquo;$header.data.size&rsquo; -C
&rsquo;perf_event_header(sizeof,type,type_enum=perf_event_type+perf_user_event_type)&rsquo;
--count 5 --prettify perf.data <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_TIME_CONV,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 32,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.time_shift = 31,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.time_mult = 1016803377,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.time_zero = 435759009518382,</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_THREAD_MAP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 40,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.nr = 1,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.entries = 0x50 0x7e 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00,</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CPU_MAP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 32,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.data = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = 1,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.data = &quot;&quot;,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CGROUP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 40,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.id = 1,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.path = &quot;/&quot;,</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.header = {</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.type = PERF_RECORD_CGROUP,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.misc = 0,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p>.size = 48,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>},</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.id = 1553,</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>.path = &quot;/system.slice&quot;,</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:11%;">}, <br>
$</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to pass multiple types, one has only to make sure they
appear in the file in sequence, i.e. for the perf.data
example, see the perf_file_header dump above, one can print
the perf_file_attr structs in the header attrs range, then
the perf_event_header in the data range with the following
command:</p>

<p style="margin-left:11%; margin-top: 1em">pahole
~/bin/perf --header=perf_file_header -C
&rsquo;perf_file_attr(range=attrs),perf_event_header(range=data,sizeof,type,type_enum=perf_event_type+perf_user_event_type)&rsquo;
--prettify perf.data</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>eu-readelf</i>(1),
<i>readelf</i>(1), <i>objdump</i>(1).</p>


<p style="margin-left:11%; margin-top: 1em"><i>https://www.kernel.org/doc/ols/2007/ols2007v2-pages-35-44.pdf</i>.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>pahole</b>
was written and is maintained by Arnaldo Carvalho de Melo
&lt;acme@kernel.org&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Thanks to
Andrii Nakryiko and Martin KaFai Lau for providing the BTF
encoder and improving the codebase while making sure the BTF
encoder works as needed to be used in encoding the Linux
kernel .BTF section from the DWARF info generated by gcc.
For that Andrii wrote a BTF deduplicator in libbpf that is
used by <b>pahole</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Also thanks to
Conectiva, Mandriva and Red Hat for allowing me to work on
these tools.</p>

<p style="margin-left:11%; margin-top: 1em">Please send bug
reports to &lt;dwarves@vger.kernel.org&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">No subscription
is required.</p>
<hr>
</body>
</html>
