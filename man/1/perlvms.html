<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:00 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLVMS</title>

</head>
<body>
<h1>perlvms</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlvms &minus;
VMS&minus;specific documentation for Perl</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Gathered below
are notes describing details of Perl 5&rsquo;s behavior on
<small>VMS.</small> They are a supplement to the regular
Perl 5 documentation, so we have focussed on the ways in
which Perl 5 functions differently under <small>VMS</small>
than it does under Unix, and on the interactions between
Perl and the rest of the operating system. We haven&rsquo;t
tried to duplicate complete descriptions of Perl features
from the main Perl documentation, which can be found in the
<i>[.pod]</i> subdirectory of the Perl distribution.</p>

<p style="margin-left:11%; margin-top: 1em">We hope these
notes will save you from confusion and lost sleep when
writing Perl scripts on <small>VMS.</small> If you find
we&rsquo;ve missed something you think should appear here,
please don&rsquo;t hesitate to drop a line to
vmsperl@perl.org.</p>

<h2>Installation
<a name="Installation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Directions for
building and installing Perl 5 can be found in the file
<i><small>README</small> .vms</i> in the main source
directory of the Perl distribution.</p>

<h2>Organization of Perl Images
<a name="Organization of Perl Images"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Core
Images</b> <br>
During the build process, three Perl images are produced.
<i>Miniperl.Exe</i> is an executable image which contains
all of the basic functionality of Perl, but cannot take
advantage of Perl <small>XS</small> extensions and has a
hard-wired list of library locations for loading pure-Perl
modules. It is used extensively to build and test Perl and
various extensions, but is not installed.</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
complete Perl resides in the shareable image
<i>PerlShr.Exe</i>, which provides a core to which the Perl
executable image and all Perl extensions are linked. It is
generally located via the logical name
<i><small>PERLSHR</small></i> . While it&rsquo;s possible to
put the image in <i><small>SYS$SHARE</small></i> to make it
loadable, that&rsquo;s not recommended. And while you may
wish to <small>INSTALL</small> the image for performance
reasons, you should not install it with privileges; if you
do, the result will not be what you expect as image
privileges are disabled during Perl start-up.</p>

<p style="margin-left:11%; margin-top: 1em">Finally,
<i>Perl.Exe</i> is an executable image containing the main
entry point for Perl, as well as some initialization code.
It should be placed in a public directory, and made world
executable. In order to run Perl with command line
arguments, you should define a foreign command to invoke
this image.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Perl
Extensions</b> <br>
Perl extensions are packages which provide both
<small>XS</small> and Perl code to add new functionality to
perl. ( <small>XS</small> is a meta-language which
simplifies writing C code which interacts with Perl, see
perlxs for more details.) The Perl code for an extension is
treated like any other library module &minus; it&rsquo;s
made available in your script through the appropriate
&quot;use&quot; or &quot;require&quot; statement, and
usually defines a Perl package containing the extension.</p>

<p style="margin-left:11%; margin-top: 1em">The portion of
the extension provided by the <small>XS</small> code may be
connected to the rest of Perl in either of two ways. In the
<b>static</b> configuration, the object code for the
extension is linked directly into <i>PerlShr.Exe</i>, and is
initialized whenever Perl is invoked. In the <b>dynamic</b>
configuration, the extension&rsquo;s machine code is placed
into a separate shareable image, which is mapped by
Perl&rsquo;s DynaLoader when the extension is
&quot;use&quot;d or &quot;require&quot;d in your script.
This allows you to maintain the extension as a separate
entity, at the cost of keeping track of the additional
shareable image. Most extensions can be set up as either
static or dynamic.</p>

<p style="margin-left:11%; margin-top: 1em">The source code
for an extension usually resides in its own directory. At
least three files are generally provided:
<i>Extshortname.xs</i> (where <i>Extshortname</i> is the
portion of the extension&rsquo;s name following the last
&quot;::&quot;), containing the <small>XS</small> code,
<i>Extshortname.pm</i>, the Perl library module for the
extension, and <i>Makefile.PL</i>, a Perl script which uses
the &quot;MakeMaker&quot; library modules supplied with Perl
to generate a <i>Descrip.MMS</i> file for the extension.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Installing
static extensions</b> <br>
Since static extensions are incorporated directly into
<i>PerlShr.Exe</i>, you&rsquo;ll have to rebuild Perl to
incorporate a new extension. You should edit the main
<i>Descrip.MMS</i> or <i>Makefile</i> you use to build Perl,
adding the extension&rsquo;s name to the &quot;ext&quot;
macro, and the extension&rsquo;s object file to the
&quot;extobj&quot; macro. You&rsquo;ll also need to build
the extension&rsquo;s object file, either by adding
dependencies to the main <i>Descrip.MMS</i>, or using a
separate <i>Descrip.MMS</i> for the extension. Then, rebuild
<i>PerlShr.Exe</i> to incorporate the new code.</p>

<p style="margin-left:11%; margin-top: 1em">Finally,
you&rsquo;ll need to copy the extension&rsquo;s Perl library
module to the <i>[.Extname]</i> subdirectory under one of
the directories in @INC, where <i>Extname</i> is the name of
the extension, with all &quot;::&quot; replaced by
&quot;.&quot; (e.g. the library module for extension
Foo::Bar would be copied to a <i>[.Foo.Bar]</i>
subdirectory).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Installing
dynamic extensions</b> <br>
In general, the distributed kit for a Perl extension
includes a file named Makefile.PL, which is a Perl program
which is used to create a <i>Descrip.MMS</i> file which can
be used to build and install the files required by the
extension. The kit should be unpacked into a directory tree
<b>not</b> under the main Perl source directory, and the
procedure for building the extension is simply</p>

<p style="margin-left:11%; margin-top: 1em">$ perl
Makefile.PL ! Create Descrip.MMS <br>
$ mmk ! Build necessary files <br>
$ mmk test ! Run test code, if supplied <br>
$ mmk install ! Install into public Perl tree</p>


<p style="margin-left:11%; margin-top: 1em"><small>VMS</small>
support for this process in the current release of Perl is
sufficient to handle most extensions. (See the MakeMaker
documentation for more details on installation options for
extensions.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>the <i>[.Lib.Auto.Arch$PVersExtname]</i> subdirectory of
one of the directories in @INC (where <i>PVers</i> is the
version of Perl you&rsquo;re using, as supplied in $], with
&rsquo;.&rsquo; converted to &rsquo;_&rsquo;), or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>one of the directories in @INC, or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>a directory which the extensions Perl library module
passes to the DynaLoader when asking it to map the shareable
image, or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p><i>Sys$Share</i> or <i>Sys$Library</i>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the
shareable image isn&rsquo;t in any of these places,
you&rsquo;ll need to define a logical name
<i>Extshortname</i>, where <i>Extshortname</i> is the
portion of the extension&rsquo;s name after the last
&quot;::&quot;, which translates to the full file
specification of the shareable image.</p>

<h2>File specifications
<a name="File specifications"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Syntax</b>
<br>
We have tried to make Perl aware of both VMS-style and
Unix-style file specifications wherever possible. You may
use either style, or both, on the command line and in
scripts, but you may not combine the two styles within a
single file specification. <small>VMS</small> Perl
interprets Unix pathnames in much the same way as the
<small>CRTL</small> (<i>e.g.</i> the first component of an
absolute path is read as the device name for the
<small>VMS</small> file specification). There are a set of
functions provided in the &quot;VMS::Filespec&quot; package
for explicit interconversion between <small>VMS</small> and
Unix syntax; its documentation provides more details.</p>

<p style="margin-left:11%; margin-top: 1em">We&rsquo;ve
tried to minimize the dependence of Perl library modules on
Unix syntax, but you may find that some of these, as well as
some scripts written for Unix systems, will require that you
use Unix syntax, since they will assume that &rsquo;/&rsquo;
is the directory separator, <i>etc.</i> If you find
instances of this in the Perl distribution itself, please
let us know, so we can try to work around them.</p>

<p style="margin-left:11%; margin-top: 1em">Also when
working on Perl programs on <small>VMS,</small> if you need
a syntax in a specific operating system format, then you
need either to check the appropriate <small>DECC$</small>
feature logical, or call a conversion routine to force it to
that format.</p>

<p style="margin-left:11%; margin-top: 1em">The feature
logical name <small>DECC$FILENAME_UNIX_REPORT</small>
modifies traditional Perl behavior in the conversion of file
specifications from Unix to <small>VMS</small> format in
order to follow the extended character handling rules now
expected by the <small>CRTL.</small> Specifically, when this
feature is in effect, the &quot;./.../&quot; in a Unix path
is now translated to &quot;[.^.^.^.]&quot; instead of the
traditional <small>VMS</small> &quot;[...]&quot;. To be
compatible with what MakeMaker expects, if a
<small>VMS</small> path cannot be translated to a Unix path,
it is passed through unchanged, so
&quot;unixify(&quot;[...]&quot;)&quot; will return
&quot;[...]&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">There are
several ambiguous cases where a conversion routine cannot
determine whether an input filename is in Unix format or in
<small>VMS</small> format, since now both <small>VMS</small>
and Unix file specifications may have characters in them
that could be mistaken for syntax delimiters of the other
type. So some pathnames simply cannot be used in a mode that
allows either type of pathname to be present. Perl will tend
to assume that an ambiguous filename is in Unix format.</p>

<p style="margin-left:11%; margin-top: 1em">Allowing
&quot;.&quot; as a version delimiter is simply incompatible
with determining whether a pathname is in <small>VMS</small>
format or in Unix format with extended file syntax. There is
no way to know whether &quot;perl&minus;5.8.6&quot; is a
Unix &quot;perl&minus;5.8.6&quot; or a <small>VMS</small>
&quot;perl&minus;5.8;6&quot; when passing it to
<b>unixify()</b> or <b>vmsify()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>DECC$FILENAME_UNIX_REPORT</small> logical name
controls how Perl interprets filenames to the extent that
Perl uses the <small>CRTL</small> internally for many
purposes, and attempts to follow <small>CRTL</small>
conventions for reporting filenames. The
<small>DECC$FILENAME_UNIX_ONLY</small> feature differs in
that it expects all filenames passed to the C run-time to be
already in Unix format. This feature is not yet supported in
Perl since Perl uses traditional OpenVMS file specifications
internally and in the test harness, and it is not yet clear
whether this mode will be useful or useable. The feature
logical name <small>DECC$POSIX_COMPLIANT_PATHNAMES</small>
is new with the <small>RMS</small> Symbolic Link
<small>SDK</small> and included with OpenVMS v8.3, but is
not yet supported in Perl.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Filename
Case</b> <br>
Perl enables <small>DECC$EFS_CASE_PRESERVE</small> and
<small>DECC$ARGV_PARSE_STYLE</small> by default. Note that
the latter only takes effect when extended parse is set in
the process in which Perl is running. When these features
are explicitly disabled in the environment or the
<small>CRTL</small> does not support them, Perl follows the
traditional <small>CRTL</small> behavior of downcasing
command-line arguments and returning file specifications in
lower case only.</p>

<p style="margin-left:11%; margin-top: 1em"><i>N. B.</i> It
is very easy to get tripped up using a mixture of other
programs, external utilities, and Perl scripts that are in
varying states of being able to handle case preservation.
For example, a file created by an older version of an
archive utility or a build utility such as
<small>MMK</small> or <small>MMS</small> may generate a
filename in all upper case even on an
<small>ODS&minus;5</small> volume. If this filename is later
retrieved by a Perl script or module in a case preserving
environment, that upper case name may not match the
mixed-case or lower-case expectations of the Perl code. Your
best bet is to follow an all-or-nothing approach to case
preservation: either don&rsquo;t use it at all, or make sure
your entire toolchain and application environment support
and use it.</p>

<p style="margin-left:11%; margin-top: 1em">OpenVMS Alpha
v7.3&minus;1 and later and all version of OpenVMS I64
support case sensitivity as a process setting (see &quot;SET
PROCESS /CASE_LOOKUP=SENSITIVE&quot;). Perl does not
currently support case sensitivity on <small>VMS,</small>
but it may in the future, so Perl programs should use the
&quot;File::Spec&minus;&gt;case_tolerant&quot; method to
determine the state, and not the $^O variable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Symbolic
Links</b> <br>
When built on an <small>ODS&minus;5</small> volume with
symbolic links enabled, Perl by default supports symbolic
links when the requisite support is available in the
filesystem and <small>CRTL</small> (generally 64&minus;bit
OpenVMS v8.3 and later). There are a number of limitations
and caveats to be aware of when working with symbolic links
on <small>VMS.</small> Most notably, the target of a valid
symbolic link must be expressed as a Unix-style path and it
must exist on a volume visible from your
<small>POSIX</small> root (see the &quot;SHOW ROOT&quot;
command in <small>DCL</small> help). For further details on
symbolic link capabilities and requirements, see chapter 12
of the <small>CRTL</small> manual that ships with OpenVMS
v8.3 or later.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Wildcard
expansion</b> <br>
File specifications containing wildcards are allowed both on
the command line and within Perl globs (e.g.
&quot;&lt;*.c&gt;&quot;). If the wildcard filespec uses
<small>VMS</small> syntax, the resultant filespecs will
follow <small>VMS</small> syntax; if a Unix-style filespec
is passed in, Unix-style filespecs will be returned. Similar
to the behavior of wildcard globbing for a Unix shell, one
can escape command line wildcards with double quotation
marks &quot;&quot;&quot; around a perl program command line
argument. However, owing to the stripping of
&quot;&quot;&quot; characters carried out by the C handling
of argv you will need to escape a construct such as this one
(in a directory containing the files
<i><small>PERL.C</small></i> ,
<i><small>PERL.EXE</small></i> ,
<i><small>PERL.H</small></i> , and
<i><small>PERL.OBJ</small></i> ):</p>

<p style="margin-left:11%; margin-top: 1em">$ perl &minus;e
&quot;print join(' ',@ARGV)&quot; perl.* <br>
perl.c perl.exe perl.h perl.obj</p>

<p style="margin-left:11%; margin-top: 1em">in the
following triple quoted manner:</p>

<p style="margin-left:11%; margin-top: 1em">$ perl &minus;e
&quot;print join(' ',@ARGV)&quot;
&quot;&quot;&quot;perl.*&quot;&quot;&quot; <br>
perl.*</p>

<p style="margin-left:11%; margin-top: 1em">In both the
case of unquoted command line arguments or in calls to
&quot;glob()&quot; <small>VMS</small> wildcard expansion is
performed. (csh-style wildcard expansion is available if you
use &quot;File::Glob::glob&quot;.) If the wildcard filespec
contains a device or directory specification, then the
resultant filespecs will also contain a device and
directory; otherwise, device and directory information are
removed. VMS-style resultant filespecs will contain a full
device and directory, while Unix-style resultant filespecs
will contain only as much of a directory path as was present
in the input filespec. For example, if your default
directory is Perl_Root:[000000], the expansion of
&quot;[.t]*.*&quot; will yield filespecs like
&quot;perl_root:[t]base.dir&quot;, while the expansion of
&quot;t/*/*&quot; will yield filespecs like
&quot;t/base.dir&quot;. (This is done to match the behavior
of glob expansion performed by Unix shells.)</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, the
resultant filespec will contain the file version only if one
was present in the input filespec.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pipes</b>
<br>
Input and output pipes to Perl filehandles are supported;
the &quot;file name&quot; is passed to lib$<b>spawn()</b>
for asynchronous execution. You should be careful to close
any pipes you have opened in a Perl script, lest you leave
any &quot;orphaned&quot; subprocesses around when Perl
exits.</p>

<p style="margin-left:11%; margin-top: 1em">You may also
use backticks to invoke a <small>DCL</small> subprocess,
whose output is used as the return value of the expression.
The string between the backticks is handled as if it were
the argument to the &quot;system&quot; operator (see below).
In this case, Perl will wait for the subprocess to complete
before continuing.</p>

<p style="margin-left:11%; margin-top: 1em">The mailbox (
<small>MBX</small> ) that perl can create to communicate
with a pipe defaults to a buffer size of 8192 on
64&minus;bit systems, 512 on <small>VAX.</small> The default
buffer size is adjustable via the logical name
<small>PERL_MBX_SIZE</small> provided that the value falls
between 128 and the <small>SYSGEN</small> parameter
<small>MAXBUF</small> inclusive. For example, to set the
mailbox size to 32767 use &quot;$ENV{'PERL_MBX_SIZE'} =
32767;&quot; and then open and use pipe constructs. An
alternative would be to issue the command:</p>

<p style="margin-left:11%; margin-top: 1em">$ Define
PERL_MBX_SIZE 32767</p>

<p style="margin-left:11%; margin-top: 1em">before running
your wide record pipe program. A larger value may improve
performance at the expense of the <small>BYTLM UAF</small>
quota.</p>

<h2>PERL5LIB and PERLLIB
<a name="PERL5LIB and PERLLIB"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>PERL5LIB</small> and <small>PERLLIB</small>
environment elements work as documented in perl, except that
the element separator is, by default, &rsquo;|&rsquo;
instead of &rsquo;:&rsquo;. However, when running under a
Unix shell as determined by the logical name
&quot;GNV$UNIX_SHELL&quot;, the separator will be
&rsquo;:&rsquo; as on Unix systems. The directory
specifications may use either <small>VMS</small> or Unix
syntax.</p>

<h2>The Perl Forked Debugger
<a name="The Perl Forked Debugger"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Perl forked
debugger places the debugger commands and output in a
separate X&minus;11 terminal window so that commands and
output from multiple processes are not mixed together.</p>

<p style="margin-left:11%; margin-top: 1em">Perl on
<small>VMS</small> supports an emulation of the forked
debugger when Perl is run on a <small>VMS</small> system
that has X11 support installed.</p>

<p style="margin-left:11%; margin-top: 1em">To use the
forked debugger, you need to have the default display set to
an X&minus;11 Server and some environment variables set that
Unix expects.</p>

<p style="margin-left:11%; margin-top: 1em">The forked
debugger requires the environment variable &quot;TERM&quot;
to be &quot;xterm&quot;, and the environment variable
&quot;DISPLAY&quot; to exist. &quot;xterm&quot; must be in
lower case.</p>

<p style="margin-left:11%; margin-top: 1em">$define TERM
&quot;xterm&quot; <br>
$define DISPLAY &quot;hostname:0.0&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Currently the
value of &quot;DISPLAY&quot; is ignored. It is recommended
that it be set to be the hostname of the display, the server
and screen in Unix notation. In the future the value of
<small>DISPLAY</small> may be honored by Perl instead of
using the default display.</p>

<p style="margin-left:11%; margin-top: 1em">It may be
helpful to always use the forked debugger so that script I/O
is separated from debugger I/O. You can force the debugger
to be forked by assigning a value to the logical name &lt;
<small>PERLDB_PIDS</small> &gt; that is not a process
identification number.</p>

<p style="margin-left:11%; margin-top: 1em">$define
PERLDB_PIDS XXXX</p>

<h2>PERL_VMS_EXCEPTION_DEBUG
<a name="PERL_VMS_EXCEPTION_DEBUG"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>PERL_VMS_EXCEPTION_DEBUG</small> being defined as
&quot; <small>ENABLE&quot;</small> will cause the
<small>VMS</small> debugger to be invoked if a fatal
exception that is not otherwise handled is raised. The
purpose of this is to allow debugging of internal Perl
problems that would cause such a condition.</p>

<p style="margin-left:11%; margin-top: 1em">This allows the
programmer to look at the execution stack and variables to
find out the cause of the exception. As the debugger is
being invoked as the Perl interpreter is about to do a fatal
exit, continuing the execution in debug mode is usually not
practical.</p>

<p style="margin-left:11%; margin-top: 1em">Starting Perl
in the <small>VMS</small> debugger may change the program
execution profile in a way that such problems are not
reproduced.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;kill&quot; function can be used to test this
functionality from within a program.</p>

<p style="margin-left:11%; margin-top: 1em">In typical
<small>VMS</small> style, only the first letter of the value
of this logical name is actually checked in a case
insensitive mode, and it is considered enabled if it is the
value &quot;T&quot;,&quot;1&quot; or &quot;E&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This logical
name must be defined before Perl is started.</p>

<h2>Command line
<a name="Command line"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>I/O
redirection and backgrounding</b> <br>
Perl for <small>VMS</small> supports redirection of input
and output on the command line, using a subset of Bourne
shell syntax:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p style="margin-top: 1em">&quot;&lt;file&quot; reads stdin
from &quot;file&quot;,</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p>&quot;&gt;file&quot; writes stdout to
&quot;file&quot;,</p> </td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p>&quot;&gt;&gt;file&quot; appends stdout to
&quot;file&quot;,</p> </td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p>&quot;2&gt;file&quot; writes stderr to
&quot;file&quot;,</p> </td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p>&quot;2&gt;&gt;file&quot; appends stderr to
&quot;file&quot;, and</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p>&quot;2&gt;&amp;1&quot; redirects stderr to stdout.</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In addition,
output may be piped to a subprocess, using the character
&rsquo;|&rsquo;. Anything after this character on the
command line is passed to a subprocess for execution; the
subprocess takes the output of Perl as its input.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, if the
command line ends with &rsquo;&amp;&rsquo;, the entire
command is run in the background as an asynchronous
subprocess.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Command line
switches</b> <br>
The following command line switches behave differently under
<small>VMS</small> than described in perlrun. Note also that
in order to pass uppercase switches to Perl, you need to
enclose them in double-quotes on the command line, since the
<small>CRTL</small> downcases all unquoted strings.</p>

<p style="margin-left:11%; margin-top: 1em">On newer 64 bit
versions of OpenVMS, a process setting now controls if the
quoting is needed to preserve the case of command line
arguments.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">&minus;i</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If the &quot;&minus;i&quot;
switch is present but no extension for a backup copy is
given, then inplace editing creates a new version of a file;
the existing copy is not deleted. (Note that if an extension
is given, an existing file is renamed to the backup file, as
is the case under other operating systems, so it does not
remain as a previous version under the original
filename.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;S</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the &quot;&minus;S&quot; or
&quot;&minus;&quot;S&quot;&quot; switch is present
<i>and</i> the script name does not contain a directory,
then Perl translates the logical name
<small>DCL$PATH</small> as a searchlist, using each
translation as a directory in which to look for the script.
In addition, if no file type is specified, Perl looks in
each directory for a file matching the name specified, with
a blank type, a type of <i>.pl</i>, and a type of
<i>.com</i>, in that order.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>&minus;u</p></td>
<td width="3%"></td>
<td width="83%">


<p>The &quot;&minus;u&quot; switch causes the
<small>VMS</small> debugger to be invoked after the Perl
program is compiled, but before it has run. It does not
create a core dump file.</p></td></tr>
</table>

<h2>Perl functions
<a name="Perl functions"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As of the time
this document was last revised, the following Perl functions
were implemented in the <small>VMS</small> port of Perl
(functions marked with * are discussed in more detail
below):</p>

<p style="margin-left:11%; margin-top: 1em">file tests*,
abs, alarm, atan, backticks*, binmode*, bless, <br>
caller, chdir, chmod, chown, chomp, chop, chr, <br>
close, closedir, cos, crypt*, defined, delete, die, do,
dump*, <br>
each, endgrent, endpwent, eof, eval, exec*, exists, exit,
exp, <br>
fileno, flock getc, getgrent*, getgrgid*, getgrnam,
getlogin, <br>
getppid, getpwent*, getpwnam*, getpwuid*, glob, gmtime*,
goto, <br>
grep, hex, ioctl, import, index, int, join, keys, kill*,
<br>
last, lc, lcfirst, lchown*, length, link*, local, localtime,
log, <br>
lstat, m//, map, mkdir, my, next, no, oct, open, opendir,
ord, <br>
pack, pipe, pop, pos, print, printf, push, q//, qq//, qw//,
<br>
qx//*, quotemeta, rand, read, readdir, readlink*, redo, ref,
<br>
rename, require, reset, return, reverse, rewinddir, rindex,
<br>
rmdir, s///, scalar, seek, seekdir, select(internal), <br>
select (system call)*, setgrent, setpwent, shift, sin,
sleep, <br>
socketpair, sort, splice, split, sprintf, sqrt, srand, stat,
<br>
study, substr, symlink*, sysread, system*, syswrite, tell,
<br>
telldir, tie, time, times*, tr///, uc, ucfirst, umask, <br>
undef, unlink*, unpack, untie, unshift, use, utime*, <br>
values, vec, wait, waitpid*, wantarray, warn, write,
y///</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions were not implemented in the <small>VMS</small>
port, and calling them produces a fatal error (usually) or
undefined behavior (rarely, we hope):</p>

<p style="margin-left:11%; margin-top: 1em">chroot,
dbmclose, dbmopen, fork*, getpgrp, getpriority, <br>
msgctl, msgget, msgsend, msgrcv, semctl, <br>
semget, semop, setpgrp, setpriority, shmctl, shmget, <br>
shmread, shmwrite, syscall</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions are available on Perls compiled with Dec C 5.2 or
greater and running <small>VMS 7.0</small> or greater:</p>

<p style="margin-left:11%; margin-top: 1em">truncate</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions are available on Perls built on <small>VMS
7.2</small> or greater:</p>

<p style="margin-left:11%; margin-top: 1em">fcntl (without
locking)</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions may or may not be implemented, depending on what
type of socket support you&rsquo;ve built into your copy of
Perl:</p>

<p style="margin-left:11%; margin-top: 1em">accept, bind,
connect, getpeername, <br>
gethostbyname, getnetbyname, getprotobyname, <br>
getservbyname, gethostbyaddr, getnetbyaddr, <br>
getprotobynumber, getservbyport, gethostent, <br>
getnetent, getprotoent, getservent, sethostent, <br>
setnetent, setprotoent, setservent, endhostent, <br>
endnetent, endprotoent, endservent, getsockname, <br>
getsockopt, listen, recv, select(system call)*, <br>
send, setsockopt, shutdown, socket</p>

<p style="margin-left:11%; margin-top: 1em">The following
function is available on Perls built on 64 bit OpenVMS v8.2
with hard links enabled on an <small>ODS&minus;5</small>
formatted build disk. <small>CRTL</small> support is in
principle available as of OpenVMS v7.3&minus;1, and better
configuration support could detect this.</p>

<p style="margin-left:11%; margin-top: 1em">link</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions are available on Perls built on 64 bit OpenVMS
v8.2 and later. <small>CRTL</small> support is in principle
available as of OpenVMS v7.3&minus;2, and better
configuration support could detect this.</p>

<p style="margin-left:11%; margin-top: 1em">getgrgid,
getgrnam, getpwnam, getpwuid, <br>
setgrent, ttyname</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions are available on Perls built on 64 bit OpenVMS
v8.2 and later.</p>

<p style="margin-left:11%; margin-top: 1em">statvfs,
socketpair <br>
File tests</p>

<p style="margin-left:17%;">The tests &quot;&minus;b&quot;,
&quot;&minus;B&quot;, &quot;&minus;c&quot;,
&quot;&minus;C&quot;, &quot;&minus;d&quot;,
&quot;&minus;e&quot;, &quot;&minus;f&quot;,
&quot;&minus;o&quot;, &quot;&minus;M&quot;,
&quot;&minus;s&quot;, &quot;&minus;S&quot;,
&quot;&minus;t&quot;, &quot;&minus;T&quot;, and
&quot;&minus;z&quot; work as advertised. The return values
for &quot;&minus;r&quot;, &quot;&minus;w&quot;, and
&quot;&minus;x&quot; tell you whether you can actually
access the file; this may not reflect the UIC-based file
protections. Since real and effective <small>UIC</small>
don&rsquo;t differ under <small>VMS,</small>
&quot;&minus;O&quot;, &quot;&minus;R&quot;,
&quot;&minus;W&quot;, and &quot;&minus;X&quot; are
equivalent to &quot;&minus;o&quot;, &quot;&minus;r&quot;,
&quot;&minus;w&quot;, and &quot;&minus;x&quot;. Similarly,
several other tests, including &quot;&minus;A&quot;,
&quot;&minus;g&quot;, &quot;&minus;k&quot;,
&quot;&minus;l&quot;, &quot;&minus;p&quot;, and
&quot;&minus;u&quot;, aren&rsquo;t particularly meaningful
under <small>VMS,</small> and the values returned by these
tests reflect whatever your <small>CRTL</small>
&quot;stat()&quot; routine does to the equivalent bits in
the st_mode field. Finally, &quot;&minus;d&quot; returns
true if passed a device specification without an explicit
directory (e.g. &quot;DUA1:&quot;), as well as if passed a
directory.</p>

<p style="margin-left:17%; margin-top: 1em">There are
<small>DECC</small> feature logical names <small>AND
ODS&minus;5</small> volume attributes that also control what
values are returned for the date fields.</p>

<p style="margin-left:17%; margin-top: 1em">Note: Some
sites have reported problems when using the file-access
tests (&quot;&minus;r&quot;, &quot;&minus;w&quot;, and
&quot;&minus;x&quot;) on files accessed via
<small>DEC</small> &rsquo;s <small>DFS.</small>
Specifically, since <small>DFS</small> does not currently
provide access to the extended file header of files on
remote volumes, attempts to examine the <small>ACL</small>
fail, and the file tests will return false, with $!
indicating that the file does not exist. You can use
&quot;stat&quot; on these files, since that checks UIC-based
protection only, and then manually check the appropriate
bits, as defined by your C compiler&rsquo;s <i>stat.h</i>,
in the mode value it returns, if you need an approximation
of the file&rsquo;s protections.</p>

<p style="margin-left:11%;">backticks</p>

<p style="margin-left:17%;">Backticks create a subprocess,
and pass the enclosed string to it for execution as a
<small>DCL</small> command. Since the subprocess is created
directly via &quot;lib$spawn()&quot;, any valid
<small>DCL</small> command string may be specified.</p>

<p style="margin-left:11%;">binmode
<small>FILEHANDLE</small></p>

<p style="margin-left:17%;">The &quot;binmode&quot;
operator will attempt to insure that no translation of
carriage control occurs on input from or output to this
filehandle. Since this involves reopening the file and then
restoring its file position indicator, if this function
returns <small>FALSE,</small> the underlying filehandle may
no longer point to an open file, or may point to a different
position in the file than before &quot;binmode&quot; was
called.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;binmode&quot; is generally not necessary when using
normal filehandles; it is provided so that you can control
I/O to existing record-structured files when necessary. You
can also use the &quot;vmsfopen&quot; function in the
VMS::Stdio extension to gain finer control of I/O to files
and devices with different record structures.</p>

<p style="margin-left:11%;">crypt <small>PLAINTEXT,
USER</small></p>

<p style="margin-left:17%;">The &quot;crypt&quot; operator
uses the &quot;sys$hash_password&quot; system service to
generate the hashed representation of
<small>PLAINTEXT.</small> If <small>USER</small> is a valid
username, the algorithm and salt values are taken from that
user&rsquo;s <small>UAF</small> record. If it is not, then
the preferred algorithm and a salt of 0 are used. The
quadword encrypted value is returned as an 8&minus;character
string.</p>

<p style="margin-left:17%; margin-top: 1em">The value
returned by &quot;crypt&quot; may be compared against the
encrypted password from the <small>UAF</small> returned by
the &quot;getpw*&quot; functions, in order to authenticate
users. If you&rsquo;re going to do this, remember that the
encrypted password in the <small>UAF</small> was generated
using uppercase username and password strings; you&rsquo;ll
have to upcase the arguments to &quot;crypt&quot; to insure
that you&rsquo;ll get the proper value:</p>

<p style="margin-left:17%; margin-top: 1em">sub
validate_passwd { <br>
my($user,$passwd) = @_; <br>
my($pwdhash); <br>
if ( !($pwdhash = (getpwnam($user))[1]) || <br>
$pwdhash ne crypt(&quot;\U$passwd&quot;,&quot;\U$name&quot;)
) { <br>
intruder_alert($name); <br>
} <br>
return 1; <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>die</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;die&quot; will force the native <small>VMS</small>
exit status to be an <small>SS$_ABORT</small> code if
neither of the $! or $? status values are ones that would
cause the native status to be interpreted as being what
<small>VMS</small> classifies as <small>SEVERE_ERROR</small>
severity for <small>DCL</small> error handling.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">When
&quot;PERL_VMS_POSIX_EXIT&quot; is active (see
&quot;$?&quot; below), the native <small>VMS</small> exit
status value will have either one of the $! or $? or $^E or
the Unix value 255 encoded into it in a way that the
effective original value can be decoded by other programs
written in C, including Perl and the <small>GNV</small>
package. As per the normal non-VMS behavior of
&quot;die&quot; if either $! or $? are non-zero, one of
those values will be encoded into a native
<small>VMS</small> status value. If both of the Unix status
values are 0, and the $^E value is set one of
<small>ERROR</small> or <small>SEVERE_ERROR</small>
severity, then the $^E value will be used as the exit code
as is. If none of the above apply, the Unix value of 255
will be encoded into a native <small>VMS</small> exit status
value.</p>

<p style="margin-left:17%; margin-top: 1em">Please note a
significant difference in the behavior of &quot;die&quot; in
the &quot;PERL_VMS_POSIX_EXIT&quot; mode is that it does not
force a <small>VMS SEVERE_ERROR</small> status on exit. The
Unix exit values of 2 through 255 will be encoded in
<small>VMS</small> status values with severity levels of
<small>SUCCESS.</small> The Unix exit value of 1 will be
encoded in a <small>VMS</small> status value with a severity
level of <small>ERROR.</small> This is to be compatible with
how the <small>VMS C</small> library encodes these
values.</p>

<p style="margin-left:17%; margin-top: 1em">The minimum
severity level set by &quot;die&quot; in
&quot;PERL_VMS_POSIX_EXIT&quot; mode may be changed to be
<small>ERROR</small> or higher in the future depending on
the results of testing and further review.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;$?&quot; for a description of the encoding of the Unix
value to produce a native <small>VMS</small> status
containing it.</p>

<p style="margin-left:11%;">dump</p>

<p style="margin-left:17%;">Rather than causing Perl to
abort and dump core, the &quot;dump&quot; operator invokes
the <small>VMS</small> debugger. If you continue to execute
the Perl program under the debugger, control will be
transferred to the label specified as the argument to
&quot;dump&quot;, or, if no label was specified, back to the
beginning of the program. All other state of the program
(<i>e.g.</i> values of variables, open file handles) are not
affected by calling &quot;dump&quot;.</p>

<p style="margin-left:11%;">exec <small>LIST</small></p>

<p style="margin-left:17%;">A call to &quot;exec&quot; will
cause Perl to exit, and to invoke the command given as an
argument to &quot;exec&quot; via &quot;lib$do_command&quot;.
If the argument begins with &rsquo;@&rsquo; or
&rsquo;$&rsquo; (other than as part of a filespec), then it
is executed as a <small>DCL</small> command. Otherwise, the
first token on the command line is treated as the filespec
of an image to run, and an attempt is made to invoke it
(using <i>.Exe</i> and the process defaults to expand the
filespec) and pass the rest of &quot;exec&quot;&rsquo;s
argument to it as parameters. If the token has no file type,
and matches a file with null type, then an attempt is made
to determine whether the file is an executable image which
should be invoked using &quot;MCR&quot; or a text file which
should be passed to <small>DCL</small> as a command
procedure.</p>

<p style="margin-left:11%;">fork</p>

<p style="margin-left:17%;">While in principle the
&quot;fork&quot; operator could be implemented via (and with
the same rather severe limitations as) the
<small>CRTL</small> &quot;vfork()&quot; routine, and while
some internal support to do just that is in place, the
implementation has never been completed, making
&quot;fork&quot; currently unavailable. A true kernel
&quot;fork()&quot; is expected in a future version of
<small>VMS,</small> and the pseudo-fork based on interpreter
threads may be available in a future version of Perl on
<small>VMS</small> (see perlfork). In the meantime, use
&quot;system&quot;, backticks, or piped filehandles to
create subprocesses.</p>

<p style="margin-left:11%;">getpwent <br>
getpwnam <br>
getpwuid</p>

<p style="margin-left:17%;">These operators obtain the
information described in perlfunc, if you have the
privileges necessary to retrieve the named user&rsquo;s
<small>UAF</small> information via &quot;sys$getuai&quot;.
If not, then only the $name, $uid, and $gid items are
returned. The $dir item contains the login directory in
<small>VMS</small> syntax, while the $comment item contains
the login directory in Unix syntax. The $gcos item contains
the owner field from the <small>UAF</small> record. The
$quota item is not used.</p>

<p style="margin-left:11%;">gmtime</p>

<p style="margin-left:17%;">The &quot;gmtime&quot; operator
will function properly if you have a working
<small>CRTL</small> &quot;gmtime()&quot; routine, or if the
logical name <small>SYS$TIMEZONE_DIFFERENTIAL</small> is
defined as the number of seconds which must be added to
<small>UTC</small> to yield local time. (This logical name
is defined automatically if you are running a version of
<small>VMS</small> with built-in <small>UTC</small>
support.) If neither of these cases is true, a warning
message is printed, and &quot;undef&quot; is returned.</p>

<p style="margin-left:11%;">kill</p>

<p style="margin-left:17%;">In most cases, &quot;kill&quot;
is implemented via the undocumented system service $SIGPRC,
which has the same calling sequence as $FORCEX, but throws
an exception in the target process rather than forcing it to
call $EXIT. Generally speaking, &quot;kill&quot; follows the
behavior of the <small>CRTL</small> &rsquo;s
&quot;kill()&quot; function, but unlike that function can be
called from within a signal handler. Also, unlike the
&quot;kill&quot; in some versions of the
<small>CRTL,</small> Perl&rsquo;s &quot;kill&quot; checks
the validity of the signal passed in and returns an error
rather than attempting to send an unrecognized signal.</p>

<p style="margin-left:17%; margin-top: 1em">Also, negative
signal values don&rsquo;t do anything special under
<small>VMS</small> ; they&rsquo;re just converted to the
corresponding positive value.</p>

<p style="margin-left:11%;">qx//</p>

<p style="margin-left:17%;">See the entry on
&quot;backticks&quot; above.</p>

<p style="margin-left:11%;">select (system call)</p>

<p style="margin-left:17%;">If Perl was not built with
socket support, the system call version of
&quot;select&quot; is not available at all. If socket
support is present, then the system call version of
&quot;select&quot; functions only for file descriptors
attached to sockets. It will not provide information about
regular files or pipes, since the <small>CRTL</small>
&quot;select()&quot; routine does not provide this
functionality.</p>

<p style="margin-left:11%;">stat <small>EXPR</small></p>

<p style="margin-left:17%;">Since <small>VMS</small> keeps
track of files according to a different scheme than Unix,
it&rsquo;s not really possible to represent the file&rsquo;s
<small>ID</small> in the &quot;st_dev&quot; and
&quot;st_ino&quot; fields of a &quot;struct stat&quot;. Perl
tries its best, though, and the values it uses are pretty
unlikely to be the same for two different files. We
can&rsquo;t guarantee this, though, so caveat scriptor.</p>

<p style="margin-left:11%;">system <small>LIST</small></p>

<p style="margin-left:17%;">The &quot;system&quot; operator
creates a subprocess, and passes its arguments to the
subprocess for execution as a <small>DCL</small> command.
Since the subprocess is created directly via
&quot;lib$spawn()&quot;, any valid <small>DCL</small>
command string may be specified. If the string begins with
&rsquo;@&rsquo;, it is treated as a <small>DCL</small>
command unconditionally. Otherwise, if the first token
contains a character used as a delimiter in file
specification (e.g. &quot;:&quot; or &quot;]&quot;), an
attempt is made to expand it using a default type of
<i>.Exe</i> and the process defaults, and if successful, the
resulting file is invoked via &quot;MCR&quot;. This allows
you to invoke an image directly simply by passing the file
specification to &quot;system&quot;, a common Unixish idiom.
If the token has no file type, and matches a file with null
type, then an attempt is made to determine whether the file
is an executable image which should be invoked using
&quot;MCR&quot; or a text file which should be passed to
<small>DCL</small> as a command procedure.</p>

<p style="margin-left:17%; margin-top: 1em">If
<small>LIST</small> consists of the empty string,
&quot;system&quot; spawns an interactive <small>DCL</small>
subprocess, in the same fashion as typing
<b><small>SPAWN</small></b> at the <small>DCL</small>
prompt.</p>

<p style="margin-left:17%; margin-top: 1em">Perl waits for
the subprocess to complete before continuing execution in
the current process. As described in perlfunc, the return
value of &quot;system&quot; is a fake &quot;status&quot;
which follows <small>POSIX</small> semantics unless the
pragma &quot;use vmsish 'status'&quot; is in effect; see the
description of $? in this document for more detail.</p>

<p style="margin-left:11%;">time</p>

<p style="margin-left:17%;">The value returned by
&quot;time&quot; is the offset in seconds from
01&minus;JAN&minus;1970 00:00:00 (just like the
<small>CRTL</small> &rsquo;s <b>times()</b> routine), in
order to make life easier for code coming in from the
POSIX/Unix world.</p>

<p style="margin-left:11%;">times</p>

<p style="margin-left:17%;">The array returned by the
&quot;times&quot; operator is divided up according to the
same rules the <small>CRTL</small> &quot;times()&quot;
routine. Therefore, the &quot;system time&quot; elements
will always be 0, since there is no difference between
&quot;user time&quot; and &quot;system&quot; time under
<small>VMS,</small> and the time accumulated by a subprocess
may or may not appear separately in the &quot;child
time&quot; field, depending on whether &quot;times()&quot;
keeps track of subprocesses separately. Note especially that
the <small>VAXCRTL</small> (at least) keeps track only of
subprocesses spawned using &quot;fork()&quot; and
&quot;exec()&quot;; it will not accumulate the times of
subprocesses spawned via pipes, &quot;system()&quot;, or
backticks.</p>

<p style="margin-left:11%;">unlink <small>LIST</small></p>

<p style="margin-left:17%;">&quot;unlink&quot; will delete
the highest version of a file only; in order to delete all
versions, you need to say</p>

<p style="margin-left:17%; margin-top: 1em">1 while unlink
LIST;</p>

<p style="margin-left:17%; margin-top: 1em">You may need to
make this change to scripts written for a Unix system which
expect that after a call to &quot;unlink&quot;, no files
with the names passed to &quot;unlink&quot; will exist.
(Note: This can be changed at compile time; if you &quot;use
Config&quot; and $Config{'d_unlink_all_versions'} is
&quot;define&quot;, then &quot;unlink&quot; will delete all
versions of a file on the first call.)</p>


<p style="margin-left:17%; margin-top: 1em">&quot;unlink&quot;
will delete a file if at all possible, even if it requires
changing file protection (though it won&rsquo;t try to
change the protection of the parent directory). You can tell
whether you&rsquo;ve got explicit delete access to a file by
using the &quot;VMS::Filespec::candelete&quot; operator. For
instance, in order to delete only files to which you have
delete access, you could say something like</p>

<p style="margin-left:17%; margin-top: 1em">sub safe_unlink
{ <br>
my($file,$num); <br>
foreach $file (@_) { <br>
next unless VMS::Filespec::candelete($file); <br>
$num += unlink $file; <br>
} <br>
$num; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">(or you could
just use &quot;VMS::Stdio::remove&quot;, if you&rsquo;ve
installed the VMS::Stdio extension distributed with Perl).
If &quot;unlink&quot; has to change the file protection to
delete the file, and you interrupt it in midstream, the file
may be left intact, but with a changed <small>ACL</small>
allowing you delete access.</p>

<p style="margin-left:17%; margin-top: 1em">This behavior
of &quot;unlink&quot; is to be compatible with
<small>POSIX</small> behavior and not traditional
<small>VMS</small> behavior.</p>

<p style="margin-left:11%;">utime <small>LIST</small></p>

<p style="margin-left:17%;">This operator changes only the
modification time of the file ( <small>VMS</small> revision
date) on <small>ODS&minus;2</small> volumes and
<small>ODS&minus;5</small> volumes without access dates
enabled. On <small>ODS&minus;5</small> volumes with access
dates enabled, the true access time is modified.</p>

<p style="margin-left:11%;">waitpid
<small>PID,FLAGS</small></p>

<p style="margin-left:17%;">If <small>PID</small> is a
subprocess started by a piped &quot;open()&quot; (see open),
&quot;waitpid&quot; will wait for that subprocess, and
return its final status value in $?. If <small>PID</small>
is a subprocess created in some other way (e.g. SPAWNed
before Perl was invoked), &quot;waitpid&quot; will simply
check once per second whether the process has completed, and
return when it has. (If <small>PID</small> specifies a
process that isn&rsquo;t a subprocess of the current
process, and you invoked Perl with the &quot;&minus;w&quot;
switch, a warning will be issued.)</p>

<p style="margin-left:17%; margin-top: 1em">Returns
<small>PID</small> on success, &minus;1 on error. The
<small>FLAGS</small> argument is ignored in all cases.</p>

<h2>Perl variables
<a name="Perl variables"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
VMS-specific information applies to the indicated
&quot;special&quot; Perl variables, in addition to the
general information in perlvar. Where there is a conflict,
this information takes precedence. <br>
%ENV</p>

<p style="margin-left:17%;">The operation of the %ENV array
depends on the translation of the logical name
<i><small>PERL_ENV_TABLES</small></i> . If defined, it
should be a search list, each element of which specifies a
location for %ENV elements. If you tell Perl to read or set
the element &quot;$ENV{&quot;<i>name</i>&quot;}&quot;, then
Perl uses the translations of
<i><small>PERL_ENV_TABLES</small></i> as follows:
<small><br>
CRTL_ENV</small></p>

<p style="margin-left:23%;">This string tells Perl to
consult the <small>CRTL</small> &rsquo;s internal
&quot;environ&quot; array of key-value pairs, using
<i>name</i> as the key. In most cases, this contains only a
few keys, but if Perl was invoked via the C
&quot;exec[lv]e()&quot; function, as is the case for some
embedded Perl applications or when running under a shell
such as <small>GNV</small> bash, the &quot;environ&quot;
array may have been populated by the calling program.</p>

<p style="margin-left:17%;">CLISYM_[ <small>LOCAL</small>
]</p>

<p style="margin-left:23%;">A string beginning with
&quot;CLISYM_&quot;tells Perl to consult the
<small>CLI</small> &rsquo;s symbol tables, using <i>name</i>
as the name of the symbol. When reading an element of %ENV,
the local symbol table is scanned first, followed by the
global symbol table.. The characters following
&quot;CLISYM_&quot; are significant when an element of %ENV
is set or deleted: if the complete string is
&quot;CLISYM_LOCAL&quot;, the change is made in the local
symbol table; otherwise the global symbol table is
changed.</p>

<p style="margin-left:17%;">Any other string</p>

<p style="margin-left:23%;">If an element of
<i><small>PERL_ENV_TABLES</small></i> translates to any
other string, that string is used as the name of a logical
name table, which is consulted using <i>name</i> as the
logical name. The normal search order of access modes is
used.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>PERL_ENV_TABLES</small></i>
is translated once when Perl starts up; any changes you make
while Perl is running do not affect the behavior of %ENV. If
<i><small>PERL_ENV_TABLES</small></i> is not defined, then
Perl defaults to consulting first the logical name tables
specified by <i><small>LNM$FILE_DEV</small></i> , and then
the <small>CRTL</small> &quot;environ&quot; array. This
default order is reversed when the logical name
<i><small>GNV$UNIX_SHELL</small></i> is defined, such as
when running under <small>GNV</small> bash.</p>

<p style="margin-left:17%; margin-top: 1em">For operations
on %ENV entries based on logical names or <small>DCL</small>
symbols, the key string is treated as if it were entirely
uppercase, regardless of the case actually specified in the
Perl expression. Entries in %ENV based on the
<small>CRTL</small> &rsquo;s environ array preserve the case
of the key string when stored, and lookups are case
sensitive.</p>

<p style="margin-left:17%; margin-top: 1em">When an element
of %ENV is read, the locations to which
<i><small>PERL_ENV_TABLES</small></i> points are checked in
order, and the value obtained from the first successful
lookup is returned. If the name of the %ENV element contains
a semi-colon, it and any characters after it are removed.
These are ignored when the <small>CRTL</small>
&quot;environ&quot; array or a <small>CLI</small> symbol
table is consulted. However, the name is looked up in a
logical name table, the suffix after the semi-colon is
treated as the translation index to be used for the lookup.
This lets you look up successive values for search list
logical names. For instance, if you say</p>

<p style="margin-left:17%; margin-top: 1em">$ Define STORY
once,upon,a,time,there,was <br>
$ perl &minus;e &quot;for ($i = 0; $i &lt;= 6; $i++) &quot;
&minus; <br>
_$ &minus;e &quot;{ print $ENV{'story;'.$i},' '}&quot;</p>

<p style="margin-left:17%; margin-top: 1em">Perl will print
&quot;ONCE UPON A TIME THERE WAS&quot;, assuming, of course,
that <i><small>PERL_ENV_TABLES</small></i> is set up so that
the logical name &quot;story&quot; is found, rather than a
<small>CLI</small> symbol or <small>CRTL</small>
&quot;environ&quot; element with the same name.</p>

<p style="margin-left:17%; margin-top: 1em">When an element
of %ENV is set to a defined string, the corresponding
definition is made in the location to which the first
translation of <i><small>PERL_ENV_TABLES</small></i> points.
If this causes a logical name to be created, it is defined
in supervisor mode. (The same is done if an existing logical
name was defined in executive or kernel mode; an existing
user or supervisor mode logical name is reset to the new
value.) If the value is an empty string, the logical
name&rsquo;s translation is defined as a single
&quot;NUL&quot; ( <small>ASCII</small> &quot;\0&quot;)
character, since a logical name cannot translate to a
zero-length string. (This restriction does not apply to
<small>CLI</small> symbols or <small>CRTL</small>
&quot;environ&quot; values; they are set to the empty
string.)</p>

<p style="margin-left:17%; margin-top: 1em">When an element
of %ENV is set to &quot;undef&quot;, the element is looked
up as if it were being read, and if it is found, it is
deleted. (An item &quot;deleted&quot; from the
<small>CRTL</small> &quot;environ&quot; array is set to the
empty string.) Using &quot;delete&quot; to remove an element
from %ENV has a similar effect, but after the element is
deleted, another attempt is made to look up the element, so
an inner-mode logical name or a name in another location
will replace the logical name just deleted. In either case,
only the first value found searching
<small>PERL_ENV_TABLES</small> is altered. It is not
possible at present to define a search list logical name via
%ENV.</p>

<p style="margin-left:17%; margin-top: 1em">The element
$ENV{DEFAULT} is special: when read, it returns Perl&rsquo;s
current default device and directory, and when set, it
resets them, regardless of the definition of
<i><small>PERL_ENV_TABLES</small></i> . It cannot be cleared
or deleted; attempts to do so are silently ignored.</p>

<p style="margin-left:17%; margin-top: 1em">Note that if
you want to pass on any elements of the C&minus;local
environ array to a subprocess which isn&rsquo;t started by
fork/exec, or isn&rsquo;t running a C program, you can
&quot;promote&quot; them to logical names in the current
process, which will then be inherited by all subprocesses,
by saying</p>

<p style="margin-left:17%; margin-top: 1em">foreach my $key
(qw[C&minus;local keys you want promoted]) { <br>
my $temp = $ENV{$key}; # read from C&minus;local array <br>
$ENV{$key} = $temp; # and define as logical name <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">(You
can&rsquo;t just say $ENV{$key} = $ENV{$key}, since the Perl
optimizer is smart enough to elide the expression.)</p>

<p style="margin-left:17%; margin-top: 1em">Don&rsquo;t try
to clear %ENV by saying &quot;%ENV = ();&quot;, it will
throw a fatal error. This is equivalent to doing the
following from <small>DCL:</small></p>

<p style="margin-left:17%; margin-top: 1em">DELETE/LOGICAL
*</p>

<p style="margin-left:17%; margin-top: 1em">You can imagine
how bad things would be if, for example, the
<small>SYS$MANAGER</small> or <small>SYS$SYSTEM</small>
logical names were deleted.</p>

<p style="margin-left:17%; margin-top: 1em">At present, the
first time you iterate over %ENV using &quot;keys&quot;, or
&quot;values&quot;, you will incur a time penalty as all
logical names are read, in order to fully populate %ENV.
Subsequent iterations will not reread logical names, so they
won&rsquo;t be as slow, but they also won&rsquo;t reflect
any changes to logical name tables caused by other
programs.</p>

<p style="margin-left:17%; margin-top: 1em">You do need to
be careful with the logical names representing
process-permanent files, such as &quot;SYS$INPUT&quot; and
&quot;SYS$OUTPUT&quot;. The translations for these logical
names are prepended with a two-byte binary value (0x1B 0x00)
that needs to be stripped off if you want to use it. (In
previous versions of Perl it wasn&rsquo;t possible to get
the values of these logical names, as the null byte acted as
an end-of-string marker)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>$!</p></td>
<td width="2%"></td>
<td width="83%">


<p>The string value of $! is that returned by the
<small>CRTL</small> &rsquo;s <b>strerror()</b> function, so
it will include the <small>VMS</small> message for
VMS-specific errors. The numeric value of $! is the value of
&quot;errno&quot;, except if errno is
<small>EVMSERR,</small> in which case $! contains the value
of vaxc$errno. Setting $! always sets errno to the value
specified. If this value is <small>EVMSERR,</small> it also
sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string
value of $! won&rsquo;t reflect the <small>VMS</small> error
message from before $! was set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>$^E</p></td>
<td width="2%"></td>
<td width="83%">


<p>This variable provides direct access to
<small>VMS</small> status values in vaxc$errno, which are
often more specific than the generic Unix-style error
messages in $!. Its numeric value is the value of
vaxc$errno, and its string value is the corresponding
<small>VMS</small> message string, as retrieved by
sys$<b>getmsg()</b>. Setting $^E sets vaxc$errno to the
value specified.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">While Perl
attempts to keep the vaxc$errno value to be current, if
errno is not <small>EVMSERR,</small> it may not be from the
current operation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">$?</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">The &quot;status value&quot;
returned in $? is synthesized from the actual exit status of
the subprocess in a way that approximates
<small>POSIX</small> <b>wait</b>(5) semantics, in order to
allow Perl programs to portably test for successful
completion of subprocesses. The low order 8 bits of $? are
always 0 under <small>VMS,</small> since the termination
status of a process may or may not have been generated by an
exception.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The next 8 bits
contain the termination status of the program.</p>

<p style="margin-left:17%; margin-top: 1em">If the child
process follows the convention of C programs compiled with
the _POSIX_EXIT macro set, the status value will contain the
actual value of 0 to 255 returned by that program on a
normal exit.</p>

<p style="margin-left:17%; margin-top: 1em">With the
_POSIX_EXIT macro set, the Unix exit value of zero is
represented as a <small>VMS</small> native status of 1, and
the Unix values from 2 to 255 are encoded by the
equation:</p>

<p style="margin-left:17%; margin-top: 1em">VMS_status =
0x35a000 + (unix_value * 8) + 1.</p>

<p style="margin-left:17%; margin-top: 1em">And in the
special case of Unix value 1 the encoding is:</p>

<p style="margin-left:17%; margin-top: 1em">VMS_status =
0x35a000 + 8 + 2 + 0x10000000.</p>

<p style="margin-left:17%; margin-top: 1em">For other
termination statuses, the severity portion of the
subprocess&rsquo;s exit status is used: if the severity was
success or informational, these bits are all 0; if the
severity was warning, they contain a value of 1; if the
severity was error or fatal error, they contain the actual
severity bits, which turns out to be a value of 2 for error
and 4 for severe_error. Fatal is another term for the
severe_error status.</p>

<p style="margin-left:17%; margin-top: 1em">As a result, $?
will always be zero if the subprocess&rsquo;s exit status
indicated successful completion, and non-zero if a warning
or error occurred or a program compliant with encoding
_POSIX_EXIT values was run and set a status.</p>

<p style="margin-left:17%; margin-top: 1em">How can you
tell the difference between a non-zero status that is the
result of a <small>VMS</small> native error status or an
encoded Unix status? You can not unless you look at the
${^CHILD_ERROR_NATIVE} value. The ${^CHILD_ERROR_NATIVE}
value returns the actual <small>VMS</small> status value and
check the severity bits. If the severity bits are equal to
1, then if the numeric value for $? is between 2 and 255 or
0, then $? accurately reflects a value passed back from a
Unix application. If $? is 1, and the severity bits indicate
a <small>VMS</small> error (2), then $? is from a Unix
application exit value.</p>

<p style="margin-left:17%; margin-top: 1em">In practice,
Perl scripts that call programs that return _POSIX_EXIT type
status values will be expecting those values, and programs
that call traditional <small>VMS</small> programs will
either be expecting the previous behavior or just checking
for a non-zero status.</p>

<p style="margin-left:17%; margin-top: 1em">And success is
always the value 0 in all behaviors.</p>

<p style="margin-left:17%; margin-top: 1em">When the actual
<small>VMS</small> termination status of the child is an
error, internally the $! value will be set to the closest
Unix errno value to that error so that Perl scripts that
test for error messages will see the expected Unix style
error message instead of a <small>VMS</small> message.</p>

<p style="margin-left:17%; margin-top: 1em">Conversely,
when setting $? in an <small>END</small> block, an attempt
is made to convert the <small>POSIX</small> value into a
native status intelligible to the operating system upon
exiting Perl. What this boils down to is that setting $? to
zero results in the generic success value
<small>SS$_NORMAL,</small> and setting $? to a non-zero
value results in the generic failure status
<small>SS$_ABORT.</small> See also &quot;exit&quot; in
perlport.</p>

<p style="margin-left:17%; margin-top: 1em">With the
&quot;PERL_VMS_POSIX_EXIT&quot; logical name defined as
&quot; <small>ENABLE&quot;,</small> setting $? will cause
the new value to be encoded into $^E so that either the
original parent or child exit status values <br>
0 to 255 can be automatically recovered by C programs
expecting _POSIX_EXIT behavior. If both a parent and a child
exit value are non-zero, then it will be assumed that this
is actually a <small>VMS</small> native status value to be
passed through. The special value of 0xFFFF is almost a
<small>NOOP</small> as it will cause the current native
<small>VMS</small> status in the C library to become the
current native Perl <small>VMS</small> status, and is
handled this way as it is known to not be a valid native
<small>VMS</small> status value. It is recommend that only
values in the range of normal Unix parent or child status
numbers, 0 to 255 are used.</p>

<p style="margin-left:17%; margin-top: 1em">The pragma
&quot;use vmsish 'status'&quot; makes $? reflect the actual
<small>VMS</small> exit status instead of the default
emulation of <small>POSIX</small> status described above.
This pragma also disables the conversion of non-zero values
to <small>SS$_ABORT</small> when setting $? in an
<small>END</small> block (but zero will still be converted
to <small>SS$_NORMAL</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">Do not use the
pragma &quot;use vmsish 'status'&quot; with
&quot;PERL_VMS_POSIX_EXIT&quot; enabled, as they are at
times requesting conflicting actions and the consequence of
ignoring this advice will be undefined to allow future
improvements in the <small>POSIX</small> exit handling.</p>

<p style="margin-left:17%; margin-top: 1em">In general,
with &quot;PERL_VMS_POSIX_EXIT&quot; enabled, more detailed
information will be available in the exit status for
<small>DCL</small> scripts or other native
<small>VMS</small> tools, and will give the expected
information for Posix programs. It has not been made the
default in order to preserve backward compatibility.</p>

<p style="margin-left:17%; margin-top: 1em">N.B. Setting
&quot;DECC$FILENAME_UNIX_REPORT&quot; implicitly enables
&quot;PERL_VMS_POSIX_EXIT&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">$|</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Setting $| for an I/O stream
causes data to be flushed all the way to disk on each write
(<i>i.e.</i> not just to the underlying <small>RMS</small>
buffers for a file). In other words, it&rsquo;s equivalent
to calling <b>fflush()</b> and <b>fsync()</b> from C.</p></td></tr>
</table>

<h2>Standard modules with VMS-specific differences
<a name="Standard modules with VMS-specific differences"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>SDBM_File</b>
<br>
SDBM_File works properly on <small>VMS.</small> It has,
however, one minor difference. The database directory file
created has a <i>.sdbm_dir</i> extension rather than a
<i>.dir</i> extension. <i>.dir</i> files are
<small>VMS</small> filesystem directory files, and using
them for other purposes could cause unacceptable
problems.</p>

<h2>Revision date
<a name="Revision date"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please see the
git repository for revision history.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Charles Bailey
bailey@cor.newman.upenn.edu Craig Berry craigberry@mac.com
Dan Sugalski dan@sidhe.org John Malmberg wb8tyw@qsl.net</p>
<hr>
</body>
</html>
