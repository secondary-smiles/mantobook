<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLPODSPEC</title>

</head>
<body>
<h1>perlpodspec</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlpodspec
&minus; Plain Old Documentation: format specification and
notes</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
is detailed notes on the Pod markup language. Most people
will only have to read perlpod to know how to write in Pod,
but this document may answer some incidental questions to do
with parsing and rendering Pod.</p>

<p style="margin-left:11%; margin-top: 1em">In this
document, &quot;must&quot; / &quot;must not&quot;,
&quot;should&quot; / &quot;should not&quot;, and
&quot;may&quot; have their conventional (cf. <small>RFC
2119</small> ) meanings: &quot;X must do Y&quot; means that
if X doesn&rsquo;t do Y, it&rsquo;s against this
specification, and should really be fixed. &quot;X should do
Y&quot; means that it&rsquo;s recommended, but X may fail to
do Y, if there&rsquo;s a good reason. &quot;X may do Y&quot;
is merely a note that X can do Y at will (although it is up
to the reader to detect any connotation of &quot;and I think
it would be <i>nice</i> if X did Y&quot; versus &quot;it
wouldn&rsquo;t really <i>bother</i> me if X did
Y&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Notably, when I
say &quot;the parser should do Y&quot;, the parser may fail
to do Y, if the calling application explicitly requests that
the parser <i>not</i> do Y. I often phrase this as &quot;the
parser should, by default, do Y.&quot; This doesn&rsquo;t
<i>require</i> the parser to provide an option for turning
off whatever feature Y is (like expanding tabs in verbatim
paragraphs), although it implicates that such an option
<i>may</i> be provided.</p>

<h2>Pod Definitions
<a name="Pod Definitions"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Pod is embedded
in files, typically Perl source files, although you can
write a file that&rsquo;s nothing but Pod.</p>

<p style="margin-left:11%; margin-top: 1em">A <b>line</b>
in a file consists of zero or more non-newline characters,
terminated by either a newline or the end of the file.</p>

<p style="margin-left:11%; margin-top: 1em">A <b>newline
sequence</b> is usually a platform-dependent concept, but
Pod parsers should understand it to mean any of
<small>CR</small> ( <small>ASCII 13</small> ),
<small>LF</small> ( <small>ASCII 10</small> ), or a
<small>CRLF</small> ( <small>ASCII 13</small> followed
immediately by <small>ASCII 10</small> ), in addition to any
other system-specific meaning. The first
<small>CR/CRLF/LF</small> sequence in the file may be used
as the basis for identifying the newline sequence for
parsing the rest of the file.</p>

<p style="margin-left:11%; margin-top: 1em">A <b>blank
line</b> is a line consisting entirely of zero or more
spaces ( <small>ASCII 32</small> ) or tabs ( <small>ASCII
9</small> ), and terminated by a newline or end-of-file. A
<b>non-blank line</b> is a line containing one or more
characters other than space or tab (and terminated by a
newline or end-of-file).</p>

<p style="margin-left:11%; margin-top: 1em">(<i>Note:</i>
Many older Pod parsers did not accept a line consisting of
spaces/tabs and then a newline as a blank line. The only
lines they considered blank were lines consisting of <i>no
characters at all</i>, terminated by a newline.)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Whitespace</b>
is used in this document as a blanket term for spaces, tabs,
and newline sequences. (By itself, this term usually refers
to literal whitespace. That is, sequences of whitespace
characters in Pod source, as opposed to
&quot;E&lt;32&gt;&quot;, which is a formatting code that
<i>denotes</i> a whitespace character.)</p>

<p style="margin-left:11%; margin-top: 1em">A <b>Pod
parser</b> is a module meant for parsing Pod (regardless of
whether this involves calling callbacks or building a parse
tree or directly formatting it). A <b>Pod formatter</b> (or
<b>Pod translator</b>) is a module or program that converts
Pod to some other format ( <small>HTML,</small> plaintext,
TeX, PostScript, <small>RTF</small> ). A <b>Pod
processor</b> might be a formatter or translator, or might
be a program that does something else with the Pod (like
counting words, scanning for index points, etc.).</p>

<p style="margin-left:11%; margin-top: 1em">Pod content is
contained in <b>Pod blocks</b>. A Pod block starts with a
line that matches &quot;m/\A=[a&minus;zA&minus;Z]/&quot;,
and continues up to the next line that matches
&quot;m/\A=cut/&quot; or up to the end of the file if there
is no &quot;m/\A=cut/&quot; line.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
parser is not expected to distinguish between something that
looks like pod, but is in a quoted string, such as a here
document.</p>

<p style="margin-left:11%; margin-top: 1em">Within a Pod
block, there are <b>Pod paragraphs</b>. A Pod paragraph
consists of non-blank lines of text, separated by one or
more blank lines.</p>

<p style="margin-left:11%; margin-top: 1em">For purposes of
Pod processing, there are four types of paragraphs in a Pod
block:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A command paragraph (also called a
&quot;directive&quot;). The first line of this paragraph
must match &quot;m/\A=[a&minus;zA&minus;Z]/&quot;. Command
paragraphs are typically one line, as in:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">=head1 NOTES
<br>
=item *</p>

<p style="margin-left:17%; margin-top: 1em">But they may
span several (non-blank) lines:</p>

<p style="margin-left:17%; margin-top: 1em">=for comment
<br>
Hm, I wonder what it would look like if <br>
you tried to write a BNF for Pod from this. <br>
=head3 Dr. Strangelove, or: How I Learned to <br>
Stop Worrying and Love the Bomb</p>

<p style="margin-left:17%; margin-top: 1em"><i>Some</i>
command paragraphs allow formatting codes in their content
(i.e., after the part that matches
&quot;m/\A=[a&minus;zA&minus;Z]\S*\s*/&quot;), as in:</p>

<p style="margin-left:17%; margin-top: 1em">=head1 Did You
Remember to C&lt;use strict;&gt;?</p>

<p style="margin-left:17%; margin-top: 1em">In other words,
the Pod processing handler for &quot;head1&quot; will apply
the same processing to &quot;Did You Remember to C&lt;use
strict;&gt;?&quot; that it would to an ordinary paragraph
(i.e., formatting codes like &quot;C&lt;...&gt;&quot;) are
parsed and presumably formatted appropriately, and
whitespace in the form of literal spaces and/or tabs is not
significant.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">A <b>verbatim paragraph</b>. The
first line of this paragraph must be a literal space or tab,
and this paragraph must not be inside a &quot;=begin
<i>identifier</i>&quot;, ... &quot;=end
<i>identifier</i>&quot; sequence unless
&quot;<i>identifier</i>&quot; begins with a colon
(&quot;:&quot;). That is, if a paragraph starts with a
literal space or tab, but <i>is</i> inside a &quot;=begin
<i>identifier</i>&quot;, ... &quot;=end
<i>identifier</i>&quot; region, then it&rsquo;s a data
paragraph, unless &quot;<i>identifier</i>&quot; begins with
a colon.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Whitespace
<i>is</i> significant in verbatim paragraphs (although, in
processing, tabs are probably expanded).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">An <b>ordinary paragraph</b>. A
paragraph is an ordinary paragraph if its first line matches
neither &quot;m/\A=[a&minus;zA&minus;Z]/&quot; nor
&quot;m/\A[ \t]/&quot;, <i>and</i> if it&rsquo;s not inside
a &quot;=begin <i>identifier</i>&quot;, ... &quot;=end
<i>identifier</i>&quot; sequence unless
&quot;<i>identifier</i>&quot; begins with a colon
(&quot;:&quot;).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A <b>data paragraph</b>. This is a paragraph that
<i>is</i> inside a &quot;=begin <i>identifier</i>&quot; ...
&quot;=end <i>identifier</i>&quot; sequence where
&quot;<i>identifier</i>&quot; does <i>not</i> begin with a
literal colon (&quot;:&quot;). In some sense, a data
paragraph is not part of Pod at all (i.e., effectively
it&rsquo;s &quot;out-of-band&quot;), since it&rsquo;s not
subject to most kinds of Pod parsing; but it is specified
here, since Pod parsers need to be able to call an event for
it, or store it in some form in a parse tree, or at least
just parse <i>around</i> it.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">For example:
consider the following paragraphs:</p>

<p style="margin-left:11%; margin-top: 1em"># &lt;&minus;
that's the 0th column <br>
=head1 Foo <br>
Stuff <br>
$foo&minus;&gt;bar <br>
=cut</p>

<p style="margin-left:11%; margin-top: 1em">Here,
&quot;=head1 Foo&quot; and &quot;=cut&quot; are command
paragraphs because the first line of each matches
&quot;m/\A=[a&minus;zA&minus;Z]/&quot;.
&quot;<i>[space][space]</i>$foo&minus;&gt;bar&quot; is a
verbatim paragraph, because its first line starts with a
literal whitespace character (and there&rsquo;s no
&quot;=begin&quot;...&quot;=end&quot; region around).</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;=begin <i>identifier</i>&quot; ... &quot;=end
<i>identifier</i>&quot; commands stop paragraphs that they
surround from being parsed as ordinary or verbatim
paragraphs, if <i>identifier</i> doesn&rsquo;t begin with a
colon. This is discussed in detail in the section
&quot;About Data Paragraphs and &quot;=begin/=end&quot;
Regions&quot;.</p>

<h2>Pod Commands
<a name="Pod Commands"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section is
intended to supplement and clarify the discussion in
&quot;Command Paragraph&quot; in perlpod. These are the
currently recognized Pod commands: <br>
&quot;=head1&quot;, &quot;=head2&quot;, &quot;=head3&quot;,
&quot;=head4&quot;, &quot;=head5&quot;,
&quot;=head6&quot;</p>

<p style="margin-left:17%;">This command indicates that the
text in the remainder of the paragraph is a heading. That
text may contain formatting codes. Examples:</p>

<p style="margin-left:17%; margin-top: 1em">=head1 Object
Attributes <br>
=head3 What B&lt;Not&gt; to Do!</p>

<p style="margin-left:17%; margin-top: 1em">Both
&quot;=head5&quot; and &quot;=head6&quot; were added in 2020
and might not be supported on all Pod parsers. Pod::Simple
3.41 was released on October 2020 and supports both of these
providing support for all Pod::Simple&minus;based Pod
parsers.</p>

<p style="margin-left:11%;">&quot;=pod&quot;</p>

<p style="margin-left:17%;">This command indicates that
this paragraph begins a Pod block. (If we are already in the
middle of a Pod block, this command has no effect at all.)
If there is any text in this command paragraph after
&quot;=pod&quot;, it must be ignored. Examples:</p>

<p style="margin-left:17%; margin-top: 1em">=pod <br>
This is a plain Pod paragraph. <br>
=pod This text is ignored.</p>

<p style="margin-left:11%;">&quot;=cut&quot;</p>

<p style="margin-left:17%;">This command indicates that
this line is the end of this previously started Pod block.
If there is any text after &quot;=cut&quot; on the line, it
must be ignored. Examples:</p>

<p style="margin-left:17%; margin-top: 1em">=cut <br>
=cut The documentation ends here. <br>
=cut <br>
# This is the first line of program text. <br>
sub foo { # This is the second.</p>

<p style="margin-left:17%; margin-top: 1em">It is an error
to try to <i>start</i> a Pod block with a &quot;=cut&quot;
command. In that case, the Pod processor must halt parsing
of the input file, and must by default emit a warning.</p>

<p style="margin-left:11%;">&quot;=over&quot;</p>

<p style="margin-left:17%;">This command indicates that
this is the start of a list/indent region. If there is any
text following the &quot;=over&quot;, it must consist of
only a nonzero positive numeral. The semantics of this
numeral is explained in the &quot;About =over...=back
Regions&quot; section, further below. Formatting codes are
not expanded. Examples:</p>

<p style="margin-left:17%; margin-top: 1em">=over 3 <br>
=over 3.5 <br>
=over</p>

<p style="margin-left:11%;">&quot;=item&quot;</p>

<p style="margin-left:17%;">This command indicates that an
item in a list begins here. Formatting codes are processed.
The semantics of the (optional) text in the remainder of
this paragraph are explained in the &quot;About
=over...=back Regions&quot; section, further below.
Examples:</p>

<p style="margin-left:17%; margin-top: 1em">=item <br>
=item * <br>
=item * <br>
=item 14 <br>
=item 3. <br>
=item C&lt;&lt; $thing&minus;&gt;stuff(I&lt;dodad&gt;)
&gt;&gt; <br>
=item For transporting us beyond seas to be tried for
pretended <br>
offenses <br>
=item He is at this time transporting large armies of
foreign <br>
mercenaries to complete the works of death, desolation and
<br>
tyranny, already begun with circumstances of cruelty and
perfidy <br>
scarcely paralleled in the most barbarous ages, and totally
<br>
unworthy the head of a civilized nation.</p>

<p style="margin-left:11%;">&quot;=back&quot;</p>

<p style="margin-left:17%;">This command indicates that
this is the end of the region begun by the most recent
&quot;=over&quot; command. It permits no text after the
&quot;=back&quot; command.</p>

<p style="margin-left:11%;">&quot;=begin formatname&quot;
<br>
&quot;=begin formatname parameter&quot;</p>

<p style="margin-left:17%;">This marks the following
paragraphs (until the matching &quot;=end formatname&quot;)
as being for some special kind of processing. Unless
&quot;formatname&quot; begins with a colon, the contained
non-command paragraphs are data paragraphs. But if
&quot;formatname&quot; <i>does</i> begin with a colon, then
non-command paragraphs are ordinary paragraphs or data
paragraphs. This is discussed in detail in the section
&quot;About Data Paragraphs and &quot;=begin/=end&quot;
Regions&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">It is advised
that formatnames match the regexp
&quot;m/\A:?[&minus;a&minus;zA&minus;Z0&minus;9_]+\z/&quot;.
Everything following whitespace after the formatname is a
parameter that may be used by the formatter when dealing
with this region. This parameter must not be repeated in the
&quot;=end&quot; paragraph. Implementors should anticipate
future expansion in the semantics and syntax of the first
parameter to
&quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</p>

<p style="margin-left:11%;">&quot;=end formatname&quot;</p>

<p style="margin-left:17%;">This marks the end of the
region opened by the matching &quot;=begin formatname&quot;
region. If &quot;formatname&quot; is not the formatname of
the most recent open &quot;=begin formatname&quot; region,
then this is an error, and must generate an error message.
This is discussed in detail in the section &quot;About Data
Paragraphs and &quot;=begin/=end&quot; Regions&quot;.</p>

<p style="margin-left:11%;">&quot;=for formatname
text...&quot;</p>

<p style="margin-left:17%;">This is synonymous with:</p>

<p style="margin-left:17%; margin-top: 1em">=begin
formatname <br>
text... <br>
=end formatname</p>

<p style="margin-left:17%; margin-top: 1em">That is, it
creates a region consisting of a single paragraph; that
paragraph is to be treated as a normal paragraph if
&quot;formatname&quot; begins with a &quot;:&quot;; if
&quot;formatname&quot; <i>doesn&rsquo;t</i> begin with a
colon, then &quot;text...&quot; will constitute a data
paragraph. There is no way to use &quot;=for formatname
text...&quot; to express &quot;text...&quot; as a verbatim
paragraph.</p>

<p style="margin-left:11%;">&quot;=encoding
encodingname&quot;</p>

<p style="margin-left:17%;">This command, which should
occur early in the document (at least before any
non-US-ASCII data!), declares that this document is encoded
in the encoding <i>encodingname</i>, which must be an
encoding name that Encode recognizes. (Encode&rsquo;s list
of supported encodings, in Encode::Supported, is useful
here.) If the Pod parser cannot decode the declared
encoding, it should emit a warning and may abort parsing the
document altogether.</p>

<p style="margin-left:17%; margin-top: 1em">A document
having more than one &quot;=encoding&quot; line should be
considered an error. Pod processors may silently tolerate
this if the not-first &quot;=encoding&quot; lines are just
duplicates of the first one (e.g., if there&rsquo;s a
&quot;=encoding utf8&quot; line, and later on another
&quot;=encoding utf8&quot; line). But Pod processors should
complain if there are contradictory &quot;=encoding&quot;
lines in the same document (e.g., if there is a
&quot;=encoding utf8&quot; early in the document and
&quot;=encoding big5&quot; later). Pod processors that
recognize BOMs may also complain if they see an
&quot;=encoding&quot; line that contradicts the
<small>BOM</small> (e.g., if a document with a
<small>UTF&minus;16LE BOM</small> has an &quot;=encoding
shiftjis&quot; line).</p>

<p style="margin-left:11%; margin-top: 1em">If a Pod
processor sees any command other than the ones listed above
(like &quot;=head&quot;, or &quot;=haed1&quot;, or
&quot;=stuff&quot;, or &quot;=cuttlefish&quot;, or
&quot;=w123&quot;), that processor must by default treat
this as an error. It must not process the paragraph
beginning with that command, must by default warn of this as
an error, and may abort the parse. A Pod parser may allow a
way for particular applications to add to the above list of
known commands, and to stipulate, for each additional
command, whether formatting codes should be processed.</p>

<p style="margin-left:11%; margin-top: 1em">Future versions
of this specification may add additional commands.</p>

<h2>Pod Formatting Codes
<a name="Pod Formatting Codes"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">(Note that in
previous drafts of this document and of perlpod, formatting
codes were referred to as &quot;interior sequences&quot;,
and this term may still be found in the documentation for
Pod parsers, and in error messages from Pod processors.)</p>

<p style="margin-left:11%; margin-top: 1em">There are two
syntaxes for formatting codes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A formatting code starts with a capital letter (just
US-ASCII [A&minus;Z]) followed by a &quot;&lt;&quot;, any
number of characters, and ending with the first matching
&quot;&gt;&quot;. Examples:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">That's what
I&lt;you&gt; think! <br>
What's C&lt;CORE::dump()&gt; for? <br>
X&lt;C&lt;chmod&gt; and C&lt;unlink()&gt; Under Different
Operating Systems&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">A formatting code starts with a
capital letter (just US-ASCII [A&minus;Z]) followed by two
or more &quot;&lt;&quot;&rsquo;s, one or more whitespace
characters, any number of characters, one or more whitespace
characters, and ending with the first matching sequence of
two or more &quot;&gt;&quot;&rsquo;s, where the number of
&quot;&gt;&quot;&rsquo;s equals the number of
&quot;&lt;&quot;&rsquo;s in the opening of this formatting
code. Examples:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">That's what
I&lt;&lt; you &gt;&gt; think! <br>
C&lt;&lt;&lt; open(X, &quot;&gt;&gt;thing.dat&quot;) || die
$! &gt;&gt;&gt; <br>
B&lt;&lt; $foo&minus;&gt;bar(); &gt;&gt;</p>

<p style="margin-left:17%; margin-top: 1em">With this
syntax, the whitespace character(s) after the
&quot;C&lt;&lt;&lt;&quot; and before the
&quot;&gt;&gt;&gt;&quot; (or whatever letter) are <i>not</i>
renderable. They do not signify whitespace, are merely part
of the formatting codes themselves. That is, these are all
synonymous:</p>

<p style="margin-left:17%; margin-top: 1em">C&lt;thing&gt;
<br>
C&lt;&lt; thing &gt;&gt; <br>
C&lt;&lt; thing &gt;&gt; <br>
C&lt;&lt;&lt; thing &gt;&gt;&gt; <br>
C&lt;&lt;&lt;&lt; <br>
thing <br>
&gt;&gt;&gt;&gt;</p>

<p style="margin-left:17%; margin-top: 1em">and so on.</p>

<p style="margin-left:17%; margin-top: 1em">Finally, the
multiple-angle-bracket form does <i>not</i> alter the
interpretation of nested formatting codes, meaning that the
following four example lines are identical in meaning:</p>

<p style="margin-left:17%; margin-top: 1em">B&lt;example:
C&lt;$a E&lt;lt&gt;=E&lt;gt&gt; $b&gt;&gt; <br>
B&lt;example: C&lt;&lt; $a &lt;=&gt; $b &gt;&gt;&gt; <br>
B&lt;example: C&lt;&lt; $a E&lt;lt&gt;=E&lt;gt&gt; $b
&gt;&gt;&gt; <br>
B&lt;&lt;&lt; example: C&lt;&lt; $a E&lt;lt&gt;=E&lt;gt&gt;
$b &gt;&gt; &gt;&gt;&gt;</p>

<p style="margin-left:11%; margin-top: 1em">In parsing Pod,
a notably tricky part is the correct parsing of (potentially
nested!) formatting codes. Implementors should consult the
code in the &quot;parse_text&quot; routine in Pod::Parser as
an example of a correct implementation. <br>
&quot;I&lt;text&gt;&quot; -- italic text</p>

<p style="margin-left:17%;">See the brief discussion in
&quot;Formatting Codes&quot; in perlpod.</p>

<p style="margin-left:11%;">&quot;B&lt;text&gt;&quot; --
bold text</p>

<p style="margin-left:17%;">See the brief discussion in
&quot;Formatting Codes&quot; in perlpod.</p>

<p style="margin-left:11%;">&quot;C&lt;code&gt;&quot; --
code text</p>

<p style="margin-left:17%;">See the brief discussion in
&quot;Formatting Codes&quot; in perlpod.</p>

<p style="margin-left:11%;">&quot;F&lt;filename&gt;&quot;
-- style for filenames</p>

<p style="margin-left:17%;">See the brief discussion in
&quot;Formatting Codes&quot; in perlpod.</p>

<p style="margin-left:11%;">&quot;X&lt;topic name&gt;&quot;
-- an index entry</p>

<p style="margin-left:17%;">See the brief discussion in
&quot;Formatting Codes&quot; in perlpod.</p>

<p style="margin-left:17%; margin-top: 1em">This code is
unusual in that most formatters completely discard this code
and its content. Other formatters will render it with
invisible codes that can be used in building an index of the
current document.</p>

<p style="margin-left:11%;">&quot;Z&lt;&gt;&quot; -- a null
(zero-effect) formatting code</p>

<p style="margin-left:17%;">Discussed briefly in
&quot;Formatting Codes&quot; in perlpod.</p>

<p style="margin-left:17%; margin-top: 1em">This code is
unusual in that it should have no content. That is, a
processor may complain if it sees
&quot;Z&lt;potatoes&gt;&quot;. Whether or not it complains,
the <i>potatoes</i> text should ignored.</p>

<p style="margin-left:11%;">&quot;L&lt;name&gt;&quot; -- a
hyperlink</p>

<p style="margin-left:17%;">The complicated syntaxes of
this code are discussed at length in &quot;Formatting
Codes&quot; in perlpod, and implementation details are
discussed below, in &quot;About L&lt;...&gt; Codes&quot;.
Parsing the contents of L&lt;content&gt; is tricky. Notably,
the content has to be checked for whether it looks like a
<small>URL,</small> or whether it has to be split on literal
&quot;|&quot; and/or &quot;/&quot; (in the right order!),
and so on, <i>before</i> E&lt;...&gt; codes are
resolved.</p>

<p style="margin-left:11%;">&quot;E&lt;escape&gt;&quot; --
a character escape</p>

<p style="margin-left:17%;">See &quot;Formatting
Codes&quot; in perlpod, and several points in &quot;Notes on
Implementing Pod Processors&quot;.</p>

<p style="margin-left:11%;">&quot;S&lt;text&gt;&quot; --
text contains non-breaking spaces</p>

<p style="margin-left:17%;">This formatting code is
syntactically simple, but semantically complex. What it
means is that each space in the printable content of this
code signifies a non-breaking space.</p>

<p style="margin-left:17%; margin-top: 1em">Consider:</p>

<p style="margin-left:17%; margin-top: 1em">C&lt;$x ? $y :
$z&gt; <br>
S&lt;C&lt;$x ? $y : $z&gt;&gt;</p>

<p style="margin-left:17%; margin-top: 1em">Both signify
the monospace (c[ode] style) text consisting of
&quot;$x&quot;, one space, &quot;?&quot;, one space,
&quot;:&quot;, one space, &quot;$z&quot;. The difference is
that in the latter, with the S code, those spaces are not
&quot;normal&quot; spaces, but instead are non-breaking
spaces.</p>

<p style="margin-left:11%; margin-top: 1em">If a Pod
processor sees any formatting code other than the ones
listed above (as in &quot;N&lt;...&gt;&quot;, or
&quot;Q&lt;...&gt;&quot;, etc.), that processor must by
default treat this as an error. A Pod parser may allow a way
for particular applications to add to the above list of
known formatting codes; a Pod parser might even allow a way
to stipulate, for each additional command, whether it
requires some form of special processing, as L&lt;...&gt;
does.</p>

<p style="margin-left:11%; margin-top: 1em">Future versions
of this specification may add additional formatting
codes.</p>

<p style="margin-left:11%; margin-top: 1em">Historical
note: A few older Pod processors would not see a
&quot;&gt;&quot; as closing a &quot;C&lt;&quot; code, if the
&quot;&gt;&quot; was immediately preceded by a
&quot;&minus;&quot;. This was so that this:</p>


<p style="margin-left:11%; margin-top: 1em">C&lt;$foo&minus;&gt;bar&gt;</p>

<p style="margin-left:11%; margin-top: 1em">would parse as
equivalent to this:</p>


<p style="margin-left:11%; margin-top: 1em">C&lt;$foo&minus;E&lt;gt&gt;bar&gt;</p>

<p style="margin-left:11%; margin-top: 1em">instead of as
equivalent to a &quot;C&quot; formatting code containing
only &quot;$foo&minus;&quot;, and then a &quot;bar&gt;&quot;
outside the &quot;C&quot; formatting code. This problem has
since been solved by the addition of syntaxes like this:</p>

<p style="margin-left:11%; margin-top: 1em">C&lt;&lt;
$foo&minus;&gt;bar &gt;&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Compliant
parsers must not treat &quot;&minus;&gt;&quot; as
special.</p>

<p style="margin-left:11%; margin-top: 1em">Formatting
codes absolutely cannot span paragraphs. If a code is opened
in one paragraph, and no closing code is found by the end of
that paragraph, the Pod parser must close that formatting
code, and should complain (as in &quot;Unterminated I code
in the paragraph starting at line 123: &rsquo;Time objects
are not...&rsquo;&quot;). So these two paragraphs:</p>

<p style="margin-left:11%; margin-top: 1em">I&lt;I told you
not to do this! <br>
Don't make me say it again!&gt;</p>

<p style="margin-left:11%; margin-top: 1em">...must
<i>not</i> be parsed as two paragraphs in italics (with the
I code starting in one paragraph and starting in another.)
Instead, the first paragraph should generate a warning, but
that aside, the above code must parse as if it were:</p>

<p style="margin-left:11%; margin-top: 1em">I&lt;I told you
not to do this!&gt; <br>
Don't make me say it again!E&lt;gt&gt;</p>

<p style="margin-left:11%; margin-top: 1em">(In SGMLish
jargon, all Pod commands are like block-level elements,
whereas all Pod formatting codes are like inline-level
elements.)</p>

<h2>Notes on Implementing Pod Processors
<a name="Notes on Implementing Pod Processors"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
is a long section of miscellaneous requirements and
suggestions to do with Pod processing.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod formatters should tolerate lines in verbatim blocks
that are of any length, even if that means having to break
them (possibly several times, for very long lines) to avoid
text running off the side of the page. Pod formatters may
warn of such line-breaking. Such warnings are particularly
appropriate for lines are over 100 characters long, which
are usually not intentional.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers must recognize <i>all</i> of the three
well-known newline formats: <small>CR, LF,</small> and
<small>CRLF.</small> See perlport.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers should accept input lines that are of any
length.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Since Perl recognizes a Unicode Byte Order Mark at the
start of files as signaling that the file is Unicode encoded
as in <small>UTF&minus;16</small> (whether big-endian or
little-endian) or <small>UTF&minus;8,</small> Pod parsers
should do the same. Otherwise, the character encoding should
be understood as being <small>UTF&minus;8</small> if the
first highbit byte sequence in the file seems valid as a
<small>UTF&minus;8</small> sequence, or otherwise as
<small>CP&minus;1252</small> (earlier versions of this
specification used Latin&minus;1 instead of
<small>CP&minus;1252</small> ).</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Future versions
of this specification may specify how Pod can accept other
encodings. Presumably treatment of other encodings in Pod
parsing would be as in <small>XML</small> parsing: whatever
the encoding declared by a particular Pod file, content is
to be stored in memory as Unicode characters.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The well known Unicode Byte
Order Marks are as follows: if the file begins with the two
literal byte values 0xFE 0xFF, this is the
<small>BOM</small> for big-endian
<small>UTF&minus;16.</small> If the file begins with the two
literal byte value 0xFF 0xFE, this is the <small>BOM</small>
for little-endian <small>UTF&minus;16.</small> On an
<small>ASCII</small> platform, if the file begins with the
three literal byte values 0xEF 0xBB 0xBF, this is the
<small>BOM</small> for <small>UTF&minus;8. A</small>
mechanism portable to <small>EBCDIC</small> platforms is
to:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">my $utf8_bom =
&quot;\x{FEFF}&quot;; <br>
utf8::encode($utf8_bom);</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">A naive, but often sufficient
heuristic on <small>ASCII</small> platforms, for testing the
first highbit byte-sequence in a BOM-less file (whether in
code or in Pod!), to see whether that sequence is valid as
<small>UTF&minus;8</small> ( <small>RFC 2279</small> ) is to
check whether that the first byte in the sequence is in the
range 0xC2 &minus; 0xFD <i>and</i> whether the next byte is
in the range 0x80 &minus; 0xBF. If so, the parser may
conclude that this file is in <small>UTF&minus;8,</small>
and all highbit sequences in the file should be assumed to
be <small>UTF&minus;8.</small> Otherwise the parser should
treat the file as being in <small>CP&minus;1252.</small> (A
better check, and which works on <small>EBCDIC</small>
platforms as well, is to pass a copy of the sequence to
<b>utf8::decode()</b> which performs a full validity check
on the sequence and returns <small>TRUE</small> if it is
valid <small>UTF&minus;8, FALSE</small> otherwise. This
function is always pre-loaded, is fast because it is written
in C, and will only get called at most once, so you
don&rsquo;t need to avoid it out of performance concerns.)
In the unlikely circumstance that the first highbit sequence
in a truly non&minus;UTF&minus;8 file happens to appear to
be <small>UTF&minus;8,</small> one can cater to our
heuristic (as well as any more intelligent heuristic) by
prefacing that line with a comment line containing a highbit
sequence that is clearly <i>not</i> valid as
<small>UTF&minus;8.</small> A line consisting of simply
&quot;#&quot;, an e&minus;acute, and any non-highbit byte,
is sufficient to establish this file&rsquo;s encoding.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod processors must treat a &quot;=for [label]
[content...]&quot; paragraph as meaning the same thing as a
&quot;=begin [label]&quot; paragraph, content, and an
&quot;=end [label]&quot; paragraph. (The parser may conflate
these two constructs, or may leave them distinct, in the
expectation that the formatter will nevertheless treat them
the same.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>When rendering Pod to a format that allows comments
(i.e., to nearly any format other than plaintext), a Pod
formatter must insert comment text identifying its name and
version number, and the name and version numbers of any
modules it might be using to process the Pod. Minimal
examples:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">%% POD::Pod2PS
v3.14159, using POD::Parser v1.92 <br>
&lt;!&minus;&minus; Pod::HTML v3.14159, using POD::Parser
v1.92 &minus;&minus;&gt; <br>
{\doccomm generated by Pod::Tree::RTF 3.14159 using
Pod::Tree 1.08} <br>
.\&quot; Pod::Man version 3.14159, using POD::Parser version
1.92</p>

<p style="margin-left:17%; margin-top: 1em">Formatters may
also insert additional comments, including: the release date
of the Pod formatter program, the contact address for the
author(s) of the formatter, the current time, the name of
input file, the formatting options in effect, version of
Perl used, etc.</p>

<p style="margin-left:17%; margin-top: 1em">Formatters may
also choose to note errors/warnings as comments, besides or
instead of emitting them otherwise (as in messages to
<small>STDERR,</small> or &quot;die&quot;ing).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Pod parsers <i>may</i> emit
warnings or error messages (&quot;Unknown E code
E&lt;zslig&gt;!&quot;) to <small>STDERR</small> (whether
through printing to <small>STDERR,</small> or
&quot;warn&quot;ing/&quot;carp&quot;ing, or
&quot;die&quot;ing/&quot;croak&quot;ing), but <i>must</i>
allow suppressing all such <small>STDERR</small> output, and
instead allow an option for reporting errors/warnings in
some other way, whether by triggering a callback, or noting
errors in some attribute of the document object, or some
similarly unobtrusive mechanism -- or even by appending a
&quot;Pod Errors&quot; section to the end of the parsed form
of the document.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>In cases of exceptionally aberrant documents, Pod
parsers may abort the parse. Even then, using
&quot;die&quot;ing/&quot;croak&quot;ing is to be avoided;
where possible, the parser library may simply close the
input file and add text like &quot;*** Formatting Aborted
***&quot; to the end of the (partial) in-memory
document.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>In paragraphs where formatting codes (like E&lt;...&gt;,
B&lt;...&gt;) are understood (i.e., <i>not</i> verbatim
paragraphs, but <i>including</i> ordinary paragraphs, and
command paragraphs that produce renderable text, like
&quot;=head1&quot;), literal whitespace should generally be
considered &quot;insignificant&quot;, in that one literal
space has the same meaning as any (nonzero) number of
literal spaces, literal newlines, and literal tabs (as long
as this produces no blank lines, since those would terminate
the paragraph). Pod parsers should compact literal
whitespace in each processed paragraph, but may provide an
option for overriding this (since some processing tasks do
not require it), or may follow additional special rules (for
example, specially treating period-space-space or
period-newline sequences).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers should not, by default, try to coerce
apostrophe (&rsquo;) and quote (&quot;) into smart quotes
(little 9&rsquo;s, 66&rsquo;s, 99&rsquo;s, etc), nor try to
turn backtick (&lsquo;) into anything else but a single
backtick character (distinct from an open quote character!),
nor &quot;&minus;&minus;&quot; into anything but two minus
signs. They <i>must never</i> do any of those things to text
in C&lt;...&gt; formatting codes, and never <i>ever</i> to
text in verbatim paragraphs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>When rendering Pod to a format that has two kinds of
hyphens (&minus;), one that&rsquo;s a non-breaking hyphen,
and another that&rsquo;s a breakable hyphen (as in
&quot;object-oriented&quot;, which can be split across lines
as &quot;object&minus;&quot;, newline,
&quot;oriented&quot;), formatters are encouraged to
generally translate &quot;&minus;&quot; to non-breaking
hyphen, but may apply heuristics to convert some of these to
breaking hyphens.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod formatters should make reasonable efforts to keep
words of Perl code from being broken across lines. For
example, &quot;Foo::Bar&quot; in some formatting systems is
seen as eligible for being broken across lines as
&quot;Foo::&quot; newline &quot;Bar&quot; or even
&quot;Foo::&minus;&quot; newline &quot;Bar&quot;. This
should be avoided where possible, either by disabling all
line-breaking in mid-word, or by wrapping particular words
with internal punctuation in &quot;don&rsquo;t break this
across lines&quot; codes (which in some formats may not be a
single code, but might be a matter of inserting non-breaking
zero-width spaces between every pair of characters in a
word.)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers should, by default, expand tabs in verbatim
paragraphs as they are processed, before passing them to the
formatter or other processor. Parsers may also allow an
option for overriding this.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers should, by default, remove newlines from the
end of ordinary and verbatim paragraphs before passing them
to the formatter. For example, while the paragraph
you&rsquo;re reading now could be considered, in Pod source,
to end with (and contain) the newline(s) that end it, it
should be processed as ending with (and containing) the
period character that ends this sentence.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers, when reporting errors, should make some
effort to report an approximate line number (&quot;Nested
E&lt;&gt;&rsquo;s in Paragraph #52, near line 633 of
Thing/Foo.pm!&quot;), instead of merely noting the paragraph
number (&quot;Nested E&lt;&gt;&rsquo;s in Paragraph #52 of
Thing/Foo.pm!&quot;). Where this is problematic, the
paragraph number should at least be accompanied by an
excerpt from the paragraph (&quot;Nested E&lt;&gt;&rsquo;s
in Paragraph #52 of Thing/Foo.pm, which begins
&rsquo;Read/write accessor for the C&lt;interest rate&gt;
attribute...&rsquo;&quot;).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers, when processing a series of verbatim
paragraphs one after another, should consider them to be one
large verbatim paragraph that happens to contain blank
lines. I.e., these two lines, which have a blank line
between them:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">use Foo; <br>
print Foo&minus;&gt;VERSION</p>

<p style="margin-left:17%; margin-top: 1em">should be
unified into one paragraph (&quot;\tuse Foo;\n\n\tprint
Foo&minus;&gt; <small>VERSION&quot;</small> ) before being
passed to the formatter or other processor. Parsers may also
allow an option for overriding this.</p>

<p style="margin-left:17%; margin-top: 1em">While this
might be too cumbersome to implement in event-based Pod
parsers, it is straightforward for parsers that return parse
trees.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Pod formatters, where feasible,
are advised to avoid splitting short verbatim paragraphs
(under twelve lines, say) across pages.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers must treat a line with only spaces and/or
tabs on it as a &quot;blank line&quot; such as separates
paragraphs. (Some older parsers recognized only two adjacent
newlines as a &quot;blank line&quot; but would not recognize
a newline, a space, and a newline, as a blank line. This is
noncompliant behavior.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Authors of Pod formatters/processors should make every
effort to avoid writing their own Pod parser. There are
already several in <small>CPAN,</small> with a wide range of
interface styles -- and one of them, Pod::Simple, comes with
modern versions of Perl.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Characters in Pod documents may be conveyed either as
literals, or by number in E&lt;n&gt; codes, or by an
equivalent mnemonic, as in E&lt;eacute&gt; which is exactly
equivalent to E&lt;233&gt;. The numbers are the
Latin1/Unicode values, even on <small>EBCDIC</small>
platforms.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">When referring
to characters by using a E&lt;n&gt; numeric code, numbers in
the range 32&minus;126 refer to those well known US-ASCII
characters (also defined there by Unicode, with the same
meaning), which all Pod formatters must render faithfully.
Characters whose E&lt;&gt; numbers are in the ranges
0&minus;31 and 127&minus;159 should not be used (neither as
literals, nor as E&lt;number&gt; codes), except for the
literal byte-sequences for newline ( <small>ASCII 13, ASCII
13 10,</small> or <small>ASCII 10</small> ), and tab (
<small>ASCII 9</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">Numbers in the
range 160&minus;255 refer to Latin&minus;1 characters (also
defined there by Unicode, with the same meaning). Numbers
above 255 should be understood to refer to Unicode
characters.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Be warned that some formatters
cannot reliably render characters outside 32&minus;126; and
many are able to handle 32&minus;126 and 160&minus;255, but
nothing above 255.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Besides the well-known &quot;E&lt;lt&gt;&quot; and
&quot;E&lt;gt&gt;&quot; codes for less-than and
greater-than, Pod parsers must understand
&quot;E&lt;sol&gt;&quot; for &quot;/&quot; (solidus, slash),
and &quot;E&lt;verbar&gt;&quot; for &quot;|&quot; (vertical
bar, pipe). Pod parsers should also understand
&quot;E&lt;lchevron&gt;&quot; and
&quot;E&lt;rchevron&gt;&quot; as legacy codes for characters
171 and 187, i.e., &quot;left-pointing double angle
quotation mark&quot; = &quot;left pointing guillemet&quot;
and &quot;right-pointing double angle quotation mark&quot; =
&quot;right pointing guillemet&quot;. (These look like
little &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot;, and
they are now preferably expressed with the
<small>HTML/XHTML</small> codes &quot;E&lt;laquo&gt;&quot;
and &quot;E&lt;raquo&gt;&quot;.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers should understand all
&quot;E&lt;html&gt;&quot; codes as defined in the entity
declarations in the most recent <small>XHTML</small>
specification at &quot;www.W3.org&quot;. Pod parsers must
understand at least the entities that define characters in
the range 160&minus;255 (Latin&minus;1). Pod parsers, when
faced with some unknown
&quot;E&lt;<i>identifier</i>&gt;&quot; code, shouldn&rsquo;t
simply replace it with nullstring (by default, at least),
but may pass it through as a string consisting of the
literal characters E, less-than, <i>identifier</i>,
greater-than. Or Pod parsers may offer the alternative
option of processing such unknown
&quot;E&lt;<i>identifier</i>&gt;&quot; codes by firing an
event especially for such codes, or by adding a special
node-type to the in-memory document tree. Such
&quot;E&lt;<i>identifier</i>&gt;&quot; may have special
meaning to some processors, or some processors may choose to
add them to a special error report.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Pod parsers must also support the <small>XHTML</small>
codes &quot;E&lt;quot&gt;&quot; for character 34
(doublequote, &quot;), &quot;E&lt;amp&gt;&quot; for
character 38 (ampersand, &amp;), and
&quot;E&lt;apos&gt;&quot; for character 39 (apostrophe,
&rsquo;).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Note that in all cases of &quot;E&lt;whatever&gt;&quot;,
<i>whatever</i> (whether an htmlname, or a number in any
base) must consist only of alphanumeric characters -- that
is, <i>whatever</i> must match &quot;m/\A\w+\z/&quot;. So
&quot;E&lt;&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;&gt;&quot; is
invalid, because it contains spaces, which aren&rsquo;t
alphanumeric characters. This presumably does not
<i>need</i> special treatment by a Pod processor;
&quot;&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;&quot; doesn&rsquo;t
look like a number in any base, so it would presumably be
looked up in the table of HTML-like names. Since there
isn&rsquo;t (and cannot be) an HTML-like entity called
&quot;&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;&quot;, this will be
treated as an error. However, Pod processors may treat
&quot;E&lt;&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;&gt;&quot; or
&quot;E&lt;e&minus;acute&gt;&quot; as <i>syntactically</i>
invalid, potentially earning a different error message than
the error message (or warning, or event) generated by a
merely unknown (but theoretically valid) htmlname, as in
&quot;E&lt;qacute&gt;&quot; [sic]. However, Pod parsers are
not required to make this distinction.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Note that E&lt;number&gt; <i>must not</i> be interpreted
as simply &quot;codepoint <i>number</i> in the
current/native character set&quot;. It always means only
&quot;the character represented by codepoint <i>number</i>
in Unicode.&quot; (This is identical to the semantics of
&amp;#<i>number</i>; in <small>XML.</small> )</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This will
likely require many formatters to have tables mapping from
treatable Unicode codepoints (such as the &quot;\xE9&quot;
for the e&minus;acute character) to the escape sequences or
codes necessary for conveying such sequences in the target
output format. A converter to *roff would, for example know
that &quot;\xE9&quot; (whether conveyed literally, or via a
E&lt;...&gt; sequence) is to be conveyed as
&quot;e\\*&rsquo;&quot;. Similarly, a program rendering Pod
in a Mac <small>OS</small> application window, would
presumably need to know that &quot;\xE9&quot; maps to
codepoint 142 in MacRoman encoding that (at time of writing)
is native for Mac <small>OS.</small> Such Unicode2whatever
mappings are presumably already widely available for common
output formats. (Such mappings may be incomplete!
Implementers are not expected to bend over backwards in an
attempt to render Cherokee syllabics, Etruscan runes,
Byzantine musical symbols, or any of the other weird things
that Unicode can encode.) And if a Pod document uses a
character not found in such a mapping, the formatter should
consider it an unrenderable character.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If, surprisingly, the
implementor of a Pod formatter can&rsquo;t find a
satisfactory pre-existing table mapping from Unicode
characters to escapes in the target format (e.g., a decent
table of Unicode characters to *roff escapes), it will be
necessary to build such a table. If you are in this
circumstance, you should begin with the characters in the
range 0x00A0 &minus; 0x00FF, which is mostly the heavily
used accented characters. Then proceed (as patience permits
and fastidiousness compels) through the characters that the
(X)HTML standards groups judged important enough to merit
mnemonics for. These are declared in the (X)HTML
specifications at the www.W3.org site. At time of writing
(September 2001), the most recent entity declaration files
are:</p> </td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">http://www.w3.org/TR/xhtml1/DTD/xhtml&minus;lat1.ent
<br>
http://www.w3.org/TR/xhtml1/DTD/xhtml&minus;special.ent <br>
http://www.w3.org/TR/xhtml1/DTD/xhtml&minus;symbol.ent</p>

<p style="margin-left:17%; margin-top: 1em">Then you can
progress through any remaining notable Unicode characters in
the range 0x2000&minus;0x204D (consult the character tables
at www.unicode.org), and whatever else strikes your fancy.
For example, in <i>xhtml&minus;symbol.ent</i>, there is the
entry:</p>

<p style="margin-left:17%; margin-top: 1em">&lt;!ENTITY
infin &quot;&amp;#8734;&quot;&gt; &lt;!&minus;&minus;
infinity, U+221E ISOtech &minus;&minus;&gt;</p>

<p style="margin-left:17%; margin-top: 1em">While the
mapping &quot;infin&quot; to the character
&quot;\x{221E}&quot; will (hopefully) have been already
handled by the Pod parser, the presence of the character in
this file means that it&rsquo;s reasonably important enough
to include in a formatter&rsquo;s table that maps from
notable Unicode characters to the codes necessary for
rendering them. So for a Unicode&minus;to&minus;*roff
mapping, for example, this would merit the entry:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;\x{221E}&quot;
=&gt; '\(in',</p>

<p style="margin-left:17%; margin-top: 1em">It is eagerly
hoped that in the future, increasing numbers of formats (and
formatters) will support Unicode characters directly (as
(X)HTML does with &quot;&amp;infin;&quot;,
&quot;&amp;#8734;&quot;, or &quot;&amp;#x221E;&quot;),
reducing the need for idiosyncratic mappings of
Unicode&minus;to&minus;<i>my_escapes</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">It is up to individual Pod
formatter to display good judgement when confronted with an
unrenderable character (which is distinct from an unknown
E&lt;thing&gt; sequence that the parser couldn&rsquo;t
resolve to anything, renderable or not). It is good practice
to map Latin letters with diacritics (like
&quot;E&lt;eacute&gt;&quot;/&quot;E&lt;233&gt;&quot;) to the
corresponding unaccented US-ASCII letters (like a simple
character 101, &quot;e&quot;), but clearly this is often not
feasible, and an unrenderable character may be represented
as &quot;?&quot;, or the like. In attempting a sane fallback
(as from E&lt;233&gt; to &quot;e&quot;), Pod formatters may
use the %Latin1Code_to_fallback table in Pod::Escapes, or
Text::Unidecode, if available.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For example,
this Pod text:</p>

<p style="margin-left:17%; margin-top: 1em">magic is
enabled if you set C&lt;$Currency&gt; to
'E&lt;euro&gt;'.</p>

<p style="margin-left:17%; margin-top: 1em">may be rendered
as: &quot;magic is enabled if you set $Currency to
&rsquo;<i>?</i>&rsquo;&quot; or as &quot;magic is enabled if
you set $Currency to &rsquo;<b>[euro]</b>&rsquo;&quot;, or
as &quot;magic is enabled if you set $Currency to
&rsquo;[x20AC]&rsquo;, etc.</p>

<p style="margin-left:17%; margin-top: 1em">A Pod formatter
may also note, in a comment or warning, a list of what
unrenderable characters were encountered.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">E&lt;...&gt; may freely appear
in any formatting code (other than in another E&lt;...&gt;
or in an Z&lt;&gt;). That is, &quot;X&lt;The
E&lt;euro&gt;1,000,000 Solution&gt;&quot; is valid, as is
&quot;L&lt;The E&lt;euro&gt;1,000,000
Solution|Million::Euros&gt;&quot;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Some Pod formatters output to formats that implement
non-breaking spaces as an individual character (which
I&rsquo;ll call &quot; <small>NBSP&quot;</small> ), and
others output to formats that implement non-breaking spaces
just as spaces wrapped in a &quot;don&rsquo;t break this
across lines&quot; code. Note that at the level of Pod, both
sorts of codes can occur: Pod can contain a
<small>NBSP</small> character (whether as a literal, or as a
&quot;E&lt;160&gt;&quot; or &quot;E&lt;nbsp&gt;&quot; code);
and Pod can contain &quot;S&lt;foo I&lt;bar&gt;
baz&gt;&quot; codes, where &quot;mere spaces&quot;
(character 32) in such codes are taken to represent
non-breaking spaces. Pod parsers should consider supporting
the optional parsing of &quot;S&lt;foo I&lt;bar&gt;
baz&gt;&quot; as if it were &quot;foo
<i><small>NBSP</small></i> I&lt;bar&gt;
<i><small>NBSP</small></i> baz&quot;, and, going the other
way, the optional parsing of groups of words joined by
<small>NBSP</small> &rsquo;s as if each group were in a
S&lt;...&gt; code, so that formatters may use the
representation that maps best to what the output format
demands.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Some processors may find that the
&quot;S&lt;...&gt;&quot; code is easiest to implement by
replacing each space in the parse tree under the content of
the S, with an <small>NBSP.</small> But note: the
replacement should apply <i>not</i> to spaces in <i>all</i>
text, but <i>only</i> to spaces in <i>printable</i> text.
(This distinction may or may not be evident in the
particular tree/event model implemented by the Pod parser.)
For example, consider this unusual case:</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">S&lt;L&lt;/Autoloaded
Functions&gt;&gt;</p>

<p style="margin-left:17%; margin-top: 1em">This means that
the space in the middle of the visible link text must not be
broken across lines. In other words, it&rsquo;s the same as
this:</p>


<p style="margin-left:17%; margin-top: 1em">L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/Autoloaded
Functions&gt;</p>

<p style="margin-left:17%; margin-top: 1em">However, a
misapplied space-to-NBSP replacement could (wrongly) produce
something equivalent to this:</p>


<p style="margin-left:17%; margin-top: 1em">L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/AutoloadedE&lt;160&gt;Functions&gt;</p>

<p style="margin-left:17%; margin-top: 1em">...which is
almost definitely not going to work as a hyperlink (assuming
this formatter outputs a format supporting hypertext).</p>

<p style="margin-left:17%; margin-top: 1em">Formatters may
choose to just not support the S format code, especially in
cases where the output format simply has no
<small>NBSP</small> character/code and no code for
&quot;don&rsquo;t break this stuff across lines&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Besides the <small>NBSP</small>
character discussed above, implementors are reminded of the
existence of the other &quot;special&quot; character in
Latin&minus;1, the &quot;soft hyphen&quot; character, also
known as &quot;discretionary hyphen&quot;, i.e.
&quot;E&lt;173&gt;&quot; = &quot;E&lt;0xAD&gt;&quot; =
&quot;E&lt;shy&gt;&quot;). This character expresses an
optional hyphenation point. That is, it normally renders as
nothing, but may render as a &quot;&minus;&quot; if a
formatter breaks the word at that point. Pod formatters
should, as appropriate, do one of the following: 1) render
this with a code with the same meaning (e.g.,
&quot;\&minus;&quot; in <small>RTF</small> ), 2) pass it
through in the expectation that the formatter understands
this character as such, or 3) delete it.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>


<p style="margin-left:17%; margin-top: 1em">sigE&lt;shy&gt;action
<br>
manuE&lt;shy&gt;script <br>
JarkE&lt;shy&gt;ko
HieE&lt;shy&gt;taE&lt;shy&gt;nieE&lt;shy&gt;mi</p>

<p style="margin-left:17%; margin-top: 1em">These signal to
a formatter that if it is to hyphenate &quot;sigaction&quot;
or &quot;manuscript&quot;, then it should be done as
&quot;sig&minus;<i>[linebreak]</i>action&quot; or
&quot;manu&minus;<i>[linebreak]</i>script&quot; (and if it
doesn&rsquo;t hyphenate it, then the
&quot;E&lt;shy&gt;&quot; doesn&rsquo;t show up at all). And
if it is to hyphenate &quot;Jarkko&quot; and/or
&quot;Hietaniemi&quot;, it can do so only at the points
where there is a &quot;E&lt;shy&gt;&quot; code.</p>

<p style="margin-left:17%; margin-top: 1em">In practice, it
is anticipated that this character will not be used often,
but formatters should either support it, or delete it.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If you think that you want to
add a new command to Pod (like, say, a &quot;=biblio&quot;
command), consider whether you could get the same effect
with a for or begin/end sequence: &quot;=for biblio
...&quot; or &quot;=begin biblio&quot; ... &quot;=end
biblio&quot;. Pod processors that don&rsquo;t understand
&quot;=for biblio&quot;, etc, will simply ignore it, whereas
they may complain loudly if they see
&quot;=biblio&quot;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Throughout this document, &quot;Pod&quot; has been the
preferred spelling for the name of the documentation format.
One may also use &quot; <small>POD&quot;</small> or
&quot;pod&quot;. For the documentation that is (typically)
in the Pod format, you may use &quot;pod&quot;, or
&quot;Pod&quot;, or &quot; <small>POD&quot;.</small>
Understanding these distinctions is useful; but obsessing
over how to spell them, usually is not.</p></td></tr>
</table>

<h2>About L&lt;...&gt; Codes
<a name="About L&lt;...&gt; Codes"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As you can tell
from a glance at perlpod, the L&lt;...&gt; code is the most
complex of the Pod formatting codes. The points below will
hopefully clarify what it means and how processors should
deal with it.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">In parsing an L&lt;...&gt; code,
Pod parsers must distinguish at least four attributes:</p></td></tr>
</table>

<p style="margin-left:17%;">First:</p>

<p style="margin-left:23%;">The link-text. If there is
none, this must be &quot;undef&quot;. (E.g., in
&quot;L&lt;Perl Functions|perlfunc&gt;&quot;, the link-text
is &quot;Perl Functions&quot;. In
&quot;L&lt;Time::HiRes&gt;&quot; and even
&quot;L&lt;|Time::HiRes&gt;&quot;, there is no link text.
Note that link text may contain formatting.)</p>

<p style="margin-left:17%;">Second:</p>

<p style="margin-left:23%;">The possibly inferred
link-text; i.e., if there was no real link text, then this
is the text that we&rsquo;ll infer in its place. (E.g., for
&quot;L&lt;Getopt::Std&gt;&quot;, the inferred link text is
&quot;Getopt::Std&quot;.)</p>

<p style="margin-left:17%;">Third:</p>

<p style="margin-left:23%;">The name or <small>URL,</small>
or &quot;undef&quot; if none. (E.g., in &quot;L&lt;Perl
Functions|perlfunc&gt;&quot;, the name (also sometimes
called the page) is &quot;perlfunc&quot;. In
&quot;L&lt;/CAVEATS&gt;&quot;, the name is
&quot;undef&quot;.)</p>

<p style="margin-left:17%;">Fourth:</p>

<p style="margin-left:23%;">The section (
<small>AKA</small> &quot;item&quot; in older perlpods), or
&quot;undef&quot; if none. E.g., in
&quot;L&lt;Getopt::Std/DESCRIPTION&gt;&quot;, &quot;
<small>DESCRIPTION&quot;</small> is the section. (Note that
this is not the same as a manpage section like the
&quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section
Foo&quot; in the Pod sense means the part of the text
that&rsquo;s introduced by the heading or item whose text is
&quot;Foo&quot;.)</p>

<p style="margin-left:17%; margin-top: 1em">Pod parsers may
also note additional attributes including: <br>
Fifth:</p>

<p style="margin-left:23%;">A flag for whether item 3 (if
present) is a <small>URL</small> (like
&quot;http://lists.perl.org&quot; is), in which case there
should be no section attribute; a Pod name (like
&quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or
possibly a man page name (like &quot;<b>crontab</b>(5)&quot;
is).</p>

<p style="margin-left:17%;">Sixth:</p>

<p style="margin-left:23%;">The raw original L&lt;...&gt;
content, before text is split on &quot;|&quot;,
&quot;/&quot;, etc, and before E&lt;...&gt; codes are
expanded.</p>

<p style="margin-left:17%; margin-top: 1em">(The above were
numbered only for concise reference below. It is not a
requirement that these be passed as an actual list or
array.)</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>


<p style="margin-left:17%; margin-top: 1em">L&lt;Foo::Bar&gt;
<br>
=&gt; undef, # link text <br>
&quot;Foo::Bar&quot;, # possibly inferred link text <br>
&quot;Foo::Bar&quot;, # name <br>
undef, # section <br>
'pod', # what sort of link <br>
&quot;Foo::Bar&quot; # original content <br>
L&lt;Perlport's section on NL's|perlport/Newlines&gt; <br>
=&gt; &quot;Perlport's section on NL's&quot;, # link text
<br>
&quot;Perlport's section on NL's&quot;, # possibly inferred
link text <br>
&quot;perlport&quot;, # name <br>
&quot;Newlines&quot;, # section <br>
'pod', # what sort of link <br>
&quot;Perlport's section on NL's|perlport/Newlines&quot;
<br>
# original content <br>
L&lt;perlport/Newlines&gt; <br>
=&gt; undef, # link text <br>
'&quot;Newlines&quot; in perlport', # possibly inferred link
text <br>
&quot;perlport&quot;, # name <br>
&quot;Newlines&quot;, # section <br>
'pod', # what sort of link <br>
&quot;perlport/Newlines&quot; # original content <br>
L&lt;crontab(5)/&quot;DESCRIPTION&quot;&gt; <br>
=&gt; undef, # link text <br>
'&quot;DESCRIPTION&quot; in crontab(5)', # possibly inferred
link text <br>
&quot;crontab(5)&quot;, # name <br>
&quot;DESCRIPTION&quot;, # section <br>
'man', # what sort of link <br>
'crontab(5)/&quot;DESCRIPTION&quot;' # original content <br>
L&lt;/Object Attributes&gt; <br>
=&gt; undef, # link text <br>
'&quot;Object Attributes&quot;', # possibly inferred link
text <br>
undef, # name <br>
&quot;Object Attributes&quot;, # section <br>
'pod', # what sort of link <br>
&quot;/Object Attributes&quot; # original content <br>
L&lt;https://www.perl.org/&gt; <br>
=&gt; undef, # link text <br>
&quot;https://www.perl.org/&quot;, # possibly inferred link
text <br>
&quot;https://www.perl.org/&quot;, # name <br>
undef, # section <br>
'url', # what sort of link <br>
&quot;https://www.perl.org/&quot; # original content <br>
L&lt;Perl.org|https://www.perl.org/&gt; <br>
=&gt; &quot;Perl.org&quot;, # link text <br>
&quot;https://www.perl.org/&quot;, # possibly inferred link
text <br>
&quot;https://www.perl.org/&quot;, # name <br>
undef, # section <br>
'url', # what sort of link <br>
&quot;Perl.org|https://www.perl.org/&quot; # original
content</p>

<p style="margin-left:17%; margin-top: 1em">Note that you
can distinguish URL-links from anything else by the fact
that they match &quot;m/\A\w+:[^:\s]\S*\z/&quot;. So
&quot;L&lt;http://www.perl.com&gt;&quot; is a
<small>URL,</small> but &quot;L&lt;HTTP::Response&gt;&quot;
isn&rsquo;t.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>In case of L&lt;...&gt; codes with no &quot;text|&quot;
part in them, older formatters have exhibited great
variation in actually displaying the link or cross
reference. For example, L&lt;<b>crontab</b>(5)&gt; would
render as &quot;the crontab(5) manpage&quot;, or &quot;in
the crontab(5) manpage&quot; or just
&quot;crontab(5)&quot;.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Pod processors
must now treat &quot;text|&quot;&minus;less links as
follows:</p>

<p style="margin-left:17%; margin-top: 1em">L&lt;name&gt;
=&gt; L&lt;name|name&gt; <br>
L&lt;/section&gt; =&gt;
L&lt;&quot;section&quot;|/section&gt; <br>
L&lt;name/section&gt; =&gt; L&lt;&quot;section&quot; in
name|name/section&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Note that section names might
contain markup. I.e., if a section starts with:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">=head2 About
the C&lt;&minus;M&gt; Operator</p>

<p style="margin-left:17%; margin-top: 1em">or with:</p>

<p style="margin-left:17%; margin-top: 1em">=item About the
C&lt;&minus;M&gt; Operator</p>

<p style="margin-left:17%; margin-top: 1em">then a link to
it would look like this:</p>


<p style="margin-left:17%; margin-top: 1em">L&lt;somedoc/About
the C&lt;&minus;M&gt; Operator&gt;</p>

<p style="margin-left:17%; margin-top: 1em">Formatters may
choose to ignore the markup for purposes of resolving the
link and use only the renderable characters in the section
name, as in:</p>


<p style="margin-left:17%; margin-top: 1em">&lt;h1&gt;&lt;a
name=&quot;About_the_&minus;M_Operator&quot;&gt;About the
&lt;code&gt;&minus;M&lt;/code&gt; <br>
Operator&lt;/h1&gt; <br>
... <br>
&lt;a
href=&quot;somedoc#About_the_&minus;M_Operator&quot;&gt;About
the &lt;code&gt;&minus;M&lt;/code&gt; <br>
Operator&quot; in somedoc&lt;/a&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Previous versions of perlpod
distinguished &quot;L&lt;name/&quot;section&quot;&gt;&quot;
links from &quot;L&lt;name/item&gt;&quot; links (and their
targets). These have been merged syntactically and
semantically in the current specification, and
<i>section</i> can refer either to a &quot;=head<i>n</i>
Heading Content&quot; command or to a &quot;=item Item
Content&quot; command. This specification does not specify
what behavior should be in the case of a given document
having several things all seeming to produce the same
<i>section</i> identifier (e.g., in <small>HTML,</small>
several things all producing the same <i>anchorname</i> in
&lt;a name=&quot;<i>anchorname</i>&quot;&gt;...&lt;/a&gt;
elements). Where Pod processors can control this behavior,
they should use the first such anchor. That is,
&quot;L&lt;Foo/Bar&gt;&quot; refers to the <i>first</i>
&quot;Bar&quot; section in Foo.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">But for some
processors/formats this cannot be easily controlled; as with
the <small>HTML</small> example, the behavior of multiple
ambiguous &lt;a
name=&quot;<i>anchorname</i>&quot;&gt;...&lt;/a&gt; is most
easily just left up to browsers to decide.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">In a
&quot;L&lt;text|...&gt;&quot; code, text may contain
formatting codes for formatting or for E&lt;...&gt; escapes,
as in:</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">L&lt;B&lt;ummE&lt;234&gt;stuff&gt;|...&gt;</p>

<p style="margin-left:17%; margin-top: 1em">For
&quot;L&lt;...&gt;&quot; codes without a &quot;name|&quot;
part, only &quot;E&lt;...&gt;&quot; and
&quot;Z&lt;&gt;&quot; codes may occur. That is, authors
should not use
&quot;&quot;L&lt;B&lt;Foo::Bar&gt;&gt;&quot;&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note, however,
that formatting codes and Z&lt;&gt;&rsquo;s can occur in any
and all parts of an L&lt;...&gt; (i.e., in <i>name</i>,
<i>section</i>, <i>text</i>, and <i>url</i>).</p>

<p style="margin-left:17%; margin-top: 1em">Authors must
not nest L&lt;...&gt; codes. For example, &quot;L&lt;The
L&lt;Foo::Bar&gt; man page&gt;&quot; should be treated as an
error.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Note that Pod authors may use
formatting codes inside the &quot;text&quot; part of
&quot;L&lt;text|name&gt;&quot; (and so on for
L&lt;text|/&quot;sec&quot;&gt;).</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In other words,
this is valid:</p>

<p style="margin-left:17%; margin-top: 1em">Go read
L&lt;the docs on C&lt;$.&gt;|perlvar/&quot;$.&quot;&gt;</p>

<p style="margin-left:17%; margin-top: 1em">Some output
formats that do allow rendering &quot;L&lt;...&gt;&quot;
codes as hypertext, might not allow the link-text to be
formatted; in that case, formatters will have to just ignore
that formatting.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">At time of writing,
&quot;L&lt;name&gt;&quot; values are of two types: either
the name of a Pod page like &quot;L&lt;Foo::Bar&gt;&quot;
(which might be a real Perl module or program in an @INC /
<small>PATH</small> directory, or a .pod file in those
places); or the name of a Unix man page, like
&quot;L&lt;crontab(5)&gt;&quot;. In theory,
&quot;L&lt;chmod&gt;&quot; is ambiguous between a Pod page
called &quot;chmod&quot;, or the Unix man page
&quot;chmod&quot; (in whatever man-section). However, the
presence of a string in parens, as in
&quot;<b>crontab</b>(5)&quot;, is sufficient to signal that
what is being discussed is not a Pod page, and so is
presumably a Unix man page. The distinction is of no
importance to many Pod processors, but some processors that
render to hypertext formats may need to distinguish them in
order to know how to render a given &quot;L&lt;foo&gt;&quot;
code.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Previous versions of perlpod allowed for a
&quot;L&lt;section&gt;&quot; syntax (as in &quot;L&lt;Object
Attributes&gt;&quot;), which was not easily distinguishable
from &quot;L&lt;name&gt;&quot; syntax and for
&quot;L&lt;&quot;section&quot;&gt;&quot; which was only
slightly less ambiguous. This syntax is no longer in the
specification, and has been replaced by the
&quot;L&lt;/section&gt;&quot; syntax (where the slash was
formerly optional). Pod parsers should tolerate the
&quot;L&lt;&quot;section&quot;&gt;&quot; syntax, for a while
at least. The suggested heuristic for distinguishing
&quot;L&lt;section&gt;&quot; from &quot;L&lt;name&gt;&quot;
is that if it contains any whitespace, it&rsquo;s a
<i>section</i>. Pod processors should warn about this being
deprecated syntax.</p></td></tr>
</table>

<h2>About =over...=back Regions
<a name="About =over...=back Regions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;=over&quot;...&quot;=back&quot;
regions are used for various kinds of list-like structures.
(I use the term &quot;region&quot; here simply as a
collective term for everything from the &quot;=over&quot; to
the matching &quot;=back&quot;.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The non-zero numeric
<i>indentlevel</i> in &quot;=over <i>indentlevel</i>&quot;
... &quot;=back&quot; is used for giving the formatter a
clue as to how many &quot;spaces&quot; (ems, or roughly
equivalent units) it should tab over, although many
formatters will have to convert this to an absolute
measurement that may not exactly match with the size of
spaces (or M&rsquo;s) in the document&rsquo;s base font.
Other formatters may have to completely ignore the number.
The lack of any explicit <i>indentlevel</i> parameter is
equivalent to an <i>indentlevel</i> value of 4. Pod
processors may complain if <i>indentlevel</i> is present but
is not a positive number matching
&quot;m/\A(\d*\.)?\d+\z/&quot;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Authors of Pod formatters are reminded that
&quot;=over&quot; ... &quot;=back&quot; may map to several
different constructs in your output format. For example, in
converting Pod to (X)HTML, it can map to any of
&lt;ul&gt;...&lt;/ul&gt;, &lt;ol&gt;...&lt;/ol&gt;,
&lt;dl&gt;...&lt;/dl&gt;, or
&lt;blockquote&gt;...&lt;/blockquote&gt;. Similarly,
&quot;=item&quot; can map to &lt;li&gt; or &lt;dt&gt;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Each &quot;=over&quot; ... &quot;=back&quot; region
should be one of the following:</p></td></tr>
</table>

<p style="margin-left:17%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="77%">


<p style="margin-top: 1em">An &quot;=over&quot; ...
&quot;=back&quot; region containing only &quot;=item *&quot;
commands, each followed by some number of ordinary/verbatim
paragraphs, other nested &quot;=over&quot; ...
&quot;=back&quot; regions, &quot;=for...&quot; paragraphs,
and &quot;=begin&quot;...&quot;=end&quot; regions.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">(Pod processors
must tolerate a bare &quot;=item&quot; as if it were
&quot;=item *&quot;.) Whether &quot;*&quot; is rendered as a
literal asterisk, an &quot;o&quot;, or as some kind of real
bullet character, is left up to the Pod formatter, and may
depend on the level of nesting.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">An &quot;=over&quot; ...
&quot;=back&quot; region containing only
&quot;m/\A=item\s+\d+\.?\s*\z/&quot; paragraphs, each one
(or each group of them) followed by some number of
ordinary/verbatim paragraphs, other nested &quot;=over&quot;
... &quot;=back&quot; regions, &quot;=for...&quot;
paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot;
codes. Note that the numbers must start at 1 in each
section, and must proceed in order and without skipping
numbers.</p> </td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">(Pod processors
must tolerate lines like &quot;=item 1&quot; as if they were
&quot;=item 1.&quot;, with the period.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">An &quot;=over&quot; ...
&quot;=back&quot; region containing only &quot;=item
[text]&quot; commands, each one (or each group of them)
followed by some number of ordinary/verbatim paragraphs,
other nested &quot;=over&quot; ... &quot;=back&quot;
regions, or &quot;=for...&quot; paragraphs, and
&quot;=begin&quot;...&quot;=end&quot; regions.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">The &quot;=item
[text]&quot; paragraph should not match
&quot;m/\A=item\s+\d+\.?\s*\z/&quot; or
&quot;m/\A=item\s+\*\s*\z/&quot;, nor should it match just
&quot;m/\A=item\s*\z/&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">An &quot;=over&quot; ...
&quot;=back&quot; region containing no &quot;=item&quot;
paragraphs at all, and containing only some number of
ordinary/verbatim paragraphs, and possibly also some nested
&quot;=over&quot; ... &quot;=back&quot; regions,
&quot;=for...&quot; paragraphs, and
&quot;=begin&quot;...&quot;=end&quot; regions. Such an
itemless &quot;=over&quot; ... &quot;=back&quot; region in
Pod is equivalent in meaning to a
&quot;&lt;blockquote&gt;...&lt;/blockquote&gt;&quot; element
in <small>HTML.</small></p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Note that with
all the above cases, you can determine which type of
&quot;=over&quot; ... &quot;=back&quot; you have, by
examining the first (non&minus;&quot;=cut&quot;,
non&minus;&quot;=pod&quot;) Pod paragraph after the
&quot;=over&quot; command.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Pod formatters <i>must</i>
tolerate arbitrarily large amounts of text in the
&quot;=item <i>text...</i>&quot; paragraph. In practice,
most such paragraphs are short, as in:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">=item For
cutting off our trade with all parts of the world</p>

<p style="margin-left:17%; margin-top: 1em">But they may be
arbitrarily long:</p>

<p style="margin-left:17%; margin-top: 1em">=item For
transporting us beyond seas to be tried for pretended <br>
offenses <br>
=item He is at this time transporting large armies of
foreign <br>
mercenaries to complete the works of death, desolation and
<br>
tyranny, already begun with circumstances of cruelty and
perfidy <br>
scarcely paralleled in the most barbarous ages, and totally
<br>
unworthy the head of a civilized nation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Pod processors should tolerate
&quot;=item *&quot; / &quot;=item <i>number</i>&quot;
commands with no accompanying paragraph. The middle item is
an example:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">=over <br>
=item 1 <br>
Pick up dry cleaning. <br>
=item 2 <br>
=item 3 <br>
Stop by the store. Get Abba Zabas, Stoli, and cheap lawn
chairs. <br>
=back</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">No &quot;=over&quot; ...
&quot;=back&quot; region can contain headings. Processors
may treat such a heading as an error.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Note that an &quot;=over&quot; ... &quot;=back&quot;
region should have some content. That is, authors should not
have an empty region like this:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">=over <br>
=back</p>

<p style="margin-left:17%; margin-top: 1em">Pod processors
seeing such a contentless &quot;=over&quot; ...
&quot;=back&quot; region, may ignore it, or may report it as
an error.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Processors must tolerate an
&quot;=over&quot; list that goes off the end of the document
(i.e., which has no matching &quot;=back&quot;), but they
may warn about such a list.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Authors of Pod formatters should note that this
construct:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">=item Neque
<br>
=item Porro <br>
=item Quisquam Est <br>
Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
<br>
velit, sed quia non numquam eius modi tempora incidunt ut
<br>
labore et dolore magnam aliquam quaerat voluptatem. <br>
=item Ut Enim</p>

<p style="margin-left:17%; margin-top: 1em">is semantically
ambiguous, in a way that makes formatting decisions a bit
difficult. On the one hand, it could be mention of an item
&quot;Neque&quot;, mention of another item
&quot;Porro&quot;, and mention of another item
&quot;Quisquam Est&quot;, with just the last one requiring
the explanatory paragraph &quot;Qui dolorem ipsum quia
dolor...&quot;; and then an item &quot;Ut Enim&quot;. In
that case, you&rsquo;d want to format it like so:</p>

<p style="margin-left:17%; margin-top: 1em">Neque <br>
Porro <br>
Quisquam Est <br>
Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
<br>
velit, sed quia non numquam eius modi tempora incidunt ut
<br>
labore et dolore magnam aliquam quaerat voluptatem. <br>
Ut Enim</p>

<p style="margin-left:17%; margin-top: 1em">But it could
equally well be a discussion of three (related or
equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and
&quot;Quisquam Est&quot;, followed by a paragraph explaining
them all, and then a new item &quot;Ut Enim&quot;. In that
case, you&rsquo;d probably want to format it like so:</p>

<p style="margin-left:17%; margin-top: 1em">Neque <br>
Porro <br>
Quisquam Est <br>
Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
<br>
velit, sed quia non numquam eius modi tempora incidunt ut
<br>
labore et dolore magnam aliquam quaerat voluptatem. <br>
Ut Enim</p>

<p style="margin-left:17%; margin-top: 1em">But (for the
foreseeable future), Pod does not provide any way for Pod
authors to distinguish which grouping is meant by the above
&quot;=item&quot;&minus;cluster structure. So formatters
should format it like so:</p>

<p style="margin-left:17%; margin-top: 1em">Neque <br>
Porro <br>
Quisquam Est <br>
Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
<br>
velit, sed quia non numquam eius modi tempora incidunt ut
<br>
labore et dolore magnam aliquam quaerat voluptatem. <br>
Ut Enim</p>

<p style="margin-left:17%; margin-top: 1em">That is, there
should be (at least roughly) equal spacing between items as
between paragraphs (although that spacing may well be less
than the full height of a line of text). This leaves it to
the reader to use (con)textual cues to figure out whether
the &quot;Qui dolorem ipsum...&quot; paragraph applies to
the &quot;Quisquam Est&quot; item or to all three items
&quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam
Est&quot;. While not an ideal situation, this is preferable
to providing formatting cues that may be actually contrary
to the author&rsquo;s intent.</p>

<h2>About Data Paragraphs and &quot;=begin/=end&quot; Regions
<a name="About Data Paragraphs and &quot;=begin/=end&quot; Regions"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Data paragraphs
are typically used for inlining non-Pod data that is to be
used (typically passed through) when rendering the document
to a specific format:</p>

<p style="margin-left:11%; margin-top: 1em">=begin rtf <br>
\par{\pard\qr\sa4500{\i Printed\~\chdate\~\chtime}\par} <br>
=end rtf</p>

<p style="margin-left:11%; margin-top: 1em">The exact same
effect could, incidentally, be achieved with a single
&quot;=for&quot; paragraph:</p>

<p style="margin-left:11%; margin-top: 1em">=for rtf
\par{\pard\qr\sa4500{\i Printed\~\chdate\~\chtime}\par}</p>

<p style="margin-left:11%; margin-top: 1em">(Although that
is not formally a data paragraph, it has the same meaning as
one, and Pod parsers may parse it as one.)</p>

<p style="margin-left:11%; margin-top: 1em">Another example
of a data paragraph:</p>

<p style="margin-left:11%; margin-top: 1em">=begin html
<br>
I like &lt;em&gt;PIE&lt;/em&gt;! <br>
&lt;hr&gt;Especially pecan pie! <br>
=end html</p>

<p style="margin-left:11%; margin-top: 1em">If these were
ordinary paragraphs, the Pod parser would try to expand the
&quot;E&lt;/em&gt;&quot; (in the first paragraph) as a
formatting code, just like &quot;E&lt;lt&gt;&quot; or
&quot;E&lt;eacute&gt;&quot;. But since this is in a
&quot;=begin <i>identifier</i>&quot;...&quot;=end
<i>identifier</i>&quot; region <i>and</i> the identifier
&quot;html&quot; doesn&rsquo;t begin have a &quot;:&quot;
prefix, the contents of this region are stored as data
paragraphs, instead of being processed as ordinary
paragraphs (or if they began with a spaces and/or tabs, as
verbatim paragraphs).</p>

<p style="margin-left:11%; margin-top: 1em">As a further
example: At time of writing, no &quot;biblio&quot;
identifier is supported, but suppose some processor were
written to recognize it as a way of (say) denoting a
bibliographic reference (necessarily containing formatting
codes in ordinary paragraphs). The fact that
&quot;biblio&quot; paragraphs were meant for ordinary
processing would be indicated by prefacing each
&quot;biblio&quot; identifier with a colon:</p>

<p style="margin-left:11%; margin-top: 1em">=begin :biblio
<br>
Wirth, Niklaus. 1976. I&lt;Algorithms + Data Structures =
<br>
Programs.&gt; Prentice&minus;Hall, Englewood Cliffs, NJ.
<br>
=end :biblio</p>

<p style="margin-left:11%; margin-top: 1em">This would
signal to the parser that paragraphs in this begin...end
region are subject to normal handling as ordinary/verbatim
paragraphs (while still tagged as meant only for processors
that understand the &quot;biblio&quot; identifier). The same
effect could be had with:</p>

<p style="margin-left:11%; margin-top: 1em">=for :biblio
<br>
Wirth, Niklaus. 1976. I&lt;Algorithms + Data Structures =
<br>
Programs.&gt; Prentice&minus;Hall, Englewood Cliffs, NJ.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;:&quot; on these identifiers means simply
&quot;process this stuff normally, even though the result
will be for some special target&quot;. I suggest that parser
APIs report &quot;biblio&quot; as the target identifier, but
also report that it had a &quot;:&quot; prefix. (And
similarly, with the above &quot;html&quot;, report
&quot;html&quot; as the target identifier, and note the
<i>lack</i> of a &quot;:&quot; prefix.)</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
&quot;=begin <i>identifier</i>&quot;...&quot;=end
<i>identifier</i>&quot; region where <i>identifier</i>
begins with a colon, <i>can</i> contain commands. For
example:</p>

<p style="margin-left:11%; margin-top: 1em">=begin :biblio
<br>
Wirth's classic is available in several editions, including:
<br>
=for comment <br>
hm, check abebooks.com for how much used copies cost. <br>
=over <br>
=item <br>
Wirth, Niklaus. 1975. I&lt;Algorithmen und
Datenstrukturen.&gt; <br>
Teubner, Stuttgart. [Yes, it's in German.] <br>
=item <br>
Wirth, Niklaus. 1976. I&lt;Algorithms + Data Structures =
<br>
Programs.&gt; Prentice&minus;Hall, Englewood Cliffs, NJ.
<br>
=back <br>
=end :biblio</p>

<p style="margin-left:11%; margin-top: 1em">Note, however,
a &quot;=begin <i>identifier</i>&quot;...&quot;=end
<i>identifier</i>&quot; region where <i>identifier</i> does
<i>not</i> begin with a colon, should not directly contain
&quot;=head1&quot; ... &quot;=head4&quot; commands, nor
&quot;=over&quot;, nor &quot;=back&quot;, nor
&quot;=item&quot;. For example, this may be considered
invalid:</p>

<p style="margin-left:11%; margin-top: 1em">=begin somedata
<br>
This is a data paragraph. <br>
=head1 Don't do this! <br>
This is a data paragraph too. <br>
=end somedata</p>

<p style="margin-left:11%; margin-top: 1em">A Pod processor
may signal that the above (specifically the
&quot;=head1&quot; paragraph) is an error. Note, however,
that the following should <i>not</i> be treated as an
error:</p>

<p style="margin-left:11%; margin-top: 1em">=begin somedata
<br>
This is a data paragraph. <br>
=cut <br>
# Yup, this isn't Pod anymore. <br>
sub excl { (rand() &gt; .5) ? &quot;hoo!&quot; :
&quot;hah!&quot; } <br>
=pod <br>
This is a data paragraph too. <br>
=end somedata</p>

<p style="margin-left:11%; margin-top: 1em">And this too is
valid:</p>

<p style="margin-left:11%; margin-top: 1em">=begin
someformat <br>
This is a data paragraph. <br>
And this is a data paragraph. <br>
=begin someotherformat <br>
This is a data paragraph too. <br>
And this is a data paragraph too. <br>
=begin :yetanotherformat <br>
=head2 This is a command paragraph! <br>
This is an ordinary paragraph! <br>
And this is a verbatim paragraph! <br>
=end :yetanotherformat <br>
=end someotherformat <br>
Another data paragraph! <br>
=end someformat</p>

<p style="margin-left:11%; margin-top: 1em">The contents of
the above &quot;=begin :yetanotherformat&quot; ...
&quot;=end :yetanotherformat&quot; region
<i>aren&rsquo;t</i> data paragraphs, because the immediately
containing region&rsquo;s identifier
(&quot;:yetanotherformat&quot;) begins with a colon. In
practice, most regions that contain data paragraphs will
contain <i>only</i> data paragraphs; however, the above
nesting is syntactically valid as Pod, even if it is rare.
However, the handlers for some formats, like
&quot;html&quot;, will accept only data paragraphs, not
nested regions; and they may complain if they see (targeted
for them) nested regions, or commands, other than
&quot;=end&quot;, &quot;=pod&quot;, and
&quot;=cut&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Also consider
this valid structure:</p>

<p style="margin-left:11%; margin-top: 1em">=begin :biblio
<br>
Wirth's classic is available in several editions, including:
<br>
=over <br>
=item <br>
Wirth, Niklaus. 1975. I&lt;Algorithmen und
Datenstrukturen.&gt; <br>
Teubner, Stuttgart. [Yes, it's in German.] <br>
=item <br>
Wirth, Niklaus. 1976. I&lt;Algorithms + Data Structures =
<br>
Programs.&gt; Prentice&minus;Hall, Englewood Cliffs, NJ.
<br>
=back <br>
Buy buy buy! <br>
=begin html <br>
&lt;img src='wirth_spokesmodeling_book.png'&gt; <br>
&lt;hr&gt; <br>
=end html <br>
Now now now! <br>
=end :biblio</p>

<p style="margin-left:11%; margin-top: 1em">There, the
&quot;=begin html&quot;...&quot;=end html&quot; region is
nested inside the larger &quot;=begin
:biblio&quot;...&quot;=end :biblio&quot; region. Note that
the content of the &quot;=begin html&quot;...&quot;=end
html&quot; region is data paragraph(s), because the
immediately containing region&rsquo;s identifier
(&quot;html&quot;) <i>doesn&rsquo;t</i> begin with a
colon.</p>

<p style="margin-left:11%; margin-top: 1em">Pod parsers,
when processing a series of data paragraphs one after
another (within a single region), should consider them to be
one large data paragraph that happens to contain blank
lines. So the content of the above &quot;=begin
html&quot;...&quot;=end html&quot; <i>may</i> be stored as
two data paragraphs (one consisting of &quot;&lt;img
src=&rsquo;wirth_spokesmodeling_book.png&rsquo;&gt;\n&quot;
and another consisting of &quot;&lt;hr&gt;\n&quot;), but
<i>should</i> be stored as a single data paragraph
(consisting of &quot;&lt;img
src=&rsquo;wirth_spokesmodeling_book.png&rsquo;&gt;\n\n&lt;hr&gt;\n&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Pod processors
should tolerate empty &quot;=begin
<i>something</i>&quot;...&quot;=end <i>something</i>&quot;
regions, empty &quot;=begin
:<i>something</i>&quot;...&quot;=end :<i>something</i>&quot;
regions, and contentless &quot;=for <i>something</i>&quot;
and &quot;=for :<i>something</i>&quot; paragraphs. I.e.,
these should be tolerated:</p>

<p style="margin-left:11%; margin-top: 1em">=for html <br>
=begin html <br>
=end html <br>
=begin :biblio <br>
=end :biblio</p>

<p style="margin-left:11%; margin-top: 1em">Incidentally,
note that there&rsquo;s no easy way to express a data
paragraph starting with something that looks like a command.
Consider:</p>

<p style="margin-left:11%; margin-top: 1em">=begin stuff
<br>
=shazbot <br>
=end stuff</p>

<p style="margin-left:11%; margin-top: 1em">There,
&quot;=shazbot&quot; will be parsed as a Pod command
&quot;shazbot&quot;, not as a data paragraph
&quot;=shazbot\n&quot;. However, you can express a data
paragraph consisting of &quot;=shazbot\n&quot; using this
code:</p>

<p style="margin-left:11%; margin-top: 1em">=for stuff
=shazbot</p>

<p style="margin-left:11%; margin-top: 1em">The situation
where this is necessary, is presumably quite rare.</p>

<p style="margin-left:11%; margin-top: 1em">Note that =end
commands must match the currently open =begin command. That
is, they must properly nest. For example, this is valid:</p>

<p style="margin-left:11%; margin-top: 1em">=begin outer
<br>
X <br>
=begin inner <br>
Y <br>
=end inner <br>
Z <br>
=end outer</p>

<p style="margin-left:11%; margin-top: 1em">while this is
invalid:</p>

<p style="margin-left:11%; margin-top: 1em">=begin outer
<br>
X <br>
=begin inner <br>
Y <br>
=end outer <br>
Z <br>
=end inner</p>

<p style="margin-left:11%; margin-top: 1em">This latter is
improper because when the &quot;=end outer&quot; command is
seen, the currently open region has the formatname
&quot;inner&quot;, not &quot;outer&quot;. (It just happens
that &quot;outer&quot; is the format name of a higher-up
region.) This is an error. Processors must by default report
this as an error, and may halt processing the document
containing that error. A corollary of this is that regions
cannot &quot;overlap&quot;. That is, the latter block above
does not represent a region called &quot;outer&quot; which
contains X and Y, overlapping a region called
&quot;inner&quot; which contains Y and Z. But because it is
invalid (as all apparently overlapping regions would be), it
doesn&rsquo;t represent that, or anything at all.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, this
is invalid:</p>

<p style="margin-left:11%; margin-top: 1em">=begin thing
<br>
=end hting</p>

<p style="margin-left:11%; margin-top: 1em">This is an
error because the region is opened by &quot;thing&quot;, and
the &quot;=end&quot; tries to close &quot;hting&quot;
[sic].</p>

<p style="margin-left:11%; margin-top: 1em">This is also
invalid:</p>

<p style="margin-left:11%; margin-top: 1em">=begin thing
<br>
=end</p>

<p style="margin-left:11%; margin-top: 1em">This is invalid
because every &quot;=end&quot; command must have a
formatname parameter.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlpod,
&quot;PODs: Embedded Documentation&quot; in perlsyn,
podchecker</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Sean M.
Burke</p>
<hr>
</body>
</html>
