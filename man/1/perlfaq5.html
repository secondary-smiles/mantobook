<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:58 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLFAQ5</title>

</head>
<body>
<h1>perlfaq5</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlfaq5
&minus; Files and Formats</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">version
5.20210520</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
deals with I/O and the &quot;f&quot; issues: filehandles,
flushing, formats, and footers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
flush/unbuffer an output filehandle? Why must I do this?</b>
<br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">You might like
to read Mark Jason Dominus&rsquo;s &quot;Suffering From
Buffering&quot; at
&lt;http://perl.plover.com/FAQs/Buffering.html&gt; .</p>

<p style="margin-left:11%; margin-top: 1em">Perl normally
buffers output so it doesn&rsquo;t make a system call for
every bit of output. By saving up output, it makes fewer
expensive system calls. For instance, in this little bit of
code, you want to print a dot to the screen for every line
you process to watch the progress of your program. Instead
of seeing a dot for every line, Perl buffers the output and
you have a long wait before you see a row of 50 dots all at
once:</p>

<p style="margin-left:11%; margin-top: 1em"># long wait,
then row of dots all at once <br>
while( &lt;&gt; ) { <br>
print &quot;.&quot;; <br>
print &quot;\n&quot; unless ++$count % 50; <br>
#... expensive line processing operations <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">To get around
this, you have to unbuffer the output filehandle, in this
case, &quot;STDOUT&quot;. You can set the special variable
$| to a true value (mnemonic: making your filehandles
&quot;piping hot&quot;):</p>

<p style="margin-left:11%; margin-top: 1em">$|++; <br>
# dot shown immediately <br>
while( &lt;&gt; ) { <br>
print &quot;.&quot;; <br>
print &quot;\n&quot; unless ++$count % 50; <br>
#... expensive line processing operations <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The $| is one
of the per-filehandle special variables, so each filehandle
has its own copy of its value. If you want to merge standard
output and standard error for instance, you have to unbuffer
each (although <small>STDERR</small> might be unbuffered by
default):</p>

<p style="margin-left:11%; margin-top: 1em">{ <br>
my $previous_default = select(STDOUT); # save previous
default <br>
$|++; # autoflush STDOUT <br>
select(STDERR); <br>
$|++; # autoflush STDERR, to be sure <br>
select($previous_default); # restore previous default <br>
} <br>
# now should alternate . and + <br>
while( 1 ) { <br>
sleep 1; <br>
print STDOUT &quot;.&quot;; <br>
print STDERR &quot;+&quot;; <br>
print STDOUT &quot;\n&quot; unless ++$count % 25; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Besides the $|
special variable, you can use &quot;binmode&quot; to give
your filehandle a &quot;:unix&quot; layer, which is
unbuffered:</p>

<p style="margin-left:11%; margin-top: 1em">binmode(
STDOUT, &quot;:unix&quot; ); <br>
while( 1 ) { <br>
sleep 1; <br>
print &quot;.&quot;; <br>
print &quot;\n&quot; unless ++$count % 50; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">For more
information on output layers, see the entries for
&quot;binmode&quot; and open in perlfunc, and the PerlIO
module documentation.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
using IO::Handle or one of its subclasses, you can call the
&quot;autoflush&quot; method to change the settings of the
filehandle:</p>

<p style="margin-left:11%; margin-top: 1em">use IO::Handle;
<br>
open my( $io_fh ), &quot;&gt;&quot;, &quot;output.txt&quot;;
<br>
$io_fh&minus;&gt;autoflush(1);</p>

<p style="margin-left:11%; margin-top: 1em">The IO::Handle
objects also have a &quot;flush&quot; method. You can flush
the buffer any time you want without auto-buffering</p>


<p style="margin-left:11%; margin-top: 1em">$io_fh&minus;&gt;flush;</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
change, delete, or insert a line in a file, or append to the
beginning of a file?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">The basic idea
of inserting, changing, or deleting a line from a text file
involves reading and printing the file to the point you want
to make the change, making the change, then reading and
printing the rest of the file. Perl doesn&rsquo;t provide
random access to lines (especially since the record input
separator, $/, is mutable), although modules such as
Tie::File can fake it.</p>

<p style="margin-left:11%; margin-top: 1em">A Perl program
to do these tasks takes the basic form of opening a file,
printing its lines, then closing the file:</p>

<p style="margin-left:11%; margin-top: 1em">open my $in,
'&lt;', $file or die &quot;Can't read old file: $!&quot;;
<br>
open my $out, '&gt;', &quot;$file.new&quot; or die
&quot;Can't write new file: $!&quot;; <br>
while( &lt;$in&gt; ) { <br>
print $out $_; <br>
} <br>
close $out;</p>

<p style="margin-left:11%; margin-top: 1em">Within that
basic form, add the parts that you need to insert, change,
or delete lines.</p>

<p style="margin-left:11%; margin-top: 1em">To prepend
lines to the beginning, print those lines before you enter
the loop that prints the existing lines.</p>

<p style="margin-left:11%; margin-top: 1em">open my $in,
'&lt;', $file or die &quot;Can't read old file: $!&quot;;
<br>
open my $out, '&gt;', &quot;$file.new&quot; or die
&quot;Can't write new file: $!&quot;; <br>
print $out &quot;# Add this line to the top\n&quot;; #
&lt;&minus;&minus;&minus; HERE'S THE MAGIC <br>
while( &lt;$in&gt; ) { <br>
print $out $_; <br>
} <br>
close $out;</p>

<p style="margin-left:11%; margin-top: 1em">To change
existing lines, insert the code to modify the lines inside
the &quot;while&quot; loop. In this case, the code finds all
lowercased versions of &quot;perl&quot; and uppercases them.
The happens for every line, so be sure that you&rsquo;re
supposed to do that on every line!</p>

<p style="margin-left:11%; margin-top: 1em">open my $in,
'&lt;', $file or die &quot;Can't read old file: $!&quot;;
<br>
open my $out, '&gt;', &quot;$file.new&quot; or die
&quot;Can't write new file: $!&quot;; <br>
print $out &quot;# Add this line to the top\n&quot;; <br>
while( &lt;$in&gt; ) { <br>
s/\b(perl)\b/Perl/g; <br>
print $out $_; <br>
} <br>
close $out;</p>

<p style="margin-left:11%; margin-top: 1em">To change only
a particular line, the input line number, $., is useful.
First read and print the lines up to the one you want to
change. Next, read the single line you want to change,
change it, and print it. After that, read the rest of the
lines and print those:</p>

<p style="margin-left:11%; margin-top: 1em">while(
&lt;$in&gt; ) { # print the lines before the change <br>
print $out $_; <br>
last if $. == 4; # line number before change <br>
} <br>
my $line = &lt;$in&gt;; <br>
$line =~ s/\b(perl)\b/Perl/g; <br>
print $out $line; <br>
while( &lt;$in&gt; ) { # print the rest of the lines <br>
print $out $_; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">To skip lines,
use the looping controls. The &quot;next&quot; in this
example skips comment lines, and the &quot;last&quot; stops
all processing once it encounters either &quot;__END__&quot;
or &quot;__DATA__&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">while(
&lt;$in&gt; ) { <br>
next if /^\s+#/; # skip comment lines <br>
last if /^__(END|DATA)__$/; # stop at end of code marker
<br>
print $out $_; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Do the same
sort of thing to delete a particular line by using
&quot;next&quot; to skip the lines you don&rsquo;t want to
show up in the output. This example skips every fifth
line:</p>

<p style="margin-left:11%; margin-top: 1em">while(
&lt;$in&gt; ) { <br>
next unless $. % 5; <br>
print $out $_; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If, for some
odd reason, you really want to see the whole file at once
rather than processing line-by-line, you can slurp it in (as
long as you can fit the whole thing in memory!):</p>

<p style="margin-left:11%; margin-top: 1em">open my $in,
'&lt;', $file or die &quot;Can't read old file: $!&quot;
<br>
open my $out, '&gt;', &quot;$file.new&quot; or die
&quot;Can't write new file: $!&quot;; <br>
my $content = do { local $/; &lt;$in&gt; }; # slurp! <br>
# do your magic here <br>
print $out $content;</p>

<p style="margin-left:11%; margin-top: 1em">Modules such as
Path::Tiny and Tie::File can help with that too. If you can,
however, avoid reading the entire file at once. Perl
won&rsquo;t give that memory back to the operating system
until the process finishes.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use Perl one-liners to modify a file in-place. The following
changes all &rsquo;Fred&rsquo; to &rsquo;Barney&rsquo; in
<i>inFile.txt</i>, overwriting the file with the new
contents. With the &quot;&minus;p&quot; switch, Perl wraps a
&quot;while&quot; loop around the code you specify with
&quot;&minus;e&quot;, and &quot;&minus;i&quot; turns on
in-place editing. The current line is in $_. With
&quot;&minus;p&quot;, Perl automatically prints the value of
$_ at the end of the loop. See perlrun for more details.</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;pi
&minus;e 's/Fred/Barney/' inFile.txt</p>

<p style="margin-left:11%; margin-top: 1em">To make a
backup of &quot;inFile.txt&quot;, give &quot;&minus;i&quot;
a file extension to add:</p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;pi.bak &minus;e 's/Fred/Barney/' inFile.txt</p>

<p style="margin-left:11%; margin-top: 1em">To change only
the fifth line, you can add a test checking $., the input
line number, then only perform the operation when the test
passes:</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;pi
&minus;e 's/Fred/Barney/ if $. == 5' inFile.txt</p>

<p style="margin-left:11%; margin-top: 1em">To add lines
before a certain line, you can add a line (or lines!) before
Perl prints $_:</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;pi
&minus;e 'print &quot;Put before third line\n&quot; if $. ==
3' inFile.txt</p>

<p style="margin-left:11%; margin-top: 1em">You can even
add a line to the beginning of a file, since the current
line prints at the end of the loop:</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;pi
&minus;e 'print &quot;Put before first line\n&quot; if $. ==
1' inFile.txt</p>

<p style="margin-left:11%; margin-top: 1em">To insert a
line after one already in the file, use the
&quot;&minus;n&quot; switch. It&rsquo;s just like
&quot;&minus;p&quot; except that it doesn&rsquo;t print $_
at the end of the loop, so you have to do that yourself. In
this case, print $_ first, then print the line that you want
to add.</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;ni
&minus;e 'print; print &quot;Put after fifth line\n&quot; if
$. == 5' inFile.txt</p>

<p style="margin-left:11%; margin-top: 1em">To delete
lines, only print the ones that you want.</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;ni
&minus;e 'print if /d/' inFile.txt</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
count the number of lines in a file?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">Conceptually,
the easiest way to count the lines in a file is to simply
read them and count them:</p>

<p style="margin-left:11%; margin-top: 1em">my $count = 0;
<br>
while( &lt;$fh&gt; ) { $count++; }</p>

<p style="margin-left:11%; margin-top: 1em">You don&rsquo;t
really have to count them yourself, though, since Perl
already does that with the $. variable, which is the current
line number from the last filehandle read:</p>

<p style="margin-left:11%; margin-top: 1em">1 while(
&lt;$fh&gt; ); <br>
my $count = $.;</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
use $., you can reduce it to a simple one-liner, like one of
these:</p>

<p style="margin-left:11%; margin-top: 1em">% perl
&minus;lne '} print $.; {' file <br>
% perl &minus;lne 'END { print $. }' file</p>

<p style="margin-left:11%; margin-top: 1em">Those can be
rather inefficient though. If they aren&rsquo;t fast enough
for you, you might just read chunks of data and count the
number of newlines:</p>

<p style="margin-left:11%; margin-top: 1em">my $lines = 0;
<br>
open my($fh), '&lt;:raw', $filename or die &quot;Can't open
$filename: $!&quot;; <br>
while( sysread $fh, $buffer, 4096 ) { <br>
$lines += ( $buffer =~ tr/\n// ); <br>
} <br>
close $fh;</p>

<p style="margin-left:11%; margin-top: 1em">However, that
doesn&rsquo;t work if the line ending isn&rsquo;t a newline.
You might change that &quot;tr///&quot; to a
&quot;s///&quot; so you can count the number of times the
input record separator, $/, shows up:</p>

<p style="margin-left:11%; margin-top: 1em">my $lines = 0;
<br>
open my($fh), '&lt;:raw', $filename or die &quot;Can't open
$filename: $!&quot;; <br>
while( sysread $fh, $buffer, 4096 ) { <br>
$lines += ( $buffer =~ s|$/||g; ); <br>
} <br>
close $fh;</p>

<p style="margin-left:11%; margin-top: 1em">If you
don&rsquo;t mind shelling out, the &quot;wc&quot; command is
usually the fastest, even with the extra interprocess
overhead. Ensure that you have an untainted filename
though:</p>

<p style="margin-left:11%; margin-top: 1em">#!perl &minus;T
<br>
$ENV{PATH} = undef; <br>
my $lines; <br>
if( $filename =~ /^([0&minus;9a&minus;z_.]+)\z/ ) { <br>
$lines = `/usr/bin/wc &minus;l $1` <br>
chomp $lines; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
delete the last N lines from a file?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">The easiest
conceptual solution is to count the lines in the file then
start at the beginning and print the number of lines (minus
the last N) to a new file.</p>

<p style="margin-left:11%; margin-top: 1em">Most often, the
real question is how you can delete the last N lines without
making more than one pass over the file, or how to do it
without a lot of copying. The easy concept is the hard
reality when you might have millions of lines in your
file.</p>

<p style="margin-left:11%; margin-top: 1em">One trick is to
use File::ReadBackwards, which starts at the end of the
file. That module provides an object that wraps the real
filehandle to make it easy for you to move around the file.
Once you get to the spot you need, you can get the actual
filehandle and work with it as normal. In this case, you get
the file position at the end of the last line you want to
keep and truncate the file to that point:</p>

<p style="margin-left:11%; margin-top: 1em">use
File::ReadBackwards; <br>
my $filename = 'test.txt'; <br>
my $Lines_to_truncate = 2; <br>
my $bw = File::ReadBackwards&minus;&gt;new( $filename ) <br>
or die &quot;Could not read backwards in [$filename]:
$!&quot;; <br>
my $lines_from_end = 0; <br>
until( $bw&minus;&gt;eof or $lines_from_end ==
$Lines_to_truncate ) { <br>
print &quot;Got: &quot;, $bw&minus;&gt;readline; <br>
$lines_from_end++; <br>
} <br>
truncate( $filename, $bw&minus;&gt;tell );</p>

<p style="margin-left:11%; margin-top: 1em">The
File::ReadBackwards module also has the advantage of setting
the input record separator to a regular expression.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use the Tie::File module which lets you access the lines
through a tied array. You can use normal array operations to
modify your file, including setting the last index and using
&quot;splice&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
use Perl&rsquo;s &quot;&minus;i&quot; option from within a
program?</b> <br>
&quot;&minus;i&quot; sets the value of Perl&rsquo;s $^I
variable, which in turn affects the behavior of
&quot;&lt;&gt;&quot;; see perlrun for more details. By
modifying the appropriate variables directly, you can get
the same behavior within a larger program. For example:</p>

<p style="margin-left:11%; margin-top: 1em"># ... <br>
{ <br>
local($^I, @ARGV) = ('.orig', glob(&quot;*.c&quot;)); <br>
while (&lt;&gt;) { <br>
if ($. == 1) { <br>
print &quot;This line should appear at the top of each
file\n&quot;; <br>
} <br>
s/\b(p)earl\b/${1}erl/i; # Correct typos, preserving case
<br>
print; <br>
close ARGV if eof; # Reset $. <br>
} <br>
} <br>
# $^I and @ARGV return to their old values here</p>

<p style="margin-left:11%; margin-top: 1em">This block
modifies all the &quot;.c&quot; files in the current
directory, leaving a backup of the original data from each
file in a new &quot;.c.orig&quot; file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
copy a file?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">Use the
File::Copy module. It comes with Perl and can do a true copy
across file systems, and it does its magic in a portable
fashion.</p>

<p style="margin-left:11%; margin-top: 1em">use File::Copy;
<br>
copy( $original, $new_copy ) or die &quot;Copy failed:
$!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If you
can&rsquo;t use File::Copy, you&rsquo;ll have to do the work
yourself: open the original file, open the destination file,
then print to the destination file as you read the original.
You also have to remember to copy the permissions, owner,
and group to the new file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
make a temporary file name?</b> <br>
If you don&rsquo;t need to know the name of the file, you
can use &quot;open()&quot; with &quot;undef&quot; in place
of the file name. In Perl 5.8 or later, the
&quot;open()&quot; function creates an anonymous temporary
file:</p>

<p style="margin-left:11%; margin-top: 1em">open my $tmp,
'+&gt;', undef or die $!;</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, you
can use the File::Temp module.</p>

<p style="margin-left:11%; margin-top: 1em">use File::Temp
qw/ tempfile tempdir /; <br>
my $dir = tempdir( CLEANUP =&gt; 1 ); <br>
($fh, $filename) = tempfile( DIR =&gt; $dir ); <br>
# or if you don't need to know the filename <br>
my $fh = tempfile( DIR =&gt; $dir );</p>

<p style="margin-left:11%; margin-top: 1em">The File::Temp
has been a standard module since Perl 5.6.1. If you
don&rsquo;t have a modern enough Perl installed, use the
&quot;new_tmpfile&quot; class method from the IO::File
module to get a filehandle opened for reading and writing.
Use it if you don&rsquo;t need to know the file&rsquo;s
name:</p>

<p style="margin-left:11%; margin-top: 1em">use IO::File;
<br>
my $fh = IO::File&minus;&gt;new_tmpfile() <br>
or die &quot;Unable to make new temporary file:
$!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
committed to creating a temporary file by hand, use the
process <small>ID</small> and/or the current time-value. If
you need to have many temporary files in one process, use a
counter:</p>

<p style="margin-left:11%; margin-top: 1em">BEGIN { <br>
use Fcntl; <br>
use File::Spec; <br>
my $temp_dir = File::Spec&minus;&gt;tmpdir(); <br>
my $file_base = sprintf &quot;%d&minus;%d&minus;0000&quot;,
$$, time; <br>
my $base_name = File::Spec&minus;&gt;catfile($temp_dir,
$file_base); <br>
sub temp_file { <br>
my $fh; <br>
my $count = 0; <br>
until( defined(fileno($fh)) || $count++ &gt; 100 ) { <br>
$base_name =~ s/&minus;(\d+)$/&quot;&minus;&quot; . (1 +
$1)/e; <br>
# O_EXCL is required for security reasons. <br>
sysopen $fh, $base_name, O_WRONLY|O_EXCL|O_CREAT; <br>
} <br>
if( defined fileno($fh) ) { <br>
return ($fh, $base_name); <br>
} <br>
else { <br>
return (); <br>
} <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
manipulate fixed-record-length files?</b> <br>
The most efficient way is using <b>pack()</b> and
<b>unpack()</b>. This is faster than using <b>substr()</b>
when taking many, many strings. It is slower for just a
few.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
sample chunk of code to break up and put back together again
some fixed-format input lines, in this case from the output
of a normal, Berkeley-style ps:</p>

<p style="margin-left:11%; margin-top: 1em"># sample input
line: <br>
# 15158 p5 T 0:00 perl /home/tchrist/scripts/now&minus;what
<br>
my $PS_T = 'A6 A4 A7 A5 A*'; <br>
open my $ps, '&minus;|', 'ps'; <br>
print scalar &lt;$ps&gt;; <br>
my @fields = qw( pid tt stat time command ); <br>
while (&lt;$ps&gt;) { <br>
my %process; <br>
@process{@fields} = unpack($PS_T, $_); <br>
for my $field ( @fields ) { <br>
print &quot;$field: &lt;$process{$field}&gt;\n&quot;; <br>
} <br>
print 'line=', pack($PS_T, @process{@fields} ),
&quot;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">We&rsquo;ve
used a hash slice in order to easily handle the fields of
each row. Storing the keys in an array makes it easy to
operate on them as a group or loop over them with
&quot;for&quot;. It also avoids polluting the program with
global variables and using symbolic references.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
make a filehandle local to a subroutine? How do I pass
filehandles between subroutines? How do I make an array of
filehandles?</b> <br>
As of perl5.6, <b>open()</b> autovivifies file and directory
handles as references if you pass it an uninitialized scalar
variable. You can then pass these references just like any
other scalar, and use them in the place of named
handles.</p>

<p style="margin-left:11%; margin-top: 1em">open my $fh,
$file_name; <br>
open local $fh, $file_name; <br>
print $fh &quot;Hello World!\n&quot;; <br>
process_file( $fh );</p>

<p style="margin-left:11%; margin-top: 1em">If you like,
you can store these filehandles in an array or a hash. If
you access them directly, they aren&rsquo;t simple scalars
and you need to give &quot;print&quot; a little help by
placing the filehandle reference in braces. Perl can only
figure it out on its own when the filehandle reference is a
simple scalar.</p>

<p style="margin-left:11%; margin-top: 1em">my @fhs = (
$fh1, $fh2, $fh3 ); <br>
for( $i = 0; $i &lt;= $#fhs; $i++ ) { <br>
print {$fhs[$i]} &quot;just another Perl answer, \n&quot;;
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Before perl5.6,
you had to deal with various typeglob idioms which you may
see in older code.</p>

<p style="margin-left:11%; margin-top: 1em">open FILE,
&quot;&gt; $filename&quot;; <br>
process_typeglob( *FILE ); <br>
process_reference( \*FILE ); <br>
sub process_typeglob { local *FH = shift; print FH
&quot;Typeglob!&quot; } <br>
sub process_reference { local $fh = shift; print $fh
&quot;Reference!&quot; }</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
create many anonymous handles, you should check out the
Symbol or IO::Handle modules.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
use a filehandle indirectly?</b> <br>
An indirect filehandle is the use of something other than a
symbol in a place that a filehandle is expected. Here are
ways to get indirect filehandles:</p>

<p style="margin-left:11%; margin-top: 1em">$fh = SOME_FH;
# bareword is strict&minus;subs hostile <br>
$fh = &quot;SOME_FH&quot;; # strict&minus;refs hostile; same
package only <br>
$fh = *SOME_FH; # typeglob <br>
$fh = \*SOME_FH; # ref to typeglob (bless&minus;able) <br>
$fh = *SOME_FH{IO}; # blessed IO::Handle from *SOME_FH
typeglob</p>

<p style="margin-left:11%; margin-top: 1em">Or, you can use
the &quot;new&quot; method from one of the IO::* modules to
create an anonymous filehandle and store that in a scalar
variable.</p>

<p style="margin-left:11%; margin-top: 1em">use IO::Handle;
# 5.004 or higher <br>
my $fh = IO::Handle&minus;&gt;new();</p>

<p style="margin-left:11%; margin-top: 1em">Then use any of
those as you would a normal filehandle. Anywhere that Perl
is expecting a filehandle, an indirect filehandle may be
used instead. An indirect filehandle is just a scalar
variable that contains a filehandle. Functions like
&quot;print&quot;, &quot;open&quot;, &quot;seek&quot;, or
the &quot;&lt;FH&gt;&quot; diamond operator will accept
either a named filehandle or a scalar variable containing
one:</p>

<p style="margin-left:11%; margin-top: 1em">($ifh, $ofh,
$efh) = (*STDIN, *STDOUT, *STDERR); <br>
print $ofh &quot;Type it: &quot;; <br>
my $got = &lt;$ifh&gt; <br>
print $efh &quot;What was that: $got&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
passing a filehandle to a function, you can write the
function in two ways:</p>

<p style="margin-left:11%; margin-top: 1em">sub accept_fh {
<br>
my $fh = shift; <br>
print $fh &quot;Sending to indirect filehandle\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Or it can
localize a typeglob and use the filehandle directly:</p>

<p style="margin-left:11%; margin-top: 1em">sub accept_fh {
<br>
local *FH = shift; <br>
print FH &quot;Sending to localized filehandle\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Both styles
work with either objects or typeglobs of real filehandles.
(They might also work with strings under some circumstances,
but this is risky.)</p>


<p style="margin-left:11%; margin-top: 1em">accept_fh(*STDOUT);
<br>
accept_fh($handle);</p>

<p style="margin-left:11%; margin-top: 1em">In the examples
above, we assigned the filehandle to a scalar variable
before using it. That is because only simple scalar
variables, not expressions or subscripts of hashes or
arrays, can be used with built-ins like &quot;print&quot;,
&quot;printf&quot;, or the diamond operator. Using something
other than a simple scalar variable as a filehandle is
illegal and won&rsquo;t even compile:</p>

<p style="margin-left:11%; margin-top: 1em">my @fd =
(*STDIN, *STDOUT, *STDERR); <br>
print $fd[1] &quot;Type it: &quot;; # WRONG <br>
my $got = &lt;$fd[0]&gt; # WRONG <br>
print $fd[2] &quot;What was that: $got&quot;; # WRONG</p>

<p style="margin-left:11%; margin-top: 1em">With
&quot;print&quot; and &quot;printf&quot;, you get around
this by using a block and an expression where you would
place the filehandle:</p>

<p style="margin-left:11%; margin-top: 1em">print { $fd[1]
} &quot;funny stuff\n&quot;; <br>
printf { $fd[1] } &quot;Pity the poor %x.\n&quot;,
3_735_928_559; <br>
# Pity the poor deadbeef.</p>

<p style="margin-left:11%; margin-top: 1em">That block is a
proper block like any other, so you can put more complicated
code there. This sends the message out to one of two
places:</p>

<p style="margin-left:11%; margin-top: 1em">my $ok =
&minus;x &quot;/bin/cat&quot;; <br>
print { $ok ? $fd[1] : $fd[2] } &quot;cat stat $ok\n&quot;;
<br>
print { $fd[ 1+ ($ok || 0) ] } &quot;cat stat
$ok\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">This approach
of treating &quot;print&quot; and &quot;printf&quot; like
object methods calls doesn&rsquo;t work for the diamond
operator. That&rsquo;s because it&rsquo;s a real operator,
not just a function with a comma-less argument. Assuming
you&rsquo;ve been storing typeglobs in your structure as we
did above, you can use the built-in function named
&quot;readline&quot; to read a record just as
&quot;&lt;&gt;&quot; does. Given the initialization shown
above for @fd, this would work, but only because
<b>readline()</b> requires a typeglob. It doesn&rsquo;t work
with objects or strings, which might be a bug we
haven&rsquo;t fixed yet.</p>

<p style="margin-left:11%; margin-top: 1em">$got =
readline($fd[0]);</p>

<p style="margin-left:11%; margin-top: 1em">Let it be noted
that the flakiness of indirect filehandles is not related to
whether they&rsquo;re strings, typeglobs, objects, or
anything else. It&rsquo;s the syntax of the fundamental
operators. Playing the object game doesn&rsquo;t help you at
all here.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
open a filehandle to a string?</b> <br>
(contributed by Peter J. Holzer,
hjp&minus;usenet2@hjp.at)</p>

<p style="margin-left:11%; margin-top: 1em">Since Perl
5.8.0 a file handle referring to a string can be created by
calling open with a reference to that string instead of the
filename. This file handle can then be used to read from or
write to the string:</p>

<p style="margin-left:11%; margin-top: 1em">open(my $fh,
'&gt;', \$string) or die &quot;Could not open string for
writing&quot;; <br>
print $fh &quot;foo\n&quot;; <br>
print $fh &quot;bar\n&quot;; # $string now contains
&quot;foo\nbar\n&quot; <br>
open(my $fh, '&lt;', \$string) or die &quot;Could not open
string for reading&quot;; <br>
my $x = &lt;$fh&gt;; # $x now contains &quot;foo\n&quot;</p>

<p style="margin-left:11%; margin-top: 1em">With older
versions of Perl, the IO::String module provides similar
functionality.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
set up a footer format to be used with write()?</b> <br>
There&rsquo;s no builtin way to do this, but perlform has a
couple of techniques to make it possible for the intrepid
hacker.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
write() into a string?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
&quot;write&quot; into a string, you just have to
&lt;open&gt; a filehandle to a string, which Perl has been
able to do since Perl 5.6:</p>

<p style="margin-left:11%; margin-top: 1em">open FH,
'&gt;', \my $string; <br>
write( FH );</p>

<p style="margin-left:11%; margin-top: 1em">Since you want
to be a good programmer, you probably want to use a lexical
filehandle, even though formats are designed to work with
bareword filehandles since the default format names take the
filehandle name. However, you can control this with some
Perl special per-filehandle variables: $^, which names the
top-of-page format, and $~ which shows the line format. You
have to change the default filehandle to set these
variables:</p>

<p style="margin-left:11%; margin-top: 1em">open my($fh),
'&gt;', \my $string; <br>
{ # set per&minus;filehandle variables <br>
my $old_fh = select( $fh ); <br>
$~ = 'ANIMAL'; <br>
$^ = 'ANIMAL_TOP'; <br>
select( $old_fh ); <br>
} <br>
format ANIMAL_TOP = <br>
ID Type Name <br>
. <br>
format ANIMAL = <br>
@## @&lt;&lt;&lt;
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
<br>
$id, $type, $name <br>
.</p>

<p style="margin-left:11%; margin-top: 1em">Although write
can work with lexical or package variables, whatever
variables you use have to scope in the format. That most
likely means you&rsquo;ll want to localize some package
variables:</p>

<p style="margin-left:11%; margin-top: 1em">{ <br>
local( $id, $type, $name ) = qw( 12 cat Buster ); <br>
write( $fh ); <br>
} <br>
print $string;</p>

<p style="margin-left:11%; margin-top: 1em">There are also
some tricks that you can play with &quot;formline&quot; and
the accumulator variable $^A, but you lose a lot of the
value of formats since &quot;formline&quot; won&rsquo;t
handle paging and so on. You end up reimplementing formats
when you use them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
output my numbers with commas added?</b> <br>
(contributed by brian d foy and Benjamin Goldberg)</p>

<p style="margin-left:11%; margin-top: 1em">You can use
Number::Format to separate places in a number. It handles
locale information for those of you who want to insert full
stops instead (or anything else that they want to use,
really).</p>

<p style="margin-left:11%; margin-top: 1em">This subroutine
will add commas to your number:</p>

<p style="margin-left:11%; margin-top: 1em">sub commify {
<br>
local $_ = shift; <br>
1 while s/^([&minus;+]?\d+)(\d{3})/$1,$2/; <br>
return $_; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This regex from
Benjamin Goldberg will add commas to numbers:</p>


<p style="margin-left:11%; margin-top: 1em">s/(^[&minus;+]?\d+?(?=(?&gt;(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g;</p>

<p style="margin-left:11%; margin-top: 1em">It is easier to
see with comments:</p>

<p style="margin-left:11%; margin-top: 1em">s/( <br>
^[&minus;+]? # beginning of number. <br>
\d+? # first digits before first comma <br>
(?= # followed by, (but not included in the match) : <br>
(?&gt;(?:\d{3})+) # some positive multiple of three digits.
<br>
(?!\d) # an *exact* multiple, not x * 3 + 1 or whatever.
<br>
) <br>
| # or: <br>
\G\d{3} # after the last group, get three digits <br>
(?=\d) # but they have to have more digits after them. <br>
)/$1,/xg;</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
translate tildes (~) in a filename?</b> <br>
Use the &lt;&gt; (&quot;glob()&quot;) operator, documented
in perlfunc. Versions of Perl older than 5.6 require that
you have a shell installed that groks tildes. Later versions
of Perl have this feature built in. The File::KGlob module
(available from <small>CPAN</small> ) gives more portable
glob functionality.</p>

<p style="margin-left:11%; margin-top: 1em">Within Perl,
you may use this directly:</p>

<p style="margin-left:11%; margin-top: 1em">$filename =~ s{
<br>
^ ~ # find a leading tilde <br>
( # save this in $1 <br>
[^/] # a non&minus;slash character <br>
* # repeated 0 or more times (0 means me) <br>
) <br>
}{ <br>
$1 <br>
? (getpwnam($1))[7] <br>
: ( $ENV{HOME} || $ENV{LOGDIR} ) <br>
}ex;</p>

<p style="margin-left:11%; margin-top: 1em"><b>How come
when I open a file read-write it wipes it out?</b> <br>
Because you&rsquo;re using something like this, which
truncates the file <i>then</i> gives you read-write
access:</p>

<p style="margin-left:11%; margin-top: 1em">open my $fh,
'+&gt;', '/path/name'; # WRONG (almost always)</p>

<p style="margin-left:11%; margin-top: 1em">Whoops. You
should instead use this, which will fail if the file
doesn&rsquo;t exist:</p>

<p style="margin-left:11%; margin-top: 1em">open my $fh,
'+&lt;', '/path/name'; # open for update</p>

<p style="margin-left:11%; margin-top: 1em">Using
&quot;&gt;&quot; always clobbers or creates. Using
&quot;&lt;&quot; never does either. The &quot;+&quot;
doesn&rsquo;t change this.</p>

<p style="margin-left:11%; margin-top: 1em">Here are
examples of many kinds of file opens. Those using
&quot;sysopen&quot; all assume that you&rsquo;ve pulled in
the constants from Fcntl:</p>

<p style="margin-left:11%; margin-top: 1em">use Fcntl;</p>

<p style="margin-left:11%; margin-top: 1em">To open file
for reading:</p>

<p style="margin-left:11%; margin-top: 1em">open my $fh,
'&lt;', $path or die $!; <br>
sysopen my $fh, $path, O_RDONLY or die $!;</p>

<p style="margin-left:11%; margin-top: 1em">To open file
for writing, create new file if needed or else truncate old
file:</p>

<p style="margin-left:11%; margin-top: 1em">open my $fh,
'&gt;', $path or die $!; <br>
sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT or die $!;
<br>
sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666 or die
$!;</p>

<p style="margin-left:11%; margin-top: 1em">To open file
for writing, create new file, file must not exist:</p>

<p style="margin-left:11%; margin-top: 1em">sysopen my $fh,
$path, O_WRONLY|O_EXCL|O_CREAT or die $!; <br>
sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666 or die
$!;</p>

<p style="margin-left:11%; margin-top: 1em">To open file
for appending, create if necessary:</p>

<p style="margin-left:11%; margin-top: 1em">open my $fh,
'&gt;&gt;', $path or die $!; <br>
sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT or die $!;
<br>
sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666 or
die $!;</p>

<p style="margin-left:11%; margin-top: 1em">To open file
for appending, file must exist:</p>

<p style="margin-left:11%; margin-top: 1em">sysopen my $fh,
$path, O_WRONLY|O_APPEND or die $!;</p>

<p style="margin-left:11%; margin-top: 1em">To open file
for update, file must exist:</p>

<p style="margin-left:11%; margin-top: 1em">open my $fh,
'+&lt;', $path or die $!; <br>
sysopen my $fh, $path, O_RDWR or die $!;</p>

<p style="margin-left:11%; margin-top: 1em">To open file
for update, create file if necessary:</p>

<p style="margin-left:11%; margin-top: 1em">sysopen my $fh,
$path, O_RDWR|O_CREAT or die $!; <br>
sysopen my $fh, $path, O_RDWR|O_CREAT, 0666 or die $!;</p>

<p style="margin-left:11%; margin-top: 1em">To open file
for update, file must not exist:</p>

<p style="margin-left:11%; margin-top: 1em">sysopen my $fh,
$path, O_RDWR|O_EXCL|O_CREAT or die $!; <br>
sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666 or die
$!;</p>

<p style="margin-left:11%; margin-top: 1em">To open a file
without blocking, creating if necessary:</p>

<p style="margin-left:11%; margin-top: 1em">sysopen my $fh,
'/foo/somefile', O_WRONLY|O_NDELAY|O_CREAT <br>
or die &quot;can't open /foo/somefile: $!&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">Be warned that
neither creation nor deletion of files is guaranteed to be
an atomic operation over <small>NFS.</small> That is, two
processes might both successfully create or unlink the same
file! Therefore O_EXCL isn&rsquo;t as exclusive as you might
wish.</p>

<p style="margin-left:11%; margin-top: 1em">See also
perlopentut.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why do I
sometimes get an &quot;Argument list too long&quot; when I
use &lt;*&gt;?</b> <br>
The &quot;&lt;&gt;&quot; operator performs a globbing
operation (see above). In Perl versions earlier than v5.6.0,
the internal <b>glob()</b> operator forks <b>csh</b>(1) to
do the actual glob expansion, but csh can&rsquo;t handle
more than 127 items and so gives the error message
&quot;Argument list too long&quot;. People who installed
tcsh as csh won&rsquo;t have this problem, but their users
may be surprised by it.</p>

<p style="margin-left:11%; margin-top: 1em">To get around
this, either upgrade to Perl v5.6.0 or later, do the glob
yourself with <b>readdir()</b> and patterns, or use a module
like File::Glob, one that doesn&rsquo;t use the shell to do
globbing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
open a file named with a leading &quot;&gt;&quot; or
trailing blanks?</b> <br>
(contributed by Brian McCauley)</p>

<p style="margin-left:11%; margin-top: 1em">The special
two-argument form of Perl&rsquo;s <b>open()</b> function
ignores trailing blanks in filenames and infers the mode
from certain leading characters (or a trailing
&quot;|&quot;). In older versions of Perl this was the only
version of <b>open()</b> and so it is prevalent in old code
and books.</p>

<p style="margin-left:11%; margin-top: 1em">Unless you have
a particular reason to use the two-argument form you should
use the three-argument form of <b>open()</b> which does not
treat any characters in the filename as special.</p>

<p style="margin-left:11%; margin-top: 1em">open my $fh,
&quot;&lt;&quot;, &quot; file &quot;; # filename is &quot;
file &quot; <br>
open my $fh, &quot;&gt;&quot;, &quot;&gt;file&quot;; #
filename is &quot;&gt;file&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
reliably rename a file?</b> <br>
If your operating system supports a proper <b>mv</b>(1)
utility or its functional equivalent, this works:</p>

<p style="margin-left:11%; margin-top: 1em">rename($old,
$new) or system(&quot;mv&quot;, $old, $new);</p>

<p style="margin-left:11%; margin-top: 1em">It may be more
portable to use the File::Copy module instead. You just copy
to the new file to the new name (checking return values),
then delete the old one. This isn&rsquo;t really the same
semantically as a &quot;rename()&quot;, which preserves
meta-information like permissions, timestamps, inode info,
etc.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
lock a file?</b> <br>
Perl&rsquo;s builtin <b>flock()</b> function (see perlfunc
for details) will call <b>flock</b>(2) if that exists,
<b>fcntl</b>(2) if it doesn&rsquo;t (on perl version 5.004
and later), and <b>lockf</b>(3) if neither of the two
previous system calls exists. On some systems, it may even
use a different form of native locking. Here are some
gotchas with Perl&rsquo;s <b>flock()</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Produces a fatal error if none of the three system calls
(or their close equivalent) exists.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p><b>lockf</b>(3) does not provide shared locking, and
requires that the filehandle be open for writing (or
appending, or read/writing).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Some versions of <b>flock()</b> can&rsquo;t lock files
over a network (e.g. on <small>NFS</small> file systems), so
you&rsquo;d need to force the use of <b>fcntl</b>(2) when
you build Perl. But even this is dubious at best. See the
flock entry of perlfunc and the
<i><small>INSTALL</small></i> file in the source
distribution for information on building Perl to do
this.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Two potentially
non-obvious but traditional flock semantics are that it
waits indefinitely until the lock is granted, and that its
locks are <i>merely advisory</i>. Such discretionary locks
are more flexible, but offer fewer guarantees. This means
that files locked with <b>flock()</b> may be modified by
programs that do not also use <b>flock()</b>. Cars that stop
for red lights get on well with each other, but not with
cars that don&rsquo;t stop for red lights. See the perlport
manpage, your port&rsquo;s specific documentation, or your
system-specific local manpages for details. It&rsquo;s best
to assume traditional behavior if you&rsquo;re writing
portable programs. (If you&rsquo;re not, you should as
always feel perfectly free to write for your own
system&rsquo;s idiosyncrasies (sometimes called
&quot;features&quot;). Slavish adherence to portability
concerns shouldn&rsquo;t get in the way of your getting your
job done.)</p>

<p style="margin-left:17%; margin-top: 1em">For more
information on file locking, see also &quot;File
Locking&quot; in perlopentut if you have it (new for
5.6).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why
can&rsquo;t I just open( <small>FH, &quot;</small>
&gt;file.lock&quot;)?</b> <br>
A common bit of code <b><small>NOT TO USE</small></b> is
this:</p>

<p style="margin-left:11%; margin-top: 1em">sleep(3) while
&minus;e 'file.lock'; # PLEASE DO NOT USE <br>
open my $lock, '&gt;', 'file.lock'; # THIS BROKEN CODE</p>

<p style="margin-left:11%; margin-top: 1em">This is a
classic race condition: you take two steps to do something
which must be done in one. That&rsquo;s why computer
hardware provides an atomic test-and-set instruction. In
theory, this &quot;ought&quot; to work:</p>

<p style="margin-left:11%; margin-top: 1em">sysopen my $fh,
&quot;file.lock&quot;, O_WRONLY|O_EXCL|O_CREAT <br>
or die &quot;can't open file.lock: $!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">except that
lamentably, file creation (and deletion) is not atomic over
<small>NFS,</small> so this won&rsquo;t work (at least, not
every time) over the net. Various schemes involving
<b>link()</b> have been suggested, but these tend to involve
busy-wait, which is also less than desirable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I still
don&rsquo;t get locking. I just want to increment the number
in the file. How can I do this?</b> <br>
Didn&rsquo;t anyone ever tell you web-page hit counters were
useless? They don&rsquo;t count number of hits,
they&rsquo;re a waste of time, and they serve only to stroke
the writer&rsquo;s vanity. It&rsquo;s better to pick a
random number; they&rsquo;re more realistic.</p>

<p style="margin-left:11%; margin-top: 1em">Anyway, this is
what you can do if you can&rsquo;t help yourself.</p>

<p style="margin-left:11%; margin-top: 1em">use Fcntl
qw(:DEFAULT :flock); <br>
sysopen my $fh, &quot;numfile&quot;, O_RDWR|O_CREAT or die
&quot;can't open numfile: $!&quot;; <br>
flock $fh, LOCK_EX or die &quot;can't flock numfile:
$!&quot;; <br>
my $num = &lt;$fh&gt; || 0; <br>
seek $fh, 0, 0 or die &quot;can't rewind numfile: $!&quot;;
<br>
truncate $fh, 0 or die &quot;can't truncate numfile:
$!&quot;; <br>
(print $fh $num+1, &quot;\n&quot;) or die &quot;can't write
numfile: $!&quot;; <br>
close $fh or die &quot;can't close numfile: $!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
much better web-page hit counter:</p>

<p style="margin-left:11%; margin-top: 1em">$hits = int(
(time() &minus; 850_000_000) / rand(1_000) );</p>

<p style="margin-left:11%; margin-top: 1em">If the count
doesn&rsquo;t impress your friends, then the code might.
:&minus;)</p>

<p style="margin-left:11%; margin-top: 1em"><b>All I want
to do is append a small amount of text to the end of a file.
Do I still have to use locking?</b> <br>
If you are on a system that correctly implements
&quot;flock&quot; and you use the example appending code
from &quot;perldoc &minus;f flock&quot; everything will be
<small>OK</small> even if the <small>OS</small> you are on
doesn&rsquo;t implement append mode correctly (if such a
system exists). So if you are happy to restrict yourself to
OSs that implement &quot;flock&quot; (and that&rsquo;s not
really much of a restriction) then that is what you should
do.</p>

<p style="margin-left:11%; margin-top: 1em">If you know you
are only going to use a system that does correctly implement
appending (i.e. not Win32) then you can omit the
&quot;seek&quot; from the code in the previous answer.</p>

<p style="margin-left:11%; margin-top: 1em">If you know you
are only writing code to run on an <small>OS</small> and
filesystem that does implement append mode correctly (a
local filesystem on a modern Unix for example), and you keep
the file in block-buffered mode and you write less than one
buffer-full of output between each manual flushing of the
buffer then each bufferload is almost guaranteed to be
written to the end of the file in one chunk without getting
intermingled with anyone else&rsquo;s output. You can also
use the &quot;syswrite&quot; function which is simply a
wrapper around your system&rsquo;s write(2) system call.</p>

<p style="margin-left:11%; margin-top: 1em">There is still
a small theoretical chance that a signal will interrupt the
system-level &quot;write()&quot; operation before
completion. There is also a possibility that some
<small>STDIO</small> implementations may call multiple
system level &quot;write()&quot;s even if the buffer was
empty to start. There may be some systems where this
probability is reduced to zero, and this is not a concern
when using &quot;:perlio&quot; instead of your
system&rsquo;s <small>STDIO.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
randomly update a binary file?</b> <br>
If you&rsquo;re just trying to patch a binary, in many cases
something as simple as this works:</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;i
&minus;pe 's{window manager}{window mangler}g'
/usr/bin/emacs</p>

<p style="margin-left:11%; margin-top: 1em">However, if you
have fixed sized records, then you might do something more
like this:</p>

<p style="margin-left:11%; margin-top: 1em">my $RECSIZE =
220; # size of record, in bytes <br>
my $recno = 37; # which record to update <br>
open my $fh, '+&lt;', 'somewhere' or die &quot;can't update
somewhere: $!&quot;; <br>
seek $fh, $recno * $RECSIZE, 0; <br>
read $fh, $record, $RECSIZE == $RECSIZE or die &quot;can't
read record $recno: $!&quot;; <br>
# munge the record <br>
seek $fh, &minus;$RECSIZE, 1; <br>
print $fh $record; <br>
close $fh;</p>

<p style="margin-left:11%; margin-top: 1em">Locking and
error checking are left as an exercise for the reader.
Don&rsquo;t forget them or you&rsquo;ll be quite sorry.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I get
a file&rsquo;s timestamp in perl?</b> <br>
If you want to retrieve the time at which the file was last
read, written, or had its meta-data (owner, etc) changed,
you use the <b>&minus;A</b>, <b>&minus;M</b>, or
<b>&minus;C</b> file test operations as documented in
perlfunc. These retrieve the age of the file (measured
against the start-time of your program) in days as a
floating point number. Some platforms may not have all of
these times. See perlport for details. To retrieve the
&quot;raw&quot; time in seconds since the epoch, you would
call the stat function, then use &quot;localtime()&quot;,
&quot;gmtime()&quot;, or &quot;POSIX::strftime()&quot; to
convert this into human-readable form.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s an
example:</p>

<p style="margin-left:11%; margin-top: 1em">my $write_secs
= (stat($file))[9]; <br>
printf &quot;file %s updated at %s\n&quot;, $file, <br>
scalar localtime($write_secs);</p>

<p style="margin-left:11%; margin-top: 1em">If you prefer
something more legible, use the File::stat module (part of
the standard distribution in version 5.004 and later):</p>

<p style="margin-left:11%; margin-top: 1em"># error
checking left as an exercise for reader. <br>
use File::stat; <br>
use Time::localtime; <br>
my $date_string = ctime(stat($file)&minus;&gt;mtime); <br>
print &quot;file $file updated at $date_string\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>POSIX::strftime()</b> approach has the benefit of being,
in theory, independent of the current locale. See perllocale
for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I set
a file&rsquo;s timestamp in perl?</b> <br>
You use the <b>utime()</b> function documented in
&quot;utime&quot; in perlfunc. By way of example,
here&rsquo;s a little program that copies the read and write
times from its first argument to all the rest of them.</p>

<p style="margin-left:11%; margin-top: 1em">if (@ARGV &lt;
2) { <br>
die &quot;usage: cptimes timestamp_file other_files
...\n&quot;; <br>
} <br>
my $timestamp = shift; <br>
my($atime, $mtime) = (stat($timestamp))[8,9]; <br>
utime $atime, $mtime, @ARGV;</p>

<p style="margin-left:11%; margin-top: 1em">Error checking
is, as usual, left as an exercise for the reader.</p>

<p style="margin-left:11%; margin-top: 1em">The perldoc for
utime also has an example that has the same effect as
<b>touch</b>(1) on files that <i>already exist</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Certain file
systems have a limited ability to store the times on a file
at the expected level of precision. For example, the
<small>FAT</small> and <small>HPFS</small> filesystem are
unable to create dates on files with a finer granularity
than two seconds. This is a limitation of the filesystems,
not of <b>utime()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
print to more than one file at once?</b> <br>
To connect one filehandle to several output filehandles, you
can use the IO::Tee or Tie::FileHandle::Multiplex
modules.</p>

<p style="margin-left:11%; margin-top: 1em">If you only
have to do this once, you can print individually to each
filehandle.</p>

<p style="margin-left:11%; margin-top: 1em">for my $fh
($fh1, $fh2, $fh3) { print $fh &quot;whatever\n&quot; }</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
read in an entire file all at once?</b> <br>
The customary Perl approach for processing all the lines in
a file is to do so one line at a time:</p>

<p style="margin-left:11%; margin-top: 1em">open my $input,
'&lt;', $file or die &quot;can't open $file: $!&quot;; <br>
while (&lt;$input&gt;) { <br>
chomp; <br>
# do something with $_ <br>
} <br>
close $input or die &quot;can't close $file: $!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">This is
tremendously more efficient than reading the entire file
into memory as an array of lines and then processing it one
element at a time, which is often--if not almost always--the
wrong approach. Whenever you see someone do this:</p>

<p style="margin-left:11%; margin-top: 1em">my @lines =
&lt;INPUT&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">You should
think long and hard about why you need everything loaded at
once. It&rsquo;s just not a scalable solution.</p>

<p style="margin-left:11%; margin-top: 1em">If you
&quot;mmap&quot; the file with the File::Map module from
<small>CPAN,</small> you can virtually load the entire file
into a string without actually storing it in memory:</p>

<p style="margin-left:11%; margin-top: 1em">use File::Map
qw(map_file); <br>
map_file my $string, $filename;</p>

<p style="margin-left:11%; margin-top: 1em">Once mapped,
you can treat $string as you would any other string. Since
you don&rsquo;t necessarily have to load the data, mmap-ing
can be very fast and may not increase your memory
footprint.</p>

<p style="margin-left:11%; margin-top: 1em">You might also
find it more fun to use the standard Tie::File module, or
the DB_File module&rsquo;s $DB_RECNO bindings, which allow
you to tie an array to a file so that accessing an element
of the array actually accesses the corresponding line in the
file.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
load the entire file, you can use the Path::Tiny module to
do it in one simple and efficient step:</p>

<p style="margin-left:11%; margin-top: 1em">use Path::Tiny;
<br>
my $all_of_it = path($filename)&minus;&gt;slurp; # entire
file in scalar <br>
my @all_lines = path($filename)&minus;&gt;lines; # one line
per element</p>

<p style="margin-left:11%; margin-top: 1em">Or you can read
the entire file contents into a scalar like this:</p>

<p style="margin-left:11%; margin-top: 1em">my $var; <br>
{ <br>
local $/; <br>
open my $fh, '&lt;', $file or die &quot;can't open $file:
$!&quot;; <br>
$var = &lt;$fh&gt;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">That
temporarily undefs your record separator, and will
automatically close the file at block exit. If the file is
already open, just use this:</p>

<p style="margin-left:11%; margin-top: 1em">my $var = do {
local $/; &lt;$fh&gt; };</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use a localized @ARGV to eliminate the &quot;open&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">my $var = do {
local( @ARGV, $/ ) = $file; &lt;&gt; };</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
read in a file by paragraphs?</b> <br>
Use the $/ variable (see perlvar for details). You can
either set it to &quot;&quot; to eliminate empty paragraphs
(&quot;abc\n\n\n\ndef&quot;, for instance, gets treated as
two paragraphs and not three), or &quot;\n\n&quot; to accept
empty paragraphs.</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
blank line must have no blanks in it. Thus
&quot;fred\n&nbsp;\nstuff\n\n&quot; is one paragraph, but
&quot;fred\n\nstuff\n\n&quot; is two.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
read a single character from a file? From the keyboard?</b>
<br>
You can use the builtin &quot;getc()&quot; function for most
filehandles, but it won&rsquo;t (easily) work on a terminal
device. For <small>STDIN,</small> either use the
Term::ReadKey module from <small>CPAN</small> or use the
sample code in &quot;getc&quot; in perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em">If your system
supports the portable operating system programming interface
( <small>POSIX</small> ), you can use the following code,
which you&rsquo;ll note turns off echo processing as
well.</p>


<p style="margin-left:11%; margin-top: 1em">#!/usr/bin/perl
&minus;w <br>
use strict; <br>
$| = 1; <br>
for (1..4) { <br>
print &quot;gimme: &quot;; <br>
my $got = getone(); <br>
print &quot;&minus;&minus;&gt; $got\n&quot;; <br>
} <br>
exit; <br>
BEGIN { <br>
use POSIX qw(:termios_h); <br>
my ($term, $oterm, $echo, $noecho, $fd_stdin); <br>
my $fd_stdin = fileno(STDIN); <br>
$term = POSIX::Termios&minus;&gt;new(); <br>
$term&minus;&gt;getattr($fd_stdin); <br>
$oterm = $term&minus;&gt;getlflag(); <br>
$echo = ECHO | ECHOK | ICANON; <br>
$noecho = $oterm &amp; ~$echo; <br>
sub cbreak { <br>
$term&minus;&gt;setlflag($noecho); <br>
$term&minus;&gt;setcc(VTIME, 1); <br>
$term&minus;&gt;setattr($fd_stdin, TCSANOW); <br>
} <br>
sub cooked { <br>
$term&minus;&gt;setlflag($oterm); <br>
$term&minus;&gt;setcc(VTIME, 0); <br>
$term&minus;&gt;setattr($fd_stdin, TCSANOW); <br>
} <br>
sub getone { <br>
my $key = ''; <br>
cbreak(); <br>
sysread(STDIN, $key, 1); <br>
cooked(); <br>
return $key; <br>
} <br>
} <br>
END { cooked() }</p>

<p style="margin-left:11%; margin-top: 1em">The
Term::ReadKey module from <small>CPAN</small> may be easier
to use. Recent versions include also support for
non-portable systems as well.</p>

<p style="margin-left:11%; margin-top: 1em">use
Term::ReadKey; <br>
open my $tty, '&lt;', '/dev/tty'; <br>
print &quot;Gimme a char: &quot;; <br>
ReadMode &quot;raw&quot;; <br>
my $key = ReadKey 0, $tty; <br>
ReadMode &quot;normal&quot;; <br>
printf &quot;\nYou said %s, char number %03d\n&quot;, <br>
$key, ord $key;</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
tell whether there&rsquo;s a character waiting on a
filehandle?</b> <br>
The very first thing you should do is look into getting the
Term::ReadKey extension from <small>CPAN.</small> As we
mentioned earlier, it now even has limited support for
non-portable (read: not open systems, closed, proprietary,
not <small>POSIX,</small> not Unix, etc.) systems.</p>

<p style="margin-left:11%; margin-top: 1em">You should also
check out the Frequently Asked Questions list in comp.unix.*
for things like this: the answer is essentially the same.
It&rsquo;s very system-dependent. Here&rsquo;s one solution
that works on <small>BSD</small> systems:</p>

<p style="margin-left:11%; margin-top: 1em">sub key_ready {
<br>
my($rin, $nfd); <br>
vec($rin, fileno(STDIN), 1) = 1; <br>
return $nfd = select($rin,undef,undef,0); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
find out how many characters are waiting, there&rsquo;s also
the <small>FIONREAD</small> ioctl call to be looked at. The
<i>h2ph</i> tool that comes with Perl tries to convert C
include files to Perl code, which can be
&quot;require&quot;d. <small>FIONREAD</small> ends up
defined as a function in the <i>sys/ioctl.ph</i> file:</p>

<p style="margin-left:11%; margin-top: 1em">require
'./sys/ioctl.ph'; <br>
$size = pack(&quot;L&quot;, 0); <br>
ioctl(FH, FIONREAD(), $size) or die &quot;Couldn't call
ioctl: $!\n&quot;; <br>
$size = unpack(&quot;L&quot;, $size);</p>

<p style="margin-left:11%; margin-top: 1em">If <i>h2ph</i>
wasn&rsquo;t installed or doesn&rsquo;t work for you, you
can <i>grep</i> the include files by hand:</p>

<p style="margin-left:11%; margin-top: 1em">% grep FIONREAD
/usr/include/*/* <br>
/usr/include/asm/ioctls.h:#define FIONREAD 0x541B</p>

<p style="margin-left:11%; margin-top: 1em">Or write a
small C program using the editor of champions:</p>

<p style="margin-left:11%; margin-top: 1em">% cat &gt;
fionread.c <br>
#include &lt;sys/ioctl.h&gt; <br>
main() { <br>
printf(&quot;%#08x\n&quot;, FIONREAD); <br>
} <br>
^D <br>
% cc &minus;o fionread fionread.c <br>
% ./fionread <br>
0x4004667f</p>

<p style="margin-left:11%; margin-top: 1em">And then
hard-code it, leaving porting as an exercise to your
successor.</p>

<p style="margin-left:11%; margin-top: 1em">$FIONREAD =
0x4004667f; # XXX: opsys dependent <br>
$size = pack(&quot;L&quot;, 0); <br>
ioctl(FH, $FIONREAD, $size) or die &quot;Couldn't call
ioctl: $!\n&quot;; <br>
$size = unpack(&quot;L&quot;, $size);</p>


<p style="margin-left:11%; margin-top: 1em"><small>FIONREAD</small>
requires a filehandle connected to a stream, meaning that
sockets, pipes, and tty devices work, but <i>not</i>
files.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I do
a &quot;tail &minus;f&quot; in perl?</b> <br>
First try</p>

<p style="margin-left:11%; margin-top: 1em">seek($gw_fh, 0,
1);</p>

<p style="margin-left:11%; margin-top: 1em">The statement
&quot;seek($gw_fh, 0, 1)&quot; doesn&rsquo;t change the
current position, but it does clear the end-of-file
condition on the handle, so that the next
&quot;&lt;$gw_fh&gt;&quot; makes Perl try again to read
something.</p>

<p style="margin-left:11%; margin-top: 1em">If that
doesn&rsquo;t work (it relies on features of your stdio
implementation), then you need something more like this:</p>

<p style="margin-left:11%; margin-top: 1em">for (;;) { <br>
for ($curpos = tell($gw_fh); &lt;$gw_fh&gt;; $curpos
=tell($gw_fh)) { <br>
# search for some stuff and put it into files <br>
} <br>
# sleep for a while <br>
seek($gw_fh, $curpos, 0); # seek to where we had been <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If this still
doesn&rsquo;t work, look into the &quot;clearerr&quot;
method from IO::Handle, which resets the error and
end-of-file states on the handle.</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s
also a File::Tail module from <small>CPAN.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
dup() a filehandle in Perl?</b> <br>
If you check &quot;open&quot; in perlfunc, you&rsquo;ll see
that several of the ways to call <b>open()</b> should do the
trick. For example:</p>

<p style="margin-left:11%; margin-top: 1em">open my $log,
'&gt;&gt;', '/foo/logfile'; <br>
open STDERR, '&gt;&amp;', $log;</p>

<p style="margin-left:11%; margin-top: 1em">Or even with a
literal numeric descriptor:</p>

<p style="margin-left:11%; margin-top: 1em">my $fd =
$ENV{MHCONTEXTFD}; <br>
open $mhcontext, &quot;&lt;&amp;=$fd&quot;; # like
fdopen(3S)</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;&lt;&amp;STDIN&quot; makes a copy, but
&quot;&lt;&amp;=STDIN&quot; makes an alias. That means if
you close an aliased handle, all aliases become
inaccessible. This is not true with a copied one.</p>

<p style="margin-left:11%; margin-top: 1em">Error checking,
as always, has been left as an exercise for the reader.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
close a file descriptor by number?</b> <br>
If, for some reason, you have a file descriptor instead of a
filehandle (perhaps you used &quot;POSIX::open&quot;), you
can use the &quot;close()&quot; function from the
<small>POSIX</small> module:</p>

<p style="margin-left:11%; margin-top: 1em">use POSIX ();
<br>
POSIX::close( $fd );</p>

<p style="margin-left:11%; margin-top: 1em">This should
rarely be necessary, as the Perl &quot;close()&quot;
function is to be used for things that Perl opened itself,
even if it was a dup of a numeric descriptor as with
&quot;MHCONTEXT&quot; above. But if you really have to, you
may be able to do this:</p>

<p style="margin-left:11%; margin-top: 1em">require
'./sys/syscall.ph'; <br>
my $rc = syscall(SYS_close(), $fd + 0); # must force numeric
<br>
die &quot;can't sysclose $fd: $!&quot; unless $rc ==
&minus;1;</p>

<p style="margin-left:11%; margin-top: 1em">Or, just use
the fdopen(3S) feature of &quot;open()&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">{ <br>
open my $fh, &quot;&lt;&amp;=$fd&quot; or die &quot;Cannot
reopen fd=$fd: $!&quot;; <br>
close $fh; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why
can&rsquo;t I use &quot;C:\temp\foo&quot; in
<small>DOS</small> paths? Why doesn&rsquo;t
&lsquo;C:\temp\foo.exe&lsquo; work?</b> <br>
Whoops! You just put a tab and a formfeed into that
filename! Remember that within double quoted strings
(&quot;like\this&quot;), the backslash is an escape
character. The full list of these is in &quot;Quote and
Quote-like Operators&quot; in perlop. Unsurprisingly, you
don&rsquo;t have a file called
&quot;c:(tab)emp(formfeed)oo&quot; or
&quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy
<small>DOS</small> filesystem.</p>

<p style="margin-left:11%; margin-top: 1em">Either
single-quote your strings, or (preferably) use forward
slashes. Since all <small>DOS</small> and Windows versions
since something like MS-DOS 2.0 or so have treated
&quot;/&quot; and &quot;\&quot; the same in a path, you
might as well use the one that doesn&rsquo;t clash with
Perl--or the <small>POSIX</small> shell, <small>ANSI
C</small> and C <small>++</small> , awk, Tcl, Java, or
Python, just to mention a few. <small>POSIX</small> paths
are more portable, too.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why
doesn&rsquo;t glob(&quot;*.*&quot;) get all the files?</b>
<br>
Because even on non-Unix ports, Perl&rsquo;s glob function
follows standard Unix globbing semantics. You&rsquo;ll need
&quot;glob(&quot;*&quot;)&quot; to get all (non-hidden)
files. This makes <b>glob()</b> portable even to legacy
systems. Your port may include proprietary globbing
functions as well. Check its documentation for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why does
Perl let me delete read-only files? Why does
&quot;&minus;i&quot; clobber protected files? Isn&rsquo;t
this a bug in Perl?</b> <br>
This is elaborately and painstakingly described in the
<i>file-dir-perms</i> article in the &quot;Far More Than You
Ever Wanted To Know&quot; collection in
&lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt; .</p>

<p style="margin-left:11%; margin-top: 1em">The executive
summary: learn how your filesystem works. The permissions on
a file say what can happen to the data in that file. The
permissions on a directory say what can happen to the list
of files in that directory. If you delete a file,
you&rsquo;re removing its name from the directory (so the
operation depends on the permissions of the directory, not
of the file). If you try to write to the file, the
permissions of the file govern whether you&rsquo;re allowed
to.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
select a random line from a file?</b> <br>
Short of loading the file into a database or pre-indexing
the lines in the file, there are a couple of things that you
can do.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
reservoir-sampling algorithm from the Camel Book:</p>

<p style="margin-left:11%; margin-top: 1em">srand; <br>
rand($.) &lt; 1 &amp;&amp; ($line = $_) while &lt;&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">This has a
significant advantage in space over reading the whole file
in. You can find a proof of this method in <i>The Art of
Computer Programming</i>, Volume 2, Section 3.4.2, by Donald
E. Knuth.</p>

<p style="margin-left:11%; margin-top: 1em">You can use the
File::Random module which provides a function for that
algorithm:</p>

<p style="margin-left:11%; margin-top: 1em">use
File::Random qw/random_line/; <br>
my $line = random_line($filename);</p>

<p style="margin-left:11%; margin-top: 1em">Another way is
to use the Tie::File module, which treats the entire file as
an array. Simply access a random array element.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why do I get
weird spaces when I print an array of lines?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">If you are
seeing spaces between the elements of your array when you
print the array, you are probably interpolating the array in
double quotes:</p>

<p style="margin-left:11%; margin-top: 1em">my @animals =
qw(camel llama alpaca vicuna); <br>
print &quot;animals are: @animals\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s the
double quotes, not the &quot;print&quot;, doing this.
Whenever you interpolate an array in a double quote context,
Perl joins the elements with spaces (or whatever is in
$&quot;, which is a space by default):</p>

<p style="margin-left:11%; margin-top: 1em">animals are:
camel llama alpaca vicuna</p>

<p style="margin-left:11%; margin-top: 1em">This is
different than printing the array without the
interpolation:</p>

<p style="margin-left:11%; margin-top: 1em">my @animals =
qw(camel llama alpaca vicuna); <br>
print &quot;animals are: &quot;, @animals,
&quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">Now the output
doesn&rsquo;t have the spaces between the elements because
the elements of @animals simply become part of the list to
&quot;print&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">animals are:
camelllamaalpacavicuna</p>

<p style="margin-left:11%; margin-top: 1em">You might
notice this when each of the elements of @array end with a
newline. You expect to print one element per line, but
notice that every line after the first is indented:</p>

<p style="margin-left:11%; margin-top: 1em">this is a line
<br>
this is another line <br>
this is the third line</p>

<p style="margin-left:11%; margin-top: 1em">That extra
space comes from the interpolation of the array. If you
don&rsquo;t want to put anything between your array
elements, don&rsquo;t use the array in double quotes. You
can send it to print without them:</p>

<p style="margin-left:11%; margin-top: 1em">print
@lines;</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
traverse a directory tree?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">The File::Find
module, which comes with Perl, does all of the hard work to
traverse a directory structure. It comes with Perl. You
simply call the &quot;find&quot; subroutine with a callback
subroutine and the directories you want to traverse:</p>

<p style="margin-left:11%; margin-top: 1em">use File::Find;
<br>
find( \&amp;wanted, @directories ); <br>
sub wanted { <br>
# full path in $File::Find::name <br>
# just filename in $_ <br>
... do whatever you want to do ... <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The
File::Find::Closures, which you can download from
<small>CPAN,</small> provides many ready-to-use subroutines
that you can use with File::Find.</p>

<p style="margin-left:11%; margin-top: 1em">The
File::Finder, which you can download from
<small>CPAN,</small> can help you create the callback
subroutine using something closer to the syntax of the
&quot;find&quot; command-line utility:</p>

<p style="margin-left:11%; margin-top: 1em">use File::Find;
<br>
use File::Finder; <br>
my $deep_dirs =
File::Finder&minus;&gt;depth&minus;&gt;type('d')&minus;&gt;ls&minus;&gt;exec('rmdir','{}');
<br>
find( $deep_dirs&minus;&gt;as_options, @places );</p>

<p style="margin-left:11%; margin-top: 1em">The
File::Find::Rule module, which you can download from
<small>CPAN,</small> has a similar interface, but does the
traversal for you too:</p>

<p style="margin-left:11%; margin-top: 1em">use
File::Find::Rule; <br>
my @files = File::Find::Rule&minus;&gt;file() <br>
&minus;&gt;name( '*.pm' ) <br>
&minus;&gt;in( @INC );</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
delete a directory tree?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">If you have an
empty directory, you can use Perl&rsquo;s built-in
&quot;rmdir&quot;. If the directory is not empty (so, with
files or subdirectories), you either have to empty it
yourself (a lot of work) or use a module to help you.</p>

<p style="margin-left:11%; margin-top: 1em">The File::Path
module, which comes with Perl, has a &quot;remove_tree&quot;
which can take care of all of the hard work for you:</p>

<p style="margin-left:11%; margin-top: 1em">use File::Path
qw(remove_tree); <br>
remove_tree( @directories );</p>

<p style="margin-left:11%; margin-top: 1em">The File::Path
module also has a legacy interface to the older
&quot;rmtree&quot; subroutine.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
copy an entire directory?</b> <br>
(contributed by Shlomi Fish)</p>

<p style="margin-left:11%; margin-top: 1em">To do the
equivalent of &quot;cp &minus;R&quot; (i.e. copy an entire
directory tree recursively) in portable Perl, you&rsquo;ll
either need to write something yourself or find a good
<small>CPAN</small> module such as
File::Copy::Recursive.</p>

<h2>AUTHOR AND COPYRIGHT
<a name="AUTHOR AND COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1997&minus;2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This
documentation is free; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

<p style="margin-left:11%; margin-top: 1em">Irrespective of
its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code
and any derivatives thereof in your own programs for fun or
for profit as you see fit. A simple comment in the code
giving credit to the <small>FAQ</small> would be courteous
but is not required.</p>
<hr>
</body>
</html>
