<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLRECHARCLASS</title>

</head>
<body>
<h1>perlrecharclass</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">perlrecharclass
&minus; Perl Regular Expression Character Classes</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The top level
documentation about Perl regular expressions is found in
perlre.</p>

<p style="margin-left:11%; margin-top: 1em">This manual
page discusses the syntax and use of character classes in
Perl regular expressions.</p>

<p style="margin-left:11%; margin-top: 1em">A character
class is a way of denoting a set of characters in such a way
that one character of the set is matched. It&rsquo;s
important to remember that: matching a character class
consumes exactly one character in the source string. (The
source string is the string the regular expression is
matched against.)</p>

<p style="margin-left:11%; margin-top: 1em">There are three
types of character classes in Perl regular expressions: the
dot, backslash sequences, and the form enclosed in square
brackets. Keep in mind, though, that often the term
&quot;character class&quot; is used to mean just the
bracketed form. Certainly, most Perl documentation does
that.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The dot</b>
<br>
The dot (or period), &quot;.&quot; is probably the most
used, and certainly the most well-known character class. By
default, a dot matches any character, except for the
newline. That default can be changed to add matching the
newline by using the <i>single line</i> modifier: for the
entire regular expression with the &quot;/s&quot; modifier,
or locally with &quot;(?s)&quot; (and even globally within
the scope of &quot;use re '/s'&quot;). (The &quot;\N&quot;
backslash sequence, described below, matches any character
except newline without regard to the <i>single line</i>
modifier.)</p>

<p style="margin-left:11%; margin-top: 1em">Here are some
examples:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;a&quot;
=~ /./ # Match <br>
&quot;.&quot; =~ /./ # Match <br>
&quot;&quot; =~ /./ # No match (dot has to match a
character) <br>
&quot;\n&quot; =~ /./ # No match (dot does not match a
newline) <br>
&quot;\n&quot; =~ /./s # Match (global 'single line'
modifier) <br>
&quot;\n&quot; =~ /(?s:.)/ # Match (local 'single line'
modifier) <br>
&quot;ab&quot; =~ /^.$/ # No match (dot matches one
character)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Backslash
sequences</b> <br>
A backslash sequence is a sequence of characters, the first
one of which is a backslash. Perl ascribes special meaning
to many such sequences, and some of these are character
classes. That is, they match a single character each,
provided that the character belongs to the specific set of
characters defined by the sequence.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
list of the backslash sequences that are character classes.
They are discussed in more detail below. (For the backslash
sequences that aren&rsquo;t character classes, see
perlrebackslash.)</p>

<p style="margin-left:11%; margin-top: 1em">\d Match a
decimal digit character. <br>
\D Match a non&minus;decimal&minus;digit character. <br>
\w Match a &quot;word&quot; character. <br>
\W Match a non&minus;&quot;word&quot; character. <br>
\s Match a whitespace character. <br>
\S Match a non&minus;whitespace character. <br>
\h Match a horizontal whitespace character. <br>
\H Match a character that isn't horizontal whitespace. <br>
\v Match a vertical whitespace character. <br>
\V Match a character that isn't vertical whitespace. <br>
\N Match a character that isn't a newline. <br>
\pP, \p{Prop} Match a character that has the given Unicode
property. <br>
\PP, \P{Prop} Match a character that doesn't have the
Unicode property</p>

<p style="margin-left:11%; margin-top: 1em"><i>\N</i></p>


<p style="margin-left:11%; margin-top: 1em">&quot;\N&quot;,
available starting in v5.12, like the dot, matches any
character that is not a newline. The difference is that
&quot;\N&quot; is not influenced by the <i>single line</i>
regular expression modifier (see &quot;The dot&quot; above).
Note that the form &quot;\N{...}&quot; may mean something
completely different. When the &quot;{...}&quot; is a
quantifier, it means to match a non-newline character that
many times. For example, &quot;\N{3}&quot; means to match 3
non-newlines; &quot;\N{5,}&quot; means to match 5 or more
non-newlines. But if &quot;{...}&quot; is not a legal
quantifier, it is presumed to be a named character. See
charnames for those. For example, none of
&quot;\N{COLON}&quot;, &quot;\N{4F}&quot;, and
&quot;\N{F4}&quot; contain legal quantifiers, so Perl will
try to find characters whose names are respectively
&quot;COLON&quot;, &quot;4F&quot;, and &quot;F4&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Digits</i></p>

<p style="margin-left:11%; margin-top: 1em">&quot;\d&quot;
matches a single character considered to be a decimal
<i>digit</i>. If the &quot;/a&quot; regular expression
modifier is in effect, it matches [0&minus;9]. Otherwise, it
matches anything that is matched by &quot;\p{Digit}&quot;,
which includes [0&minus;9]. (An unlikely possible exception
is that under locale matching rules, the current locale
might not have &quot;[0&minus;9]&quot; matched by
&quot;\d&quot;, and/or might match other characters whose
code point is less than 256. The only such locale
definitions that are legal would be to match
&quot;[0&minus;9]&quot; plus another set of 10 consecutive
digit characters; anything else would be in violation of the
C language standard, but Perl doesn&rsquo;t currently assume
anything in regard to this.)</p>

<p style="margin-left:11%; margin-top: 1em">What this means
is that unless the &quot;/a&quot; modifier is in effect
&quot;\d&quot; not only matches the digits &rsquo;0&rsquo;
&minus; &rsquo;9&rsquo;, but also Arabic, Devanagari, and
digits from other languages. This may cause some confusion,
and some security issues.</p>

<p style="margin-left:11%; margin-top: 1em">Some digits
that &quot;\d&quot; matches look like some of the
[0&minus;9] ones, but have different values. For example,
<small>BENGALI DIGIT FOUR</small> (U+09EA) looks very much
like an <small>ASCII DIGIT EIGHT</small> (U+0038), and
<small>LEPCHA DIGIT SIX</small> (U+1C46) looks very much
like an <small>ASCII DIGIT FIVE</small> (U+0035). An
application that is expecting only the <small>ASCII</small>
digits might be misled, or if the match is &quot;\d+&quot;,
the matched string might contain a mixture of digits from
different writing systems that look like they signify a
number different than they actually do.
&quot;<b>num()</b>&quot; in Unicode::UCD can be used to
safely calculate the value, returning &quot;undef&quot; if
the input string contains such a mixture. Otherwise, for
example, a displayed price might be deliberately different
than it appears.</p>

<p style="margin-left:11%; margin-top: 1em">What
&quot;\p{Digit}&quot; means (and hence &quot;\d&quot; except
under the &quot;/a&quot; modifier) is
&quot;\p{General_Category=Decimal_Number}&quot;, or
synonymously, &quot;\p{General_Category=Digit}&quot;.
Starting with Unicode version 4.1, this is the same set of
characters matched by &quot;\p{Numeric_Type=Decimal}&quot;.
But Unicode also has a different property with a similar
name, &quot;\p{Numeric_Type=Digit}&quot;, which matches a
completely different set of characters. These characters are
things such as &quot;CIRCLED DIGIT ONE&quot; or subscripts,
or are from writing systems that lack all ten digits.</p>

<p style="margin-left:11%; margin-top: 1em">The design
intent is for &quot;\d&quot; to exactly match the set of
characters that can safely be used with &quot;normal&quot;
big-endian positional decimal syntax, where, for example 123
means one &rsquo;hundred&rsquo;, plus two
&rsquo;tens&rsquo;, plus three &rsquo;ones&rsquo;. This
positional notation does not necessarily apply to characters
that match the other type of &quot;digit&quot;,
&quot;\p{Numeric_Type=Digit}&quot;, and so &quot;\d&quot;
doesn&rsquo;t match them.</p>

<p style="margin-left:11%; margin-top: 1em">The Tamil
digits (U+0BE6 &minus; U+0BEF) can also legally be used in
old-style Tamil numbers in which they would appear no more
than one in a row, separated by characters that mean
&quot;times 10&quot;, &quot;times 100&quot;, etc. (See
&lt;https://www.unicode.org/notes/tn21&gt;.)</p>

<p style="margin-left:11%; margin-top: 1em">Any character
not matched by &quot;\d&quot; is matched by
&quot;\D&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Word
characters</i></p>

<p style="margin-left:11%; margin-top: 1em">A
&quot;\w&quot; matches a single alphanumeric character (an
alphabetic character, or a decimal digit); or a connecting
punctuation character, such as an underscore
(&quot;_&quot;); or a &quot;mark&quot; character (like some
sort of accent) that attaches to one of those. It does not
match a whole word. To match a whole word, use
&quot;\w+&quot;. This isn&rsquo;t the same thing as matching
an English word, but in the <small>ASCII</small> range it is
the same as a string of Perl-identifier characters. <br>
If the &quot;/a&quot; modifier is in effect ...</p>

<p style="margin-left:17%;">&quot;\w&quot; matches the 63
characters [a&minus;zA&minus;Z0&minus;9_].</p>

<p style="margin-left:11%;">otherwise ...</p>

<p style="margin-left:17%;">For code points above 255
...</p>

<p style="margin-left:23%;">&quot;\w&quot; matches the same
as &quot;\p{Word}&quot; matches in this range. That is, it
matches Thai letters, Greek letters, etc. This includes
connector punctuation (like the underscore) which connect
two words together, or diacritics, such as a &quot;COMBINING
TILDE&quot; and the modifier letters, which are generally
used to add auxiliary markings to letters.</p>

<p style="margin-left:17%;">For code points below 256
...</p>

<p style="margin-left:23%;">if locale rules are in effect
...</p>

<p style="margin-left:29%;">&quot;\w&quot; matches the
platform&rsquo;s native underscore character plus whatever
the locale considers to be alphanumeric.</p>

<p style="margin-left:23%;">if, instead, Unicode rules are
in effect ...</p>

<p style="margin-left:29%;">&quot;\w&quot; matches exactly
what &quot;\p{Word}&quot; matches.</p>

<p style="margin-left:23%;">otherwise ...</p>

<p style="margin-left:29%;">&quot;\w&quot; matches
[a&minus;zA&minus;Z0&minus;9_].</p>

<p style="margin-left:11%; margin-top: 1em">Which rules
apply are determined as described in &quot;Which character
set modifier is in effect?&quot; in perlre.</p>

<p style="margin-left:11%; margin-top: 1em">There are a
number of security issues with the full Unicode list of word
characters. See &lt;http://unicode.org/reports/tr36&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Also, for a
somewhat finer-grained set of characters that are in
programming language identifiers beyond the
<small>ASCII</small> range, you may wish to instead use the
more customized &quot;Unicode Properties&quot;,
&quot;\p{ID_Start}&quot;, &quot;\p{ID_Continue}&quot;,
&quot;\p{XID_Start}&quot;, and &quot;\p{XID_Continue}&quot;.
See &lt;http://unicode.org/reports/tr31&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Any character
not matched by &quot;\w&quot; is matched by
&quot;\W&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Whitespace</i></p>

<p style="margin-left:11%; margin-top: 1em">&quot;\s&quot;
matches any single character considered whitespace. <br>
If the &quot;/a&quot; modifier is in effect ...</p>

<p style="margin-left:17%;">In all Perl versions,
&quot;\s&quot; matches the 5 characters [\t\n\f\r ]; that
is, the horizontal tab, the newline, the form feed, the
carriage return, and the space. Starting in Perl v5.18, it
also matches the vertical tab, &quot;\cK&quot;. See note
&quot;[1]&quot; below for a discussion of this.</p>

<p style="margin-left:11%;">otherwise ...</p>

<p style="margin-left:17%;">For code points above 255
...</p>

<p style="margin-left:23%;">&quot;\s&quot; matches exactly
the code points above 255 shown with an &quot;s&quot; column
in the table below.</p>

<p style="margin-left:17%;">For code points below 256
...</p>

<p style="margin-left:23%;">if locale rules are in effect
...</p>

<p style="margin-left:29%;">&quot;\s&quot; matches whatever
the locale considers to be whitespace.</p>

<p style="margin-left:23%;">if, instead, Unicode rules are
in effect ...</p>

<p style="margin-left:29%;">&quot;\s&quot; matches exactly
the characters shown with an &quot;s&quot; column in the
table below.</p>

<p style="margin-left:23%;">otherwise ...</p>

<p style="margin-left:29%;">&quot;\s&quot; matches
[\t\n\f\r ] and, starting in Perl v5.18, the vertical tab,
&quot;\cK&quot;. (See note &quot;[1]&quot; below for a
discussion of this.) Note that this list doesn&rsquo;t
include the non-breaking space.</p>

<p style="margin-left:11%; margin-top: 1em">Which rules
apply are determined as described in &quot;Which character
set modifier is in effect?&quot; in perlre.</p>

<p style="margin-left:11%; margin-top: 1em">Any character
not matched by &quot;\s&quot; is matched by
&quot;\S&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;\h&quot;
matches any character considered horizontal whitespace; this
includes the platform&rsquo;s space and tab characters and
several others listed in the table below. &quot;\H&quot;
matches any character not considered horizontal whitespace.
They use the platform&rsquo;s native character set, and do
not consider any locale that may otherwise be in use.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;\v&quot;
matches any character considered vertical whitespace; this
includes the platform&rsquo;s carriage return and line feed
characters (newline) plus several other characters, all
listed in the table below. &quot;\V&quot; matches any
character not considered vertical whitespace. They use the
platform&rsquo;s native character set, and do not consider
any locale that may otherwise be in use.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;\R&quot;
matches anything that can be considered a newline under
Unicode rules. It can match a multi-character sequence. It
cannot be used inside a bracketed character class; use
&quot;\v&quot; instead (vertical whitespace). It uses the
platform&rsquo;s native character set, and does not consider
any locale that may otherwise be in use. Details are
discussed in perlrebackslash.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
unlike &quot;\s&quot; (and &quot;\d&quot; and
&quot;\w&quot;), &quot;\h&quot; and &quot;\v&quot; always
match the same characters, without regard to other factors,
such as the active locale or whether the source string is in
<small>UTF&minus;8</small> format.</p>

<p style="margin-left:11%; margin-top: 1em">One might think
that &quot;\s&quot; is equivalent to &quot;[\h\v]&quot;.
This is indeed true starting in Perl v5.18, but prior to
that, the sole difference was that the vertical tab
(&quot;\cK&quot;) was not matched by &quot;\s&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The following
table is a complete listing of characters matched by
&quot;\s&quot;, &quot;\h&quot; and &quot;\v&quot; as of
Unicode 14.0.</p>

<p style="margin-left:11%; margin-top: 1em">The first
column gives the Unicode code point of the character (in hex
format), the second column gives the (Unicode) name. The
third column indicates by which class(es) the character is
matched (assuming no locale is in effect that changes the
&quot;\s&quot; matching).</p>

<p style="margin-left:11%; margin-top: 1em">0x0009
CHARACTER TABULATION h s <br>
0x000a LINE FEED (LF) vs <br>
0x000b LINE TABULATION vs [1] <br>
0x000c FORM FEED (FF) vs <br>
0x000d CARRIAGE RETURN (CR) vs <br>
0x0020 SPACE h s <br>
0x0085 NEXT LINE (NEL) vs [2] <br>
0x00a0 NO&minus;BREAK SPACE h s [2] <br>
0x1680 OGHAM SPACE MARK h s <br>
0x2000 EN QUAD h s <br>
0x2001 EM QUAD h s <br>
0x2002 EN SPACE h s <br>
0x2003 EM SPACE h s <br>
0x2004 THREE&minus;PER&minus;EM SPACE h s <br>
0x2005 FOUR&minus;PER&minus;EM SPACE h s <br>
0x2006 SIX&minus;PER&minus;EM SPACE h s <br>
0x2007 FIGURE SPACE h s <br>
0x2008 PUNCTUATION SPACE h s <br>
0x2009 THIN SPACE h s <br>
0x200a HAIR SPACE h s <br>
0x2028 LINE SEPARATOR vs <br>
0x2029 PARAGRAPH SEPARATOR vs <br>
0x202f NARROW NO&minus;BREAK SPACE h s <br>
0x205f MEDIUM MATHEMATICAL SPACE h s <br>
0x3000 IDEOGRAPHIC SPACE h s</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p>Prior to Perl v5.18, &quot;\s&quot; did not match the
vertical tab. &quot;[^\S\cK]&quot; (obscurely) matches what
&quot;\s&quot; traditionally did.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p><small>NEXT LINE</small> and NO-BREAK
<small>SPACE</small> may or may not match &quot;\s&quot;
depending on the rules in effect. See the beginning of this
section.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><i>Unicode
Properties</i></p>


<p style="margin-left:11%; margin-top: 1em">&quot;\pP&quot;
and &quot;\p{Prop}&quot; are character classes to match
characters that fit given Unicode properties. One letter
property names can be used in the &quot;\pP&quot; form, with
the property name following the &quot;\p&quot;, otherwise,
braces are required. When using braces, there is a single
form, which is just the property name enclosed in the
braces, and a compound form which looks like
&quot;\p{name=value}&quot;, which means to match if the
property &quot;name&quot; for the character has that
particular &quot;value&quot;. For instance, a match for a
number can be written as &quot;/\pN/&quot; or as
&quot;/\p{Number}/&quot;, or as
&quot;/\p{Number=True}/&quot;. Lowercase letters are matched
by the property <i>Lowercase_Letter</i> which has the short
form <i>Ll</i>. They need the braces, so are written as
&quot;/\p{Ll}/&quot; or &quot;/\p{Lowercase_Letter}/&quot;,
or &quot;/\p{General_Category=Lowercase_Letter}/&quot; (the
underscores are optional). &quot;/\pLl/&quot; is valid, but
means something different. It matches a two character
string: a letter (Unicode property &quot;\pL&quot;),
followed by a lowercase &quot;l&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">What a Unicode
property matches is never subject to locale rules, and if
locale rules are not otherwise in effect, the use of a
Unicode property will force the regular expression into
using Unicode rules, if it isn&rsquo;t already.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
almost all properties are immune to case-insensitive
matching. That is, adding a &quot;/i&quot; regular
expression modifier does not change what they match. But
there are two sets that are affected. The first set is
&quot;Uppercase_Letter&quot;, &quot;Lowercase_Letter&quot;,
and &quot;Titlecase_Letter&quot;, all of which match
&quot;Cased_Letter&quot; under &quot;/i&quot; matching. The
second set is &quot;Uppercase&quot;, &quot;Lowercase&quot;,
and &quot;Titlecase&quot;, all of which match
&quot;Cased&quot; under &quot;/i&quot; matching. (The
difference between these sets is that some things, such as
Roman numerals, come in both upper and lower case, so they
are &quot;Cased&quot;, but aren&rsquo;t considered to be
letters, so they aren&rsquo;t &quot;Cased_Letter&quot;s.
They&rsquo;re actually &quot;Letter_Number&quot;s.) This set
also includes its subsets &quot;PosixUpper&quot; and
&quot;PosixLower&quot;, both of which under &quot;/i&quot;
match &quot;PosixAlpha&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">For more
details on Unicode properties, see &quot;Unicode Character
Properties&quot; in perlunicode; for a complete list of
possible properties, see &quot;Properties accessible through
\p{} and \P{}&quot; in perluniprops, which notes all forms
that have &quot;/i&quot; differences. It is also possible to
define your own properties. This is discussed in
&quot;User-Defined Character Properties&quot; in
perlunicode.</p>

<p style="margin-left:11%; margin-top: 1em">Unicode
properties are defined (surprise!) only on Unicode code
points. Starting in v5.20, when matching against
&quot;\p&quot; and &quot;\P&quot;, Perl treats non-Unicode
code points (those above the legal Unicode maximum of
0x10FFFF) as if they were typical unassigned Unicode code
points.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to v5.20,
Perl raised a warning and made all matches fail on
non-Unicode code points. This could be somewhat
surprising:</p>

<p style="margin-left:11%; margin-top: 1em">chr(0x110000)
=~ \p{ASCII_Hex_Digit=True} # Fails on Perls &lt; v5.20.
<br>
chr(0x110000) =~ \p{ASCII_Hex_Digit=False} # Also fails on
Perls <br>
# &lt; v5.20</p>

<p style="margin-left:11%; margin-top: 1em">Even though
these two matches might be thought of as complements, until
v5.20 they were so only on Unicode code points.</p>

<p style="margin-left:11%; margin-top: 1em">Starting in
perl v5.30, wildcards are allowed in Unicode property
values. See &quot;Wildcards in Property Values&quot; in
perlunicode.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<p style="margin-left:11%; margin-top: 1em">&quot;a&quot;
=~ /\w/ # Match, &quot;a&quot; is a 'word' character. <br>
&quot;7&quot; =~ /\w/ # Match, &quot;7&quot; is a 'word'
character as well. <br>
&quot;a&quot; =~ /\d/ # No match, &quot;a&quot; isn't a
digit. <br>
&quot;7&quot; =~ /\d/ # Match, &quot;7&quot; is a digit.
<br>
&quot; &quot; =~ /\s/ # Match, a space is whitespace. <br>
&quot;a&quot; =~ /\D/ # Match, &quot;a&quot; is a
non&minus;digit. <br>
&quot;7&quot; =~ /\D/ # No match, &quot;7&quot; is not a
non&minus;digit. <br>
&quot; &quot; =~ /\S/ # No match, a space is not
non&minus;whitespace. <br>
&quot; &quot; =~ /\h/ # Match, space is horizontal
whitespace. <br>
&quot; &quot; =~ /\v/ # No match, space is not vertical
whitespace. <br>
&quot;\r&quot; =~ /\v/ # Match, a return is vertical
whitespace. <br>
&quot;a&quot; =~ /\pL/ # Match, &quot;a&quot; is a letter.
<br>
&quot;a&quot; =~ /\p{Lu}/ # No match, /\p{Lu}/ matches upper
case letters. <br>
&quot;\x{0e0b}&quot; =~ /\p{Thai}/ # Match, \x{0e0b} is the
character <br>
# 'THAI CHARACTER SO SO', and that's in <br>
# Thai Unicode class. <br>
&quot;a&quot; =~ /\P{Lao}/ # Match, as &quot;a&quot; is not
a Laotian character.</p>

<p style="margin-left:11%; margin-top: 1em">It is worth
emphasizing that &quot;\d&quot;, &quot;\w&quot;, etc, match
single characters, not complete numbers or words. To match a
number (that consists of digits), use &quot;\d+&quot;; to
match a word, use &quot;\w+&quot;. But be aware of the
security considerations in doing so, as mentioned above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Bracketed
Character Classes</b> <br>
The third form of character class you can use in Perl
regular expressions is the bracketed character class. In its
simplest form, it lists the characters that may be matched,
surrounded by square brackets, like this:
&quot;[aeiou]&quot;. This matches one of &quot;a&quot;,
&quot;e&quot;, &quot;i&quot;, &quot;o&quot; or
&quot;u&quot;. Like the other character classes, exactly one
character is matched.* To match a longer string consisting
of characters mentioned in the character class, follow the
character class with a quantifier. For instance,
&quot;[aeiou]+&quot; matches one or more lowercase English
vowels.</p>

<p style="margin-left:11%; margin-top: 1em">Repeating a
character in a character class has no effect; it&rsquo;s
considered to be in the set only once.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;e&quot;
=~ /[aeiou]/ # Match, as &quot;e&quot; is listed in the
class. <br>
&quot;p&quot; =~ /[aeiou]/ # No match, &quot;p&quot; is not
listed in the class. <br>
&quot;ae&quot; =~ /^[aeiou]$/ # No match, a character class
only matches <br>
# a single character. <br>
&quot;ae&quot; =~ /^[aeiou]+$/ # Match, due to the
quantifier. <br>
&minus;&minus;&minus;&minus;&minus;&minus;&minus;</p>

<p style="margin-left:11%; margin-top: 1em">* There are two
exceptions to a bracketed character class matching a single
character only. Each requires special handling by Perl to
make things work:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">When the class is to match
caselessly under &quot;/i&quot; matching rules, and a
character that is explicitly mentioned inside the class
matches a multiple-character sequence caselessly under
Unicode rules, the class will also match that sequence. For
example, Unicode says that the letter &quot;LATIN SMALL
LETTER SHARP S&quot; should match the sequence
&quot;ss&quot; under &quot;/i&quot; rules. Thus,</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">'ss' =~
/\A\N{LATIN SMALL LETTER SHARP S}\z/i # Matches <br>
'ss' =~ /\A[aeioust\N{LATIN SMALL LETTER SHARP S}]\z/i #
Matches</p>

<p style="margin-left:17%; margin-top: 1em">For this to
happen, the class must not be inverted (see
&quot;Negation&quot;) and the character must be explicitly
specified, and not be part of a multi-character range (not
even as one of its endpoints). (&quot;Character Ranges&quot;
will be explained shortly.) Therefore,</p>

<p style="margin-left:17%; margin-top: 1em">'ss' =~
/\A[\0&minus;\x{ff}]\z/ui # Doesn't match <br>
'ss' =~ /\A[\0&minus;\N{LATIN SMALL LETTER SHARP S}]\z/ui #
No match <br>
'ss' =~ /\A[\xDF&minus;\xDF]\z/ui # Matches on ASCII
platforms, since <br>
# \xDF is LATIN SMALL LETTER SHARP S, <br>
# and the range is just a single <br>
# element</p>

<p style="margin-left:17%; margin-top: 1em">Note that it
isn&rsquo;t a good idea to specify these types of ranges
anyway.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Some names known to
&quot;\N{...}&quot; refer to a sequence of multiple
characters, instead of the usual single character. When one
of these is included in the class, the entire sequence is
matched. For example,</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">&quot;\N{TAMIL
LETTER KA}\N{TAMIL VOWEL SIGN AU}&quot; <br>
=~ / ^ [\N{TAMIL SYLLABLE KAU}] $ /x;</p>

<p style="margin-left:17%; margin-top: 1em">matches,
because &quot;\N{TAMIL SYLLABLE KAU}&quot; is a named
sequence consisting of the two characters matched against.
Like the other instance where a bracketed class can match
multiple characters, and for similar reasons, the class must
not be inverted, and the named sequence may not appear in a
range, even one where it is both endpoints. If these happen,
it is a fatal error if the character class is within the
scope of &quot;use re 'strict&quot;, or within an extended
&quot;(?[...])&quot; class; otherwise only the first code
point is used (with a &quot;regexp&quot;&minus;type warning
raised).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Special
Characters Inside a Bracketed Character Class</i></p>

<p style="margin-left:11%; margin-top: 1em">Most characters
that are meta characters in regular expressions (that is,
characters that carry a special meaning like &quot;.&quot;,
&quot;*&quot;, or &quot;(&quot;) lose their special meaning
and can be used inside a character class without the need to
escape them. For instance, &quot;[()]&quot; matches either
an opening parenthesis, or a closing parenthesis, and the
parens inside the character class don&rsquo;t group or
capture. Be aware that, unless the pattern is evaluated in
single-quotish context, variable interpolation will take
place before the bracketed class is parsed:</p>

<p style="margin-left:11%; margin-top: 1em">$, = &quot;\t|
&quot;; <br>
$a =~ m'[$,]'; # single&minus;quotish: matches '$' or ','
<br>
$a =~ q{[$,]}' # same <br>
$a =~ m/[$,]/; # double&minus;quotish: Because we made an
<br>
# assignment to $, above, this now <br>
# matches &quot;\t&quot;, &quot;|&quot;, or &quot;
&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Characters that
may carry a special meaning inside a character class are:
&quot;\&quot;, &quot;^&quot;, &quot;&minus;&quot;,
&quot;[&quot; and &quot;]&quot;, and are discussed below.
They can be escaped with a backslash, although this is
sometimes not needed, in which case the backslash may be
omitted.</p>

<p style="margin-left:11%; margin-top: 1em">The sequence
&quot;\b&quot; is special inside a bracketed character
class. While outside the character class, &quot;\b&quot; is
an assertion indicating a point that does not have either
two word characters or two non-word characters on either
side, inside a bracketed character class, &quot;\b&quot;
matches a backspace character.</p>

<p style="margin-left:11%; margin-top: 1em">The sequences
&quot;\a&quot;, &quot;\c&quot;, &quot;\e&quot;,
&quot;\f&quot;, &quot;\n&quot;, &quot;\N{<i>NAME</i>}&quot;,
&quot;\N{U+<i>hex char</i>}&quot;, &quot;\r&quot;,
&quot;\t&quot;, and &quot;\x&quot; are also special and have
the same meanings as they do outside a bracketed character
class.</p>

<p style="margin-left:11%; margin-top: 1em">Also, a
backslash followed by two or three octal digits is
considered an octal number.</p>

<p style="margin-left:11%; margin-top: 1em">A &quot;[&quot;
is not special inside a character class, unless it&rsquo;s
the start of a <small>POSIX</small> character class (see
&quot; <small>POSIX</small> Character Classes&quot; below).
It normally does not need escaping.</p>

<p style="margin-left:11%; margin-top: 1em">A &quot;]&quot;
is normally either the end of a <small>POSIX</small>
character class (see &quot; <small>POSIX</small> Character
Classes&quot; below), or it signals the end of the bracketed
character class. If you want to include a &quot;]&quot; in
the set of characters, you must generally escape it.</p>

<p style="margin-left:11%; margin-top: 1em">However, if the
&quot;]&quot; is the <i>first</i> (or the second if the
first character is a caret) character of a bracketed
character class, it does not denote the end of the class (as
you cannot have an empty class) and is considered part of
the set of characters that can be matched without
escaping.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;+&quot;
=~ /[+?*]/ # Match, &quot;+&quot; in a character class is
not special. <br>
&quot;\cH&quot; =~ /[\b]/ # Match, \b inside in a character
class <br>
# is equivalent to a backspace. <br>
&quot;]&quot; =~ /[][]/ # Match, as the character class
contains <br>
# both [ and ]. <br>
&quot;[]&quot; =~ /[[]]/ # Match, the pattern contains a
character class <br>
# containing just [, and the character class is <br>
# followed by a ].</p>

<p style="margin-left:11%; margin-top: 1em"><i>Bracketed
Character Classes and the &quot;/xx&quot; pattern
modifier</i></p>

<p style="margin-left:11%; margin-top: 1em">Normally
<small>SPACE</small> and <small>TAB</small> characters have
no special meaning inside a bracketed character class; they
are just added to the list of characters matched by the
class. But if the &quot;/xx&quot; pattern modifier is in
effect, they are generally ignored and can be added to
improve readability. They can&rsquo;t be added in the middle
of a single construct:</p>

<p style="margin-left:11%; margin-top: 1em">/ [ \x{10 FFFF}
] /xx # WRONG!</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>SPACE</small> in the middle of the hex constant is
illegal.</p>

<p style="margin-left:11%; margin-top: 1em">To specify a
literal <small>SPACE</small> character, you can escape it
with a backslash, like:</p>

<p style="margin-left:11%; margin-top: 1em">/[ a e i o u \
]/xx</p>

<p style="margin-left:11%; margin-top: 1em">This matches
the English vowels plus the <small>SPACE</small>
character.</p>

<p style="margin-left:11%; margin-top: 1em">For clarity,
you should already have been using &quot;\t&quot; to specify
a literal tab, and &quot;\t&quot; is unaffected by
&quot;/xx&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Character
Ranges</i></p>

<p style="margin-left:11%; margin-top: 1em">It is not
uncommon to want to match a range of characters. Luckily,
instead of listing all characters in the range, one may use
the hyphen (&quot;&minus;&quot;). If inside a bracketed
character class you have two characters separated by a
hyphen, it&rsquo;s treated as if all characters between the
two were in the class. For instance, &quot;[0&minus;9]&quot;
matches any <small>ASCII</small> digit, and
&quot;[a&minus;m]&quot; matches any lowercase letter from
the first half of the <small>ASCII</small> alphabet.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
two characters on either side of the hyphen are not
necessarily both letters or both digits. Any character is
possible, although not advisable. &quot;['&minus;?]&quot;
contains a range of characters, but most people will not
know which characters that means. Furthermore, such ranges
may lead to portability problems if the code has to run on a
platform that uses a different character set, such as
<small>EBCDIC.</small></p>

<p style="margin-left:11%; margin-top: 1em">If a hyphen in
a character class cannot syntactically be part of a range,
for instance because it is the first or the last character
of the character class, or if it immediately follows a
range, the hyphen isn&rsquo;t special, and so is considered
a character to be matched literally. If you want a hyphen in
your set of characters to be matched and its position in the
class is such that it could be considered part of a range,
you must escape that hyphen with a backslash.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">[a&minus;z] #
Matches a character that is a lower case ASCII letter. <br>
[a&minus;fz] # Matches any letter between 'a' and 'f'
(inclusive) or <br>
# the letter 'z'. <br>
[&minus;z] # Matches either a hyphen ('&minus;') or the
letter 'z'. <br>
[a&minus;f&minus;m] # Matches any letter between 'a' and 'f'
(inclusive), the <br>
# hyphen ('&minus;'), or the letter 'm'. <br>
['&minus;?] # Matches any of the characters
'()*+,&minus;./0123456789:;&lt;=&gt;? <br>
# (But not on an EBCDIC platform). <br>
[\N{APOSTROPHE}&minus;\N{QUESTION MARK}] <br>
# Matches any of the characters
'()*+,&minus;./0123456789:;&lt;=&gt;? <br>
# even on an EBCDIC platform. <br>
[\N{U+27}&minus;\N{U+3F}] # Same. (U+27 is &quot;'&quot;,
and U+3F is &quot;?&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">As the final
two examples above show, you can achieve portability to
non-ASCII platforms by using the &quot;\N{...}&quot; form
for the range endpoints. These indicate that the specified
range is to be interpreted using Unicode values, so
&quot;[\N{U+27}&minus;\N{U+3F}]&quot; means to match
&quot;\N{U+27}&quot;, &quot;\N{U+28}&quot;,
&quot;\N{U+29}&quot;, ..., &quot;\N{U+3D}&quot;,
&quot;\N{U+3E}&quot;, and &quot;\N{U+3F}&quot;, whatever the
native code point versions for those are. These are called
&quot;Unicode&quot; ranges. If either end is of the
&quot;\N{...}&quot; form, the range is considered Unicode. A
&quot;regexp&quot; warning is raised under
&quot;use&nbsp;re&nbsp;'strict'&quot; if the other endpoint
is specified non-portably:</p>


<p style="margin-left:11%; margin-top: 1em">[\N{U+00}&minus;\x09]
# Warning under re 'strict'; \x09 is non&minus;portable <br>
[\N{U+00}&minus;\t] # No warning;</p>

<p style="margin-left:11%; margin-top: 1em">Both of the
above match the characters &quot;\N{U+00}&quot;
&quot;\N{U+01}&quot;, ... &quot;\N{U+08}&quot;,
&quot;\N{U+09}&quot;, but the &quot;\x09&quot; looks like it
could be a mistake so the warning is raised (under &quot;re
'strict'&quot;) for it.</p>

<p style="margin-left:11%; margin-top: 1em">Perl also
guarantees that the ranges &quot;A&minus;Z&quot;,
&quot;a&minus;z&quot;, &quot;0&minus;9&quot;, and any
subranges of these match what an English-only speaker would
expect them to match on any platform. That is,
&quot;[A&minus;Z]&quot; matches the 26 <small>ASCII</small>
uppercase letters; &quot;[a&minus;z]&quot; matches the 26
lowercase letters; and &quot;[0&minus;9]&quot; matches the
10 digits. Subranges, like &quot;[h&minus;k]&quot;, match
correspondingly, in this case just the four letters
&quot;h&quot;, &quot;i&quot;, &quot;j&quot;, and
&quot;k&quot;. This is the natural behavior on
<small>ASCII</small> platforms where the code points
(ordinal values) for &quot;h&quot; through &quot;k&quot; are
consecutive integers (0x68 through 0x6B). But special
handling to achieve this may be needed on platforms with a
non-ASCII native character set. For example, on
<small>EBCDIC</small> platforms, the code point for
&quot;h&quot; is 0x88, &quot;i&quot; is 0x89, &quot;j&quot;
is 0x91, and &quot;k&quot; is 0x92. Perl specially treats
&quot;[h&minus;k]&quot; to exclude the seven code points in
the gap: 0x8A through 0x90. This special handling is only
invoked when the range is a subrange of one of the
<small>ASCII</small> uppercase, lowercase, and digit ranges,
<small>AND</small> each end of the range is expressed either
as a literal, like &quot;A&quot;, or as a named character
(&quot;\N{...}&quot;, including the &quot;\N{U+...&quot;
form).</p>


<p style="margin-left:11%; margin-top: 1em"><small>EBCDIC</small>
Examples:</p>

<p style="margin-left:11%; margin-top: 1em">[i&minus;j] #
Matches either &quot;i&quot; or &quot;j&quot; <br>
[i&minus;\N{LATIN SMALL LETTER J}] # Same <br>
[i&minus;\N{U+6A}] # Same <br>
[\N{U+69}&minus;\N{U+6A}] # Same <br>
[\x{89}&minus;\x{91}] # Matches 0x89 (&quot;i&quot;), 0x8A
.. 0x90, 0x91 (&quot;j&quot;) <br>
[i&minus;\x{91}] # Same <br>
[\x{89}&minus;j] # Same <br>
[i&minus;J] # Matches, 0x89 (&quot;i&quot;) .. 0xC1
(&quot;J&quot;); special <br>
# handling doesn't apply because range is mixed <br>
# case</p>


<p style="margin-left:11%; margin-top: 1em"><i>Negation</i></p>

<p style="margin-left:11%; margin-top: 1em">It is also
possible to instead list the characters you do not want to
match. You can do so by using a caret (&quot;^&quot;) as the
first character in the character class. For instance,
&quot;[^a&minus;z]&quot; matches any character that is not a
lowercase <small>ASCII</small> letter, which therefore
includes more than a million Unicode code points. The class
is said to be &quot;negated&quot; or
&quot;inverted&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This syntax
make the caret a special character inside a bracketed
character class, but only if it is the first character of
the class. So if you want the caret as one of the characters
to match, either escape the caret or else don&rsquo;t list
it first.</p>

<p style="margin-left:11%; margin-top: 1em">In inverted
bracketed character classes, Perl ignores the Unicode rules
that normally say that named sequence, and certain
characters should match a sequence of multiple characters
use under caseless &quot;/i&quot; matching. Following those
rules could lead to highly confusing situations:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;ss&quot;
=~ /^[^\xDF]+$/ui; # Matches!</p>

<p style="margin-left:11%; margin-top: 1em">This should
match any sequences of characters that aren&rsquo;t
&quot;\xDF&quot; nor what &quot;\xDF&quot; matches under
&quot;/i&quot;. &quot;s&quot; isn&rsquo;t &quot;\xDF&quot;,
but Unicode says that &quot;ss&quot; is what
&quot;\xDF&quot; matches under &quot;/i&quot;. So which one
&quot;wins&quot;? Do you fail the match because the string
has &quot;ss&quot; or accept it because it has an
&quot;s&quot; followed by another &quot;s&quot;? Perl has
chosen the latter. (See note in &quot;Bracketed Character
Classes&quot; above.)</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;e&quot;
=~ /[^aeiou]/ # No match, the 'e' is listed. <br>
&quot;x&quot; =~ /[^aeiou]/ # Match, as 'x' isn't a
lowercase vowel. <br>
&quot;^&quot; =~ /[^^]/ # No match, matches anything that
isn't a caret. <br>
&quot;^&quot; =~ /[x^]/ # Match, caret is not special
here.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Backslash
Sequences</i></p>

<p style="margin-left:11%; margin-top: 1em">You can put any
backslash sequence character class (with the exception of
&quot;\N&quot; and &quot;\R&quot;) inside a bracketed
character class, and it will act just as if you had put all
characters matched by the backslash sequence inside the
character class. For instance, &quot;[a&minus;f\d]&quot;
matches any decimal digit, or any of the lowercase letters
between &rsquo;a&rsquo; and &rsquo;f&rsquo; inclusive.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;\N&quot;
within a bracketed character class must be of the forms
&quot;\N{<i>name</i>}&quot; or &quot;\N{U+<i>hex
char</i>}&quot;, and <small>NOT</small> be the form that
matches non-newlines, for the same reason that a dot
&quot;.&quot; inside a bracketed character class loses its
special meaning: it matches nearly anything, which generally
isn&rsquo;t what you want to happen.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">/[\p{Thai}\d]/
# Matches a character that is either a Thai <br>
# character, or a digit. <br>
/[^\p{Arabic}()]/ # Matches a character that is neither an
Arabic <br>
# character, nor a parenthesis.</p>

<p style="margin-left:11%; margin-top: 1em">Backslash
sequence character classes cannot form one of the endpoints
of a range. Thus, you can&rsquo;t say:</p>


<p style="margin-left:11%; margin-top: 1em">/[\p{Thai}&minus;\d]/
# Wrong!</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>POSIX</small>
Character Classes</i></p>


<p style="margin-left:11%; margin-top: 1em"><small>POSIX</small>
character classes have the form &quot;[:class:]&quot;, where
<i>class</i> is the name, and the &quot;[:&quot; and
&quot;:]&quot; delimiters. <small>POSIX</small> character
classes only appear <i>inside</i> bracketed character
classes, and are a convenient and descriptive way of listing
a group of characters.</p>

<p style="margin-left:11%; margin-top: 1em">Be careful
about the syntax,</p>

<p style="margin-left:11%; margin-top: 1em"># Correct: <br>
$string =~ /[[:alpha:]]/ <br>
# Incorrect (will warn): <br>
$string =~ /[:alpha:]/</p>

<p style="margin-left:11%; margin-top: 1em">The latter
pattern would be a character class consisting of a colon,
and the letters &quot;a&quot;, &quot;l&quot;, &quot;p&quot;
and &quot;h&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><small>POSIX</small>
character classes can be part of a larger bracketed
character class. For example,</p>


<p style="margin-left:11%; margin-top: 1em">[01[:alpha:]%]</p>

<p style="margin-left:11%; margin-top: 1em">is valid and
matches &rsquo;0&rsquo;, &rsquo;1&rsquo;, any alphabetic
character, and the percent sign.</p>

<p style="margin-left:11%; margin-top: 1em">Perl recognizes
the following <small>POSIX</small> character classes:</p>

<p style="margin-left:11%; margin-top: 1em">alpha Any
alphabetical character (e.g., [A&minus;Za&minus;z]). <br>
alnum Any alphanumeric character (e.g.,
[A&minus;Za&minus;z0&minus;9]). <br>
ascii Any character in the ASCII character set. <br>
blank A GNU extension, equal to a space or a horizontal tab
(&quot;\t&quot;). <br>
cntrl Any control character. See Note [2] below. <br>
digit Any decimal digit (e.g., [0&minus;9]), equivalent to
&quot;\d&quot;. <br>
graph Any printable character, excluding a space. See Note
[3] below. <br>
lower Any lowercase character (e.g., [a&minus;z]). <br>
print Any printable character, including a space. See Note
[4] below. <br>
punct Any graphical character excluding &quot;word&quot;
characters. Note [5]. <br>
space Any whitespace character. &quot;\s&quot; including the
vertical tab <br>
(&quot;\cK&quot;). <br>
upper Any uppercase character (e.g., [A&minus;Z]). <br>
word A Perl extension (e.g.,
[A&minus;Za&minus;z0&minus;9_]), equivalent to
&quot;\w&quot;. <br>
xdigit Any hexadecimal digit (e.g.,
[0&minus;9a&minus;fA&minus;F]). Note [7].</p>

<p style="margin-left:11%; margin-top: 1em">Like the
Unicode properties, most of the <small>POSIX</small>
properties match the same regardless of whether
case-insensitive (&quot;/i&quot;) matching is in effect or
not. The two exceptions are &quot;[:upper:]&quot; and
&quot;[:lower:]&quot;. Under &quot;/i&quot;, they each match
the union of &quot;[:upper:]&quot; and
&quot;[:lower:]&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Most
<small>POSIX</small> character classes have two
Unicode-style &quot;\p&quot; property counterparts. (They
are not official Unicode properties, but Perl extensions
derived from official Unicode properties.) The table below
shows the relation between <small>POSIX</small> character
classes and these counterparts.</p>

<p style="margin-left:11%; margin-top: 1em">One
counterpart, in the column labelled &quot;ASCII-range
Unicode&quot; in the table, matches only characters in the
<small>ASCII</small> character set.</p>

<p style="margin-left:11%; margin-top: 1em">The other
counterpart, in the column labelled &quot;Full-range
Unicode&quot;, matches any appropriate characters in the
full Unicode character set. For example,
&quot;\p{Alpha}&quot; matches not just the
<small>ASCII</small> alphabetic characters, but any
character in the entire Unicode character set considered
alphabetic. An entry in the column labelled &quot;backslash
sequence&quot; is a (short) equivalent.</p>

<p style="margin-left:11%; margin-top: 1em">[[:...:]]
ASCII&minus;range Full&minus;range backslash Note <br>
Unicode Unicode sequence <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
alpha \p{PosixAlpha} \p{XPosixAlpha} <br>
alnum \p{PosixAlnum} \p{XPosixAlnum} <br>
ascii \p{ASCII} <br>
blank \p{PosixBlank} \p{XPosixBlank} \h [1] <br>
or \p{HorizSpace} [1] <br>
cntrl \p{PosixCntrl} \p{XPosixCntrl} [2] <br>
digit \p{PosixDigit} \p{XPosixDigit} \d <br>
graph \p{PosixGraph} \p{XPosixGraph} [3] <br>
lower \p{PosixLower} \p{XPosixLower} <br>
print \p{PosixPrint} \p{XPosixPrint} [4] <br>
punct \p{PosixPunct} \p{XPosixPunct} [5] <br>
\p{PerlSpace} \p{XPerlSpace} \s [6] <br>
space \p{PosixSpace} \p{XPosixSpace} [6] <br>
upper \p{PosixUpper} \p{XPosixUpper} <br>
word \p{PosixWord} \p{XPosixWord} \w <br>
xdigit \p{PosixXDigit} \p{XPosixXDigit} [7]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">&quot;\p{Blank}&quot; and
&quot;\p{HorizSpace}&quot; are synonyms.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>Control characters don&rsquo;t produce output as such,
but instead usually control the terminal somehow: for
example, newline and backspace are control characters. On
<small>ASCII</small> platforms, in the <small>ASCII</small>
range, characters whose code points are between 0 and 31
inclusive, plus 127 (&quot;DEL&quot;) are control
characters; on <small>EBCDIC</small> platforms, their
counterparts are control characters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[3]</p></td>
<td width="2%"></td>
<td width="83%">


<p>Any character that is <i>graphical</i>, that is,
visible. This class consists of all alphanumeric characters
and all punctuation characters.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[4]</p></td>
<td width="2%"></td>
<td width="83%">


<p>All printable characters, which is the set of all
graphical characters plus those whitespace characters which
are not also controls.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[5]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;\p{PosixPunct}&quot; and &quot;[[:punct:]]&quot;
in the <small>ASCII</small> range match all non-controls,
non-alphanumeric, non-space characters:
&quot;[&minus;!&quot;#$%&amp;'()*+,./:;&lt;=&gt;?@[\\\]^_`{|}~]&quot;
(although if a locale is in effect, it could alter the
behavior of &quot;[[:punct:]]&quot;).</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The similarly
named property, &quot;\p{Punct}&quot;, matches a somewhat
different set in the <small>ASCII</small> range, namely
&quot;[&minus;!&quot;#%&amp;'()*,./:;?@[\\\]_{}]&quot;. That
is, it is missing the nine characters
&quot;[$+&lt;=&gt;^`|~]&quot;. This is because Unicode
splits what <small>POSIX</small> considers to be punctuation
into two categories, Punctuation and Symbols.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;\p{XPosixPunct}&quot;
and (under Unicode rules) &quot;[[:punct:]]&quot;, match
what &quot;\p{PosixPunct}&quot; matches in the
<small>ASCII</small> range, plus what &quot;\p{Punct}&quot;
matches. This is different than strictly matching according
to &quot;\p{Punct}&quot;. Another way to say it is that if
Unicode rules are in effect, &quot;[[:punct:]]&quot; matches
all characters that Unicode considers punctuation, plus all
ASCII-range characters that Unicode considers symbols.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[6]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">&quot;\p{XPerlSpace}&quot; and
&quot;\p{Space}&quot; match identically starting with Perl
v5.18. In earlier versions, these differ only in that in
non-locale matching, &quot;\p{XPerlSpace}&quot; did not
match the vertical tab, &quot;\cK&quot;. Same for the two
ASCII-only range forms.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[7]</p></td>
<td width="2%"></td>
<td width="83%">


<p>Unlike &quot;[[:digit:]]&quot; which matches digits in
many writing systems, such as Thai and Devanagari, there are
currently only two sets of hexadecimal digits, and it is
unlikely that more will be added. This is because you not
only need the ten digits, but also the six
&quot;[A&minus;F]&quot; (and &quot;[a&minus;f]&quot;) to
correspond. That means only the Latin script is suitable for
these, and Unicode has only two sets of these, the familiar
<small>ASCII</small> set, and the fullwidth forms starting
at U+FF10 ( <small>FULLWIDTH DIGIT ZERO</small> ).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">There are
various other synonyms that can be used besides the names
listed in the table. For example,
&quot;\p{XPosixAlpha}&quot; can be written as
&quot;\p{Alpha}&quot;. All are listed in &quot;Properties
accessible through \p{} and \P{}&quot; in perluniprops.</p>

<p style="margin-left:11%; margin-top: 1em">Both the
&quot;\p&quot; counterparts always assume Unicode rules are
in effect. On <small>ASCII</small> platforms, this means
they assume that the code points from 128 to 255 are
Latin&minus;1, and that means that using them under locale
rules is unwise unless the locale is guaranteed to be
Latin&minus;1 or <small>UTF&minus;8.</small> In contrast,
the <small>POSIX</small> character classes are useful under
locale rules. They are affected by the actual rules in
effect, as follows: <br>
If the &quot;/a&quot; modifier, is in effect ...</p>

<p style="margin-left:17%;">Each of the
<small>POSIX</small> classes matches exactly the same as
their ASCII-range counterparts.</p>

<p style="margin-left:11%;">otherwise ...</p>

<p style="margin-left:17%;">For code points above 255
...</p>

<p style="margin-left:23%;">The <small>POSIX</small> class
matches the same as its Full-range counterpart.</p>

<p style="margin-left:17%;">For code points below 256
...</p>

<p style="margin-left:23%;">if locale rules are in effect
...</p>

<p style="margin-left:29%;">The <small>POSIX</small> class
matches according to the locale, except: <br>
&quot;word&quot;</p>

<p style="margin-left:35%;">also includes the
platform&rsquo;s native underscore character, no matter what
the locale is.</p>

<p style="margin-left:29%;">&quot;ascii&quot;</p>

<p style="margin-left:35%;">on platforms that don&rsquo;t
have the <small>POSIX</small> &quot;ascii&quot; extension,
this matches just the platform&rsquo;s native ASCII-range
characters.</p>

<p style="margin-left:29%;">&quot;blank&quot;</p>

<p style="margin-left:35%;">on platforms that don&rsquo;t
have the <small>POSIX</small> &quot;blank&quot; extension,
this matches just the platform&rsquo;s native tab and space
characters.</p>

<p style="margin-left:23%;">if, instead, Unicode rules are
in effect ...</p>

<p style="margin-left:29%;">The <small>POSIX</small> class
matches the same as the Full-range counterpart.</p>

<p style="margin-left:23%;">otherwise ...</p>

<p style="margin-left:29%;">The <small>POSIX</small> class
matches the same as the <small>ASCII</small> range
counterpart.</p>

<p style="margin-left:11%; margin-top: 1em">Which rules
apply are determined as described in &quot;Which character
set modifier is in effect?&quot; in perlre.</p>

<p style="margin-left:11%; margin-top: 1em">Negation of
<small>POSIX</small> character classes</p>

<p style="margin-left:11%; margin-top: 1em">A Perl
extension to the <small>POSIX</small> character class is the
ability to negate it. This is done by prefixing the class
name with a caret (&quot;^&quot;). Some examples:</p>

<p style="margin-left:11%; margin-top: 1em">POSIX
ASCII&minus;range Full&minus;range backslash <br>
Unicode Unicode sequence <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
[[:^digit:]] \P{PosixDigit} \P{XPosixDigit} \D <br>
[[:^space:]] \P{PosixSpace} \P{XPosixSpace} <br>
\P{PerlSpace} \P{XPerlSpace} \S <br>
[[:^word:]] \P{PerlWord} \P{XPosixWord} \W</p>

<p style="margin-left:11%; margin-top: 1em">The backslash
sequence can mean either <small>ASCII&minus;</small> or
Full-range Unicode, depending on various factors as
described in &quot;Which character set modifier is in
effect?&quot; in perlre.</p>

<p style="margin-left:11%; margin-top: 1em">[= =] and [.
.]</p>

<p style="margin-left:11%; margin-top: 1em">Perl recognizes
the <small>POSIX</small> character classes
&quot;[=class=]&quot; and &quot;[.class.]&quot;, but does
not (yet?) support them. Any attempt to use either construct
raises an exception.</p>

<p style="margin-left:11%; margin-top: 1em">Examples</p>

<p style="margin-left:11%; margin-top: 1em">/[[:digit:]]/ #
Matches a character that is a digit. <br>
/[01[:lower:]]/ # Matches a character that is either a <br>
# lowercase letter, or '0' or '1'. <br>
/[[:digit:][:^xdigit:]]/ # Matches a character that can be
anything <br>
# except the letters 'a' to 'f' and 'A' to <br>
# 'F'. This is because the main character <br>
# class is composed of two POSIX character <br>
# classes that are ORed together, one that <br>
# matches any digit, and the other that <br>
# matches anything that isn't a hex digit. <br>
# The OR adds the digits, leaving only the <br>
# letters 'a' to 'f' and 'A' to 'F' excluded.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Extended
Bracketed Character Classes</i></p>

<p style="margin-left:11%; margin-top: 1em">This is a fancy
bracketed character class that can be used for more readable
and less error-prone classes, and to perform set operations,
such as intersection. An example is</p>

<p style="margin-left:11%; margin-top: 1em">/(?[ \p{Thai}
&amp; \p{Digit} ])/</p>

<p style="margin-left:11%; margin-top: 1em">This will match
all the digit characters that are in the Thai script.</p>

<p style="margin-left:11%; margin-top: 1em">This feature
became available in Perl 5.18, as experimental; accepted in
5.36.</p>

<p style="margin-left:11%; margin-top: 1em">The rules used
by &quot;use re 'strict&quot; apply to this construct.</p>

<p style="margin-left:11%; margin-top: 1em">We can extend
the example above:</p>

<p style="margin-left:11%; margin-top: 1em">/(?[ ( \p{Thai}
+ \p{Lao} ) &amp; \p{Digit} ])/</p>

<p style="margin-left:11%; margin-top: 1em">This matches
digits that are in either the Thai or Laotian scripts.</p>

<p style="margin-left:11%; margin-top: 1em">Notice the
white space in these examples. This construct always has the
&quot;/xx&quot; modifier turned on within it.</p>

<p style="margin-left:11%; margin-top: 1em">The available
binary operators are:</p>

<p style="margin-left:11%; margin-top: 1em">&amp;
intersection <br>
+ union <br>
| another name for '+', hence means union <br>
&minus; subtraction (the result matches the set consisting
of those <br>
code points matched by the first operand, excluding any that
<br>
are also matched by the second operand) <br>
^ symmetric difference (the union minus the intersection).
This <br>
is like an exclusive or, in that the result is the set of
code <br>
points that are matched by either, but not both, of the <br>
operands.</p>

<p style="margin-left:11%; margin-top: 1em">There is one
unary operator:</p>

<p style="margin-left:11%; margin-top: 1em">!
complement</p>

<p style="margin-left:11%; margin-top: 1em">All the binary
operators left associate; &quot;&amp;&quot; is higher
precedence than the others, which all have equal precedence.
The unary operator right associates, and has highest
precedence. Thus this follows the normal Perl precedence
rules for logical operators. Use parentheses to override the
default precedence and associativity.</p>

<p style="margin-left:11%; margin-top: 1em">The main
restriction is that everything is a metacharacter. Thus, you
cannot refer to single characters by doing something like
this:</p>

<p style="margin-left:11%; margin-top: 1em">/(?[ a + b ])/
# Syntax error!</p>

<p style="margin-left:11%; margin-top: 1em">The easiest way
to specify an individual typable character is to enclose it
in brackets:</p>

<p style="margin-left:11%; margin-top: 1em">/(?[ [a] + [b]
])/</p>

<p style="margin-left:11%; margin-top: 1em">(This is the
same thing as &quot;[ab]&quot;.) You could also have said
the equivalent:</p>

<p style="margin-left:11%; margin-top: 1em">/(?[[ a b
]])/</p>

<p style="margin-left:11%; margin-top: 1em">(You can, of
course, specify single characters by using,
&quot;\x{...}&quot;, &quot;\N{...}&quot;, etc.)</p>

<p style="margin-left:11%; margin-top: 1em">This last
example shows the use of this construct to specify an
ordinary bracketed character class without additional set
operations. Note the white space within it. This is allowed
because &quot;/xx&quot; is automatically turned on within
this construct.</p>

<p style="margin-left:11%; margin-top: 1em">All the other
escapes accepted by normal bracketed character classes are
accepted here as well.</p>

<p style="margin-left:11%; margin-top: 1em">Because this
construct compiles under &quot;use re 'strict&quot;,
unrecognized escapes that generate warnings in normal
classes are fatal errors here, as well as all other warnings
from these class elements, as well as some practices that
don&rsquo;t currently warn outside &quot;re 'strict'&quot;.
For example you cannot say</p>

<p style="margin-left:11%; margin-top: 1em">/(?[ [ \xF ]
])/ # Syntax error!</p>

<p style="margin-left:11%; margin-top: 1em">You have to
have two hex digits after a braceless &quot;\x&quot; (use a
leading zero to make two). These restrictions are to lower
the incidence of typos causing the class to not match what
you thought it would.</p>

<p style="margin-left:11%; margin-top: 1em">If a regular
bracketed character class contains a &quot;\p{}&quot; or
&quot;\P{}&quot; and is matched against a non-Unicode code
point, a warning may be raised, as the result is not
Unicode-defined. No such warning will come when using this
extended form.</p>

<p style="margin-left:11%; margin-top: 1em">The final
difference between regular bracketed character classes and
these, is that it is not possible to get these to match a
multi-character fold. Thus,</p>

<p style="margin-left:11%; margin-top: 1em">/(?[ [\xDF]
])/iu</p>

<p style="margin-left:11%; margin-top: 1em">does not match
the string &quot;ss&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You don&rsquo;t
have to enclose <small>POSIX</small> class names inside
double brackets, hence both of the following work:</p>

<p style="margin-left:11%; margin-top: 1em">/(?[ [:word:]
&minus; [:lower:] ])/ <br>
/(?[ [[:word:]] &minus; [[:lower:]] ])/</p>

<p style="margin-left:11%; margin-top: 1em">Any contained
<small>POSIX</small> character classes, including things
like &quot;\w&quot; and &quot;\D&quot; respect the
&quot;/a&quot; (and &quot;/aa&quot;) modifiers.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;(?[ ])&quot; is a regex-compile-time construct. Any
attempt to use something which isn&rsquo;t knowable at the
time the containing regular expression is compiled is a
fatal error. In practice, this means just three
limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>When compiled within the scope of &quot;use locale&quot;
(or the &quot;/l&quot; regex modifier), this construct
assumes that the execution-time locale will be a
<small>UTF&minus;8</small> one, and the generated pattern
always uses Unicode rules. What gets matched or not thus
isn&rsquo;t dependent on the actual runtime locale, so
tainting is not enabled. But a &quot;locale&quot; category
warning is raised if the runtime locale turns out to not be
<small>UTF&minus;8.</small></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Any user-defined property used must be already defined
by the time the regular expression is compiled (but note
that this construct can be used instead of such
properties).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>A regular expression that otherwise would compile using
&quot;/d&quot; rules, and which uses this construct will
instead use &quot;/u&quot;. Thus this construct tells Perl
that you don&rsquo;t want &quot;/d&quot; rules for the
entire regular expression containing it.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that
skipping white space applies only to the interior of this
construct. There must not be any space between any of the
characters that form the initial &quot;(?[&quot;. Nor may
there be space between the closing &quot;])&quot;
characters.</p>

<p style="margin-left:11%; margin-top: 1em">Just as in all
regular expressions, the pattern can be built up by
including variables that are interpolated at regex
compilation time. But currently each such sub-component
should be an already-compiled extended bracketed character
class.</p>

<p style="margin-left:11%; margin-top: 1em">my $thai_or_lao
= qr/(?[ \p{Thai} + \p{Lao} ])/; <br>
... <br>
qr/(?[ \p{Digit} &amp; $thai_or_lao ])/;</p>

<p style="margin-left:11%; margin-top: 1em">If you
interpolate something else, the pattern may still compile
(or it may die), but if it compiles, it very well may not
behave as you would expect:</p>

<p style="margin-left:11%; margin-top: 1em">my $thai_or_lao
= '\p{Thai} + \p{Lao}'; <br>
qr/(?[ \p{Digit} &amp; $thai_or_lao ])/;</p>

<p style="margin-left:11%; margin-top: 1em">compiles to</p>

<p style="margin-left:11%; margin-top: 1em">qr/(?[
\p{Digit} &amp; \p{Thai} + \p{Lao} ])/;</p>

<p style="margin-left:11%; margin-top: 1em">This does not
have the effect that someone reading the source code would
likely expect, as the intersection applies just to
&quot;\p{Thai}&quot;, excluding the Laotian.</p>

<p style="margin-left:11%; margin-top: 1em">Due to the way
that Perl parses things, your parentheses and brackets may
need to be balanced, even including comments. If you run
into any examples, please submit them to
&lt;https://github.com/Perl/perl5/issues&gt;, so that we can
have a concrete example for this man page.</p>
<hr>
</body>
</html>
