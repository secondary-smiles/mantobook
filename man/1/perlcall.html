<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:58 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLCALL</title>

</head>
<body>
<h1>perlcall</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlcall
&minus; Perl calling conventions from C</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The purpose of
this document is to show you how to call Perl subroutines
directly from C, i.e., how to write <i>callbacks</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Apart from
discussing the C interface provided by Perl for writing
callbacks the document uses a series of examples to show how
the interface actually works in practice. In addition some
techniques for coding callbacks are covered.</p>

<p style="margin-left:11%; margin-top: 1em">Examples where
callbacks are necessary include</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="25%">


<p>An Error Handler</p></td>
<td width="57%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">You have
created an <small>XSUB</small> interface to an
application&rsquo;s C <small>API.</small></p>

<p style="margin-left:18%; margin-top: 1em">A fairly common
feature in applications is to allow you to define a C
function that will be called whenever something nasty
occurs. What we would like is to be able to specify a Perl
subroutine that will be called instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="36%">


<p style="margin-top: 1em">An Event-Driven Program</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The classic
example of where callbacks are used is when writing an event
driven program, such as for an X11 application. In this case
you register functions to be called whenever specific events
occur, e.g., a mouse button is pressed, the cursor moves
into a window or a menu item is selected.</p>

<p style="margin-left:11%; margin-top: 1em">Although the
techniques described here are applicable when embedding Perl
in a C program, this is not the primary goal of this
document. There are other details that must be considered
and are specific to embedding Perl. For details on embedding
Perl in C refer to perlembed.</p>

<p style="margin-left:11%; margin-top: 1em">Before you
launch yourself head first into the rest of this document,
it would be a good idea to have read the following two
documents--perlxs and perlguts.</p>

<h2>THE CALL_ FUNCTIONS
<a name="THE CALL_ FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Although this
stuff is easier to explain using examples, you first need be
aware of a few important definitions.</p>

<p style="margin-left:11%; margin-top: 1em">Perl has a
number of C functions that allow you to call Perl
subroutines. They are</p>

<p style="margin-left:11%; margin-top: 1em">I32 call_sv(SV*
sv, I32 flags); <br>
I32 call_pv(char *subname, I32 flags); <br>
I32 call_method(char *methname, I32 flags); <br>
I32 call_argv(char *subname, I32 flags, char **argv);</p>

<p style="margin-left:11%; margin-top: 1em">The key
function is <i>call_sv</i>. All the other functions are
fairly simple wrappers which make it easier to call Perl
subroutines in special cases. At the end of the day they
will all call <i>call_sv</i> to invoke the Perl
subroutine.</p>

<p style="margin-left:11%; margin-top: 1em">All the
<i>call_*</i> functions have a &quot;flags&quot; parameter
which is used to pass a bit mask of options to Perl. This
bit mask operates identically for each of the functions. The
settings available in the bit mask are discussed in &quot;
<small>FLAG VALUES&quot;</small> .</p>

<p style="margin-left:11%; margin-top: 1em">Each of the
functions will now be discussed in turn. <br>
call_sv</p>

<p style="margin-left:18%;"><i>call_sv</i> takes two
parameters. The first, &quot;sv&quot;, is an SV*. This
allows you to specify the Perl subroutine to be called
either as a C string (which has first been converted to an
<small>SV</small> ) or a reference to a subroutine. The
section, &quot;Using call_sv&quot;, shows how you can make
use of <i>call_sv</i>.</p>

<p style="margin-left:11%;">call_pv</p>

<p style="margin-left:18%;">The function, <i>call_pv</i>,
is similar to <i>call_sv</i> except it expects its first
parameter to be a C char* which identifies the Perl
subroutine you want to call, e.g.,
&quot;call_pv(&quot;fred&quot;, 0)&quot;. If the subroutine
you want to call is in another package, just include the
package name in the string, e.g., &quot;pkg::fred&quot;.</p>

<p style="margin-left:11%;">call_method</p>

<p style="margin-left:18%;">The function <i>call_method</i>
is used to call a method from a Perl class. The parameter
&quot;methname&quot; corresponds to the name of the method
to be called. Note that the class that the method belongs to
is passed on the Perl stack rather than in the parameter
list. This class can be either the name of the class (for a
static method) or a reference to an object (for a virtual
method). See perlobj for more information on static and
virtual methods and &quot;Using call_method&quot; for an
example of using <i>call_method</i>.</p>

<p style="margin-left:11%;">call_argv</p>

<p style="margin-left:18%;"><i>call_argv</i> calls the Perl
subroutine specified by the C string stored in the
&quot;subname&quot; parameter. It also takes the usual
&quot;flags&quot; parameter. The final parameter,
&quot;argv&quot;, consists of a NULL-terminated list of C
strings to be passed as parameters to the Perl subroutine.
See &quot;Using call_argv&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">All the
functions return an integer. This is a count of the number
of items returned by the Perl subroutine. The actual items
returned by the subroutine are stored on the Perl stack.</p>

<p style="margin-left:11%; margin-top: 1em">As a general
rule you should <i>always</i> check the return value from
these functions. Even if you are expecting only a particular
number of values to be returned from the Perl subroutine,
there is nothing to stop someone from doing something
unexpected--don&rsquo;t say you haven&rsquo;t been
warned.</p>

<h2>FLAG VALUES
<a name="FLAG VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
&quot;flags&quot; parameter in all the <i>call_*</i>
functions is one of &quot;G_VOID&quot;,
&quot;G_SCALAR&quot;, or &quot;G_LIST&quot;, which indicate
the call context, <small>OR</small> &rsquo;ed together with
a bit mask of any combination of the other G_* symbols
defined below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>G_VOID</b>
<br>
Calls the Perl subroutine in a void context.</p>

<p style="margin-left:11%; margin-top: 1em">This flag has 2
effects:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="82%">


<p>It indicates to the subroutine being called that it is
executing in a void context (if it executes <i>wantarray</i>
the result will be the undefined value).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>It ensures that nothing is actually returned from the
subroutine.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The value
returned by the <i>call_*</i> function indicates how many
items have been returned by the Perl subroutine--in this
case it will be 0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>G_SCALAR</b>
<br>
Calls the Perl subroutine in a scalar context. This is the
default context flag setting for all the <i>call_*</i>
functions.</p>

<p style="margin-left:11%; margin-top: 1em">This flag has 2
effects:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">It indicates to the subroutine
being called that it is executing in a scalar context (if it
executes <i>wantarray</i> the result will be false).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>It ensures that only a scalar is actually returned from
the subroutine. The subroutine can, of course, ignore the
<i>wantarray</i> and return a list anyway. If so, then only
the last element of the list will be returned.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The value
returned by the <i>call_*</i> function indicates how many
items have been returned by the Perl subroutine &minus; in
this case it will be either 0 or 1.</p>

<p style="margin-left:11%; margin-top: 1em">If 0, then you
have specified the G_DISCARD flag.</p>

<p style="margin-left:11%; margin-top: 1em">If 1, then the
item actually returned by the Perl subroutine will be stored
on the Perl stack &minus; the section &quot;Returning a
Scalar&quot; shows how to access this value on the stack.
Remember that regardless of how many items the Perl
subroutine returns, only the last one will be accessible
from the stack &minus; think of the case where only one
value is returned as being a list with only one element. Any
other items that were returned will not exist by the time
control returns from the <i>call_*</i> function. The section
&quot;Returning a List in Scalar Context&quot; shows an
example of this behavior.</p>

<p style="margin-left:11%; margin-top: 1em"><b>G_LIST</b>
<br>
Calls the Perl subroutine in a list context. Prior to Perl
version 5.35.1 this was called &quot;G_ARRAY&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">As with
G_SCALAR, this flag has 2 effects:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">It indicates to the subroutine
being called that it is executing in a list context (if it
executes <i>wantarray</i> the result will be true).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>It ensures that all items returned from the subroutine
will be accessible when control returns from the
<i>call_*</i> function.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The value
returned by the <i>call_*</i> function indicates how many
items have been returned by the Perl subroutine.</p>

<p style="margin-left:11%; margin-top: 1em">If 0, then you
have specified the G_DISCARD flag.</p>

<p style="margin-left:11%; margin-top: 1em">If not 0, then
it will be a count of the number of items returned by the
subroutine. These items will be stored on the Perl stack.
The section &quot;Returning a List of Values&quot; gives an
example of using the G_LIST flag and the mechanics of
accessing the returned items from the Perl stack.</p>


<p style="margin-left:11%; margin-top: 1em"><b>G_DISCARD</b>
<br>
By default, the <i>call_*</i> functions place the items
returned from by the Perl subroutine on the stack. If you
are not interested in these items, then setting this flag
will make Perl get rid of them automatically for you. Note
that it is still possible to indicate a context to the Perl
subroutine by using either G_SCALAR or G_LIST.</p>

<p style="margin-left:11%; margin-top: 1em">If you do not
set this flag then it is <i>very</i> important that you make
sure that any temporaries (i.e., parameters passed to the
Perl subroutine and values returned from the subroutine) are
disposed of yourself. The section &quot;Returning a
Scalar&quot; gives details of how to dispose of these
temporaries explicitly and the section &quot;Using Perl to
Dispose of Temporaries&quot; discusses the specific
circumstances where you can ignore the problem and let Perl
deal with it for you.</p>


<p style="margin-left:11%; margin-top: 1em"><b>G_NOARGS</b>
<br>
Whenever a Perl subroutine is called using one of the
<i>call_*</i> functions, it is assumed by default that
parameters are to be passed to the subroutine. If you are
not passing any parameters to the Perl subroutine, you can
save a bit of time by setting this flag. It has the effect
of not creating the @_ array for the Perl subroutine.</p>

<p style="margin-left:11%; margin-top: 1em">Although the
functionality provided by this flag may seem
straightforward, it should be used only if there is a good
reason to do so. The reason for being cautious is that, even
if you have specified the G_NOARGS flag, it is still
possible for the Perl subroutine that has been called to
think that you have passed it parameters.</p>

<p style="margin-left:11%; margin-top: 1em">In fact, what
can happen is that the Perl subroutine you have called can
access the @_ array from a previous Perl subroutine. This
will occur when the code that is executing the <i>call_*</i>
function has itself been called from another Perl
subroutine. The code below illustrates this</p>

<p style="margin-left:11%; margin-top: 1em">sub fred <br>
{ print &quot;@_\n&quot; } <br>
sub joe <br>
{ &amp;fred } <br>
&amp;joe(1,2,3);</p>

<p style="margin-left:11%; margin-top: 1em">This will
print</p>

<p style="margin-left:11%; margin-top: 1em">1 2 3</p>

<p style="margin-left:11%; margin-top: 1em">What has
happened is that &quot;fred&quot; accesses the @_ array
which belongs to &quot;joe&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>G_EVAL</b>
<br>
It is possible for the Perl subroutine you are calling to
terminate abnormally, e.g., by calling <i>die</i> explicitly
or by not actually existing. By default, when either of
these events occurs, the process will terminate immediately.
If you want to trap this type of event, specify the G_EVAL
flag. It will put an <i>eval { }</i> around the subroutine
call.</p>

<p style="margin-left:11%; margin-top: 1em">Whenever
control returns from the <i>call_*</i> function you need to
check the $@ variable as you would in a normal Perl
script.</p>

<p style="margin-left:11%; margin-top: 1em">The value
returned from the <i>call_*</i> function is dependent on
what other flags have been specified and whether an error
has occurred. Here are all the different cases that can
occur:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">If the <i>call_*</i> function
returns normally, then the value returned is as specified in
the previous sections.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>If G_DISCARD is specified, the return value will always
be 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>If G_LIST is specified <i>and</i> an error has occurred,
the return value will always be 0.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>If G_SCALAR is specified <i>and</i> an error has
occurred, the return value will be 1 and the value on the
top of the stack will be <i>undef</i>. This means that if
you have already detected the error by checking $@ and you
want the program to continue, you must remember to pop the
<i>undef</i> from the stack.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">See &quot;Using
G_EVAL&quot; for details on using G_EVAL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>G_KEEPERR</b>
<br>
Using the G_EVAL flag described above will always set $@:
clearing it if there was no error, and setting it to
describe the error if there was an error in the called code.
This is what you want if your intention is to handle
possible errors, but sometimes you just want to trap errors
and stop them interfering with the rest of the program.</p>

<p style="margin-left:11%; margin-top: 1em">This scenario
will mostly be applicable to code that is meant to be called
from within destructors, asynchronous callbacks, and signal
handlers. In such situations, where the code being called
has little relation to the surrounding dynamic context, the
main program needs to be insulated from errors in the called
code, even if they can&rsquo;t be handled intelligently. It
may also be useful to do this with code for
&quot;__DIE__&quot; or &quot;__WARN__&quot; hooks, and
&quot;tie&quot; functions.</p>

<p style="margin-left:11%; margin-top: 1em">The G_KEEPERR
flag is meant to be used in conjunction with G_EVAL in
<i>call_*</i> functions that are used to implement such
code, or with &quot;eval_sv&quot;. This flag has no effect
on the &quot;call_*&quot; functions when G_EVAL is not
used.</p>

<p style="margin-left:11%; margin-top: 1em">When G_KEEPERR
is used, any error in the called code will terminate the
call as usual, and the error will not propagate beyond the
call (as usual for G_EVAL), but it will not go into $@.
Instead the error will be converted into a warning, prefixed
with the string &quot;\t(in cleanup)&quot;. This can be
disabled using &quot;no warnings 'misc'&quot;. If there is
no error, $@ will not be cleared.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
G_KEEPERR flag does not propagate into inner evals; these
may still set $@.</p>

<p style="margin-left:11%; margin-top: 1em">The G_KEEPERR
flag was introduced in Perl version 5.002.</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;Using
G_KEEPERR&quot; for an example of a situation that warrants
the use of this flag.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Determining
the Context</b> <br>
As mentioned above, you can determine the context of the
currently executing subroutine in Perl with
<i>wantarray</i>. The equivalent test can be made in C by
using the &quot;GIMME_V&quot; macro, which returns
&quot;G_LIST&quot; if you have been called in a list
context, &quot;G_SCALAR&quot; if in a scalar context, or
&quot;G_VOID&quot; if in a void context (i.e., the return
value will not be used). An older version of this macro is
called &quot;GIMME&quot;; in a void context it returns
&quot;G_SCALAR&quot; instead of &quot;G_VOID&quot;. An
example of using the &quot;GIMME_V&quot; macro is shown in
section &quot;Using <small>GIMME_V&quot;</small> .</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Enough of the
definition talk! Let&rsquo;s have a few examples.</p>

<p style="margin-left:11%; margin-top: 1em">Perl provides
many macros to assist in accessing the Perl stack. Wherever
possible, these macros should always be used when
interfacing to Perl internals. We hope this should make the
code less vulnerable to any changes made to Perl in the
future.</p>

<p style="margin-left:11%; margin-top: 1em">Another point
worth noting is that in the first series of examples I have
made use of only the <i>call_pv</i> function. This has been
done to keep the code simpler and ease you into the topic.
Wherever possible, if the choice is between using
<i>call_pv</i> and <i>call_sv</i>, you should always try to
use <i>call_sv</i>. See &quot;Using call_sv&quot; for
details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>No
Parameters, Nothing Returned</b> <br>
This first trivial example will call a Perl subroutine,
<i>PrintUID</i>, to print out the <small>UID</small> of the
process.</p>

<p style="margin-left:11%; margin-top: 1em">sub PrintUID
<br>
{ <br>
print &quot;UID is $&lt;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">and here is a C
function to call it</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
call_PrintUID() <br>
{ <br>
dSP; <br>
PUSHMARK(SP); <br>
call_pv(&quot;PrintUID&quot;, G_DISCARD|G_NOARGS); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Simple, eh?</p>

<p style="margin-left:11%; margin-top: 1em">A few points to
note about this example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Ignore &quot;dSP&quot; and
&quot;PUSHMARK(SP)&quot; for now. They will be discussed in
the next example.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>We aren&rsquo;t passing any parameters to
<i>PrintUID</i> so G_NOARGS can be specified.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="4%"></td>
<td width="82%">


<p>We aren&rsquo;t interested in anything returned from
<i>PrintUID</i>, so G_DISCARD is specified. Even if
<i>PrintUID</i> was changed to return some value(s), having
specified G_DISCARD will mean that they will be wiped by the
time control returns from <i>call_pv</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="4%"></td>
<td width="82%">


<p>As <i>call_pv</i> is being used, the Perl subroutine is
specified as a C string. In this case the subroutine name
has been &rsquo;hard&minus;wired&rsquo; into the code.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="4%"></td>
<td width="82%">


<p>Because we specified G_DISCARD, it is not necessary to
check the value returned from <i>call_pv</i>. It will always
be 0.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Passing
Parameters</b> <br>
Now let&rsquo;s make a slightly more complex example. This
time we want to call a Perl subroutine,
&quot;LeftString&quot;, which will take 2 parameters--a
string ($s) and an integer ($n). The subroutine will simply
print the first $n characters of the string.</p>

<p style="margin-left:11%; margin-top: 1em">So the Perl
subroutine would look like this:</p>

<p style="margin-left:11%; margin-top: 1em">sub LeftString
<br>
{ <br>
my($s, $n) = @_; <br>
print substr($s, 0, $n), &quot;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The C function
required to call <i>LeftString</i> would look like this:</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
call_LeftString(a, b) <br>
char * a; <br>
int b; <br>
{ <br>
dSP; <br>
ENTER; <br>
SAVETMPS; <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(sv_2mortal(newSVpv(a, 0))); <br>
PUSHs(sv_2mortal(newSViv(b))); <br>
PUTBACK; <br>
call_pv(&quot;LeftString&quot;, G_DISCARD); <br>
FREETMPS; <br>
LEAVE; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Here are a few
notes on the C function <i>call_LeftString</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Parameters are passed to the
Perl subroutine using the Perl stack. This is the purpose of
the code beginning with the line &quot;dSP&quot; and ending
with the line &quot;PUTBACK&quot;. The &quot;dSP&quot;
declares a local copy of the stack pointer. This local copy
should <b>always</b> be accessed as &quot;SP&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>If you are going to put something onto the Perl stack,
you need to know where to put it. This is the purpose of the
macro &quot;dSP&quot;&minus;&minus;it declares and
initializes a <i>local</i> copy of the Perl stack
pointer.</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">All the other
macros which will be used in this example require you to
have used this macro.</p>

<p style="margin-left:18%; margin-top: 1em">The exception
to this rule is if you are calling a Perl subroutine
directly from an <small>XSUB</small> function. In this case
it is not necessary to use the &quot;dSP&quot; macro
explicitly--it will be declared for you automatically.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Any parameters to be pushed onto
the stack should be bracketed by the &quot;PUSHMARK&quot;
and &quot;PUTBACK&quot; macros. The purpose of these two
macros, in this context, is to count the number of
parameters you are pushing automatically. Then whenever Perl
is creating the @_ array for the subroutine, it knows how
big to make it.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The
&quot;PUSHMARK&quot; macro tells Perl to make a mental note
of the current stack pointer. Even if you aren&rsquo;t
passing any parameters (like the example shown in the
section &quot;No Parameters, Nothing Returned&quot;) you
must still call the &quot;PUSHMARK&quot; macro before you
can call any of the <i>call_*</i> functions--Perl still
needs to know that there are no parameters.</p>

<p style="margin-left:18%; margin-top: 1em">The
&quot;PUTBACK&quot; macro sets the global copy of the stack
pointer to be the same as our local copy. If we didn&rsquo;t
do this, <i>call_pv</i> wouldn&rsquo;t know where the two
parameters we pushed were--remember that up to now all the
stack pointer manipulation we have done is with our local
copy, <i>not</i> the global copy.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Next, we come to
<small>EXTEND</small> and PUSHs. This is where the
parameters actually get pushed onto the stack. In this case
we are pushing a string and an integer.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Alternatively
you can use the <b>XPUSHs()</b> macro, which combines a
&quot;EXTEND(SP, 1)&quot; and &quot;PUSHs()&quot;. This is
less efficient if you&rsquo;re pushing multiple values.</p>

<p style="margin-left:18%; margin-top: 1em">See &quot;XSUBs
and the Argument Stack&quot; in perlguts for details on how
the <small>PUSH</small> macros work.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">5.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Because we created temporary
values (by means of <b>sv_2mortal()</b> calls) we will have
to tidy up the Perl stack and dispose of mortal SVs.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">This is the
purpose of</p>

<p style="margin-left:18%; margin-top: 1em">ENTER; <br>
SAVETMPS;</p>

<p style="margin-left:18%; margin-top: 1em">at the start of
the function, and</p>

<p style="margin-left:18%; margin-top: 1em">FREETMPS; <br>
LEAVE;</p>

<p style="margin-left:18%; margin-top: 1em">at the end. The
&quot;ENTER&quot;/&quot;SAVETMPS&quot; pair creates a
boundary for any temporaries we create. This means that the
temporaries we get rid of will be limited to those which
were created after these calls.</p>

<p style="margin-left:18%; margin-top: 1em">The
&quot;FREETMPS&quot;/&quot;LEAVE&quot; pair will get rid of
any values returned by the Perl subroutine (see next
example), plus it will also dump the mortal SVs we have
created. Having &quot;ENTER&quot;/&quot;SAVETMPS&quot; at
the beginning of the code makes sure that no other mortals
are destroyed.</p>

<p style="margin-left:18%; margin-top: 1em">Think of these
macros as working a bit like &quot;{&quot; and &quot;}&quot;
in Perl to limit the scope of local variables.</p>

<p style="margin-left:18%; margin-top: 1em">See the section
&quot;Using Perl to Dispose of Temporaries&quot; for details
of an alternative to using these macros.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">6.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Finally, <i>LeftString</i> can
now be called via the <i>call_pv</i> function. The only flag
specified this time is G_DISCARD. Because we are passing 2
parameters to the Perl subroutine this time, we have not
specified G_NOARGS.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Returning a
Scalar</b> <br>
Now for an example of dealing with the items returned from a
Perl subroutine.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a Perl
subroutine, <i>Adder</i>, that takes 2 integer parameters
and simply returns their sum.</p>

<p style="margin-left:11%; margin-top: 1em">sub Adder <br>
{ <br>
my($a, $b) = @_; <br>
$a + $b; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Because we are
now concerned with the return value from <i>Adder</i>, the C
function required to call it is now a bit more complex.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
call_Adder(a, b) <br>
int a; <br>
int b; <br>
{ <br>
dSP; <br>
int count; <br>
ENTER; <br>
SAVETMPS; <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(sv_2mortal(newSViv(a))); <br>
PUSHs(sv_2mortal(newSViv(b))); <br>
PUTBACK; <br>
count = call_pv(&quot;Adder&quot;, G_SCALAR); <br>
SPAGAIN; <br>
if (count != 1) <br>
croak(&quot;Big trouble\n&quot;); <br>
printf (&quot;The sum of %d and %d is %d\n&quot;, a, b,
POPi); <br>
PUTBACK; <br>
FREETMPS; <br>
LEAVE; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Points to note
this time are</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">The only flag specified this
time was G_SCALAR. That means that the @_ array will be
created and that the value returned by <i>Adder</i> will
still exist after the call to <i>call_pv</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>The purpose of the macro &quot;SPAGAIN&quot; is to
refresh the local copy of the stack pointer. This is
necessary because it is possible that the memory allocated
to the Perl stack has been reallocated during the
<i>call_pv</i> call.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">If you are
making use of the Perl stack pointer in your code you must
always refresh the local copy using <small>SPAGAIN</small>
whenever you make use of the <i>call_*</i> functions or any
other Perl internal function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Although only a single value was
expected to be returned from <i>Adder</i>, it is still good
practice to check the return code from <i>call_pv</i>
anyway.</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Expecting a
single value is not quite the same as knowing that there
will be one. If someone modified <i>Adder</i> to return a
list and we didn&rsquo;t check for that possibility and take
appropriate action the Perl stack would end up in an
inconsistent state. That is something you <i>really</i>
don&rsquo;t want to happen ever.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">The &quot;POPi&quot; macro is
used here to pop the return value from the stack. In this
case we wanted an integer, so &quot;POPi&quot; was used.</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Here is the
complete list of <small>POP</small> macros available, along
with the types they return.</p>

<p style="margin-left:18%; margin-top: 1em">POPs SV <br>
POPp pointer (PV) <br>
POPpbytex pointer to bytes (PV) <br>
POPn double (NV) <br>
POPi integer (IV) <br>
POPu unsigned integer (UV) <br>
POPl long <br>
POPul unsigned long</p>

<p style="margin-left:18%; margin-top: 1em">Since these
macros have side-effects don&rsquo;t use them as arguments
to macros that may evaluate their argument several times,
for example:</p>

<p style="margin-left:18%; margin-top: 1em">/* Bad idea,
don't do this */ <br>
STRLEN len; <br>
const char *s = SvPV(POPs, len);</p>

<p style="margin-left:18%; margin-top: 1em">Instead, use a
temporary:</p>

<p style="margin-left:18%; margin-top: 1em">STRLEN len;
<br>
SV *sv = POPs; <br>
const char *s = SvPV(sv, len);</p>

<p style="margin-left:18%; margin-top: 1em">or a macro that
guarantees it will evaluate its arguments only once:</p>

<p style="margin-left:18%; margin-top: 1em">STRLEN len;
<br>
const char *s = SvPVx(POPs, len);</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">5.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">The final &quot;PUTBACK&quot; is
used to leave the Perl stack in a consistent state before
exiting the function. This is necessary because when we
popped the return value from the stack with &quot;POPi&quot;
it updated only our local copy of the stack pointer.
Remember, &quot;PUTBACK&quot; sets the global stack pointer
to be the same as our local copy.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Returning a
List of Values</b> <br>
Now, let&rsquo;s extend the previous example to return both
the sum of the parameters and the difference.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
Perl subroutine</p>

<p style="margin-left:11%; margin-top: 1em">sub AddSubtract
<br>
{ <br>
my($a, $b) = @_; <br>
($a+$b, $a&minus;$b); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">and this is the
C function</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
call_AddSubtract(a, b) <br>
int a; <br>
int b; <br>
{ <br>
dSP; <br>
int count; <br>
ENTER; <br>
SAVETMPS; <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(sv_2mortal(newSViv(a))); <br>
PUSHs(sv_2mortal(newSViv(b))); <br>
PUTBACK; <br>
count = call_pv(&quot;AddSubtract&quot;, G_LIST); <br>
SPAGAIN; <br>
if (count != 2) <br>
croak(&quot;Big trouble\n&quot;); <br>
printf (&quot;%d &minus; %d = %d\n&quot;, a, b, POPi); <br>
printf (&quot;%d + %d = %d\n&quot;, a, b, POPi); <br>
PUTBACK; <br>
FREETMPS; <br>
LEAVE; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>call_AddSubtract</i> is called like this</p>


<p style="margin-left:11%; margin-top: 1em">call_AddSubtract(7,
4);</p>

<p style="margin-left:11%; margin-top: 1em">then here is
the output</p>

<p style="margin-left:11%; margin-top: 1em">7 &minus; 4 = 3
<br>
7 + 4 = 11</p>

<p style="margin-left:11%; margin-top: 1em">Notes</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">We wanted list context, so
G_LIST was used.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>Not surprisingly &quot;POPi&quot; is used twice this
time because we were retrieving 2 values from the stack. The
important thing to note is that when using the
&quot;POP*&quot; macros they come off the stack in
<i>reverse</i> order.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Returning a
List in Scalar Context</b> <br>
Say the Perl subroutine in the previous section was called
in a scalar context, like this</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
call_AddSubScalar(a, b) <br>
int a; <br>
int b; <br>
{ <br>
dSP; <br>
int count; <br>
int i; <br>
ENTER; <br>
SAVETMPS; <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(sv_2mortal(newSViv(a))); <br>
PUSHs(sv_2mortal(newSViv(b))); <br>
PUTBACK; <br>
count = call_pv(&quot;AddSubtract&quot;, G_SCALAR); <br>
SPAGAIN; <br>
printf (&quot;Items Returned = %d\n&quot;, count); <br>
for (i = 1; i &lt;= count; ++i) <br>
printf (&quot;Value %d = %d\n&quot;, i, POPi); <br>
PUTBACK; <br>
FREETMPS; <br>
LEAVE; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The other
modification made is that <i>call_AddSubScalar</i> will
print the number of items returned from the Perl subroutine
and their value (for simplicity it assumes that they are
integer). So if <i>call_AddSubScalar</i> is called</p>


<p style="margin-left:11%; margin-top: 1em">call_AddSubScalar(7,
4);</p>

<p style="margin-left:11%; margin-top: 1em">then the output
will be</p>

<p style="margin-left:11%; margin-top: 1em">Items Returned
= 1 <br>
Value 1 = 3</p>

<p style="margin-left:11%; margin-top: 1em">In this case
the main point to note is that only the last item in the
list is returned from the subroutine. <i>AddSubtract</i>
actually made it back to <i>call_AddSubScalar</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Returning
Data from Perl via the Parameter List</b> <br>
It is also possible to return values directly via the
parameter list--whether it is actually desirable to do it is
another matter entirely.</p>

<p style="margin-left:11%; margin-top: 1em">The Perl
subroutine, <i>Inc</i>, below takes 2 parameters and
increments each directly.</p>

<p style="margin-left:11%; margin-top: 1em">sub Inc <br>
{ <br>
++ $_[0]; <br>
++ $_[1]; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">and here is a C
function to call it.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
call_Inc(a, b) <br>
int a; <br>
int b; <br>
{ <br>
dSP; <br>
int count; <br>
SV * sva; <br>
SV * svb; <br>
ENTER; <br>
SAVETMPS; <br>
sva = sv_2mortal(newSViv(a)); <br>
svb = sv_2mortal(newSViv(b)); <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(sva); <br>
PUSHs(svb); <br>
PUTBACK; <br>
count = call_pv(&quot;Inc&quot;, G_DISCARD); <br>
if (count != 0) <br>
croak (&quot;call_Inc: expected 0 values from 'Inc', got
%d\n&quot;, <br>
count); <br>
printf (&quot;%d + 1 = %d\n&quot;, a, SvIV(sva)); <br>
printf (&quot;%d + 1 = %d\n&quot;, b, SvIV(svb)); <br>
FREETMPS; <br>
LEAVE; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">To be able to
access the two parameters that were pushed onto the stack
after they return from <i>call_pv</i> it is necessary to
make a note of their addresses--thus the two variables
&quot;sva&quot; and &quot;svb&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The reason this
is necessary is that the area of the Perl stack which held
them will very likely have been overwritten by something
else by the time control returns from <i>call_pv</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
G_EVAL</b> <br>
Now an example using G_EVAL. Below is a Perl subroutine
which computes the difference of its 2 parameters. If this
would result in a negative result, the subroutine calls
<i>die</i>.</p>

<p style="margin-left:11%; margin-top: 1em">sub Subtract
<br>
{ <br>
my ($a, $b) = @_; <br>
die &quot;death can be fatal\n&quot; if $a &lt; $b; <br>
$a &minus; $b; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">and some C to
call it</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
call_Subtract(a, b) <br>
int a; <br>
int b; <br>
{ <br>
dSP; <br>
int count; <br>
SV *err_tmp; <br>
ENTER; <br>
SAVETMPS; <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(sv_2mortal(newSViv(a))); <br>
PUSHs(sv_2mortal(newSViv(b))); <br>
PUTBACK; <br>
count = call_pv(&quot;Subtract&quot;, G_EVAL|G_SCALAR); <br>
SPAGAIN; <br>
/* Check the eval first */ <br>
err_tmp = ERRSV; <br>
if (SvTRUE(err_tmp)) <br>
{ <br>
printf (&quot;Uh oh &minus; %s\n&quot;,
SvPV_nolen(err_tmp)); <br>
POPs; <br>
} <br>
else <br>
{ <br>
if (count != 1) <br>
croak(&quot;call_Subtract: wanted 1 value from 'Subtract',
got %d\n&quot;, <br>
count); <br>
printf (&quot;%d &minus; %d = %d\n&quot;, a, b, POPi); <br>
} <br>
PUTBACK; <br>
FREETMPS; <br>
LEAVE; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If
<i>call_Subtract</i> is called thus</p>


<p style="margin-left:11%; margin-top: 1em">call_Subtract(4,
5)</p>

<p style="margin-left:11%; margin-top: 1em">the following
will be printed</p>

<p style="margin-left:11%; margin-top: 1em">Uh oh &minus;
death can be fatal</p>

<p style="margin-left:11%; margin-top: 1em">Notes</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">We want to be able to catch the
<i>die</i> so we have used the G_EVAL flag. Not specifying
this flag would mean that the program would terminate
immediately at the <i>die</i> statement in the subroutine
<i>Subtract</i>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>The code</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">err_tmp =
ERRSV; <br>
if (SvTRUE(err_tmp)) <br>
{ <br>
printf (&quot;Uh oh &minus; %s\n&quot;,
SvPV_nolen(err_tmp)); <br>
POPs; <br>
}</p>

<p style="margin-left:18%; margin-top: 1em">is the direct
equivalent of this bit of Perl</p>

<p style="margin-left:18%; margin-top: 1em">print &quot;Uh
oh &minus; $@\n&quot; if $@;</p>


<p style="margin-left:18%; margin-top: 1em">&quot;PL_errgv&quot;
is a perl global of type &quot;GV *&quot; that points to the
symbol table entry containing the error. &quot;ERRSV&quot;
therefore refers to the C equivalent of $@. We use a local
temporary, &quot;err_tmp&quot;, since &quot;ERRSV&quot; is a
macro that calls a function, and &quot;SvTRUE(ERRSV)&quot;
would end up calling that function multiple times.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Note that the stack is popped
using &quot;POPs&quot; in the block where
&quot;SvTRUE(err_tmp)&quot; is true. This is necessary
because whenever a <i>call_*</i> function invoked with
G_EVAL|G_SCALAR returns an error, the top of the stack holds
the value <i>undef</i>. Because we want the program to
continue after detecting this error, it is essential that
the stack be tidied up by removing the <i>undef</i>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Using
G_KEEPERR</b> <br>
Consider this rather facetious example, where we have used
an <small>XS</small> version of the call_Subtract example
above inside a destructor:</p>

<p style="margin-left:11%; margin-top: 1em">package Foo;
<br>
sub new { bless {}, $_[0] } <br>
sub Subtract { <br>
my($a,$b) = @_; <br>
die &quot;death can be fatal&quot; if $a &lt; $b; <br>
$a &minus; $b; <br>
} <br>
sub DESTROY { call_Subtract(5, 4); } <br>
sub foo { die &quot;foo dies&quot;; } <br>
package main; <br>
{ <br>
my $foo = Foo&minus;&gt;new; <br>
eval { $foo&minus;&gt;foo }; <br>
} <br>
print &quot;Saw: $@&quot; if $@; # should be, but isn't</p>

<p style="margin-left:11%; margin-top: 1em">This example
will fail to recognize that an error occurred inside the
&quot;eval {}&quot;. Here&rsquo;s why: the call_Subtract
code got executed while perl was cleaning up temporaries
when exiting the outer braced block, and because
call_Subtract is implemented with <i>call_pv</i> using the
G_EVAL flag, it promptly reset $@. This results in the
failure of the outermost test for $@, and thereby the
failure of the error trap.</p>

<p style="margin-left:11%; margin-top: 1em">Appending the
G_KEEPERR flag, so that the <i>call_pv</i> call in
call_Subtract reads:</p>

<p style="margin-left:11%; margin-top: 1em">count =
call_pv(&quot;Subtract&quot;,
G_EVAL|G_SCALAR|G_KEEPERR);</p>

<p style="margin-left:11%; margin-top: 1em">will preserve
the error and restore reliable error handling.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
call_sv</b> <br>
In all the previous examples I have
&rsquo;hard&minus;wired&rsquo; the name of the Perl
subroutine to be called from C. Most of the time though, it
is more convenient to be able to specify the name of the
Perl subroutine from within the Perl script, and
you&rsquo;ll want to use call_sv.</p>

<p style="margin-left:11%; margin-top: 1em">Consider the
Perl code below</p>

<p style="margin-left:11%; margin-top: 1em">sub fred <br>
{ <br>
print &quot;Hello there\n&quot;; <br>
} <br>
CallSubPV(&quot;fred&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
snippet of <small>XSUB</small> which defines
<i>CallSubPV</i>.</p>

<p style="margin-left:11%; margin-top: 1em">void <br>
CallSubPV(name) <br>
char * name <br>
CODE: <br>
PUSHMARK(SP); <br>
call_pv(name, G_DISCARD|G_NOARGS);</p>

<p style="margin-left:11%; margin-top: 1em">That is fine as
far as it goes. The thing is, the Perl subroutine can be
specified as only a string, however, Perl allows references
to subroutines and anonymous subroutines. This is where
<i>call_sv</i> is useful.</p>

<p style="margin-left:11%; margin-top: 1em">The code below
for <i>CallSubSV</i> is identical to <i>CallSubPV</i> except
that the &quot;name&quot; parameter is now defined as an SV*
and we use <i>call_sv</i> instead of <i>call_pv</i>.</p>

<p style="margin-left:11%; margin-top: 1em">void <br>
CallSubSV(name) <br>
SV * name <br>
CODE: <br>
PUSHMARK(SP); <br>
call_sv(name, G_DISCARD|G_NOARGS);</p>

<p style="margin-left:11%; margin-top: 1em">Because we are
using an <small>SV</small> to call <i>fred</i> the following
can all be used:</p>


<p style="margin-left:11%; margin-top: 1em">CallSubSV(&quot;fred&quot;);
<br>
CallSubSV(\&amp;fred); <br>
$ref = \&amp;fred; <br>
CallSubSV($ref); <br>
CallSubSV( sub { print &quot;Hello there\n&quot; } );</p>

<p style="margin-left:11%; margin-top: 1em">As you can see,
<i>call_sv</i> gives you much greater flexibility in how you
can specify the Perl subroutine.</p>

<p style="margin-left:11%; margin-top: 1em">You should note
that, if it is necessary to store the <small>SV</small>
(&quot;name&quot; in the example above) which corresponds to
the Perl subroutine so that it can be used later in the
program, it not enough just to store a copy of the pointer
to the <small>SV.</small> Say the code above had been like
this:</p>

<p style="margin-left:11%; margin-top: 1em">static SV *
rememberSub; <br>
void <br>
SaveSub1(name) <br>
SV * name <br>
CODE: <br>
rememberSub = name; <br>
void <br>
CallSavedSub1() <br>
CODE: <br>
PUSHMARK(SP); <br>
call_sv(rememberSub, G_DISCARD|G_NOARGS);</p>

<p style="margin-left:11%; margin-top: 1em">The reason this
is wrong is that, by the time you come to use the pointer
&quot;rememberSub&quot; in &quot;CallSavedSub1&quot;, it may
or may not still refer to the Perl subroutine that was
recorded in &quot;SaveSub1&quot;. This is particularly true
for these cases:</p>


<p style="margin-left:11%; margin-top: 1em">SaveSub1(\&amp;fred);
<br>
CallSavedSub1(); <br>
SaveSub1( sub { print &quot;Hello there\n&quot; } ); <br>
CallSavedSub1();</p>

<p style="margin-left:11%; margin-top: 1em">By the time
each of the &quot;SaveSub1&quot; statements above has been
executed, the SV*s which corresponded to the parameters will
no longer exist. Expect an error message from Perl of the
form</p>

<p style="margin-left:11%; margin-top: 1em">Can't use an
undefined value as a subroutine reference at ...</p>

<p style="margin-left:11%; margin-top: 1em">for each of the
&quot;CallSavedSub1&quot; lines.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, with
this code</p>

<p style="margin-left:11%; margin-top: 1em">$ref =
\&amp;fred; <br>
SaveSub1($ref); <br>
$ref = 47; <br>
CallSavedSub1();</p>

<p style="margin-left:11%; margin-top: 1em">you can expect
one of these messages (which you actually get is dependent
on the version of Perl you are using)</p>

<p style="margin-left:11%; margin-top: 1em">Not a CODE
reference at ... <br>
Undefined subroutine &amp;main::47 called ...</p>

<p style="margin-left:11%; margin-top: 1em">The variable
$ref may have referred to the subroutine &quot;fred&quot;
whenever the call to &quot;SaveSub1&quot; was made but by
the time &quot;CallSavedSub1&quot; gets called it now holds
the number 47. Because we saved only a pointer to the
original <small>SV</small> in &quot;SaveSub1&quot;, any
changes to $ref will be tracked by the pointer
&quot;rememberSub&quot;. This means that whenever
&quot;CallSavedSub1&quot; gets called, it will attempt to
execute the code which is referenced by the SV*
&quot;rememberSub&quot;. In this case though, it now refers
to the integer 47, so expect Perl to complain loudly.</p>

<p style="margin-left:11%; margin-top: 1em">A similar but
more subtle problem is illustrated with this code:</p>

<p style="margin-left:11%; margin-top: 1em">$ref =
\&amp;fred; <br>
SaveSub1($ref); <br>
$ref = \&amp;joe; <br>
CallSavedSub1();</p>

<p style="margin-left:11%; margin-top: 1em">This time
whenever &quot;CallSavedSub1&quot; gets called it will
execute the Perl subroutine &quot;joe&quot; (assuming it
exists) rather than &quot;fred&quot; as was originally
requested in the call to &quot;SaveSub1&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To get around
these problems it is necessary to take a full copy of the
<small>SV.</small> The code below shows &quot;SaveSub2&quot;
modified to do that.</p>

<p style="margin-left:11%; margin-top: 1em">/* this isn't
thread&minus;safe */ <br>
static SV * keepSub = (SV*)NULL; <br>
void <br>
SaveSub2(name) <br>
SV * name <br>
CODE: <br>
/* Take a copy of the callback */ <br>
if (keepSub == (SV*)NULL) <br>
/* First time, so create a new SV */ <br>
keepSub = newSVsv(name); <br>
else <br>
/* Been here before, so overwrite */ <br>
SvSetSV(keepSub, name); <br>
void <br>
CallSavedSub2() <br>
CODE: <br>
PUSHMARK(SP); <br>
call_sv(keepSub, G_DISCARD|G_NOARGS);</p>

<p style="margin-left:11%; margin-top: 1em">To avoid
creating a new <small>SV</small> every time
&quot;SaveSub2&quot; is called, the function first checks to
see if it has been called before. If not, then space for a
new <small>SV</small> is allocated and the reference to the
Perl subroutine &quot;name&quot; is copied to the variable
&quot;keepSub&quot; in one operation using
&quot;newSVsv&quot;. Thereafter, whenever
&quot;SaveSub2&quot; is called, the existing
<small>SV,</small> &quot;keepSub&quot;, is overwritten with
the new value using &quot;SvSetSV&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Note: using a
static or global variable to store the <small>SV</small>
isn&rsquo;t thread-safe. You can either use the
&quot;MY_CXT&quot; mechanism documented in &quot;Safely
Storing Static Data in <small>XS&quot;</small> in perlxs
which is fast, or store the values in perl global variables,
using <b>get_sv()</b>, which is much slower.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
call_argv</b> <br>
Here is a Perl subroutine which prints whatever parameters
are passed to it.</p>

<p style="margin-left:11%; margin-top: 1em">sub PrintList
<br>
{ <br>
my(@list) = @_; <br>
foreach (@list) { print &quot;$_\n&quot; } <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">And here is an
example of <i>call_argv</i> which will call
<i>PrintList</i>.</p>

<p style="margin-left:11%; margin-top: 1em">static char *
words[] = {&quot;alpha&quot;, &quot;beta&quot;,
&quot;gamma&quot;, &quot;delta&quot;, NULL}; <br>
static void <br>
call_PrintList() <br>
{ <br>
call_argv(&quot;PrintList&quot;, G_DISCARD, words); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Note that it is
not necessary to call &quot;PUSHMARK&quot; in this instance.
This is because <i>call_argv</i> will do it for you.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
call_method</b> <br>
Consider the following Perl code:</p>

<p style="margin-left:11%; margin-top: 1em">{ <br>
package Mine; <br>
sub new <br>
{ <br>
my($type) = shift; <br>
bless [@_] <br>
} <br>
sub Display <br>
{ <br>
my ($self, $index) = @_; <br>
print &quot;$index: $$self[$index]\n&quot;; <br>
} <br>
sub PrintID <br>
{ <br>
my($class) = @_; <br>
print &quot;This is Class $class version 1.0\n&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">It implements
just a very simple class to manage an array. Apart from the
constructor, &quot;new&quot;, it declares methods, one
static and one virtual. The static method,
&quot;PrintID&quot;, prints out simply the class name and a
version number. The virtual method, &quot;Display&quot;,
prints out a single element of the array. Here is an
all-Perl example of using it.</p>

<p style="margin-left:11%; margin-top: 1em">$a =
Mine&minus;&gt;new('red', 'green', 'blue'); <br>
$a&minus;&gt;Display(1); <br>
Mine&minus;&gt;PrintID;</p>

<p style="margin-left:11%; margin-top: 1em">will print</p>

<p style="margin-left:11%; margin-top: 1em">1: green <br>
This is Class Mine version 1.0</p>

<p style="margin-left:11%; margin-top: 1em">Calling a Perl
method from C is fairly straightforward. The following
things are required:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">A reference to the object for a
virtual method or the name of the class for a static
method</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>The name of the method</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Any other parameters specific to the method</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Here is a
simple <small>XSUB</small> which illustrates the mechanics
of calling both the &quot;PrintID&quot; and
&quot;Display&quot; methods from C.</p>

<p style="margin-left:11%; margin-top: 1em">void <br>
call_Method(ref, method, index) <br>
SV * ref <br>
char * method <br>
int index <br>
CODE: <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(ref); <br>
PUSHs(sv_2mortal(newSViv(index))); <br>
PUTBACK; <br>
call_method(method, G_DISCARD); <br>
void <br>
call_PrintID(class, method) <br>
char * class <br>
char * method <br>
CODE: <br>
PUSHMARK(SP); <br>
XPUSHs(sv_2mortal(newSVpv(class, 0))); <br>
PUTBACK; <br>
call_method(method, G_DISCARD);</p>

<p style="margin-left:11%; margin-top: 1em">So the methods
&quot;PrintID&quot; and &quot;Display&quot; can be invoked
like this:</p>

<p style="margin-left:11%; margin-top: 1em">$a =
Mine&minus;&gt;new('red', 'green', 'blue'); <br>
call_Method($a, 'Display', 1); <br>
call_PrintID('Mine', 'PrintID');</p>

<p style="margin-left:11%; margin-top: 1em">The only thing
to note is that, in both the static and virtual methods, the
method name is not passed via the stack--it is used as the
first parameter to <i>call_method</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
<small>GIMME_V</small></b> <br>
Here is a trivial <small>XSUB</small> which prints the
context in which it is currently executing.</p>

<p style="margin-left:11%; margin-top: 1em">void <br>
PrintContext() <br>
CODE: <br>
U8 gimme = GIMME_V; <br>
if (gimme == G_VOID) <br>
printf (&quot;Context is Void\n&quot;); <br>
else if (gimme == G_SCALAR) <br>
printf (&quot;Context is Scalar\n&quot;); <br>
else <br>
printf (&quot;Context is Array\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">And here is
some Perl to test it.</p>

<p style="margin-left:11%; margin-top: 1em">PrintContext;
<br>
$a = PrintContext; <br>
@a = PrintContext;</p>

<p style="margin-left:11%; margin-top: 1em">The output from
that will be</p>

<p style="margin-left:11%; margin-top: 1em">Context is Void
<br>
Context is Scalar <br>
Context is Array</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using Perl
to Dispose of Temporaries</b> <br>
In the examples given to date, any temporaries created in
the callback (i.e., parameters passed on the stack to the
<i>call_*</i> function or values returned via the stack)
have been freed by one of these methods:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p style="margin-top: 1em">Specifying the G_DISCARD flag
with <i>call_*</i></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="82%">


<p>Explicitly using the
&quot;ENTER&quot;/&quot;SAVETMPS&quot;&minus;&minus;&quot;FREETMPS&quot;/&quot;LEAVE&quot;
pairing</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">There is
another method which can be used, namely letting Perl do it
for you automatically whenever it regains control after the
callback has terminated. This is done by simply not using
the</p>

<p style="margin-left:11%; margin-top: 1em">ENTER; <br>
SAVETMPS; <br>
... <br>
FREETMPS; <br>
LEAVE;</p>

<p style="margin-left:11%; margin-top: 1em">sequence in the
callback (and not, of course, specifying the G_DISCARD
flag).</p>

<p style="margin-left:11%; margin-top: 1em">If you are
going to use this method you have to be aware of a possible
memory leak which can arise under very specific
circumstances. To explain these circumstances you need to
know a bit about the flow of control between Perl and the
callback routine.</p>

<p style="margin-left:11%; margin-top: 1em">The examples
given at the start of the document (an error handler and an
event driven program) are typical of the two main sorts of
flow control that you are likely to encounter with
callbacks. There is a very important distinction between
them, so pay attention.</p>

<p style="margin-left:11%; margin-top: 1em">In the first
example, an error handler, the flow of control could be as
follows. You have created an interface to an external
library. Control can reach the external library like
this</p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;&minus;&gt; XSUB &minus;&minus;&gt; external
library</p>

<p style="margin-left:11%; margin-top: 1em">Whilst control
is in the library, an error condition occurs. You have
previously set up a Perl callback to handle this situation,
so it will get executed. Once the callback has finished,
control will drop back to Perl again. Here is what the flow
of control will be like in that situation</p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;&minus;&gt; XSUB &minus;&minus;&gt; external library
<br>
... <br>
error occurs <br>
... <br>
external library &minus;&minus;&gt; call_*
&minus;&minus;&gt; perl <br>
| <br>
perl &lt;&minus;&minus; XSUB &lt;&minus;&minus; external
library &lt;&minus;&minus; call_*
&lt;&minus;&minus;&minus;&minus;+</p>

<p style="margin-left:11%; margin-top: 1em">After
processing of the error using <i>call_*</i> is completed,
control reverts back to Perl more or less immediately.</p>

<p style="margin-left:11%; margin-top: 1em">In the diagram,
the further right you go the more deeply nested the scope
is. It is only when control is back with perl on the extreme
left of the diagram that you will have dropped back to the
enclosing scope and any temporaries you have left hanging
around will be freed.</p>

<p style="margin-left:11%; margin-top: 1em">In the second
example, an event driven program, the flow of control will
be more like this</p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;&minus;&gt; XSUB &minus;&minus;&gt; event handler
<br>
... <br>
event handler &minus;&minus;&gt; call_* &minus;&minus;&gt;
perl <br>
| <br>
event handler &lt;&minus;&minus; call_*
&lt;&minus;&minus;&minus;&minus;+ <br>
... <br>
event handler &minus;&minus;&gt; call_* &minus;&minus;&gt;
perl <br>
| <br>
event handler &lt;&minus;&minus; call_*
&lt;&minus;&minus;&minus;&minus;+ <br>
... <br>
event handler &minus;&minus;&gt; call_* &minus;&minus;&gt;
perl <br>
| <br>
event handler &lt;&minus;&minus; call_*
&lt;&minus;&minus;&minus;&minus;+</p>

<p style="margin-left:11%; margin-top: 1em">In this case
the flow of control can consist of only the repeated
sequence</p>

<p style="margin-left:11%; margin-top: 1em">event handler
&minus;&minus;&gt; call_* &minus;&minus;&gt; perl</p>

<p style="margin-left:11%; margin-top: 1em">for practically
the complete duration of the program. This means that
control may <i>never</i> drop back to the surrounding scope
in Perl at the extreme left.</p>

<p style="margin-left:11%; margin-top: 1em">So what is the
big problem? Well, if you are expecting Perl to tidy up
those temporaries for you, you might be in for a long wait.
For Perl to dispose of your temporaries, control must drop
back to the enclosing scope at some stage. In the event
driven scenario that may never happen. This means that, as
time goes on, your program will create more and more
temporaries, none of which will ever be freed. As each of
these temporaries consumes some memory your program will
eventually consume all the available memory in your
system--kapow!</p>

<p style="margin-left:11%; margin-top: 1em">So here is the
bottom line--if you are sure that control will revert back
to the enclosing Perl scope fairly quickly after the end of
your callback, then it isn&rsquo;t absolutely necessary to
dispose explicitly of any temporaries you may have created.
Mind you, if you are at all uncertain about what to do, it
doesn&rsquo;t do any harm to tidy up anyway.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Strategies
for Storing Callback Context Information</b> <br>
Potentially one of the trickiest problems to overcome when
designing a callback interface can be figuring out how to
store the mapping between the C callback function and the
Perl equivalent.</p>

<p style="margin-left:11%; margin-top: 1em">To help
understand why this can be a real problem first consider how
a callback is set up in an all C environment. Typically a C
<small>API</small> will provide a function to register a
callback. This will expect a pointer to a function as one of
its parameters. Below is a call to a hypothetical function
&quot;register_fatal&quot; which registers the C function to
get called when a fatal error occurs.</p>


<p style="margin-left:11%; margin-top: 1em">register_fatal(cb1);</p>

<p style="margin-left:11%; margin-top: 1em">The single
parameter &quot;cb1&quot; is a pointer to a function, so you
must have defined &quot;cb1&quot; in your code, say
something like this</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
cb1() <br>
{ <br>
printf (&quot;Fatal Error\n&quot;); <br>
exit(1); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now change that
to call a Perl subroutine instead</p>

<p style="margin-left:11%; margin-top: 1em">static SV *
callback = (SV*)NULL; <br>
static void <br>
cb1() <br>
{ <br>
dSP; <br>
PUSHMARK(SP); <br>
/* Call the Perl sub to process the callback */ <br>
call_sv(callback, G_DISCARD); <br>
} <br>
void <br>
register_fatal(fn) <br>
SV * fn <br>
CODE: <br>
/* Remember the Perl sub */ <br>
if (callback == (SV*)NULL) <br>
callback = newSVsv(fn); <br>
else <br>
SvSetSV(callback, fn); <br>
/* register the callback with the external library */ <br>
register_fatal(cb1);</p>

<p style="margin-left:11%; margin-top: 1em">where the Perl
equivalent of &quot;register_fatal&quot; and the callback it
registers, &quot;pcb1&quot;, might look like this</p>

<p style="margin-left:11%; margin-top: 1em"># Register the
sub pcb1 <br>
register_fatal(\&amp;pcb1); <br>
sub pcb1 <br>
{ <br>
die &quot;I'm dying...\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The mapping
between the C callback and the Perl equivalent is stored in
the global variable &quot;callback&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This will be
adequate if you ever need to have only one callback
registered at any time. An example could be an error handler
like the code sketched out above. Remember though, repeated
calls to &quot;register_fatal&quot; will replace the
previously registered callback function with the new
one.</p>

<p style="margin-left:11%; margin-top: 1em">Say for example
you want to interface to a library which allows asynchronous
file i/o. In this case you may be able to register a
callback whenever a read operation has completed. To be of
any use we want to be able to call separate Perl subroutines
for each file that is opened. As it stands, the error
handler example above would not be adequate as it allows
only a single callback to be defined at any time. What we
require is a means of storing the mapping between the opened
file and the Perl subroutine we want to be called for that
file.</p>

<p style="margin-left:11%; margin-top: 1em">Say the i/o
library has a function &quot;asynch_read&quot; which
associates a C function &quot;ProcessRead&quot; with a file
handle &quot;fh&quot;&minus;&minus;this assumes that it has
also provided some routine to open the file and so obtain
the file handle.</p>


<p style="margin-left:11%; margin-top: 1em">asynch_read(fh,
ProcessRead)</p>

<p style="margin-left:11%; margin-top: 1em">This may expect
the C <i>ProcessRead</i> function of this form</p>

<p style="margin-left:11%; margin-top: 1em">void <br>
ProcessRead(fh, buffer) <br>
int fh; <br>
char * buffer; <br>
{ <br>
... <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">To provide a
Perl interface to this library we need to be able to map
between the &quot;fh&quot; parameter and the Perl subroutine
we want called. A hash is a convenient mechanism for storing
this mapping. The code below shows a possible
implementation</p>

<p style="margin-left:11%; margin-top: 1em">static HV *
Mapping = (HV*)NULL; <br>
void <br>
asynch_read(fh, callback) <br>
int fh <br>
SV * callback <br>
CODE: <br>
/* If the hash doesn't already exist, create it */ <br>
if (Mapping == (HV*)NULL) <br>
Mapping = newHV(); <br>
/* Save the fh &minus;&gt; callback mapping */ <br>
hv_store(Mapping, (char*)&amp;fh, sizeof(fh),
newSVsv(callback), 0); <br>
/* Register with the C Library */ <br>
asynch_read(fh, asynch_read_if);</p>

<p style="margin-left:11%; margin-top: 1em">and
&quot;asynch_read_if&quot; could look like this</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
asynch_read_if(fh, buffer) <br>
int fh; <br>
char * buffer; <br>
{ <br>
dSP; <br>
SV ** sv; <br>
/* Get the callback associated with fh */ <br>
sv = hv_fetch(Mapping, (char*)&amp;fh , sizeof(fh), FALSE);
<br>
if (sv == (SV**)NULL) <br>
croak(&quot;Internal error...\n&quot;); <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(sv_2mortal(newSViv(fh))); <br>
PUSHs(sv_2mortal(newSVpv(buffer, 0))); <br>
PUTBACK; <br>
/* Call the Perl sub */ <br>
call_sv(*sv, G_DISCARD); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">For
completeness, here is &quot;asynch_close&quot;. This shows
how to remove the entry from the hash
&quot;Mapping&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">void <br>
asynch_close(fh) <br>
int fh <br>
CODE: <br>
/* Remove the entry from the hash */ <br>
(void) hv_delete(Mapping, (char*)&amp;fh, sizeof(fh),
G_DISCARD); <br>
/* Now call the real asynch_close */ <br>
asynch_close(fh);</p>

<p style="margin-left:11%; margin-top: 1em">So the Perl
interface would look like this</p>

<p style="margin-left:11%; margin-top: 1em">sub callback1
<br>
{ <br>
my($handle, $buffer) = @_; <br>
} <br>
# Register the Perl callback <br>
asynch_read($fh, \&amp;callback1); <br>
asynch_close($fh);</p>

<p style="margin-left:11%; margin-top: 1em">The mapping
between the C callback and Perl is stored in the global hash
&quot;Mapping&quot; this time. Using a hash has the distinct
advantage that it allows an unlimited number of callbacks to
be registered.</p>

<p style="margin-left:11%; margin-top: 1em">What if the
interface provided by the C callback doesn&rsquo;t contain a
parameter which allows the file handle to Perl subroutine
mapping? Say in the asynchronous i/o package, the callback
function gets passed only the &quot;buffer&quot; parameter
like this</p>

<p style="margin-left:11%; margin-top: 1em">void <br>
ProcessRead(buffer) <br>
char * buffer; <br>
{ <br>
... <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Without the
file handle there is no straightforward way to map from the
C callback to the Perl subroutine.</p>

<p style="margin-left:11%; margin-top: 1em">In this case a
possible way around this problem is to predefine a series of
C functions to act as the interface to Perl, thus</p>

<p style="margin-left:11%; margin-top: 1em">#define MAX_CB
3 <br>
#define NULL_HANDLE &minus;1 <br>
typedef void (*FnMap)(); <br>
struct MapStruct { <br>
FnMap Function; <br>
SV * PerlSub; <br>
int Handle; <br>
}; <br>
static void fn1(); <br>
static void fn2(); <br>
static void fn3(); <br>
static struct MapStruct Map [MAX_CB] = <br>
{ <br>
{ fn1, NULL, NULL_HANDLE }, <br>
{ fn2, NULL, NULL_HANDLE }, <br>
{ fn3, NULL, NULL_HANDLE } <br>
}; <br>
static void <br>
Pcb(index, buffer) <br>
int index; <br>
char * buffer; <br>
{ <br>
dSP; <br>
PUSHMARK(SP); <br>
XPUSHs(sv_2mortal(newSVpv(buffer, 0))); <br>
PUTBACK; <br>
/* Call the Perl sub */ <br>
call_sv(Map[index].PerlSub, G_DISCARD); <br>
} <br>
static void <br>
fn1(buffer) <br>
char * buffer; <br>
{ <br>
Pcb(0, buffer); <br>
} <br>
static void <br>
fn2(buffer) <br>
char * buffer; <br>
{ <br>
Pcb(1, buffer); <br>
} <br>
static void <br>
fn3(buffer) <br>
char * buffer; <br>
{ <br>
Pcb(2, buffer); <br>
} <br>
void <br>
array_asynch_read(fh, callback) <br>
int fh <br>
SV * callback <br>
CODE: <br>
int index; <br>
int null_index = MAX_CB; <br>
/* Find the same handle or an empty entry */ <br>
for (index = 0; index &lt; MAX_CB; ++index) <br>
{ <br>
if (Map[index].Handle == fh) <br>
break; <br>
if (Map[index].Handle == NULL_HANDLE) <br>
null_index = index; <br>
} <br>
if (index == MAX_CB &amp;&amp; null_index == MAX_CB) <br>
croak (&quot;Too many callback functions
registered\n&quot;); <br>
if (index == MAX_CB) <br>
index = null_index; <br>
/* Save the file handle */ <br>
Map[index].Handle = fh; <br>
/* Remember the Perl sub */ <br>
if (Map[index].PerlSub == (SV*)NULL) <br>
Map[index].PerlSub = newSVsv(callback); <br>
else <br>
SvSetSV(Map[index].PerlSub, callback); <br>
asynch_read(fh, Map[index].Function); <br>
void <br>
array_asynch_close(fh) <br>
int fh <br>
CODE: <br>
int index; <br>
/* Find the file handle */ <br>
for (index = 0; index &lt; MAX_CB; ++ index) <br>
if (Map[index].Handle == fh) <br>
break; <br>
if (index == MAX_CB) <br>
croak (&quot;could not close fh %d\n&quot;, fh); <br>
Map[index].Handle = NULL_HANDLE; <br>
SvREFCNT_dec(Map[index].PerlSub); <br>
Map[index].PerlSub = (SV*)NULL; <br>
asynch_close(fh);</p>

<p style="margin-left:11%; margin-top: 1em">In this case
the functions &quot;fn1&quot;, &quot;fn2&quot;, and
&quot;fn3&quot; are used to remember the Perl subroutine to
be called. Each of the functions holds a separate hard-wired
index which is used in the function &quot;Pcb&quot; to
access the &quot;Map&quot; array and actually call the Perl
subroutine.</p>

<p style="margin-left:11%; margin-top: 1em">There are some
obvious disadvantages with this technique.</p>

<p style="margin-left:11%; margin-top: 1em">Firstly, the
code is considerably more complex than with the previous
example.</p>

<p style="margin-left:11%; margin-top: 1em">Secondly, there
is a hard-wired limit (in this case 3) to the number of
callbacks that can exist simultaneously. The only way to
increase the limit is by modifying the code to add more
functions and then recompiling. None the less, as long as
the number of functions is chosen with some care, it is
still a workable solution and in some cases is the only one
available.</p>

<p style="margin-left:11%; margin-top: 1em">To summarize,
here are a number of possible methods for you to consider
for storing the mapping between C and the Perl callback <br>
1. Ignore the problem &minus; Allow only 1 callback</p>

<p style="margin-left:18%;">For a lot of situations, like
interfacing to an error handler, this may be a perfectly
adequate solution.</p>

<p style="margin-left:11%;">2. Create a sequence of
callbacks &minus; hard wired limit</p>

<p style="margin-left:18%;">If it is impossible to tell
from the parameters passed back from the C callback what the
context is, then you may need to create a sequence of C
callback interface functions, and store pointers to each in
an array.</p>

<p style="margin-left:11%;">3. Use a parameter to map to
the Perl callback</p>

<p style="margin-left:18%;">A hash is an ideal mechanism to
store the mapping between C and Perl.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Alternate
Stack Manipulation</b> <br>
Although I have made use of only the &quot;POP*&quot; macros
to access values returned from Perl subroutines, it is also
possible to bypass these macros and read the stack using the
&quot;ST&quot; macro (See perlxs for a full description of
the &quot;ST&quot; macro).</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
time the &quot;POP*&quot; macros should be adequate; the
main problem with them is that they force you to process the
returned values in sequence. This may not be the most
suitable way to process the values in some cases. What we
want is to be able to access the stack in a random order.
The &quot;ST&quot; macro as used when coding an
<small>XSUB</small> is ideal for this purpose.</p>

<p style="margin-left:11%; margin-top: 1em">The code below
is the example given in the section &quot;Returning a List
of Values&quot; recoded to use &quot;ST&quot; instead of
&quot;POP*&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
call_AddSubtract2(a, b) <br>
int a; <br>
int b; <br>
{ <br>
dSP; <br>
I32 ax; <br>
int count; <br>
ENTER; <br>
SAVETMPS; <br>
PUSHMARK(SP); <br>
EXTEND(SP, 2); <br>
PUSHs(sv_2mortal(newSViv(a))); <br>
PUSHs(sv_2mortal(newSViv(b))); <br>
PUTBACK; <br>
count = call_pv(&quot;AddSubtract&quot;, G_LIST); <br>
SPAGAIN; <br>
SP &minus;= count; <br>
ax = (SP &minus; PL_stack_base) + 1; <br>
if (count != 2) <br>
croak(&quot;Big trouble\n&quot;); <br>
printf (&quot;%d + %d = %d\n&quot;, a, b, SvIV(ST(0))); <br>
printf (&quot;%d &minus; %d = %d\n&quot;, a, b,
SvIV(ST(1))); <br>
PUTBACK; <br>
FREETMPS; <br>
LEAVE; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Notes</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="82%">


<p>Notice that it was necessary to define the variable
&quot;ax&quot;. This is because the &quot;ST&quot; macro
expects it to exist. If we were in an <small>XSUB</small> it
would not be necessary to define &quot;ax&quot; as it is
already defined for us.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>The code</p></td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">SPAGAIN; <br>
SP &minus;= count; <br>
ax = (SP &minus; PL_stack_base) + 1;</p>

<p style="margin-left:18%; margin-top: 1em">sets the stack
up so that we can use the &quot;ST&quot; macro.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Unlike the original coding of
this example, the returned values are not accessed in
reverse order. So ST(0) refers to the first value returned
by the Perl subroutine and &quot;ST(count&minus;1)&quot;
refers to the last.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Creating and
Calling an Anonymous Subroutine in C</b> <br>
As we&rsquo;ve already shown, &quot;call_sv&quot; can be
used to invoke an anonymous subroutine. However, our example
showed a Perl script invoking an <small>XSUB</small> to
perform this operation. Let&rsquo;s see how it can be done
inside our C code:</p>

<p style="margin-left:11%; margin-top: 1em">... <br>
SV *cvrv <br>
= eval_pv(&quot;sub { <br>
print 'You will not find me cluttering any namespace!' <br>
}&quot;, TRUE); <br>
... <br>
call_sv(cvrv, G_VOID|G_NOARGS);</p>


<p style="margin-left:11%; margin-top: 1em">&quot;eval_pv&quot;
is used to compile the anonymous subroutine, which will be
the return value as well (read more about
&quot;eval_pv&quot; in &quot;eval_pv&quot; in perlapi). Once
this code reference is in hand, it can be mixed in with all
the previous examples we&rsquo;ve shown.</p>

<h2>LIGHTWEIGHT CALLBACKS
<a name="LIGHTWEIGHT CALLBACKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Sometimes you
need to invoke the same subroutine repeatedly. This usually
happens with a function that acts on a list of values, such
as Perl&rsquo;s built-in <b>sort()</b>. You can pass a
comparison function to <b>sort()</b>, which will then be
invoked for every pair of values that needs to be compared.
The <b>first()</b> and <b>reduce()</b> functions from
List::Util follow a similar pattern.</p>

<p style="margin-left:11%; margin-top: 1em">In this case it
is possible to speed up the routine (often quite
substantially) by using the lightweight callback
<small>API.</small> The idea is that the calling context
only needs to be created and destroyed once, and the sub can
be called arbitrarily many times in between.</p>

<p style="margin-left:11%; margin-top: 1em">It is usual to
pass parameters using global variables (typically $_ for one
parameter, or $a and $b for two parameters) rather than via
@_. (It is possible to use the @_ mechanism if you know what
you&rsquo;re doing, though there is as yet no supported
<small>API</small> for it. It&rsquo;s also inherently
slower.)</p>

<p style="margin-left:11%; margin-top: 1em">The pattern of
macro calls is like this:</p>

<p style="margin-left:11%; margin-top: 1em">dMULTICALL; /*
Declare local variables */ <br>
U8 gimme = G_SCALAR; /* context of the call: G_SCALAR, <br>
* G_LIST, or G_VOID */ <br>
PUSH_MULTICALL(cv); /* Set up the context for calling cv,
<br>
and set local vars appropriately */ <br>
/* loop */ { <br>
/* set the value(s) af your parameter variables */ <br>
MULTICALL; /* Make the actual call */ <br>
} /* end of loop */ <br>
POP_MULTICALL; /* Tear down the calling context */</p>

<p style="margin-left:11%; margin-top: 1em">For some
concrete examples, see the implementation of the
<b>first()</b> and <b>reduce()</b> functions of List::Util
1.18. There you will also find a header file that emulates
the multicall <small>API</small> on older versions of
perl.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlxs,
perlguts, perlembed</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Paul
Marquess</p>

<p style="margin-left:11%; margin-top: 1em">Special thanks
to the following people who assisted in the creation of the
document.</p>

<p style="margin-left:11%; margin-top: 1em">Jeff Okamoto,
Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy
and Larry Wall.</p>

<h2>DATE
<a name="DATE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Last updated
for perl 5.23.1.</p>
<hr>
</body>
</html>
