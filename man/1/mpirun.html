<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:54 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPIRUN</title>

</head>
<body>
<h1>mpirun</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">orterun,
mpirun, mpiexec &minus; Execute serial and parallel jobs in
Open MPI. oshrun, shmemrun &minus; Execute serial and
parallel jobs in Open SHMEM.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
<i>mpirun</i>, <i>mpiexec</i>, and <i>orterun</i> are all
synonyms for each other as well as <i>oshrun</i>,
<i>shmemrun</i> in case Open SHMEM is installed. Using any
of the names will produce the same behavior.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Single Process
Multiple Data (SPMD) Model:</p>

<p style="margin-left:11%; margin-top: 1em"><b>mpirun</b> [
options ] <b>&lt;program&gt;</b> [ &lt;args&gt; ]</p>

<p style="margin-left:11%; margin-top: 1em">Multiple
Instruction Multiple Data (MIMD) Model:</p>

<p style="margin-left:11%; margin-top: 1em"><b>mpirun</b> [
global_options ] <br>
[ local_options1 ] <b>&lt;program1&gt;</b> [ &lt;args1&gt; ]
: <br>
[ local_options2 ] <b>&lt;program2&gt;</b> [ &lt;args2&gt; ]
: <br>
... : <br>
[ local_optionsN ] <b>&lt;programN&gt;</b> [ &lt;argsN&gt;
]</p>

<p style="margin-left:11%; margin-top: 1em">Note that in
both models, invoking <i>mpirun</i> via an absolute path
name is equivalent to specifying the <i>--prefix</i> option
with a <i>&lt;dir&gt;</i> value equivalent to the directory
where <i>mpirun</i> resides, minus its last subdirectory.
For example:</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b>
/usr/local/bin/mpirun ...</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b> mpirun
--prefix /usr/local</p>

<h2>QUICK SUMMARY
<a name="QUICK SUMMARY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you are
simply looking for how to run an MPI application, you
probably want to use a command line of the following
form:</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b> mpirun
[ -np X ] [ --hostfile &lt;filename&gt; ]
&lt;program&gt;</p>

<p style="margin-left:11%; margin-top: 1em">This will run X
copies of <i>&lt;program&gt;</i> in your current run-time
environment (if running under a supported resource manager,
Open MPI&rsquo;s <i>mpirun</i> will usually automatically
use the corresponding resource manager process starter, as
opposed to, for example, <i>rsh</i> or <i>ssh</i>, which
require the use of a hostfile, or will default to running
all X copies on the localhost), scheduling (by default) in a
round-robin fashion by CPU slot. See the rest of this page
for more details.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that mpirun automatically binds processes as of the start of
the v1.8 series. Three binding patterns are used in the
absence of any further directives:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="23%">


<p><b>Bind to core:</b></p></td>
<td width="4%"></td>
<td width="56%">


<p>when the number of processes is &lt;= 2</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="23%">


<p><b>Bind to socket:</b></p></td>
<td width="4%"></td>
<td width="56%">


<p>when the number of processes is &gt; 2</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="23%">


<p><b>Bind to none:</b></p></td>
<td width="4%"></td>
<td width="56%">


<p>when oversubscribed</p></td>
<td width="6%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If your
application uses threads, then you probably want to ensure
that you are either not bound at all (by specifying
--bind-to none), or bound to multiple cores using an
appropriate binding level or specific number of processing
elements per application process.</p>

<h2>DEFINITION OF &rsquo;SLOT&rsquo;
<a name="DEFINITION OF &rsquo;SLOT&rsquo;"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The term
&quot;slot&quot; is used extensively in the rest of this
manual page. A slot is an allocation unit for a process. The
number of slots on a node indicate how many processes can
potentially execute on that node. By default, Open MPI will
allow one process per slot.</p>

<p style="margin-left:11%; margin-top: 1em">If Open MPI is
not explicitly told how many slots are available on a node
(e.g., if a hostfile is used and the number of slots is not
specified for a given node), it will determine a maximum
number of slots for that node in one of two ways: <br>
1. Default behavior</p>

<p style="margin-left:15%;">By default, Open MPI will
attempt to discover the number of processor cores on the
node, and use that as the number of slots available.</p>

<p style="margin-left:11%;">2. When
<i>--use-hwthread-cpus</i> is used</p>

<p style="margin-left:15%;">If <i>--use-hwthread-cpus</i>
is specified on the <i>mpirun</i> command line, then Open
MPI will attempt to discover the number of hardware threads
on the node, and use that as the number of slots
available.</p>

<p style="margin-left:11%; margin-top: 1em">This default
behavior also occurs when specifying the <i>-host</i> option
with a single host. Thus, the command: <br>
mpirun --host node1 ./a.out</p>

<p style="margin-left:17%;">launches a number of processes
equal to the number of cores on node node1, whereas:</p>

<p style="margin-left:11%;">mpirun --host node1
--use-hwthread-cpus ./a.out</p>

<p style="margin-left:17%;">launches a number of processes
equal to the number of hardware threads on node1.</p>

<p style="margin-left:11%; margin-top: 1em">When Open MPI
applications are invoked in an environment managed by a
resource manager (e.g., inside of a SLURM job), and Open MPI
was built with appropriate support for that resource
manager, then Open MPI will be informed of the number of
slots for each node by the resource manager. For example:
<br>
mpirun ./a.out</p>

<p style="margin-left:17%;">launches one process for every
slot (on every node) as dictated by the resource manager job
specification.</p>

<p style="margin-left:11%; margin-top: 1em">Also note that
the one-process-per-slot restriction can be overridden in
unmanaged environments (e.g., when using hostfiles without a
resource manager) if oversubscription is enabled (by
default, it is disabled). Most MPI applications and HPC
environments do not oversubscribe; for simplicity, the
majority of this documentation assumes that oversubscription
is not enabled.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Slots are
not hardware resources</b> <br>
Slots are frequently incorrectly conflated with hardware
resources. It is important to realize that slots are an
entirely different metric than the number (and type) of
hardware resources available.</p>

<p style="margin-left:11%; margin-top: 1em">Here are some
examples that may help illustrate the difference: <br>
1. More processor cores than slots</p>

<p style="margin-left:15%; margin-top: 1em">Consider a
resource manager job environment that tells Open MPI that
there is a single node with 20 processor cores and 2 slots
available. By default, Open MPI will only let you run up to
2 processes.</p>

<p style="margin-left:15%; margin-top: 1em">Meaning: you
run out of slots long before you run out of processor
cores.</p>

<p style="margin-left:11%;">2. More slots than processor
cores</p>

<p style="margin-left:15%; margin-top: 1em">Consider a
hostfile with a single node listed with a
&quot;slots=50&quot; qualification. The node has 20
processor cores. By default, Open MPI will let you run up to
50 processes.</p>

<p style="margin-left:15%; margin-top: 1em">Meaning: you
can run many more processes than you have processor
cores.</p>

<h2>DEFINITION OF &rsquo;PROCESSOR ELEMENT&rsquo;
<a name="DEFINITION OF &rsquo;PROCESSOR ELEMENT&rsquo;"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">By default,
Open MPI defines that a &quot;processing element&quot; is a
processor core. However, if <i>--use-hwthread-cpus</i> is
specified on the <i>mpirun</i> command line, then a
&quot;processing element&quot; is a hardware thread.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>mpirun</i>
will send the name of the directory where it was invoked on
the local node to each of the remote nodes, and attempt to
change to that directory. See the &quot;Current Working
Directory&quot; section below for further details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>&lt;program&gt;</b></p></td>
<td width="1%"></td>
<td width="74%">


<p>The program executable. This is identified as the first
non-recognized argument to mpirun.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p><b>&lt;args&gt;</b></p></td>
<td width="1%"></td>
<td width="74%">


<p>Pass these run-time arguments to every new process.
These must always be the last arguments to <i>mpirun</i>. If
an app context file is used, <i>&lt;args&gt;</i> will be
ignored.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>-h</b>, <b>--help</b></p>

<p style="margin-left:26%;">Display help for this
command</p>

<p style="margin-left:11%;"><b>-q</b>, <b>--quiet</b></p>

<p style="margin-left:26%;">Suppress informative messages
from orterun during application execution.</p>

<p style="margin-left:11%;"><b>-v</b>, <b>--verbose</b></p>

<p style="margin-left:26%;">Be verbose</p>

<p style="margin-left:11%;"><b>-V</b>, <b>--version</b></p>

<p style="margin-left:26%;">Print version number. If no
other arguments are given, this will also cause orterun to
exit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>-N</b> &lt;num&gt;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Launch num processes per node on all allocated nodes
(synonym for npernode).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-display-map</b>,
<b>--display-map</b></p>

<p style="margin-left:26%;">Display a table showing the
mapped location of each process prior to launch.</p>

<p style="margin-left:11%;"><b>-display-allocation</b>,
<b>--display-allocation</b></p>

<p style="margin-left:26%;">Display the detected resource
allocation.</p>

<p style="margin-left:11%;"><b>-output-proctable</b>,
<b>--output-proctable</b></p>

<p style="margin-left:26%;">Output the debugger proctable
after launch.</p>

<p style="margin-left:11%;"><b>-dvm</b>, <b>--dvm</b></p>

<p style="margin-left:26%;">Create a persistent distributed
virtual machine (DVM).</p>

<p style="margin-left:11%;"><b>-max-vm-size</b>,
<b>--max-vm-size</b> &lt;size&gt;</p>

<p style="margin-left:26%;">Number of processes to run.</p>

<p style="margin-left:11%;"><b>-novm</b>, <b>--novm</b></p>

<p style="margin-left:26%;">Execute without creating an
allocation-spanning virtual machine (only start daemons on
nodes hosting application procs).</p>

<p style="margin-left:11%;"><b>-hnp</b>, <b>--hnp</b>
&lt;arg0&gt;</p>

<p style="margin-left:26%;">Specify the URI of the Head
Node Process (HNP), or the name of the file (specified as
file:filename) that contains that info.</p>

<p style="margin-left:11%; margin-top: 1em">Use one of the
following options to specify which hosts (nodes) of the
cluster to run on. Note that as of the start of the v1.8
release, mpirun will launch a daemon onto each host in the
allocation (as modified by the following options) at the
very beginning of execution, regardless of whether or not
application processes will eventually be mapped to execute
there. This is done to allow collection of hardware topology
information from the remote nodes, thus allowing us to map
processes against known topology. However, it is a change
from the behavior in prior releases where daemons were only
launched after mapping was complete, and thus only occurred
on nodes where application processes would actually be
executing. <b><br>
-H</b>, <b>-host</b>, <b>--host</b>
&lt;host1,host2,...,hostN&gt;</p>

<p style="margin-left:22%;">List of hosts on which to
invoke processes.</p>

<p style="margin-left:11%;"><b>-hostfile</b>,
<b>--hostfile</b> &lt;hostfile&gt;</p>

<p style="margin-left:22%;">Provide a hostfile to use.</p>

<p style="margin-left:11%;"><b>-default-hostfile</b>,
<b>--default-hostfile</b> &lt;hostfile&gt;</p>

<p style="margin-left:22%;">Provide a default hostfile.</p>

<p style="margin-left:11%;"><b>-machinefile</b>,
<b>--machinefile</b> &lt;machinefile&gt;</p>

<p style="margin-left:22%;">Synonym for
<i>-hostfile</i>.</p>

<p style="margin-left:11%;"><b>-cpu-set</b>,
<b>--cpu-set</b> &lt;list&gt;</p>

<p style="margin-left:22%;">Restrict launched processes to
the specified logical cpus on each node (comma-separated
list). Note that the binding options will still apply within
the specified envelope - e.g., you can elect to bind each
process to only one cpu within the specified cpu set.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options specify the number of processes to launch. Note that
none of the options imply a particular binding policy -
e.g., requesting N processes for each socket does not imply
that the processes will be bound to the socket. <b><br>
-c</b>, <b>-n</b>, <b>--n</b>, <b>-np</b> &lt;#&gt;</p>

<p style="margin-left:22%;">Run this many copies of the
program on the given nodes. This option indicates that the
specified file is an executable program and not an
application context. If no value is provided for the number
of copies to execute (i.e., neither the &quot;-np&quot; nor
its synonyms are provided on the command line), Open MPI
will automatically execute a copy of the program on each
process slot (see below for description of a &quot;process
slot&quot;). This feature, however, can only be used in the
SPMD model and will return an error (without beginning
execution of the application) otherwise.</p>

<p style="margin-left:11%;"><b>&acirc;map-by
ppr:N:&lt;object&gt;</b></p>

<p style="margin-left:22%;">Launch N times the number of
objects of the specified type on each node.</p>

<p style="margin-left:11%;"><b>-npersocket</b>,
<b>--npersocket</b> &lt;#persocket&gt;</p>

<p style="margin-left:22%;">On each node, launch this many
processes times the number of processor sockets on the node.
The <i>-npersocket</i> option also turns on the
<i>-bind-to-socket</i> option. (deprecated in favor of
--map-by ppr:n:socket)</p>

<p style="margin-left:11%;"><b>-npernode</b>,
<b>--npernode</b> &lt;#pernode&gt;</p>

<p style="margin-left:22%;">On each node, launch this many
processes. (deprecated in favor of --map-by ppr:n:node)</p>

<p style="margin-left:11%;"><b>-pernode</b>,
<b>--pernode</b></p>

<p style="margin-left:22%;">On each node, launch one
process -- equivalent to <i>-npernode</i> 1. (deprecated in
favor of --map-by ppr:1:node)</p>

<p style="margin-left:11%; margin-top: 1em">To map
processes: <b><br>
--map-by</b> &lt;foo&gt;</p>

<p style="margin-left:22%;">Map to the specified object,
defaults to <i>socket</i>. Supported options include
<i>slot</i>, <i>hwthread</i>, <i>core</i>, <i>L1cache</i>,
<i>L2cache</i>, <i>L3cache</i>, <i>socket</i>, <i>numa</i>,
<i>board</i>, <i>node</i>, <i>sequential</i>,
<i>distance</i>, and <i>ppr</i>. Any object can include
modifiers by adding a <i>:</i> and any combination of
<i>PE=n</i> (bind n processing elements to each proc),
<i>SPAN</i> (load balance the processes across the
allocation), <i>OVERSUBSCRIBE</i> (allow more processes on a
node than processing elements), and <i>NOOVERSUBSCRIBE</i>.
This includes <i>PPR</i>, where the pattern would be
terminated by another colon to separate it from the
modifiers.</p>

<p style="margin-left:11%;"><b>-bycore</b>,
<b>--bycore</b></p>

<p style="margin-left:22%;">Map processes by core
(deprecated in favor of --map-by core)</p>

<p style="margin-left:11%;"><b>-byslot</b>,
<b>--byslot</b></p>

<p style="margin-left:22%;">Map and rank processes
round-robin by slot.</p>

<p style="margin-left:11%;"><b>-nolocal</b>,
<b>--nolocal</b></p>

<p style="margin-left:22%;">Do not run any copies of the
launched application on the same node as orterun is running.
This option will override listing the localhost with
<b>--host</b> or any other host-specifying mechanism.</p>

<p style="margin-left:11%;"><b>-nooversubscribe</b>,
<b>--nooversubscribe</b></p>

<p style="margin-left:22%;">Do not oversubscribe any nodes;
error (without starting any processes) if the requested
number of processes would cause oversubscription. This
option implicitly sets &quot;max_slots&quot; equal to the
&quot;slots&quot; value for each node. (Enabled by
default).</p>

<p style="margin-left:11%;"><b>-oversubscribe</b>,
<b>--oversubscribe</b></p>

<p style="margin-left:22%;">Nodes are allowed to be
oversubscribed, even on a managed system, and overloading of
processing elements.</p>

<p style="margin-left:11%;"><b>-bynode</b>,
<b>--bynode</b></p>

<p style="margin-left:22%;">Launch processes one per node,
cycling by node in a round-robin fashion. This spreads
processes evenly among nodes and assigns MPI_COMM_WORLD
ranks in a round-robin, &quot;by node&quot; manner.</p>

<p style="margin-left:11%;"><b>-cpu-list</b>,
<b>--cpu-list</b> &lt;cpus&gt;</p>

<p style="margin-left:22%;">Comma-delimited list of
processor IDs to which to bind processes [default=NULL].
Processor IDs are interpreted as hwloc logical core IDs. Run
the hwloc <i>lstopo(1)</i> command to see a list of
available cores and their logical IDs.</p>

<p style="margin-left:11%; margin-top: 1em">To order
processes&rsquo; ranks in MPI_COMM_WORLD: <b><br>
--rank-by</b> &lt;foo&gt;</p>

<p style="margin-left:22%;">Rank in round-robin fashion
according to the specified object, defaults to <i>slot</i>.
Supported options include slot, hwthread, core, L1cache,
L2cache, L3cache, socket, numa, board, and node.</p>

<p style="margin-left:11%; margin-top: 1em">For process
binding: <b><br>
--bind-to</b> &lt;foo&gt;</p>

<p style="margin-left:22%;">Bind processes to the specified
object, defaults to <i>core</i>. Supported options include
slot, hwthread, core, l1cache, l2cache, l3cache, socket,
numa, board, cpu-list, and none.</p>

<p style="margin-left:11%;"><b>-cpus-per-proc</b>,
<b>--cpus-per-proc</b> &lt;#perproc&gt;</p>

<p style="margin-left:22%;">Bind each process to the
specified number of cpus. (deprecated in favor of --map-by
&lt;obj&gt;:PE=n)</p>

<p style="margin-left:11%;"><b>-cpus-per-rank</b>,
<b>--cpus-per-rank</b> &lt;#perrank&gt;</p>

<p style="margin-left:22%;">Alias for
<i>-cpus-per-proc</i>. (deprecated in favor of --map-by
&lt;obj&gt;:PE=n)</p>

<p style="margin-left:11%;"><b>-bind-to-core</b>,
<b>--bind-to-core</b></p>

<p style="margin-left:22%;">Bind processes to cores
(deprecated in favor of --bind-to core)</p>

<p style="margin-left:11%;"><b>-bind-to-socket</b>,
<b>--bind-to-socket</b></p>

<p style="margin-left:22%;">Bind processes to processor
sockets (deprecated in favor of --bind-to socket)</p>

<p style="margin-left:11%;"><b>-report-bindings</b>,
<b>--report-bindings</b></p>

<p style="margin-left:22%;">Report any bindings for
launched processes.</p>

<p style="margin-left:11%; margin-top: 1em">For rankfiles:
<b><br>
-rf</b>, <b>--rankfile</b> &lt;rankfile&gt;</p>

<p style="margin-left:22%;">Provide a rankfile file.</p>

<p style="margin-left:11%; margin-top: 1em">To manage
standard I/O: <b><br>
-output-filename</b>, <b>--output-filename</b>
&lt;filename&gt;</p>

<p style="margin-left:22%;">Redirect the stdout, stderr,
and stddiag of all processes to a process-unique version of
the specified filename. Any directories in the filename will
automatically be created. Each output file will consist of
filename.id, where the id will be the processes&rsquo; rank
in MPI_COMM_WORLD, left-filled with zero&rsquo;s for correct
ordering in listings. A relative path value will be
converted to an absolute path based on the cwd where mpirun
is executed. Note that this <i>will not</i> work on
environments where the file system on compute nodes differs
from that where mpirun is executed.</p>

<p style="margin-left:11%;"><b>-stdin</b>, <b>--stdin</b>
&lt;rank&gt;</p>

<p style="margin-left:22%;">The MPI_COMM_WORLD rank of the
process that is to receive stdin. The default is to forward
stdin to MPI_COMM_WORLD rank 0, but this option can be used
to forward stdin to any process. It is also acceptable to
specify <i>none</i>, indicating that no processes are to
receive stdin.</p>


<p style="margin-left:11%;"><b>-merge-stderr-to-stdout</b>,
<b>--merge-stderr-to-stdout</b></p>

<p style="margin-left:22%;">Merge stderr to stdout for each
process.</p>

<p style="margin-left:11%;"><b>-tag-output</b>,
<b>--tag-output</b></p>

<p style="margin-left:22%;">Tag each line of output to
stdout, stderr, and stddiag with <b>[jobid,
MCW_rank]&lt;stdxxx&gt;</b> indicating the process jobid and
MPI_COMM_WORLD rank of the process that generated the
output, and the channel which generated it.</p>

<p style="margin-left:11%;"><b>-timestamp-output</b>,
<b>--timestamp-output</b></p>

<p style="margin-left:22%;">Timestamp each line of output
to stdout, stderr, and stddiag.</p>

<p style="margin-left:11%;"><b>-xml</b>, <b>--xml</b></p>

<p style="margin-left:22%;">Provide all output to stdout,
stderr, and stddiag in an xml format.</p>

<p style="margin-left:11%;"><b>-xml-file</b>,
<b>--xml-file</b> &lt;filename&gt;</p>

<p style="margin-left:22%;">Provide all output in XML
format to the specified file.</p>

<p style="margin-left:11%;"><b>-xterm</b>, <b>--xterm</b>
&lt;ranks&gt;</p>

<p style="margin-left:22%;">Display the output from the
processes identified by their MPI_COMM_WORLD ranks in
separate xterm windows. The ranks are specified as a
comma-separated list of ranges, with a -1 indicating all. A
separate window will be created for each specified process.
<b>Note:</b> xterm will normally terminate the window upon
termination of the process running within it. However, by
adding a &quot;!&quot; to the end of the list of specified
ranks, the proper options will be provided to ensure that
xterm keeps the window open <i>after</i> the process
terminates, thus allowing you to see the process&rsquo;
output. Each xterm window will subsequently need to be
manually closed. <b>Note:</b> In some environments, xterm
may require that the executable be in the user&rsquo;s path,
or be specified in absolute or relative terms. Thus, it may
be necessary to specify a local executable as
&quot;./foo&quot; instead of just &quot;foo&quot;. If xterm
fails to find the executable, mpirun will hang, but still
respond correctly to a ctrl-c. If this happens, please check
that the executable is being specified correctly and try
again.</p>

<p style="margin-left:11%; margin-top: 1em">To manage files
and runtime environment: <b><br>
-path</b>, <b>--path</b> &lt;path&gt;</p>

<p style="margin-left:22%;">&lt;path&gt; that will be used
when attempting to locate the requested executables. This is
used prior to using the local PATH setting.</p>

<p style="margin-left:11%;"><b>--prefix</b> &lt;dir&gt;</p>

<p style="margin-left:22%;">Prefix directory that will be
used to set the <i>PATH</i> and <i>LD_LIBRARY_PATH</i> on
the remote node before invoking Open MPI or the target
process. See the &quot;Remote Execution&quot; section,
below.</p>

<p style="margin-left:11%;"><b>--noprefix</b></p>

<p style="margin-left:22%;">Disable the automatic --prefix
behavior</p>

<p style="margin-left:11%;"><b>-s</b>,
<b>--preload-binary</b></p>

<p style="margin-left:22%;">Copy the specified
executable(s) to remote machines prior to starting remote
processes. The executables will be copied to the Open MPI
session directory and will be deleted upon completion of the
job.</p>

<p style="margin-left:11%;"><b>--preload-files</b>
&lt;files&gt;</p>

<p style="margin-left:22%;">Preload the comma separated
list of files to the current working directory of the remote
machines where processes will be launched prior to starting
those processes.</p>


<p style="margin-left:11%;"><b>-set-cwd-to-session-dir</b>,
<b>--set-cwd-to-session-dir</b></p>

<p style="margin-left:22%;">Set the working directory of
the started processes to their session directory.</p>

<p style="margin-left:11%;"><b>-wd</b> &lt;dir&gt;</p>

<p style="margin-left:22%;">Synonym for <i>-wdir</i>.</p>

<p style="margin-left:11%;"><b>-wdir</b> &lt;dir&gt;</p>

<p style="margin-left:22%;">Change to the directory
&lt;dir&gt; before the user&rsquo;s program executes. See
the &quot;Current Working Directory&quot; section for notes
on relative paths. <b>Note:</b> If the <i>-wdir</i> option
appears both on the command line and in an application
context, the context will take precedence over the command
line. Thus, if the path to the desired wdir is different on
the backend nodes, then it must be specified as an absolute
path that is correct for the backend node.</p>

<p style="margin-left:11%;"><b>-x</b> &lt;env&gt;</p>

<p style="margin-left:22%;">Export the specified
environment variables to the remote nodes before executing
the program. Only one environment variable can be specified
per <i>-x</i> option. Existing environment variables can be
specified or new variable names specified with corresponding
values. For example: <b><br>
%</b> mpirun -x DISPLAY -x OFILE=/tmp/out ...</p>

<p style="margin-left:22%; margin-top: 1em">The parser for
the <i>-x</i> option is not very sophisticated; it does not
even understand quoted values. Users are advised to set
variables in the environment, and then use <i>-x</i> to
export (not define) them.</p>

<p style="margin-left:11%; margin-top: 1em">Setting MCA
parameters: <b><br>
-gmca</b>, <b>--gmca</b> &lt;key&gt; &lt;value&gt;</p>

<p style="margin-left:22%;">Pass global MCA parameters that
are applicable to all contexts. <i>&lt;key&gt;</i> is the
parameter name; <i>&lt;value&gt;</i> is the parameter
value.</p>

<p style="margin-left:11%;"><b>-mca</b>, <b>--mca</b>
&lt;key&gt; &lt;value&gt;</p>

<p style="margin-left:22%;">Send arguments to various MCA
modules. See the &quot;MCA&quot; section, below.</p>

<p style="margin-left:11%;"><b>-am</b> &lt;arg0&gt;</p>

<p style="margin-left:22%;">Aggregate MCA parameter set
file list.</p>

<p style="margin-left:11%;"><b>-tune</b>, <b>--tune</b>
&lt;tune_file&gt;</p>

<p style="margin-left:22%;">Specify a tune file to set
arguments for various MCA modules and environment variables.
See the &quot;Setting MCA parameters and environment
variables from file&quot; section, below.</p>

<p style="margin-left:11%; margin-top: 1em">For debugging:
<b><br>
-debug</b>, <b>--debug</b></p>

<p style="margin-left:22%;">Invoke the user-level debugger
indicated by the <i>orte_base_user_debugger</i> MCA
parameter.</p>

<p style="margin-left:11%;"><b>--get-stack-traces</b></p>

<p style="margin-left:22%;">When paired with the
<b>--timeout</b> option, <i>mpirun</i> will obtain and print
out stack traces from all launched processes that are still
alive when the timeout expires. Note that obtaining stack
traces can take a little time and produce a lot of output,
especially for large process-count jobs.</p>

<p style="margin-left:11%;"><b>-debugger</b>,
<b>--debugger</b> &lt;args&gt;</p>

<p style="margin-left:22%;">Sequence of debuggers to search
for when <i>--debug</i> is used (i.e. a synonym for
<i>orte_base_user_debugger</i> MCA parameter).</p>

<p style="margin-left:11%;"><b>--timeout</b>
&lt;seconds&gt;</p>

<p style="margin-left:22%;">The maximum number of seconds
that <i>mpirun</i> (also known as <i>mpiexec</i>,
<i>oshrun</i>, <i>orterun</i>, etc.) will run. After this
many seconds, <i>mpirun</i> will abort the launched job and
exit with a non-zero exit status. Using <b>--timeout</b> can
be also useful when combined with the
<b>--get-stack-traces</b> option.</p>

<p style="margin-left:11%;"><b>-tv</b>, <b>--tv</b></p>

<p style="margin-left:22%;">Launch processes under the
TotalView debugger. Deprecated backwards compatibility flag.
Synonym for <i>--debug</i>.</p>

<p style="margin-left:11%; margin-top: 1em">There are also
other options: <b><br>
--allow-run-as-root</b></p>

<p style="margin-left:22%;">Allow <i>mpirun</i> to run when
executed by the root user (<i>mpirun</i> defaults to
aborting when launched as the root user). Be sure to see the
<i>Running as root</i> section, below, for more detail.</p>

<p style="margin-left:11%;"><b>--app</b>
&lt;appfile&gt;</p>

<p style="margin-left:22%;">Provide an appfile, ignoring
all other command line options.</p>

<p style="margin-left:11%;"><b>-cf</b>, <b>--cartofile</b>
&lt;cartofile&gt;</p>

<p style="margin-left:22%;">Provide a cartography file.</p>

<p style="margin-left:11%;"><b>-continuous</b>,
<b>--continuous</b></p>

<p style="margin-left:22%;">Job is to run until explicitly
terminated.</p>

<p style="margin-left:11%;"><b>-disable-recovery</b>,
<b>--disable-recovery</b></p>

<p style="margin-left:22%;">Disable recovery (resets all
recovery options to off).</p>

<p style="margin-left:11%;"><b>-do-not-launch</b>,
<b>--do-not-launch</b></p>

<p style="margin-left:22%;">Perform all necessary
operations to prepare to launch the application, but do not
actually launch it.</p>

<p style="margin-left:11%;"><b>-do-not-resolve</b>,
<b>--do-not-resolve</b></p>

<p style="margin-left:22%;">Do not attempt to resolve
interfaces.</p>

<p style="margin-left:11%;"><b>-enable-recovery</b>,
<b>--enable-recovery</b></p>

<p style="margin-left:22%;">Enable recovery from process
failure [Default = disabled].</p>

<p style="margin-left:11%;"><b>-index-argv-by-rank</b>,
<b>--index-argv-by-rank</b></p>

<p style="margin-left:22%;">Uniquely index argv[0] for each
process using its rank.</p>


<p style="margin-left:11%;"><b>-leave-session-attached</b>,
<b>--leave-session-attached</b></p>

<p style="margin-left:22%;">Do not detach OmpiRTE daemons
used by this application. This allows error messages from
the daemons as well as the underlying environment (e.g.,
when failing to launch a daemon) to be output.</p>

<p style="margin-left:11%;"><b>-max-restarts</b>,
<b>--max-restarts</b> &lt;num&gt;</p>

<p style="margin-left:22%;">Max number of times to restart
a failed process.</p>

<p style="margin-left:11%;"><b>-ompi-server</b>,
<b>--ompi-server</b> &lt;uri or file&gt;</p>

<p style="margin-left:22%;">Specify the URI of the Open MPI
server (or the mpirun to be used as the server), the name of
the file (specified as file:filename) that contains that
info, or the PID (specified as pid:#) of the mpirun to be
used as the server. The Open MPI server is used to support
multi-application data exchange via the MPI-2
MPI_Publish_name and MPI_Lookup_name functions.</p>

<p style="margin-left:11%;"><b>-personality</b>,
<b>--personality</b> &lt;list&gt;</p>

<p style="margin-left:22%;">Comma-separated list of
programming model, languages, and containers being used
(default=&quot;ompi&quot;).</p>

<p style="margin-left:11%;"><b>--ppr</b> &lt;list&gt;</p>

<p style="margin-left:22%;">Comma-separated list of number
of processes on a given resource type [default: none].</p>


<p style="margin-left:11%;"><b>-report-child-jobs-separately</b>,
<b>--report-child-jobs-separately</b></p>

<p style="margin-left:22%;">Return the exit status of the
primary job only.</p>

<p style="margin-left:11%;"><b>-report-events</b>,
<b>--report-events</b> &lt;URI&gt;</p>

<p style="margin-left:22%;">Report events to a tool
listening at the specified URI.</p>

<p style="margin-left:11%;"><b>-report-pid</b>,
<b>--report-pid</b> &lt;channel&gt;</p>

<p style="margin-left:22%;">Print out mpirun&rsquo;s PID
during startup. The channel must be either a &rsquo;-&rsquo;
to indicate that the pid is to be output to stdout, a
&rsquo;+&rsquo; to indicate that the pid is to be output to
stderr, or a filename to which the pid is to be written.</p>

<p style="margin-left:11%;"><b>-report-uri</b>,
<b>--report-uri</b> &lt;channel&gt;</p>

<p style="margin-left:22%;">Print out mpirun&rsquo;s URI
during startup. The channel must be either a &rsquo;-&rsquo;
to indicate that the URI is to be output to stdout, a
&rsquo;+&rsquo; to indicate that the URI is to be output to
stderr, or a filename to which the URI is to be written.</p>

<p style="margin-left:11%;"><b>-show-progress</b>,
<b>--show-progress</b></p>

<p style="margin-left:22%;">Output a brief periodic report
on launch progress.</p>

<p style="margin-left:11%;"><b>-terminate</b>,
<b>--terminate</b></p>

<p style="margin-left:22%;">Terminate the DVM.</p>

<p style="margin-left:11%;"><b>-use-hwthread-cpus</b>,
<b>--use-hwthread-cpus</b></p>

<p style="margin-left:22%;">Use hardware threads as
independent CPUs.</p>

<p style="margin-left:22%; margin-top: 1em">Note that if a
number of slots is not provided to Open MPI (e.g., via the
&quot;slots&quot; keyword in a hostfile or from a resource
manager such as SLURM), the use of this option changes the
default calculation of number of slots on a node. See
&quot;DEFINITION OF &rsquo;SLOT&rsquo;&quot;, above.</p>

<p style="margin-left:22%; margin-top: 1em">Also note that
the use of this option changes the Open MPI&rsquo;s
definition of a &quot;processor element&quot; from a
processor core to a hardware thread. See &quot;DEFINITION OF
&rsquo;PROCESSOR ELEMENT&rsquo;&quot;, above.</p>

<p style="margin-left:11%;"><b>-use-regexp</b>,
<b>--use-regexp</b></p>

<p style="margin-left:22%;">Use regular expressions for
launch.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options are useful for developers; they are not generally
useful to most ORTE and/or MPI users: <b><br>
-d</b>, <b>--debug-devel</b></p>

<p style="margin-left:22%;">Enable debugging of the OmpiRTE
(the run-time layer in Open MPI). This is not generally
useful for most users.</p>

<p style="margin-left:11%;"><b>--debug-daemons</b></p>

<p style="margin-left:22%;">Enable debugging of any OmpiRTE
daemons used by this application.</p>


<p style="margin-left:11%;"><b>--debug-daemons-file</b></p>

<p style="margin-left:22%;">Enable debugging of any OmpiRTE
daemons used by this application, storing output in
files.</p>


<p style="margin-left:11%;"><b>-display-devel-allocation</b>,
<b>--display-devel-allocation</b></p>

<p style="margin-left:22%;">Display a detailed list of the
allocation being used by this job.</p>

<p style="margin-left:11%;"><b>-display-devel-map</b>,
<b>--display-devel-map</b></p>

<p style="margin-left:22%;">Display a more detailed table
showing the mapped location of each process prior to
launch.</p>

<p style="margin-left:11%;"><b>-display-diffable-map</b>,
<b>--display-diffable-map</b></p>

<p style="margin-left:22%;">Display a diffable process map
just before launch.</p>

<p style="margin-left:11%;"><b>-display-topo</b>,
<b>--display-topo</b></p>

<p style="margin-left:22%;">Display the topology as part of
the process map just before launch.</p>

<p style="margin-left:11%;"><b>-launch-agent</b>,
<b>--launch-agent</b></p>

<p style="margin-left:22%;">Name of the executable that is
to be used to start processes on the remote nodes. The
default is &quot;orted&quot;. This option can be used to
test new daemon concepts, or to pass options back to the
daemons without having mpirun itself see them. For example,
specifying a launch agent of orted -mca odls_base_verbose 5
allows the developer to ask the orted for debugging output
without clutter from mpirun itself.</p>


<p style="margin-left:11%;"><b>--report-state-on-timeout</b></p>

<p style="margin-left:22%;">When paired with the
<b>--timeout</b> command line option, report the run-time
subsystem state of each process when the timeout
expires.</p>

<p style="margin-left:11%; margin-top: 1em">There may be
other options listed with <i>mpirun --help</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Environment
Variables <br>
MPIEXEC_TIMEOUT</b></p>

<p style="margin-left:22%;">Synonym for the
<b>--timeout</b> command line option.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">One invocation
of <i>mpirun</i> starts an MPI application running under
Open MPI. If the application is single process multiple data
(SPMD), the application can be specified on the
<i>mpirun</i> command line.</p>

<p style="margin-left:11%; margin-top: 1em">If the
application is multiple instruction multiple data (MIMD),
comprising of multiple programs, the set of programs and
argument can be specified in one of two ways: Extended
Command Line Arguments, and Application Context.</p>

<p style="margin-left:11%; margin-top: 1em">An application
context describes the MIMD program set including all
arguments in a separate file. This file essentially contains
multiple <i>mpirun</i> command lines, less the command name
itself. The ability to specify different options for
different instantiations of a program is another reason to
use an application context.</p>

<p style="margin-left:11%; margin-top: 1em">Extended
command line arguments allow for the description of the
application layout on the command line using colons
(<i>:</i>) to separate the specification of programs and
arguments. Some options are globally set across all
specified programs (e.g. --hostfile), while others are
specific to a single program (e.g. -np).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Specifying
Host Nodes</b> <br>
Host nodes can be identified on the <i>mpirun</i> command
line with the <i>-host</i> option or in a hostfile.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
<br>
mpirun -H aa,aa,bb ./a.out</p>

<p style="margin-left:17%;">launches two processes on node
aa and one on bb.</p>

<p style="margin-left:11%; margin-top: 1em">Or, consider
the hostfile</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b> cat
myhostfile <br>
aa slots=2 <br>
bb slots=2 <br>
cc slots=2</p>

<p style="margin-left:11%; margin-top: 1em">Here, we list
both the host names (aa, bb, and cc) but also how many slots
there are for each. <br>
mpirun -hostfile myhostfile ./a.out</p>

<p style="margin-left:17%;">will launch two processes on
each of the three nodes.</p>

<p style="margin-left:11%;">mpirun -hostfile myhostfile
-host aa ./a.out</p>

<p style="margin-left:17%;">will launch two processes, both
on node aa.</p>

<p style="margin-left:11%;">mpirun -hostfile myhostfile
-host dd ./a.out</p>

<p style="margin-left:17%;">will find no hosts to run on
and abort with an error. That is, the specified host dd is
not in the specified hostfile.</p>

<p style="margin-left:11%; margin-top: 1em">When running
under resource managers (e.g., SLURM, Torque, etc.), Open
MPI will obtain both the hostnames and the number of slots
directly from the resource manger.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Specifying
Number of Processes</b> <br>
As we have just seen, the number of processes to run can be
set using the hostfile. Other mechanisms exist.</p>

<p style="margin-left:11%; margin-top: 1em">The number of
processes launched can be specified as a multiple of the
number of nodes or processor sockets available. For example,
<br>
mpirun -H aa,bb -npersocket 2 ./a.out</p>

<p style="margin-left:17%;">launches processes 0-3 on node
aa and process 4-7 on node bb, where aa and bb are both
dual-socket nodes. The <i>-npersocket</i> option also turns
on the <i>-bind-to-socket</i> option, which is discussed in
a later section.</p>

<p style="margin-left:11%;">mpirun -H aa,bb -npernode 2
./a.out</p>

<p style="margin-left:17%;">launches processes 0-1 on node
aa and processes 2-3 on node bb.</p>

<p style="margin-left:11%;">mpirun -H aa,bb -npernode 1
./a.out</p>

<p style="margin-left:17%;">launches one process per host
node.</p>

<p style="margin-left:11%;">mpirun -H aa,bb -pernode
./a.out</p>

<p style="margin-left:17%;">is the same as <i>-npernode</i>
1.</p>

<p style="margin-left:11%; margin-top: 1em">Another
alternative is to specify the number of processes with the
<i>-np</i> option. Consider now the hostfile</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b> cat
myhostfile <br>
aa slots=4 <br>
bb slots=4 <br>
cc slots=4</p>

<p style="margin-left:11%; margin-top: 1em">Now, <br>
mpirun -hostfile myhostfile -np 6 ./a.out</p>

<p style="margin-left:17%;">will launch processes 0-3 on
node aa and processes 4-5 on node bb. The remaining slots in
the hostfile will not be used since the <i>-np</i> option
indicated that only 6 processes should be launched.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mapping
Processes to Nodes: Using Policies</b> <br>
The examples above illustrate the default mapping of process
processes to nodes. This mapping can also be controlled with
various <i>mpirun</i> options that describe mapping
policies.</p>

<p style="margin-left:11%; margin-top: 1em">Consider the
same hostfile as above, again with <i>-np</i> 6:</p>

<p style="margin-left:11%; margin-top: 1em">node aa node bb
node cc</p>

<p style="margin-left:11%; margin-top: 1em">mpirun 0 1 2 3
4 5</p>

<p style="margin-left:11%; margin-top: 1em">mpirun --map-by
node 0 3 1 4 2 5</p>

<p style="margin-left:11%; margin-top: 1em">mpirun -nolocal
0 1 2 3 4 5</p>

<p style="margin-left:11%; margin-top: 1em">The <i>--map-by
node</i> option will load balance the processes across the
available nodes, numbering each process in a round-robin
fashion.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>-nolocal</i> option prevents any processes from being
mapped onto the local host (in this case node aa). While
<i>mpirun</i> typically consumes few system resources,
<i>-nolocal</i> can be helpful for launching very large jobs
where <i>mpirun</i> may actually need to use noticeable
amounts of memory and/or processing time.</p>

<p style="margin-left:11%; margin-top: 1em">Just as
<i>-np</i> can specify fewer processes than there are slots,
it can also oversubscribe the slots. For example, with the
same hostfile: <br>
mpirun -hostfile myhostfile -np 14 ./a.out</p>

<p style="margin-left:17%;">will launch processes 0-3 on
node aa, 4-7 on bb, and 8-11 on cc. It will then add the
remaining two processes to whichever nodes it chooses.</p>

<p style="margin-left:11%; margin-top: 1em">One can also
specify limits to oversubscription. For example, with the
same hostfile: <br>
mpirun -hostfile myhostfile -np 14 -nooversubscribe
./a.out</p>

<p style="margin-left:17%;">will produce an error since
<i>-nooversubscribe</i> prevents oversubscription.</p>

<p style="margin-left:11%; margin-top: 1em">Limits to
oversubscription can also be specified in the hostfile
itself: <br>
% cat myhostfile <br>
aa slots=4 max_slots=4 <br>
bb max_slots=4 <br>
cc slots=4</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>max_slots</i> field specifies such a limit. When it does,
the <i>slots</i> value defaults to the limit. Now: <br>
mpirun -hostfile myhostfile -np 14 ./a.out</p>

<p style="margin-left:17%;">causes the first 12 processes
to be launched as before, but the remaining two processes
will be forced onto node cc. The other two nodes are
protected by the hostfile against oversubscription by this
job.</p>

<p style="margin-left:11%; margin-top: 1em">Using the
<i>--nooversubscribe</i> option can be helpful since Open
MPI currently does not get &quot;max_slots&quot; values from
the resource manager.</p>

<p style="margin-left:11%; margin-top: 1em">Of course,
<i>-np</i> can also be used with the <i>-H</i> or
<i>-host</i> option. For example, <br>
mpirun -H aa,bb -np 8 ./a.out</p>

<p style="margin-left:17%;">launches 8 processes. Since
only two hosts are specified, after the first two processes
are mapped, one to aa and one to bb, the remaining processes
oversubscribe the specified hosts.</p>

<p style="margin-left:11%; margin-top: 1em">And here is a
MIMD example: <br>
mpirun -H aa -np 1 hostname : -H bb,cc -np 2 uptime</p>

<p style="margin-left:17%;">will launch process 0 running
<i>hostname</i> on node aa and processes 1 and 2 each
running <i>uptime</i> on nodes bb and cc, respectively.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Mapping,
Ranking, and Binding: Oh My!</b> <br>
Open MPI employs a three-phase procedure for assigning
process locations and ranks:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>mapping</b></p></td>
<td width="4%"></td>
<td width="74%">


<p>Assigns a default location to each process</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>ranking</b></p></td>
<td width="4%"></td>
<td width="74%">


<p>Assigns an MPI_COMM_WORLD rank value to each process</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p><b>binding</b></p></td>
<td width="4%"></td>
<td width="74%">


<p>Constrains each process to run on specific
processors</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<i>mapping</i> step is used to assign a default location to
each process based on the mapper being employed. Mapping by
slot, node, and sequentially results in the assignment of
the processes to the node level. In contrast, mapping by
object, allows the mapper to assign the process to an actual
object on each node.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
the location assigned to the process is independent of where
it will be bound - the assignment is used solely as input to
the binding algorithm.</p>

<p style="margin-left:11%; margin-top: 1em">The mapping of
process processes to nodes can be defined not just with
general policies but also, if necessary, using arbitrary
mappings that cannot be described by a simple policy. One
can use the &quot;sequential mapper,&quot; which reads the
hostfile line by line, assigning processes to nodes in
whatever order the hostfile specifies. Use the <i>-mca rmaps
seq</i> option. For example, using the same hostfile as
before:</p>

<p style="margin-left:11%; margin-top: 1em">mpirun
-hostfile myhostfile -mca rmaps seq ./a.out</p>

<p style="margin-left:11%; margin-top: 1em">will launch
three processes, one on each of nodes aa, bb, and cc,
respectively. The slot counts don&rsquo;t matter; one
process is launched per line on whatever node is listed on
the line.</p>

<p style="margin-left:11%; margin-top: 1em">Another way to
specify arbitrary mappings is with a rankfile, which gives
you detailed control over process binding as well. Rankfiles
are discussed below.</p>

<p style="margin-left:11%; margin-top: 1em">The second
phase focuses on the <i>ranking</i> of the process within
the job&rsquo;s MPI_COMM_WORLD. Open MPI separates this from
the mapping procedure to allow more flexibility in the
relative placement of MPI processes. This is best
illustrated by considering the following two cases where we
used the &acirc;map-by ppr:2:socket option:</p>

<p style="margin-left:11%; margin-top: 1em">node aa node
bb</p>

<p style="margin-left:11%; margin-top: 1em">rank-by core 0
1 ! 2 3 4 5 ! 6 7</p>

<p style="margin-left:11%; margin-top: 1em">rank-by socket
0 2 ! 1 3 4 6 ! 5 7</p>

<p style="margin-left:11%; margin-top: 1em">rank-by
socket:span 0 4 ! 1 5 2 6 ! 3 7</p>

<p style="margin-left:11%; margin-top: 1em">Ranking by core
and by slot provide the identical result - a simple
progression of MPI_COMM_WORLD ranks across each node.
Ranking by socket does a round-robin ranking within each
node until all processes have been assigned an MCW rank, and
then progresses to the next node. Adding the <i>span</i>
modifier to the ranking directive causes the ranking
algorithm to treat the entire allocation as a single entity
- thus, the MCW ranks are assigned across all sockets before
circling back around to the beginning.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>binding</i> phase actually binds each process to a given
set of processors. This can improve performance if the
operating system is placing processes suboptimally. For
example, it might oversubscribe some multi-core processor
sockets, leaving other sockets idle; this can lead processes
to contend unnecessarily for common resources. Or, it might
spread processes out too widely; this can be suboptimal if
application performance is sensitive to interprocess
communication costs. Binding can also keep the operating
system from migrating processes excessively, regardless of
how optimally those processes were placed to begin with.</p>

<p style="margin-left:11%; margin-top: 1em">The processors
to be used for binding can be identified in terms of
topological groupings - e.g., binding to an l3cache will
bind each process to all processors within the scope of a
single L3 cache within their assigned location. Thus, if a
process is assigned by the mapper to a certain socket, then
a <i>&acirc;bind-to l3cache</i> directive will cause the
process to be bound to the processors that share a single L3
cache within that socket.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
processes can be assigned to processors based on their local
rank on a node using the <i>--bind-to cpu-list:ordered</i>
option with an associated <i>--cpu-list
&quot;0,2,5&quot;</i>. In this example, the first process on
a node will be bound to cpu 0, the second process on the
node will be bound to cpu 2, and the third process on the
node will be bound to cpu 5. <i>--bind-to</i> will also
accept <i>cpulist:ortered</i> as a synonym to
<i>cpu-list:ordered</i>. Note that an error will result if
more processes are assigned to a node than cpus are
provided.</p>

<p style="margin-left:11%; margin-top: 1em">To help balance
loads, the binding directive uses a round-robin method when
binding to levels lower than used in the mapper. For
example, consider the case where a job is mapped to the
socket level, and then bound to core. Each socket will have
multiple cores, so if multiple processes are mapped to a
given socket, the binding algorithm will assign each process
located to a socket to a unique core in a round-robin
manner.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
processes mapped by l2cache and then bound to socket will
simply be bound to all the processors in the socket where
they are located. In this manner, users can exert detailed
control over relative MCW rank location and binding.</p>

<p style="margin-left:11%; margin-top: 1em">Finally,
<i>--report-bindings</i> can be used to report bindings.</p>

<p style="margin-left:11%; margin-top: 1em">As an example,
consider a node with two processor sockets, each comprised
of four cores, and each of those cores contains one hardware
thread. We run <i>mpirun</i> with <i>-np 4
--report-bindings</i> and the following additional
options:</p>

<p style="margin-left:11%; margin-top: 1em">% mpirun ...
--map-by core --bind-to core <br>
[...] ... binding child [...,0] to cpus 0001 <br>
[...] ... binding child [...,1] to cpus 0002 <br>
[...] ... binding child [...,2] to cpus 0004 <br>
[...] ... binding child [...,3] to cpus 0008</p>

<p style="margin-left:11%; margin-top: 1em">% mpirun ...
--map-by socket --bind-to socket <br>
[...] ... binding child [...,0] to socket 0 cpus 000f <br>
[...] ... binding child [...,1] to socket 1 cpus 00f0 <br>
[...] ... binding child [...,2] to socket 0 cpus 000f <br>
[...] ... binding child [...,3] to socket 1 cpus 00f0</p>

<p style="margin-left:11%; margin-top: 1em">% mpirun ...
--map-by slot:PE=2 --bind-to core <br>
[...] ... binding child [...,0] to cpus 0003 <br>
[...] ... binding child [...,1] to cpus 000c <br>
[...] ... binding child [...,2] to cpus 0030 <br>
[...] ... binding child [...,3] to cpus 00c0</p>

<p style="margin-left:11%; margin-top: 1em">% mpirun ...
--bind-to none</p>

<p style="margin-left:11%; margin-top: 1em">Here,
<i>--report-bindings</i> shows the binding of each process
as a mask. In the first case, the processes bind to
successive cores as indicated by the masks 0001, 0002, 0004,
and 0008. In the second case, processes bind to all cores on
successive sockets as indicated by the masks 000f and 00f0.
The processes cycle through the processor sockets in a
round-robin fashion as many times as are needed.</p>

<p style="margin-left:11%; margin-top: 1em">In the third
case, the masks show us that 2 cores have been bound per
process. Specifically, the mapping by slot with the
<i>PE=2</i> qualifier indicated that each slot (i.e.,
process) should consume two processor elements. Since
<i>--use-hwthread-cpus</i> was not specified, Open MPI
defined &quot;processor element&quot; as &quot;core&quot;,
and therefore the <i>--bind-to core</i> caused each process
to be bound to both of the cores to which it was mapped.</p>

<p style="margin-left:11%; margin-top: 1em">In the fourth
case, binding is turned off and no bindings are
reported.</p>

<p style="margin-left:11%; margin-top: 1em">Open
MPI&rsquo;s support for process binding depends on the
underlying operating system. Therefore, certain process
binding options may not be available on every system.</p>

<p style="margin-left:11%; margin-top: 1em">Process binding
can also be set with MCA parameters. Their usage is less
convenient than that of <i>mpirun</i> options. On the other
hand, MCA parameters can be set not only on the
<i>mpirun</i> command line, but alternatively in a system or
user mca-params.conf file or as environment variables, as
described in the MCA section below. Some examples
include:</p>

<p style="margin-left:11%; margin-top: 1em">mpirun option
MCA parameter key value</p>

<p style="margin-left:11%; margin-top: 1em">--map-by core
rmaps_base_mapping_policy core <br>
--map-by socket rmaps_base_mapping_policy socket <br>
--rank-by core rmaps_base_ranking_policy core <br>
--bind-to core hwloc_base_binding_policy core <br>
--bind-to socket hwloc_base_binding_policy socket <br>
--bind-to none hwloc_base_binding_policy none</p>


<p style="margin-left:11%; margin-top: 1em"><b>Rankfiles</b>
<br>
Rankfiles are text files that specify detailed information
about how individual processes should be mapped to nodes,
and to which processor(s) they should be bound. Each line of
a rankfile specifies the location of one process (for MPI
jobs, the process&rsquo; &quot;rank&quot; refers to its rank
in MPI_COMM_WORLD). The general form of each line in the
rankfile is:</p>

<p style="margin-left:11%; margin-top: 1em">rank
&lt;N&gt;=&lt;hostname&gt; slot=&lt;slot list&gt;</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<p style="margin-left:11%; margin-top: 1em">$ cat
myrankfile <br>
rank 0=aa slot=1:0-2 <br>
rank 1=bb slot=0:0,1 <br>
rank 2=cc slot=1-2 <br>
$ mpirun -H aa,bb,cc,dd -rf myrankfile ./a.out</p>

<p style="margin-left:11%; margin-top: 1em">Means that</p>

<p style="margin-left:11%; margin-top: 1em">Rank 0 runs on
node aa, bound to logical socket 1, cores 0-2. <br>
Rank 1 runs on node bb, bound to logical socket 0, cores 0
and 1. <br>
Rank 2 runs on node cc, bound to logical cores 1 and 2.</p>

<p style="margin-left:11%; margin-top: 1em">Rankfiles can
alternatively be used to specify <i>physical</i> processor
locations. In this case, the syntax is somewhat different.
Sockets are no longer recognized, and the slot number given
must be the number of the physical PU as most OS&rsquo;s do
not assign a unique physical identifier to each core in the
node. Thus, a proper physical rankfile looks something like
the following:</p>

<p style="margin-left:11%; margin-top: 1em">$ cat
myphysicalrankfile <br>
rank 0=aa slot=1 <br>
rank 1=bb slot=8 <br>
rank 2=cc slot=6</p>

<p style="margin-left:11%; margin-top: 1em">This means
that</p>

<p style="margin-left:11%; margin-top: 1em">Rank 0 will run
on node aa, bound to the core that contains physical PU 1
<br>
Rank 1 will run on node bb, bound to the core that contains
physical PU 8 <br>
Rank 2 will run on node cc, bound to the core that contains
physical PU 6</p>

<p style="margin-left:11%; margin-top: 1em">Rankfiles are
treated as <i>logical</i> by default, and the MCA parameter
rmaps_rank_file_physical must be set to 1 to indicate that
the rankfile is to be considered as <i>physical</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The hostnames
listed above are &quot;absolute,&quot; meaning that actual
resolveable hostnames are specified. However, hostnames can
also be specified as &quot;relative,&quot; meaning that they
are specified in relation to an externally-specified list of
hostnames (e.g., by mpirun&rsquo;s --host argument, a
hostfile, or a job scheduler).</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;relative&quot; specification is of the form
&quot;+n&lt;X&gt;&quot;, where X is an integer specifying
the Xth hostname in the set of all available hostnames,
indexed from 0. For example:</p>

<p style="margin-left:11%; margin-top: 1em">$ cat
myrankfile <br>
rank 0=+n0 slot=1:0-2 <br>
rank 1=+n1 slot=0:0,1 <br>
rank 2=+n2 slot=1-2 <br>
$ mpirun -H aa,bb,cc,dd -rf myrankfile ./a.out</p>

<p style="margin-left:11%; margin-top: 1em">Starting with
Open MPI v1.7, all socket/core slot locations are be
specified as <i>logical</i> indexes (the Open MPI v1.6
series used <i>physical</i> indexes). You can use tools such
as HWLOC&rsquo;s &quot;lstopo&quot; to find the logical
indexes of socket and cores.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Application
Context or Executable Program?</b> <br>
To distinguish the two different forms, <i>mpirun</i> looks
on the command line for <i>--app</i> option. If it is
specified, then the file named on the command line is
assumed to be an application context. If it is not
specified, then the file is assumed to be an executable
program.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Locating
Files</b> <br>
If no relative or absolute path is specified for a file,
Open MPI will first look for files by searching the
directories specified by the <i>--path</i> option. If there
is no <i>--path</i> option set or if the file is not found
at the <i>--path</i> location, then Open MPI will search the
user&rsquo;s PATH environment variable as defined on the
source node(s).</p>

<p style="margin-left:11%; margin-top: 1em">If a relative
directory is specified, it must be relative to the initial
working directory determined by the specific starter used.
For example when using the rsh or ssh starters, the initial
directory is $HOME by default. Other starters may set the
initial directory to the current working directory from the
invocation of <i>mpirun</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Current
Working Directory</b> <br>
The <i>&minus;wdir</i> mpirun option (and its synonym,
<i>&minus;wd</i>) allows the user to change to an arbitrary
directory before the program is invoked. It can also be used
in application context files to specify working directories
on specific nodes and/or for specific applications.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>&minus;wdir</i> option appears both in a context file and
on the command line, the context file directory will
override the command line value.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>-wdir</i> option is specified, Open MPI will attempt to
change to the specified directory on all of the remote
nodes. If this fails, <i>mpirun</i> will abort.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>-wdir</i> option is <b>not</b> specified, Open MPI will
send the directory name where <i>mpirun</i> was invoked to
each of the remote nodes. The remote nodes will try to
change to that directory. If they are unable (e.g., if the
directory does not exist on that node), then Open MPI will
use the default directory determined by the starter.</p>

<p style="margin-left:11%; margin-top: 1em">All directory
changing occurs before the user&rsquo;s program is invoked;
it does not wait until <i>MPI_INIT</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Standard
I/O</b> <br>
Open MPI directs UNIX standard input to /dev/null on all
processes except the MPI_COMM_WORLD rank 0 process. The
MPI_COMM_WORLD rank 0 process inherits standard input from
<i>mpirun</i>. <b>Note:</b> The node that invoked
<i>mpirun</i> need not be the same as the node where the
MPI_COMM_WORLD rank 0 process resides. Open MPI handles the
redirection of <i>mpirun</i>&rsquo;s standard input to the
rank 0 process.</p>

<p style="margin-left:11%; margin-top: 1em">Open MPI
directs UNIX standard output and error from remote nodes to
the node that invoked <i>mpirun</i> and prints it on the
standard output/error of <i>mpirun</i>. Local processes
inherit the standard output/error of <i>mpirun</i> and
transfer to it directly.</p>

<p style="margin-left:11%; margin-top: 1em">Thus it is
possible to redirect standard I/O for Open MPI applications
by using the typical shell redirection procedure on
<i>mpirun</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b> mpirun
-np 2 my_app &lt; my_input &gt; my_output</p>

<p style="margin-left:11%; margin-top: 1em">Note that in
this example <i>only</i> the MPI_COMM_WORLD rank 0 process
will receive the stream from <i>my_input</i> on stdin. The
stdin on all the other nodes will be tied to /dev/null.
However, the stdout from all nodes will be collected into
the <i>my_output</i> file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Signal
Propagation</b> <br>
When orterun receives a SIGTERM and SIGINT, it will attempt
to kill the entire job by sending all processes in the job a
SIGTERM, waiting a small number of seconds, then sending all
processes in the job a SIGKILL.</p>

<p style="margin-left:11%; margin-top: 1em">SIGUSR1 and
SIGUSR2 signals received by orterun are propagated to all
processes in the job.</p>

<p style="margin-left:11%; margin-top: 1em">A SIGTSTOP
signal to mpirun will cause a SIGSTOP signal to be sent to
all of the programs started by mpirun and likewise a SIGCONT
signal to mpirun will cause a SIGCONT sent.</p>

<p style="margin-left:11%; margin-top: 1em">Other signals
are not currently propagated by orterun.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Process
Termination / Signal Handling</b> <br>
During the run of an MPI application, if any process dies
abnormally (either exiting before invoking
<i>MPI_FINALIZE</i>, or dying as the result of a signal),
<i>mpirun</i> will print out an error message and kill the
rest of the MPI application.</p>

<p style="margin-left:11%; margin-top: 1em">User signal
handlers should probably avoid trying to cleanup MPI state
(Open MPI is currently not async-signal-safe; see
MPI_Init_thread(3) for details about
<i>MPI_THREAD_MULTIPLE</i> and thread safety). For example,
if a segmentation fault occurs in <i>MPI_SEND</i> (perhaps
because a bad buffer was passed in) and a user signal
handler is invoked, if this user handler attempts to invoke
<i>MPI_FINALIZE</i>, Bad Things could happen since Open MPI
was already &quot;in&quot; MPI when the error occurred.
Since <i>mpirun</i> will notice that the process died due to
a signal, it is probably not necessary (and safest) for the
user to only clean up non-MPI state.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Process
Environment</b> <br>
Processes in the MPI application inherit their environment
from the Open RTE daemon upon the node on which they are
running. The environment is typically inherited from the
user&rsquo;s shell. On remote nodes, the exact environment
is determined by the boot MCA module used. The <i>rsh</i>
launch module, for example, uses either
<i>rsh</i>/<i>ssh</i> to launch the Open RTE daemon on
remote nodes, and typically executes one or more of the
user&rsquo;s shell-setup files before launching the Open RTE
daemon. When running dynamically linked applications which
require the <i>LD_LIBRARY_PATH</i> environment variable to
be set, care must be taken to ensure that it is correctly
set when booting Open MPI.</p>

<p style="margin-left:11%; margin-top: 1em">See the
&quot;Remote Execution&quot; section for more details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Remote
Execution</b> <br>
Open MPI requires that the <i>PATH</i> environment variable
be set to find executables on remote nodes (this is
typically only necessary in <i>rsh</i>- or <i>ssh</i>-based
environments -- batch/scheduled environments typically copy
the current environment to the execution of remote jobs, so
if the current environment has <i>PATH</i> and/or
<i>LD_LIBRARY_PATH</i> set properly, the remote nodes will
also have it set properly). If Open MPI was compiled with
shared library support, it may also be necessary to have the
<i>LD_LIBRARY_PATH</i> environment variable set on remote
nodes as well (especially to find the shared libraries
required to run user MPI applications).</p>

<p style="margin-left:11%; margin-top: 1em">However, it is
not always desirable or possible to edit shell startup files
to set <i>PATH</i> and/or <i>LD_LIBRARY_PATH</i>. The
<i>--prefix</i> option is provided for some simple
configurations where this is not possible.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>--prefix</i> option takes a single argument: the base
directory on the remote node where Open MPI is installed.
Open MPI will use this directory to set the remote
<i>PATH</i> and <i>LD_LIBRARY_PATH</i> before executing any
Open MPI or user applications. This allows running Open MPI
jobs without having pre-configured the <i>PATH</i> and
<i>LD_LIBRARY_PATH</i> on the remote nodes.</p>

<p style="margin-left:11%; margin-top: 1em">Open MPI adds
the basename of the current node&rsquo;s &quot;bindir&quot;
(the directory where Open MPI&rsquo;s executables are
installed) to the prefix and uses that to set the
<i>PATH</i> on the remote node. Similarly, Open MPI adds the
basename of the current node&rsquo;s &quot;libdir&quot; (the
directory where Open MPI&rsquo;s libraries are installed) to
the prefix and uses that to set the <i>LD_LIBRARY_PATH</i>
on the remote node. For example:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p style="margin-top: 1em">Local bindir:</p></td>
<td width="3%"></td>
<td width="41%">


<p style="margin-top: 1em">/local/node/directory/bin</p></td>
<td width="25%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="20%">


<p>Local libdir:</p></td>
<td width="3%"></td>
<td width="41%">


<p>/local/node/directory/lib64</p></td>
<td width="25%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the
following command line is used:</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b> mpirun
--prefix /remote/node/directory</p>

<p style="margin-left:11%; margin-top: 1em">Open MPI will
add &quot;/remote/node/directory/bin&quot; to the
<i>PATH</i> and &quot;/remote/node/directory/lib64&quot; to
the <i>LD_LIBRARY_PATH</i> on the remote node before
attempting to execute anything.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>--prefix</i> option is not sufficient if the installation
paths on the remote node are different than the local node
(e.g., if &quot;/lib&quot; is used on the local node, but
&quot;/lib64&quot; is used on the remote node), or if the
installation paths are something other than a subdirectory
under a common prefix.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
executing <i>mpirun</i> via an absolute pathname is
equivalent to specifying <i>--prefix</i> without the last
subdirectory in the absolute pathname to <i>mpirun</i>. For
example:</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b>
/usr/local/bin/mpirun ...</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>

<p style="margin-left:11%; margin-top: 1em"><b>%</b> mpirun
--prefix /usr/local</p>

<p style="margin-left:11%; margin-top: 1em"><b>Exported
Environment Variables</b> <br>
All environment variables that are named in the form OMPI_*
will automatically be exported to new processes on the local
and remote nodes. Environmental parameters can also be
set/forwarded to the new processes using the MCA parameter
<i>mca_base_env_list</i>. The <i>&minus;x</i> option to
<i>mpirun</i> has been deprecated, but the syntax of the MCA
param follows that prior example. While the syntax of the
<i>&minus;x</i> option and MCA param allows the definition
of new variables, note that the parser for these options are
currently not very sophisticated - it does not even
understand quoted values. Users are advised to set variables
in the environment and use the option to export them; not to
define them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Setting MCA
Parameters</b> <br>
The <i>-mca</i> switch allows the passing of parameters to
various MCA (Modular Component Architecture) modules. MCA
modules have direct impact on MPI programs because they
allow tunable parameters to be set at run time (such as
which BTL communication device driver to use, what
parameters to pass to that BTL, etc.).</p>

<p style="margin-left:11%; margin-top: 1em">The <i>-mca</i>
switch takes two arguments: <i>&lt;key&gt;</i> and
<i>&lt;value&gt;</i>. The <i>&lt;key&gt;</i> argument
generally specifies which MCA module will receive the value.
For example, the <i>&lt;key&gt;</i> &quot;btl&quot; is used
to select which BTL to be used for transporting MPI
messages. The <i>&lt;value&gt;</i> argument is the value
that is passed. For example: <br>
mpirun -mca btl tcp,self -np 1 foo</p>

<p style="margin-left:17%;">Tells Open MPI to use the
&quot;tcp&quot; and &quot;self&quot; BTLs, and to run a
single copy of &quot;foo&quot; an allocated node.</p>

<p style="margin-left:11%;">mpirun -mca btl self -np 1
foo</p>

<p style="margin-left:17%;">Tells Open MPI to use the
&quot;self&quot; BTL, and to run a single copy of
&quot;foo&quot; an allocated node.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>-mca</i>
switch can be used multiple times to specify different
<i>&lt;key&gt;</i> and/or <i>&lt;value&gt;</i> arguments. If
the same <i>&lt;key&gt;</i> is specified more than once, the
<i>&lt;value&gt;</i>s are concatenated with a comma
(&quot;,&quot;) separating them.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
<i>-mca</i> switch is simply a shortcut for setting
environment variables. The same effect may be accomplished
by setting corresponding environment variables before
running <i>mpirun</i>. The form of the environment variables
that Open MPI sets is:</p>


<p style="margin-left:11%; margin-top: 1em">OMPI_MCA_&lt;key&gt;=&lt;value&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Thus, the
<i>-mca</i> switch overrides any previously set environment
variables. The <i>-mca</i> settings similarly override MCA
parameters set in the
$OPAL_PREFIX/etc/openmpi-mca-params.conf or
$HOME/.openmpi/mca-params.conf file.</p>

<p style="margin-left:11%; margin-top: 1em">Unknown
<i>&lt;key&gt;</i> arguments are still set as environment
variable -- they are not checked (by <i>mpirun</i>) for
correctness. Illegal or incorrect <i>&lt;value&gt;</i>
arguments may or may not be reported -- it depends on the
specific MCA module.</p>

<p style="margin-left:11%; margin-top: 1em">To find the
available component types under the MCA architecture, or to
find the available parameters for a specific component, use
the <i>ompi_info</i> command. See the <i>ompi_info(1)</i>
man page for detailed information on the command.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Setting MCA
parameters and environment variables from file.</b> <br>
The <i>-tune</i> command line option and its synonym <i>-mca
mca_base_envar_file_prefix</i> allows a user to set mca
parameters and environment variables with the syntax
described below. This option requires a single file or list
of files separated by &quot;,&quot; to follow.</p>

<p style="margin-left:11%; margin-top: 1em">A valid line in
the file may contain zero or many &quot;-x&quot;,
&quot;-mca&quot;, or &acirc;--mca&acirc; arguments. The
following patterns are supported: -mca var val -mca var
&quot;val&quot; -x var=val -x var. If any argument is
duplicated in the file, the last value read will be
used.</p>

<p style="margin-left:11%; margin-top: 1em">MCA parameters
and environment specified on the command line have higher
precedence than variables specified in the file.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Running as
root</b> <br>
The Open MPI team strongly advises against executing
<i>mpirun</i> as the root user. MPI applications should be
run as regular (non-root) users.</p>

<p style="margin-left:11%; margin-top: 1em">Reflecting this
advice, mpirun will refuse to run as root by default. To
override this default, you can add the
<i>--allow-run-as-root</i> option to the <i>mpirun</i>
command line, or you can set the environmental parameters
<i>OMPI_ALLOW_RUN_AS_ROOT=1</i> and
<i>OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1</i>. Note that it takes
setting <i>two</i> environment variables to effect the same
behavior as <i>--allow-run-as-root</i> in order to stress
the Open MPI team&rsquo;s strong advice against running as
the root user. After extended discussions with communities
who use containers (where running as the root user is the
default), there was a persistent desire to be able to enable
root execution of <i>mpirun</i> via an environmental control
(vs. the existing <i>--allow-run-as-root</i> command line
parameter). The compromise of using <i>two</i> environment
variables was reached: it allows root execution via an
environmental control, but it conveys the Open MPI
team&rsquo;s strong recomendation against this behavior.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Exit
status</b> <br>
There is no standard definition for what <i>mpirun</i>
should return as an exit status. After considerable
discussion, we settled on the following method for assigning
the <i>mpirun</i> exit status (note: in the following
description, the &quot;primary&quot; job is the initial
application started by mpirun - all jobs that are spawned by
that job are designated &quot;secondary&quot; jobs):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>if all processes in the primary job normally terminate
with exit status 0, we return 0</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>if one or more processes in the primary job normally
terminate with non-zero exit status, we return the exit
status of the process with the lowest MPI_COMM_WORLD rank to
have a non-zero status</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>if all processes in the primary job normally terminate
with exit status 0, and one or more processes in a secondary
job normally terminate with non-zero exit status, we (a)
return the exit status of the process with the lowest
MPI_COMM_WORLD rank in the lowest jobid to have a non-zero
status, and (b) output a message summarizing the exit status
of the primary and all secondary jobs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>if the cmd line option --report-child-jobs-separately is
set, we will return -only- the exit status of the primary
job. Any non-zero exit status in secondary jobs will be
reported solely in a summary print statement.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">By default, the
job will abort when any process terminates with non-zero
status. The MCA parameter
&quot;orte_abort_on_non_zero_status&quot; can be set to
&quot;false&quot; (or &quot;0&quot;) to cause OMPI to not
abort a job if one or more processes return a non-zero
status. In that situation the OMPI records and notes that
processes exited with non-zero termination status to report
the approprate exit status of <i>mpirun</i> (per bullet
points above).</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Be sure also to
see the examples throughout the sections above. <br>
mpirun -np 4 -mca btl ib,tcp,self prog1</p>

<p style="margin-left:17%;">Run 4 copies of prog1 using the
&quot;ib&quot;, &quot;tcp&quot;, and &quot;self&quot;
BTL&rsquo;s for the transport of MPI messages.</p>

<p style="margin-left:11%;">mpirun -np 4 -mca btl
tcp,sm,self</p>

<p style="margin-left:17%;">--mca btl_tcp_if_include eth0
prog1 <br>
Run 4 copies of prog1 using the &quot;tcp&quot;,
&quot;sm&quot; and &quot;self&quot; BTLs for the transport
of MPI messages, with TCP using only the eth0 interface to
communicate. Note that other BTLs have similar if_include
MCA parameters.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>mpirun</i>
returns 0 if all processes started by <i>mpirun</i> exit
after calling MPI_FINALIZE. A non-zero value is returned if
an internal error occurred in mpirun, or one or more
processes exited before calling MPI_FINALIZE. If an internal
error occurred in mpirun, the corresponding error code is
returned. In the event that one or more processes exit
before calling MPI_FINALIZE, the return value of the
MPI_COMM_WORLD rank of the process that <i>mpirun</i> first
notices died before calling MPI_FINALIZE will be returned.
Note that, in general, this will be the first process that
died but is not guaranteed to be so.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>--timeout</b> command line option is used and the timeout
expires before the job completes (thereby forcing
<i>mpirun</i> to kill the job) <i>mpirun</i> will return an
exit status equivalent to the value of <b>ETIMEDOUT</b>
(which is typically 110 on Linux and OS X systems).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">MPI_Init_thread(3)</p>
<hr>
</body>
</html>
