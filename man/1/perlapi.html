<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:03 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLAPI</title>

</head>
<body>
<h1>perlapi</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlapi &minus;
autogenerated documentation for the perl public API</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This file
contains most of the documentation of the perl public
<small>API,</small> as generated by <i>embed.pl</i>.
Specifically, it is a listing of functions, macros, flags,
and variables that may be used by extension writers. Besides
perlintern and <i>config.h</i>, some items are listed here
as being actually documented in another pod.</p>

<p style="margin-left:11%; margin-top: 1em">At the end is a
list of functions which have yet to be documented. Patches
welcome! The interfaces of these are subject to change
without notice.</p>

<p style="margin-left:11%; margin-top: 1em">Some of the
functions documented here are consolidated so that a single
entry serves for multiple functions which all do basically
the same thing, but have some slight differences. For
example, one form might process magic, while another
doesn&rsquo;t. The name of each variation is listed at the
top of the single entry. But if all have the same signature
(arguments and return type) except for their names, only the
usage for the base form is shown. If any one of the forms
has a different signature (such as returning
&quot;const&quot; or not) every function&rsquo;s signature
is explicitly displayed.</p>

<p style="margin-left:11%; margin-top: 1em">Anything not
listed here or in the other mentioned pods is not part of
the public <small>API,</small> and should not be used by
extension writers at all. For these reasons, blindly using
functions listed in <i>proto.h</i> is to be avoided when
writing extensions.</p>

<p style="margin-left:11%; margin-top: 1em">In Perl, unlike
C, a string of characters may generally contain embedded
&quot;NUL&quot; characters. Sometimes in the documentation a
Perl string is referred to as a &quot;buffer&quot; to
distinguish it from a C string, but sometimes they are both
just referred to as strings.</p>

<p style="margin-left:11%; margin-top: 1em">Note that all
Perl <small>API</small> global variables must be referenced
with the &quot;PL_&quot; prefix. Again, those not listed
here are not to be used by extension writers, and can be
changed or removed without notice; same with macros. Some
macros are provided for compatibility with the older,
unadorned names, but this support may be disabled in a
future release.</p>

<p style="margin-left:11%; margin-top: 1em">Perl was
originally written to handle US-ASCII only (that is
characters whose ordinal numbers are in the range 0 &minus;
127). And documentation and comments may still use the term
<small>ASCII,</small> when sometimes in fact the entire
range from 0 &minus; 255 is meant.</p>

<p style="margin-left:11%; margin-top: 1em">The non-ASCII
characters below 256 can have various meanings, depending on
various things. (See, most notably, perllocale.) But usually
the whole range can be referred to as
<small>ISO&minus;8859&minus;1.</small> Often, the term
&quot;Latin&minus;1&quot; (or &quot;Latin1&quot;) is used as
an equivalent for <small>ISO&minus;8859&minus;1.</small> But
some people treat &quot;Latin1&quot; as referring just to
the characters in the range 128 through 255, or sometimes
from 160 through 255. This documentation uses
&quot;Latin1&quot; and &quot;Latin&minus;1&quot; to refer to
all 256 characters.</p>

<p style="margin-left:11%; margin-top: 1em">Note that Perl
can be compiled and run under either <small>ASCII</small> or
<small>EBCDIC</small> (See perlebcdic). Most of the
documentation (and even comments in the code) ignore the
<small>EBCDIC</small> possibility. For almost all purposes
the differences are transparent. As an example, under
<small>EBCDIC,</small> instead of
<small>UTF&minus;8,</small> UTF-EBCDIC is used to encode
Unicode strings, and so whenever this documentation refers
to &quot;utf8&quot; (and variants of that name, including in
function names), it also (essentially transparently) means
&quot;UTF&minus;EBCDIC&quot;. But the ordinals of characters
differ between <small>ASCII, EBCDIC,</small> and the
<small>UTF&minus;</small> encodings, and a string encoded in
UTF-EBCDIC may occupy a different number of bytes than in
<small>UTF&minus;8.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
organization of this document is tentative and subject to
change. Suggestions and patches welcome
perl5&minus;porters@perl.org
&lt;mailto:perl5-porters@perl.org&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">The sections in
this document currently are <br>
&quot; <small>AV</small> Handling&quot; <br>
&quot;Callback Functions&quot; <br>
&quot;Casting&quot; <br>
&quot;Character case changing&quot; <br>
&quot;Character classification&quot; <br>
&quot;Compiler and Preprocessor information&quot; <br>
&quot;Compiler directives&quot; <br>
&quot;Compile-time scope hooks&quot; <br>
&quot;Concurrency&quot; <br>
&quot;COPs and Hint Hashes&quot; <br>
&quot;Custom Operators&quot; <br>
&quot; <small>CV</small> Handling&quot; <br>
&quot;Debugging&quot; <br>
&quot;Display functions&quot; <br>
&quot;Embedding, Threads, and Interpreter Cloning&quot; <br>
&quot;Errno&quot; <br>
&quot;Exception Handling (simple) Macros&quot; <br>
&quot;Filesystem configuration values&quot; <br>
&quot;Floating point&quot; <br>
&quot;General Configuration&quot; <br>
&quot;Global Variables&quot; <br>
&quot; <small>GV</small> Handling and Stashes&quot; <br>
&quot;Hook manipulation&quot; <br>
&quot; <small>HV</small> Handling&quot; <br>
&quot;Input/Output&quot; <br>
&quot;Integer&quot; <br>
&quot;I/O Formats&quot; <br>
&quot;Lexer interface&quot; <br>
&quot;Locales&quot; <br>
&quot;Magic&quot; <br>
&quot;Memory Management&quot; <br>
&quot; <small>MRO&quot;</small> <br>
&quot;Multicall Functions&quot; <br>
&quot;Numeric Functions&quot; <br>
&quot;Optrees&quot; <br>
&quot;Pack and Unpack&quot; <br>
&quot;Pad Data Structures&quot; <br>
&quot;Password and Group access&quot; <br>
&quot;Paths to system commands&quot; <br>
&quot;Prototype information&quot; <br>
&quot; <small>REGEXP</small> Functions&quot; <br>
&quot;Reports and Formats&quot; <br>
&quot;Signals&quot; <br>
&quot;Site configuration&quot; <br>
&quot;Sockets configuration values&quot; <br>
&quot;Source Filters&quot; <br>
&quot;Stack Manipulation Macros&quot; <br>
&quot;String Handling&quot; <br>
&quot; <small>SV</small> Flags&quot; <br>
&quot; <small>SV</small> Handling&quot; <br>
&quot;Tainting&quot; <br>
&quot;Time&quot; <br>
&quot;Typedef names&quot; <br>
&quot;Unicode Support&quot; <br>
&quot;Utility Functions&quot; <br>
&quot;Versioning&quot; <br>
&quot;Warning and Dieing&quot; <br>
&quot; <small>XS&quot;</small> <br>
&quot;Undocumented elements&quot;</p>

<p style="margin-left:11%; margin-top: 1em">The listing
below is alphabetical, case insensitive.</p>

<h2>AV Handling
<a name="AV Handling"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;AV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;AvALLOC&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">AvALLOC(AV*
av)</p>

<p style="margin-left:11%;">&quot;AvARRAY&quot;</p>

<p style="margin-left:17%;">Returns a pointer to the
<small>AV</small> &rsquo;s internal SV* array.</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
for doing pointer arithmetic on the array. If all you need
is to look up an array element, then prefer
&quot;av_fetch&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV**
AvARRAY(AV* av)</p>

<p style="margin-left:11%;">&quot;av_clear&quot;</p>

<p style="margin-left:17%;">Frees all the elements of an
array, leaving it empty. The <small>XS</small> equivalent of
&quot;@array = ()&quot;. See also &quot;av_undef&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note that it is
possible that the actions of a destructor called directly or
indirectly by freeing an element of the array could cause
the reference count of the array itself to be reduced (e.g.
by deleting an entry in the symbol table). So it is a
possibility that the <small>AV</small> could have been freed
(or even reallocated) on return from the call unless you
hold a reference to it.</p>

<p style="margin-left:17%; margin-top: 1em">void
av_clear(AV *av)</p>

<p style="margin-left:11%;">&quot;av_count&quot;</p>

<p style="margin-left:17%;">Returns the number of elements
in the array &quot;av&quot;. This is the true length of the
array, including any undefined elements. It is always the
same as &quot;av_top_index(av)&nbsp;+&nbsp;1&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
av_count(AV *av)</p>


<p style="margin-left:11%;">&quot;av_create_and_push&quot;</p>

<p style="margin-left:17%;">Push an <small>SV</small> onto
the end of the array, creating the array if necessary. A
small internal helper function to remove a commonly
duplicated idiom.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;av_create_and_push&quot; must be explicitly called as
&quot;Perl_av_create_and_push&quot; with an
&quot;aTHX_&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_av_create_and_push(pTHX_ AV **const avp, <br>
SV *const val)</p>


<p style="margin-left:11%;">&quot;av_create_and_unshift_one&quot;</p>

<p style="margin-left:17%;">Unshifts an <small>SV</small>
onto the beginning of the array, creating the array if
necessary. A small internal helper function to remove a
commonly duplicated idiom.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;av_create_and_unshift_one&quot; must be explicitly
called as &quot;Perl_av_create_and_unshift_one&quot; with an
&quot;aTHX_&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">SV**
Perl_av_create_and_unshift_one(pTHX_ AV **const avp, <br>
SV *const val)</p>

<p style="margin-left:11%;">&quot;av_delete&quot;</p>

<p style="margin-left:17%;">Deletes the element indexed by
&quot;key&quot; from the array, makes the element mortal,
and returns it. If &quot;flags&quot; equals
&quot;G_DISCARD&quot;, the element is freed and
<small>NULL</small> is returned. <small>NULL</small> is also
returned if &quot;key&quot; is out of range.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
equivalent:
&quot;splice(@myarray,&nbsp;$key,&nbsp;1,&nbsp;undef)&quot;
(with the &quot;splice&quot; in void context if
&quot;G_DISCARD&quot; is present).</p>

<p style="margin-left:17%; margin-top: 1em">SV*
av_delete(AV *av, SSize_t key, I32 flags)</p>

<p style="margin-left:11%;">&quot;av_exists&quot;</p>

<p style="margin-left:17%;">Returns true if the element
indexed by &quot;key&quot; has been initialized.</p>

<p style="margin-left:17%; margin-top: 1em">This relies on
the fact that uninitialized array elements are set to
&quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
equivalent: &quot;exists($myarray[$key])&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
av_exists(AV *av, SSize_t key)</p>

<p style="margin-left:11%;">&quot;av_extend&quot;</p>

<p style="margin-left:17%;">Pre-extend an array so that it
is capable of storing values at indexes &quot;0..key&quot;.
Thus &quot;av_extend(av,99)&quot; guarantees that the array
can store 100 elements, i.e. that &quot;av_store(av, 0,
sv)&quot; through &quot;av_store(av, 99, sv)&quot; on a
plain array will work without any further memory
allocation.</p>

<p style="margin-left:17%; margin-top: 1em">If the av
argument is a tied array then will call the
&quot;EXTEND&quot; tied array method with an argument of
&quot;(key+1)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
av_extend(AV *av, SSize_t key)</p>

<p style="margin-left:11%;">&quot;av_fetch&quot;</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
at the specified index in the array. The &quot;key&quot; is
the index. If &quot;lval&quot; is true, you are guaranteed
to get a real <small>SV</small> back (in case it
wasn&rsquo;t real before), which you can then modify. Check
that the return value is non-NULL before dereferencing it to
a &quot;SV*&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied arrays.</p>

<p style="margin-left:17%; margin-top: 1em">The rough perl
equivalent is $myarray[$key].</p>

<p style="margin-left:17%; margin-top: 1em">SV**
av_fetch(AV *av, SSize_t key, I32 lval)</p>

<p style="margin-left:11%;">&quot;AvFILL&quot;</p>

<p style="margin-left:17%;">Same as
&quot;av_top_index&quot; or &quot;av_tindex&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
AvFILL(AV* av)</p>

<p style="margin-left:11%;">&quot;av_fill&quot;</p>

<p style="margin-left:17%;">Set the highest index in the
array to the given number, equivalent to Perl&rsquo;s
&quot;$#array&nbsp;=&nbsp;$fill;&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The number of
elements in the array will be &quot;fill&nbsp;+&nbsp;1&quot;
after &quot;av_fill()&quot; returns. If the array was
previously shorter, then the additional elements appended
are set to <small>NULL.</small> If the array was longer,
then the excess elements are freed.
&quot;av_fill(av,&nbsp;&minus;1)&quot; is the same as
&quot;av_clear(av)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void av_fill(AV
*av, SSize_t fill)</p>

<p style="margin-left:11%;">&quot;av_len&quot;</p>

<p style="margin-left:17%;">Same as
&quot;av_top_index&quot;. Note that, unlike what the name
implies, it returns the maximum index in the array. This is
unlike &quot;sv_len&quot;, which returns what you would
expect.</p>

<p style="margin-left:17%; margin-top: 1em"><b>To get the
true number of elements in the array, instead use
&quot;av_count&quot;</b>.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
av_len(AV *av)</p>

<p style="margin-left:11%;">&quot;av_make&quot;</p>

<p style="margin-left:17%;">Creates a new <small>AV</small>
and populates it with a list (**strp, length
&quot;size&quot;) of SVs. A copy is made of each
<small>SV,</small> so their refcounts are not changed. The
new <small>AV</small> will have a reference count of 1.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
equivalent: &quot;my @new_array = ($scalar1, $scalar2,
$scalar3...);&quot;</p>

<p style="margin-left:17%; margin-top: 1em">AV*
av_make(SSize_t size, SV **strp)</p>

<p style="margin-left:11%;">&quot;av_pop&quot;</p>

<p style="margin-left:17%;">Removes one <small>SV</small>
from the end of the array, reducing its size by one and
returning the <small>SV</small> (transferring control of one
reference count) to the caller. Returns &amp;PL_sv_undef if
the array is empty.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
equivalent: &quot;pop(@myarray);&quot;</p>

<p style="margin-left:17%; margin-top: 1em">SV* av_pop(AV
*av)</p>

<p style="margin-left:11%;">&quot;av_push&quot;</p>

<p style="margin-left:17%;">Pushes an <small>SV</small>
(transferring control of one reference count) onto the end
of the array. The array will grow automatically to
accommodate the addition.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
equivalent: &quot;push @myarray, $val;&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void av_push(AV
*av, SV *val)</p>

<p style="margin-left:11%;">&quot;av_shift&quot;</p>

<p style="margin-left:17%;">Removes one <small>SV</small>
from the start of the array, reducing its size by one and
returning the <small>SV</small> (transferring control of one
reference count) to the caller. Returns &amp;PL_sv_undef if
the array is empty.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
equivalent: &quot;shift(@myarray);&quot;</p>

<p style="margin-left:17%; margin-top: 1em">SV* av_shift(AV
*av)</p>

<p style="margin-left:11%;">&quot;av_store&quot;</p>

<p style="margin-left:17%;">Stores an <small>SV</small> in
an array. The array index is specified as &quot;key&quot;.
The return value will be &quot;NULL&quot; if the operation
failed or if the value did not need to be actually stored
within the array (as in the case of tied arrays). Otherwise,
it can be dereferenced to get the &quot;SV*&quot; that was
stored there (= &quot;val&quot;)).</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
caller is responsible for suitably incrementing the
reference count of &quot;val&quot; before the call, and
decrementing it if the function returned
&quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Approximate
Perl equivalent: &quot;splice(@myarray, $key, 1,
$val)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied arrays.</p>

<p style="margin-left:17%; margin-top: 1em">SV**
av_store(AV *av, SSize_t key, SV *val)</p>

<p style="margin-left:11%;">&quot;av_tindex&quot; <br>
&quot;av_top_index&quot;</p>

<p style="margin-left:17%;">These behave identically. If
the array &quot;av&quot; is empty, these return &minus;1;
otherwise they return the maximum value of the indices of
all the array elements which are currently defined in
&quot;av&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">They process
&rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">The Perl
equivalent for these is $#av.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;av_count&quot; to get the number of elements in an
array.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
av_tindex(AV *av)</p>

<p style="margin-left:11%;">&quot;av_undef&quot;</p>

<p style="margin-left:17%;">Undefines the array. The
<small>XS</small> equivalent of
&quot;undef(@array)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">As well as
freeing all the elements of the array (like
&quot;av_clear()&quot;), this also frees the memory used by
the av to store its list of scalars.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;av_clear&quot; for a note about the array possibly
being invalid on return.</p>

<p style="margin-left:17%; margin-top: 1em">void
av_undef(AV *av)</p>

<p style="margin-left:11%;">&quot;av_unshift&quot;</p>

<p style="margin-left:17%;">Unshift the given number of
&quot;undef&quot; values onto the beginning of the array.
The array will grow automatically to accommodate the
addition.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
equivalent:
&quot;unshift&nbsp;@myarray,&nbsp;((undef)&nbsp;x&nbsp;$num);&quot;</p>

<p style="margin-left:17%; margin-top: 1em">void
av_unshift(AV *av, SSize_t num)</p>

<p style="margin-left:11%;">&quot;get_av&quot;</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
of the specified Perl global or package array with the given
name (so it won&rsquo;t work on lexical variables).
&quot;flags&quot; are passed to &quot;gv_fetchpv&quot;. If
&quot;GV_ADD&quot; is set and the Perl variable does not
exist then it will be created. If &quot;flags&quot; is zero
and the variable does not exist then <small>NULL</small> is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
equivalent: &quot;@{&quot;$name&quot;}&quot;.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_get_av()&quot; form is <b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">AV*
get_av(const char *name, I32 flags)</p>

<p style="margin-left:11%;">&quot;newAV&quot; <br>
&quot;newAV_alloc_x&quot; <br>
&quot;newAV_alloc_xz&quot;</p>

<p style="margin-left:17%;">These all create a new
<small>AV,</small> setting the reference count to 1. If you
also know the initial elements of the array with, see
&quot;&quot;av_make&quot;&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">As background,
an array consists of three things:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="77%">


<p>A data structure containing information about the array
as a whole, such as its size and reference count.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="77%">


<p>A C language array of pointers to the individual
elements. These are treated as pointers to SVs, so all must
be castable to SV*.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="77%">


<p>The individual elements themselves. These could be, for
instance, SVs and/or AVs and/or HVs, etc.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">An empty array
need only have the first data structure, and all these
functions create that. They differ in what else they do, as
follows: <br>
&quot;newAV&quot; form</p>

<p style="margin-left:23%;">This does nothing beyond
creating the whole-array data structure. The Perl equivalent
is approximately &quot;my&nbsp;@array;&quot;</p>

<p style="margin-left:23%; margin-top: 1em">This is useful
when the minimum size of the array could be zero (perhaps
there are likely code paths that will entirely skip using
it).</p>

<p style="margin-left:23%; margin-top: 1em">If the array
does get used, the pointers data structure will need to be
allocated at that time. This will end up being done by
&quot;av_extend&quot;&gt;, either explicitly:</p>

<p style="margin-left:23%; margin-top: 1em">av_extend(av,
len);</p>

<p style="margin-left:23%; margin-top: 1em">or implicitly
when the first element is stored:</p>


<p style="margin-left:23%; margin-top: 1em">(void)av_store(av,
0, sv);</p>

<p style="margin-left:23%; margin-top: 1em">Unused array
elements are typically initialized by
&quot;av_extend&quot;.</p>

<p style="margin-left:17%;">&quot;newAV_alloc_x&quot;
form</p>

<p style="margin-left:23%;">This effectively does a
&quot;newAV&quot; followed by also allocating
(uninitialized) space for the pointers array. This is used
when you know ahead of time the likely minimum size of the
array. It is more efficient to do this than doing a plain
&quot;newAV&quot; followed by an &quot;av_extend&quot;.</p>

<p style="margin-left:23%; margin-top: 1em">Of course the
array can be extended later should it become necessary.</p>


<p style="margin-left:23%; margin-top: 1em">&quot;size&quot;
must be at least 1.</p>

<p style="margin-left:17%;">&quot;newAV_alloc_xz&quot;
form</p>

<p style="margin-left:23%;">This is
&quot;newAV_alloc_x&quot;, but initializes each pointer in
it to <small>NULL.</small> This gives added safety to guard
against them being read before being set.</p>


<p style="margin-left:23%; margin-top: 1em">&quot;size&quot;
must be at least 1.</p>

<p style="margin-left:17%; margin-top: 1em">The following
examples all result in an array that can fit four elements
(indexes 0 .. 3):</p>

<p style="margin-left:17%; margin-top: 1em">AV *av =
newAV(); <br>
av_extend(av, 3); <br>
AV *av = newAV_alloc_x(4); <br>
AV *av = newAV_alloc_xz(4);</p>

<p style="margin-left:17%; margin-top: 1em">In contrast,
the following examples allocate an array that is only
guaranteed to fit one element without extending:</p>

<p style="margin-left:17%; margin-top: 1em">AV *av =
newAV_alloc_x(1); <br>
AV *av = newAV_alloc_xz(1);</p>

<p style="margin-left:17%; margin-top: 1em">AV* newAV ()
<br>
AV* newAV_alloc_x (SSize_t size) <br>
AV* newAV_alloc_xz(SSize_t size)</p>

<p style="margin-left:11%;">&quot;Nullav&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;Nullav&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Null
<small>AV</small> pointer.</p>

<p style="margin-left:17%; margin-top: 1em">(deprecated
&minus; use &quot;(AV *)NULL&quot; instead)</p>

<h2>Callback Functions
<a name="Callback Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;call_argv&quot;</p>

<p style="margin-left:17%;">Performs a callback to the
specified named and package-scoped Perl subroutine with
&quot;argv&quot; (a &quot;NULL&quot;&minus;terminated array
of strings) as arguments. See perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">Approximate
Perl equivalent:
&quot;&amp;{&quot;$sub_name&quot;}(@$argv)&quot;.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_call_argv()&quot; form is
<b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">I32
call_argv(const char* sub_name, I32 flags, char** argv)</p>

<p style="margin-left:11%;">&quot;call_method&quot;</p>

<p style="margin-left:17%;">Performs a callback to the
specified Perl method. The blessed object must be on the
stack. See perlcall.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_call_method()&quot; form is
<b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">I32
call_method(const char* methname, I32 flags)</p>

<p style="margin-left:11%;">&quot;call_pv&quot;</p>

<p style="margin-left:17%;">Performs a callback to the
specified Perl sub. See perlcall.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_call_pv()&quot; form is
<b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">I32
call_pv(const char* sub_name, I32 flags)</p>

<p style="margin-left:11%;">&quot;call_sv&quot;</p>

<p style="margin-left:17%;">Performs a callback to the Perl
sub specified by the <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">If neither the
&quot;G_METHOD&quot; nor &quot;G_METHOD_NAMED&quot; flag is
supplied, the <small>SV</small> may be any of a
<small>CV,</small> a <small>GV,</small> a reference to a
<small>CV,</small> a reference to a <small>GV</small> or
&quot;SvPV(sv)&quot; will be used as the name of the sub to
call.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;G_METHOD&quot; flag is supplied, the <small>SV</small>
may be a reference to a <small>CV</small> or
&quot;SvPV(sv)&quot; will be used as the name of the method
to call.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;G_METHOD_NAMED&quot; flag is supplied,
&quot;SvPV(sv)&quot; will be used as the name of the method
to call.</p>

<p style="margin-left:17%; margin-top: 1em">Some other
values are treated specially for internal use and should not
be depended on.</p>

<p style="margin-left:17%; margin-top: 1em">See
perlcall.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_call_sv()&quot; form is
<b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">I32 call_sv(SV*
sv, volatile I32 flags)</p>


<p style="margin-left:11%;">&quot;DESTRUCTORFUNC_NOCONTEXT_t&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:11%;">&quot;DESTRUCTORFUNC_t&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;ENTER&quot;</p>

<p style="margin-left:17%;">Opening bracket on a callback.
See &quot;LEAVE&quot; and perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">ENTER;</p>


<p style="margin-left:11%;">&quot;ENTER_with_name&quot;</p>

<p style="margin-left:17%;">Same as &quot;ENTER&quot;, but
when debugging is enabled it also associates the given
literal string with the new scope.</p>


<p style="margin-left:17%; margin-top: 1em">ENTER_with_name(&quot;name&quot;);</p>

<p style="margin-left:11%;">&quot;eval_pv&quot;</p>

<p style="margin-left:17%;">Tells Perl to &quot;eval&quot;
the given string in scalar context and return an SV*
result.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_eval_pv()&quot; form is
<b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
eval_pv(const char* p, I32 croak_on_error)</p>

<p style="margin-left:11%;">&quot;eval_sv&quot;</p>

<p style="margin-left:17%;">Tells Perl to &quot;eval&quot;
the string in the <small>SV.</small> It supports the same
flags as &quot;call_sv&quot;, with the obvious exception of
&quot;G_EVAL&quot;. See perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;G_RETHROW&quot; flag can be used if you only need
<b>eval_sv()</b> to execute code specified by a string, but
not catch any errors.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_eval_sv()&quot; form is
<b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">I32 eval_sv(SV*
sv, I32 flags)</p>

<p style="margin-left:11%;">&quot;FREETMPS&quot;</p>

<p style="margin-left:17%;">Closing bracket for temporaries
on a callback. See &quot;SAVETMPS&quot; and perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">FREETMPS;</p>

<p style="margin-left:11%;">&quot;G_DISCARD&quot;</p>

<p style="margin-left:17%;">Described in perlcall.</p>

<p style="margin-left:11%;">&quot;G_EVAL&quot;</p>

<p style="margin-left:17%;">Described in perlcall.</p>

<p style="margin-left:11%;">&quot;GIMME&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;GIMME&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">A
backward-compatible version of &quot;GIMME_V&quot; which can
only return &quot;G_SCALAR&quot; or &quot;G_LIST&quot;; in a
void context, it returns &quot;G_SCALAR&quot;. Deprecated.
Use &quot;GIMME_V&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">U32 GIMME</p>

<p style="margin-left:11%;">&quot;GIMME_V&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
equivalent to Perl&rsquo;s &quot;wantarray&quot;. Returns
&quot;G_VOID&quot;, &quot;G_SCALAR&quot; or
&quot;G_LIST&quot; for void, scalar or list context,
respectively. See perlcall for a usage example.</p>

<p style="margin-left:17%; margin-top: 1em">U32 GIMME_V</p>

<p style="margin-left:11%;">&quot;G_KEEPERR&quot;</p>

<p style="margin-left:17%;">Described in perlcall.</p>

<p style="margin-left:11%;">&quot;G_LIST&quot;</p>

<p style="margin-left:17%;">Described in perlcall.</p>

<p style="margin-left:11%;">&quot;G_NOARGS&quot;</p>

<p style="margin-left:17%;">Described in perlcall.</p>

<p style="margin-left:11%;">&quot;G_SCALAR&quot;</p>

<p style="margin-left:17%;">Described in perlcall.</p>

<p style="margin-left:11%;">&quot;G_VOID&quot;</p>

<p style="margin-left:17%;">Described in perlcall.</p>

<p style="margin-left:11%;">&quot;is_lvalue_sub&quot;</p>

<p style="margin-left:17%;">Returns non-zero if the sub
calling this function is being called in an lvalue context.
Returns 0 otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">I32
is_lvalue_sub()</p>

<p style="margin-left:11%;">&quot;LEAVE&quot;</p>

<p style="margin-left:17%;">Closing bracket on a callback.
See &quot;ENTER&quot; and perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">LEAVE;</p>


<p style="margin-left:11%;">&quot;LEAVE_with_name&quot;</p>

<p style="margin-left:17%;">Same as &quot;LEAVE&quot;, but
when debugging is enabled it first checks that the scope has
the given name. &quot;name&quot; must be a literal
string.</p>


<p style="margin-left:17%; margin-top: 1em">LEAVE_with_name(&quot;name&quot;);</p>

<p style="margin-left:11%;">&quot;PL_errgv&quot;</p>

<p style="margin-left:17%;">Described in perlcall.</p>

<p style="margin-left:11%;">&quot;save_aptr&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_aptr(AV** aptr)</p>

<p style="margin-left:11%;">&quot;save_ary&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">AV*
save_ary(GV* gv)</p>

<p style="margin-left:11%;">&quot;SAVEBOOL&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEBOOL(bool
i)</p>

<p style="margin-left:11%;">&quot;SAVEDELETE&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEDELETE(HV *
hv, char * key, I32 length)</p>

<p style="margin-left:11%;">&quot;SAVEDESTRUCTOR&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:17%; margin-top: 1em">SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t
f, void *p)</p>


<p style="margin-left:11%;">&quot;SAVEDESTRUCTOR_X&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:17%; margin-top: 1em">SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t
f, void *p)</p>

<p style="margin-left:11%;">&quot;SAVEFREEOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEFREEOP(OP
*op)</p>

<p style="margin-left:11%;">&quot;SAVEFREEPV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:17%; margin-top: 1em">SAVEFREEPV(void
* p)</p>

<p style="margin-left:11%;">&quot;SAVEFREESV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEFREESV(SV*
sv)</p>

<p style="margin-left:11%;">&quot;save_hash&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
save_hash(GV* gv)</p>

<p style="margin-left:11%;">&quot;save_hptr&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_hptr(HV** hptr)</p>

<p style="margin-left:11%;">&quot;SAVEI8&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEI8(I8
i)</p>

<p style="margin-left:11%;">&quot;SAVEI32&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEI32(I32
i)</p>

<p style="margin-left:11%;">&quot;SAVEI16&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEI16(I16
i)</p>

<p style="margin-left:11%;">&quot;SAVEINT&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEINT(int
i)</p>

<p style="margin-left:11%;">&quot;save_item&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_item(SV* item)</p>

<p style="margin-left:11%;">&quot;SAVEIV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEIV(IV
i)</p>

<p style="margin-left:11%;">&quot;save_list&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;save_list&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Described in
perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_list(SV** sarg, I32 maxsarg)</p>

<p style="margin-left:11%;">&quot;SAVELONG&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVELONG(long
i)</p>


<p style="margin-left:11%;">&quot;SAVEMORTALIZESV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:17%; margin-top: 1em">SAVEMORTALIZESV(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SAVEPPTR&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVEPPTR(char *
p)</p>

<p style="margin-left:11%;">&quot;save_scalar&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
save_scalar(GV* gv)</p>

<p style="margin-left:11%;">&quot;SAVESPTR&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SAVESPTR(SV *
s)</p>

<p style="margin-left:11%;">&quot;SAVESTACK_POS&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:17%; margin-top: 1em">SAVESTACK_POS()</p>

<p style="margin-left:11%;">&quot;SAVESTRLEN&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:17%; margin-top: 1em">SAVESTRLEN(STRLEN
i)</p>

<p style="margin-left:11%;">&quot;save_svref&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
save_svref(SV** sptr)</p>

<p style="margin-left:11%;">&quot;SAVETMPS&quot;</p>

<p style="margin-left:17%;">Opening bracket for temporaries
on a callback. See &quot;FREETMPS&quot; and perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">SAVETMPS;</p>

<h2>Casting
<a name="Casting"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;cBOOL&quot;</p>

<p style="margin-left:17%;">Cast-to-bool. When Perl was
able to be compiled on pre&minus;C99 compilers, a
&quot;(bool)&quot; cast didn&rsquo;t necessarily do the
right thing, so this macro was created (and made somewhat
complicated to work around bugs in old compilers). Now, many
years later, and C99 is used, this is no longer required,
but is kept for backwards compatibility.</p>

<p style="margin-left:17%; margin-top: 1em">bool cBOOL(bool
expr)</p>

<p style="margin-left:11%;">&quot;I_32&quot;</p>

<p style="margin-left:17%;">Cast an <small>NV</small> to
I32 while avoiding undefined C behavior</p>

<p style="margin-left:17%; margin-top: 1em">I32 I_32(NV
what)</p>

<p style="margin-left:11%;">&quot;INT2PTR&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">type
INT2PTR(type, int value)</p>

<p style="margin-left:11%;">&quot;I_V&quot;</p>

<p style="margin-left:17%;">Cast an <small>NV</small> to
<small>IV</small> while avoiding undefined C behavior</p>

<p style="margin-left:17%; margin-top: 1em">IV I_V(NV
what)</p>

<p style="margin-left:11%;">&quot;PTR2IV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">IV PTR2IV(void
* ptr)</p>

<p style="margin-left:11%;">&quot;PTR2nat&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">IV PTR2nat(void
*)</p>

<p style="margin-left:11%;">&quot;PTR2NV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">NV PTR2NV(void
* ptr)</p>

<p style="margin-left:11%;">&quot;PTR2ul&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">unsigned long
PTR2ul(void *)</p>

<p style="margin-left:11%;">&quot;PTR2UV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">UV PTR2UV(void
* ptr)</p>

<p style="margin-left:11%;">&quot;PTRV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;U_32&quot;</p>

<p style="margin-left:17%;">Cast an <small>NV</small> to
U32 while avoiding undefined C behavior</p>

<p style="margin-left:17%; margin-top: 1em">U32 U_32(NV
what)</p>

<p style="margin-left:11%;">&quot;U_V&quot;</p>

<p style="margin-left:17%;">Cast an <small>NV</small> to
<small>UV</small> while avoiding undefined C behavior</p>

<p style="margin-left:17%; margin-top: 1em">UV U_V(NV
what)</p>

<h2>Character case changing
<a name="Character case changing"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perl uses
&quot;full&quot; Unicode case mappings. This means that
converting a single character to another case may result in
a sequence of more than one character. For example, the
uppercase of &quot;ss&quot; ( <small>LATIN SMALL LETTER
SHARP S</small> ) is the two character sequence
&quot;SS&quot;. This presents some complications The
lowercase of all characters in the range 0..255 is a single
character, and thus &quot;toLOWER_L1&quot; is furnished.
But, &quot;toUPPER_L1&quot; can&rsquo;t exist, as it
couldn&rsquo;t return a valid result for all legal inputs.
Instead &quot;toUPPER_uvchr&quot; has an <small>API</small>
that does allow every possible legal result to be returned.)
Likewise no other function that is crippled by not being
able to give the correct results for the full range of
possible inputs has been implemented here. <br>
&quot;toFOLD&quot; <br>
&quot;toFOLD_A&quot; <br>
&quot;toFOLD_uvchr&quot; <br>
&quot;toFOLD_utf8&quot; <br>
&quot;toFOLD_utf8_safe&quot;</p>

<p style="margin-left:17%;">These all return the foldcase
of a character. &quot;foldcase&quot; is an internal case for
&quot;/i&quot; pattern matching. If the foldcase of
character A and the foldcase of character B are the same,
they match caselessly; otherwise they don&rsquo;t.</p>

<p style="margin-left:17%; margin-top: 1em">The differences
in the forms are what domain they operate on, and whether
the input is specified as a code point (those forms with a
&quot;cp&quot; parameter) or as a <small>UTF&minus;8</small>
string (the others). In the latter case, the code point to
use is the first one in the buffer of
<small>UTF&minus;8</small> encoded code points, delineated
by the arguments
&quot;p&nbsp;..&nbsp;e&nbsp;&minus;&nbsp;1&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toFOLD&quot;
and &quot;toFOLD_A&quot; are synonyms of each other. They
return the foldcase of any ASCII-range code point. In this
range, the foldcase is identical to the lowercase. All other
inputs are returned unchanged. Since these are macros, the
input type may be any integral one, and the output will
occupy the same number of bits as the input.</p>

<p style="margin-left:17%; margin-top: 1em">There is no
&quot;toFOLD_L1&quot; nor &quot;toFOLD_LATIN1&quot; as the
foldcase of some code points in the 0..255 range is above
that range or consists of multiple characters. Instead use
&quot;toFOLD_uvchr&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toFOLD_uvchr&quot;
returns the foldcase of any Unicode code point. The return
value is identical to that of &quot;toFOLD_A&quot; for input
code points in the <small>ASCII</small> range. The foldcase
of the vast majority of Unicode code points is the same as
the code point itself. For these, and for code points above
the legal Unicode maximum, this returns the input code point
unchanged. It additionally stores the
<small>UTF&minus;8</small> of the result into the buffer
beginning at &quot;s&quot;, and its length in bytes into
*lenp. The caller must have made &quot;s&quot; large enough
to contain at least &quot;UTF8_MAXBYTES_CASE+1&quot; bytes
to avoid possible overflow.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the foldcase of a code point may be more than one code
point. The return value of this function is only the first
of these. The entire foldcase is returned in &quot;s&quot;.
To determine if the result is more than a single code point,
you can do something like this:</p>

<p style="margin-left:17%; margin-top: 1em">uc =
toFOLD_uvchr(cp, s, &amp;len); <br>
if (len &gt; UTF8SKIP(s)) { is multiple code points } <br>
else { is a single code point }</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toFOLD_utf8&quot;
and &quot;toFOLD_utf8_safe&quot; are synonyms of each other.
The only difference between these and
&quot;toFOLD_uvchr&quot; is that the source for these is
encoded in <small>UTF&minus;8,</small> instead of being a
code point. It is passed as a buffer starting at
&quot;p&quot;, with &quot;e&quot; pointing to one byte
beyond its end. The &quot;p&quot; buffer may certainly
contain more than one code point; but only the first one (up
through &quot;e&nbsp;&minus;&nbsp;1&quot;) is examined. If
the <small>UTF&minus;8</small> for the input character is
malformed in some way, the program may croak, or the
function may return the <small>REPLACEMENT
CHARACTER,</small> at the discretion of the implementation,
and subject to change in future releases.</p>

<p style="margin-left:17%; margin-top: 1em">UV toFOLD (UV
cp) <br>
UV toFOLD_A (UV cp) <br>
UV toFOLD_uvchr (UV cp, U8* s, STRLEN* lenp) <br>
UV toFOLD_utf8 (U8* p, U8* e, U8* s, STRLEN* lenp) <br>
UV toFOLD_utf8_safe(U8* p, U8* e, U8* s, STRLEN* lenp)</p>

<p style="margin-left:11%;">&quot;toLOWER&quot; <br>
&quot;toLOWER_A&quot; <br>
&quot;toLOWER_L1&quot; <br>
&quot;toLOWER_LATIN1&quot; <br>
&quot;toLOWER_LC&quot; <br>
&quot;toLOWER_uvchr&quot; <br>
&quot;toLOWER_utf8&quot; <br>
&quot;toLOWER_utf8_safe&quot;</p>

<p style="margin-left:17%;">These all return the lowercase
of a character. The differences are what domain they operate
on, and whether the input is specified as a code point
(those forms with a &quot;cp&quot; parameter) or as a
<small>UTF&minus;8</small> string (the others). In the
latter case, the code point to use is the first one in the
buffer of <small>UTF&minus;8</small> encoded code points,
delineated by the arguments
&quot;p&nbsp;..&nbsp;e&nbsp;&minus;&nbsp;1&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toLOWER&quot;
and &quot;toLOWER_A&quot; are synonyms of each other. They
return the lowercase of any uppercase ASCII-range code
point. All other inputs are returned unchanged. Since these
are macros, the input type may be any integral one, and the
output will occupy the same number of bits as the input.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toLOWER_L1&quot;
and &quot;toLOWER_LATIN1&quot; are synonyms of each other.
They behave identically as &quot;toLOWER&quot; for
ASCII-range input. But additionally will return the
lowercase of any uppercase code point in the entire 0..255
range, assuming a Latin&minus;1 encoding (or the
<small>EBCDIC</small> equivalent on such platforms).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toLOWER_LC&quot;
returns the lowercase of the input code point according to
the rules of the current <small>POSIX</small> locale. Input
code points outside the range 0..255 are returned
unchanged.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toLOWER_uvchr&quot;
returns the lowercase of any Unicode code point. The return
value is identical to that of &quot;toLOWER_L1&quot; for
input code points in the 0..255 range. The lowercase of the
vast majority of Unicode code points is the same as the code
point itself. For these, and for code points above the legal
Unicode maximum, this returns the input code point
unchanged. It additionally stores the
<small>UTF&minus;8</small> of the result into the buffer
beginning at &quot;s&quot;, and its length in bytes into
*lenp. The caller must have made &quot;s&quot; large enough
to contain at least &quot;UTF8_MAXBYTES_CASE+1&quot; bytes
to avoid possible overflow.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the lowercase of a code point may be more than one code
point. The return value of this function is only the first
of these. The entire lowercase is returned in &quot;s&quot;.
To determine if the result is more than a single code point,
you can do something like this:</p>

<p style="margin-left:17%; margin-top: 1em">uc =
toLOWER_uvchr(cp, s, &amp;len); <br>
if (len &gt; UTF8SKIP(s)) { is multiple code points } <br>
else { is a single code point }</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toLOWER_utf8&quot;
and &quot;toLOWER_utf8_safe&quot; are synonyms of each
other. The only difference between these and
&quot;toLOWER_uvchr&quot; is that the source for these is
encoded in <small>UTF&minus;8,</small> instead of being a
code point. It is passed as a buffer starting at
&quot;p&quot;, with &quot;e&quot; pointing to one byte
beyond its end. The &quot;p&quot; buffer may certainly
contain more than one code point; but only the first one (up
through &quot;e&nbsp;&minus;&nbsp;1&quot;) is examined. If
the <small>UTF&minus;8</small> for the input character is
malformed in some way, the program may croak, or the
function may return the <small>REPLACEMENT
CHARACTER,</small> at the discretion of the implementation,
and subject to change in future releases.</p>

<p style="margin-left:17%; margin-top: 1em">UV toLOWER (UV
cp) <br>
UV toLOWER_A (UV cp) <br>
UV toLOWER_L1 (UV cp) <br>
UV toLOWER_LATIN1 (UV cp) <br>
UV toLOWER_LC (UV cp) <br>
UV toLOWER_uvchr (UV cp, U8* s, STRLEN* lenp) <br>
UV toLOWER_utf8 (U8* p, U8* e, U8* s, STRLEN* lenp) <br>
UV toLOWER_utf8_safe(U8* p, U8* e, U8* s, STRLEN* lenp)</p>

<p style="margin-left:11%;">&quot;toTITLE&quot; <br>
&quot;toTITLE_A&quot; <br>
&quot;toTITLE_uvchr&quot; <br>
&quot;toTITLE_utf8&quot; <br>
&quot;toTITLE_utf8_safe&quot;</p>

<p style="margin-left:17%;">These all return the titlecase
of a character. The differences are what domain they operate
on, and whether the input is specified as a code point
(those forms with a &quot;cp&quot; parameter) or as a
<small>UTF&minus;8</small> string (the others). In the
latter case, the code point to use is the first one in the
buffer of <small>UTF&minus;8</small> encoded code points,
delineated by the arguments
&quot;p&nbsp;..&nbsp;e&nbsp;&minus;&nbsp;1&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toTITLE&quot;
and &quot;toTITLE_A&quot; are synonyms of each other. They
return the titlecase of any lowercase ASCII-range code
point. In this range, the titlecase is identical to the
uppercase. All other inputs are returned unchanged. Since
these are macros, the input type may be any integral one,
and the output will occupy the same number of bits as the
input.</p>

<p style="margin-left:17%; margin-top: 1em">There is no
&quot;toTITLE_L1&quot; nor &quot;toTITLE_LATIN1&quot; as the
titlecase of some code points in the 0..255 range is above
that range or consists of multiple characters. Instead use
&quot;toTITLE_uvchr&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toTITLE_uvchr&quot;
returns the titlecase of any Unicode code point. The return
value is identical to that of &quot;toTITLE_A&quot; for
input code points in the <small>ASCII</small> range. The
titlecase of the vast majority of Unicode code points is the
same as the code point itself. For these, and for code
points above the legal Unicode maximum, this returns the
input code point unchanged. It additionally stores the
<small>UTF&minus;8</small> of the result into the buffer
beginning at &quot;s&quot;, and its length in bytes into
*lenp. The caller must have made &quot;s&quot; large enough
to contain at least &quot;UTF8_MAXBYTES_CASE+1&quot; bytes
to avoid possible overflow.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the titlecase of a code point may be more than one code
point. The return value of this function is only the first
of these. The entire titlecase is returned in &quot;s&quot;.
To determine if the result is more than a single code point,
you can do something like this:</p>

<p style="margin-left:17%; margin-top: 1em">uc =
toTITLE_uvchr(cp, s, &amp;len); <br>
if (len &gt; UTF8SKIP(s)) { is multiple code points } <br>
else { is a single code point }</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toTITLE_utf8&quot;
and &quot;toTITLE_utf8_safe&quot; are synonyms of each
other. The only difference between these and
&quot;toTITLE_uvchr&quot; is that the source for these is
encoded in <small>UTF&minus;8,</small> instead of being a
code point. It is passed as a buffer starting at
&quot;p&quot;, with &quot;e&quot; pointing to one byte
beyond its end. The &quot;p&quot; buffer may certainly
contain more than one code point; but only the first one (up
through &quot;e&nbsp;&minus;&nbsp;1&quot;) is examined. If
the <small>UTF&minus;8</small> for the input character is
malformed in some way, the program may croak, or the
function may return the <small>REPLACEMENT
CHARACTER,</small> at the discretion of the implementation,
and subject to change in future releases.</p>

<p style="margin-left:17%; margin-top: 1em">UV toTITLE (UV
cp) <br>
UV toTITLE_A (UV cp) <br>
UV toTITLE_uvchr (UV cp, U8* s, STRLEN* lenp) <br>
UV toTITLE_utf8 (U8* p, U8* e, U8* s, STRLEN* lenp) <br>
UV toTITLE_utf8_safe(U8* p, U8* e, U8* s, STRLEN* lenp)</p>

<p style="margin-left:11%;">&quot;toUPPER&quot; <br>
&quot;toUPPER_A&quot; <br>
&quot;toUPPER_uvchr&quot; <br>
&quot;toUPPER_utf8&quot; <br>
&quot;toUPPER_utf8_safe&quot;</p>

<p style="margin-left:17%;">These all return the uppercase
of a character. The differences are what domain they operate
on, and whether the input is specified as a code point
(those forms with a &quot;cp&quot; parameter) or as a
<small>UTF&minus;8</small> string (the others). In the
latter case, the code point to use is the first one in the
buffer of <small>UTF&minus;8</small> encoded code points,
delineated by the arguments
&quot;p&nbsp;..&nbsp;e&nbsp;&minus;&nbsp;1&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toUPPER&quot;
and &quot;toUPPER_A&quot; are synonyms of each other. They
return the uppercase of any lowercase ASCII-range code
point. All other inputs are returned unchanged. Since these
are macros, the input type may be any integral one, and the
output will occupy the same number of bits as the input.</p>

<p style="margin-left:17%; margin-top: 1em">There is no
&quot;toUPPER_L1&quot; nor &quot;toUPPER_LATIN1&quot; as the
uppercase of some code points in the 0..255 range is above
that range or consists of multiple characters. Instead use
&quot;toUPPER_uvchr&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toUPPER_uvchr&quot;
returns the uppercase of any Unicode code point. The return
value is identical to that of &quot;toUPPER_A&quot; for
input code points in the <small>ASCII</small> range. The
uppercase of the vast majority of Unicode code points is the
same as the code point itself. For these, and for code
points above the legal Unicode maximum, this returns the
input code point unchanged. It additionally stores the
<small>UTF&minus;8</small> of the result into the buffer
beginning at &quot;s&quot;, and its length in bytes into
*lenp. The caller must have made &quot;s&quot; large enough
to contain at least &quot;UTF8_MAXBYTES_CASE+1&quot; bytes
to avoid possible overflow.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the uppercase of a code point may be more than one code
point. The return value of this function is only the first
of these. The entire uppercase is returned in &quot;s&quot;.
To determine if the result is more than a single code point,
you can do something like this:</p>

<p style="margin-left:17%; margin-top: 1em">uc =
toUPPER_uvchr(cp, s, &amp;len); <br>
if (len &gt; UTF8SKIP(s)) { is multiple code points } <br>
else { is a single code point }</p>


<p style="margin-left:17%; margin-top: 1em">&quot;toUPPER_utf8&quot;
and &quot;toUPPER_utf8_safe&quot; are synonyms of each
other. The only difference between these and
&quot;toUPPER_uvchr&quot; is that the source for these is
encoded in <small>UTF&minus;8,</small> instead of being a
code point. It is passed as a buffer starting at
&quot;p&quot;, with &quot;e&quot; pointing to one byte
beyond its end. The &quot;p&quot; buffer may certainly
contain more than one code point; but only the first one (up
through &quot;e&nbsp;&minus;&nbsp;1&quot;) is examined. If
the <small>UTF&minus;8</small> for the input character is
malformed in some way, the program may croak, or the
function may return the <small>REPLACEMENT
CHARACTER,</small> at the discretion of the implementation,
and subject to change in future releases.</p>

<p style="margin-left:17%; margin-top: 1em">UV toUPPER (UV
cp) <br>
UV toUPPER_A (UV cp) <br>
UV toUPPER_uvchr (UV cp, U8* s, STRLEN* lenp) <br>
UV toUPPER_utf8 (U8* p, U8* e, U8* s, STRLEN* lenp) <br>
UV toUPPER_utf8_safe(U8* p, U8* e, U8* s, STRLEN* lenp)</p>

<h2>Character classification
<a name="Character classification"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section is
about functions (really macros) that classify characters
into types, such as punctuation versus alphabetic, etc. Most
of these are analogous to regular expression character
classes. (See &quot; <small>POSIX</small> Character
Classes&quot; in perlrecharclass.) There are several
variants for each class. (Not all macros have all variants;
each item below lists the ones valid for it.) None are
affected by &quot;use bytes&quot;, and only the ones with
&quot;LC&quot; in the name are affected by the current
locale.</p>

<p style="margin-left:11%; margin-top: 1em">The base
function, e.g., &quot;isALPHA()&quot;, takes any signed or
unsigned value, treating it as a code point, and returns a
boolean as to whether or not the character represented by it
is (or on non-ASCII platforms, corresponds to) an
<small>ASCII</small> character in the named class based on
platform, Unicode, and Perl rules. If the input is a number
that doesn&rsquo;t fit in an octet, <small>FALSE</small> is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">Variant
&quot;is<i>FOO</i>_A&quot; (e.g., &quot;isALPHA_A()&quot;)
is identical to the base function with no suffix
&quot;_A&quot;. This variant is used to emphasize by its
name that only ASCII-range characters can return
<small>TRUE.</small></p>

<p style="margin-left:11%; margin-top: 1em">Variant
&quot;is<i>FOO</i>_L1&quot; imposes the Latin&minus;1 (or
<small>EBCDIC</small> equivalent) character set onto the
platform. That is, the code points that are
<small>ASCII</small> are unaffected, since
<small>ASCII</small> is a subset of Latin&minus;1. But the
non-ASCII code points are treated as if they are
Latin&minus;1 characters. For example,
&quot;isWORDCHAR_L1()&quot; will return true when called
with the code point 0xDF, which is a word character in both
<small>ASCII</small> and <small>EBCDIC</small> (though it
represents different characters in each). If the input is a
number that doesn&rsquo;t fit in an octet,
<small>FALSE</small> is returned. (Perl&rsquo;s
documentation uses a colloquial definition of Latin&minus;1,
to include all code points below 256.)</p>

<p style="margin-left:11%; margin-top: 1em">Variant
&quot;is<i>FOO</i>_uvchr&quot; is exactly like the
&quot;is<i>FOO</i>_L1&quot; variant, for inputs below 256,
but if the code point is larger than 255, Unicode rules are
used to determine if it is in the character class. For
example, &quot;isWORDCHAR_uvchr(0x100)&quot; returns
<small>TRUE,</small> since 0x100 is <small>LATIN CAPITAL
LETTER A WITH MACRON</small> in Unicode, and is a word
character.</p>

<p style="margin-left:11%; margin-top: 1em">Variants
&quot;is<i>FOO</i>_utf8&quot; and
&quot;is<i>FOO</i>_utf8_safe&quot; are like
&quot;is<i>FOO</i>_uvchr&quot;, but are used for
<small>UTF&minus;8</small> encoded strings. The two forms
are different names for the same thing. Each call to one of
these classifies the first character of the string starting
at &quot;p&quot;. The second parameter, &quot;e&quot;,
points to anywhere in the string beyond the first character,
up to one byte past the end of the entire string. Although
both variants are identical, the suffix &quot;_safe&quot; in
one name emphasizes that it will not attempt to read beyond
&quot;e&nbsp;&minus;&nbsp;1&quot;, provided that the
constraint &quot;s&nbsp;&lt;&nbsp;e&quot; is true (this is
asserted for in &quot;&minus;DDEBUGGING&quot; builds). If
the <small>UTF&minus;8</small> for the input character is
malformed in some way, the program may croak, or the
function may return <small>FALSE,</small> at the discretion
of the implementation, and subject to change in future
releases.</p>

<p style="margin-left:11%; margin-top: 1em">Variant
&quot;is<i>FOO</i>_LC&quot; is like the
&quot;is<i>FOO</i>_A&quot; and &quot;is<i>FOO</i>_L1&quot;
variants, but the result is based on the current locale,
which is what &quot;LC&quot; in the name stands for. If Perl
can determine that the current locale is a
<small>UTF&minus;8</small> locale, it uses the published
Unicode rules; otherwise, it uses the C library function
that gives the named classification. For example,
&quot;isDIGIT_LC()&quot; when not in a
<small>UTF&minus;8</small> locale returns the result of
calling &quot;isdigit()&quot;. <small>FALSE</small> is
always returned if the input won&rsquo;t fit into an octet.
On some platforms where the C library function is known to
be defective, Perl changes its result to follow the
<small>POSIX</small> standard&rsquo;s rules.</p>

<p style="margin-left:11%; margin-top: 1em">Variant
&quot;is<i>FOO</i>_LC_uvchr&quot; acts exactly like
&quot;is<i>FOO</i>_LC&quot; for inputs less than 256, but
for larger ones it returns the Unicode classification of the
code point.</p>

<p style="margin-left:11%; margin-top: 1em">Variants
&quot;is<i>FOO</i>_LC_utf8&quot; and
&quot;is<i>FOO</i>_LC_utf8_safe&quot; are like
&quot;is<i>FOO</i>_LC_uvchr&quot;, but are used for
<small>UTF&minus;8</small> encoded strings. The two forms
are different names for the same thing. Each call to one of
these classifies the first character of the string starting
at &quot;p&quot;. The second parameter, &quot;e&quot;,
points to anywhere in the string beyond the first character,
up to one byte past the end of the entire string. Although
both variants are identical, the suffix &quot;_safe&quot; in
one name emphasizes that it will not attempt to read beyond
&quot;e&nbsp;&minus;&nbsp;1&quot;, provided that the
constraint &quot;s&nbsp;&lt;&nbsp;e&quot; is true (this is
asserted for in &quot;&minus;DDEBUGGING&quot; builds). If
the <small>UTF&minus;8</small> for the input character is
malformed in some way, the program may croak, or the
function may return <small>FALSE,</small> at the discretion
of the implementation, and subject to change in future
releases. <br>
&quot;isALPHA&quot; <br>
&quot;isALPHA_A&quot; <br>
&quot;isALPHA_L1&quot; <br>
&quot;isALPHA_uvchr&quot; <br>
&quot;isALPHA_utf8_safe&quot; <br>
&quot;isALPHA_utf8&quot; <br>
&quot;isALPHA_LC&quot; <br>
&quot;isALPHA_LC_uvchr&quot; <br>
&quot;isALPHA_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified input is one of
&quot;[A&minus;Za&minus;z]&quot;, analogous to
&quot;m/[[:alpha:]]/&quot;. See the top of this section for
an explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isALPHA
(UV ch) <br>
bool isALPHA_A (UV ch) <br>
bool isALPHA_L1 (UV ch) <br>
bool isALPHA_uvchr (UV ch) <br>
bool isALPHA_utf8_safe (U8 * s, U8 * end) <br>
bool isALPHA_utf8 (U8 * s, U8 * end) <br>
bool isALPHA_LC (UV ch) <br>
bool isALPHA_LC_uvchr (UV ch) <br>
bool isALPHA_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isALPHANUMERIC&quot; <br>
&quot;isALPHANUMERIC_A&quot; <br>
&quot;isALPHANUMERIC_L1&quot; <br>
&quot;isALPHANUMERIC_uvchr&quot; <br>
&quot;isALPHANUMERIC_utf8_safe&quot; <br>
&quot;isALPHANUMERIC_utf8&quot; <br>
&quot;isALPHANUMERIC_LC&quot; <br>
&quot;isALPHANUMERIC_LC_uvchr&quot; <br>
&quot;isALPHANUMERIC_LC_utf8_safe&quot; <br>
&quot;isALNUMC&quot; <br>
&quot;isALNUMC_A&quot; <br>
&quot;isALNUMC_L1&quot; <br>
&quot;isALNUMC_LC&quot; <br>
&quot;isALNUMC_LC_uvchr&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is one of
&quot;[A&minus;Za&minus;z0&minus;9]&quot;, analogous to
&quot;m/[[:alnum:]]/&quot;. See the top of this section for
an explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">A (discouraged
from use) synonym is &quot;isALNUMC&quot; (where the
&quot;C&quot; suffix means this corresponds to the C
language alphanumeric definition). Also there are the
variants &quot;isALNUMC_A&quot;, &quot;isALNUMC_L1&quot;
&quot;isALNUMC_LC&quot;, and
&quot;isALNUMC_LC_uvchr&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
isALPHANUMERIC (UV ch) <br>
bool isALPHANUMERIC_A (UV ch) <br>
bool isALPHANUMERIC_L1 (UV ch) <br>
bool isALPHANUMERIC_uvchr (UV ch) <br>
bool isALPHANUMERIC_utf8_safe (U8 * s, U8 * end) <br>
bool isALPHANUMERIC_utf8 (U8 * s, U8 * end) <br>
bool isALPHANUMERIC_LC (UV ch) <br>
bool isALPHANUMERIC_LC_uvchr (UV ch) <br>
bool isALPHANUMERIC_LC_utf8_safe(U8 * s, U8 *end) <br>
bool isALNUMC (UV ch) <br>
bool isALNUMC_A (UV ch) <br>
bool isALNUMC_L1 (UV ch) <br>
bool isALNUMC_LC (UV ch) <br>
bool isALNUMC_LC_uvchr (UV ch)</p>

<p style="margin-left:11%;">&quot;isASCII&quot; <br>
&quot;isASCII_A&quot; <br>
&quot;isASCII_L1&quot; <br>
&quot;isASCII_uvchr&quot; <br>
&quot;isASCII_utf8_safe&quot; <br>
&quot;isASCII_utf8&quot; <br>
&quot;isASCII_LC&quot; <br>
&quot;isASCII_LC_uvchr&quot; <br>
&quot;isASCII_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is one of the 128 characters
in the <small>ASCII</small> character set, analogous to
&quot;m/[[:ascii:]]/&quot;. On non-ASCII platforms, it
returns <small>TRUE</small> iff this character corresponds
to an <small>ASCII</small> character. Variants
&quot;isASCII_A()&quot; and &quot;isASCII_L1()&quot; are
identical to &quot;isASCII()&quot;. See the top of this
section for an explanation of the variants. Note, however,
that some platforms do not have the C library routine
&quot;isascii()&quot;. In these cases, the variants whose
names contain &quot;LC&quot; are the same as the
corresponding ones without.</p>

<p style="margin-left:17%; margin-top: 1em">Also note, that
because all <small>ASCII</small> characters are
<small>UTF&minus;8</small> invariant (meaning they have the
exact same representation (always a single byte) whether
encoded in <small>UTF&minus;8</small> or not),
&quot;isASCII&quot; will give the correct results when
called with any byte in any string encoded or not in
<small>UTF&minus;8.</small> And similarly
&quot;isASCII_utf8&quot; and &quot;isASCII_utf8_safe&quot;
will work properly on any string encoded or not in
<small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">bool isASCII
(UV ch) <br>
bool isASCII_A (UV ch) <br>
bool isASCII_L1 (UV ch) <br>
bool isASCII_uvchr (UV ch) <br>
bool isASCII_utf8_safe (U8 * s, U8 * end) <br>
bool isASCII_utf8 (U8 * s, U8 * end) <br>
bool isASCII_LC (UV ch) <br>
bool isASCII_LC_uvchr (UV ch) <br>
bool isASCII_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isBLANK&quot; <br>
&quot;isBLANK_A&quot; <br>
&quot;isBLANK_L1&quot; <br>
&quot;isBLANK_uvchr&quot; <br>
&quot;isBLANK_utf8_safe&quot; <br>
&quot;isBLANK_utf8&quot; <br>
&quot;isBLANK_LC&quot; <br>
&quot;isBLANK_LC_uvchr&quot; <br>
&quot;isBLANK_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a character considered to
be a blank, analogous to &quot;m/[[:blank:]]/&quot;. See the
top of this section for an explanation of the variants.
Note, however, that some platforms do not have the C library
routine &quot;isblank()&quot;. In these cases, the variants
whose names contain &quot;LC&quot; are the same as the
corresponding ones without.</p>

<p style="margin-left:17%; margin-top: 1em">bool isBLANK
(UV ch) <br>
bool isBLANK_A (UV ch) <br>
bool isBLANK_L1 (UV ch) <br>
bool isBLANK_uvchr (UV ch) <br>
bool isBLANK_utf8_safe (U8 * s, U8 * end) <br>
bool isBLANK_utf8 (U8 * s, U8 * end) <br>
bool isBLANK_LC (UV ch) <br>
bool isBLANK_LC_uvchr (UV ch) <br>
bool isBLANK_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isCNTRL&quot; <br>
&quot;isCNTRL_A&quot; <br>
&quot;isCNTRL_L1&quot; <br>
&quot;isCNTRL_uvchr&quot; <br>
&quot;isCNTRL_utf8_safe&quot; <br>
&quot;isCNTRL_utf8&quot; <br>
&quot;isCNTRL_LC&quot; <br>
&quot;isCNTRL_LC_uvchr&quot; <br>
&quot;isCNTRL_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a control character,
analogous to &quot;m/[[:cntrl:]]/&quot;. See the top of this
section for an explanation of the variants. On
<small>EBCDIC</small> platforms, you almost always want to
use the &quot;isCNTRL_L1&quot; variant.</p>

<p style="margin-left:17%; margin-top: 1em">bool isCNTRL
(UV ch) <br>
bool isCNTRL_A (UV ch) <br>
bool isCNTRL_L1 (UV ch) <br>
bool isCNTRL_uvchr (UV ch) <br>
bool isCNTRL_utf8_safe (U8 * s, U8 * end) <br>
bool isCNTRL_utf8 (U8 * s, U8 * end) <br>
bool isCNTRL_LC (UV ch) <br>
bool isCNTRL_LC_uvchr (UV ch) <br>
bool isCNTRL_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isDIGIT&quot; <br>
&quot;isDIGIT_A&quot; <br>
&quot;isDIGIT_L1&quot; <br>
&quot;isDIGIT_uvchr&quot; <br>
&quot;isDIGIT_utf8_safe&quot; <br>
&quot;isDIGIT_utf8&quot; <br>
&quot;isDIGIT_LC&quot; <br>
&quot;isDIGIT_LC_uvchr&quot; <br>
&quot;isDIGIT_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a digit, analogous to
&quot;m/[[:digit:]]/&quot;. Variants &quot;isDIGIT_A&quot;
and &quot;isDIGIT_L1&quot; are identical to
&quot;isDIGIT&quot;. See the top of this section for an
explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isDIGIT
(UV ch) <br>
bool isDIGIT_A (UV ch) <br>
bool isDIGIT_L1 (UV ch) <br>
bool isDIGIT_uvchr (UV ch) <br>
bool isDIGIT_utf8_safe (U8 * s, U8 * end) <br>
bool isDIGIT_utf8 (U8 * s, U8 * end) <br>
bool isDIGIT_LC (UV ch) <br>
bool isDIGIT_LC_uvchr (UV ch) <br>
bool isDIGIT_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isGRAPH&quot; <br>
&quot;isGRAPH_A&quot; <br>
&quot;isGRAPH_L1&quot; <br>
&quot;isGRAPH_uvchr&quot; <br>
&quot;isGRAPH_utf8_safe&quot; <br>
&quot;isGRAPH_utf8&quot; <br>
&quot;isGRAPH_LC&quot; <br>
&quot;isGRAPH_LC_uvchr&quot; <br>
&quot;isGRAPH_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a graphic character,
analogous to &quot;m/[[:graph:]]/&quot;. See the top of this
section for an explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isGRAPH
(UV ch) <br>
bool isGRAPH_A (UV ch) <br>
bool isGRAPH_L1 (UV ch) <br>
bool isGRAPH_uvchr (UV ch) <br>
bool isGRAPH_utf8_safe (U8 * s, U8 * end) <br>
bool isGRAPH_utf8 (U8 * s, U8 * end) <br>
bool isGRAPH_LC (UV ch) <br>
bool isGRAPH_LC_uvchr (UV ch) <br>
bool isGRAPH_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isIDCONT&quot; <br>
&quot;isIDCONT_A&quot; <br>
&quot;isIDCONT_L1&quot; <br>
&quot;isIDCONT_uvchr&quot; <br>
&quot;isIDCONT_utf8_safe&quot; <br>
&quot;isIDCONT_utf8&quot; <br>
&quot;isIDCONT_LC&quot; <br>
&quot;isIDCONT_LC_uvchr&quot; <br>
&quot;isIDCONT_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character can be the second or
succeeding character of an identifier. This is very close
to, but not quite the same as the official Unicode property
&quot;XID_Continue&quot;. The difference is that this
returns true only if the input character also matches
&quot;isWORDCHAR&quot;. See the top of this section for an
explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isIDCONT
(UV ch) <br>
bool isIDCONT_A (UV ch) <br>
bool isIDCONT_L1 (UV ch) <br>
bool isIDCONT_uvchr (UV ch) <br>
bool isIDCONT_utf8_safe (U8 * s, U8 * end) <br>
bool isIDCONT_utf8 (U8 * s, U8 * end) <br>
bool isIDCONT_LC (UV ch) <br>
bool isIDCONT_LC_uvchr (UV ch) <br>
bool isIDCONT_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isIDFIRST&quot; <br>
&quot;isIDFIRST_A&quot; <br>
&quot;isIDFIRST_L1&quot; <br>
&quot;isIDFIRST_uvchr&quot; <br>
&quot;isIDFIRST_utf8_safe&quot; <br>
&quot;isIDFIRST_utf8&quot; <br>
&quot;isIDFIRST_LC&quot; <br>
&quot;isIDFIRST_LC_uvchr&quot; <br>
&quot;isIDFIRST_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character can be the first character
of an identifier. This is very close to, but not quite the
same as the official Unicode property &quot;XID_Start&quot;.
The difference is that this returns true only if the input
character also matches &quot;isWORDCHAR&quot;. See the top
of this section for an explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isIDFIRST
(UV ch) <br>
bool isIDFIRST_A (UV ch) <br>
bool isIDFIRST_L1 (UV ch) <br>
bool isIDFIRST_uvchr (UV ch) <br>
bool isIDFIRST_utf8_safe (U8 * s, U8 * end) <br>
bool isIDFIRST_utf8 (U8 * s, U8 * end) <br>
bool isIDFIRST_LC (UV ch) <br>
bool isIDFIRST_LC_uvchr (UV ch) <br>
bool isIDFIRST_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isLOWER&quot; <br>
&quot;isLOWER_A&quot; <br>
&quot;isLOWER_L1&quot; <br>
&quot;isLOWER_uvchr&quot; <br>
&quot;isLOWER_utf8_safe&quot; <br>
&quot;isLOWER_utf8&quot; <br>
&quot;isLOWER_LC&quot; <br>
&quot;isLOWER_LC_uvchr&quot; <br>
&quot;isLOWER_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a lowercase character,
analogous to &quot;m/[[:lower:]]/&quot;. See the top of this
section for an explanation of the variants</p>

<p style="margin-left:17%; margin-top: 1em">bool isLOWER
(UV ch) <br>
bool isLOWER_A (UV ch) <br>
bool isLOWER_L1 (UV ch) <br>
bool isLOWER_uvchr (UV ch) <br>
bool isLOWER_utf8_safe (U8 * s, U8 * end) <br>
bool isLOWER_utf8 (U8 * s, U8 * end) <br>
bool isLOWER_LC (UV ch) <br>
bool isLOWER_LC_uvchr (UV ch) <br>
bool isLOWER_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isOCTAL&quot; <br>
&quot;isOCTAL_A&quot; <br>
&quot;isOCTAL_L1&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is an octal digit,
[0&minus;7]. The only two variants are &quot;isOCTAL_A&quot;
and &quot;isOCTAL_L1&quot;; each is identical to
&quot;isOCTAL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool isOCTAL(UV
ch)</p>

<p style="margin-left:11%;">&quot;isPRINT&quot; <br>
&quot;isPRINT_A&quot; <br>
&quot;isPRINT_L1&quot; <br>
&quot;isPRINT_uvchr&quot; <br>
&quot;isPRINT_utf8_safe&quot; <br>
&quot;isPRINT_utf8&quot; <br>
&quot;isPRINT_LC&quot; <br>
&quot;isPRINT_LC_uvchr&quot; <br>
&quot;isPRINT_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a printable character,
analogous to &quot;m/[[:print:]]/&quot;. See the top of this
section for an explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isPRINT
(UV ch) <br>
bool isPRINT_A (UV ch) <br>
bool isPRINT_L1 (UV ch) <br>
bool isPRINT_uvchr (UV ch) <br>
bool isPRINT_utf8_safe (U8 * s, U8 * end) <br>
bool isPRINT_utf8 (U8 * s, U8 * end) <br>
bool isPRINT_LC (UV ch) <br>
bool isPRINT_LC_uvchr (UV ch) <br>
bool isPRINT_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isPSXSPC&quot; <br>
&quot;isPSXSPC_A&quot; <br>
&quot;isPSXSPC_L1&quot; <br>
&quot;isPSXSPC_uvchr&quot; <br>
&quot;isPSXSPC_utf8_safe&quot; <br>
&quot;isPSXSPC_utf8&quot; <br>
&quot;isPSXSPC_LC&quot; <br>
&quot;isPSXSPC_LC_uvchr&quot; <br>
&quot;isPSXSPC_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">(short for Posix Space)
Starting in 5.18, this is identical in all its forms to the
corresponding &quot;isSPACE()&quot; macros. The locale forms
of this macro are identical to their corresponding
&quot;isSPACE()&quot; forms in all Perl releases. In
releases prior to 5.18, the non-locale forms differ from
their &quot;isSPACE()&quot; forms only in that the
&quot;isSPACE()&quot; forms don&rsquo;t match a Vertical
Tab, and the &quot;isPSXSPC()&quot; forms do. Otherwise they
are identical. Thus this macro is analogous to what
&quot;m/[[:space:]]/&quot; matches in a regular expression.
See the top of this section for an explanation of the
variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isPSXSPC
(UV ch) <br>
bool isPSXSPC_A (UV ch) <br>
bool isPSXSPC_L1 (UV ch) <br>
bool isPSXSPC_uvchr (UV ch) <br>
bool isPSXSPC_utf8_safe (U8 * s, U8 * end) <br>
bool isPSXSPC_utf8 (U8 * s, U8 * end) <br>
bool isPSXSPC_LC (UV ch) <br>
bool isPSXSPC_LC_uvchr (UV ch) <br>
bool isPSXSPC_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isPUNCT&quot; <br>
&quot;isPUNCT_A&quot; <br>
&quot;isPUNCT_L1&quot; <br>
&quot;isPUNCT_uvchr&quot; <br>
&quot;isPUNCT_utf8_safe&quot; <br>
&quot;isPUNCT_utf8&quot; <br>
&quot;isPUNCT_LC&quot; <br>
&quot;isPUNCT_LC_uvchr&quot; <br>
&quot;isPUNCT_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a punctuation character,
analogous to &quot;m/[[:punct:]]/&quot;. Note that the
definition of what is punctuation isn&rsquo;t as
straightforward as one might desire. See &quot;
<small>POSIX</small> Character Classes&quot; in
perlrecharclass for details. See the top of this section for
an explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isPUNCT
(UV ch) <br>
bool isPUNCT_A (UV ch) <br>
bool isPUNCT_L1 (UV ch) <br>
bool isPUNCT_uvchr (UV ch) <br>
bool isPUNCT_utf8_safe (U8 * s, U8 * end) <br>
bool isPUNCT_utf8 (U8 * s, U8 * end) <br>
bool isPUNCT_LC (UV ch) <br>
bool isPUNCT_LC_uvchr (UV ch) <br>
bool isPUNCT_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isSPACE&quot; <br>
&quot;isSPACE_A&quot; <br>
&quot;isSPACE_L1&quot; <br>
&quot;isSPACE_uvchr&quot; <br>
&quot;isSPACE_utf8_safe&quot; <br>
&quot;isSPACE_utf8&quot; <br>
&quot;isSPACE_LC&quot; <br>
&quot;isSPACE_LC_uvchr&quot; <br>
&quot;isSPACE_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a whitespace character.
This is analogous to what &quot;m/\s/&quot; matches in a
regular expression. Starting in Perl 5.18 this also matches
what &quot;m/[[:space:]]/&quot; does. Prior to 5.18, only
the locale forms of this macro (the ones with &quot;LC&quot;
in their names) matched precisely what
&quot;m/[[:space:]]/&quot; does. In those releases, the only
difference, in the non-locale variants, was that
&quot;isSPACE()&quot; did not match a vertical tab. (See
&quot;isPSXSPC&quot; for a macro that matches a vertical tab
in all releases.) See the top of this section for an
explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isSPACE
(UV ch) <br>
bool isSPACE_A (UV ch) <br>
bool isSPACE_L1 (UV ch) <br>
bool isSPACE_uvchr (UV ch) <br>
bool isSPACE_utf8_safe (U8 * s, U8 * end) <br>
bool isSPACE_utf8 (U8 * s, U8 * end) <br>
bool isSPACE_LC (UV ch) <br>
bool isSPACE_LC_uvchr (UV ch) <br>
bool isSPACE_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isUPPER&quot; <br>
&quot;isUPPER_A&quot; <br>
&quot;isUPPER_L1&quot; <br>
&quot;isUPPER_uvchr&quot; <br>
&quot;isUPPER_utf8_safe&quot; <br>
&quot;isUPPER_utf8&quot; <br>
&quot;isUPPER_LC&quot; <br>
&quot;isUPPER_LC_uvchr&quot; <br>
&quot;isUPPER_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is an uppercase character,
analogous to &quot;m/[[:upper:]]/&quot;. See the top of this
section for an explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isUPPER
(UV ch) <br>
bool isUPPER_A (UV ch) <br>
bool isUPPER_L1 (UV ch) <br>
bool isUPPER_uvchr (UV ch) <br>
bool isUPPER_utf8_safe (U8 * s, U8 * end) <br>
bool isUPPER_utf8 (U8 * s, U8 * end) <br>
bool isUPPER_LC (UV ch) <br>
bool isUPPER_LC_uvchr (UV ch) <br>
bool isUPPER_LC_utf8_safe(U8 * s, U8 *end)</p>

<p style="margin-left:11%;">&quot;isWORDCHAR&quot; <br>
&quot;isWORDCHAR_A&quot; <br>
&quot;isWORDCHAR_L1&quot; <br>
&quot;isWORDCHAR_uvchr&quot; <br>
&quot;isWORDCHAR_utf8_safe&quot; <br>
&quot;isWORDCHAR_utf8&quot; <br>
&quot;isWORDCHAR_LC&quot; <br>
&quot;isWORDCHAR_LC_uvchr&quot; <br>
&quot;isWORDCHAR_LC_utf8_safe&quot; <br>
&quot;isALNUM&quot; <br>
&quot;isALNUM_A&quot; <br>
&quot;isALNUM_LC&quot; <br>
&quot;isALNUM_LC_uvchr&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a character that is a
word character, analogous to what &quot;m/\w/&quot; and
&quot;m/[[:word:]]/&quot; match in a regular expression. A
word character is an alphabetic character, a decimal digit,
a connecting punctuation character (such as an underscore),
or a &quot;mark&quot; character that attaches to one of
those (like some sort of accent). &quot;isALNUM()&quot; is a
synonym provided for backward compatibility, even though a
word character includes more than the standard C language
meaning of alphanumeric. See the top of this section for an
explanation of the variants. &quot;isWORDCHAR_A&quot;,
&quot;isWORDCHAR_L1&quot;, &quot;isWORDCHAR_uvchr&quot;,
&quot;isWORDCHAR_LC&quot;, &quot;isWORDCHAR_LC_uvchr&quot;,
&quot;isWORDCHAR_LC_utf8&quot;, and
&quot;isWORDCHAR_LC_utf8_safe&quot; are also as described
there, but additionally include the platform&rsquo;s native
underscore.</p>

<p style="margin-left:17%; margin-top: 1em">bool isWORDCHAR
(UV ch) <br>
bool isWORDCHAR_A (UV ch) <br>
bool isWORDCHAR_L1 (UV ch) <br>
bool isWORDCHAR_uvchr (UV ch) <br>
bool isWORDCHAR_utf8_safe (U8 * s, U8 * end) <br>
bool isWORDCHAR_utf8 (U8 * s, U8 * end) <br>
bool isWORDCHAR_LC (UV ch) <br>
bool isWORDCHAR_LC_uvchr (UV ch) <br>
bool isWORDCHAR_LC_utf8_safe(U8 * s, U8 *end) <br>
bool isALNUM (UV ch) <br>
bool isALNUM_A (UV ch) <br>
bool isALNUM_LC (UV ch) <br>
bool isALNUM_LC_uvchr (UV ch)</p>

<p style="margin-left:11%;">&quot;isXDIGIT&quot; <br>
&quot;isXDIGIT_A&quot; <br>
&quot;isXDIGIT_L1&quot; <br>
&quot;isXDIGIT_uvchr&quot; <br>
&quot;isXDIGIT_utf8_safe&quot; <br>
&quot;isXDIGIT_utf8&quot; <br>
&quot;isXDIGIT_LC&quot; <br>
&quot;isXDIGIT_LC_uvchr&quot; <br>
&quot;isXDIGIT_LC_utf8_safe&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified character is a hexadecimal digit. In
the <small>ASCII</small> range these are
&quot;[0&minus;9A&minus;Fa&minus;f]&quot;. Variants
&quot;isXDIGIT_A()&quot; and &quot;isXDIGIT_L1()&quot; are
identical to &quot;isXDIGIT()&quot;. See the top of this
section for an explanation of the variants.</p>

<p style="margin-left:17%; margin-top: 1em">bool isXDIGIT
(UV ch) <br>
bool isXDIGIT_A (UV ch) <br>
bool isXDIGIT_L1 (UV ch) <br>
bool isXDIGIT_uvchr (UV ch) <br>
bool isXDIGIT_utf8_safe (U8 * s, U8 * end) <br>
bool isXDIGIT_utf8 (U8 * s, U8 * end) <br>
bool isXDIGIT_LC (UV ch) <br>
bool isXDIGIT_LC_uvchr (UV ch) <br>
bool isXDIGIT_LC_utf8_safe(U8 * s, U8 *end)</p>

<h2>Compiler and Preprocessor information
<a name="Compiler and Preprocessor information"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;CPPLAST&quot;</p>

<p style="margin-left:17%;">This symbol is intended to be
used along with &quot;CPPRUN&quot; in the same manner symbol
&quot;CPPMINUS&quot; is used with &quot;CPPSTDIN&quot;. It
contains either &quot;&minus;&quot; or &quot;&quot;.</p>

<p style="margin-left:11%;">&quot;CPPMINUS&quot;</p>

<p style="margin-left:17%;">This symbol contains the second
part of the string which will invoke the C preprocessor on
the standard input and produce to standard output. This
symbol will have the value &quot;&minus;&quot; if
&quot;CPPSTDIN&quot; needs a minus to specify standard
input, otherwise the value is &quot;&quot;.</p>

<p style="margin-left:11%;">&quot;CPPRUN&quot;</p>

<p style="margin-left:17%;">This symbol contains the string
which will invoke a C preprocessor on the standard input and
produce to standard output. It needs to end with
&quot;CPPLAST&quot;, after all other preprocessor flags have
been specified. The main difference with
&quot;CPPSTDIN&quot; is that this program will never be a
pointer to a shell wrapper, i.e. it will be empty if no
preprocessor is available directly to the user. Note that it
may well be different from the preprocessor used to compile
the C program.</p>

<p style="margin-left:11%;">&quot;CPPSTDIN&quot;</p>

<p style="margin-left:17%;">This symbol contains the first
part of the string which will invoke the C preprocessor on
the standard input and produce to standard output. Typical
value of &quot;cc &minus;E&quot; or
&quot;<i>/lib/cpp</i>&quot;, but it can also call a wrapper.
See &quot;CPPRUN&quot;.</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_ALWAYS_INLINE&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for functions that should always be inlined.</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_DEPRECATED&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for marking deprecated &quot;APIs&quot;</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_FORMAT&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for checking printf-style formats</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_NONNULL&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for nonnull function parms.</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_NORETURN&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for functions that do not return</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_PURE&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for pure functions</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_UNUSED&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for unused variables and arguments</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_WARN_UNUSED_RESULT&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for warning on unused results</p>


<p style="margin-left:11%;">&quot;HAS_BUILTIN_ADD_OVERFLOW&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the compiler supports
&quot;__builtin_add_overflow&quot; for adding integers with
overflow checks.</p>


<p style="margin-left:11%;">&quot;HAS_BUILTIN_CHOOSE_EXPR&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
builtin for compile-time ternary-like expressions</p>


<p style="margin-left:11%;">&quot;HAS_BUILTIN_EXPECT&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
builtin for telling that certain values are more likely</p>


<p style="margin-left:11%;">&quot;HAS_BUILTIN_MUL_OVERFLOW&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the compiler supports
&quot;__builtin_mul_overflow&quot; for multiplying integers
with overflow checks.</p>


<p style="margin-left:11%;">&quot;HAS_BUILTIN_SUB_OVERFLOW&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the compiler supports
&quot;__builtin_sub_overflow&quot; for subtracting integers
with overflow checks.</p>


<p style="margin-left:11%;">&quot;HAS_C99_VARIADIC_MACROS&quot;</p>

<p style="margin-left:17%;">If defined, the compiler
supports C99 variadic macros.</p>


<p style="margin-left:11%;">&quot;HAS_STATIC_INLINE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the C compiler supports C99&minus;style
static inline. That is, the function can&rsquo;t be called
from another translation unit.</p>

<p style="margin-left:11%;">&quot;MEM_ALIGNBYTES&quot;</p>

<p style="margin-left:17%;">This symbol contains the number
of bytes required to align a double, or a long double when
applicable. Usual values are 2, 4 and 8. The default is
eight, for safety. For cross-compiling or multiarch support,
Configure will set a minimum of 8.</p>


<p style="margin-left:11%;">&quot;PERL_STATIC_INLINE&quot;</p>

<p style="margin-left:17%;">This symbol gives the
best-guess incantation to use for static inline functions.
If &quot;HAS_STATIC_INLINE&quot; is defined, this will give
C99&minus;style inline. If &quot;HAS_STATIC_INLINE&quot; is
not defined, this will give a plain &rsquo;static&rsquo;. It
will always be defined to something that gives static
linkage. Possibilities include</p>

<p style="margin-left:17%; margin-top: 1em">static inline
(c99) <br>
static __inline__ (gcc &minus;ansi) <br>
static __inline (MSVC) <br>
static _inline (older MSVC) <br>
static (c89 compilers)</p>


<p style="margin-left:11%;">&quot;PERL_THREAD_LOCAL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, gives
a linkage specification for thread-local storage. For
example, for a C11 compiler this will be
&quot;_Thread_local&quot;. Beware, some compilers are
sensitive to the C language standard they are told to parse.
For example, suncc defaults to C11, so our probe will report
that &quot;_Thread_local&quot; can be used. However, if the
&minus;std=c99 is later added to the compiler flags, then
&quot;_Thread_local&quot; will become a syntax error. Hence
it is important for these flags to be consistent between
probing and use.</p>


<p style="margin-left:11%;">&quot;U32_ALIGNMENT_REQUIRED&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that you must access character data through
U32&minus;aligned pointers.</p>

<h2>Compiler directives
<a name="Compiler directives"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;ASSUME&quot;</p>

<p style="margin-left:17%;">&quot;ASSUME&quot; is like
&quot;assert()&quot;, but it has a benefit in a release
build. It is a hint to a compiler about a statement of fact
in a function call free expression, which allows the
compiler to generate better machine code. In a debug build,
ASSUME(x) is a synonym for assert(x). ASSUME(0) means the
control path is unreachable. In a for loop,
&quot;ASSUME&quot; can be used to hint that a loop will run
at least X times. &quot;ASSUME&quot; is based off
<small>MSVC</small> &rsquo;s &quot;__assume&quot; intrinsic
function, see its documents for more details.</p>

<p style="margin-left:17%; margin-top: 1em">ASSUME(bool
expr)</p>

<p style="margin-left:11%;">&quot;dNOOP&quot;</p>

<p style="margin-left:17%;">Declare nothing; typically used
as a placeholder to replace something that used to declare
something. Works on compilers that require declarations
before any code.</p>

<p style="margin-left:17%; margin-top: 1em">dNOOP;</p>

<p style="margin-left:11%;">&quot;END_EXTERN_C&quot;</p>

<p style="margin-left:17%;">When not compiling using C
<small>++</small> , expands to nothing. Otherwise ends a
section of code already begun by a
&quot;START_EXTERN_C&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">END_EXTERN_C</p>

<p style="margin-left:11%;">&quot;EXTERN_C&quot;</p>

<p style="margin-left:17%;">When not compiling using C
<small>++</small> , expands to nothing. Otherwise is used in
a declaration of a function to indicate the function should
have external C linkage. This is required for things to work
for just about all functions with external linkage compiled
into perl. Often, you can use &quot;START_EXTERN_C&quot; ...
&quot;END_EXTERN_C&quot; blocks surrounding all your code
that you need to have this linkage.</p>

<p style="margin-left:17%; margin-top: 1em">Example
usage:</p>

<p style="margin-left:17%; margin-top: 1em">EXTERN_C int
flock(int fd, int op);</p>

<p style="margin-left:11%;">&quot;LIKELY&quot;</p>

<p style="margin-left:17%;">Returns the input unchanged,
but at the same time it gives a branch prediction hint to
the compiler that this condition is likely to be true.</p>

<p style="margin-left:17%; margin-top: 1em">LIKELY(bool
expr)</p>

<p style="margin-left:11%;">&quot;NOOP&quot;</p>

<p style="margin-left:17%;">Do nothing; typically used as a
placeholder to replace something that used to do
something.</p>

<p style="margin-left:17%; margin-top: 1em">NOOP;</p>


<p style="margin-left:11%;">&quot;PERL_UNUSED_ARG&quot;</p>

<p style="margin-left:17%;">This is used to suppress
compiler warnings that a parameter to a function is not
used. This situation can arise, for example, when a
parameter is needed under some configuration conditions, but
not others, so that C preprocessor conditional compilation
causes it be used just some times.</p>


<p style="margin-left:17%; margin-top: 1em">PERL_UNUSED_ARG(void
x);</p>


<p style="margin-left:11%;">&quot;PERL_UNUSED_CONTEXT&quot;</p>

<p style="margin-left:17%;">This is used to suppress
compiler warnings that the thread context parameter to a
function is not used. This situation can arise, for example,
when a C preprocessor conditional compilation causes it be
used just some times.</p>


<p style="margin-left:17%; margin-top: 1em">PERL_UNUSED_CONTEXT;</p>


<p style="margin-left:11%;">&quot;PERL_UNUSED_DECL&quot;</p>

<p style="margin-left:17%;">Tells the compiler that the
parameter in the function prototype just before it is not
necessarily expected to be used in the function. Not that
many compilers understand this, so this should only be used
in cases where &quot;PERL_UNUSED_ARG&quot; can&rsquo;t
conveniently be used.</p>

<p style="margin-left:17%; margin-top: 1em">Example
usage:</p>

<p style="margin-left:17%; margin-top: 1em">Signal_t <br>
Perl_perly_sighandler(int sig, Siginfo_t *sip
PERL_UNUSED_DECL, <br>
void *uap PERL_UNUSED_DECL, bool safe)</p>


<p style="margin-left:11%;">&quot;PERL_UNUSED_RESULT&quot;</p>

<p style="margin-left:17%;">This macro indicates to discard
the return value of the function call inside it,
<i>e.g.</i>,</p>


<p style="margin-left:17%; margin-top: 1em">PERL_UNUSED_RESULT(foo(a,
b))</p>

<p style="margin-left:17%; margin-top: 1em">The main reason
for this is that the combination of &quot;gcc
&minus;Wunused&minus;result&quot; (part of
&quot;&minus;Wall&quot;) and the
&quot;__attribute__((warn_unused_result))&quot; cannot be
silenced with casting to &quot;void&quot;. This causes
trouble when the system header files use the attribute.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;PERL_UNUSED_RESULT&quot; sparingly, though, since
usually the warning is there for a good reason: you might
lose success/failure information, or leak resources, or
changes in resources.</p>

<p style="margin-left:17%; margin-top: 1em">But sometimes
you just want to ignore the return value, <i>e.g.</i>, on
codepaths soon ending up in abort, or in &quot;best
effort&quot; attempts, or in situations where there is no
good way to handle failures.</p>

<p style="margin-left:17%; margin-top: 1em">Sometimes
&quot;PERL_UNUSED_RESULT&quot; might not be the most natural
way: another possibility is that you can capture the return
value and use &quot;PERL_UNUSED_VAR&quot; on that.</p>


<p style="margin-left:17%; margin-top: 1em">PERL_UNUSED_RESULT(void
x)</p>


<p style="margin-left:11%;">&quot;PERL_UNUSED_VAR&quot;</p>

<p style="margin-left:17%;">This is used to suppress
compiler warnings that the variable <i>x</i> is not used.
This situation can arise, for example, when a C preprocessor
conditional compilation causes it be used just some
times.</p>


<p style="margin-left:17%; margin-top: 1em">PERL_UNUSED_VAR(void
x);</p>


<p style="margin-left:11%;">&quot;PERL_USE_GCC_BRACE_GROUPS&quot;</p>

<p style="margin-left:17%;">This C pre-processor value, if
defined, indicates that it is permissible to use the
<small>GCC</small> brace groups extension. This extension,
of the form</p>

<p style="margin-left:17%; margin-top: 1em">({ statement
... })</p>

<p style="margin-left:17%; margin-top: 1em">turns the block
consisting of <i>statements ...</i> into an expression with
a value, unlike plain C language blocks. This can present
optimization possibilities, <b><small>BUT</small></b> you
generally need to specify an alternative in case this
ability doesn&rsquo;t exist or has otherwise been
forbidden.</p>

<p style="margin-left:17%; margin-top: 1em">Example
usage:</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
PERL_USE_GCC_BRACE_GROUPS <br>
... <br>
#else <br>
... <br>
#endif</p>

<p style="margin-left:11%;">&quot;START_EXTERN_C&quot;</p>

<p style="margin-left:17%;">When not compiling using C
<small>++</small> , expands to nothing. Otherwise begins a
section of code in which every function will effectively
have &quot;EXTERN_C&quot; applied to it, that is to have
external C linkage. The section is ended by a
&quot;END_EXTERN_C&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">START_EXTERN_C</p>

<p style="margin-left:11%;">&quot;STATIC&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;STMT_START&quot; <br>
&quot;STMT_END&quot;</p>

<p style="margin-left:17%;">This allows a series of
statements in a macro to be used as a single statement, as
in</p>

<p style="margin-left:17%; margin-top: 1em">if (x)
STMT_START { ... } STMT_END else ...</p>

<p style="margin-left:17%; margin-top: 1em">Note that you
can&rsquo;t return a value out of them, which limits their
utility. But see &quot;PERL_USE_GCC_BRACE_GROUPS&quot;.</p>

<p style="margin-left:11%;">&quot;UNLIKELY&quot;</p>

<p style="margin-left:17%;">Returns the input unchanged,
but at the same time it gives a branch prediction hint to
the compiler that this condition is likely to be false.</p>

<p style="margin-left:17%; margin-top: 1em">UNLIKELY(bool
expr)</p>

<p style="margin-left:11%;">&quot;__ASSERT_&quot;</p>

<p style="margin-left:17%;">This is a helper macro to avoid
preprocessor issues, replaced by nothing unless under
<small>DEBUGGING,</small> where it expands to an assert of
its argument, followed by a comma (hence the comma
operator). If we just used a straight <b>assert()</b>, we
would get a comma with nothing before it when not
<small>DEBUGGING.</small></p>

<p style="margin-left:17%; margin-top: 1em">__ASSERT_(bool
expr)</p>

<h2>Compile-time scope hooks
<a name="Compile-time scope hooks"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;BhkDISABLE&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;BhkDISABLE&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Temporarily
disable an entry in this <small>BHK</small> structure, by
clearing the appropriate flag. &quot;which&quot; is a
preprocessor token indicating which entry to disable.</p>

<p style="margin-left:17%; margin-top: 1em">void
BhkDISABLE(BHK *hk, which)</p>

<p style="margin-left:11%;">&quot;BhkENABLE&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;BhkENABLE&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Re-enable an
entry in this <small>BHK</small> structure, by setting the
appropriate flag. &quot;which&quot; is a preprocessor token
indicating which entry to enable. This will assert (under
&minus;DDEBUGGING) if the entry doesn&rsquo;t contain a
valid pointer.</p>

<p style="margin-left:17%; margin-top: 1em">void
BhkENABLE(BHK *hk, which)</p>

<p style="margin-left:11%;">&quot;BhkENTRY_set&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;BhkENTRY_set&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Set an entry in
the <small>BHK</small> structure, and set the flags to
indicate it is valid. &quot;which&quot; is a preprocessing
token indicating which entry to set. The type of
&quot;ptr&quot; depends on the entry.</p>

<p style="margin-left:17%; margin-top: 1em">void
BhkENTRY_set(BHK *hk, which, void *ptr)</p>


<p style="margin-left:11%;">&quot;blockhook_register&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;blockhook_register&quot; is <b>experimental</b> and
may change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Register a set
of hooks to be called when the Perl lexical scope changes at
compile time. See &quot;Compile-time scope hooks&quot; in
perlguts.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;blockhook_register&quot; must be explicitly called as
&quot;Perl_blockhook_register&quot; with an
&quot;aTHX_&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_blockhook_register(pTHX_ BHK *hk)</p>

<h2>Concurrency
<a name="Concurrency"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;aTHX&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;aTHX_&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;CPERLscope&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;CPERLscope&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Now a
no-op.</p>

<p style="margin-left:17%; margin-top: 1em">void
CPERLscope(void x)</p>

<p style="margin-left:11%;">&quot;dTHR&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;dTHX&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;dTHXa&quot;</p>

<p style="margin-left:17%;">On threaded perls, set
&quot;pTHX&quot; to &quot;a&quot;; on unthreaded perls, do
nothing</p>

<p style="margin-left:11%;">&quot;dTHXoa&quot;</p>

<p style="margin-left:17%;">Now a synonym for
&quot;dTHXa&quot;.</p>

<p style="margin-left:11%;">&quot;dVAR&quot;</p>

<p style="margin-left:17%;">This is now a synonym for
dNOOP: declare nothing</p>


<p style="margin-left:11%;">&quot;GETENV_PRESERVES_OTHER_THREAD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the getenv system call doesn&rsquo;t zap the
static buffer of &quot;getenv()&quot; in a different thread.
The typical &quot;getenv()&quot; implementation will return
a pointer to the proper position in **environ. But some may
instead copy them to a static buffer in
&quot;getenv()&quot;. If there is a per-thread instance of
that buffer, or the return points to **environ, then a
many&minus;reader/1&minus;writer mutex will work; otherwise
an exclusive locking mutex is required to prevent races.</p>


<p style="margin-left:11%;">&quot;HAS_PTHREAD_ATFORK&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;pthread_atfork&quot; routine is
available to setup fork handlers.</p>


<p style="margin-left:11%;">&quot;HAS_PTHREAD_ATTR_SETSCOPE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;pthread_attr_setscope&quot; system
call is available to set the contention scope attribute of a
thread attribute object.</p>


<p style="margin-left:11%;">&quot;HAS_PTHREAD_YIELD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;pthread_yield&quot; routine is
available to yield the execution of the current thread.
&quot;sched_yield&quot; is preferable to
&quot;pthread_yield&quot;.</p>


<p style="margin-left:11%;">&quot;HAS_SCHED_YIELD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;sched_yield&quot; routine is
available to yield the execution of the current thread.
&quot;sched_yield&quot; is preferable to
&quot;pthread_yield&quot;.</p>


<p style="margin-left:11%;">&quot;I_MACH_CTHREADS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>mach/cthreads.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_MACH_CTHREADS <br>
#include &lt;mach_cthreads.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_PTHREAD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>pthread.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_PTHREAD <br>
#include &lt;pthread.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;MULTIPLICITY&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should be built to use multiplicity.</p>


<p style="margin-left:11%;">&quot;OLD_PTHREADS_API&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should be built to use the old draft
&quot;POSIX&quot; threads &quot;API&quot;.</p>


<p style="margin-left:11%;">&quot;OLD_PTHREAD_CREATE_JOINABLE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates how to create pthread in joinable (aka undetached)
state. &quot;NOTE&quot;: not defined if <i>pthread.h</i>
already has defined &quot;PTHREAD_CREATE_JOINABLE&quot; (the
new version of the constant). If defined, known values are
&quot;PTHREAD_CREATE_UNDETACHED&quot; and
&quot;__UNDETACHED&quot;.</p>


<p style="margin-left:11%;">&quot;PERL_IMPLICIT_CONTEXT&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;pTHX&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;pTHX_&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;SCHED_YIELD&quot;</p>

<p style="margin-left:17%;">This symbol defines the way to
yield the execution of the current thread. Known ways are
&quot;sched_yield&quot;, &quot;pthread_yield&quot;, and
&quot;pthread_yield&quot; with &quot;NULL&quot;.</p>

<h2>COPs and Hint Hashes
<a name="COPs and Hint Hashes"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;cop_fetch_label&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;cop_fetch_label&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
label attached to a cop, and stores its length in bytes into
*len. Upon return, *flags will be set to either
&quot;SVf_UTF8&quot; or 0.</p>

<p style="margin-left:17%; margin-top: 1em">Alternatively,
use the macro &quot;CopLABEL_len_flags&quot;; or if you
don&rsquo;t need to know if the label is
<small>UTF&minus;8</small> or not, the macro
&quot;CopLABEL_len&quot;; or if you additionally dont need
to know the length, &quot;CopLABEL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">const char *
cop_fetch_label(COP *const cop, STRLEN *len, <br>
U32 *flags)</p>

<p style="margin-left:11%;">&quot;CopFILE&quot;</p>

<p style="margin-left:17%;">Returns the name of the file
associated with the &quot;COP&quot; &quot;c&quot;</p>

<p style="margin-left:17%; margin-top: 1em">const char *
CopFILE(const COP * c)</p>

<p style="margin-left:11%;">&quot;CopFILEAV&quot;</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
associated with the &quot;COP&quot; &quot;c&quot;, creating
it if necessary.</p>

<p style="margin-left:17%; margin-top: 1em">AV *
CopFILEAV(const COP * c)</p>

<p style="margin-left:11%;">&quot;CopFILEAVn&quot;</p>

<p style="margin-left:17%;">Returns the <small>AV</small>
associated with the &quot;COP&quot; &quot;c&quot;, returning
<small>NULL</small> if it doesn&rsquo;t already exist.</p>

<p style="margin-left:17%; margin-top: 1em">AV *
CopFILEAVn(const COP * c)</p>

<p style="margin-left:11%;">&quot;CopFILEGV&quot;</p>

<p style="margin-left:17%;">Returns the <small>GV</small>
associated with the &quot;COP&quot; &quot;c&quot;</p>

<p style="margin-left:17%; margin-top: 1em">GV *
CopFILEGV(const COP * c)</p>

<p style="margin-left:11%;">&quot;CopFILEGV_set&quot;</p>

<p style="margin-left:17%;">Available only on unthreaded
perls. Makes &quot;pv&quot; the name of the file associated
with the &quot;COP&quot; &quot;c&quot;</p>

<p style="margin-left:17%; margin-top: 1em">void
CopFILEGV_set(COP * c, GV * gv)</p>

<p style="margin-left:11%;">&quot;CopFILE_set&quot;</p>

<p style="margin-left:17%;">Makes &quot;pv&quot; the name
of the file associated with the &quot;COP&quot;
&quot;c&quot;</p>

<p style="margin-left:17%; margin-top: 1em">void
CopFILE_set(COP * c, const char * pv)</p>

<p style="margin-left:11%;">&quot;CopFILESV&quot;</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
associated with the &quot;COP&quot; &quot;c&quot;</p>

<p style="margin-left:17%; margin-top: 1em">SV *
CopFILESV(const COP * c)</p>

<p style="margin-left:11%;">&quot;cophh_2hv&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;cophh_2hv&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Generates and
returns a standard Perl hash representing the full set of
key/value pairs in the cop hints hash &quot;cophh&quot;.
&quot;flags&quot; is currently unused and must be zero.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
cophh_2hv(const COPHH *cophh, U32 flags)</p>

<p style="margin-left:11%;">&quot;cophh_copy&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;cophh_copy&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Make and return
a complete copy of the cop hints hash &quot;cophh&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">COPHH *
cophh_copy(COPHH *cophh)</p>

<p style="margin-left:11%;">&quot;cophh_delete_pvn&quot;
<br>
&quot;cophh_delete_pv&quot; <br>
&quot;cophh_delete_pvs&quot; <br>
&quot;cophh_delete_sv&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small> all these
forms are <b>experimental</b> and may change or be removed
without notice.</p>

<p style="margin-left:17%; margin-top: 1em">These delete a
key and its associated value from the cop hints hash
&quot;cophh&quot;, and return the modified hash. The
returned hash pointer is in general not the same as the hash
pointer that was passed in. The input hash is consumed by
the function, and the pointer to it must not be subsequently
used. Use &quot;cophh_copy&quot; if you need both
hashes.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in how the key is specified. In all forms, the key is
pointed to by &quot;key&quot;. In the plain &quot;pv&quot;
form, the key is a C language NUL-terminated string. In the
&quot;pvs&quot; form, the key is a C language string
literal. In the &quot;pvn&quot; form, an additional
parameter, &quot;keylen&quot;, specifies the length of the
string, which hence, may contain embedded-NUL characters. In
the &quot;sv&quot; form, *key is an <small>SV,</small> and
the key is the <small>PV</small> extracted from that. using
&quot;SvPV_const&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;hash&quot;
is a precomputed hash of the key string, or zero if it has
not been precomputed. This parameter is omitted from the
&quot;pvs&quot; form, as it is computed automatically at
compile time.</p>

<p style="margin-left:17%; margin-top: 1em">The only flag
currently used from the &quot;flags&quot; parameter is
&quot;COPHH_KEY_UTF8&quot;. It is illegal to set this in the
&quot;sv&quot; form. In the &quot;pv*&quot; forms, it
specifies whether the key octets are interpreted as
<small>UTF&minus;8</small> (if set) or as Latin&minus;1 (if
cleared). The &quot;sv&quot; form uses the underlying
<small>SV</small> to determine the UTF&minus;8ness of the
octets.</p>

<p style="margin-left:17%; margin-top: 1em">COPHH *
cophh_delete_pvn(COPHH *cophh, const char *key, <br>
STRLEN keylen, U32 hash, U32 flags) <br>
COPHH * cophh_delete_pv (COPHH *cophh, const char *key, U32
hash, <br>
U32 flags) <br>
COPHH * cophh_delete_pvs(COPHH *cophh, &quot;key&quot;, U32
flags) <br>
COPHH * cophh_delete_sv (COPHH *cophh, SV *key, U32 hash,
<br>
U32 flags)</p>


<p style="margin-left:11%;">&quot;cophh_exists_pvn&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;cophh_exists_pvn&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">These look up
the hint entry in the cop &quot;cop&quot; with the key
specified by &quot;key&quot; (and &quot;keylen&quot; in the
&quot;pvn&quot; form), returning true if a value exists, and
false otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in how the key is specified. In the plain
&quot;pv&quot; form, the key is a C language NUL-terminated
string. In the &quot;pvs&quot; form, the key is a C language
string literal. In the &quot;pvn&quot; form, an additional
parameter, &quot;keylen&quot;, specifies the length of the
string, which hence, may contain embedded-NUL characters. In
the &quot;sv&quot; form, *key is an <small>SV,</small> and
the key is the <small>PV</small> extracted from that. using
&quot;SvPV_const&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;hash&quot;
is a precomputed hash of the key string, or zero if it has
not been precomputed. This parameter is omitted from the
&quot;pvs&quot; form, as it is computed automatically at
compile time.</p>

<p style="margin-left:17%; margin-top: 1em">The only flag
currently used from the &quot;flags&quot; parameter is
&quot;COPHH_KEY_UTF8&quot;. It is illegal to set this in the
&quot;sv&quot; form. In the &quot;pv*&quot; forms, it
specifies whether the key octets are interpreted as
<small>UTF&minus;8</small> (if set) or as Latin&minus;1 (if
cleared). The &quot;sv&quot; form uses the underlying
<small>SV</small> to determine the UTF&minus;8ness of the
octets.</p>

<p style="margin-left:17%; margin-top: 1em">bool
cophh_exists_pvn(const COPHH *cophh, const char *key, <br>
STRLEN keylen, U32 hash, U32 flags)</p>

<p style="margin-left:11%;">&quot;cophh_fetch_pvn&quot;
<br>
&quot;cophh_fetch_pv&quot; <br>
&quot;cophh_fetch_pvs&quot; <br>
&quot;cophh_fetch_sv&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small> all these
forms are <b>experimental</b> and may change or be removed
without notice.</p>

<p style="margin-left:17%; margin-top: 1em">These look up
the entry in the cop hints hash &quot;cophh&quot; with the
key specified by &quot;key&quot; (and &quot;keylen&quot; in
the &quot;pvn&quot; form), returning that value as a mortal
scalar copy, or &amp;PL_sv_placeholder if there is no value
associated with the key.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in how the key is specified. In the plain
&quot;pv&quot; form, the key is a C language NUL-terminated
string. In the &quot;pvs&quot; form, the key is a C language
string literal. In the &quot;pvn&quot; form, an additional
parameter, &quot;keylen&quot;, specifies the length of the
string, which hence, may contain embedded-NUL characters. In
the &quot;sv&quot; form, *key is an <small>SV,</small> and
the key is the <small>PV</small> extracted from that. using
&quot;SvPV_const&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;hash&quot;
is a precomputed hash of the key string, or zero if it has
not been precomputed. This parameter is omitted from the
&quot;pvs&quot; form, as it is computed automatically at
compile time.</p>

<p style="margin-left:17%; margin-top: 1em">The only flag
currently used from the &quot;flags&quot; parameter is
&quot;COPHH_KEY_UTF8&quot;. It is illegal to set this in the
&quot;sv&quot; form. In the &quot;pv*&quot; forms, it
specifies whether the key octets are interpreted as
<small>UTF&minus;8</small> (if set) or as Latin&minus;1 (if
cleared). The &quot;sv&quot; form uses the underlying
<small>SV</small> to determine the UTF&minus;8ness of the
octets.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
cophh_fetch_pvn(const COPHH *cophh, const char *key, <br>
STRLEN keylen, U32 hash, U32 flags) <br>
SV * cophh_fetch_pv (const COPHH *cophh, const char *key,
<br>
U32 hash, U32 flags) <br>
SV * cophh_fetch_pvs(const COPHH *cophh, &quot;key&quot;,
U32 flags) <br>
SV * cophh_fetch_sv (const COPHH *cophh, SV *key, U32 hash,
<br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;cophh_free&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;cophh_free&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Discard the cop
hints hash &quot;cophh&quot;, freeing all resources
associated with it.</p>

<p style="margin-left:17%; margin-top: 1em">void
cophh_free(COPHH *cophh)</p>


<p style="margin-left:11%;">&quot;cophh_new_empty&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;cophh_new_empty&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Generate and
return a fresh cop hints hash containing no entries.</p>

<p style="margin-left:17%; margin-top: 1em">COPHH *
cophh_new_empty()</p>

<p style="margin-left:11%;">&quot;cophh_store_pvn&quot;
<br>
&quot;cophh_store_pv&quot; <br>
&quot;cophh_store_pvs&quot; <br>
&quot;cophh_store_sv&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small> all these
forms are <b>experimental</b> and may change or be removed
without notice.</p>

<p style="margin-left:17%; margin-top: 1em">These store a
value, associated with a key, in the cop hints hash
&quot;cophh&quot;, and return the modified hash. The
returned hash pointer is in general not the same as the hash
pointer that was passed in. The input hash is consumed by
the function, and the pointer to it must not be subsequently
used. Use &quot;cophh_copy&quot; if you need both
hashes.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;value&quot;
is the scalar value to store for this key. &quot;value&quot;
is copied by these functions, which thus do not take
ownership of any reference to it, and hence later changes to
the scalar will not be reflected in the value visible in the
cop hints hash. Complex types of scalar will not be stored
with referential integrity, but will be coerced to
strings.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in how the key is specified. In all forms, the key is
pointed to by &quot;key&quot;. In the plain &quot;pv&quot;
form, the key is a C language NUL-terminated string. In the
&quot;pvs&quot; form, the key is a C language string
literal. In the &quot;pvn&quot; form, an additional
parameter, &quot;keylen&quot;, specifies the length of the
string, which hence, may contain embedded-NUL characters. In
the &quot;sv&quot; form, *key is an <small>SV,</small> and
the key is the <small>PV</small> extracted from that. using
&quot;SvPV_const&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;hash&quot;
is a precomputed hash of the key string, or zero if it has
not been precomputed. This parameter is omitted from the
&quot;pvs&quot; form, as it is computed automatically at
compile time.</p>

<p style="margin-left:17%; margin-top: 1em">The only flag
currently used from the &quot;flags&quot; parameter is
&quot;COPHH_KEY_UTF8&quot;. It is illegal to set this in the
&quot;sv&quot; form. In the &quot;pv*&quot; forms, it
specifies whether the key octets are interpreted as
<small>UTF&minus;8</small> (if set) or as Latin&minus;1 (if
cleared). The &quot;sv&quot; form uses the underlying
<small>SV</small> to determine the UTF&minus;8ness of the
octets.</p>

<p style="margin-left:17%; margin-top: 1em">COPHH *
cophh_store_pvn(COPHH *cophh, const char *key, <br>
STRLEN keylen, U32 hash, SV *value, <br>
U32 flags) <br>
COPHH * cophh_store_pv (COPHH *cophh, const char *key, U32
hash, <br>
SV *value, U32 flags) <br>
COPHH * cophh_store_pvs(COPHH *cophh, &quot;key&quot;, SV
*value, <br>
U32 flags) <br>
COPHH * cophh_store_sv (COPHH *cophh, SV *key, U32 hash,
<br>
SV *value, U32 flags)</p>

<p style="margin-left:11%;">&quot;cop_hints_2hv&quot;</p>

<p style="margin-left:17%;">Generates and returns a
standard Perl hash representing the full set of hint entries
in the cop &quot;cop&quot;. &quot;flags&quot; is currently
unused and must be zero.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
cop_hints_2hv(const COP *cop, U32 flags)</p>


<p style="margin-left:11%;">&quot;cop_hints_exists_pvn&quot;
<br>
&quot;cop_hints_exists_pv&quot; <br>
&quot;cop_hints_exists_pvs&quot; <br>
&quot;cop_hints_exists_sv&quot;</p>

<p style="margin-left:17%;">These look up the hint entry in
the cop &quot;cop&quot; with the key specified by
&quot;key&quot; (and &quot;keylen&quot; in the
&quot;pvn&quot; form), returning true if a value exists, and
false otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in how the key is specified. In all forms, the key is
pointed to by &quot;key&quot;. In the plain &quot;pv&quot;
form, the key is a C language NUL-terminated string. In the
&quot;pvs&quot; form, the key is a C language string
literal. In the &quot;pvn&quot; form, an additional
parameter, &quot;keylen&quot;, specifies the length of the
string, which hence, may contain embedded-NUL characters. In
the &quot;sv&quot; form, *key is an <small>SV,</small> and
the key is the <small>PV</small> extracted from that. using
&quot;SvPV_const&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;hash&quot;
is a precomputed hash of the key string, or zero if it has
not been precomputed. This parameter is omitted from the
&quot;pvs&quot; form, as it is computed automatically at
compile time.</p>

<p style="margin-left:17%; margin-top: 1em">The only flag
currently used from the &quot;flags&quot; parameter is
&quot;COPHH_KEY_UTF8&quot;. It is illegal to set this in the
&quot;sv&quot; form. In the &quot;pv*&quot; forms, it
specifies whether the key octets are interpreted as
<small>UTF&minus;8</small> (if set) or as Latin&minus;1 (if
cleared). The &quot;sv&quot; form uses the underlying
<small>SV</small> to determine the UTF&minus;8ness of the
octets.</p>

<p style="margin-left:17%; margin-top: 1em">bool
cop_hints_exists_pvn(const COP *cop, const char *key, <br>
STRLEN keylen, U32 hash, U32 flags) <br>
bool cop_hints_exists_pv (const COP *cop, const char *key,
<br>
U32 hash, U32 flags) <br>
bool cop_hints_exists_pvs(const COP *cop, &quot;key&quot;,
U32 flags) <br>
bool cop_hints_exists_sv (const COP *cop, SV *key, U32 hash,
<br>
U32 flags)</p>


<p style="margin-left:11%;">&quot;cop_hints_fetch_pvn&quot;
<br>
&quot;cop_hints_fetch_pv&quot; <br>
&quot;cop_hints_fetch_pvs&quot; <br>
&quot;cop_hints_fetch_sv&quot;</p>

<p style="margin-left:17%;">These look up the hint entry in
the cop &quot;cop&quot; with the key specified by
&quot;key&quot; (and &quot;keylen&quot; in the
&quot;pvn&quot; form), returning that value as a mortal
scalar copy, or &amp;PL_sv_placeholder if there is no value
associated with the key.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in how the key is specified. In the plain
&quot;pv&quot; form, the key is a C language NUL-terminated
string. In the &quot;pvs&quot; form, the key is a C language
string literal. In the &quot;pvn&quot; form, an additional
parameter, &quot;keylen&quot;, specifies the length of the
string, which hence, may contain embedded-NUL characters. In
the &quot;sv&quot; form, *key is an <small>SV,</small> and
the key is the <small>PV</small> extracted from that. using
&quot;SvPV_const&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;hash&quot;
is a precomputed hash of the key string, or zero if it has
not been precomputed. This parameter is omitted from the
&quot;pvs&quot; form, as it is computed automatically at
compile time.</p>

<p style="margin-left:17%; margin-top: 1em">The only flag
currently used from the &quot;flags&quot; parameter is
&quot;COPHH_KEY_UTF8&quot;. It is illegal to set this in the
&quot;sv&quot; form. In the &quot;pv*&quot; forms, it
specifies whether the key octets are interpreted as
<small>UTF&minus;8</small> (if set) or as Latin&minus;1 (if
cleared). The &quot;sv&quot; form uses the underlying
<small>SV</small> to determine the UTF&minus;8ness of the
octets.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
cop_hints_fetch_pvn(const COP *cop, const char *key, <br>
STRLEN keylen, U32 hash, U32 flags) <br>
SV * cop_hints_fetch_pv (const COP *cop, const char *key,
<br>
U32 hash, U32 flags) <br>
SV * cop_hints_fetch_pvs(const COP *cop, &quot;key&quot;,
U32 flags) <br>
SV * cop_hints_fetch_sv (const COP *cop, SV *key, U32 hash,
<br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;CopLABEL&quot; <br>
&quot;CopLABEL_len&quot; <br>
&quot;CopLABEL_len_flags&quot;</p>

<p style="margin-left:17%;">These return the label attached
to a cop.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;CopLABEL_len&quot;
and &quot;CopLABEL_len_flags&quot; additionally store the
number of bytes comprising the returned label into *len.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;CopLABEL_len_flags&quot;
additionally returns the UTF&minus;8ness of the returned
label, by setting *flags to 0 or &quot;SVf_UTF8&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">const char *
CopLABEL (COP *const cop) <br>
const char * CopLABEL_len (COP *const cop, STRLEN *len) <br>
const char * CopLABEL_len_flags(COP *const cop, STRLEN *len,
<br>
U32 *flags)</p>

<p style="margin-left:11%;">&quot;CopLINE&quot;</p>

<p style="margin-left:17%;">Returns the line number in the
source code associated with the &quot;COP&quot;
&quot;c&quot;</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
CopLINE(const COP * c)</p>

<p style="margin-left:11%;">&quot;CopSTASH&quot;</p>

<p style="margin-left:17%;">Returns the stash associated
with &quot;c&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
CopSTASH(const COP * c)</p>

<p style="margin-left:11%;">&quot;CopSTASH_eq&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
or not &quot;hv&quot; is the stash associated with
&quot;c&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
CopSTASH_eq(const COP * c, const HV * hv)</p>

<p style="margin-left:11%;">&quot;CopSTASHPV&quot;</p>

<p style="margin-left:17%;">Returns the package name of the
stash associated with &quot;c&quot;, or &quot;NULL&quot; if
no associated stash</p>

<p style="margin-left:17%; margin-top: 1em">char *
CopSTASHPV(const COP * c)</p>

<p style="margin-left:11%;">&quot;CopSTASHPV_set&quot;</p>

<p style="margin-left:17%;">Set the package name of the
stash associated with &quot;c&quot;, to the NUL-terminated C
string &quot;p&quot;, creating the package if necessary.</p>

<p style="margin-left:17%; margin-top: 1em">void
CopSTASHPV_set(COP * c, const char * pv)</p>

<p style="margin-left:11%;">&quot;CopSTASH_set&quot;</p>

<p style="margin-left:17%;">Set the stash associated with
&quot;c&quot; to &quot;hv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
CopSTASH_set(COP * c, HV * hv)</p>


<p style="margin-left:11%;">&quot;cop_store_label&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;cop_store_label&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Save a label
into a &quot;cop_hints_hash&quot;. You need to set flags to
&quot;SVf_UTF8&quot; for a <small>UTF&minus;8</small> label.
Any other flag is ignored.</p>

<p style="margin-left:17%; margin-top: 1em">void
cop_store_label(COP *const cop, const char *label, <br>
STRLEN len, U32 flags)</p>

<p style="margin-left:11%;">&quot;PERL_SI&quot;</p>

<p style="margin-left:17%;">Use this typedef to declare
variables that are to hold &quot;struct stackinfo&quot;.</p>

<p style="margin-left:11%;">&quot;PL_curcop&quot;</p>

<p style="margin-left:17%;">The currently active
<small>COP</small> (control op) roughly representing the
current statement in the source.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">COP*
PL_curcop</p>

<h2>Custom Operators
<a name="Custom Operators"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;custom_op_desc&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;custom_op_desc&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Return the
description of a given custom op. This was once used by the
&quot;OP_DESC&quot; macro, but is no longer: it has only
been kept for compatibility, and should not be used.</p>

<p style="margin-left:17%; margin-top: 1em">const char *
custom_op_desc(const OP *o)</p>

<p style="margin-left:11%;">&quot;custom_op_name&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;custom_op_name&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Return the name
for a given custom op. This was once used by the
&quot;OP_NAME&quot; macro, but is no longer: it has only
been kept for compatibility, and should not be used.</p>

<p style="margin-left:17%; margin-top: 1em">const char *
custom_op_name(const OP *o)</p>


<p style="margin-left:11%;">&quot;custom_op_register&quot;</p>

<p style="margin-left:17%;">Register a custom op. See
&quot;Custom Operators&quot; in perlguts.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;custom_op_register&quot; must be explicitly called as
&quot;Perl_custom_op_register&quot; with an
&quot;aTHX_&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_custom_op_register(pTHX_ Perl_ppaddr_t ppaddr, <br>
const XOP *xop)</p>


<p style="margin-left:11%;">&quot;Perl_custom_op_xop&quot;</p>

<p style="margin-left:17%;">Return the <small>XOP</small>
structure for a given custom op. This macro should be
considered internal to &quot;OP_NAME&quot; and the other
access macros: use them instead. This macro does call a
function. Prior to 5.19.6, this was implemented as a
function.</p>

<p style="margin-left:17%; margin-top: 1em">const XOP *
Perl_custom_op_xop(pTHX_ const OP *o)</p>

<p style="margin-left:11%;">&quot;XopDISABLE&quot;</p>

<p style="margin-left:17%;">Temporarily disable a member of
the <small>XOP,</small> by clearing the appropriate
flag.</p>

<p style="margin-left:17%; margin-top: 1em">void
XopDISABLE(XOP *xop, which)</p>

<p style="margin-left:11%;">&quot;XopENABLE&quot;</p>

<p style="margin-left:17%;">Reenable a member of the
<small>XOP</small> which has been disabled.</p>

<p style="margin-left:17%; margin-top: 1em">void
XopENABLE(XOP *xop, which)</p>

<p style="margin-left:11%;">&quot;XopENTRY&quot;</p>

<p style="margin-left:17%;">Return a member of the
<small>XOP</small> structure. &quot;which&quot; is a cpp
token indicating which entry to return. If the member is not
set this will return a default value. The return type
depends on &quot;which&quot;. This macro evaluates its
arguments more than once. If you are using
&quot;Perl_custom_op_xop&quot; to retrieve a &quot;XOP
*&quot; from a &quot;OP *&quot;, use the more efficient
&quot;XopENTRYCUSTOM&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">XopENTRY(XOP
*xop, which)</p>

<p style="margin-left:11%;">&quot;XopENTRYCUSTOM&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o),
which)&quot; but more efficient. The &quot;which&quot;
parameter is identical to &quot;XopENTRY&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">XopENTRYCUSTOM(const
OP *o, which)</p>

<p style="margin-left:11%;">&quot;XopENTRY_set&quot;</p>

<p style="margin-left:17%;">Set a member of the
<small>XOP</small> structure. &quot;which&quot; is a cpp
token indicating which entry to set. See &quot;Custom
Operators&quot; in perlguts for details about the available
members and how they are used. This macro evaluates its
argument more than once.</p>

<p style="margin-left:17%; margin-top: 1em">void
XopENTRY_set(XOP *xop, which, value)</p>

<p style="margin-left:11%;">&quot;XopFLAGS&quot;</p>

<p style="margin-left:17%;">Return the <small>XOP</small>
&rsquo;s flags.</p>

<p style="margin-left:17%; margin-top: 1em">U32
XopFLAGS(XOP *xop)</p>

<h2>CV Handling
<a name="CV Handling"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
documents functions to manipulate CVs which are code-values,
meaning subroutines. For more information, see perlguts.
<br>
&quot;caller_cx&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
equivalent of <b>caller()</b>. The returned
&quot;PERL_CONTEXT&quot; structure can be interrogated to
find all the information returned to Perl by
&quot;caller&quot;. Note that XSUBs don&rsquo;t get a stack
frame, so &quot;caller_cx(0, NULL)&quot; will return
information for the immediately-surrounding Perl code.</p>

<p style="margin-left:17%; margin-top: 1em">This function
skips over the automatic calls to &amp;DB::sub made on the
behalf of the debugger. If the stack frame requested was a
sub called by &quot;DB::sub&quot;, the return value will be
the frame for the call to &quot;DB::sub&quot;, since that
has the correct line number/etc. for the call site. If
<i>dbcxp</i> is non&minus;&quot;NULL&quot;, it will be set
to a pointer to the frame for the sub call itself.</p>

<p style="margin-left:17%; margin-top: 1em">const
PERL_CONTEXT * caller_cx(I32 level, <br>
const PERL_CONTEXT **dbcxp)</p>

<p style="margin-left:11%;">&quot;CvDEPTH&quot;</p>

<p style="margin-left:17%;">Returns the recursion level of
the <small>CV</small> &quot;sv&quot;. Hence &gt;= 2
indicates we are in a recursive call.</p>

<p style="margin-left:17%; margin-top: 1em">I32 *
CvDEPTH(const CV * const sv)</p>

<p style="margin-left:11%;">&quot;CvGV&quot;</p>

<p style="margin-left:17%;">Returns the <small>GV</small>
associated with the <small>CV</small> &quot;sv&quot;,
reifying it if necessary.</p>

<p style="margin-left:17%; margin-top: 1em">GV * CvGV(CV
*sv)</p>

<p style="margin-left:11%;">&quot;CvSTASH&quot;</p>

<p style="margin-left:17%;">Returns the stash of the
<small>CV.</small> A stash is the symbol table hash,
containing the package-scoped variables in the package where
the subroutine was defined. For more information, see
perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">This also has a
special use with <small>XS AUTOLOAD</small> subs. See
&quot;Autoloading with XSUBs&quot; in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">HV* CvSTASH(CV*
cv)</p>

<p style="margin-left:11%;">&quot;find_runcv&quot;</p>

<p style="margin-left:17%;">Locate the <small>CV</small>
corresponding to the currently executing sub or eval. If
&quot;db_seqp&quot; is non_null, skip CVs that are in the
<small>DB</small> package and populate *db_seqp with the cop
sequence number at the point that the <small>DB::</small>
code was entered. (This allows debuggers to eval in the
scope of the breakpoint rather than in the scope of the
debugger itself.)</p>

<p style="margin-left:17%; margin-top: 1em">CV*
find_runcv(U32 *db_seqp)</p>

<p style="margin-left:11%;">&quot;get_cv&quot; <br>
&quot;get_cvs&quot; <br>
&quot;get_cvn_flags&quot;</p>

<p style="margin-left:17%;">These return the
<small>CV</small> of the specified Perl subroutine.
&quot;flags&quot; are passed to
&quot;gv_fetchpvn_flags&quot;. If &quot;GV_ADD&quot; is set
and the Perl subroutine does not exist then it will be
declared (which has the same effect as saying &quot;sub
name;&quot;). If &quot;GV_ADD&quot; is not set and the
subroutine does not exist, then <small>NULL</small> is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ only in how the subroutine is specified.. With
&quot;get_cvs&quot;, the name is a literal C string,
enclosed in double quotes. With &quot;get_cv&quot;, the name
is given by the &quot;name&quot; parameter, which must be a
NUL-terminated C string. With &quot;get_cvn_flags&quot;, the
name is also given by the &quot;name&quot; parameter, but it
is a Perl string (possibly containing embedded
<small>NUL</small> bytes), and its length in bytes is
contained in the &quot;len&quot; parameter.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_get_cv()&quot; form is <b>deprecated</b>.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_get_cvs()&quot; form is
<b>deprecated</b>.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_get_cvn_flags()&quot; form is
<b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">CV* get_cv
(const char* name, I32 flags) <br>
CV * get_cvs (&quot;string&quot;, I32 flags) <br>
CV* get_cvn_flags(const char* name, STRLEN len, I32
flags)</p>

<p style="margin-left:11%;">&quot;Nullcv&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;Nullcv&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Null
<small>CV</small> pointer.</p>

<p style="margin-left:17%; margin-top: 1em">(deprecated
&minus; use &quot;(CV *)NULL&quot; instead)</p>

<p style="margin-left:11%;">&quot;SvAMAGIC_off&quot;</p>

<p style="margin-left:17%;">Indicate that &quot;sv&quot;
has overloading (active magic) disabled.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvAMAGIC_off(SV *sv)</p>

<p style="margin-left:11%;">&quot;SvAMAGIC_on&quot;</p>

<p style="margin-left:17%;">Indicate that &quot;sv&quot;
has overloading (active magic) enabled.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvAMAGIC_on(SV *sv)</p>

<h2>Debugging
<a name="Debugging"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;deb&quot;
<br>
&quot;deb_nocontext&quot;</p>

<p style="margin-left:17%;">When perl is compiled with
&quot;&minus;DDEBUGGING&quot;, this prints to
<small>STDERR</small> the information given by the
arguments, prefaced by the name of the file containing the
script causing the call, and the line number within that
file.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;v&quot; (verbose) debugging option is in effect, the
process id is also printed.</p>

<p style="margin-left:17%; margin-top: 1em">The two forms
differ only in that &quot;deb_nocontext&quot; does not take
a thread context (&quot;aTHX&quot;) parameter, so is used in
situations where the caller doesn&rsquo;t already have the
thread context.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;deb&quot; must be explicitly called as
&quot;Perl_deb&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void Perl_deb
(pTHX_ const char* pat, ...) <br>
void deb_nocontext(const char* pat, ...)</p>

<p style="margin-left:11%;">&quot;debstack&quot;</p>

<p style="margin-left:17%;">Dump the current stack</p>

<p style="margin-left:17%; margin-top: 1em">I32
debstack()</p>

<p style="margin-left:11%;">&quot;dump_all&quot;</p>

<p style="margin-left:17%;">Dumps the entire optree of the
current program starting at &quot;PL_main_root&quot; to
&quot;STDERR&quot;. Also dumps the optrees for all visible
subroutines in &quot;PL_defstash&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
dump_all()</p>


<p style="margin-left:11%;">&quot;dump_c_backtrace&quot;</p>

<p style="margin-left:17%;">Dumps the C backtrace to the
given &quot;fp&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Returns true if
a backtrace could be retrieved, false if not.</p>

<p style="margin-left:17%; margin-top: 1em">bool
dump_c_backtrace(PerlIO* fp, int max_depth, int skip)</p>

<p style="margin-left:11%;">&quot;dump_eval&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
dump_eval()</p>

<p style="margin-left:11%;">&quot;dump_form&quot;</p>

<p style="margin-left:17%;">Dumps the contents of the
format contained in the <small>GV</small> &quot;gv&quot; to
&quot;STDERR&quot;, or a message that one doesn&rsquo;t
exist.</p>

<p style="margin-left:17%; margin-top: 1em">void
dump_form(const GV* gv)</p>

<p style="margin-left:11%;">&quot;dump_packsubs&quot;</p>

<p style="margin-left:17%;">Dumps the optrees for all
visible subroutines in &quot;stash&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
dump_packsubs(const HV* stash)</p>

<p style="margin-left:11%;">&quot;dump_sub&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
dump_sub(const GV* gv)</p>


<p style="margin-left:11%;">&quot;get_c_backtrace_dump&quot;</p>

<p style="margin-left:17%;">Returns a <small>SV</small>
containing a dump of &quot;depth&quot; frames of the call
stack, skipping the &quot;skip&quot; innermost ones.
&quot;depth&quot; of 20 is usually enough.</p>

<p style="margin-left:17%; margin-top: 1em">The appended
output looks like:</p>

<p style="margin-left:17%; margin-top: 1em">... <br>
1 10e004812:0082 Perl_croak util.c:1716 /usr/bin/perl <br>
2 10df8d6d2:1d72 perl_parse perl.c:3975 /usr/bin/perl <br>
...</p>

<p style="margin-left:17%; margin-top: 1em">The fields are
tab-separated. The first column is the depth (zero being the
innermost non-skipped frame). In the hex:offset, the hex is
where the program counter was in &quot;S_parse_body&quot;,
and the :offset (might be missing) tells how much inside the
&quot;S_parse_body&quot; the program counter was.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;util.c:1716&quot; is the source code file and line
number.</p>

<p style="margin-left:17%; margin-top: 1em">The
<i>/usr/bin/perl</i> is obvious (hopefully).</p>

<p style="margin-left:17%; margin-top: 1em">Unknowns are
&quot;&minus;&quot;. Unknowns can happen unfortunately quite
easily: if the platform doesn&rsquo;t support retrieving the
information; if the binary is missing the debug information;
if the optimizer has transformed the code by for example
inlining.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
get_c_backtrace_dump(int max_depth, int skip)</p>

<p style="margin-left:11%;">&quot;gv_dump&quot;</p>

<p style="margin-left:17%;">Dump the name and, if they
differ, the effective name of the <small>GV</small>
&quot;gv&quot; to &quot;STDERR&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
gv_dump(GV* gv)</p>

<p style="margin-left:11%;">&quot;HAS_BACKTRACE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;backtrace()&quot; routine is
available to get a stack trace. The <i>execinfo.h</i> header
must be included to use this routine.</p>

<p style="margin-left:11%;">&quot;magic_dump&quot;</p>

<p style="margin-left:17%;">Dumps the contents of the
<small>MAGIC</small> &quot;mg&quot; to
&quot;STDERR&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
magic_dump(const MAGIC *mg)</p>

<p style="margin-left:11%;">&quot;op_class&quot;</p>

<p style="margin-left:17%;">Given an op, determine what
type of struct it has been allocated as. Returns one of the
OPclass enums, such as OPclass_LISTOP.</p>

<p style="margin-left:17%; margin-top: 1em">OPclass
op_class(const OP *o)</p>

<p style="margin-left:11%;">&quot;op_dump&quot;</p>

<p style="margin-left:17%;">Dumps the optree starting at
<small>OP</small> &quot;o&quot; to &quot;STDERR&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
op_dump(const OP *o)</p>

<p style="margin-left:11%;">&quot;PL_op&quot;</p>

<p style="margin-left:17%;">Described in perlhacktips.</p>

<p style="margin-left:11%;">&quot;PL_runops&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_sv_serial&quot;</p>

<p style="margin-left:17%;">Described in perlhacktips.</p>

<p style="margin-left:11%;">&quot;pmop_dump&quot;</p>

<p style="margin-left:17%;">Dump an <small>OP</small> that
is related to Pattern Matching, such as
&quot;s/foo/bar/&quot;; these require special handling.</p>

<p style="margin-left:17%; margin-top: 1em">void
pmop_dump(PMOP* pm)</p>

<p style="margin-left:11%;">&quot;sv_dump&quot;</p>

<p style="margin-left:17%;">Dumps the contents of an
<small>SV</small> to the &quot;STDERR&quot; filehandle.</p>

<p style="margin-left:17%; margin-top: 1em">For an example
of its output, see Devel::Peek.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_dump(SV* sv)</p>

<p style="margin-left:11%;">&quot;vdeb&quot;</p>

<p style="margin-left:17%;">This is like &quot;deb&quot;,
but &quot;args&quot; are an encapsulated argument list.</p>

<p style="margin-left:17%; margin-top: 1em">void vdeb(const
char* pat, va_list* args)</p>

<h2>Display functions
<a name="Display functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;form&quot;
<br>
&quot;form_nocontext&quot;</p>

<p style="margin-left:17%;">These take a sprintf-style
format pattern and conventional (non-SV) arguments and
return the formatted string.</p>

<p style="margin-left:17%; margin-top: 1em">(char *)
Perl_form(pTHX_ const char* pat, ...)</p>

<p style="margin-left:17%; margin-top: 1em">can be used any
place a string (char *) is required:</p>

<p style="margin-left:17%; margin-top: 1em">char * s =
Perl_form(&quot;%d.%d&quot;,major,minor);</p>

<p style="margin-left:17%; margin-top: 1em">They use a
single (per-thread) private buffer so if you want to format
several strings you must explicitly copy the earlier strings
away (and free the copies when you are done).</p>

<p style="margin-left:17%; margin-top: 1em">The two forms
differ only in that &quot;form_nocontext&quot; does not take
a thread context (&quot;aTHX&quot;) parameter, so is used in
situations where the caller doesn&rsquo;t already have the
thread context.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;form&quot; must be explicitly called as
&quot;Perl_form&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">char* Perl_form
(pTHX_ const char* pat, ...) <br>
char* form_nocontext(const char* pat, ...)</p>

<p style="margin-left:11%;">&quot;mess&quot; <br>
&quot;mess_nocontext&quot;</p>

<p style="margin-left:17%;">These take a sprintf-style
format pattern and argument list, which are used to generate
a string message. If the message does not end with a
newline, then it will be extended with some indication of
the current location in the code, as described for
&quot;mess_sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Normally, the
resulting message is returned in a new mortal
<small>SV.</small> But during global destruction a single
<small>SV</small> may be shared between uses of this
function.</p>

<p style="margin-left:17%; margin-top: 1em">The two forms
differ only in that &quot;mess_nocontext&quot; does not take
a thread context (&quot;aTHX&quot;) parameter, so is used in
situations where the caller doesn&rsquo;t already have the
thread context.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;mess&quot; must be explicitly called as
&quot;Perl_mess&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">SV* Perl_mess
(pTHX_ const char* pat, ...) <br>
SV* mess_nocontext(const char* pat, ...)</p>

<p style="margin-left:11%;">&quot;mess_sv&quot;</p>

<p style="margin-left:17%;">Expands a message, intended for
the user, to include an indication of the current location
in the code, if the message does not already appear to be
complete.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;basemsg&quot;
is the initial message or object. If it is a reference, it
will be used as-is and will be the result of this function.
Otherwise it is used as a string, and if it already ends
with a newline, it is taken to be complete, and the result
of this function will be the same string. If the message
does not end with a newline, then a segment such as &quot;at
foo.pl line 37&quot; will be appended, and possibly other
clauses indicating the current state of execution. The
resulting message will end with a dot and a newline.</p>

<p style="margin-left:17%; margin-top: 1em">Normally, the
resulting message is returned in a new mortal
<small>SV.</small> During global destruction a single
<small>SV</small> may be shared between uses of this
function. If &quot;consume&quot; is true, then the function
is permitted (but not required) to modify and return
&quot;basemsg&quot; instead of allocating a new
<small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">SV* mess_sv(SV*
basemsg, bool consume)</p>

<p style="margin-left:11%;">&quot;pv_display&quot;</p>

<p style="margin-left:17%;">Similar to</p>


<p style="margin-left:17%; margin-top: 1em">pv_escape(dsv,pv,cur,pvlim,PERL_PV_ESCAPE_QUOTE);</p>

<p style="margin-left:17%; margin-top: 1em">except that an
additional &quot;\0&quot; will be appended to the string
when len &gt; cur and pv[cur] is &quot;\0&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
final string may be up to 7 chars longer than pvlim.</p>

<p style="margin-left:17%; margin-top: 1em">char*
pv_display(SV *dsv, const char *pv, STRLEN cur, STRLEN len,
<br>
STRLEN pvlim)</p>

<p style="margin-left:11%;">&quot;pv_escape&quot;</p>

<p style="margin-left:17%;">Escapes at most the first
&quot;count&quot; chars of &quot;pv&quot; and puts the
results into &quot;dsv&quot; such that the size of the
escaped string will not exceed &quot;max&quot; chars and
will not contain any incomplete escape sequences. The number
of bytes escaped will be returned in the &quot;STRLEN
*escaped&quot; parameter if it is not null. When the
&quot;dsv&quot; parameter is null no escaping actually
occurs, but the number of bytes that would be escaped were
it not null will be calculated.</p>

<p style="margin-left:17%; margin-top: 1em">If flags
contains &quot;PERL_PV_ESCAPE_QUOTE&quot; then any double
quotes in the string will also be escaped.</p>

<p style="margin-left:17%; margin-top: 1em">Normally the
<small>SV</small> will be cleared before the escaped string
is prepared, but when &quot;PERL_PV_ESCAPE_NOCLEAR&quot; is
set this will not occur.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_PV_ESCAPE_UNI&quot; is set then the input string
is treated as <small>UTF&minus;8</small> if
&quot;PERL_PV_ESCAPE_UNI_DETECT&quot; is set then the input
string is scanned using &quot;is_utf8_string()&quot; to
determine if it is <small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_PV_ESCAPE_ALL&quot; is set then all input chars
will be output using &quot;\x01F1&quot; style escapes,
otherwise if &quot;PERL_PV_ESCAPE_NONASCII&quot; is set,
only non-ASCII chars will be escaped using this style;
otherwise, only chars above 255 will be so escaped; other
non printable chars will use octal or common escaped
patterns like &quot;\n&quot;. Otherwise, if
&quot;PERL_PV_ESCAPE_NOBACKSLASH&quot; then all chars below
255 will be treated as printable and will be output as
literals.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_PV_ESCAPE_FIRSTCHAR&quot; is set then only the
first char of the string will be escaped, regardless of max.
If the output is to be in hex, then it will be returned as a
plain hex sequence. Thus the output will either be a single
char, an octal escape sequence, a special escape like
&quot;\n&quot; or a hex value.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_PV_ESCAPE_RE&quot; is set then the escape char
used will be a &quot;%&quot; and not a &quot;\\&quot;. This
is because regexes very often contain backslashed sequences,
whereas &quot;%&quot; is not a particularly common character
in patterns.</p>

<p style="margin-left:17%; margin-top: 1em">Returns a
pointer to the escaped text as held by &quot;dsv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
pv_escape(SV *dsv, char const * const str, <br>
const STRLEN count, const STRLEN max, <br>
STRLEN * const escaped, const U32 flags)</p>

<p style="margin-left:11%;">&quot;pv_pretty&quot;</p>

<p style="margin-left:17%;">Converts a string into
something presentable, handling escaping via
&quot;pv_escape()&quot; and supporting quoting and
ellipses.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;PERL_PV_PRETTY_QUOTE&quot; flag is set then the result
will be double quoted with any double quotes in the string
escaped. Otherwise if the &quot;PERL_PV_PRETTY_LTGT&quot;
flag is set then the result be wrapped in angle
brackets.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;PERL_PV_PRETTY_ELLIPSES&quot; flag is set and not all
characters in string were output then an ellipsis
&quot;...&quot; will be appended to the string. Note that
this happens <small>AFTER</small> it has been quoted.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;start_color&quot; is non-null then it will be inserted
after the opening quote (if there is one) but before the
escaped text. If &quot;end_color&quot; is non-null then it
will be inserted after the escaped text but before any
quotes or ellipses.</p>

<p style="margin-left:17%; margin-top: 1em">Returns a
pointer to the prettified text as held by
&quot;dsv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
pv_pretty(SV *dsv, char const * const str, <br>
const STRLEN count, const STRLEN max, <br>
char const * const start_color, <br>
char const * const end_color, const U32 flags)</p>

<p style="margin-left:11%;">&quot;vform&quot;</p>

<p style="margin-left:17%;">Like &quot;form&quot; but but
the arguments are an encapsulated argument list.</p>

<p style="margin-left:17%; margin-top: 1em">char*
vform(const char* pat, va_list* args)</p>

<p style="margin-left:11%;">&quot;vmess&quot;</p>

<p style="margin-left:17%;">&quot;pat&quot; and
&quot;args&quot; are a sprintf-style format pattern and
encapsulated argument list, respectively. These are used to
generate a string message. If the message does not end with
a newline, then it will be extended with some indication of
the current location in the code, as described for
&quot;mess_sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Normally, the
resulting message is returned in a new mortal
<small>SV.</small> During global destruction a single
<small>SV</small> may be shared between uses of this
function.</p>

<p style="margin-left:17%; margin-top: 1em">SV* vmess(const
char* pat, va_list* args)</p>

<h2>Embedding, Threads, and Interpreter Cloning
<a name="Embedding, Threads, and Interpreter Cloning"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;call_atexit&quot;</p>

<p style="margin-left:17%;">Add a function &quot;fn&quot;
to the list of functions to be called at global destruction.
&quot;ptr&quot; will be passed as an argument to
&quot;fn&quot;; it can point to a &quot;struct&quot; so that
you can pass anything you want.</p>

<p style="margin-left:17%; margin-top: 1em">Note that under
threads, &quot;fn&quot; may run multiple times. This is
because the list is executed each time the current or any
descendent thread terminates.</p>

<p style="margin-left:17%; margin-top: 1em">void
call_atexit(ATEXIT_t fn, void *ptr)</p>

<p style="margin-left:11%;">&quot;cv_clone&quot;</p>

<p style="margin-left:17%;">Clone a <small>CV,</small>
making a lexical closure. &quot;proto&quot; supplies the
prototype of the function: its code, pad structure, and
other attributes. The prototype is combined with a capture
of outer lexicals to which the code refers, which are taken
from the currently-executing instance of the immediately
surrounding code.</p>

<p style="margin-left:17%; margin-top: 1em">CV*
cv_clone(CV* proto)</p>

<p style="margin-left:11%;">&quot;cv_name&quot;</p>

<p style="margin-left:17%;">Returns an <small>SV</small>
containing the name of the <small>CV,</small> mainly for use
in error reporting. The <small>CV</small> may actually be a
<small>GV</small> instead, in which case the returned
<small>SV</small> holds the <small>GV</small> &rsquo;s name.
Anything other than a <small>GV</small> or <small>CV</small>
is treated as a string already holding the sub name, but
this could change in the future.</p>

<p style="margin-left:17%; margin-top: 1em">An
<small>SV</small> may be passed as a second argument. If so,
the name will be assigned to it and it will be returned.
Otherwise the returned <small>SV</small> will be a new
mortal.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; has the &quot;CV_NAME_NOTQUAL&quot; bit
set, then the package name will not be included. If the
first argument is neither a <small>CV</small> nor a
<small>GV,</small> this flag is ignored (subject to
change).</p>

<p style="margin-left:17%; margin-top: 1em">SV * cv_name(CV
*cv, SV *sv, U32 flags)</p>

<p style="margin-left:11%;">&quot;cv_undef&quot;</p>

<p style="margin-left:17%;">Clear out all the active
components of a <small>CV.</small> This can happen either by
an explicit &quot;undef &amp;foo&quot;, or by the reference
count going to zero. In the former case, we keep the
&quot;CvOUTSIDE&quot; pointer, so that any anonymous
children can still follow the full lexical scope chain.</p>

<p style="margin-left:17%; margin-top: 1em">void
cv_undef(CV* cv)</p>

<p style="margin-left:11%;">&quot;find_rundefsv&quot;</p>

<p style="margin-left:17%;">Returns the global variable
$_.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
find_rundefsv()</p>


<p style="margin-left:11%;">&quot;find_rundefsvoffset&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;find_rundefsvoffset&quot; from
a future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Until the
lexical $_ feature was removed, this function would find the
position of the lexical $_ in the pad of the
currently-executing function and return the offset in the
current pad, or &quot;NOT_IN_PAD&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Now it always
returns &quot;NOT_IN_PAD&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
find_rundefsvoffset()</p>


<p style="margin-left:11%;">&quot;HAS_SKIP_LOCALE_INIT&quot;</p>

<p style="margin-left:17%;">Described in perlembed.</p>

<p style="margin-left:11%;">&quot;intro_my&quot;</p>

<p style="margin-left:17%;">&quot;Introduce&quot;
&quot;my&quot; variables to visible status. This is called
during parsing at the end of each statement to make lexical
variables visible to subsequent statements.</p>

<p style="margin-left:17%; margin-top: 1em">U32
intro_my()</p>

<p style="margin-left:11%;">&quot;load_module&quot; <br>
&quot;load_module_nocontext&quot;</p>

<p style="margin-left:17%;">These load the module whose
name is pointed to by the string part of &quot;name&quot;.
Note that the actual module name, not its filename, should
be given. Eg, &quot;Foo::Bar&quot; instead of
&quot;Foo/Bar.pm&quot;. ver, if specified and not
<small>NULL,</small> provides version semantics similar to
&quot;use Foo::Bar VERSION&quot;. The optional trailing
arguments can be used to specify arguments to the
module&rsquo;s &quot;import()&quot; method, similar to
&quot;use Foo::Bar VERSION LIST&quot;; their precise
handling depends on the flags. The flags argument is a
bitwise-ORed collection of any of
&quot;PERL_LOADMOD_DENY&quot;,
&quot;PERL_LOADMOD_NOIMPORT&quot;, or
&quot;PERL_LOADMOD_IMPORT_OPS&quot; (or 0 for no flags).</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_LOADMOD_NOIMPORT&quot; is set, the module is
loaded as if with an empty import list, as in &quot;use
Foo::Bar ()&quot;; this is the only circumstance in which
the trailing optional arguments may be omitted entirely.
Otherwise, if &quot;PERL_LOADMOD_IMPORT_OPS&quot; is set,
the trailing arguments must consist of exactly one
&quot;OP*&quot;, containing the op tree that produces the
relevant import arguments. Otherwise, the trailing arguments
must all be &quot;SV*&quot; values that will be used as
import arguments; and the list must be terminated with
&quot;(SV*) NULL&quot;. If neither
&quot;PERL_LOADMOD_NOIMPORT&quot; nor
&quot;PERL_LOADMOD_IMPORT_OPS&quot; is set, the trailing
&quot;NULL&quot; pointer is needed even if no import
arguments are desired. The reference count for each
specified &quot;SV*&quot; argument is decremented. In
addition, the &quot;name&quot; argument is modified.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_LOADMOD_DENY&quot; is set, the module is loaded
as if with &quot;no&quot; rather than &quot;use&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;load_module&quot;
and &quot;load_module_nocontext&quot; have the same apparent
signature, but the former hides the fact that it is
accessing a thread context parameter. So use the latter when
you get a compilation error about &quot;pTHX&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
load_module (U32 flags, SV* name, SV* ver, ...) <br>
void load_module_nocontext(U32 flags, SV* name, SV* ver,
...)</p>

<p style="margin-left:11%;">&quot;my_exit&quot;</p>

<p style="margin-left:17%;">A wrapper for the C library
<b>exit</b>(3), honoring what &quot;PL_exit_flags&quot; in
perlapi say to do.</p>

<p style="margin-left:17%; margin-top: 1em">void
my_exit(U32 status)</p>

<p style="margin-left:11%;">&quot;newPADNAMELIST&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;newPADNAMELIST&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Creates a new
pad name list. &quot;max&quot; is the highest index for
which space is allocated.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAMELIST *
newPADNAMELIST(size_t max)</p>


<p style="margin-left:11%;">&quot;newPADNAMEouter&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;newPADNAMEouter&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Constructs and
returns a new pad name. Only use this function for names
that refer to outer lexicals. (See also
&quot;newPADNAMEpvn&quot;.) &quot;outer&quot; is the outer
pad name that this one mirrors. The returned pad name has
the &quot;PADNAMEt_OUTER&quot; flag already set.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAME *
newPADNAMEouter(PADNAME *outer)</p>

<p style="margin-left:11%;">&quot;newPADNAMEpvn&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;newPADNAMEpvn&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Constructs and
returns a new pad name. &quot;s&quot; must be a
<small>UTF&minus;8</small> string. Do not use this for pad
names that point to outer lexicals. See
&quot;newPADNAMEouter&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAME *
newPADNAMEpvn(const char *s, STRLEN len)</p>

<p style="margin-left:11%;">&quot;nothreadhook&quot;</p>

<p style="margin-left:17%;">Stub that provides thread hook
for perl_destruct when there are no threads.</p>

<p style="margin-left:17%; margin-top: 1em">int
nothreadhook()</p>

<p style="margin-left:11%;">&quot;pad_add_anon&quot;</p>

<p style="margin-left:17%;">Allocates a place in the
currently-compiling pad (via &quot;pad_alloc&quot;) for an
anonymous function that is lexically scoped inside the
currently-compiling function. The function &quot;func&quot;
is linked into the pad, and its &quot;CvOUTSIDE&quot; link
to the outer scope is weakened to avoid a reference
loop.</p>

<p style="margin-left:17%; margin-top: 1em">One reference
count is stolen, so you may need to do
&quot;SvREFCNT_inc(func)&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;optype&quot;
should be an opcode indicating the type of operation that
the pad entry is to support. This doesn&rsquo;t affect
operational semantics, but is used for debugging.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_add_anon(CV* func, I32 optype)</p>


<p style="margin-left:11%;">&quot;pad_add_name_pv&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;pad_add_name_pvn&quot;, but takes a nul-terminated
string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_add_name_pv(const char *name, const U32 flags, <br>
HV *typestash, HV *ourstash)</p>


<p style="margin-left:11%;">&quot;pad_add_name_pvn&quot;</p>

<p style="margin-left:17%;">Allocates a place in the
currently-compiling pad for a named lexical variable. Stores
the name and other metadata in the name part of the pad, and
makes preparations to manage the variable&rsquo;s lexical
scoping. Returns the offset of the allocated pad slot.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;namepv&quot;/&quot;namelen&quot;
specify the variable&rsquo;s name, including leading sigil.
If &quot;typestash&quot; is non-null, the name is for a
typed lexical, and this identifies the type. If
&quot;ourstash&quot; is non-null, it&rsquo;s a lexical
reference to a package variable, and this identifies the
package. The following flags can be <small>OR</small>
&rsquo;ed together:</p>

<p style="margin-left:17%; margin-top: 1em">padadd_OUR
redundantly specifies if it's a package var <br>
padadd_STATE variable will retain value persistently <br>
padadd_NO_DUP_CHECK skip check for lexical shadowing</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_add_name_pvn(const char *namepv, STRLEN namelen, <br>
U32 flags, HV *typestash, <br>
HV *ourstash)</p>


<p style="margin-left:11%;">&quot;pad_add_name_sv&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;pad_add_name_pvn&quot;, but takes the name string in
the form of an <small>SV</small> instead of a string/length
pair.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_add_name_sv(SV *name, U32 flags, HV *typestash, <br>
HV *ourstash)</p>

<p style="margin-left:11%;">&quot;pad_alloc&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;pad_alloc&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Allocates a
place in the currently-compiling pad, returning the offset
of the allocated pad slot. No name is initially attached to
the pad slot. &quot;tmptype&quot; is a set of flags
indicating the kind of pad entry required, which will be set
in the value <small>SV</small> for the allocated pad
entry:</p>

<p style="margin-left:17%; margin-top: 1em">SVs_PADMY named
lexical variable (&quot;my&quot;, &quot;our&quot;,
&quot;state&quot;) <br>
SVs_PADTMP unnamed temporary store <br>
SVf_READONLY constant shared between recursion levels</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SVf_READONLY&quot;
has been supported here only since perl 5.20. To work with
earlier versions as well, use
&quot;SVf_READONLY|SVs_PADTMP&quot;.
&quot;SVf_READONLY&quot; does not cause the
<small>SV</small> in the pad slot to be marked read-only,
but simply tells &quot;pad_alloc&quot; that it <i>will</i>
be made read-only (by the caller), or at least should be
treated as such.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;optype&quot;
should be an opcode indicating the type of operation that
the pad entry is to support. This doesn&rsquo;t affect
operational semantics, but is used for debugging.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_alloc(I32 optype, U32 tmptype)</p>

<p style="margin-left:11%;">&quot;pad_findmy_pv&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;pad_findmy_pvn&quot;, but takes a nul-terminated
string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_findmy_pv(const char* name, U32 flags)</p>

<p style="margin-left:11%;">&quot;pad_findmy_pvn&quot;</p>

<p style="margin-left:17%;">Given the name of a lexical
variable, find its position in the currently-compiling pad.
&quot;namepv&quot;/&quot;namelen&quot; specify the
variable&rsquo;s name, including leading sigil.
&quot;flags&quot; is reserved and must be zero. If it is not
in the current pad but appears in the pad of any lexically
enclosing scope, then a pseudo-entry for it is added in the
current pad. Returns the offset in the current pad, or
&quot;NOT_IN_PAD&quot; if no such lexical is in scope.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_findmy_pvn(const char* namepv, STRLEN namelen, <br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;pad_findmy_sv&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;pad_findmy_pvn&quot;, but takes the name string in the
form of an <small>SV</small> instead of a string/length
pair.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_findmy_sv(SV* name, U32 flags)</p>


<p style="margin-left:11%;">&quot;padnamelist_fetch&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;padnamelist_fetch&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Fetches the pad
name from the given index.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAME *
padnamelist_fetch(PADNAMELIST *pnl, SSize_t key)</p>


<p style="margin-left:11%;">&quot;padnamelist_store&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;padnamelist_store&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Stores the pad
name (which may be null) at the given index, freeing any
existing pad name in that slot.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAME **
padnamelist_store(PADNAMELIST *pnl, SSize_t key, <br>
PADNAME *val)</p>

<p style="margin-left:11%;">&quot;pad_tidy&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;pad_tidy&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Tidy up a pad
at the end of compilation of the code to which it belongs.
Jobs performed here are: remove most stuff from the pads of
anonsub prototypes; give it a @_; mark temporaries as such.
&quot;type&quot; indicates the kind of subroutine:</p>

<p style="margin-left:17%; margin-top: 1em">padtidy_SUB
ordinary subroutine <br>
padtidy_SUBCLONE prototype for lexical closure <br>
padtidy_FORMAT format</p>

<p style="margin-left:17%; margin-top: 1em">void
pad_tidy(padtidy_type type)</p>

<p style="margin-left:11%;">&quot;perl_alloc&quot;</p>

<p style="margin-left:17%;">Allocates a new Perl
interpreter. See perlembed.</p>


<p style="margin-left:17%; margin-top: 1em">PerlInterpreter*
perl_alloc()</p>


<p style="margin-left:11%;">&quot;PERL_ASYNC_CHECK&quot;</p>

<p style="margin-left:17%;">Described in perlinterp.</p>

<p style="margin-left:17%; margin-top: 1em">void
PERL_ASYNC_CHECK()</p>

<p style="margin-left:11%;">&quot;perl_construct&quot;</p>

<p style="margin-left:17%;">Initializes a new Perl
interpreter. See perlembed.</p>

<p style="margin-left:17%; margin-top: 1em">void
perl_construct(PerlInterpreter *my_perl)</p>

<p style="margin-left:11%;">&quot;perl_destruct&quot;</p>

<p style="margin-left:17%;">Shuts down a Perl interpreter.
See perlembed for a tutorial.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;my_perl&quot;
points to the Perl interpreter. It must have been previously
created through the use of &quot;perl_alloc&quot; and
&quot;perl_construct&quot;. It may have been initialised
through &quot;perl_parse&quot;, and may have been used
through &quot;perl_run&quot; and other means. This function
should be called for any Perl interpreter that has been
constructed with &quot;perl_construct&quot;, even if
subsequent operations on it failed, for example if
&quot;perl_parse&quot; returned a non-zero value.</p>

<p style="margin-left:17%; margin-top: 1em">If the
interpreter&rsquo;s &quot;PL_exit_flags&quot; word has the
&quot;PERL_EXIT_DESTRUCT_END&quot; flag set, then this
function will execute code in &quot;END&quot; blocks before
performing the rest of destruction. If it is desired to make
any use of the interpreter between &quot;perl_parse&quot;
and &quot;perl_destruct&quot; other than just calling
&quot;perl_run&quot;, then this flag should be set early on.
This matters if &quot;perl_run&quot; will not be called, or
if anything else will be done in addition to calling
&quot;perl_run&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Returns a value
be a suitable value to pass to the C library function
&quot;exit&quot; (or to return from &quot;main&quot;), to
serve as an exit code indicating the nature of the way the
interpreter terminated. This takes into account any failure
of &quot;perl_parse&quot; and any early exit from
&quot;perl_run&quot;. The exit code is of the type required
by the host operating system, so because of differing exit
code conventions it is not portable to interpret specific
numeric values as having specific meanings.</p>

<p style="margin-left:17%; margin-top: 1em">int
perl_destruct(PerlInterpreter *my_perl)</p>

<p style="margin-left:11%;">&quot;perl_free&quot;</p>

<p style="margin-left:17%;">Releases a Perl interpreter.
See perlembed.</p>

<p style="margin-left:17%; margin-top: 1em">void
perl_free(PerlInterpreter *my_perl)</p>


<p style="margin-left:11%;">&quot;PERL_GET_CONTEXT&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:11%;">&quot;PerlInterpreter&quot;</p>

<p style="margin-left:17%;">Described in perlembed.</p>

<p style="margin-left:11%;">&quot;perl_parse&quot;</p>

<p style="margin-left:17%;">Tells a Perl interpreter to
parse a Perl script. This performs most of the
initialisation of a Perl interpreter. See perlembed for a
tutorial.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;my_perl&quot;
points to the Perl interpreter that is to parse the script.
It must have been previously created through the use of
&quot;perl_alloc&quot; and &quot;perl_construct&quot;.
&quot;xsinit&quot; points to a callback function that will
be called to set up the ability for this Perl interpreter to
load <small>XS</small> extensions, or may be null to perform
no such setup.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;argc&quot;
and &quot;argv&quot; supply a set of command-line arguments
to the Perl interpreter, as would normally be passed to the
&quot;main&quot; function of a C program.
&quot;argv[argc]&quot; must be null. These arguments are
where the script to parse is specified, either by naming a
script file or by providing a script in a
&quot;&minus;e&quot; option. If $0 will be written to in the
Perl interpreter, then the argument strings must be in
writable memory, and so mustn&rsquo;t just be string
constants.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;env&quot;
specifies a set of environment variables that will be used
by this Perl interpreter. If non-null, it must point to a
null-terminated array of environment strings. If null, the
Perl interpreter will use the environment supplied by the
&quot;environ&quot; global variable.</p>

<p style="margin-left:17%; margin-top: 1em">This function
initialises the interpreter, and parses and compiles the
script specified by the command-line arguments. This
includes executing code in &quot;BEGIN&quot;,
&quot;UNITCHECK&quot;, and &quot;CHECK&quot; blocks. It does
not execute &quot;INIT&quot; blocks or the main program.</p>

<p style="margin-left:17%; margin-top: 1em">Returns an
integer of slightly tricky interpretation. The correct use
of the return value is as a truth value indicating whether
there was a failure in initialisation. If zero is returned,
this indicates that initialisation was successful, and it is
safe to proceed to call &quot;perl_run&quot; and make other
use of it. If a non-zero value is returned, this indicates
some problem that means the interpreter wants to terminate.
The interpreter should not be just abandoned upon such
failure; the caller should proceed to shut the interpreter
down cleanly with &quot;perl_destruct&quot; and free it with
&quot;perl_free&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">For historical
reasons, the non-zero return value also attempts to be a
suitable value to pass to the C library function
&quot;exit&quot; (or to return from &quot;main&quot;), to
serve as an exit code indicating the nature of the way
initialisation terminated. However, this isn&rsquo;t
portable, due to differing exit code conventions. A
historical bug is preserved for the time being: if the Perl
built-in &quot;exit&quot; is called during this
function&rsquo;s execution, with a type of exit entailing a
zero exit code under the host operating system&rsquo;s
conventions, then this function returns zero rather than a
non-zero value. This bug, [perl #2754], leads to
&quot;perl_run&quot; being called (and therefore
&quot;INIT&quot; blocks and the main program running)
despite a call to &quot;exit&quot;. It has been preserved
because a popular module-installing module has come to rely
on it and needs time to be fixed. This issue is [perl
#132577], and the original bug is due to be fixed in Perl
5.30.</p>

<p style="margin-left:17%; margin-top: 1em">int
perl_parse(PerlInterpreter *my_perl, XSINIT_t xsinit, <br>
int argc, char** argv, char** env)</p>

<p style="margin-left:11%;">&quot;perl_run&quot;</p>

<p style="margin-left:17%;">Tells a Perl interpreter to run
its main program. See perlembed for a tutorial.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;my_perl&quot;
points to the Perl interpreter. It must have been previously
created through the use of &quot;perl_alloc&quot; and
&quot;perl_construct&quot;, and initialised through
&quot;perl_parse&quot;. This function should not be called
if &quot;perl_parse&quot; returned a non-zero value,
indicating a failure in initialisation or compilation.</p>

<p style="margin-left:17%; margin-top: 1em">This function
executes code in &quot;INIT&quot; blocks, and then executes
the main program. The code to be executed is that
established by the prior call to &quot;perl_parse&quot;. If
the interpreter&rsquo;s &quot;PL_exit_flags&quot; word does
not have the &quot;PERL_EXIT_DESTRUCT_END&quot; flag set,
then this function will also execute code in &quot;END&quot;
blocks. If it is desired to make any further use of the
interpreter after calling this function, then
&quot;END&quot; blocks should be postponed to
&quot;perl_destruct&quot; time by setting that flag.</p>

<p style="margin-left:17%; margin-top: 1em">Returns an
integer of slightly tricky interpretation. The correct use
of the return value is as a truth value indicating whether
the program terminated non-locally. If zero is returned,
this indicates that the program ran to completion, and it is
safe to make other use of the interpreter (provided that the
&quot;PERL_EXIT_DESTRUCT_END&quot; flag was set as described
above). If a non-zero value is returned, this indicates that
the interpreter wants to terminate early. The interpreter
should not be just abandoned because of this desire to
terminate; the caller should proceed to shut the interpreter
down cleanly with &quot;perl_destruct&quot; and free it with
&quot;perl_free&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">For historical
reasons, the non-zero return value also attempts to be a
suitable value to pass to the C library function
&quot;exit&quot; (or to return from &quot;main&quot;), to
serve as an exit code indicating the nature of the way the
program terminated. However, this isn&rsquo;t portable, due
to differing exit code conventions. An attempt is made to
return an exit code of the type required by the host
operating system, but because it is constrained to be
non-zero, it is not necessarily possible to indicate every
type of exit. It is only reliable on Unix, where a zero exit
code can be augmented with a set bit that will be ignored.
In any case, this function is not the correct place to
acquire an exit code: one should get that from
&quot;perl_destruct&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
perl_run(PerlInterpreter *my_perl)</p>


<p style="margin-left:11%;">&quot;PERL_SET_CONTEXT&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
PERL_SET_CONTEXT(PerlInterpreter* i)</p>

<p style="margin-left:11%;">&quot;PERL_SYS_INIT&quot; <br>
&quot;PERL_SYS_INIT3&quot;</p>

<p style="margin-left:17%;">These provide system-specific
tune up of the C runtime environment necessary to run Perl
interpreters. Only one should be used, and it should be
called only once, before creating any Perl interpreters.</p>

<p style="margin-left:17%; margin-top: 1em">They differ in
that &quot;PERL_SYS_INIT3&quot; also initializes
&quot;env&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
PERL_SYS_INIT (int *argc, char*** argv) <br>
void PERL_SYS_INIT3(int *argc, char*** argv, char***
env)</p>

<p style="margin-left:11%;">&quot;PERL_SYS_TERM&quot;</p>

<p style="margin-left:17%;">Provides system-specific clean
up of the C runtime environment after running Perl
interpreters. This should be called only once, after freeing
any remaining Perl interpreters.</p>

<p style="margin-left:17%; margin-top: 1em">void
PERL_SYS_TERM()</p>

<p style="margin-left:11%;">&quot;PL_exit_flags&quot;</p>

<p style="margin-left:17%;">Contains flags controlling
perl&rsquo;s behaviour on <b>exit()</b>:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="37%">


<p>&quot;PERL_EXIT_DESTRUCT_END&quot;</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">If set,
<small>END</small> blocks are executed when the interpreter
is destroyed. This is normally set by perl itself after the
interpreter is constructed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p style="margin-top: 1em">&quot;PERL_EXIT_ABORT&quot;</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">Call
&quot;abort()&quot; on exit. This is used internally by perl
itself to abort if exit is called while processing exit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="25%">


<p style="margin-top: 1em">&quot;PERL_EXIT_WARN&quot;</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">Warn on
exit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="31%">



<p style="margin-top: 1em">&quot;PERL_EXIT_EXPECTED&quot;</p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">Set by the
&quot;exit&quot; in perlfunc operator.</p>

<p style="margin-left:17%; margin-top: 1em">U8
PL_exit_flags</p>

<p style="margin-left:11%;">&quot;PL_origalen&quot;</p>

<p style="margin-left:17%;">Described in perlembed.</p>


<p style="margin-left:11%;">&quot;PL_perl_destruct_level&quot;</p>

<p style="margin-left:17%;">This value may be set when
embedding for full cleanup.</p>

<p style="margin-left:17%; margin-top: 1em">Possible
values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p>0 &minus; none</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p>1 &minus; full</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p>2 or greater &minus; full with checks.</p></td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If
$ENV{PERL_DESTRUCT_LEVEL} is set to an integer greater than
the value of &quot;PL_perl_destruct_level&quot; its value is
used instead.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">signed char
PL_perl_destruct_level</p>

<p style="margin-left:11%;">&quot;require_pv&quot;</p>

<p style="margin-left:17%;">Tells Perl to
&quot;require&quot; the file named by the string argument.
It is analogous to the Perl code &quot;eval &quot;require
'$file'&quot;&quot;. It&rsquo;s even implemented that way;
consider using load_module instead.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_require_pv()&quot; form is
<b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">void
require_pv(const char* pv)</p>

<p style="margin-left:11%;">&quot;vload_module&quot;</p>

<p style="margin-left:17%;">Like &quot;load_module&quot;
but the arguments are an encapsulated argument list.</p>

<p style="margin-left:17%; margin-top: 1em">void
vload_module(U32 flags, SV* name, SV* ver, va_list*
args)</p>

<h2>Errno
<a name="Errno"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;sv_string_from_errnum&quot;</p>

<p style="margin-left:17%;">Generates the message string
describing an <small>OS</small> error and returns it as an
<small>SV.</small> &quot;errnum&quot; must be a value that
&quot;errno&quot; could take, identifying the type of
error.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;tgtsv&quot; is non-null then the string will be
written into that <small>SV</small> (overwriting existing
content) and it will be returned. If &quot;tgtsv&quot; is a
null pointer then the string will be written into a new
mortal <small>SV</small> which will be returned.</p>

<p style="margin-left:17%; margin-top: 1em">The message
will be taken from whatever locale would be used by $!, and
will be encoded in the <small>SV</small> in whatever manner
would be used by $!. The details of this process are subject
to future change. Currently, the message is taken from the C
locale by default (usually producing an English message),
and from the currently selected locale when in the scope of
the &quot;use locale&quot; pragma. A heuristic attempt is
made to decode the message from the locale&rsquo;s character
encoding, but it will only be decoded as either
<small>UTF&minus;8</small> or
<small>ISO&minus;8859&minus;1.</small> It is always
correctly decoded in a <small>UTF&minus;8</small> locale,
usually in an <small>ISO&minus;8859&minus;1</small> locale,
and never in any other locale.</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>SV</small> is always returned containing an actual
string, and with no other <small>OK</small> bits set. Unlike
$!, a message is even yielded for &quot;errnum&quot; zero
(meaning success), and if no useful message is available
then a useless string (currently empty) is returned.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_string_from_errnum(int errnum, SV* tgtsv)</p>

<h2>Exception Handling (simple) Macros
<a name="Exception Handling (simple) Macros"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;dXCPT&quot;</p>

<p style="margin-left:17%;">Set up necessary local
variables for exception handling. See &quot;Exception
Handling&quot; in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">dXCPT;</p>

<p style="margin-left:11%;">&quot;JMPENV_JUMP&quot;</p>

<p style="margin-left:17%;">Described in perlinterp.</p>

<p style="margin-left:17%; margin-top: 1em">void
JMPENV_JUMP(int v)</p>

<p style="margin-left:11%;">&quot;JMPENV_PUSH&quot;</p>

<p style="margin-left:17%;">Described in perlinterp.</p>

<p style="margin-left:17%; margin-top: 1em">void
JMPENV_PUSH(int v)</p>

<p style="margin-left:11%;">&quot;PL_restartop&quot;</p>

<p style="margin-left:17%;">Described in perlinterp.</p>

<p style="margin-left:11%;">&quot;XCPT_CATCH&quot;</p>

<p style="margin-left:17%;">Introduces a catch block. See
&quot;Exception Handling&quot; in perlguts.</p>

<p style="margin-left:11%;">&quot;XCPT_RETHROW&quot;</p>

<p style="margin-left:17%;">Rethrows a previously caught
exception. See &quot;Exception Handling&quot; in
perlguts.</p>


<p style="margin-left:17%; margin-top: 1em">XCPT_RETHROW;</p>

<p style="margin-left:11%;">&quot;XCPT_TRY_END&quot;</p>

<p style="margin-left:17%;">Ends a try block. See
&quot;Exception Handling&quot; in perlguts.</p>

<p style="margin-left:11%;">&quot;XCPT_TRY_START&quot;</p>

<p style="margin-left:17%;">Starts a try block. See
&quot;Exception Handling&quot; in perlguts.</p>

<h2>Filesystem configuration values
<a name="Filesystem configuration values"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Also see
&quot;List of capability HAS_foo symbols&quot;. <br>
&quot;DIRNAMLEN&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that the length of directory
entry names is provided by a &quot;d_namlen&quot; field.
Otherwise you need to do &quot;strlen()&quot; on the
&quot;d_name&quot; field.</p>

<p style="margin-left:11%;">&quot;DOSUID&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the C program should check the script that it
is executing for setuid/setgid bits, and attempt to emulate
setuid/setgid on systems that have disabled setuid #!
scripts because the kernel can&rsquo;t do it securely. It is
up to the package designer to make sure that this emulation
is done securely. Among other things, it should do an fstat
on the script it just opened to make sure it really is a
setuid/setgid script, it should make sure the arguments
passed correspond exactly to the argument on the #! line,
and it should not trust any subprocesses to which it must
pass the filename rather than the file descriptor of the
script to be executed.</p>

<p style="margin-left:11%;">&quot;EOF_NONBLOCK&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that a &quot;read()&quot; on a
non-blocking file descriptor will return 0 on
&quot;EOF&quot;, and not the value held in
&quot;RD_NODATA&quot; (&minus;1 usually, in that case!).</p>

<p style="margin-left:11%;">&quot;FCNTL_CAN_LOCK&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;fcntl()&quot; can be used for file
locking. Normally on Unix systems this is defined. It may be
undefined on &quot;VMS&quot;.</p>

<p style="margin-left:11%;">&quot;FFLUSH_ALL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, tells
that to flush all pending stdio output one must loop through
all the stdio file handles stored in an array and fflush
them. Note that if &quot;fflushNULL&quot; is defined,
fflushall will not even be probed for and will be left
undefined.</p>

<p style="margin-left:11%;">&quot;FFLUSH_NULL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, tells
that &quot;fflush(NULL)&quot; correctly flushes all pending
stdio output without side effects. In particular, on some
platforms calling &quot;fflush(NULL)&quot; *still* corrupts
&quot;STDIN&quot; if it is a pipe.</p>

<p style="margin-left:11%;">&quot;FILE_base&quot;</p>

<p style="margin-left:17%;">This macro is used to access
the &quot;_base&quot; field (or equivalent) of the
&quot;FILE&quot; structure pointed to by its argument. This
macro will always be defined if &quot;USE_STDIO_BASE&quot;
is defined.</p>

<p style="margin-left:17%; margin-top: 1em">void *
FILE_base(FILE * f)</p>

<p style="margin-left:11%;">&quot;FILE_bufsiz&quot;</p>

<p style="margin-left:17%;">This macro is used to determine
the number of bytes in the I/O buffer pointed to by
&quot;_base&quot; field (or equivalent) of the
&quot;FILE&quot; structure pointed to its argument. This
macro will always be defined if &quot;USE_STDIO_BASE&quot;
is defined.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
FILE_bufsiz(FILE *f)</p>

<p style="margin-left:11%;">&quot;FILE_cnt&quot;</p>

<p style="margin-left:17%;">This macro is used to access
the &quot;_cnt&quot; field (or equivalent) of the
&quot;FILE&quot; structure pointed to by its argument. This
macro will always be defined if &quot;USE_STDIO_PTR&quot; is
defined.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
FILE_cnt(FILE * f)</p>

<p style="margin-left:11%;">&quot;FILE_ptr&quot;</p>

<p style="margin-left:17%;">This macro is used to access
the &quot;_ptr&quot; field (or equivalent) of the
&quot;FILE&quot; structure pointed to by its argument. This
macro will always be defined if &quot;USE_STDIO_PTR&quot; is
defined.</p>

<p style="margin-left:17%; margin-top: 1em">void *
FILE_ptr(FILE * f)</p>

<p style="margin-left:11%;">&quot;FLEXFILENAMES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system supports filenames longer than 14
characters.</p>

<p style="margin-left:11%;">&quot;HAS_DIR_DD_FD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the the &quot;DIR&quot;* dirstream structure
contains a member variable named &quot;dd_fd&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_DUP2&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;dup2&quot; routine is available to
duplicate file descriptors.</p>

<p style="margin-left:11%;">&quot;HAS_DUP3&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;dup3&quot; routine is available to
duplicate file descriptors.</p>

<p style="margin-left:11%;">&quot;HAS_FAST_STDIO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fast stdio&quot; is available to
manipulate the stdio buffers directly.</p>

<p style="margin-left:11%;">&quot;HAS_FCHDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fchdir&quot; routine is available
to change directory using a file descriptor.</p>

<p style="margin-left:11%;">&quot;HAS_FCNTL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that the &quot;fcntl()&quot;
function exists.</p>

<p style="margin-left:11%;">&quot;HAS_FDCLOSE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fdclose&quot; routine is available
to free a &quot;FILE&quot; structure without closing the
underlying file descriptor. This function appeared in
&quot;FreeBSD&quot; 10.2.</p>

<p style="margin-left:11%;">&quot;HAS_FPATHCONF&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;pathconf()&quot; is available to
determine file-system related limits and options associated
with a given open file descriptor.</p>

<p style="margin-left:11%;">&quot;HAS_FPOS64_T&quot;</p>

<p style="margin-left:17%;">This symbol will be defined if
the C compiler supports &quot;fpos64_t&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_FSTATFS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fstatfs&quot; routine is available
to stat filesystems by file descriptors.</p>

<p style="margin-left:11%;">&quot;HAS_FSTATVFS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fstatvfs&quot; routine is available
to stat filesystems by file descriptors.</p>

<p style="margin-left:11%;">&quot;HAS_GETFSSTAT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;getfsstat&quot; routine is
available to stat filesystems in bulk.</p>

<p style="margin-left:11%;">&quot;HAS_GETMNT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;getmnt&quot; routine is available
to get filesystem mount info by filename.</p>

<p style="margin-left:11%;">&quot;HAS_GETMNTENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;getmntent&quot; routine is
available to iterate through mounted file systems to get
their info.</p>

<p style="margin-left:11%;">&quot;HAS_HASMNTOPT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;hasmntopt&quot; routine is
available to query the mount options of file systems.</p>


<p style="margin-left:11%;">&quot;HAS_LSEEK_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;lseek()&quot; function. Otherwise, it is up to the
program to supply one. A good guess is</p>

<p style="margin-left:17%; margin-top: 1em">extern off_t
lseek(int, off_t, int);</p>

<p style="margin-left:11%;">&quot;HAS_MKDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;mkdir&quot; routine is available to
create directories. Otherwise you should fork off a new
process to exec <i>/bin/mkdir</i>.</p>

<p style="margin-left:11%;">&quot;HAS_OFF64_T&quot;</p>

<p style="margin-left:17%;">This symbol will be defined if
the C compiler supports &quot;off64_t&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_OPEN3&quot;</p>

<p style="margin-left:17%;">This manifest constant lets the
C program know that the three argument form of open(2) is
available.</p>

<p style="margin-left:11%;">&quot;HAS_OPENAT&quot;</p>

<p style="margin-left:17%;">This symbol is defined if the
&quot;openat()&quot; routine is available.</p>

<p style="margin-left:11%;">&quot;HAS_POLL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;poll&quot; routine is available to
&quot;poll&quot; active file descriptors. Please check
&quot;I_POLL&quot; and &quot;I_SYS_POLL&quot; to know which
header should be included as well.</p>

<p style="margin-left:11%;">&quot;HAS_READDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;readdir&quot; routine is available
to read directory entries. You may have to include
<i>dirent.h</i>. See &quot;I_DIRENT&quot;.</p>


<p style="margin-left:11%;">&quot;HAS_READDIR64_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;readdir64_r&quot; routine is
available to readdir64 re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_REWINDDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;rewinddir&quot; routine is
available. You may have to include <i>dirent.h</i>. See
&quot;I_DIRENT&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_RMDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;rmdir&quot; routine is available to
remove directories. Otherwise you should fork off a new
process to exec <i>/bin/rmdir</i>.</p>

<p style="margin-left:11%;">&quot;HAS_SEEKDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;seekdir&quot; routine is available.
You may have to include <i>dirent.h</i>. See
&quot;I_DIRENT&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_SELECT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;select&quot; routine is available
to &quot;select&quot; active file descriptors. If the
timeout field is used, <i>sys/time.h</i> may need to be
included.</p>

<p style="margin-left:11%;">&quot;HAS_SETVBUF&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setvbuf&quot; routine is available
to change buffering on an open stdio stream. to a
line-buffered mode.</p>


<p style="margin-left:11%;">&quot;HAS_STDIO_STREAM_ARRAY&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, tells
that there is an array holding the stdio streams.</p>


<p style="margin-left:11%;">&quot;HAS_STRUCT_FS_DATA&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;struct fs_data&quot; to do
&quot;statfs()&quot; is supported.</p>


<p style="margin-left:11%;">&quot;HAS_STRUCT_STATFS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;struct statfs&quot; to do
&quot;statfs()&quot; is supported.</p>


<p style="margin-left:11%;">&quot;HAS_STRUCT_STATFS_F_FLAGS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;struct statfs&quot; does have the
&quot;f_flags&quot; member containing the mount flags of the
filesystem containing the file. This kind of &quot;struct
statfs&quot; is coming from <i>sys/mount.h</i>
(&quot;BSD&quot; 4.3), not from <i>sys/statfs.h</i>
(&quot;SYSV&quot;). Older &quot;BSDs&quot; (like Ultrix) do
not have &quot;statfs()&quot; and &quot;struct statfs&quot;,
they have &quot;ustat()&quot; and &quot;getmnt()&quot; with
&quot;struct ustat&quot; and &quot;struct fs_data&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_TELLDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;telldir&quot; routine is available.
You may have to include <i>dirent.h</i>. See
&quot;I_DIRENT&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_USTAT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;ustat&quot; system call is
available to query file system statistics by
&quot;dev_t&quot;.</p>

<p style="margin-left:11%;">&quot;I_FCNTL&quot;</p>

<p style="margin-left:17%;">This manifest constant tells
the C program to include <i>fcntl.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef I_FCNTL
<br>
#include &lt;fcntl.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_SYS_DIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>sys/dir.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_SYS_DIR <br>
#include &lt;sys_dir.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_SYS_FILE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>sys/file.h</i> to get definition of &quot;R_OK&quot; and
friends.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_SYS_FILE <br>
#include &lt;sys_file.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_SYS_NDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>sys/ndir.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_SYS_NDIR <br>
#include &lt;sys_ndir.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_SYS_STATFS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>sys/statfs.h</i> exists.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_SYS_STATFS <br>
#include &lt;sys_statfs.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;LSEEKSIZE&quot;</p>

<p style="margin-left:17%;">This symbol holds the number of
bytes used by the &quot;Off_t&quot;.</p>

<p style="margin-left:11%;">&quot;RD_NODATA&quot;</p>

<p style="margin-left:17%;">This symbol holds the return
code from &quot;read()&quot; when no data is present on the
non-blocking file descriptor. Be careful! If
&quot;EOF_NONBLOCK&quot; is not defined, then you
can&rsquo;t distinguish between no data and &quot;EOF&quot;
by issuing a &quot;read()&quot;. You&rsquo;ll have to find
another way to tell for sure!</p>


<p style="margin-left:11%;">&quot;READDIR64_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;readdir64_r&quot;. It is zero if
&quot;d_readdir64_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_readdir64_r&quot; is defined.</p>

<p style="margin-left:11%;">&quot;STDCHAR&quot;</p>

<p style="margin-left:17%;">This symbol is defined to be
the type of char used in <i>stdio.h</i>. It has the values
&quot;unsigned char&quot; or &quot;char&quot;.</p>


<p style="margin-left:11%;">&quot;STDIO_CNT_LVALUE&quot;</p>

<p style="margin-left:17%;">This symbol is defined if the
&quot;FILE_cnt&quot; macro can be used as an lvalue.</p>


<p style="margin-left:11%;">&quot;STDIO_PTR_LVALUE&quot;</p>

<p style="margin-left:17%;">This symbol is defined if the
&quot;FILE_ptr&quot; macro can be used as an lvalue.</p>


<p style="margin-left:11%;">&quot;STDIO_PTR_LVAL_NOCHANGE_CNT&quot;</p>

<p style="margin-left:17%;">This symbol is defined if using
the &quot;FILE_ptr&quot; macro as an lvalue to increase the
pointer by n leaves &quot;File_cnt(fp)&quot; unchanged.</p>


<p style="margin-left:11%;">&quot;STDIO_PTR_LVAL_SETS_CNT&quot;</p>

<p style="margin-left:17%;">This symbol is defined if using
the &quot;FILE_ptr&quot; macro as an lvalue to increase the
pointer by n has the side effect of decreasing the value of
&quot;File_cnt(fp)&quot; by n.</p>


<p style="margin-left:11%;">&quot;STDIO_STREAM_ARRAY&quot;</p>

<p style="margin-left:17%;">This symbol tells the name of
the array holding the stdio streams. Usual values include
&quot;_iob&quot;, &quot;__iob&quot;, and
&quot;__sF&quot;.</p>

<p style="margin-left:11%;">&quot;ST_INO_SIGN&quot;</p>

<p style="margin-left:17%;">This symbol holds the
signedness of &quot;struct stat&quot;&rsquo;s
&quot;st_ino&quot;. 1 for unsigned, &minus;1 for signed.</p>

<p style="margin-left:11%;">&quot;ST_INO_SIZE&quot;</p>

<p style="margin-left:17%;">This variable contains the size
of &quot;struct stat&quot;&rsquo;s &quot;st_ino&quot; in
bytes.</p>

<p style="margin-left:11%;">&quot;VAL_EAGAIN&quot;</p>

<p style="margin-left:17%;">This symbol holds the errno
error code set by &quot;read()&quot; when no data was
present on the non-blocking file descriptor.</p>

<p style="margin-left:11%;">&quot;VAL_O_NONBLOCK&quot;</p>

<p style="margin-left:17%;">This symbol is to be used
during &quot;open()&quot; or &quot;fcntl(F_SETFL)&quot; to
turn on non-blocking I/O for the file descriptor. Note that
there is no way back, i.e. you cannot turn it blocking again
this way. If you wish to alternatively switch between
blocking and non-blocking, use the
&quot;ioctl(FIOSNBIO)&quot; call instead, but that is not
supported by all devices.</p>

<p style="margin-left:11%;">&quot;VOID_CLOSEDIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;closedir()&quot; routine does not
return a value.</p>

<h2>Floating point
<a name="Floating point"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Also &quot;List
of capability HAS_foo symbols&quot; lists capabilities that
arent in this section. For example &quot;HAS_ASINH&quot;,
for the hyperbolic sine function. <br>
&quot;CASTFLAGS&quot;</p>

<p style="margin-left:17%;">This symbol contains flags that
say what difficulties the compiler has casting odd floating
values to unsigned long:</p>

<p style="margin-left:17%; margin-top: 1em">0 = ok <br>
1 = couldn't cast &lt; 0 <br>
2 = couldn't cast &gt;= 0x80000000 <br>
4 = couldn't cast in argument expression list</p>

<p style="margin-left:11%;">&quot;CASTNEGFLOAT&quot;</p>

<p style="margin-left:17%;">This symbol is defined if the C
compiler can cast negative numbers to unsigned longs, ints
and shorts.</p>

<p style="margin-left:11%;">&quot;DOUBLE_HAS_INF&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the double has the infinity.</p>

<p style="margin-left:11%;">&quot;DOUBLE_HAS_NAN&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the double has the not-a-number.</p>


<p style="margin-left:11%;">&quot;DOUBLE_HAS_NEGATIVE_ZERO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the double has the
&quot;negative_zero&quot;.</p>


<p style="margin-left:11%;">&quot;DOUBLE_HAS_SUBNORMALS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the double has the subnormals
(denormals).</p>

<p style="margin-left:11%;">&quot;DOUBLEINFBYTES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, is a
comma-separated list of hexadecimal bytes for the double
precision infinity.</p>

<p style="margin-left:11%;">&quot;DOUBLEKIND&quot;</p>

<p style="margin-left:17%;">&quot;DOUBLEKIND&quot; will be
one of &quot;DOUBLE_IS_IEEE_754_32_BIT_LITTLE_ENDIAN&quot;
&quot;DOUBLE_IS_IEEE_754_32_BIT_BIG_ENDIAN&quot;
&quot;DOUBLE_IS_IEEE_754_64_BIT_LITTLE_ENDIAN&quot;
&quot;DOUBLE_IS_IEEE_754_64_BIT_BIG_ENDIAN&quot;
&quot;DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN&quot;
&quot;DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN&quot;
&quot;DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_LE_BE&quot;
&quot;DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_BE_LE&quot;
&quot;DOUBLE_IS_VAX_F_FLOAT&quot;
&quot;DOUBLE_IS_VAX_D_FLOAT&quot;
&quot;DOUBLE_IS_VAX_G_FLOAT&quot;
&quot;DOUBLE_IS_IBM_SINGLE_32_BIT&quot;
&quot;DOUBLE_IS_IBM_DOUBLE_64_BIT&quot;
&quot;DOUBLE_IS_CRAY_SINGLE_64_BIT&quot;
&quot;DOUBLE_IS_UNKNOWN_FORMAT&quot;</p>

<p style="margin-left:11%;">&quot;DOUBLEMANTBITS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, tells
how many mantissa bits there are in double precision
floating point format. Note that this is usually
&quot;DBL_MANT_DIG&quot; minus one, since with the standard
&quot;IEEE&quot; 754 formats &quot;DBL_MANT_DIG&quot;
includes the implicit bit, which doesn&rsquo;t really
exist.</p>

<p style="margin-left:11%;">&quot;DOUBLENANBYTES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, is a
comma-separated list of hexadecimal bytes (0xHH) for the
double precision not-a-number.</p>

<p style="margin-left:11%;">&quot;DOUBLESIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the size
of a double, so that the C preprocessor can make decisions
based on it.</p>


<p style="margin-left:11%;">&quot;DOUBLE_STYLE_CRAY&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the double is the 64&minus;bit
&quot;CRAY&quot; mainframe format.</p>


<p style="margin-left:11%;">&quot;DOUBLE_STYLE_IBM&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the double is the 64&minus;bit
&quot;IBM&quot; mainframe format.</p>


<p style="margin-left:11%;">&quot;DOUBLE_STYLE_IEEE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the double is the 64&minus;bit
&quot;IEEE&quot; 754.</p>


<p style="margin-left:11%;">&quot;DOUBLE_STYLE_VAX&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the double is the 64&minus;bit
&quot;VAX&quot; format D or G.</p>

<p style="margin-left:11%;">&quot;HAS_ATOLF&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;atolf&quot; routine is available to
convert strings into long doubles.</p>

<p style="margin-left:11%;">&quot;HAS_CLASS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;class&quot; routine is available to
classify doubles. Available for example in &quot;AIX&quot;.
The returned values are defined in <i>float.h</i> and
are:</p>

<p style="margin-left:17%; margin-top: 1em">FP_PLUS_NORM
Positive normalized, nonzero <br>
FP_MINUS_NORM Negative normalized, nonzero <br>
FP_PLUS_DENORM Positive denormalized, nonzero <br>
FP_MINUS_DENORM Negative denormalized, nonzero <br>
FP_PLUS_ZERO +0.0 <br>
FP_MINUS_ZERO &minus;0.0 <br>
FP_PLUS_INF +INF <br>
FP_MINUS_INF &minus;INF <br>
FP_NANS Signaling Not a Number (NaNS) <br>
FP_NANQ Quiet Not a Number (NaNQ)</p>

<p style="margin-left:11%;">&quot;HAS_FINITE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;finite&quot; routine is available
to check whether a double is &quot;finite&quot;
(non-infinity non-NaN).</p>

<p style="margin-left:11%;">&quot;HAS_FINITEL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;finitel&quot; routine is available
to check whether a long double is finite (non-infinity
non-NaN).</p>

<p style="margin-left:11%;">&quot;HAS_FPCLASS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fpclass&quot; routine is available
to classify doubles. Available for example in
Solaris/&quot;SVR4&quot;. The returned values are defined in
<i>ieeefp.h</i> and are:</p>

<p style="margin-left:17%; margin-top: 1em">FP_SNAN
signaling NaN <br>
FP_QNAN quiet NaN <br>
FP_NINF negative infinity <br>
FP_PINF positive infinity <br>
FP_NDENORM negative denormalized non&minus;zero <br>
FP_PDENORM positive denormalized non&minus;zero <br>
FP_NZERO negative zero <br>
FP_PZERO positive zero <br>
FP_NNORM negative normalized non&minus;zero <br>
FP_PNORM positive normalized non&minus;zero</p>

<p style="margin-left:11%;">&quot;HAS_FPCLASSIFY&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fpclassify&quot; routine is
available to classify doubles. Available for example in
HP-UX. The returned values are defined in <i>math.h</i> and
are</p>

<p style="margin-left:17%; margin-top: 1em">FP_NORMAL
Normalized <br>
FP_ZERO Zero <br>
FP_INFINITE Infinity <br>
FP_SUBNORMAL Denormalized <br>
FP_NAN NaN</p>

<p style="margin-left:11%;">&quot;HAS_FPCLASSL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fpclassl&quot; routine is available
to classify long doubles. Available for example in
&quot;IRIX&quot;. The returned values are defined in
<i>ieeefp.h</i> and are:</p>

<p style="margin-left:17%; margin-top: 1em">FP_SNAN
signaling NaN <br>
FP_QNAN quiet NaN <br>
FP_NINF negative infinity <br>
FP_PINF positive infinity <br>
FP_NDENORM negative denormalized non&minus;zero <br>
FP_PDENORM positive denormalized non&minus;zero <br>
FP_NZERO negative zero <br>
FP_PZERO positive zero <br>
FP_NNORM negative normalized non&minus;zero <br>
FP_PNORM positive normalized non&minus;zero</p>

<p style="margin-left:11%;">&quot;HAS_FPGETROUND&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fpgetround&quot; routine is
available to get the floating point rounding mode.</p>

<p style="margin-left:11%;">&quot;HAS_FP_CLASS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fp_class&quot; routine is available
to classify doubles. Available for example in Digital
&quot;UNIX&quot;. The returned values are defined in
<i>math.h</i> and are:</p>

<p style="margin-left:17%; margin-top: 1em">FP_SNAN
Signaling NaN (Not&minus;a&minus;Number) <br>
FP_QNAN Quiet NaN (Not&minus;a&minus;Number) <br>
FP_POS_INF +infinity <br>
FP_NEG_INF &minus;infinity <br>
FP_POS_NORM Positive normalized <br>
FP_NEG_NORM Negative normalized <br>
FP_POS_DENORM Positive denormalized <br>
FP_NEG_DENORM Negative denormalized <br>
FP_POS_ZERO +0.0 (positive zero) <br>
FP_NEG_ZERO &minus;0.0 (negative zero)</p>


<p style="margin-left:11%;">&quot;HAS_FP_CLASSIFY&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fp_classify&quot; routine is
available to classify doubles. The values are defined in
<i>math.h</i></p>

<p style="margin-left:17%; margin-top: 1em">FP_NORMAL
Normalized <br>
FP_ZERO Zero <br>
FP_INFINITE Infinity <br>
FP_SUBNORMAL Denormalized <br>
FP_NAN NaN</p>

<p style="margin-left:11%;">&quot;HAS_FP_CLASSL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;fp_classl&quot; routine is
available to classify long doubles. Available for example in
Digital &quot;UNIX&quot;. See for possible values
&quot;HAS_FP_CLASS&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_FREXPL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;frexpl&quot; routine is available
to break a long double floating-point number into a
normalized fraction and an integral power of 2.</p>

<p style="margin-left:11%;">&quot;HAS_ILOGB&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;ilogb&quot; routine is available to
get integer exponent of a floating-point value.</p>

<p style="margin-left:11%;">&quot;HAS_ISFINITE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;isfinite&quot; routine is available
to check whether a double is finite (non-infinity
non-NaN).</p>

<p style="margin-left:11%;">&quot;HAS_ISFINITEL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;isfinitel&quot; routine is
available to check whether a long double is finite.
(non-infinity non-NaN).</p>

<p style="margin-left:11%;">&quot;HAS_ISINF&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;isinf&quot; routine is available to
check whether a double is an infinity.</p>

<p style="margin-left:11%;">&quot;HAS_ISINFL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;isinfl&quot; routine is available
to check whether a long double is an infinity.</p>

<p style="margin-left:11%;">&quot;HAS_ISNAN&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;isnan&quot; routine is available to
check whether a double is a NaN.</p>

<p style="margin-left:11%;">&quot;HAS_ISNANL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;isnanl&quot; routine is available
to check whether a long double is a NaN.</p>

<p style="margin-left:11%;">&quot;HAS_ISNORMAL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;isnormal&quot; routine is available
to check whether a double is normal (non-zero
normalized).</p>

<p style="margin-left:11%;">&quot;HAS_J0&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that the &quot;j0()&quot;
function is available for Bessel functions of the first kind
of the order zero, for doubles.</p>

<p style="margin-left:11%;">&quot;HAS_J0L&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that the &quot;j0l()&quot;
function is available for Bessel functions of the first kind
of the order zero, for long doubles.</p>

<p style="margin-left:11%;">&quot;HAS_LDBL_DIG&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that this system&rsquo;s <i>float.h</i> or
<i>limits.h</i> defines the symbol &quot;LDBL_DIG&quot;,
which is the number of significant digits in a long double
precision number. Unlike for &quot;DBL_DIG&quot;,
there&rsquo;s no good guess for &quot;LDBL_DIG&quot; if it
is undefined.</p>

<p style="margin-left:11%;">&quot;HAS_LDEXPL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;ldexpl&quot; routine is available
to shift a long double floating-point number by an integral
power of 2.</p>

<p style="margin-left:11%;">&quot;HAS_LLRINT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;llrint&quot; routine is available
to return the long long value closest to a double (according
to the current rounding mode).</p>

<p style="margin-left:11%;">&quot;HAS_LLRINTL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;llrintl&quot; routine is available
to return the long long value closest to a long double
(according to the current rounding mode).</p>

<p style="margin-left:11%;">&quot;HAS_LLROUNDL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;llroundl&quot; routine is available
to return the nearest long long value away from zero of the
long double argument value.</p>


<p style="margin-left:11%;">&quot;HAS_LONG_DOUBLE&quot;</p>

<p style="margin-left:17%;">This symbol will be defined if
the C compiler supports long doubles.</p>

<p style="margin-left:11%;">&quot;HAS_LRINT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;lrint&quot; routine is available to
return the integral value closest to a double (according to
the current rounding mode).</p>

<p style="margin-left:11%;">&quot;HAS_LRINTL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;lrintl&quot; routine is available
to return the integral value closest to a long double
(according to the current rounding mode).</p>

<p style="margin-left:11%;">&quot;HAS_LROUNDL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;lroundl&quot; routine is available
to return the nearest integral value away from zero of the
long double argument value.</p>

<p style="margin-left:11%;">&quot;HAS_MODFL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;modfl&quot; routine is available to
split a long double x into a fractional part f and an
integer part i such that |f| &lt; 1.0 and (f + i) = x.</p>

<p style="margin-left:11%;">&quot;HAS_NAN&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;nan&quot; routine is available to
generate NaN.</p>

<p style="margin-left:11%;">&quot;HAS_NEXTTOWARD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;nexttoward&quot; routine is
available to return the next machine representable long
double from x in direction y.</p>

<p style="margin-left:11%;">&quot;HAS_REMAINDER&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;remainder&quot; routine is
available to return the floating-point
&quot;remainder&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_SCALBN&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;scalbn&quot; routine is available
to multiply floating-point number by integral power of
radix.</p>

<p style="margin-left:11%;">&quot;HAS_SIGNBIT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;signbit&quot; routine is available
to check if the given number has the sign bit set. This
should include correct testing of &minus;0.0. This will only
be set if the &quot;signbit()&quot; routine is safe to use
with the <small>NV</small> type used internally in perl.
Users should call &quot;Perl_signbit()&quot;, which will be
#defined to the system&rsquo;s &quot;signbit()&quot;
function or macro if this symbol is defined.</p>

<p style="margin-left:11%;">&quot;HAS_SQRTL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;sqrtl&quot; routine is available to
do long double square roots.</p>

<p style="margin-left:11%;">&quot;HAS_STRTOD_L&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;strtod_l&quot; routine is available
to convert strings to long doubles.</p>

<p style="margin-left:11%;">&quot;HAS_STRTOLD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;strtold&quot; routine is available
to convert strings to long doubles.</p>

<p style="margin-left:11%;">&quot;HAS_STRTOLD_L&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;strtold_l&quot; routine is
available to convert strings to long doubles.</p>

<p style="margin-left:11%;">&quot;HAS_TRUNC&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;trunc&quot; routine is available to
round doubles towards zero.</p>

<p style="margin-left:11%;">&quot;HAS_UNORDERED&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;unordered&quot; routine is
available to check whether two doubles are
&quot;unordered&quot; (effectively: whether either of them
is NaN)</p>

<p style="margin-left:11%;">&quot;I_FENV&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>fenv.h</i> to get the floating point environment
definitions.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef I_FENV
<br>
#include &lt;fenv.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_QUADMATH&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>quadmath.h</i> exists and should be
included.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_QUADMATH <br>
#include &lt;quadmath.h&gt; <br>
#endif</p>


<p style="margin-left:11%;">&quot;LONGDBLINFBYTES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, is a
comma-separated list of hexadecimal bytes for the long
double precision infinity.</p>


<p style="margin-left:11%;">&quot;LONGDBLMANTBITS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, tells
how many mantissa bits there are in long double precision
floating point format. Note that this can be
&quot;LDBL_MANT_DIG&quot; minus one, since
&quot;LDBL_MANT_DIG&quot; can include the &quot;IEEE&quot;
754 implicit bit. The common x86&minus;style 80&minus;bit
long double does not have an implicit bit.</p>


<p style="margin-left:11%;">&quot;LONGDBLNANBYTES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, is a
comma-separated list of hexadecimal bytes (0xHH) for the
long double precision not-a-number.</p>


<p style="margin-left:11%;">&quot;LONG_DOUBLEKIND&quot;</p>

<p style="margin-left:17%;">&quot;LONG_DOUBLEKIND&quot;
will be one of &quot;LONG_DOUBLE_IS_DOUBLE&quot;
&quot;LONG_DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN&quot;
&quot;LONG_DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN&quot;
&quot;LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN&quot;
&quot;LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN&quot;
&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE&quot;
&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE&quot;
&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE&quot;
&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE&quot;
&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LITTLE_ENDIAN&quot;
&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BIG_ENDIAN&quot;
&quot;LONG_DOUBLE_IS_VAX_H_FLOAT&quot;
&quot;LONG_DOUBLE_IS_UNKNOWN_FORMAT&quot; It is only defined
if the system supports long doubles.</p>


<p style="margin-left:11%;">&quot;LONG_DOUBLESIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the size
of a long double, so that the C preprocessor can make
decisions based on it. It is only defined if the system
supports long doubles. Note that this is &quot;sizeof(long
double)&quot;, which may include unused bytes.</p>


<p style="margin-left:11%;">&quot;LONG_DOUBLE_STYLE_IEEE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the long double is any of the
&quot;IEEE&quot; 754 style long doubles:
&quot;LONG_DOUBLE_STYLE_IEEE_STD&quot;,
&quot;LONG_DOUBLE_STYLE_IEEE_EXTENDED&quot;,
&quot;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&quot;.</p>


<p style="margin-left:11%;">&quot;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the long double is the 128&minus;bit
double-double.</p>


<p style="margin-left:11%;">&quot;LONG_DOUBLE_STYLE_IEEE_EXTENDED&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the long double is the 80&minus;bit
&quot;IEEE&quot; 754. Note that despite the
&rsquo;extended&rsquo; this is less than the
&rsquo;std&rsquo;, since this is an extension of the double
precision.</p>


<p style="margin-left:11%;">&quot;LONG_DOUBLE_STYLE_IEEE_STD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the long double is the 128&minus;bit
&quot;IEEE&quot; 754.</p>


<p style="margin-left:11%;">&quot;LONG_DOUBLE_STYLE_VAX&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the long double is the 128&minus;bit
&quot;VAX&quot; format H.</p>

<p style="margin-left:11%;">&quot;NV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;NVMANTBITS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, tells
how many mantissa bits (not including implicit bit) there
are in a Perl <small>NV.</small> This depends on which
floating point type was chosen.</p>


<p style="margin-left:11%;">&quot;NV_OVERFLOWS_INTEGERS_AT&quot;</p>

<p style="margin-left:17%;">This symbol gives the largest
integer value that NVs can hold. This value + 1.0 cannot be
stored accurately. It is expressed as constant floating
point expression to reduce the chance of decimal/binary
conversion issues. If it can not be determined, the value 0
is given.</p>


<p style="margin-left:11%;">&quot;NV_PRESERVES_UV&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that a variable of type &quot;NVTYPE&quot; can
preserve all the bits of a variable of type
&quot;UVTYPE&quot;.</p>


<p style="margin-left:11%;">&quot;NV_PRESERVES_UV_BITS&quot;</p>

<p style="margin-left:17%;">This symbol contains the number
of bits a variable of type &quot;NVTYPE&quot; can preserve
of a variable of type &quot;UVTYPE&quot;.</p>

<p style="margin-left:11%;">&quot;NVSIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(NV)&quot;. Note that some floating point
formats have unused bytes. The most notable example is the
x86* 80&minus;bit extended precision which comes in byte
sizes of 12 and 16 (for 32 and 64 bit platforms,
respectively), but which only uses 10 bytes. Perl compiled
with &quot;&minus;Duselongdouble&quot; on x86* is like
this.</p>

<p style="margin-left:11%;">&quot;NVTYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s <small>NV.</small></p>


<p style="margin-left:11%;">&quot;NV_ZERO_IS_ALLBITS_ZERO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that a variable of type &quot;NVTYPE&quot; stores
0.0 in memory as all bits zero.</p>

<h2>General Configuration
<a name="General Configuration"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
contains configuration information not otherwise found in
the more specialized sections of this document. At the end
is a list of &quot;#defines&quot; whose name should be
enough to tell you what they do, and a list of #defines
which tell you if you need to &quot;#include&quot; files to
get the corresponding functionality. <br>
&quot;BYTEORDER&quot;</p>

<p style="margin-left:17%;">This symbol holds the
hexadecimal constant defined in byteorder, in a
<small>UV,</small> i.e. 0x1234 or 0x4321 or 0x12345678,
etc... If the compiler supports cross-compiling or
multiple-architecture binaries, use compiler-defined macros
to determine the byte order.</p>

<p style="margin-left:11%;">&quot;CHARBITS&quot;</p>

<p style="margin-left:17%;">This symbol contains the size
of a char, so that the C preprocessor can make decisions
based on it.</p>


<p style="margin-left:11%;">&quot;DB_VERSION_MAJOR_CFG&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
defines the major version number of Berkeley
<small>DB</small> found in the <i>db.h</i> header when Perl
was configured.</p>


<p style="margin-left:11%;">&quot;DB_VERSION_MINOR_CFG&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
defines the minor version number of Berkeley
<small>DB</small> found in the <i>db.h</i> header when Perl
was configured. For <small>DB</small> version 1 this is
always 0.</p>


<p style="margin-left:11%;">&quot;DB_VERSION_PATCH_CFG&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
defines the patch version number of Berkeley
<small>DB</small> found in the <i>db.h</i> header when Perl
was configured. For <small>DB</small> version 1 this is
always 0.</p>


<p style="margin-left:11%;">&quot;DEFAULT_INC_EXCLUDES_DOT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
removes the legacy default behavior of including
&rsquo;.&rsquo; at the end of @&quot;INC&quot;.</p>


<p style="margin-left:11%;">&quot;DLSYM_NEEDS_UNDERSCORE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that we need to prepend an underscore to the
symbol name before calling &quot;dlsym()&quot;. This only
makes sense if you *have* dlsym, which we will presume is
the case if you&rsquo;re using <i>dl_dlopen.xs</i>.</p>

<p style="margin-left:11%;">&quot;EBCDIC&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that this system uses &quot;EBCDIC&quot;
encoding.</p>

<p style="margin-left:11%;">&quot;HAS_CSH&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the C&minus;shell exists.</p>


<p style="margin-left:11%;">&quot;HAS_GETHOSTNAME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the C program may use the
&quot;gethostname()&quot; routine to derive the host name.
See also &quot;HAS_UNAME&quot; and
&quot;PHOSTNAME&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_GNULIBC&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that the &quot;GNU&quot; C
library is being used. A better check is to use the
&quot;__GLIBC__&quot; and &quot;__GLIBC_MINOR__&quot;
symbols supplied with glibc.</p>

<p style="margin-left:11%;">&quot;HAS_LGAMMA&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;lgamma&quot; routine is available
to do the log gamma function. See also
&quot;HAS_TGAMMA&quot; and &quot;HAS_LGAMMA_R&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_LGAMMA_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;lgamma_r&quot; routine is available
to do the log gamma function without using the global
signgam variable.</p>


<p style="margin-left:11%;">&quot;HAS_NON_INT_BITFIELDS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the C compiler accepts, without error or
warning, &quot;struct bitfields&quot; that are declared with
sizes other than plain &rsquo;int&rsquo;; for example
&rsquo;unsigned char&rsquo; is accepted.</p>


<p style="margin-left:11%;">&quot;HAS_PRCTL_SET_NAME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the prctl routine is available to set process
title and supports &quot;PR_SET_NAME&quot;.</p>


<p style="margin-left:11%;">&quot;HAS_PROCSELFEXE&quot;</p>

<p style="margin-left:17%;">This symbol is defined if
&quot;PROCSELFEXE_PATH&quot; is a symlink to the absolute
pathname of the executing program.</p>

<p style="margin-left:11%;">&quot;HAS_PSEUDOFORK&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that an emulation of the fork routine is
available.</p>

<p style="margin-left:11%;">&quot;HAS_REGCOMP&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;regcomp()&quot; routine is
available to do some regular pattern matching (usually on
&quot;POSIX&quot;.2 conforming systems).</p>

<p style="margin-left:11%;">&quot;HAS_SETPGID&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setpgid(pid, gpid)&quot; routine is
available to set process group <small>ID.</small></p>

<p style="margin-left:11%;">&quot;HAS_SIGSETJMP&quot;</p>

<p style="margin-left:17%;">This variable indicates to the
C program that the &quot;sigsetjmp()&quot; routine is
available to save the calling process&rsquo;s registers and
stack environment for later use by &quot;siglongjmp()&quot;,
and to optionally save the process&rsquo;s signal mask. See
&quot;Sigjmp_buf&quot;, &quot;Sigsetjmp&quot;, and
&quot;Siglongjmp&quot;.</p>


<p style="margin-left:11%;">&quot;HAS_STRUCT_CMSGHDR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;struct cmsghdr&quot; is
supported.</p>


<p style="margin-left:11%;">&quot;HAS_STRUCT_MSGHDR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;struct msghdr&quot; is
supported.</p>

<p style="margin-left:11%;">&quot;HAS_TGAMMA&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;tgamma&quot; routine is available
to do the gamma function. See also
&quot;HAS_LGAMMA&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_UNAME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the C program may use the &quot;uname()&quot;
routine to derive the host name. See also
&quot;HAS_GETHOSTNAME&quot; and &quot;PHOSTNAME&quot;.</p>


<p style="margin-left:11%;">&quot;HAS_UNION_SEMUN&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;union semun&quot; is defined by
including <i>sys/sem.h</i>. If not, the user code probably
needs to define it as:</p>

<p style="margin-left:17%; margin-top: 1em">union semun {
<br>
int val; <br>
struct semid_ds *buf; <br>
unsigned short *array; <br>
}</p>

<p style="margin-left:11%;">&quot;I_DIRENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>dirent.h</i>. Using this symbol also triggers the
definition of the &quot;Direntry_t&quot; define which ends
up being &rsquo;&quot;struct dirent&quot;&rsquo; or
&rsquo;&quot;struct direct&quot;&rsquo; depending on the
availability of <i>dirent.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef I_DIRENT
<br>
#include &lt;dirent.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_POLL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>poll.h</i> exists and should be included.
(see also &quot;HAS_POLL&quot;)</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef I_POLL
<br>
#include &lt;poll.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_SYS_RESOURCE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>sys/resource.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_SYS_RESOURCE <br>
#include &lt;sys_resource.h&gt; <br>
#endif</p>


<p style="margin-left:11%;">&quot;LIBM_LIB_VERSION&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that libm exports &quot;_LIB_VERSION&quot; and
that <i>math.h</i> defines the enum to manipulate it.</p>

<p style="margin-left:11%;">&quot;NEED_VA_COPY&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system stores the variable argument list
datatype, &quot;va_list&quot;, in a format that cannot be
copied by simple assignment, so that some other means must
be used when copying is required. As such systems vary in
their provision (or non-provision) of copying mechanisms,
<i>handy.h</i> defines a platform&minus; independent macro,
&quot;Perl_va_copy(src, dst)&quot;, to do the job.</p>

<p style="margin-left:11%;">&quot;OSNAME&quot;</p>

<p style="margin-left:17%;">This symbol contains the name
of the operating system, as determined by Configure. You
shouldn&rsquo;t rely on it too much; the specific feature
tests from Configure are generally more reliable.</p>

<p style="margin-left:11%;">&quot;OSVERS&quot;</p>

<p style="margin-left:17%;">This symbol contains the
version of the operating system, as determined by Configure.
You shouldn&rsquo;t rely on it too much; the specific
feature tests from Configure are generally more
reliable.</p>

<p style="margin-left:11%;">&quot;PHOSTNAME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates the command to feed to the &quot;popen()&quot;
routine to derive the host name. See also
&quot;HAS_GETHOSTNAME&quot; and &quot;HAS_UNAME&quot;. Note
that the command uses a fully qualified path, so that it is
safe even if used by a process with super-user
privileges.</p>


<p style="margin-left:11%;">&quot;PROCSELFEXE_PATH&quot;</p>

<p style="margin-left:17%;">If &quot;HAS_PROCSELFEXE&quot;
is defined this symbol is the filename of the symbolic link
pointing to the absolute pathname of the executing
program.</p>

<p style="margin-left:11%;">&quot;PTRSIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the size
of a pointer, so that the C preprocessor can make decisions
based on it. It will be &quot;sizeof(void *)&quot; if the
compiler supports (void *); otherwise it will be
&quot;sizeof(char *)&quot;.</p>

<p style="margin-left:11%;">&quot;RANDBITS&quot;</p>

<p style="margin-left:17%;">This symbol indicates how many
bits are produced by the function used to generate
normalized random numbers. Values include 15, 16, 31, and
48.</p>


<p style="margin-left:11%;">&quot;SELECT_MIN_BITS&quot;</p>

<p style="margin-left:17%;">This symbol holds the minimum
number of bits operated by select. That is, if you do
&quot;select(n, ...)&quot;, how many bits at least will be
cleared in the masks if some activity is detected. Usually
this is either n or 32*&quot;ceil(n/32)&quot;, especially
many little-endians do the latter. This is only useful if
you have &quot;select()&quot;, naturally.</p>


<p style="margin-left:11%;">&quot;SETUID_SCRIPTS_ARE_SECURE_NOW&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the bug that prevents setuid scripts from
being secure is not present in this kernel.</p>

<p style="margin-left:11%;">&quot;ST_DEV_SIGN&quot;</p>

<p style="margin-left:17%;">This symbol holds the
signedness of &quot;struct stat&quot;&rsquo;s
&quot;st_dev&quot;. 1 for unsigned, &minus;1 for signed.</p>

<p style="margin-left:11%;">&quot;ST_DEV_SIZE&quot;</p>

<p style="margin-left:17%;">This variable contains the size
of &quot;struct stat&quot;&rsquo;s &quot;st_dev&quot; in
bytes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>List of
capability &quot;HAS_</b><i>foo</i><b>&quot; symbols</b>
<br>
This is a list of those symbols that dont appear elsewhere
in ths document that indicate if the current platform has a
certain capability. Their names all begin with
&quot;HAS_&quot;. Only those symbols whose capability is
directly derived from the name are listed here. All others
have their meaning expanded out elsewhere in this document.
This (relatively) compact list is because we think that the
expansion would add little or no value and take up a lot of
space (because there are so many). If you think certain ones
should be expanded, send email to
perl5&minus;porters@perl.org
&lt;mailto:perl5-porters@perl.org&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Each symbol
here will be &quot;#define&quot;d if and only if the
platform has the capability. If you need more detail, see
the corresponding entry in <i>config.h</i>. For convenience,
the list is split so that the ones that indicate there is a
reentrant version of a capability are listed separately</p>


<p style="margin-left:11%; margin-top: 1em">&quot;HAS_ACCEPT4&quot;,&nbsp;
&quot;HAS_ACCESS&quot;,&nbsp; &quot;HAS_ACCESSX&quot;,&nbsp;
&quot;HAS_ACOSH&quot;,&nbsp; &quot;HAS_AINTL&quot;,&nbsp;
&quot;HAS_ALARM&quot;,&nbsp; &quot;HAS_ASINH&quot;,&nbsp;
&quot;HAS_ATANH&quot;,&nbsp; &quot;HAS_ATOLL&quot;,&nbsp;
&quot;HAS_CBRT&quot;,&nbsp; &quot;HAS_CHOWN&quot;,&nbsp;
&quot;HAS_CHROOT&quot;,&nbsp; &quot;HAS_CHSIZE&quot;,&nbsp;
&quot;HAS_CLEARENV&quot;,&nbsp;
&quot;HAS_COPYSIGN&quot;,&nbsp;
&quot;HAS_COPYSIGNL&quot;,&nbsp;
&quot;HAS_CRYPT&quot;,&nbsp; &quot;HAS_CTERMID&quot;,&nbsp;
&quot;HAS_CUSERID&quot;,&nbsp; &quot;HAS_DIRFD&quot;,&nbsp;
&quot;HAS_DLADDR&quot;,&nbsp; &quot;HAS_DLERROR&quot;,&nbsp;
&quot;HAS_EACCESS&quot;,&nbsp;
&quot;HAS_ENDHOSTENT&quot;,&nbsp;
&quot;HAS_ENDNETENT&quot;,&nbsp;
&quot;HAS_ENDPROTOENT&quot;,&nbsp;
&quot;HAS_ENDSERVENT&quot;,&nbsp; &quot;HAS_ERF&quot;,&nbsp;
&quot;HAS_ERFC&quot;,&nbsp; &quot;HAS_EXP2&quot;,&nbsp;
&quot;HAS_EXPM1&quot;,&nbsp; &quot;HAS_FCHMOD&quot;,&nbsp;
&quot;HAS_FCHMODAT&quot;,&nbsp;
&quot;HAS_FCHOWN&quot;,&nbsp; &quot;HAS_FDIM&quot;,&nbsp;
&quot;HAS_FD_SET&quot;,&nbsp;
&quot;HAS_FEGETROUND&quot;,&nbsp; &quot;HAS_FFS&quot;,&nbsp;
&quot;HAS_FFSL&quot;,&nbsp; &quot;HAS_FGETPOS&quot;,&nbsp;
&quot;HAS_FLOCK&quot;,&nbsp; &quot;HAS_FMA&quot;,&nbsp;
&quot;HAS_FMAX&quot;,&nbsp; &quot;HAS_FMIN&quot;,&nbsp;
&quot;HAS_FORK&quot;,&nbsp; &quot;HAS_FSEEKO&quot;,&nbsp;
&quot;HAS_FSETPOS&quot;,&nbsp; &quot;HAS_FSYNC&quot;,&nbsp;
&quot;HAS_FTELLO&quot;,&nbsp;
&quot;HAS_GAI_STRERROR&quot;,&nbsp;
&quot;HAS_GETADDRINFO&quot;,&nbsp;
&quot;HAS_GETCWD&quot;,&nbsp;
&quot;HAS_GETESPWNAM&quot;,&nbsp;
&quot;HAS_GETGROUPS&quot;,&nbsp;
&quot;HAS_GETHOSTBYADDR&quot;,&nbsp;
&quot;HAS_GETHOSTBYNAME&quot;,&nbsp;
&quot;HAS_GETHOSTENT&quot;,&nbsp;
&quot;HAS_GETLOGIN&quot;,&nbsp;
&quot;HAS_GETNAMEINFO&quot;,&nbsp;
&quot;HAS_GETNETBYADDR&quot;,&nbsp;
&quot;HAS_GETNETBYNAME&quot;,&nbsp;
&quot;HAS_GETNETENT&quot;,&nbsp;
&quot;HAS_GETPAGESIZE&quot;,&nbsp;
&quot;HAS_GETPGID&quot;,&nbsp;
&quot;HAS_GETPGRP&quot;,&nbsp;
&quot;HAS_GETPGRP2&quot;,&nbsp;
&quot;HAS_GETPPID&quot;,&nbsp;
&quot;HAS_GETPRIORITY&quot;,&nbsp;
&quot;HAS_GETPROTOBYNAME&quot;,&nbsp;
&quot;HAS_GETPROTOBYNUMBER&quot;,&nbsp;
&quot;HAS_GETPROTOENT&quot;,&nbsp;
&quot;HAS_GETPRPWNAM&quot;,&nbsp;
&quot;HAS_GETSERVBYNAME&quot;,&nbsp;
&quot;HAS_GETSERVBYPORT&quot;,&nbsp;
&quot;HAS_GETSERVENT&quot;,&nbsp;
&quot;HAS_GETSPNAM&quot;,&nbsp; &quot;HAS_HTONL&quot;,&nbsp;
&quot;HAS_HTONS&quot;,&nbsp; &quot;HAS_HYPOT&quot;,&nbsp;
&quot;HAS_ILOGBL&quot;,&nbsp;
&quot;HAS_INETNTOP&quot;,&nbsp;
&quot;HAS_INETPTON&quot;,&nbsp;
&quot;HAS_INET_ATON&quot;,&nbsp;
&quot;HAS_IPV6_MREQ&quot;,&nbsp;
&quot;HAS_IPV6_MREQ_SOURCE&quot;,&nbsp;
&quot;HAS_IP_MREQ&quot;,&nbsp;
&quot;HAS_IP_MREQ_SOURCE&quot;,&nbsp;
&quot;HAS_ISASCII&quot;,&nbsp;
&quot;HAS_ISBLANK&quot;,&nbsp; &quot;HAS_ISLESS&quot;,&nbsp;
&quot;HAS_KILLPG&quot;,&nbsp; &quot;HAS_LCHOWN&quot;,&nbsp;
&quot;HAS_LINK&quot;,&nbsp; &quot;HAS_LINKAT&quot;,&nbsp;
&quot;HAS_LLROUND&quot;,&nbsp; &quot;HAS_LOCKF&quot;,&nbsp;
&quot;HAS_LOG1P&quot;,&nbsp; &quot;HAS_LOG2&quot;,&nbsp;
&quot;HAS_LOGB&quot;,&nbsp; &quot;HAS_LROUND&quot;,&nbsp;
&quot;HAS_LSTAT&quot;,&nbsp; &quot;HAS_MADVISE&quot;,&nbsp;
&quot;HAS_MBLEN&quot;,&nbsp; &quot;HAS_MBRLEN&quot;,&nbsp;
&quot;HAS_MBRTOWC&quot;,&nbsp;
&quot;HAS_MBSTOWCS&quot;,&nbsp;
&quot;HAS_MBTOWC&quot;,&nbsp; &quot;HAS_MEMMEM&quot;,&nbsp;
&quot;HAS_MEMRCHR&quot;,&nbsp;
&quot;HAS_MKDTEMP&quot;,&nbsp; &quot;HAS_MKFIFO&quot;,&nbsp;
&quot;HAS_MKOSTEMP&quot;,&nbsp;
&quot;HAS_MKSTEMP&quot;,&nbsp;
&quot;HAS_MKSTEMPS&quot;,&nbsp; &quot;HAS_MMAP&quot;,&nbsp;
&quot;HAS_MPROTECT&quot;,&nbsp; &quot;HAS_MSG&quot;,&nbsp;
&quot;HAS_MSYNC&quot;,&nbsp; &quot;HAS_MUNMAP&quot;,&nbsp;
&quot;HAS_NEARBYINT&quot;,&nbsp;
&quot;HAS_NEXTAFTER&quot;,&nbsp; &quot;HAS_NICE&quot;,&nbsp;
&quot;HAS_NTOHL&quot;,&nbsp; &quot;HAS_NTOHS&quot;,&nbsp;
&quot;HAS_PATHCONF&quot;,&nbsp; &quot;HAS_PAUSE&quot;,&nbsp;
&quot;HAS_PHOSTNAME&quot;,&nbsp; &quot;HAS_PIPE&quot;,&nbsp;
&quot;HAS_PIPE2&quot;,&nbsp; &quot;HAS_PRCTL&quot;,&nbsp;
&quot;HAS_PTRDIFF_T&quot;,&nbsp;
&quot;HAS_READLINK&quot;,&nbsp; &quot;HAS_READV&quot;,&nbsp;
&quot;HAS_RECVMSG&quot;,&nbsp; &quot;HAS_REMQUO&quot;,&nbsp;
&quot;HAS_RENAME&quot;,&nbsp;
&quot;HAS_RENAMEAT&quot;,&nbsp; &quot;HAS_RINT&quot;,&nbsp;
&quot;HAS_ROUND&quot;,&nbsp; &quot;HAS_SCALBNL&quot;,&nbsp;
&quot;HAS_SEM&quot;,&nbsp; &quot;HAS_SENDMSG&quot;,&nbsp;
&quot;HAS_SETEGID&quot;,&nbsp;
&quot;HAS_SETEUID&quot;,&nbsp;
&quot;HAS_SETGROUPS&quot;,&nbsp;
&quot;HAS_SETHOSTENT&quot;,&nbsp;
&quot;HAS_SETLINEBUF&quot;,&nbsp;
&quot;HAS_SETNETENT&quot;,&nbsp;
&quot;HAS_SETPGRP&quot;,&nbsp;
&quot;HAS_SETPGRP2&quot;,&nbsp;
&quot;HAS_SETPRIORITY&quot;,&nbsp;
&quot;HAS_SETPROCTITLE&quot;,&nbsp;
&quot;HAS_SETPROTOENT&quot;,&nbsp;
&quot;HAS_SETREGID&quot;,&nbsp;
&quot;HAS_SETRESGID&quot;,&nbsp;
&quot;HAS_SETRESUID&quot;,&nbsp;
&quot;HAS_SETREUID&quot;,&nbsp;
&quot;HAS_SETRGID&quot;,&nbsp;
&quot;HAS_SETRUID&quot;,&nbsp;
&quot;HAS_SETSERVENT&quot;,&nbsp;
&quot;HAS_SETSID&quot;,&nbsp; &quot;HAS_SHM&quot;,&nbsp;
&quot;HAS_SIGACTION&quot;,&nbsp;
&quot;HAS_SIGPROCMASK&quot;,&nbsp;
&quot;HAS_SIN6_SCOPE_ID&quot;,&nbsp;
&quot;HAS_SNPRINTF&quot;,&nbsp; &quot;HAS_STAT&quot;,&nbsp;
&quot;HAS_STRCOLL&quot;,&nbsp;
&quot;HAS_STRERROR_L&quot;,&nbsp;
&quot;HAS_STRLCAT&quot;,&nbsp;
&quot;HAS_STRLCPY&quot;,&nbsp;
&quot;HAS_STRNLEN&quot;,&nbsp; &quot;HAS_STRTOD&quot;,&nbsp;
&quot;HAS_STRTOL&quot;,&nbsp; &quot;HAS_STRTOLL&quot;,&nbsp;
&quot;HAS_STRTOQ&quot;,&nbsp; &quot;HAS_STRTOUL&quot;,&nbsp;
&quot;HAS_STRTOULL&quot;,&nbsp;
&quot;HAS_STRTOUQ&quot;,&nbsp;
&quot;HAS_STRXFRM&quot;,&nbsp;
&quot;HAS_STRXFRM_L&quot;,&nbsp;
&quot;HAS_SYMLINK&quot;,&nbsp;
&quot;HAS_SYSCALL&quot;,&nbsp;
&quot;HAS_SYSCONF&quot;,&nbsp; &quot;HAS_SYSTEM&quot;,&nbsp;
&quot;HAS_SYS_ERRLIST&quot;,&nbsp;
&quot;HAS_TCGETPGRP&quot;,&nbsp;
&quot;HAS_TCSETPGRP&quot;,&nbsp;
&quot;HAS_TOWLOWER&quot;,&nbsp;
&quot;HAS_TOWUPPER&quot;,&nbsp;
&quot;HAS_TRUNCATE&quot;,&nbsp;
&quot;HAS_TRUNCL&quot;,&nbsp; &quot;HAS_UALARM&quot;,&nbsp;
&quot;HAS_UMASK&quot;,&nbsp; &quot;HAS_UNLINKAT&quot;,&nbsp;
&quot;HAS_UNSETENV&quot;,&nbsp; &quot;HAS_VFORK&quot;,&nbsp;
&quot;HAS_VSNPRINTF&quot;,&nbsp;
&quot;HAS_WAIT4&quot;,&nbsp; &quot;HAS_WAITPID&quot;,&nbsp;
&quot;HAS_WCRTOMB&quot;,&nbsp; &quot;HAS_WCSCMP&quot;,&nbsp;
&quot;HAS_WCSTOMBS&quot;,&nbsp;
&quot;HAS_WCSXFRM&quot;,&nbsp; &quot;HAS_WCTOMB&quot;,&nbsp;
&quot;HAS_WRITEV&quot;,&nbsp; &quot;HAS__FWALK&quot;</p>

<p style="margin-left:11%; margin-top: 1em">And, the
reentrant capabilities:</p>


<p style="margin-left:11%; margin-top: 1em">&quot;HAS_CRYPT_R&quot;,&nbsp;
&quot;HAS_CTERMID_R&quot;,&nbsp;
&quot;HAS_DRAND48_R&quot;,&nbsp;
&quot;HAS_ENDHOSTENT_R&quot;,&nbsp;
&quot;HAS_ENDNETENT_R&quot;,&nbsp;
&quot;HAS_ENDPROTOENT_R&quot;,&nbsp;
&quot;HAS_ENDSERVENT_R&quot;,&nbsp;
&quot;HAS_GETGRGID_R&quot;,&nbsp;
&quot;HAS_GETGRNAM_R&quot;,&nbsp;
&quot;HAS_GETHOSTBYADDR_R&quot;,&nbsp;
&quot;HAS_GETHOSTBYNAME_R&quot;,&nbsp;
&quot;HAS_GETHOSTENT_R&quot;,&nbsp;
&quot;HAS_GETLOGIN_R&quot;,&nbsp;
&quot;HAS_GETNETBYADDR_R&quot;,&nbsp;
&quot;HAS_GETNETBYNAME_R&quot;,&nbsp;
&quot;HAS_GETNETENT_R&quot;,&nbsp;
&quot;HAS_GETPROTOBYNAME_R&quot;,&nbsp;
&quot;HAS_GETPROTOBYNUMBER_R&quot;,&nbsp;
&quot;HAS_GETPROTOENT_R&quot;,&nbsp;
&quot;HAS_GETPWNAM_R&quot;,&nbsp;
&quot;HAS_GETPWUID_R&quot;,&nbsp;
&quot;HAS_GETSERVBYNAME_R&quot;,&nbsp;
&quot;HAS_GETSERVBYPORT_R&quot;,&nbsp;
&quot;HAS_GETSERVENT_R&quot;,&nbsp;
&quot;HAS_GETSPNAM_R&quot;,&nbsp;
&quot;HAS_RANDOM_R&quot;,&nbsp;
&quot;HAS_READDIR_R&quot;,&nbsp;
&quot;HAS_SETHOSTENT_R&quot;,&nbsp;
&quot;HAS_SETNETENT_R&quot;,&nbsp;
&quot;HAS_SETPROTOENT_R&quot;,&nbsp;
&quot;HAS_SETSERVENT_R&quot;,&nbsp;
&quot;HAS_SRAND48_R&quot;,&nbsp;
&quot;HAS_SRANDOM_R&quot;,&nbsp;
&quot;HAS_STRERROR_R&quot;,&nbsp;
&quot;HAS_TMPNAM_R&quot;,&nbsp;
&quot;HAS_TTYNAME_R&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Example
usage:</p>

<p style="margin-left:11%; margin-top: 1em">#ifdef
HAS_STRNLEN <br>
use strnlen() <br>
#else <br>
use an alternative implementation <br>
#endif</p>

<p style="margin-left:11%; margin-top: 1em"><b>List of
&quot;#include&quot; needed symbols</b> <br>
This list contains symbols that indicate if certain
&quot;#include&quot; files are present on the platform. If
your code accesses the functionality that one of these is
for, you will need to &quot;#include&quot; it if the symbol
on this list is &quot;#define&quot;d. For more detail, see
the corresponding entry in <i>config.h</i>.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;I_ARPA_INET&quot;,&nbsp;
&quot;I_BFD&quot;,&nbsp; &quot;I_CRYPT&quot;,&nbsp;
&quot;I_DBM&quot;,&nbsp; &quot;I_DLFCN&quot;,&nbsp;
&quot;I_EXECINFO&quot;,&nbsp; &quot;I_FP&quot;,&nbsp;
&quot;I_FP_CLASS&quot;,&nbsp; &quot;I_GDBM&quot;,&nbsp;
&quot;I_GDBMNDBM&quot;,&nbsp; &quot;I_GDBM_NDBM&quot;,&nbsp;
&quot;I_GRP&quot;,&nbsp; &quot;I_IEEEFP&quot;,&nbsp;
&quot;I_INTTYPES&quot;,&nbsp; &quot;I_LIBUTIL&quot;,&nbsp;
&quot;I_MNTENT&quot;,&nbsp; &quot;I_NDBM&quot;,&nbsp;
&quot;I_NETDB&quot;,&nbsp; &quot;I_NETINET_IN&quot;,&nbsp;
&quot;I_NETINET_TCP&quot;,&nbsp;
&quot;I_NET_ERRNO&quot;,&nbsp; &quot;I_PROT&quot;,&nbsp;
&quot;I_PWD&quot;,&nbsp; &quot;I_RPCSVC_DBM&quot;,&nbsp;
&quot;I_SGTTY&quot;,&nbsp; &quot;I_SHADOW&quot;,&nbsp;
&quot;I_STDBOOL&quot;,&nbsp; &quot;I_STDINT&quot;,&nbsp;
&quot;I_SUNMATH&quot;,&nbsp; &quot;I_SYSLOG&quot;,&nbsp;
&quot;I_SYSMODE&quot;,&nbsp; &quot;I_SYSUIO&quot;,&nbsp;
&quot;I_SYSUTSNAME&quot;,&nbsp;
&quot;I_SYS_ACCESS&quot;,&nbsp;
&quot;I_SYS_IOCTL&quot;,&nbsp;
&quot;I_SYS_MOUNT&quot;,&nbsp;
&quot;I_SYS_PARAM&quot;,&nbsp; &quot;I_SYS_POLL&quot;,&nbsp;
&quot;I_SYS_SECURITY&quot;,&nbsp;
&quot;I_SYS_SELECT&quot;,&nbsp;
&quot;I_SYS_STAT&quot;,&nbsp;
&quot;I_SYS_STATVFS&quot;,&nbsp;
&quot;I_SYS_TIME&quot;,&nbsp; &quot;I_SYS_TIMES&quot;,&nbsp;
&quot;I_SYS_TIME_KERNEL&quot;,&nbsp;
&quot;I_SYS_TYPES&quot;,&nbsp; &quot;I_SYS_UN&quot;,&nbsp;
&quot;I_SYS_VFS&quot;,&nbsp; &quot;I_SYS_WAIT&quot;,&nbsp;
&quot;I_TERMIO&quot;,&nbsp; &quot;I_TERMIOS&quot;,&nbsp;
&quot;I_UNISTD&quot;,&nbsp; &quot;I_USTAT&quot;,&nbsp;
&quot;I_VFORK&quot;,&nbsp; &quot;I_WCHAR&quot;,&nbsp;
&quot;I_WCTYPE&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Example
usage:</p>

<p style="margin-left:11%; margin-top: 1em">#ifdef I_WCHAR
<br>
#include &lt;wchar.h&gt; <br>
#endif</p>

<h2>Global Variables
<a name="Global Variables"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These variables
are global to an entire process. They are shared between all
interpreters and all threads in a process. Any variables not
documented here may be changed or removed without notice, so
don&rsquo;t use them! If you feel you really do need to use
an unlisted variable, first send email to
perl5&minus;porters@perl.org
&lt;mailto:perl5-porters@perl.org&gt;. It may be that
someone there will point out a way to accomplish what you
need without using an internal variable. But if not, you
should get a go-ahead to document and then use the variable.
<br>
&quot;PL_check&quot;</p>

<p style="margin-left:17%;">Array, indexed by opcode, of
functions that will be called for the &quot;check&quot;
phase of optree building during compilation of Perl code.
For most (but not all) types of op, once the op has been
initially built and populated with child ops it will be
filtered through the check function referenced by the
appropriate element of this array. The new op is passed in
as the sole argument to the check function, and the check
function returns the completed op. The check function may
(as the name suggests) check the op for validity and signal
errors. It may also initialise or modify parts of the ops,
or perform more radical surgery such as adding or removing
child ops, or even throw the op away and return a different
op in its place.</p>

<p style="margin-left:17%; margin-top: 1em">This array of
function pointers is a convenient place to hook into the
compilation process. An <small>XS</small> module can put its
own custom check function in place of any of the standard
ones, to influence the compilation of a particular type of
op. However, a custom check function must never fully
replace a standard check function (or even a custom check
function from another module). A module modifying checking
must instead <b>wrap</b> the preexisting check function. A
custom check function must be selective about when to apply
its custom behaviour. In the usual case where it decides not
to do anything special with an op, it must chain the
preexisting op function. Check functions are thus linked in
a chain, with the core&rsquo;s base checker at the end.</p>

<p style="margin-left:17%; margin-top: 1em">For thread
safety, modules should not write directly to this array.
Instead, use the function &quot;wrap_op_checker&quot;.</p>


<p style="margin-left:11%;">&quot;PL_keyword_plugin&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PL_keyword_plugin&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Function
pointer, pointing at a function used to handle extended
keywords. The function should be declared as</p>

<p style="margin-left:17%; margin-top: 1em">int
keyword_plugin_function(pTHX_ <br>
char *keyword_ptr, STRLEN keyword_len, <br>
OP **op_ptr)</p>

<p style="margin-left:17%; margin-top: 1em">The function is
called from the tokeniser, whenever a possible keyword is
seen. &quot;keyword_ptr&quot; points at the word in the
parser&rsquo;s input buffer, and &quot;keyword_len&quot;
gives its length; it is not null-terminated. The function is
expected to examine the word, and possibly other state such
as %^H, to decide whether it wants to handle it as an
extended keyword. If it does not, the function should return
&quot;KEYWORD_PLUGIN_DECLINE&quot;, and the normal parser
process will continue.</p>

<p style="margin-left:17%; margin-top: 1em">If the function
wants to handle the keyword, it first must parse anything
following the keyword that is part of the syntax introduced
by the keyword. See &quot;Lexer interface&quot; for
details.</p>

<p style="margin-left:17%; margin-top: 1em">When a keyword
is being handled, the plugin function must build a tree of
&quot;OP&quot; structures, representing the code that was
parsed. The root of the tree must be stored in *op_ptr. The
function then returns a constant indicating the syntactic
role of the construct that it has parsed:
&quot;KEYWORD_PLUGIN_STMT&quot; if it is a complete
statement, or &quot;KEYWORD_PLUGIN_EXPR&quot; if it is an
expression. Note that a statement construct cannot be used
inside an expression (except via &quot;do BLOCK&quot; and
similar), and an expression is not a complete statement (it
requires at least a terminating semicolon).</p>

<p style="margin-left:17%; margin-top: 1em">When a keyword
is handled, the plugin function may also have (compile-time)
side effects. It may modify &quot;%^H&quot;, define
functions, and so on. Typically, if side effects are the
main purpose of a handler, it does not wish to generate any
ops to be included in the normal compilation. In this case
it is still required to supply an op tree, but it suffices
to generate a single null op.</p>

<p style="margin-left:17%; margin-top: 1em">That&rsquo;s
how the *PL_keyword_plugin function needs to behave overall.
Conventionally, however, one does not completely replace the
existing handler function. Instead, take a copy of
&quot;PL_keyword_plugin&quot; before assigning your own
function pointer to it. Your handler function should look
for keywords that it is interested in and handle those.
Where it is not interested, it should call the saved plugin
function, passing on the arguments it received. Thus
&quot;PL_keyword_plugin&quot; actually points at a chain of
handler functions, all of which have an opportunity to
handle keywords, and only the last function in the chain
(built into the Perl core) will normally return
&quot;KEYWORD_PLUGIN_DECLINE&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">For thread
safety, modules should not set this variable directly.
Instead, use the function
&quot;wrap_keyword_plugin&quot;.</p>

<p style="margin-left:11%;">&quot;PL_phase&quot;</p>

<p style="margin-left:17%;">A value that indicates the
current Perl interpreter&rsquo;s phase. Possible values
include &quot;PERL_PHASE_CONSTRUCT&quot;,
&quot;PERL_PHASE_START&quot;, &quot;PERL_PHASE_CHECK&quot;,
&quot;PERL_PHASE_INIT&quot;, &quot;PERL_PHASE_RUN&quot;,
&quot;PERL_PHASE_END&quot;, and
&quot;PERL_PHASE_DESTRUCT&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">For example,
the following determines whether the interpreter is in
global destruction:</p>

<p style="margin-left:17%; margin-top: 1em">if (PL_phase ==
PERL_PHASE_DESTRUCT) { <br>
// we are in global destruction <br>
}</p>


<p style="margin-left:17%; margin-top: 1em">&quot;PL_phase&quot;
was introduced in Perl 5.14; in prior perls you can use
&quot;PL_dirty&quot; (boolean) to determine whether the
interpreter is in global destruction. (Use of
&quot;PL_dirty&quot; is discouraged since 5.14.)</p>

<p style="margin-left:17%; margin-top: 1em">enum perl_phase
PL_phase</p>

<h2>GV Handling and Stashes
<a name="GV Handling and Stashes"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A
<small>GV</small> is a structure which corresponds to to a
Perl typeglob, ie *foo. It is a structure that holds a
pointer to a scalar, an array, a hash etc, corresponding to
$foo, @foo, %foo.</p>

<p style="margin-left:11%; margin-top: 1em">GVs are usually
found as values in stashes (symbol table hashes) where Perl
stores its global variables.</p>

<p style="margin-left:11%; margin-top: 1em">A <b>stash</b>
is a hash that contains all variables that are defined
within a package. See &quot;Stashes and Globs&quot; in
perlguts <br>
&quot;amagic_call&quot;</p>

<p style="margin-left:17%;">Perform the overloaded (active
magic) operation given by &quot;method&quot;.
&quot;method&quot; is one of the values found in
<i>overload.h</i>.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;flags&quot;
affects how the operation is performed, as follows: <br>
&quot;AMGf_noleft&quot;</p>

<p style="margin-left:23%;">&quot;left&quot; is not to be
used in this operation.</p>

<p style="margin-left:17%;">&quot;AMGf_noright&quot;</p>

<p style="margin-left:23%;">&quot;right&quot; is not to be
used in this operation.</p>

<p style="margin-left:17%;">&quot;AMGf_unary&quot;</p>

<p style="margin-left:23%;">The operation is done only on
just one operand.</p>

<p style="margin-left:17%;">&quot;AMGf_assign&quot;</p>

<p style="margin-left:23%;">The operation changes one of
the operands, e.g., $x += 1</p>

<p style="margin-left:17%; margin-top: 1em">SV*
amagic_call(SV* left, SV* right, int method, int dir)</p>


<p style="margin-left:11%;">&quot;amagic_deref_call&quot;</p>

<p style="margin-left:17%;">Perform &quot;method&quot;
overloading dereferencing on &quot;ref&quot;, returning the
dereferenced result. &quot;method&quot; must be one of the
dereference operations given in <i>overload.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If overloading
is inactive on &quot;ref&quot;, returns &quot;ref&quot;
itself.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
amagic_deref_call(SV *ref, int method)</p>

<p style="margin-left:11%;">&quot;gv_add_by_type&quot;</p>

<p style="margin-left:17%;">Make sure there is a slot of
type &quot;type&quot; in the <small>GV</small>
&quot;gv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_add_by_type(GV *gv, svtype type)</p>

<p style="margin-left:11%;">&quot;Gv_AMupdate&quot;</p>

<p style="margin-left:17%;">Recalculates overload magic in
the package given by &quot;stash&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Returns: <br>
1 on success and there is some overload <br>
0 if there is no overload <br>
&minus;1 if some error occurred and it couldn&rsquo;t croak
(because <br>
&quot;destructing&quot; is true).</p>

<p style="margin-left:17%; margin-top: 1em">int
Gv_AMupdate(HV* stash, bool destructing)</p>

<p style="margin-left:11%;">&quot;gv_autoload4&quot;</p>

<p style="margin-left:17%;">Equivalent to
&quot;gv_autoload_pvn&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_autoload4(HV* stash, const char* name, STRLEN len, <br>
I32 method)</p>

<p style="margin-left:11%;">&quot;GvAV&quot;</p>

<p style="margin-left:17%;">Return the <small>AV</small>
from the <small>GV.</small></p>

<p style="margin-left:17%; margin-top: 1em">AV* GvAV(GV*
gv)</p>

<p style="margin-left:11%;">&quot;gv_AVadd&quot; <br>
&quot;gv_HVadd&quot; <br>
&quot;gv_IOadd&quot; <br>
&quot;gv_SVadd&quot;</p>

<p style="margin-left:17%;">Make sure there is a slot of
the given type ( <small>AV, HV, IO, SV</small> ) in the
<small>GV</small> &quot;gv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">GV* gv_AVadd(GV
*gv) <br>
GV* gv_HVadd(GV *gv) <br>
GV* gv_IOadd(GV* gv) <br>
GV* gv_SVadd(GV *gv)</p>

<p style="margin-left:11%;">&quot;gv_const_sv&quot;</p>

<p style="margin-left:17%;">If &quot;gv&quot; is a typeglob
whose subroutine entry is a constant sub eligible for
inlining, or &quot;gv&quot; is a placeholder reference that
would be promoted to such a typeglob, then returns the value
returned by the sub. Otherwise, returns
&quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
gv_const_sv(GV* gv)</p>

<p style="margin-left:11%;">&quot;GvCV&quot;</p>

<p style="margin-left:17%;">Return the <small>CV</small>
from the <small>GV.</small></p>

<p style="margin-left:17%; margin-top: 1em">CV* GvCV(GV*
gv)</p>

<p style="margin-left:11%;">&quot;gv_fetchfile&quot; <br>
&quot;gv_fetchfile_flags&quot;</p>

<p style="margin-left:17%;">These return the debugger glob
for the file (compiled by Perl) whose name is given by the
&quot;name&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">There are
currently exactly two differences between these
functions.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;name&quot; parameter to &quot;gv_fetchfile&quot; is a
C string, meaning it is &quot;NUL&quot;&minus;terminated;
whereas the &quot;name&quot; parameter to
&quot;gv_fetchfile_flags&quot; is a Perl string, whose
length (in bytes) is passed in via the &quot;namelen&quot;
parameter This means the name may contain embedded
&quot;NUL&quot; characters. &quot;namelen&quot;
doesn&rsquo;t exist in plain &quot;gv_fetchfile&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">The other
difference is that &quot;gv_fetchfile_flags&quot; has an
extra &quot;flags&quot; parameter, which is currently
completely ignored, but allows for possible future
extensions.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchfile (const char* name) <br>
GV* gv_fetchfile_flags(const char *const name, const STRLEN
len, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;gv_fetchmeth&quot;</p>

<p style="margin-left:17%;">Like
&quot;gv_fetchmeth_pvn&quot;, but lacks a flags
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmeth(HV* stash, const char* name, STRLEN len, <br>
I32 level)</p>

<p style="margin-left:11%;">&quot;gv_fetchmethod&quot;</p>

<p style="margin-left:17%;">See
&quot;gv_fetchmethod_autoload&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmethod(HV* stash, const char* name)</p>


<p style="margin-left:11%;">&quot;gv_fetchmethod_autoload&quot;</p>

<p style="margin-left:17%;">Returns the glob which contains
the subroutine to call to invoke the method on the
&quot;stash&quot;. In fact in the presence of autoloading
this may be the glob for &quot;
<small>AUTOLOAD&quot;.</small> In this case the
corresponding variable $AUTOLOAD is already setup.</p>

<p style="margin-left:17%; margin-top: 1em">The third
parameter of &quot;gv_fetchmethod_autoload&quot; determines
whether <small>AUTOLOAD</small> lookup is performed if the
given method is not present: non-zero means yes, look for
<small>AUTOLOAD</small> ; zero means no, don&rsquo;t look
for <small>AUTOLOAD.</small> Calling
&quot;gv_fetchmethod&quot; is equivalent to calling
&quot;gv_fetchmethod_autoload&quot; with a non-zero
&quot;autoload&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">These functions
grant &quot;SUPER&quot; token as a prefix of the method
name. Note that if you want to keep the returned glob for a
long time, you need to check for it being &quot;
<small>AUTOLOAD&quot;,</small> since at the later time the
call may load a different subroutine due to $AUTOLOAD
changing its value. Use the glob created as a side effect to
do this.</p>

<p style="margin-left:17%; margin-top: 1em">These functions
have the same side-effects as &quot;gv_fetchmeth&quot; with
&quot;level==0&quot;. The warning against passing the
<small>GV</small> returned by &quot;gv_fetchmeth&quot; to
&quot;call_sv&quot; applies equally to these functions.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmethod_autoload(HV* stash, const char* name, <br>
I32 autoload)</p>


<p style="margin-left:11%;">&quot;gv_fetchmeth_autoload&quot;</p>

<p style="margin-left:17%;">This is the old form of
&quot;gv_fetchmeth_pvn_autoload&quot;, which has no flags
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmeth_autoload(HV* stash, const char* name, <br>
STRLEN len, I32 level)</p>


<p style="margin-left:11%;">&quot;gv_fetchmeth_pv&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;gv_fetchmeth_pvn&quot;, but takes a nul-terminated
string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmeth_pv(HV* stash, const char* name, I32 level, <br>
U32 flags)</p>


<p style="margin-left:11%;">&quot;gv_fetchmeth_pvn&quot;</p>

<p style="margin-left:17%;">Returns the glob with the given
&quot;name&quot; and a defined subroutine or
&quot;NULL&quot;. The glob lives in the given
&quot;stash&quot;, or in the stashes accessible via @ISA and
&quot;UNIVERSAL::&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The argument
&quot;level&quot; should be either 0 or &minus;1. If
&quot;level==0&quot;, as a side-effect creates a glob with
the given &quot;name&quot; in the given &quot;stash&quot;
which in the case of success contains an alias for the
subroutine, and sets up caching info for this glob.</p>

<p style="margin-left:17%; margin-top: 1em">The only
significant values for &quot;flags&quot; are
&quot;GV_SUPER&quot;, &quot;GV_NOUNIVERSAL&quot;, and
&quot;SVf_UTF8&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;GV_SUPER&quot;
indicates that we want to look up the method in the
superclasses of the &quot;stash&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;GV_NOUNIVERSAL&quot;
indicates that we do not want to look up the method in the
stash accessible by &quot;UNIVERSAL::&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>GV</small> returned from &quot;gv_fetchmeth&quot; may
be a method cache entry, which is not visible to Perl code.
So when calling &quot;call_sv&quot;, you should not use the
<small>GV</small> directly; instead, you should use the
method&rsquo;s <small>CV,</small> which can be obtained from
the <small>GV</small> with the &quot;GvCV&quot; macro.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmeth_pvn(HV* stash, const char* name, STRLEN len,
<br>
I32 level, U32 flags)</p>


<p style="margin-left:11%;">&quot;gv_fetchmeth_pvn_autoload&quot;</p>

<p style="margin-left:17%;">Same as
&quot;gv_fetchmeth_pvn()&quot;, but looks for autoloaded
subroutines too. Returns a glob for the subroutine.</p>

<p style="margin-left:17%; margin-top: 1em">For an
autoloaded subroutine without a <small>GV,</small> will
create a <small>GV</small> even if &quot;level &lt; 0&quot;.
For an autoloaded subroutine without a stub,
&quot;GvCV()&quot; of the result may be zero.</p>

<p style="margin-left:17%; margin-top: 1em">Currently, the
only significant value for &quot;flags&quot; is
&quot;SVf_UTF8&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmeth_pvn_autoload(HV* stash, const char* name, <br>
STRLEN len, I32 level, U32 flags)</p>


<p style="margin-left:11%;">&quot;gv_fetchmeth_pv_autoload&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;gv_fetchmeth_pvn_autoload&quot;, but takes a
nul-terminated string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmeth_pv_autoload(HV* stash, const char* name, <br>
I32 level, U32 flags)</p>


<p style="margin-left:11%;">&quot;gv_fetchmeth_sv&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;gv_fetchmeth_pvn&quot;, but takes the name string in
the form of an <small>SV</small> instead of a string/length
pair.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmeth_sv(HV* stash, SV* namesv, I32 level, U32
flags)</p>


<p style="margin-left:11%;">&quot;gv_fetchmeth_sv_autoload&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;gv_fetchmeth_pvn_autoload&quot;, but takes the name
string in the form of an <small>SV</small> instead of a
string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">GV*
gv_fetchmeth_sv_autoload(HV* stash, SV* namesv, I32 level,
<br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;gv_fetchpv&quot; <br>
&quot;gv_fetchpvn&quot; <br>
&quot;gv_fetchpvn_flags&quot; <br>
&quot;gv_fetchpvs&quot; <br>
&quot;gv_fetchsv&quot; <br>
&quot;gv_fetchsv_nomg&quot;</p>

<p style="margin-left:17%;">These all return the
<small>GV</small> of type &quot;sv_type&quot; whose name is
given by the inputs, or <small>NULL</small> if no
<small>GV</small> of that name and type could be found. See
&quot;Stashes and Globs&quot; in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">The only
differences are how the input name is specified, and if
&rsquo;get&rsquo; magic is normally used in getting that
name.</p>

<p style="margin-left:17%; margin-top: 1em">Don&rsquo;t be
fooled by the fact that only one form has &quot;flags&quot;
in its name. They all have a &quot;flags&quot; parameter in
fact, and all the flag bits have the same meanings for
all</p>

<p style="margin-left:17%; margin-top: 1em">If any of the
flags &quot;GV_ADD&quot;, &quot;GV_ADDMG&quot;,
&quot;GV_ADDWARN&quot;, &quot;GV_ADDMULTI&quot;, or
&quot;GV_NOINIT&quot; is set, a <small>GV</small> is created
if none already exists for the input name and type. However,
&quot;GV_ADDMG&quot; will only do the creation for magical
<small>GV</small> &rsquo;s. For all of these flags except
&quot;GV_NOINIT&quot;, &quot;gv_init_pvn&quot; is called
after the addition. &quot;GV_ADDWARN&quot; is used when the
caller expects that adding won&rsquo;t be necessary because
the symbol should already exist; but if not, add it anyway,
with a warning that it was unexpectedly absent. The
&quot;GV_ADDMULTI&quot; flag means to pretend that the
<small>GV</small> has been seen before (<i>i.e.</i>,
suppress &quot;Used once&quot; warnings).</p>

<p style="margin-left:17%; margin-top: 1em">The flag
&quot;GV_NOADD_NOINIT&quot; causes &quot;gv_init_pvn&quot;
not be to called if the <small>GV</small> existed but
isn&rsquo;t <small>PVGV.</small></p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;SVf_UTF8&quot; bit is set, the name is treated as
being encoded in <small>UTF&minus;8</small> ; otherwise the
name won&rsquo;t be considered to be
<small>UTF&minus;8</small> in the &quot;pv&quot;&minus;named
forms, and the UTF&minus;8ness of the underlying SVs will be
used in the &quot;sv&quot; forms.</p>

<p style="margin-left:17%; margin-top: 1em">If the flag
&quot;GV_NOTQUAL&quot; is set, the caller warrants that the
input name is a plain symbol name, not qualified with a
package, otherwise the name is checked for being a qualified
one.</p>

<p style="margin-left:17%; margin-top: 1em">In
&quot;gv_fetchpv&quot;, &quot;nambeg&quot; is a C string,
NUL-terminated with no intermediate NULs.</p>

<p style="margin-left:17%; margin-top: 1em">In
&quot;gv_fetchpvs&quot;, &quot;name&quot; is a literal C
string, hence is enclosed in double quotes.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;gv_fetchpvn&quot;
and &quot;gv_fetchpvn_flags&quot; are identical. In these,
&lt;nambeg&gt; is a Perl string whose byte length is given
by &quot;full_len&quot;, and may contain embedded NULs.</p>

<p style="margin-left:17%; margin-top: 1em">In
&quot;gv_fetchsv&quot; and &quot;gv_fetchsv_nomg&quot;, the
name is extracted from the <small>PV</small> of the input
&quot;name&quot; <small>SV.</small> The only difference
between these two forms is that &rsquo;get&rsquo; magic is
normally done on &quot;name&quot; in &quot;gv_fetchsv&quot;,
and always skipped with &quot;gv_fetchsv_nomg&quot;.
Including &quot;GV_NO_SVGMAGIC&quot; in the
&quot;flags&quot; parameter to &quot;gv_fetchsv&quot; makes
it behave identically to &quot;gv_fetchsv_nomg&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">GV* gv_fetchpv
(const char *nambeg, I32 flags, <br>
const svtype sv_type) <br>
GV * gv_fetchpvn (const char * nambeg, STRLEN full_len, <br>
I32 flags, const svtype sv_type) <br>
GV* gv_fetchpvn_flags(const char* name, STRLEN len, I32
flags, <br>
const svtype sv_type) <br>
GV * gv_fetchpvs (&quot;name&quot;, I32 flags, const svtype
sv_type) <br>
GV* gv_fetchsv (SV *name, I32 flags, const svtype sv_type)
<br>
GV * gv_fetchsv_nomg (SV *name, I32 flags, const svtype
sv_type)</p>

<p style="margin-left:11%;">&quot;gv_fullname3&quot; <br>
&quot;gv_fullname4&quot; <br>
&quot;gv_efullname3&quot; <br>
&quot;gv_efullname4&quot;</p>

<p style="margin-left:17%;">Place the full package name of
&quot;gv&quot; into &quot;sv&quot;. The &quot;gv_e*&quot;
forms return instead the effective package name (see
&quot;HvENAME&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;prefix&quot; is non-NULL, it is considered to be a C
language NUL-terminated string, and the stored name will be
prefaced with it.</p>

<p style="margin-left:17%; margin-top: 1em">The other
difference between the functions is that the *4 forms have
an extra parameter, &quot;keepmain&quot;. If
&quot;true&quot; an initial &quot;main::&quot; in the name
is kept; if &quot;false&quot; it is stripped. With the *3
forms, it is always kept.</p>

<p style="margin-left:17%; margin-top: 1em">void
gv_fullname3 (SV* sv, const GV* gv, const char* prefix) <br>
void gv_fullname4 (SV* sv, const GV* gv, const char* prefix,
<br>
bool keepmain) <br>
void gv_efullname3(SV* sv, const GV* gv, const char* prefix)
<br>
void gv_efullname4(SV* sv, const GV* gv, const char* prefix,
<br>
bool keepmain)</p>

<p style="margin-left:11%;">&quot;GvHV&quot;</p>

<p style="margin-left:17%;">Return the <small>HV</small>
from the <small>GV.</small></p>

<p style="margin-left:17%; margin-top: 1em">HV* GvHV(GV*
gv)</p>

<p style="margin-left:11%;">&quot;gv_init&quot;</p>

<p style="margin-left:17%;">The old form of
&quot;gv_init_pvn()&quot;. It does not work with
<small>UTF&minus;8</small> strings, as it has no flags
parameter. If the &quot;multi&quot; parameter is set, the
&quot;GV_ADDMULTI&quot; flag will be passed to
&quot;gv_init_pvn()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
gv_init(GV* gv, HV* stash, const char* name, STRLEN len,
<br>
int multi)</p>

<p style="margin-left:11%;">&quot;gv_init_pv&quot;</p>

<p style="margin-left:17%;">Same as
&quot;gv_init_pvn()&quot;, but takes a nul-terminated string
for the name instead of separate char * and length
parameters.</p>

<p style="margin-left:17%; margin-top: 1em">void
gv_init_pv(GV* gv, HV* stash, const char* name, U32
flags)</p>

<p style="margin-left:11%;">&quot;gv_init_pvn&quot;</p>

<p style="margin-left:17%;">Converts a scalar into a
typeglob. This is an incoercible typeglob; assigning a
reference to it will assign to one of its slots, instead of
overwriting it as happens with typeglobs created by
&quot;SvSetSV&quot;. Converting any scalar that is
&quot;SvOK()&quot; may produce unpredictable results and is
reserved for perl&rsquo;s internal use.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;gv&quot;
is the scalar to be converted.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;stash&quot;
is the parent stash/package, if any.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;name&quot;
and &quot;len&quot; give the name. The name must be
unqualified; that is, it must not include the package name.
If &quot;gv&quot; is a stash element, it is the
caller&rsquo;s responsibility to ensure that the name passed
to this function matches the name of the element. If it does
not match, perl&rsquo;s internal bookkeeping will get out of
sync.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;flags&quot;
can be set to &quot;SVf_UTF8&quot; if &quot;name&quot; is a
<small>UTF&minus;8</small> string, or the return value of
SvUTF8(sv). It can also take the &quot;GV_ADDMULTI&quot;
flag, which means to pretend that the <small>GV</small> has
been seen before (i.e., suppress &quot;Used once&quot;
warnings).</p>

<p style="margin-left:17%; margin-top: 1em">void
gv_init_pvn(GV* gv, HV* stash, const char* name, STRLEN len,
<br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;gv_init_sv&quot;</p>

<p style="margin-left:17%;">Same as
&quot;gv_init_pvn()&quot;, but takes an <small>SV</small> *
for the name instead of separate char * and length
parameters. &quot;flags&quot; is currently unused.</p>

<p style="margin-left:17%; margin-top: 1em">void
gv_init_sv(GV* gv, HV* stash, SV* namesv, U32 flags)</p>

<p style="margin-left:11%;">&quot;gv_stashpv&quot;</p>

<p style="margin-left:17%;">Returns a pointer to the stash
for a specified package. Uses &quot;strlen&quot; to
determine the length of &quot;name&quot;, then calls
&quot;gv_stashpvn()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
gv_stashpv(const char* name, I32 flags)</p>

<p style="margin-left:11%;">&quot;gv_stashpvn&quot;</p>

<p style="margin-left:17%;">Returns a pointer to the stash
for a specified package. The &quot;namelen&quot; parameter
indicates the length of the &quot;name&quot;, in bytes.
&quot;flags&quot; is passed to
&quot;gv_fetchpvn_flags()&quot;, so if set to
&quot;GV_ADD&quot; then the package will be created if it
does not already exist. If the package does not exist and
&quot;flags&quot; is 0 (or any other setting that does not
create packages) then &quot;NULL&quot; is returned.</p>

<p style="margin-left:17%; margin-top: 1em">Flags may be
one of:</p>

<p style="margin-left:17%; margin-top: 1em">GV_ADD Create
and initialize the package if doesn't <br>
already exist <br>
GV_NOADD_NOINIT Don't create the package, <br>
GV_ADDMG GV_ADD iff the GV is magical <br>
GV_NOINIT GV_ADD, but don't initialize <br>
GV_NOEXPAND Don't expand SvOK() entries to PVGV <br>
SVf_UTF8 The name is in UTF&minus;8</p>

<p style="margin-left:17%; margin-top: 1em">The most
important of which are probably &quot;GV_ADD&quot; and
&quot;SVf_UTF8&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note, use of
&quot;gv_stashsv&quot; instead of &quot;gv_stashpvn&quot;
where possible is strongly recommended for performance
reasons.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
gv_stashpvn(const char* name, U32 namelen, I32 flags)</p>

<p style="margin-left:11%;">&quot;gv_stashpvs&quot;</p>

<p style="margin-left:17%;">Like &quot;gv_stashpvn&quot;,
but takes a literal string instead of a string/length
pair.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
gv_stashpvs(&quot;name&quot;, I32 create)</p>

<p style="margin-left:11%;">&quot;gv_stashsv&quot;</p>

<p style="margin-left:17%;">Returns a pointer to the stash
for a specified package. See &quot;gv_stashpvn&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note this
interface is strongly preferred over &quot;gv_stashpvn&quot;
for performance reasons.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
gv_stashsv(SV* sv, I32 flags)</p>

<p style="margin-left:11%;">&quot;GvSV&quot;</p>

<p style="margin-left:17%;">Return the <small>SV</small>
from the <small>GV.</small></p>

<p style="margin-left:17%; margin-top: 1em">Prior to Perl
v5.9.3, this would add a scalar if none existed. Nowadays,
use &quot;GvSVn&quot; for that, or compile perl with
&quot;&minus;DPERL_CREATE_GVSV&quot;. See perl5100delta.</p>

<p style="margin-left:17%; margin-top: 1em">SV* GvSV(GV*
gv)</p>

<p style="margin-left:11%;">&quot;GvSVn&quot;</p>

<p style="margin-left:17%;">Like &quot;GvSV&quot;, but
creates an empty scalar if none already exists.</p>

<p style="margin-left:17%; margin-top: 1em">SV* GvSVn(GV*
gv)</p>

<p style="margin-left:11%;">&quot;newGVgen&quot; <br>
&quot;newGVgen_flags&quot;</p>

<p style="margin-left:17%;">Create a new, guaranteed to be
unique, <small>GV</small> in the package given by the
NUL-terminated C language string &quot;pack&quot;, and
return a pointer to it.</p>

<p style="margin-left:17%; margin-top: 1em">For
&quot;newGVgen&quot; or if &quot;flags&quot; in
&quot;newGVgen_flags&quot; is 0, &quot;pack&quot; is to be
considered to be encoded in Latin&minus;1. The only other
legal &quot;flags&quot; value is &quot;SVf_UTF8&quot;, which
indicates &quot;pack&quot; is to be considered to be encoded
in <small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">GV* newGVgen
(const char* pack) <br>
GV* newGVgen_flags(const char* pack, U32 flags)</p>

<p style="margin-left:11%;">&quot;PL_curstash&quot;</p>

<p style="margin-left:17%;">The stash for the package code
will be compiled into.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
PL_curstash</p>

<p style="margin-left:11%;">&quot;PL_defgv&quot;</p>

<p style="margin-left:17%;">The <small>GV</small>
representing *_. Useful for access to $_.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">GV *
PL_defgv</p>

<p style="margin-left:11%;">&quot;PL_defstash&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;save_gp&quot;</p>

<p style="margin-left:17%;">Saves the current
<small>GP</small> of gv on the save stack to be restored on
scope exit.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;empty&quot; is true, replace the <small>GP</small>
with a new <small>GP.</small></p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;empty&quot; is false, mark &quot;gv&quot; with
&quot;GVf_INTRO&quot; so the next reference assigned is
localized, which is how
&quot;&nbsp;local&nbsp;*foo&nbsp;=&nbsp;$someref;&nbsp;&quot;
works.</p>

<p style="margin-left:17%; margin-top: 1em">void
save_gp(GV* gv, I32 empty)</p>

<p style="margin-left:11%;">&quot;setdefout&quot;</p>

<p style="margin-left:17%;">Sets &quot;PL_defoutgv&quot;,
the default file handle for output, to the passed in
typeglob. As &quot;PL_defoutgv&quot; &quot;owns&quot; a
reference on its typeglob, the reference count of the passed
in typeglob is increased by one, and the reference count of
the typeglob that &quot;PL_defoutgv&quot; points to is
decreased by one.</p>

<p style="margin-left:17%; margin-top: 1em">void
setdefout(GV* gv)</p>

<h2>Hook manipulation
<a name="Hook manipulation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These functions
provide convenient and thread-safe means of manipulating
hook variables. <br>
&quot;wrap_op_checker&quot;</p>

<p style="margin-left:17%;">Puts a C function into the
chain of check functions for a specified op type. This is
the preferred way to manipulate the &quot;PL_check&quot;
array. &quot;opcode&quot; specifies which type of op is to
be affected. &quot;new_checker&quot; is a pointer to the C
function that is to be added to that opcode&rsquo;s check
chain, and &quot;old_checker_p&quot; points to the storage
location where a pointer to the next function in the chain
will be stored. The value of &quot;new_checker&quot; is
written into the &quot;PL_check&quot; array, while the value
previously stored there is written to *old_checker_p.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;PL_check&quot;
is global to an entire process, and a module wishing to hook
op checking may find itself invoked more than once per
process, typically in different threads. To handle that
situation, this function is idempotent. The location
*old_checker_p must initially (once per process) contain a
null pointer. A C variable of static duration (declared at
file scope, typically also marked &quot;static&quot; to give
it internal linkage) will be implicitly initialised
appropriately, if it does not have an explicit initialiser.
This function will only actually modify the check chain if
it finds *old_checker_p to be null. This function is also
thread safe on the small scale. It uses appropriate locking
to avoid race conditions in accessing
&quot;PL_check&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">When this
function is called, the function referenced by
&quot;new_checker&quot; must be ready to be called, except
for *old_checker_p being unfilled. In a threading situation,
&quot;new_checker&quot; may be called immediately, even
before this function has returned. *old_checker_p will
always be appropriately set before &quot;new_checker&quot;
is called. If &quot;new_checker&quot; decides not to do
anything special with an op that it is given (which is the
usual case for most uses of op check hooking), it must chain
the check function referenced by *old_checker_p.</p>

<p style="margin-left:17%; margin-top: 1em">Taken all
together, <small>XS</small> code to hook an op checker
should typically look something like this:</p>

<p style="margin-left:17%; margin-top: 1em">static
Perl_check_t nxck_frob; <br>
static OP *myck_frob(pTHX_ OP *op) { <br>
... <br>
op = nxck_frob(aTHX_ op); <br>
... <br>
return op; <br>
} <br>
BOOT: <br>
wrap_op_checker(OP_FROB, myck_frob, &amp;nxck_frob);</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
influence compilation of calls to a specific subroutine,
then use &quot;cv_set_call_checker_flags&quot; rather than
hooking checking of all &quot;entersub&quot; ops.</p>

<p style="margin-left:17%; margin-top: 1em">void
wrap_op_checker(Optype opcode, Perl_check_t new_checker,
<br>
Perl_check_t *old_checker_p)</p>

<h2>HV Handling
<a name="HV Handling"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A
<small>HV</small> structure represents a Perl hash. It
consists mainly of an array of pointers, each of which
points to a linked list of <small>HE</small> structures. The
array is indexed by the hash function of the key, so each
linked list represents all the hash entries with the same
hash value. Each <small>HE</small> contains a pointer to the
actual value, plus a pointer to a <small>HEK</small>
structure which holds the key and hash value. <br>
&quot;get_hv&quot;</p>

<p style="margin-left:17%;">Returns the <small>HV</small>
of the specified Perl hash. &quot;flags&quot; are passed to
&quot;gv_fetchpv&quot;. If &quot;GV_ADD&quot; is set and the
Perl variable does not exist then it will be created. If
&quot;flags&quot; is zero and the variable does not exist
then &quot;NULL&quot; is returned.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_get_hv()&quot; form is <b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
get_hv(const char *name, I32 flags)</p>

<p style="margin-left:11%;">&quot;HE&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;HEf_SVKEY&quot;</p>

<p style="margin-left:17%;">This flag, used in the length
slot of hash entries and magic structures, specifies the
structure contains an &quot;SV*&quot; pointer where a
&quot;char*&quot; pointer is to be expected. (For
information only--not to be used).</p>

<p style="margin-left:11%;">&quot;HeHASH&quot;</p>

<p style="margin-left:17%;">Returns the computed hash
stored in the hash entry.</p>

<p style="margin-left:17%; margin-top: 1em">U32 HeHASH(HE*
he)</p>

<p style="margin-left:11%;">&quot;HeKEY&quot;</p>

<p style="margin-left:17%;">Returns the actual pointer
stored in the key slot of the hash entry. The pointer may be
either &quot;char*&quot; or &quot;SV*&quot;, depending on
the value of &quot;HeKLEN()&quot;. Can be assigned to. The
&quot;HePV()&quot; or &quot;HeSVKEY()&quot; macros are
usually preferable for finding the value of a key.</p>

<p style="margin-left:17%; margin-top: 1em">void* HeKEY(HE*
he)</p>

<p style="margin-left:11%;">&quot;HeKLEN&quot;</p>

<p style="margin-left:17%;">If this is negative, and
amounts to &quot;HEf_SVKEY&quot;, it indicates the entry
holds an &quot;SV*&quot; key. Otherwise, holds the actual
length of the key. Can be assigned to. The
&quot;HePV()&quot; macro is usually preferable for finding
key lengths.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
HeKLEN(HE* he)</p>

<p style="margin-left:11%;">&quot;HePV&quot;</p>

<p style="margin-left:17%;">Returns the key slot of the
hash entry as a &quot;char*&quot; value, doing any necessary
dereferencing of possibly &quot;SV*&quot; keys. The length
of the string is placed in &quot;len&quot; (this is a macro,
so do <i>not</i> use &amp;len). If you do not care about
what the length of the key is, you may use the global
variable &quot;PL_na&quot;, though this is rather less
efficient than using a local variable. Remember though, that
hash keys in perl are free to contain embedded nulls, so
using &quot;strlen()&quot; or similar is not a good way to
find the length of hash keys. This is very similar to the
&quot;SvPV()&quot; macro described elsewhere in this
document. See also &quot;HeUTF8&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If you are
using &quot;HePV&quot; to get values to pass to
&quot;newSVpvn()&quot; to create a new <small>SV,</small>
you should consider using
&quot;newSVhek(HeKEY_hek(he))&quot; as it is more
efficient.</p>

<p style="margin-left:17%; margin-top: 1em">char* HePV(HE*
he, STRLEN len)</p>

<p style="margin-left:11%;">&quot;HeSVKEY&quot;</p>

<p style="margin-left:17%;">Returns the key as an
&quot;SV*&quot;, or &quot;NULL&quot; if the hash entry does
not contain an &quot;SV*&quot; key.</p>

<p style="margin-left:17%; margin-top: 1em">SV* HeSVKEY(HE*
he)</p>

<p style="margin-left:11%;">&quot;HeSVKEY_force&quot;</p>

<p style="margin-left:17%;">Returns the key as an
&quot;SV*&quot;. Will create and return a temporary mortal
&quot;SV*&quot; if the hash entry contains only a
&quot;char*&quot; key.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
HeSVKEY_force(HE* he)</p>

<p style="margin-left:11%;">&quot;HeSVKEY_set&quot;</p>

<p style="margin-left:17%;">Sets the key to a given
&quot;SV*&quot;, taking care to set the appropriate flags to
indicate the presence of an &quot;SV*&quot; key, and returns
the same &quot;SV*&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
HeSVKEY_set(HE* he, SV* sv)</p>

<p style="margin-left:11%;">&quot;HeUTF8&quot;</p>

<p style="margin-left:17%;">Returns whether the &quot;char
*&quot; value returned by &quot;HePV&quot; is encoded in
<small>UTF&minus;8,</small> doing any necessary
dereferencing of possibly &quot;SV*&quot; keys. The value
returned will be 0 or non&minus;0, not necessarily 1 (or
even a value with any low bits set), so <b>do not</b>
blindly assign this to a &quot;bool&quot; variable, as
&quot;bool&quot; may be a typedef for &quot;char&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">U32 HeUTF8(HE*
he)</p>

<p style="margin-left:11%;">&quot;HeVAL&quot;</p>

<p style="margin-left:17%;">Returns the value slot (type
&quot;SV*&quot;) stored in the hash entry. Can be assigned
to.</p>

<p style="margin-left:17%; margin-top: 1em">SV *foo=
HeVAL(hv); <br>
HeVAL(hv)= sv;</p>

<p style="margin-left:17%; margin-top: 1em">SV* HeVAL(HE*
he)</p>

<p style="margin-left:11%;">&quot;HV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;hv_assert&quot;</p>

<p style="margin-left:17%;">Check that a hash is in an
internally consistent state.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;hv_assert&quot; must be explicitly called as
&quot;Perl_hv_assert&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_hv_assert(pTHX_ HV *hv)</p>


<p style="margin-left:11%;">&quot;hv_bucket_ratio&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;hv_bucket_ratio&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">If the hash is
tied dispatches through to the <small>SCALAR</small> tied
method, otherwise if the hash contains no keys returns 0,
otherwise returns a mortal sv containing a string specifying
the number of used buckets, followed by a slash, followed by
the number of available buckets.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is expensive, it must scan all of the buckets to determine
which are used, and the count is <small>NOT</small> cached.
In a large hash this could be a lot of buckets.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
hv_bucket_ratio(HV *hv)</p>

<p style="margin-left:11%;">&quot;hv_clear&quot;</p>

<p style="margin-left:17%;">Frees all the elements of a
hash, leaving it empty. The <small>XS</small> equivalent of
&quot;%hash = ()&quot;. See also &quot;hv_undef&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;av_clear&quot; for a note about the hash possibly
being invalid on return.</p>

<p style="margin-left:17%; margin-top: 1em">void
hv_clear(HV *hv)</p>


<p style="margin-left:11%;">&quot;hv_clear_placeholders&quot;</p>

<p style="margin-left:17%;">Clears any placeholders from a
hash. If a restricted hash has any of its keys marked as
readonly and the key is subsequently deleted, the key is not
actually deleted but is marked by assigning it a value of
&amp;PL_sv_placeholder. This tags it so it will be ignored
by future operations such as iterating over the hash, but
will still allow the hash to have a value reassigned to the
key at some future point. This function clears any such
placeholder keys from the hash. See
&quot;Hash::Util::lock_keys()&quot; for an example of its
use.</p>

<p style="margin-left:17%; margin-top: 1em">void
hv_clear_placeholders(HV *hv)</p>


<p style="margin-left:11%;">&quot;hv_copy_hints_hv&quot;</p>

<p style="margin-left:17%;">A specialised version of
&quot;newHVhv&quot; for copying &quot;%^H&quot;.
&quot;ohv&quot; must be a pointer to a hash (which may have
&quot;%^H&quot; magic, but should be generally non-magical),
or &quot;NULL&quot; (interpreted as an empty hash). The
content of &quot;ohv&quot; is copied to a new hash, which
has the &quot;%^H&quot;&minus;specific magic added to it. A
pointer to the new hash is returned.</p>

<p style="margin-left:17%; margin-top: 1em">HV *
hv_copy_hints_hv(HV *const ohv)</p>

<p style="margin-left:11%;">&quot;hv_delete&quot;</p>

<p style="margin-left:17%;">Deletes a key/value pair in the
hash. The value&rsquo;s <small>SV</small> is removed from
the hash, made mortal, and returned to the caller. The
absolute value of &quot;klen&quot; is the length of the key.
If &quot;klen&quot; is negative the key is assumed to be in
UTF&minus;8&minus;encoded Unicode. The &quot;flags&quot;
value will normally be zero; if set to &quot;G_DISCARD&quot;
then &quot;NULL&quot; will be returned. &quot;NULL&quot;
will also be returned if the key is not found.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
hv_delete(HV *hv, const char *key, I32 klen, I32 flags)</p>

<p style="margin-left:11%;">&quot;hv_delete_ent&quot;</p>

<p style="margin-left:17%;">Deletes a key/value pair in the
hash. The value <small>SV</small> is removed from the hash,
made mortal, and returned to the caller. The
&quot;flags&quot; value will normally be zero; if set to
&quot;G_DISCARD&quot; then &quot;NULL&quot; will be
returned. &quot;NULL&quot; will also be returned if the key
is not found. &quot;hash&quot; can be a valid precomputed
hash value, or 0 to ask for it to be computed.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
hv_delete_ent(HV *hv, SV *keysv, I32 flags, U32 hash)</p>

<p style="margin-left:11%;">&quot;HvENAME&quot;</p>

<p style="margin-left:17%;">Returns the effective name of a
stash, or <small>NULL</small> if there is none. The
effective name represents a location in the symbol table
where this stash resides. It is updated automatically when
packages are aliased or deleted. A stash that is no longer
in the symbol table has no effective name. This name is
preferable to &quot;HvNAME&quot; for use in
<small>MRO</small> linearisations and isa caches.</p>

<p style="margin-left:17%; margin-top: 1em">char*
HvENAME(HV* stash)</p>

<p style="margin-left:11%;">&quot;HvENAMELEN&quot;</p>

<p style="margin-left:17%;">Returns the length of the
stash&rsquo;s effective name.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
HvENAMELEN(HV *stash)</p>

<p style="margin-left:11%;">&quot;HvENAMEUTF8&quot;</p>

<p style="margin-left:17%;">Returns true if the effective
name is in <small>UTF&minus;8</small> encoding.</p>

<p style="margin-left:17%; margin-top: 1em">unsigned char
HvENAMEUTF8(HV *stash)</p>

<p style="margin-left:11%;">&quot;hv_exists&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified hash key exists. The absolute value of
&quot;klen&quot; is the length of the key. If
&quot;klen&quot; is negative the key is assumed to be in
UTF&minus;8&minus;encoded Unicode.</p>

<p style="margin-left:17%; margin-top: 1em">bool
hv_exists(HV *hv, const char *key, I32 klen)</p>

<p style="margin-left:11%;">&quot;hv_exists_ent&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the specified hash key exists. &quot;hash&quot; can
be a valid precomputed hash value, or 0 to ask for it to be
computed.</p>

<p style="margin-left:17%; margin-top: 1em">bool
hv_exists_ent(HV *hv, SV *keysv, U32 hash)</p>

<p style="margin-left:11%;">&quot;hv_fetch&quot;</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
which corresponds to the specified key in the hash. The
absolute value of &quot;klen&quot; is the length of the key.
If &quot;klen&quot; is negative the key is assumed to be in
UTF&minus;8&minus;encoded Unicode. If &quot;lval&quot; is
set then the fetch will be part of a store. This means that
if there is no value in the hash associated with the given
key, then one is created and a pointer to it is returned.
The &quot;SV*&quot; it points to can be assigned to. But
always check that the return value is non-null before
dereferencing it to an &quot;SV*&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied hashes.</p>

<p style="margin-left:17%; margin-top: 1em">SV**
hv_fetch(HV *hv, const char *key, I32 klen, I32 lval)</p>

<p style="margin-left:11%;">&quot;hv_fetchs&quot;</p>

<p style="margin-left:17%;">Like &quot;hv_fetch&quot;, but
takes a literal string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">SV**
hv_fetchs(HV* tb, &quot;key&quot;, I32 lval)</p>

<p style="margin-left:11%;">&quot;hv_fetch_ent&quot;</p>

<p style="margin-left:17%;">Returns the hash entry which
corresponds to the specified key in the hash.
&quot;hash&quot; must be a valid precomputed hash number for
the given &quot;key&quot;, or 0 if you want the function to
compute it. <small>IF</small> &quot;lval&quot; is set then
the fetch will be part of a store. Make sure the return
value is non-null before accessing it. The return value when
&quot;hv&quot; is a tied hash is a pointer to a static
location, so be sure to make a copy of the structure if you
need to store it somewhere.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied hashes.</p>

<p style="margin-left:17%; margin-top: 1em">HE*
hv_fetch_ent(HV *hv, SV *keysv, I32 lval, U32 hash)</p>

<p style="margin-left:11%;">&quot;HvFILL&quot;</p>

<p style="margin-left:17%;">Returns the number of hash
buckets that happen to be in use.</p>

<p style="margin-left:17%; margin-top: 1em">As of perl 5.25
this function is used only for debugging purposes, and the
number of used hash buckets is not in any way cached, thus
this function can be costly to execute as it must iterate
over all the buckets in the hash.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
HvFILL(HV *const hv)</p>

<p style="margin-left:11%;">&quot;hv_iterinit&quot;</p>

<p style="margin-left:17%;">Prepares a starting point to
traverse a hash table. Returns the number of keys in the
hash, including placeholders (i.e. the same as
&quot;HvTOTALKEYS(hv)&quot;). The return value is currently
only meaningful for hashes without tie magic.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
Before version 5.004_65, &quot;hv_iterinit&quot; used to
return the number of hash buckets that happen to be in use.
If you still need that esoteric value, you can get it
through the macro &quot;HvFILL(hv)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32
hv_iterinit(HV *hv)</p>

<p style="margin-left:11%;">&quot;hv_iterkey&quot;</p>

<p style="margin-left:17%;">Returns the key from the
current position of the hash iterator. See
&quot;hv_iterinit&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
hv_iterkey(HE* entry, I32* retlen)</p>

<p style="margin-left:11%;">&quot;hv_iterkeysv&quot;</p>

<p style="margin-left:17%;">Returns the key as an
&quot;SV*&quot; from the current position of the hash
iterator. The return value will always be a mortal copy of
the key. Also see &quot;hv_iterinit&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
hv_iterkeysv(HE* entry)</p>

<p style="margin-left:11%;">&quot;hv_iternext&quot;</p>

<p style="margin-left:17%;">Returns entries from a hash
iterator. See &quot;hv_iterinit&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">You may call
&quot;hv_delete&quot; or &quot;hv_delete_ent&quot; on the
hash entry that the iterator currently points to, without
losing your place or invalidating your iterator. Note that
in this case the current entry is deleted from the hash with
your iterator holding the last reference to it. Your
iterator is flagged to free the entry on the next call to
&quot;hv_iternext&quot;, so you must not discard your
iterator immediately else the entry will leak &minus; call
&quot;hv_iternext&quot; to trigger the resource
deallocation.</p>

<p style="margin-left:17%; margin-top: 1em">HE*
hv_iternext(HV *hv)</p>

<p style="margin-left:11%;">&quot;hv_iternextsv&quot;</p>

<p style="margin-left:17%;">Performs an
&quot;hv_iternext&quot;, &quot;hv_iterkey&quot;, and
&quot;hv_iterval&quot; in one operation.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
hv_iternextsv(HV *hv, char **key, I32 *retlen)</p>


<p style="margin-left:11%;">&quot;hv_iternext_flags&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;hv_iternext_flags&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Returns entries
from a hash iterator. See &quot;hv_iterinit&quot; and
&quot;hv_iternext&quot;. The &quot;flags&quot; value will
normally be zero; if
&quot;HV_ITERNEXT_WANTPLACEHOLDERS&quot; is set the
placeholders keys (for restricted hashes) will be returned
in addition to normal keys. By default placeholders are
automatically skipped over. Currently a placeholder is
implemented with a value that is &amp;PL_sv_placeholder.
Note that the implementation of placeholders and restricted
hashes may change, and the implementation currently is
insufficiently abstracted for any change to be tidy.</p>

<p style="margin-left:17%; margin-top: 1em">HE*
hv_iternext_flags(HV *hv, I32 flags)</p>

<p style="margin-left:11%;">&quot;hv_iterval&quot;</p>

<p style="margin-left:17%;">Returns the value from the
current position of the hash iterator. See
&quot;hv_iterkey&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
hv_iterval(HV *hv, HE *entry)</p>

<p style="margin-left:11%;">&quot;hv_magic&quot;</p>

<p style="margin-left:17%;">Adds magic to a hash. See
&quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
hv_magic(HV *hv, GV *gv, int how)</p>

<p style="margin-left:11%;">&quot;HvNAME&quot;</p>

<p style="margin-left:17%;">Returns the package name of a
stash, or &quot;NULL&quot; if &quot;stash&quot; isn&rsquo;t
a stash. See &quot;SvSTASH&quot;, &quot;CvSTASH&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
HvNAME(HV* stash)</p>

<p style="margin-left:11%;">&quot;HvNAMELEN&quot;</p>

<p style="margin-left:17%;">Returns the length of the
stash&rsquo;s name.</p>

<p style="margin-left:17%; margin-top: 1em">Disfavored
forms of HvNAME and HvNAMELEN; suppress mention of them</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
HvNAMELEN(HV *stash)</p>

<p style="margin-left:11%;">&quot;HvNAMEUTF8&quot;</p>

<p style="margin-left:17%;">Returns true if the name is in
<small>UTF&minus;8</small> encoding.</p>

<p style="margin-left:17%; margin-top: 1em">unsigned char
HvNAMEUTF8(HV *stash)</p>

<p style="margin-left:11%;">&quot;hv_scalar&quot;</p>

<p style="margin-left:17%;">Evaluates the hash in scalar
context and returns the result.</p>

<p style="margin-left:17%; margin-top: 1em">When the hash
is tied dispatches through to the <small>SCALAR</small>
method, otherwise returns a mortal <small>SV</small>
containing the number of keys in the hash.</p>

<p style="margin-left:17%; margin-top: 1em">Note, prior to
5.25 this function returned what is now returned by the
<b>hv_bucket_ratio()</b> function.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
hv_scalar(HV *hv)</p>

<p style="margin-left:11%;">&quot;hv_store&quot;</p>

<p style="margin-left:17%;">Stores an <small>SV</small> in
a hash. The hash key is specified as &quot;key&quot; and the
absolute value of &quot;klen&quot; is the length of the key.
If &quot;klen&quot; is negative the key is assumed to be in
UTF&minus;8&minus;encoded Unicode. The &quot;hash&quot;
parameter is the precomputed hash value; if it is zero then
Perl will compute it.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value will be &quot;NULL&quot; if the operation failed or if
the value did not need to be actually stored within the hash
(as in the case of tied hashes). Otherwise it can be
dereferenced to get the original &quot;SV*&quot;. Note that
the caller is responsible for suitably incrementing the
reference count of &quot;val&quot; before the call, and
decrementing it if the function returned &quot;NULL&quot;.
Effectively a successful &quot;hv_store&quot; takes
ownership of one reference to &quot;val&quot;. This is
usually what you want; a newly created <small>SV</small> has
a reference count of one, so if all your code does is create
SVs then store them in a hash, &quot;hv_store&quot; will own
the only reference to the new <small>SV,</small> and your
code doesn&rsquo;t need to do anything further to tidy up.
&quot;hv_store&quot; is not implemented as a call to
&quot;hv_store_ent&quot;, and does not create a temporary
<small>SV</small> for the key, so if your key data is not
already in <small>SV</small> form then use
&quot;hv_store&quot; in preference to
&quot;hv_store_ent&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied hashes.</p>

<p style="margin-left:17%; margin-top: 1em">SV**
hv_store(HV *hv, const char *key, I32 klen, SV *val, <br>
U32 hash)</p>

<p style="margin-left:11%;">&quot;hv_stores&quot;</p>

<p style="margin-left:17%;">Like &quot;hv_store&quot;, but
takes a literal string instead of a string/length pair and
omits the hash parameter.</p>

<p style="margin-left:17%; margin-top: 1em">SV**
hv_stores(HV* tb, &quot;key&quot;, SV* val)</p>

<p style="margin-left:11%;">&quot;hv_store_ent&quot;</p>

<p style="margin-left:17%;">Stores &quot;val&quot; in a
hash. The hash key is specified as &quot;key&quot;. The
&quot;hash&quot; parameter is the precomputed hash value; if
it is zero then Perl will compute it. The return value is
the new hash entry so created. It will be &quot;NULL&quot;
if the operation failed or if the value did not need to be
actually stored within the hash (as in the case of tied
hashes). Otherwise the contents of the return value can be
accessed using the &quot;He?&quot; macros described here.
Note that the caller is responsible for suitably
incrementing the reference count of &quot;val&quot; before
the call, and decrementing it if the function returned
<small>NULL.</small> Effectively a successful
&quot;hv_store_ent&quot; takes ownership of one reference to
&quot;val&quot;. This is usually what you want; a newly
created <small>SV</small> has a reference count of one, so
if all your code does is create SVs then store them in a
hash, &quot;hv_store&quot; will own the only reference to
the new <small>SV,</small> and your code doesn&rsquo;t need
to do anything further to tidy up. Note that
&quot;hv_store_ent&quot; only reads the &quot;key&quot;;
unlike &quot;val&quot; it does not take ownership of it, so
maintaining the correct reference count on &quot;key&quot;
is entirely the caller&rsquo;s responsibility. The reason it
does not take ownership, is that &quot;key&quot; is not used
after this function returns, and so can be freed
immediately. &quot;hv_store&quot; is not implemented as a
call to &quot;hv_store_ent&quot;, and does not create a
temporary <small>SV</small> for the key, so if your key data
is not already in <small>SV</small> form then use
&quot;hv_store&quot; in preference to
&quot;hv_store_ent&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;Understanding the Magic of Tied Hashes and
Arrays&quot; in perlguts for more information on how to use
this function on tied hashes.</p>

<p style="margin-left:17%; margin-top: 1em">HE*
hv_store_ent(HV *hv, SV *key, SV *val, U32 hash)</p>

<p style="margin-left:11%;">&quot;hv_undef&quot;</p>

<p style="margin-left:17%;">Undefines the hash. The
<small>XS</small> equivalent of
&quot;undef(%hash)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">As well as
freeing all the elements of the hash (like
&quot;hv_clear()&quot;), this also frees any auxiliary data
and storage associated with the hash.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;av_clear&quot; for a note about the hash possibly
being invalid on return.</p>

<p style="margin-left:17%; margin-top: 1em">void
hv_undef(HV *hv)</p>

<p style="margin-left:11%;">&quot;newHV&quot;</p>

<p style="margin-left:17%;">Creates a new
<small>HV.</small> The reference count is set to 1.</p>

<p style="margin-left:17%; margin-top: 1em">HV* newHV()</p>

<p style="margin-left:11%;">&quot;newHVhv&quot;</p>

<p style="margin-left:17%;">The content of &quot;ohv&quot;
is copied to a new hash. A pointer to the new hash is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">HV* newHVhv(HV
*hv)</p>

<p style="margin-left:11%;">&quot;Nullhv&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;Nullhv&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Null
<small>HV</small> pointer.</p>

<p style="margin-left:17%; margin-top: 1em">(deprecated
&minus; use &quot;(HV *)NULL&quot; instead)</p>

<p style="margin-left:11%;">&quot;PERL_HASH&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
PERL_HASH(U32 hash, char *key, STRLEN klen)</p>

<p style="margin-left:11%;">&quot;PL_modglobal&quot;</p>

<p style="margin-left:17%;">&quot;PL_modglobal&quot; is a
general purpose, interpreter global <small>HV</small> for
use by extensions that need to keep information on a
per-interpreter basis. In a pinch, it can also be used as a
symbol table for extensions to share data among each other.
It is a good idea to use keys prefixed by the package name
of the extension that owns the data.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
PL_modglobal</p>

<h2>Input/Output
<a name="Input/Output"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;IoDIRP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">DIR * IoDIRP(IO
*io)</p>

<p style="margin-left:11%;">&quot;IOf_FLUSH&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;IoFLAGS&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">U8 IoFLAGS(IO
*io)</p>

<p style="margin-left:11%;">&quot;IOf_UNTAINT&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;IoIFP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">PerlIO *
IoIFP(IO *io)</p>

<p style="margin-left:11%;">&quot;IoOFP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">PerlIO *
IoOFP(IO *io)</p>

<p style="margin-left:11%;">&quot;IoTYPE&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">char IoTYPE(IO
*io)</p>

<p style="margin-left:11%;">&quot;my_chsize&quot;</p>

<p style="margin-left:17%;">The C library <b>chsize</b>(3)
if available, or a Perl implementation of it.</p>

<p style="margin-left:17%; margin-top: 1em">I32
my_chsize(int fd, Off_t length)</p>

<p style="margin-left:11%;">&quot;my_dirfd&quot;</p>

<p style="margin-left:17%;">The C library dirfd(3) if
available, or a Perl implementation of it, or die if not
easily emulatable.</p>

<p style="margin-left:17%; margin-top: 1em">int
my_dirfd(DIR* dir)</p>

<p style="margin-left:11%;">&quot;my_pclose&quot;</p>

<p style="margin-left:17%;">A wrapper for the C library
<b>pclose</b>(3). Don&rsquo;t use the latter, as the Perl
version knows things that interact with the rest of the perl
interpreter.</p>

<p style="margin-left:17%; margin-top: 1em">I32
my_pclose(PerlIO* ptr)</p>

<p style="margin-left:11%;">&quot;my_popen&quot;</p>

<p style="margin-left:17%;">A wrapper for the C library
<b>popen</b>(3). Don&rsquo;t use the latter, as the Perl
version knows things that interact with the rest of the perl
interpreter.</p>

<p style="margin-left:17%; margin-top: 1em">PerlIO*
my_popen(const char* cmd, const char* mode)</p>

<p style="margin-left:11%;">&quot;newIO&quot;</p>

<p style="margin-left:17%;">Create a new <small>IO,</small>
setting the reference count to 1.</p>

<p style="margin-left:17%; margin-top: 1em">IO* newIO()</p>


<p style="margin-left:11%;">&quot;PERL_FLUSHALL_FOR_CHILD&quot;</p>

<p style="margin-left:17%;">This defines a way to flush all
output buffers. This may be a performance issue, so we allow
people to disable it. Also, if we are using stdio, there are
broken implementations of fflush( <small>NULL</small> ) out
there, Solaris being the most prominent.</p>

<p style="margin-left:17%; margin-top: 1em">void
PERL_FLUSHALL_FOR_CHILD</p>


<p style="margin-left:11%;">&quot;PerlIO_apply_layers&quot;
<br>
&quot;PerlIO_binmode&quot; <br>
&quot;PerlIO_canset_cnt&quot; <br>
&quot;PerlIO_clearerr&quot; <br>
&quot;PerlIO_close&quot; <br>
&quot;PerlIO_debug&quot; <br>
&quot;PerlIO_eof&quot; <br>
&quot;PerlIO_error&quot; <br>
&quot;PerlIO_exportFILE&quot; <br>
&quot;PerlIO_fast_gets&quot; <br>
&quot;PerlIO_fdopen&quot; <br>
&quot;PerlIO_fileno&quot; <br>
&quot;PerlIO_fill&quot; <br>
&quot;PerlIO_findFILE&quot; <br>
&quot;PerlIO_flush&quot; <br>
&quot;PerlIO_get_base&quot; <br>
&quot;PerlIO_get_bufsiz&quot; <br>
&quot;PerlIO_getc&quot; <br>
&quot;PerlIO_get_cnt&quot; <br>
&quot;PerlIO_getpos&quot; <br>
&quot;PerlIO_get_ptr&quot; <br>
&quot;PerlIO_has_base&quot; <br>
&quot;PerlIO_has_cntptr&quot; <br>
&quot;PerlIO_importFILE&quot; <br>
&quot;PerlIO_open&quot; <br>
&quot;PerlIO_printf&quot; <br>
&quot;PerlIO_putc&quot; <br>
&quot;PerlIO_puts&quot; <br>
&quot;PerlIO_read&quot; <br>
&quot;PerlIO_releaseFILE&quot; <br>
&quot;PerlIO_reopen&quot; <br>
&quot;PerlIO_rewind&quot; <br>
&quot;PerlIO_seek&quot; <br>
&quot;PerlIO_set_cnt&quot; <br>
&quot;PerlIO_setlinebuf&quot; <br>
&quot;PerlIO_setpos&quot; <br>
&quot;PerlIO_set_ptrcnt&quot; <br>
&quot;PerlIO_stderr&quot; <br>
&quot;PerlIO_stdin&quot; <br>
&quot;PerlIO_stdout&quot; <br>
&quot;PerlIO_stdoutf&quot; <br>
&quot;PerlIO_tell&quot; <br>
&quot;PerlIO_ungetc&quot; <br>
&quot;PerlIO_unread&quot; <br>
&quot;PerlIO_vprintf&quot; <br>
&quot;PerlIO_write&quot;</p>

<p style="margin-left:17%;">Described in perlapio.</p>

<p style="margin-left:17%; margin-top: 1em">int
PerlIO_apply_layers(PerlIO *f, const char *mode, <br>
const char *layers) <br>
int PerlIO_binmode (PerlIO *f, int ptype, int imode, <br>
const char *layers) <br>
int PerlIO_canset_cnt (PerlIO *f) <br>
void PerlIO_clearerr (PerlIO *f) <br>
int PerlIO_close (PerlIO *f) <br>
void PerlIO_debug (const char *fmt, ...) <br>
int PerlIO_eof (PerlIO *f) <br>
int PerlIO_error (PerlIO *f) <br>
FILE * PerlIO_exportFILE (PerlIO *f, const char *mode) <br>
int PerlIO_fast_gets (PerlIO *f) <br>
PerlIO * PerlIO_fdopen (int fd, const char *mode) <br>
int PerlIO_fileno (PerlIO *f) <br>
int PerlIO_fill (PerlIO *f) <br>
FILE * PerlIO_findFILE (PerlIO *f) <br>
int PerlIO_flush (PerlIO *f) <br>
STDCHAR * PerlIO_get_base (PerlIO *f) <br>
SSize_t PerlIO_get_bufsiz (PerlIO *f) <br>
int PerlIO_getc (PerlIO *d) <br>
SSize_t PerlIO_get_cnt (PerlIO *f) <br>
int PerlIO_getpos (PerlIO *f, SV *save) <br>
STDCHAR * PerlIO_get_ptr (PerlIO *f) <br>
int PerlIO_has_base (PerlIO *f) <br>
int PerlIO_has_cntptr (PerlIO *f) <br>
PerlIO * PerlIO_importFILE (FILE *stdio, const char *mode)
<br>
PerlIO * PerlIO_open (const char *path, const char *mode)
<br>
int PerlIO_printf (PerlIO *f, const char *fmt, ...) <br>
int PerlIO_putc (PerlIO *f, int ch) <br>
int PerlIO_puts (PerlIO *f, const char *string) <br>
SSize_t PerlIO_read (PerlIO *f, void *vbuf, <br>
Size_t count) <br>
void PerlIO_releaseFILE (PerlIO *f, FILE *stdio) <br>
PerlIO * PerlIO_reopen (const char *path, const char *mode,
<br>
PerlIO *old) <br>
void PerlIO_rewind (PerlIO *f) <br>
int PerlIO_seek (PerlIO *f, Off_t offset, <br>
int whence) <br>
void PerlIO_set_cnt (PerlIO *f, SSize_t cnt) <br>
void PerlIO_setlinebuf (PerlIO *f) <br>
int PerlIO_setpos (PerlIO *f, SV *saved) <br>
void PerlIO_set_ptrcnt (PerlIO *f, STDCHAR *ptr, <br>
SSize_t cnt) <br>
PerlIO * PerlIO_stderr (PerlIO *f, const char *mode, <br>
const char *layers) <br>
PerlIO * PerlIO_stdin (PerlIO *f, const char *mode, <br>
const char *layers) <br>
PerlIO * PerlIO_stdout (PerlIO *f, const char *mode, <br>
const char *layers) <br>
int PerlIO_stdoutf (const char *fmt, ...) <br>
Off_t PerlIO_tell (PerlIO *f) <br>
int PerlIO_ungetc (PerlIO *f, int ch) <br>
SSize_t PerlIO_unread (PerlIO *f, const void *vbuf, <br>
Size_t count) <br>
int PerlIO_vprintf (PerlIO *f, const char *fmt, <br>
va_list args) <br>
SSize_t PerlIO_write (PerlIO *f, const void *vbuf, <br>
Size_t count)</p>


<p style="margin-left:11%;">&quot;PERLIO_FUNCS_CAST&quot;</p>

<p style="margin-left:17%;">Cast the pointer
&quot;func&quot; to be of type
&quot;PerlIO_funcs&nbsp;*&quot;.</p>


<p style="margin-left:11%;">&quot;PERLIO_FUNCS_DECL&quot;</p>

<p style="margin-left:17%;">Declare &quot;ftab&quot; to be
a PerlIO function table, that is, of type
&quot;PerlIO_funcs&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">PERLIO_FUNCS_DECL(PerlIO
* ftab)</p>

<p style="margin-left:11%;">&quot;PERLIO_F_APPEND&quot;
<br>
&quot;PERLIO_F_CANREAD&quot; <br>
&quot;PERLIO_F_CANWRITE&quot; <br>
&quot;PERLIO_F_CRLF&quot; <br>
&quot;PERLIO_F_EOF&quot; <br>
&quot;PERLIO_F_ERROR&quot; <br>
&quot;PERLIO_F_FASTGETS&quot; <br>
&quot;PERLIO_F_LINEBUF&quot; <br>
&quot;PERLIO_F_OPEN&quot; <br>
&quot;PERLIO_F_RDBUF&quot; <br>
&quot;PERLIO_F_TEMP&quot; <br>
&quot;PERLIO_F_TRUNCATE&quot; <br>
&quot;PERLIO_F_UNBUF&quot; <br>
&quot;PERLIO_F_UTF8&quot; <br>
&quot;PERLIO_F_WRBUF&quot;</p>

<p style="margin-left:17%;">Described in perliol.</p>

<p style="margin-left:11%;">&quot;PERLIO_K_BUFFERED&quot;
<br>
&quot;PERLIO_K_CANCRLF&quot; <br>
&quot;PERLIO_K_FASTGETS&quot; <br>
&quot;PERLIO_K_MULTIARG&quot; <br>
&quot;PERLIO_K_RAW&quot;</p>

<p style="margin-left:17%;">Described in perliol.</p>


<p style="margin-left:11%;">&quot;PERLIO_NOT_STDIO&quot;</p>

<p style="margin-left:17%;">Described in perlapio.</p>

<p style="margin-left:11%;">&quot;PL_maxsysfd&quot;</p>

<p style="margin-left:17%;">Described in perliol.</p>

<p style="margin-left:11%;">&quot;repeatcpy&quot;</p>

<p style="margin-left:17%;">Make &quot;count&quot; copies
of the &quot;len&quot; bytes beginning at &quot;from&quot;,
placing them into memory beginning at &quot;to&quot;, which
must be big enough to accommodate them all.</p>

<p style="margin-left:17%; margin-top: 1em">void
repeatcpy(char* to, const char* from, I32 len, IV count)</p>

<p style="margin-left:11%;">&quot;USE_STDIO&quot;</p>

<p style="margin-left:17%;">Described in perlapio.</p>

<h2>Integer
<a name="Integer"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;CASTI32&quot;</p>

<p style="margin-left:17%;">This symbol is defined if the C
compiler can cast negative or large floating point numbers
to 32&minus;bit ints.</p>

<p style="margin-left:11%;">&quot;HAS_INT64_T&quot;</p>

<p style="margin-left:17%;">This symbol will defined if the
C compiler supports &quot;int64_t&quot;. Usually the
<i>inttypes.h</i> needs to be included, but sometimes
<i>sys/types.h</i> is enough.</p>

<p style="margin-left:11%;">&quot;HAS_LONG_LONG&quot;</p>

<p style="margin-left:17%;">This symbol will be defined if
the C compiler supports long long.</p>

<p style="margin-left:11%;">&quot;HAS_QUAD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined, tells
that there&rsquo;s a 64&minus;bit integer type,
&quot;Quad_t&quot;, and its unsigned counterpart,
&quot;Uquad_t&quot;. &quot;QUADKIND&quot; will be one of
&quot;QUAD_IS_INT&quot;, &quot;QUAD_IS_LONG&quot;,
&quot;QUAD_IS_LONG_LONG&quot;, &quot;QUAD_IS_INT64_T&quot;,
or &quot;QUAD_IS___INT64&quot;.</p>

<p style="margin-left:11%;">&quot;I8&quot; <br>
&quot;I16&quot; <br>
&quot;I32&quot; <br>
&quot;I64&quot; <br>
&quot;IV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;I32SIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(I32)&quot;.</p>

<p style="margin-left:11%;">&quot;I32TYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s I32.</p>

<p style="margin-left:11%;">&quot;I64SIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(I64)&quot;.</p>

<p style="margin-left:11%;">&quot;I64TYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s I64.</p>

<p style="margin-left:11%;">&quot;I16SIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(I16)&quot;.</p>

<p style="margin-left:11%;">&quot;I16TYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s I16.</p>

<p style="margin-left:11%;">&quot;INT16_C&quot; <br>
&quot;INT32_C&quot; <br>
&quot;INT64_C&quot;</p>

<p style="margin-left:17%;">Returns a token the C compiler
recognizes for the constant &quot;number&quot; of the
corresponding integer type on the machine.</p>

<p style="margin-left:17%; margin-top: 1em">If the machine
does not have a 64&minus;bit type, &quot;INT64_C&quot; is
undefined. Use &quot;INTMAX_C&quot; to get the largest type
available on the platform.</p>

<p style="margin-left:17%; margin-top: 1em">I16
INT16_C(number) <br>
I32 INT32_C(number) <br>
I64 INT64_C(number)</p>

<p style="margin-left:11%;">&quot;INTMAX_C&quot;</p>

<p style="margin-left:17%;">Returns a token the C compiler
recognizes for the constant &quot;number&quot; of the widest
integer type on the machine. For example, if the machine has
&quot;long long&quot;s, &quot;INTMAX_C(&minus;1)&quot; would
yield</p>

<p style="margin-left:17%; margin-top: 1em">&minus;1LL</p>

<p style="margin-left:17%; margin-top: 1em">See also, for
example, &quot;INT32_C&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Use &quot;
<small>IV&quot;</small> to declare variables of the maximum
usable size on this platform.</p>


<p style="margin-left:17%; margin-top: 1em">INTMAX_C(number)</p>

<p style="margin-left:11%;">&quot;INTSIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the value
of &quot;sizeof(int)&quot; so that the C preprocessor can
make decisions based on it.</p>

<p style="margin-left:11%;">&quot;I8SIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(I8)&quot;.</p>

<p style="margin-left:11%;">&quot;I8TYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s I8.</p>

<p style="margin-left:11%;">&quot;IV_MAX&quot;</p>

<p style="margin-left:17%;">The largest signed integer that
fits in an <small>IV</small> on this platform.</p>

<p style="margin-left:17%; margin-top: 1em">IV IV_MAX</p>

<p style="margin-left:11%;">&quot;IV_MIN&quot;</p>

<p style="margin-left:17%;">The negative signed integer
furthest away from 0 that fits in an <small>IV</small> on
this platform.</p>

<p style="margin-left:17%; margin-top: 1em">IV IV_MIN</p>

<p style="margin-left:11%;">&quot;IVSIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(IV)&quot;.</p>

<p style="margin-left:11%;">&quot;IVTYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s <small>IV.</small></p>

<p style="margin-left:11%;">&quot;line_t&quot;</p>

<p style="margin-left:17%;">The typedef to use to declare
variables that are to hold line numbers.</p>

<p style="margin-left:11%;">&quot;LONGLONGSIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the size
of a long long, so that the C preprocessor can make
decisions based on it. It is only defined if the system
supports long long.</p>

<p style="margin-left:11%;">&quot;LONGSIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the value
of &quot;sizeof(long)&quot; so that the C preprocessor can
make decisions based on it.</p>

<p style="margin-left:11%;">&quot;memzero&quot;</p>

<p style="margin-left:17%;">Set the &quot;l&quot; bytes
starting at *d to all zeroes.</p>

<p style="margin-left:17%; margin-top: 1em">void
memzero(void * d, Size_t l)</p>

<p style="margin-left:11%;">&quot;PERL_INT_FAST8_T&quot;
<br>
&quot;PERL_INT_FAST16_T&quot; <br>
&quot;PERL_UINT_FAST8_T&quot; <br>
&quot;PERL_UINT_FAST16_T&quot;</p>

<p style="margin-left:17%;">These are equivalent to the
correspondingly-named C99 typedefs on platforms that have
those; they evaluate to &quot;int&quot; and &quot;unsigned
int&quot; on platforms that don&rsquo;t, so that you can
portably take advantage of this C99 feature.</p>

<p style="margin-left:11%;">&quot;PERL_INT_MAX&quot; <br>
&quot;PERL_INT_MIN&quot; <br>
&quot;PERL_LONG_MAX&quot; <br>
&quot;PERL_LONG_MIN&quot; <br>
&quot;PERL_SHORT_MAX&quot; <br>
&quot;PERL_SHORT_MIN&quot; <br>
&quot;PERL_UCHAR_MAX&quot; <br>
&quot;PERL_UCHAR_MIN&quot; <br>
&quot;PERL_UINT_MAX&quot; <br>
&quot;PERL_UINT_MIN&quot; <br>
&quot;PERL_ULONG_MAX&quot; <br>
&quot;PERL_ULONG_MIN&quot; <br>
&quot;PERL_USHORT_MAX&quot; <br>
&quot;PERL_USHORT_MIN&quot; <br>
&quot;PERL_QUAD_MAX&quot; <br>
&quot;PERL_QUAD_MIN&quot; <br>
&quot;PERL_UQUAD_MAX&quot; <br>
&quot;PERL_UQUAD_MIN&quot;</p>

<p style="margin-left:17%;">These give the largest and
smallest number representable in the current platform in
variables of the corresponding types.</p>

<p style="margin-left:17%; margin-top: 1em">For signed
types, the smallest representable number is the most
negative number, the one furthest away from zero.</p>

<p style="margin-left:17%; margin-top: 1em">For C99 and
later compilers, these correspond to things like
&quot;INT_MAX&quot;, which are available to the C code. But
these constants, furnished by Perl, allow code compiled on
earlier compilers to portably have access to the same
constants.</p>

<p style="margin-left:11%;">&quot;SHORTSIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the value
of &quot;sizeof(short)&quot; so that the C preprocessor can
make decisions based on it.</p>

<p style="margin-left:11%;">&quot;U8&quot; <br>
&quot;U16&quot; <br>
&quot;U32&quot; <br>
&quot;U64&quot; <br>
&quot;UV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;U32SIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(U32)&quot;.</p>

<p style="margin-left:11%;">&quot;U32TYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s U32.</p>

<p style="margin-left:11%;">&quot;U64SIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(U64)&quot;.</p>

<p style="margin-left:11%;">&quot;U64TYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s U64.</p>

<p style="margin-left:11%;">&quot;U16SIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(U16)&quot;.</p>

<p style="margin-left:11%;">&quot;U16TYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s U16.</p>

<p style="margin-left:11%;">&quot;UINT16_C&quot; <br>
&quot;UINT32_C&quot; <br>
&quot;UINT64_C&quot;</p>

<p style="margin-left:17%;">Returns a token the C compiler
recognizes for the constant &quot;number&quot; of the
corresponding unsigned integer type on the machine.</p>

<p style="margin-left:17%; margin-top: 1em">If the machine
does not have a 64&minus;bit type, &quot;UINT64_C&quot; is
undefined. Use &quot;UINTMAX_C&quot; to get the largest type
available on the platform.</p>

<p style="margin-left:17%; margin-top: 1em">U16
UINT16_C(number) <br>
U32 UINT32_C(number) <br>
U64 UINT64_C(number)</p>

<p style="margin-left:11%;">&quot;UINTMAX_C&quot;</p>

<p style="margin-left:17%;">Returns a token the C compiler
recognizes for the constant &quot;number&quot; of the widest
unsigned integer type on the machine. For example, if the
machine has &quot;long&quot;s, UINTMAX_C(1) would yield</p>

<p style="margin-left:17%; margin-top: 1em">1UL</p>

<p style="margin-left:17%; margin-top: 1em">See also, for
example, &quot;UINT32_C&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Use &quot;
<small>UV&quot;</small> to declare variables of the maximum
usable size on this platform.</p>


<p style="margin-left:17%; margin-top: 1em">UINTMAX_C(number)</p>

<p style="margin-left:11%;">&quot;U8SIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(U8)&quot;.</p>

<p style="margin-left:11%;">&quot;U8TYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s U8.</p>

<p style="margin-left:11%;">&quot;UV_MAX&quot;</p>

<p style="margin-left:17%;">The largest unsigned integer
that fits in a <small>UV</small> on this platform.</p>

<p style="margin-left:17%; margin-top: 1em">UV UV_MAX</p>

<p style="margin-left:11%;">&quot;UV_MIN&quot;</p>

<p style="margin-left:17%;">The smallest unsigned integer
that fits in a <small>UV</small> on this platform. It should
equal zero.</p>

<p style="margin-left:17%; margin-top: 1em">UV UV_MIN</p>

<p style="margin-left:11%;">&quot;UVSIZE&quot;</p>

<p style="margin-left:17%;">This symbol contains the
&quot;sizeof(UV)&quot;.</p>

<p style="margin-left:11%;">&quot;UVTYPE&quot;</p>

<p style="margin-left:17%;">This symbol defines the C type
used for Perl&rsquo;s <small>UV.</small></p>

<p style="margin-left:11%;">&quot;WIDEST_UTYPE&quot;</p>

<p style="margin-left:17%;">Yields the widest unsigned
integer type on the platform, currently either
&quot;U32&quot; or &quot;U64&quot;. This can be used in
declarations such as</p>

<p style="margin-left:17%; margin-top: 1em">WIDEST_UTYPE
my_uv;</p>

<p style="margin-left:17%; margin-top: 1em">or casts</p>

<p style="margin-left:17%; margin-top: 1em">my_uv =
(WIDEST_UTYPE) val;</p>

<h2>I/O Formats
<a name="I/O Formats"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These are used
for formatting the corresponding type For example, instead
of saying</p>


<p style="margin-left:11%; margin-top: 1em">Perl_newSVpvf(pTHX_
&quot;Create an SV with a %d in it\n&quot;, iv);</p>

<p style="margin-left:11%; margin-top: 1em">use</p>


<p style="margin-left:11%; margin-top: 1em">Perl_newSVpvf(pTHX_
&quot;Create an SV with a &quot; IVdf &quot; in it\n&quot;,
iv);</p>

<p style="margin-left:11%; margin-top: 1em">This keeps you
from having to know if, say an <small>IV,</small> needs to
be printed as %d, %ld, or something else. <br>
&quot;IVdf&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a Perl <small>IV</small> as a
signed decimal integer.</p>

<p style="margin-left:11%;">&quot;NVef&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a Perl <small>NV</small> using
%e&minus;ish floating point format.</p>

<p style="margin-left:11%;">&quot;NVff&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a Perl <small>NV</small> using
%f&minus;ish floating point format.</p>

<p style="margin-left:11%;">&quot;NVgf&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a Perl <small>NV</small> using
%g&minus;ish floating point format.</p>

<p style="margin-left:11%;">&quot;PERL_PRIeldbl&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
contains the string used by stdio to format long doubles
(format &rsquo;e&rsquo;) for output.</p>

<p style="margin-left:11%;">&quot;PERL_PRIfldbl&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
contains the string used by stdio to format long doubles
(format &rsquo;f&rsquo;) for output.</p>

<p style="margin-left:11%;">&quot;PERL_PRIgldbl&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
contains the string used by stdio to format long doubles
(format &rsquo;g&rsquo;) for output.</p>

<p style="margin-left:11%;">&quot;PERL_SCNfldbl&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
contains the string used by stdio to format long doubles
(format &rsquo;f&rsquo;) for input.</p>


<p style="margin-left:11%;">&quot;PRINTF_FORMAT_NULL_OK&quot;</p>

<p style="margin-left:17%;">Allows &quot;__printf__&quot;
format to be null when checking printf-style</p>

<p style="margin-left:11%;">&quot;SVf&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;SVfARG&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">SVfARG(SV
*sv)</p>

<p style="margin-left:11%;">&quot;UTF8f&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;UTF8fARG&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">UTF8fARG(bool
is_utf8, Size_t byte_len, char *str)</p>

<p style="margin-left:11%;">&quot;UVf&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;UVf&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Obsolete form
of &quot;UVuf&quot;, which you should convert to instead
use</p>

<p style="margin-left:17%; margin-top: 1em">const char *
UVf</p>

<p style="margin-left:11%;">&quot;UVof&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a Perl <small>UV</small> as an
unsigned octal integer.</p>

<p style="margin-left:11%;">&quot;UVuf&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a Perl <small>UV</small> as an
unsigned decimal integer.</p>

<p style="margin-left:11%;">&quot;UVXf&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a Perl <small>UV</small> as an
unsigned hexadecimal integer in uppercase
&quot;ABCDEF&quot;.</p>

<p style="margin-left:11%;">&quot;UVxf&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a Perl <small>UV</small> as an
unsigned hexadecimal integer in lowercase abcdef.</p>

<h2>Lexer interface
<a name="Lexer interface"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is the
lower layer of the Perl parser, managing characters and
tokens. <br>
&quot;BHK&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;lex_bufutf8&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_bufutf8&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Indicates
whether the octets in the lexer buffer
(&quot;PL_parser&minus;&gt;linestr&quot;) should be
interpreted as the <small>UTF&minus;8</small> encoding of
Unicode characters. If not, they should be interpreted as
Latin&minus;1 characters. This is analogous to the
&quot;SvUTF8&quot; flag for scalars.</p>

<p style="margin-left:17%; margin-top: 1em">In
<small>UTF&minus;8</small> mode, it is not guaranteed that
the lexer buffer actually contains valid
<small>UTF&minus;8.</small> Lexing code must be robust in
the face of invalid encoding.</p>

<p style="margin-left:17%; margin-top: 1em">The actual
&quot;SvUTF8&quot; flag of the
&quot;PL_parser&minus;&gt;linestr&quot; scalar is
significant, but not the whole story regarding the input
character encoding. Normally, when a file is being read, the
scalar contains octets and its &quot;SvUTF8&quot; flag is
off, but the octets should be interpreted as
<small>UTF&minus;8</small> if the &quot;use utf8&quot;
pragma is in effect. During a string eval, however, the
scalar may have the &quot;SvUTF8&quot; flag on, and in this
case its octets should be interpreted as
<small>UTF&minus;8</small> unless the &quot;use bytes&quot;
pragma is in effect. This logic may change in the future;
use this function instead of implementing the logic
yourself.</p>

<p style="margin-left:17%; margin-top: 1em">bool
lex_bufutf8()</p>

<p style="margin-left:11%;">&quot;lex_discard_to&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_discard_to&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Discards the
first part of the &quot;PL_parser&minus;&gt;linestr&quot;
buffer, up to &quot;ptr&quot;. The remaining content of the
buffer will be moved, and all pointers into the buffer
updated appropriately. &quot;ptr&quot; must not be later in
the buffer than the position of
&quot;PL_parser&minus;&gt;bufptr&quot;: it is not permitted
to discard text that has yet to be lexed.</p>

<p style="margin-left:17%; margin-top: 1em">Normally it is
not necessarily to do this directly, because it suffices to
use the implicit discarding behaviour of
&quot;lex_next_chunk&quot; and things based on it. However,
if a token stretches across multiple lines, and the lexing
code has kept multiple lines of text in the buffer for that
purpose, then after completion of the token it would be wise
to explicitly discard the now-unneeded earlier lines, to
avoid future multi-line tokens growing the buffer without
bound.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_discard_to(char* ptr)</p>


<p style="margin-left:11%;">&quot;lex_grow_linestr&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_grow_linestr&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Reallocates the
lexer buffer (&quot;PL_parser&minus;&gt;linestr&quot;) to
accommodate at least &quot;len&quot; octets (including
terminating &quot;NUL&quot;). Returns a pointer to the
reallocated buffer. This is necessary before making any
direct modification of the buffer that would increase its
length. &quot;lex_stuff_pvn&quot; provides a more convenient
way to insert text into the buffer.</p>

<p style="margin-left:17%; margin-top: 1em">Do not use
&quot;SvGROW&quot; or &quot;sv_grow&quot; directly on
&quot;PL_parser&minus;&gt;linestr&quot;; this function
updates all of the lexer&rsquo;s variables that point
directly into the buffer.</p>

<p style="margin-left:17%; margin-top: 1em">char*
lex_grow_linestr(STRLEN len)</p>

<p style="margin-left:11%;">&quot;lex_next_chunk&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_next_chunk&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Reads in the
next chunk of text to be lexed, appending it to
&quot;PL_parser&minus;&gt;linestr&quot;. This should be
called when lexing code has looked to the end of the current
chunk and wants to know more. It is usual, but not
necessary, for lexing to have consumed the entirety of the
current chunk at this time.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PL_parser&minus;&gt;bufptr&quot; is pointing to the
very end of the current chunk (i.e., the current chunk has
been entirely consumed), normally the current chunk will be
discarded at the same time that the new chunk is read in. If
&quot;flags&quot; has the &quot;LEX_KEEP_PREVIOUS&quot; bit
set, the current chunk will not be discarded. If the current
chunk has not been entirely consumed, then it will not be
discarded regardless of the flag.</p>

<p style="margin-left:17%; margin-top: 1em">Returns true if
some new text was added to the buffer, or false if the
buffer has reached the end of the input text.</p>

<p style="margin-left:17%; margin-top: 1em">bool
lex_next_chunk(U32 flags)</p>


<p style="margin-left:11%;">&quot;lex_peek_unichar&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_peek_unichar&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Looks ahead one
(Unicode) character in the text currently being lexed.
Returns the codepoint (unsigned integer value) of the next
character, or &minus;1 if lexing has reached the end of the
input text. To consume the peeked character, use
&quot;lex_read_unichar&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If the next
character is in (or extends into) the next chunk of input
text, the next chunk will be read in. Normally the current
chunk will be discarded at the same time, but if
&quot;flags&quot; has the &quot;LEX_KEEP_PREVIOUS&quot; bit
set, then the current chunk will not be discarded.</p>

<p style="margin-left:17%; margin-top: 1em">If the input is
being interpreted as <small>UTF&minus;8</small> and a
<small>UTF&minus;8</small> encoding error is encountered, an
exception is generated.</p>

<p style="margin-left:17%; margin-top: 1em">I32
lex_peek_unichar(U32 flags)</p>

<p style="margin-left:11%;">&quot;lex_read_space&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_read_space&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Reads optional
spaces, in Perl style, in the text currently being lexed.
The spaces may include ordinary whitespace characters and
Perl-style comments. &quot;#line&quot; directives are
processed if encountered.
&quot;PL_parser&minus;&gt;bufptr&quot; is moved past the
spaces, so that it points at a non-space character (or the
end of the input text).</p>

<p style="margin-left:17%; margin-top: 1em">If spaces
extend into the next chunk of input text, the next chunk
will be read in. Normally the current chunk will be
discarded at the same time, but if &quot;flags&quot; has the
&quot;LEX_KEEP_PREVIOUS&quot; bit set, then the current
chunk will not be discarded.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_read_space(U32 flags)</p>

<p style="margin-left:11%;">&quot;lex_read_to&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_read_to&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Consume text in
the lexer buffer, from
&quot;PL_parser&minus;&gt;bufptr&quot; up to
&quot;ptr&quot;. This advances
&quot;PL_parser&minus;&gt;bufptr&quot; to match
&quot;ptr&quot;, performing the correct bookkeeping whenever
a newline character is passed. This is the normal way to
consume lexed text.</p>

<p style="margin-left:17%; margin-top: 1em">Interpretation
of the buffer&rsquo;s octets can be abstracted out by using
the slightly higher-level functions
&quot;lex_peek_unichar&quot; and
&quot;lex_read_unichar&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_read_to(char* ptr)</p>


<p style="margin-left:11%;">&quot;lex_read_unichar&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_read_unichar&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Reads the next
(Unicode) character in the text currently being lexed.
Returns the codepoint (unsigned integer value) of the
character read, and moves
&quot;PL_parser&minus;&gt;bufptr&quot; past the character,
or returns &minus;1 if lexing has reached the end of the
input text. To non-destructively examine the next character,
use &quot;lex_peek_unichar&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">If the next
character is in (or extends into) the next chunk of input
text, the next chunk will be read in. Normally the current
chunk will be discarded at the same time, but if
&quot;flags&quot; has the &quot;LEX_KEEP_PREVIOUS&quot; bit
set, then the current chunk will not be discarded.</p>

<p style="margin-left:17%; margin-top: 1em">If the input is
being interpreted as <small>UTF&minus;8</small> and a
<small>UTF&minus;8</small> encoding error is encountered, an
exception is generated.</p>

<p style="margin-left:17%; margin-top: 1em">I32
lex_read_unichar(U32 flags)</p>

<p style="margin-left:11%;">&quot;lex_start&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_start&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Creates and
initialises a new lexer/parser state object, supplying a
context in which to lex and parse from a new source of Perl
code. A pointer to the new state object is placed in
&quot;PL_parser&quot;. An entry is made on the save stack so
that upon unwinding, the new state object will be destroyed
and the former value of &quot;PL_parser&quot; will be
restored. Nothing else need be done to clean up the parsing
context.</p>

<p style="margin-left:17%; margin-top: 1em">The code to be
parsed comes from &quot;line&quot; and &quot;rsfp&quot;.
&quot;line&quot;, if non-null, provides a string (in
<small>SV</small> form) containing code to be parsed. A copy
of the string is made, so subsequent modification of
&quot;line&quot; does not affect parsing. &quot;rsfp&quot;,
if non-null, provides an input stream from which code will
be read to be parsed. If both are non-null, the code in
&quot;line&quot; comes first and must consist of complete
lines of input, and &quot;rsfp&quot; supplies the remainder
of the source.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; parameter is reserved for future use.
Currently it is only used by perl internally, so extensions
should always pass zero.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_start(SV* line, PerlIO *rsfp, U32 flags)</p>

<p style="margin-left:11%;">&quot;lex_stuff_pv&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_stuff_pv&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Insert
characters into the lexer buffer
(&quot;PL_parser&minus;&gt;linestr&quot;), immediately after
the current lexing point
(&quot;PL_parser&minus;&gt;bufptr&quot;), reallocating the
buffer if necessary. This means that lexing code that runs
later will see the characters as if they had appeared in the
input. It is not recommended to do this as part of normal
parsing, and most uses of this facility run the risk of the
inserted characters being interpreted in an unintended
manner.</p>

<p style="margin-left:17%; margin-top: 1em">The string to
be inserted is represented by octets starting at
&quot;pv&quot; and continuing to the first nul. These octets
are interpreted as either <small>UTF&minus;8</small> or
Latin&minus;1, according to whether the
&quot;LEX_STUFF_UTF8&quot; flag is set in &quot;flags&quot;.
The characters are recoded for the lexer buffer, according
to how the buffer is currently being interpreted
(&quot;lex_bufutf8&quot;). If it is not convenient to
nul-terminate a string to be inserted, the
&quot;lex_stuff_pvn&quot; function is more appropriate.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_stuff_pv(const char* pv, U32 flags)</p>

<p style="margin-left:11%;">&quot;lex_stuff_pvn&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_stuff_pvn&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Insert
characters into the lexer buffer
(&quot;PL_parser&minus;&gt;linestr&quot;), immediately after
the current lexing point
(&quot;PL_parser&minus;&gt;bufptr&quot;), reallocating the
buffer if necessary. This means that lexing code that runs
later will see the characters as if they had appeared in the
input. It is not recommended to do this as part of normal
parsing, and most uses of this facility run the risk of the
inserted characters being interpreted in an unintended
manner.</p>

<p style="margin-left:17%; margin-top: 1em">The string to
be inserted is represented by &quot;len&quot; octets
starting at &quot;pv&quot;. These octets are interpreted as
either <small>UTF&minus;8</small> or Latin&minus;1,
according to whether the &quot;LEX_STUFF_UTF8&quot; flag is
set in &quot;flags&quot;. The characters are recoded for the
lexer buffer, according to how the buffer is currently being
interpreted (&quot;lex_bufutf8&quot;). If a string to be
inserted is available as a Perl scalar, the
&quot;lex_stuff_sv&quot; function is more convenient.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_stuff_pvn(const char* pv, STRLEN len, U32 flags)</p>

<p style="margin-left:11%;">&quot;lex_stuff_pvs&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_stuff_pvs&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Like
&quot;lex_stuff_pvn&quot;, but takes a literal string
instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_stuff_pvs(&quot;pv&quot;, U32 flags)</p>

<p style="margin-left:11%;">&quot;lex_stuff_sv&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_stuff_sv&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Insert
characters into the lexer buffer
(&quot;PL_parser&minus;&gt;linestr&quot;), immediately after
the current lexing point
(&quot;PL_parser&minus;&gt;bufptr&quot;), reallocating the
buffer if necessary. This means that lexing code that runs
later will see the characters as if they had appeared in the
input. It is not recommended to do this as part of normal
parsing, and most uses of this facility run the risk of the
inserted characters being interpreted in an unintended
manner.</p>

<p style="margin-left:17%; margin-top: 1em">The string to
be inserted is the string value of &quot;sv&quot;. The
characters are recoded for the lexer buffer, according to
how the buffer is currently being interpreted
(&quot;lex_bufutf8&quot;). If a string to be inserted is not
already a Perl scalar, the &quot;lex_stuff_pvn&quot;
function avoids the need to construct a scalar.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_stuff_sv(SV* sv, U32 flags)</p>

<p style="margin-left:11%;">&quot;lex_unstuff&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;lex_unstuff&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Discards text
about to be lexed, from
&quot;PL_parser&minus;&gt;bufptr&quot; up to
&quot;ptr&quot;. Text following &quot;ptr&quot; will be
moved, and the buffer shortened. This hides the discarded
text from any lexing code that runs later, as if the text
had never appeared.</p>

<p style="margin-left:17%; margin-top: 1em">This is not the
normal way to consume lexed text. For that, use
&quot;lex_read_to&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
lex_unstuff(char* ptr)</p>


<p style="margin-left:11%;">&quot;parse_arithexpr&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_arithexpr&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a Perl
arithmetic expression. This may contain operators of
precedence down to the bit shift operators. The expression
must be followed (and thus terminated) either by a
comparison or lower-precedence operator or by something that
would normally terminate an expression such as semicolon. If
&quot;flags&quot; has the &quot;PARSE_OPTIONAL&quot; bit
set, then the expression is optional, otherwise it is
mandatory. It is up to the caller to ensure that the dynamic
parser state (&quot;PL_parser&quot; et al) is correctly set
to reflect the source of the code to be parsed and the
lexical context for the expression.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree
representing the expression is returned. If an optional
expression is absent, a null pointer is returned, otherwise
the pointer will be non-null.</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing or compilation, in most cases a valid op
tree is returned anyway. The error is reflected in the
parser state, normally resulting in a single exception at
the top level of parsing which covers all the compilation
errors that occurred. Some compilation errors, however, will
throw an exception immediately.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_arithexpr(U32 flags)</p>

<p style="margin-left:11%;">&quot;parse_barestmt&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_barestmt&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a single
unadorned Perl statement. This may be a normal imperative
statement or a declaration that has compile-time effect. It
does not include any label or other affixture. It is up to
the caller to ensure that the dynamic parser state
(&quot;PL_parser&quot; et al) is correctly set to reflect
the source of the code to be parsed and the lexical context
for the statement.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree
representing the statement is returned. This may be a null
pointer if the statement is null, for example if it was
actually a subroutine definition (which has compile-time
side effects). If not null, it will be ops directly
implementing the statement, suitable to pass to
&quot;newSTATEOP&quot;. It will not normally include a
&quot;nextstate&quot; or equivalent op (except for those
embedded in a scope contained entirely within the
statement).</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway. The error is
reflected in the parser state, normally resulting in a
single exception at the top level of parsing which covers
all the compilation errors that occurred. Some compilation
errors, however, will throw an exception immediately.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; parameter is reserved for future use, and
must always be zero.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_barestmt(U32 flags)</p>

<p style="margin-left:11%;">&quot;parse_block&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_block&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a single
complete Perl code block. This consists of an opening brace,
a sequence of statements, and a closing brace. The block
constitutes a lexical scope, so &quot;my&quot; variables and
various compile-time effects can be contained within it. It
is up to the caller to ensure that the dynamic parser state
(&quot;PL_parser&quot; et al) is correctly set to reflect
the source of the code to be parsed and the lexical context
for the statement.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree
representing the code block is returned. This is always a
real op, never a null pointer. It will normally be a
&quot;lineseq&quot; list, including &quot;nextstate&quot; or
equivalent ops. No ops to construct any kind of runtime
scope are included by virtue of it being a block.</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway. The error is
reflected in the parser state, normally resulting in a
single exception at the top level of parsing which covers
all the compilation errors that occurred. Some compilation
errors, however, will throw an exception immediately.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; parameter is reserved for future use, and
must always be zero.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_block(U32 flags)</p>

<p style="margin-left:11%;">&quot;parse_fullexpr&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_fullexpr&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a single
complete Perl expression. This allows the full expression
grammar, including the lowest-precedence operators such as
&quot;or&quot;. The expression must be followed (and thus
terminated) by a token that an expression would normally be
terminated by: end-of-file, closing bracketing punctuation,
semicolon, or one of the keywords that signals a postfix
expression-statement modifier. If &quot;flags&quot; has the
&quot;PARSE_OPTIONAL&quot; bit set, then the expression is
optional, otherwise it is mandatory. It is up to the caller
to ensure that the dynamic parser state
(&quot;PL_parser&quot; et al) is correctly set to reflect
the source of the code to be parsed and the lexical context
for the expression.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree
representing the expression is returned. If an optional
expression is absent, a null pointer is returned, otherwise
the pointer will be non-null.</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing or compilation, in most cases a valid op
tree is returned anyway. The error is reflected in the
parser state, normally resulting in a single exception at
the top level of parsing which covers all the compilation
errors that occurred. Some compilation errors, however, will
throw an exception immediately.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_fullexpr(U32 flags)</p>

<p style="margin-left:11%;">&quot;parse_fullstmt&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_fullstmt&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a single
complete Perl statement. This may be a normal imperative
statement or a declaration that has compile-time effect, and
may include optional labels. It is up to the caller to
ensure that the dynamic parser state (&quot;PL_parser&quot;
et al) is correctly set to reflect the source of the code to
be parsed and the lexical context for the statement.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree
representing the statement is returned. This may be a null
pointer if the statement is null, for example if it was
actually a subroutine definition (which has compile-time
side effects). If not null, it will be the result of a
&quot;newSTATEOP&quot; call, normally including a
&quot;nextstate&quot; or equivalent op.</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway. The error is
reflected in the parser state, normally resulting in a
single exception at the top level of parsing which covers
all the compilation errors that occurred. Some compilation
errors, however, will throw an exception immediately.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; parameter is reserved for future use, and
must always be zero.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_fullstmt(U32 flags)</p>

<p style="margin-left:11%;">&quot;parse_label&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_label&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a single
label, possibly optional, of the type that may prefix a Perl
statement. It is up to the caller to ensure that the dynamic
parser state (&quot;PL_parser&quot; et al) is correctly set
to reflect the source of the code to be parsed. If
&quot;flags&quot; has the &quot;PARSE_OPTIONAL&quot; bit
set, then the label is optional, otherwise it is
mandatory.</p>

<p style="margin-left:17%; margin-top: 1em">The name of the
label is returned in the form of a fresh scalar. If an
optional label is absent, a null pointer is returned.</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing, which can only occur if the label is
mandatory, a valid label is returned anyway. The error is
reflected in the parser state, normally resulting in a
single exception at the top level of parsing which covers
all the compilation errors that occurred.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
parse_label(U32 flags)</p>

<p style="margin-left:11%;">&quot;parse_listexpr&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_listexpr&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a Perl
list expression. This may contain operators of precedence
down to the comma operator. The expression must be followed
(and thus terminated) either by a low-precedence logic
operator such as &quot;or&quot; or by something that would
normally terminate an expression such as semicolon. If
&quot;flags&quot; has the &quot;PARSE_OPTIONAL&quot; bit
set, then the expression is optional, otherwise it is
mandatory. It is up to the caller to ensure that the dynamic
parser state (&quot;PL_parser&quot; et al) is correctly set
to reflect the source of the code to be parsed and the
lexical context for the expression.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree
representing the expression is returned. If an optional
expression is absent, a null pointer is returned, otherwise
the pointer will be non-null.</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing or compilation, in most cases a valid op
tree is returned anyway. The error is reflected in the
parser state, normally resulting in a single exception at
the top level of parsing which covers all the compilation
errors that occurred. Some compilation errors, however, will
throw an exception immediately.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_listexpr(U32 flags)</p>

<p style="margin-left:11%;">&quot;parse_stmtseq&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_stmtseq&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a
sequence of zero or more Perl statements. These may be
normal imperative statements, including optional labels, or
declarations that have compile-time effect, or any mixture
thereof. The statement sequence ends when a closing brace or
end-of-file is encountered in a place where a new statement
could have validly started. It is up to the caller to ensure
that the dynamic parser state (&quot;PL_parser&quot; et al)
is correctly set to reflect the source of the code to be
parsed and the lexical context for the statements.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree
representing the statement sequence is returned. This may be
a null pointer if the statements were all null, for example
if there were no statements or if there were only subroutine
definitions (which have compile-time side effects). If not
null, it will be a &quot;lineseq&quot; list, normally
including &quot;nextstate&quot; or equivalent ops.</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing or compilation, in most cases a valid op
tree is returned anyway. The error is reflected in the
parser state, normally resulting in a single exception at
the top level of parsing which covers all the compilation
errors that occurred. Some compilation errors, however, will
throw an exception immediately.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; parameter is reserved for future use, and
must always be zero.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_stmtseq(U32 flags)</p>


<p style="margin-left:11%;">&quot;parse_subsignature&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_subsignature&quot; is <b>experimental</b> and
may change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a
subroutine signature declaration. This is the contents of
the parentheses following a named or anonymous subroutine
declaration when the &quot;signatures&quot; feature is
enabled. Note that this function neither expects nor
consumes the opening and closing parentheses around the
signature; it is the caller&rsquo;s job to handle these.</p>

<p style="margin-left:17%; margin-top: 1em">This function
must only be called during parsing of a subroutine; after
&quot;start_subparse&quot; has been called. It might
allocate lexical variables on the pad for the current
subroutine.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree to
unpack the arguments from the stack at runtime is returned.
This op tree should appear at the beginning of the compiled
function. The caller may wish to use
&quot;op_append_list&quot; to build their function body
after it, or splice it together with the body before calling
&quot;newATTRSUB&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; parameter is reserved for future use, and
must always be zero.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_subsignature(U32 flags)</p>

<p style="margin-left:11%;">&quot;parse_termexpr&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;parse_termexpr&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Parse a Perl
term expression. This may contain operators of precedence
down to the assignment operators. The expression must be
followed (and thus terminated) either by a comma or
lower-precedence operator or by something that would
normally terminate an expression such as semicolon. If
&quot;flags&quot; has the &quot;PARSE_OPTIONAL&quot; bit
set, then the expression is optional, otherwise it is
mandatory. It is up to the caller to ensure that the dynamic
parser state (&quot;PL_parser&quot; et al) is correctly set
to reflect the source of the code to be parsed and the
lexical context for the expression.</p>

<p style="margin-left:17%; margin-top: 1em">The op tree
representing the expression is returned. If an optional
expression is absent, a null pointer is returned, otherwise
the pointer will be non-null.</p>

<p style="margin-left:17%; margin-top: 1em">If an error
occurs in parsing or compilation, in most cases a valid op
tree is returned anyway. The error is reflected in the
parser state, normally resulting in a single exception at
the top level of parsing which covers all the compilation
errors that occurred. Some compilation errors, however, will
throw an exception immediately.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
parse_termexpr(U32 flags)</p>

<p style="margin-left:11%;">&quot;PL_parser&quot;</p>

<p style="margin-left:17%;">Pointer to a structure
encapsulating the state of the parsing operation currently
in progress. The pointer can be locally changed to perform a
nested parse without interfering with the state of an outer
parse. Individual members of &quot;PL_parser&quot; have
their own documentation.</p>


<p style="margin-left:11%;">&quot;PL_parser&minus;&gt;bufend&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PL_parser&minus;&gt;bufend&quot; is
<b>experimental</b> and may change or be removed without
notice.</p>

<p style="margin-left:17%; margin-top: 1em">Direct pointer
to the end of the chunk of text currently being lexed, the
end of the lexer buffer. This is equal to
&quot;SvPVX(PL_parser&minus;&gt;linestr) +
SvCUR(PL_parser&minus;&gt;linestr)&quot;. A &quot;NUL&quot;
character (zero octet) is always located at the end of the
buffer, and does not count as part of the buffer&rsquo;s
contents.</p>


<p style="margin-left:11%;">&quot;PL_parser&minus;&gt;bufptr&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PL_parser&minus;&gt;bufptr&quot; is
<b>experimental</b> and may change or be removed without
notice.</p>

<p style="margin-left:17%; margin-top: 1em">Points to the
current position of lexing inside the lexer buffer.
Characters around this point may be freely examined, within
the range delimited by
&quot;SvPVX(&quot;PL_parser&minus;&gt;linestr&quot;)&quot;
and &quot;PL_parser&minus;&gt;bufend&quot;. The octets of
the buffer may be intended to be interpreted as either
<small>UTF&minus;8</small> or Latin&minus;1, as indicated by
&quot;lex_bufutf8&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Lexing code
(whether in the Perl core or not) moves this pointer past
the characters that it consumes. It is also expected to
perform some bookkeeping whenever a newline character is
consumed. This movement can be more conveniently performed
by the function &quot;lex_read_to&quot;, which handles
newlines appropriately.</p>

<p style="margin-left:17%; margin-top: 1em">Interpretation
of the buffer&rsquo;s octets can be abstracted out by using
the slightly higher-level functions
&quot;lex_peek_unichar&quot; and
&quot;lex_read_unichar&quot;.</p>


<p style="margin-left:11%;">&quot;PL_parser&minus;&gt;linestart&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PL_parser&minus;&gt;linestart&quot; is
<b>experimental</b> and may change or be removed without
notice.</p>

<p style="margin-left:17%; margin-top: 1em">Points to the
start of the current line inside the lexer buffer. This is
useful for indicating at which column an error occurred, and
not much else. This must be updated by any lexing code that
consumes a newline; the function &quot;lex_read_to&quot;
handles this detail.</p>


<p style="margin-left:11%;">&quot;PL_parser&minus;&gt;linestr&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PL_parser&minus;&gt;linestr&quot; is
<b>experimental</b> and may change or be removed without
notice.</p>

<p style="margin-left:17%; margin-top: 1em">Buffer scalar
containing the chunk currently under consideration of the
text currently being lexed. This is always a plain string
scalar (for which &quot;SvPOK&quot; is true). It is not
intended to be used as a scalar by normal scalar means;
instead refer to the buffer directly by the pointer
variables described below.</p>

<p style="margin-left:17%; margin-top: 1em">The lexer
maintains various &quot;char*&quot; pointers to things in
the &quot;PL_parser&minus;&gt;linestr&quot; buffer. If
&quot;PL_parser&minus;&gt;linestr&quot; is ever reallocated,
all of these pointers must be updated. Don&rsquo;t attempt
to do this manually, but rather use
&quot;lex_grow_linestr&quot; if you need to reallocate the
buffer.</p>

<p style="margin-left:17%; margin-top: 1em">The content of
the text chunk in the buffer is commonly exactly one
complete line of input, up to and including a newline
terminator, but there are situations where it is otherwise.
The octets of the buffer may be intended to be interpreted
as either <small>UTF&minus;8</small> or Latin&minus;1. The
function &quot;lex_bufutf8&quot; tells you which. Do not use
the &quot;SvUTF8&quot; flag on this scalar, which may
disagree with it.</p>

<p style="margin-left:17%; margin-top: 1em">For direct
examination of the buffer, the variable
&quot;PL_parser&minus;&gt;bufend&quot; points to the end of
the buffer. The current lexing position is pointed to by
&quot;PL_parser&minus;&gt;bufptr&quot;. Direct use of these
pointers is usually preferable to examination of the scalar
through normal scalar means.</p>


<p style="margin-left:11%;">&quot;wrap_keyword_plugin&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;wrap_keyword_plugin&quot; is <b>experimental</b> and
may change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Puts a C
function into the chain of keyword plugins. This is the
preferred way to manipulate the
&quot;PL_keyword_plugin&quot; variable.
&quot;new_plugin&quot; is a pointer to the C function that
is to be added to the keyword plugin chain, and
&quot;old_plugin_p&quot; points to the storage location
where a pointer to the next function in the chain will be
stored. The value of &quot;new_plugin&quot; is written into
the &quot;PL_keyword_plugin&quot; variable, while the value
previously stored there is written to *old_plugin_p.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;PL_keyword_plugin&quot;
is global to an entire process, and a module wishing to hook
keyword parsing may find itself invoked more than once per
process, typically in different threads. To handle that
situation, this function is idempotent. The location
*old_plugin_p must initially (once per process) contain a
null pointer. A C variable of static duration (declared at
file scope, typically also marked &quot;static&quot; to give
it internal linkage) will be implicitly initialised
appropriately, if it does not have an explicit initialiser.
This function will only actually modify the plugin chain if
it finds *old_plugin_p to be null. This function is also
thread safe on the small scale. It uses appropriate locking
to avoid race conditions in accessing
&quot;PL_keyword_plugin&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">When this
function is called, the function referenced by
&quot;new_plugin&quot; must be ready to be called, except
for *old_plugin_p being unfilled. In a threading situation,
&quot;new_plugin&quot; may be called immediately, even
before this function has returned. *old_plugin_p will always
be appropriately set before &quot;new_plugin&quot; is
called. If &quot;new_plugin&quot; decides not to do anything
special with the identifier that it is given (which is the
usual case for most calls to a keyword plugin), it must
chain the plugin function referenced by *old_plugin_p.</p>

<p style="margin-left:17%; margin-top: 1em">Taken all
together, <small>XS</small> code to install a keyword plugin
should typically look something like this:</p>

<p style="margin-left:17%; margin-top: 1em">static
Perl_keyword_plugin_t next_keyword_plugin; <br>
static OP *my_keyword_plugin(pTHX_ <br>
char *keyword_ptr, STRLEN keyword_len, OP **op_ptr) <br>
{ <br>
if (memEQs(keyword_ptr, keyword_len, <br>
&quot;my_new_keyword&quot;)) { <br>
... <br>
} else { <br>
return next_keyword_plugin(aTHX_ <br>
keyword_ptr, keyword_len, op_ptr); <br>
} <br>
} <br>
BOOT: <br>
wrap_keyword_plugin(my_keyword_plugin, <br>
&amp;next_keyword_plugin);</p>

<p style="margin-left:17%; margin-top: 1em">Direct access
to &quot;PL_keyword_plugin&quot; should be avoided.</p>

<p style="margin-left:17%; margin-top: 1em">void
wrap_keyword_plugin(Perl_keyword_plugin_t new_plugin, <br>
Perl_keyword_plugin_t *old_plugin_p)</p>

<h2>Locales
<a name="Locales"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;</p>

<p style="margin-left:17%;">This macro should be used as a
statement. It declares a private variable (whose name begins
with an underscore) that is needed by the other macros in
this section. Failing to include this correctly should lead
to a syntax error. For compatibility with C89 C compilers it
should be placed in a block before any executable
statements.</p>

<p style="margin-left:17%; margin-top: 1em">void
DECLARATION_FOR_LC_NUMERIC_MANIPULATION</p>

<p style="margin-left:11%;">&quot;foldEQ_locale&quot;</p>

<p style="margin-left:17%;">Returns true if the leading
&quot;len&quot; bytes of the strings &quot;s1&quot; and
&quot;s2&quot; are the same case-insensitively in the
current locale; false otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">I32
foldEQ_locale(const char* a, const char* b, I32 len)</p>

<p style="margin-left:11%;">&quot;HAS_DUPLOCALE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;duplocale&quot; routine is
available to duplicate a locale object.</p>

<p style="margin-left:11%;">&quot;HAS_FREELOCALE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;freelocale&quot; routine is
available to deallocates the resources associated with a
locale object.</p>


<p style="margin-left:11%;">&quot;HAS_LC_MONETARY_2008&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the localeconv routine is available and has
the additional members added in &quot;POSIX&quot;
1003.1&minus;2008.</p>

<p style="margin-left:11%;">&quot;HAS_LOCALECONV&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;localeconv&quot; routine is
available for numeric and monetary formatting
conventions.</p>


<p style="margin-left:11%;">&quot;HAS_LOCALECONV_L&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;localeconv_l&quot; routine is
available to query certain information about a locale.</p>

<p style="margin-left:11%;">&quot;HAS_NEWLOCALE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;newlocale&quot; routine is
available to return a new locale object or modify an
existing locale object.</p>


<p style="margin-left:11%;">&quot;HAS_NL_LANGINFO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;nl_langinfo&quot; routine is
available to return local data. You will also need
<i>langinfo.h</i> and therefore &quot;I_LANGINFO&quot;.</p>


<p style="margin-left:11%;">&quot;HAS_NL_LANGINFO_L&quot;</p>

<p style="margin-left:17%;">This symbol, when defined,
indicates presence of the &quot;nl_langinfo_l()&quot;
function</p>


<p style="margin-left:11%;">&quot;HAS_QUERYLOCALE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;querylocale&quot; routine is
available to return the name of the locale for a category
mask.</p>

<p style="margin-left:11%;">&quot;HAS_SETLOCALE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setlocale&quot; routine is
available to handle locale-specific ctype
implementations.</p>


<p style="margin-left:11%;">&quot;HAS_SETLOCALE_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setlocale_r&quot; routine is
available to setlocale re-entrantly.</p>


<p style="margin-left:11%;">&quot;HAS_THREAD_SAFE_NL_LANGINFO_L&quot;</p>

<p style="margin-left:17%;">This symbol, when defined,
indicates presence of the &quot;nl_langinfo_l()&quot;
function, and that it is thread-safe.</p>

<p style="margin-left:11%;">&quot;HAS_USELOCALE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;uselocale&quot; routine is
available to set the current locale for the calling
thread.</p>

<p style="margin-left:11%;">&quot;I_LANGINFO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>langinfo.h</i> exists and should be
included.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_LANGINFO <br>
#include &lt;langinfo.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_LOCALE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>locale.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef I_LOCALE
<br>
#include &lt;locale.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;IN_LOCALE&quot;</p>

<p style="margin-left:17%;">Evaluates to
<small>TRUE</small> if the plain locale pragma without a
parameter (&quot;use&nbsp;locale&quot;) is in effect.</p>

<p style="margin-left:17%; margin-top: 1em">bool
IN_LOCALE</p>


<p style="margin-left:11%;">&quot;IN_LOCALE_COMPILETIME&quot;</p>

<p style="margin-left:17%;">Evaluates to
<small>TRUE</small> if, when compiling a perl program
(including an &quot;eval&quot;) if the plain locale pragma
without a parameter (&quot;use&nbsp;locale&quot;) is in
effect.</p>

<p style="margin-left:17%; margin-top: 1em">bool
IN_LOCALE_COMPILETIME</p>


<p style="margin-left:11%;">&quot;IN_LOCALE_RUNTIME&quot;</p>

<p style="margin-left:17%;">Evaluates to
<small>TRUE</small> if, when executing a perl program
(including an &quot;eval&quot;) if the plain locale pragma
without a parameter (&quot;use&nbsp;locale&quot;) is in
effect.</p>

<p style="margin-left:17%; margin-top: 1em">bool
IN_LOCALE_RUNTIME</p>

<p style="margin-left:11%;">&quot;I_XLOCALE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that the header <i>xlocale.h</i>
is available. See also &quot;NEED_XLOCALE_H&quot;</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_XLOCALE <br>
#include &lt;xlocale.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;NEED_XLOCALE_H&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the C program should include <i>xlocale.h</i>
to get &quot;newlocale()&quot; and its friends.</p>

<p style="margin-left:11%;">&quot;Perl_langinfo&quot;</p>

<p style="margin-left:17%;">This is an (almost) drop-in
replacement for the system nl_langinfo(3), taking the same
&quot;item&quot; parameter values, and returning the same
information. But it is more thread-safe than regular
&quot;nl_langinfo()&quot;, and hides the quirks of
Perl&rsquo;s locale handling from your code, and can be used
on systems that lack a native &quot;nl_langinfo&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Expanding on
these:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>The reason it isn&rsquo;t quite a drop-in replacement is
actually an advantage. The only difference is that it
returns &quot;const&nbsp;char&nbsp;*&quot;, whereas plain
&quot;nl_langinfo()&quot; returns &quot;char&nbsp;*&quot;,
but you are (only by documentation) forbidden to write into
the buffer. By declaring this &quot;const&quot;, the
compiler enforces this restriction, so if it is violated,
you know at compilation time, rather than getting segfaults
at runtime.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>It delivers the correct results for the
&quot;RADIXCHAR&quot; and &quot;THOUSEP&quot; items, without
you having to write extra code. The reason for the extra
code would be because these are from the
&quot;LC_NUMERIC&quot; locale category, which is normally
kept set by Perl so that the radix is a dot, and the
separator is the empty string, no matter what the underlying
locale is supposed to be, and so to get the expected
results, you have to temporarily toggle into the underlying
locale, and later toggle back. (You could use plain
&quot;nl_langinfo&quot; and
&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot; for this
but then you wouldn&rsquo;t get the other advantages of
&quot;Perl_langinfo()&quot;; not keeping
&quot;LC_NUMERIC&quot; in the C (or equivalent) locale would
break a lot of <small>CPAN,</small> which is expecting the
radix (decimal point) character to be a dot.)</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>The system function it replaces can have its static
return buffer trashed, not only by a subsequent call to that
function, but by a &quot;freelocale&quot;,
&quot;setlocale&quot;, or other locale change. The returned
buffer of this function is not changed until the next call
to it, so the buffer is never in a trashed state.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Its return buffer is per-thread, so it also is never
overwritten by a call to this function from another thread;
unlike the function it replaces.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>But most importantly, it works on systems that
don&rsquo;t have &quot;nl_langinfo&quot;, such as Windows,
hence makes your code more portable. Of the fifty-some
possible items specified by the <small>POSIX 2008</small>
standard,
&lt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&gt;,
only one is completely unimplemented, though on non-Windows
platforms, another significant one is also not implemented).
It uses various techniques to recover the other items,
including calling localeconv(3), and strftime(3), both of
which are specified in C89, so should be always be
available. Later &quot;strftime()&quot; versions have
additional capabilities; &quot;&quot; is returned for those
not available on your system.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">It is important
to note that when called with an item that is recovered by
using &quot;localeconv&quot;, the buffer from any previous
explicit call to &quot;localeconv&quot; will be overwritten.
This means you must save that buffer&rsquo;s contents if you
need to access them after a call to this function. (But note
that you might not want to be using &quot;localeconv()&quot;
directly anyway, because of issues like the ones listed in
the second item of this list (above) for
&quot;RADIXCHAR&quot; and &quot;THOUSEP&quot;. You can use
the methods given in perlcall to call &quot;localeconv&quot;
in <small>POSIX</small> and avoid all the issues, but then
you have a hash to unpack).</p>

<p style="margin-left:23%; margin-top: 1em">The details for
those items which may deviate from what this emulation
returns and what a native &quot;nl_langinfo()&quot; would
return are specified in I18N::Langinfo.</p>

<p style="margin-left:17%; margin-top: 1em">When using
&quot;Perl_langinfo&quot; on systems that don&rsquo;t have a
native &quot;nl_langinfo()&quot;, you must</p>

<p style="margin-left:17%; margin-top: 1em">#include
&quot;perl_langinfo.h&quot;</p>

<p style="margin-left:17%; margin-top: 1em">before the
&quot;perl.h&quot; &quot;#include&quot;. You can replace
your &quot;langinfo.h&quot; &quot;#include&quot; with this
one. (Doing it this way keeps out the symbols that plain
&quot;langinfo.h&quot; would try to import into the
namespace for code that doesn&rsquo;t need it.)</p>

<p style="margin-left:17%; margin-top: 1em">The original
impetus for &quot;Perl_langinfo()&quot; was so that code
that needs to find out the current currency symbol, floating
point radix character, or digit grouping separator can use,
on all systems, the simpler and more thread-friendly
&quot;nl_langinfo&quot; <small>API</small> instead of
localeconv(3) which is a pain to make thread-friendly. For
other fields returned by &quot;localeconv&quot;, it is
better to use the methods given in perlcall to call
&quot;POSIX::localeconv()&quot;, which is
thread-friendly.</p>

<p style="margin-left:17%; margin-top: 1em">const char*
Perl_langinfo(const nl_item item)</p>

<p style="margin-left:11%;">&quot;Perl_setlocale&quot;</p>

<p style="margin-left:17%;">This is an (almost) drop-in
replacement for the system setlocale(3), taking the same
parameters, and returning the same information, except that
it returns the correct underlying &quot;LC_NUMERIC&quot;
locale. Regular &quot;setlocale&quot; will instead return
&quot;C&quot; if the underlying locale has a non-dot decimal
point character, or a non-empty thousands separator for
displaying floating point numbers. This is because perl
keeps that locale category such that it has a dot and empty
separator, changing the locale briefly during the operations
where the underlying one is required.
&quot;Perl_setlocale&quot; knows about this, and
compensates; regular &quot;setlocale&quot;
doesn&rsquo;t.</p>

<p style="margin-left:17%; margin-top: 1em">Another reason
it isn&rsquo;t completely a drop-in replacement is that it
is declared to return &quot;const&nbsp;char&nbsp;*&quot;,
whereas the system setlocale omits the &quot;const&quot;
(presumably because its <small>API</small> was specified
long ago, and can&rsquo;t be updated; it is illegal to
change the information &quot;setlocale&quot; returns; doing
so leads to segfaults.)</p>

<p style="margin-left:17%; margin-top: 1em">Finally,
&quot;Perl_setlocale&quot; works under all circumstances,
whereas plain &quot;setlocale&quot; can be completely
ineffective on some platforms under some configurations.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;Perl_setlocale&quot;
should not be used to change the locale except on systems
where the predefined variable &quot;${^SAFE_LOCALES}&quot;
is 1. On some such systems, the system
&quot;setlocale()&quot; is ineffective, returning the wrong
information, and failing to actually change the locale.
&quot;Perl_setlocale&quot;, however works properly in all
circumstances.</p>

<p style="margin-left:17%; margin-top: 1em">The return
points to a per-thread static buffer, which is overwritten
the next time &quot;Perl_setlocale&quot; is called from the
same thread.</p>

<p style="margin-left:17%; margin-top: 1em">const char*
Perl_setlocale(const int category, <br>
const char* locale)</p>


<p style="margin-left:11%;">&quot;RESTORE_LC_NUMERIC&quot;</p>

<p style="margin-left:17%;">This is used in conjunction
with one of the macros &quot;
<small>STORE_LC_NUMERIC_SET_TO_NEEDED&quot;</small> and
&quot;
<small>STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;</small> to
properly restore the &quot;LC_NUMERIC&quot; state.</p>

<p style="margin-left:17%; margin-top: 1em">A call to
&quot;
<small>DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;</small>
must have been made to declare at compile time a private
variable used by this macro and the two &quot;STORE&quot;
ones. This macro should be called as a single statement, not
an expression, but with an empty argument list, like
this:</p>

<p style="margin-left:17%; margin-top: 1em">{ <br>
DECLARATION_FOR_LC_NUMERIC_MANIPULATION; <br>
... <br>
RESTORE_LC_NUMERIC(); <br>
... <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">void
RESTORE_LC_NUMERIC()</p>


<p style="margin-left:11%;">&quot;SETLOCALE_ACCEPTS_ANY_LOCALE_NAME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the setlocale routine is available and it
accepts any input locale name as valid.</p>


<p style="margin-left:11%;">&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;</p>

<p style="margin-left:17%;">This is used by
<small>XS</small> code that is &quot;LC_NUMERIC&quot;
locale-aware to force the locale for category
&quot;LC_NUMERIC&quot; to be what perl thinks is the current
underlying locale. (The perl interpreter could be wrong
about what the underlying locale actually is if some C or
<small>XS</small> code has called the C library function
<b>setlocale</b>(3) behind its back; calling
&quot;sync_locale&quot; before calling this macro will
update perl&rsquo;s records.)</p>

<p style="margin-left:17%; margin-top: 1em">A call to
&quot;
<small>DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;</small>
must have been made to declare at compile time a private
variable used by this macro. This macro should be called as
a single statement, not an expression, but with an empty
argument list, like this:</p>

<p style="margin-left:17%; margin-top: 1em">{ <br>
DECLARATION_FOR_LC_NUMERIC_MANIPULATION; <br>
... <br>
STORE_LC_NUMERIC_FORCE_TO_UNDERLYING(); <br>
... <br>
RESTORE_LC_NUMERIC(); <br>
... <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">The private
variable is used to save the current locale state, so that
the requisite matching call to &quot;
<small>RESTORE_LC_NUMERIC&quot;</small> can restore it.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls not operating with thread-safe functionality, this
macro uses a mutex to force a critical section. Therefore
the matching <small>RESTORE</small> should be close by, and
guaranteed to be called.</p>

<p style="margin-left:17%; margin-top: 1em">void
STORE_LC_NUMERIC_FORCE_TO_UNDERLYING()</p>


<p style="margin-left:11%;">&quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot;</p>

<p style="margin-left:17%;">This is used to help wrap
<small>XS</small> or C code that is &quot;LC_NUMERIC&quot;
locale-aware. This locale category is generally kept set to
a locale where the decimal radix character is a dot, and the
separator between groups of digits is empty. This is because
most <small>XS</small> code that reads floating point
numbers is expecting them to have this syntax.</p>

<p style="margin-left:17%; margin-top: 1em">This macro
makes sure the current &quot;LC_NUMERIC&quot; state is set
properly, to be aware of locale if the call to the
<small>XS</small> or C code from the Perl program is from
within the scope of a &quot;use&nbsp;locale&quot;; or to
ignore locale if the call is instead from outside such
scope.</p>

<p style="margin-left:17%; margin-top: 1em">This macro is
the start of wrapping the C or <small>XS</small> code; the
wrap ending is done by calling the &quot;
<small>RESTORE_LC_NUMERIC&quot;</small> macro after the
operation. Otherwise the state can be changed that will
adversely affect other <small>XS</small> code.</p>

<p style="margin-left:17%; margin-top: 1em">A call to
&quot;
<small>DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;</small>
must have been made to declare at compile time a private
variable used by this macro. This macro should be called as
a single statement, not an expression, but with an empty
argument list, like this:</p>

<p style="margin-left:17%; margin-top: 1em">{ <br>
DECLARATION_FOR_LC_NUMERIC_MANIPULATION; <br>
... <br>
STORE_LC_NUMERIC_SET_TO_NEEDED(); <br>
... <br>
RESTORE_LC_NUMERIC(); <br>
... <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls not operating with thread-safe functionality, this
macro uses a mutex to force a critical section. Therefore
the matching <small>RESTORE</small> should be close by, and
guaranteed to be called; see &quot;
<small>WITH_LC_NUMERIC_SET_TO_NEEDED&quot;</small> for a
more contained way to ensure that.</p>

<p style="margin-left:17%; margin-top: 1em">void
STORE_LC_NUMERIC_SET_TO_NEEDED()</p>


<p style="margin-left:11%;">&quot;STORE_LC_NUMERIC_SET_TO_NEEDED_IN&quot;</p>

<p style="margin-left:17%;">Same as &quot;
<small>STORE_LC_NUMERIC_SET_TO_NEEDED&quot;</small> with
in_lc_numeric provided as the precalculated value of
&quot;IN_LC(LC_NUMERIC)&quot;. It is the caller&rsquo;s
responsibility to ensure that the status of
&quot;PL_compiling&quot; and &quot;PL_hints&quot; cannot
have changed since the precalculation.</p>

<p style="margin-left:17%; margin-top: 1em">void
STORE_LC_NUMERIC_SET_TO_NEEDED_IN(bool in_lc_numeric)</p>


<p style="margin-left:11%;">&quot;switch_to_global_locale&quot;</p>

<p style="margin-left:17%;">On systems without locale
support, or on typical single-threaded builds, or on
platforms that do not support per-thread locale operations,
this function does nothing. On such systems that do have
locale support, only a locale global to the whole program is
available.</p>

<p style="margin-left:17%; margin-top: 1em">On
multi-threaded builds on systems that do have per-thread
locale operations, this function converts the thread it is
running in to use the global locale. This is for code that
has not yet or cannot be updated to handle multi-threaded
locale operation. As long as only a single thread is
so-converted, everything works fine, as all the other
threads continue to ignore the global one, so only this
thread looks at it.</p>

<p style="margin-left:17%; margin-top: 1em">However, on
Windows systems this isn&rsquo;t quite true prior to Visual
Studio 15, at which point Microsoft fixed a bug. A race can
occur if you use the following operations on earlier Windows
platforms: <br>
POSIX::localeconv <br>
I18N::Langinfo, items &quot;CRNCYSTR&quot; and
&quot;THOUSEP&quot; <br>
&quot;Perl_langinfo&quot; in perlapi, items
&quot;CRNCYSTR&quot; and &quot;THOUSEP&quot;</p>

<p style="margin-left:17%; margin-top: 1em">The first item
is not fixable (except by upgrading to a later Visual Studio
release), but it would be possible to work around the latter
two items by using the Windows <small>API</small> functions
&quot;GetNumberFormat&quot; and
&quot;GetCurrencyFormat&quot;; patches welcome.</p>

<p style="margin-left:17%; margin-top: 1em">Without this
function call, threads that use the setlocale(3) system
function will not work properly, as all the locale-sensitive
functions will look at the per-thread locale, and
&quot;setlocale&quot; will have no effect on this
thread.</p>

<p style="margin-left:17%; margin-top: 1em">Perl code
should convert to either call &quot;Perl_setlocale&quot;
(which is a drop-in for the system &quot;setlocale&quot;) or
use the methods given in perlcall to call
&quot;POSIX::setlocale&quot;. Either one will transparently
properly handle all cases of single&minus; vs multi-thread,
<small>POSIX</small> 2008&minus;supported or not.</p>

<p style="margin-left:17%; margin-top: 1em">Non-Perl
libraries, such as &quot;gtk&quot;, that call the system
&quot;setlocale&quot; can continue to work if this function
is called before transferring control to the library.</p>

<p style="margin-left:17%; margin-top: 1em">Upon return
from the code that needs to use the global locale,
&quot;sync_locale()&quot; should be called to restore the
safe multi-thread operation.</p>

<p style="margin-left:17%; margin-top: 1em">void
switch_to_global_locale()</p>

<p style="margin-left:11%;">&quot;sync_locale&quot;</p>

<p style="margin-left:17%;">&quot;Perl_setlocale&quot; can
be used at any time to query or change the locale (though
changing the locale is antisocial and dangerous on
multi-threaded systems that don&rsquo;t have multi-thread
safe locale operations. (See &quot;Multi-threaded
operation&quot; in perllocale). Using the system
setlocale(3) should be avoided. Nevertheless, certain
non-Perl libraries called from <small>XS,</small> such as
&quot;Gtk&quot; do so, and this can&rsquo;t be changed. When
the locale is changed by <small>XS</small> code that
didn&rsquo;t use &quot;Perl_setlocale&quot;, Perl needs to
be told that the locale has changed. Use this function to do
so, before returning to Perl.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value is a boolean: <small>TRUE</small> if the global locale
at the time of call was in effect; and <small>FALSE</small>
if a per-thread locale was in effect. This can be used by
the caller that needs to restore things as-they-were to
decide whether or not to call
&quot;Perl_switch_to_global_locale&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sync_locale()</p>


<p style="margin-left:11%;">&quot;WITH_LC_NUMERIC_SET_TO_NEEDED&quot;</p>

<p style="margin-left:17%;">This macro invokes the supplied
statement or block within the context of a &quot;
<small>STORE_LC_NUMERIC_SET_TO_NEEDED&quot;</small> ..
&quot; <small>RESTORE_LC_NUMERIC&quot;</small> pair if
required, so eg:</p>


<p style="margin-left:17%; margin-top: 1em">WITH_LC_NUMERIC_SET_TO_NEEDED(
<br>
SNPRINTF_G(fv, ebuf, sizeof(ebuf), precis) <br>
);</p>

<p style="margin-left:17%; margin-top: 1em">is equivalent
to:</p>

<p style="margin-left:17%; margin-top: 1em">{ <br>
#ifdef USE_LOCALE_NUMERIC <br>
DECLARATION_FOR_LC_NUMERIC_MANIPULATION; <br>
STORE_LC_NUMERIC_SET_TO_NEEDED(); <br>
#endif <br>
SNPRINTF_G(fv, ebuf, sizeof(ebuf), precis); <br>
#ifdef USE_LOCALE_NUMERIC <br>
RESTORE_LC_NUMERIC(); <br>
#endif <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">void
WITH_LC_NUMERIC_SET_TO_NEEDED(block)</p>


<p style="margin-left:11%;">&quot;WITH_LC_NUMERIC_SET_TO_NEEDED_IN&quot;</p>

<p style="margin-left:17%;">Same as &quot;
<small>WITH_LC_NUMERIC_SET_TO_NEEDED&quot;</small> with
in_lc_numeric provided as the precalculated value of
&quot;IN_LC(LC_NUMERIC)&quot;. It is the caller&rsquo;s
responsibility to ensure that the status of
&quot;PL_compiling&quot; and &quot;PL_hints&quot; cannot
have changed since the precalculation.</p>

<p style="margin-left:17%; margin-top: 1em">void
WITH_LC_NUMERIC_SET_TO_NEEDED_IN(bool in_lc_numeric,
block)</p>

<h2>Magic
<a name="Magic"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;Magic&quot;
is special data attached to <small>SV</small> structures in
order to give them &quot;magical&quot; properties. When any
Perl code tries to read from, or assign to, an
<small>SV</small> marked as magical, it calls the
&rsquo;get&rsquo; or &rsquo;set&rsquo; function associated
with that <small>SV</small> &rsquo;s magic. A get is called
prior to reading an <small>SV,</small> in order to give it a
chance to update its internal value (get on $. writes the
line number of the last read filehandle into the
<small>SV</small> &rsquo;s <small>IV</small> slot), while
set is called after an <small>SV</small> has been written
to, in order to allow it to make use of its changed value
(set on $/ copies the <small>SV</small> &rsquo;s new value
to the PL_rs global variable).</p>

<p style="margin-left:11%; margin-top: 1em">Magic is
implemented as a linked list of <small>MAGIC</small>
structures attached to the <small>SV.</small> Each
<small>MAGIC</small> struct holds the type of the magic, a
pointer to an array of functions that implement the
<b>get()</b>, <b>set()</b>, <b>length()</b> etc functions,
plus space for some flags and pointers. For example, a tied
variable has a <small>MAGIC</small> structure that contains
a pointer to the object associated with the tie. <br>
&quot;mg_clear&quot;</p>

<p style="margin-left:17%;">Clear something magical that
the <small>SV</small> represents. See
&quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
mg_clear(SV* sv)</p>

<p style="margin-left:11%;">&quot;mg_copy&quot;</p>

<p style="margin-left:17%;">Copies the magic from one
<small>SV</small> to another. See &quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int mg_copy(SV
*sv, SV *nsv, const char *key, I32 klen)</p>

<p style="margin-left:11%;">&quot;MGf_COPY&quot; <br>
&quot;MGf_DUP&quot; <br>
&quot;MGf_LOCAL&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;mg_find&quot;</p>

<p style="margin-left:17%;">Finds the magic pointer for
&quot;type&quot; matching the <small>SV.</small> See
&quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">MAGIC*
mg_find(const SV* sv, int type)</p>

<p style="margin-left:11%;">&quot;mg_findext&quot;</p>

<p style="margin-left:17%;">Finds the magic pointer of
&quot;type&quot; with the given &quot;vtbl&quot; for the
&quot;SV&quot;. See &quot;sv_magicext&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">MAGIC*
mg_findext(const SV* sv, int type, const MGVTBL *vtbl)</p>

<p style="margin-left:11%;">&quot;mg_free&quot;</p>

<p style="margin-left:17%;">Free any magic storage used by
the <small>SV.</small> See &quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int mg_free(SV*
sv)</p>

<p style="margin-left:11%;">&quot;mg_freeext&quot;</p>

<p style="margin-left:17%;">Remove any magic of type
&quot;how&quot; using virtual table &quot;vtbl&quot; from
the <small>SV</small> &quot;sv&quot;. See
&quot;sv_magic&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;mg_freeext(sv,
how, NULL)&quot; is equivalent to &quot;mg_free_type(sv,
how)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
mg_freeext(SV* sv, int how, const MGVTBL *vtbl)</p>

<p style="margin-left:11%;">&quot;mg_free_type&quot;</p>

<p style="margin-left:17%;">Remove any magic of type
&quot;how&quot; from the <small>SV</small> &quot;sv&quot;.
See &quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
mg_free_type(SV* sv, int how)</p>

<p style="margin-left:11%;">&quot;mg_get&quot;</p>

<p style="margin-left:17%;">Do magic before a value is
retrieved from the <small>SV.</small> The type of
<small>SV</small> must be &gt;= &quot;SVt_PVMG&quot;. See
&quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int mg_get(SV*
sv)</p>

<p style="margin-left:11%;">&quot;mg_length&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;mg_length&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Reports on the
<small>SV</small> &rsquo;s length in bytes, calling length
magic if available, but does not set the <small>UTF8</small>
flag on &quot;sv&quot;. It will fall back to
&rsquo;get&rsquo; magic if there is no &rsquo;length&rsquo;
magic, but with no indication as to whether it called
&rsquo;get&rsquo; magic. It assumes &quot;sv&quot; is a
&quot;PVMG&quot; or higher. Use &quot;sv_len()&quot;
instead.</p>

<p style="margin-left:17%; margin-top: 1em">U32
mg_length(SV* sv)</p>

<p style="margin-left:11%;">&quot;mg_magical&quot;</p>

<p style="margin-left:17%;">Turns on the magical status of
an <small>SV.</small> See &quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
mg_magical(SV* sv)</p>

<p style="margin-left:11%;">&quot;mg_set&quot;</p>

<p style="margin-left:17%;">Do magic after a value is
assigned to the <small>SV.</small> See
&quot;sv_magic&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int mg_set(SV*
sv)</p>

<p style="margin-left:11%;">&quot;MGVTBL&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;perl_clone&quot;</p>

<p style="margin-left:17%;">Create and return a new
interpreter by cloning the current one.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;perl_clone&quot;
takes these flags as parameters:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;CLONEf_COPY_STACKS&quot;
&minus; is used to, well, copy the stacks also, without it
we only clone the data and zero the stacks, with it we copy
the stacks and the new perl interpreter is ready to run at
the exact same point as the previous one. The pseudo-fork
code uses &quot;COPY_STACKS&quot; while the
threads&minus;&gt;create doesn&rsquo;t.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;CLONEf_KEEP_PTR_TABLE&quot;
&minus; &quot;perl_clone&quot; keeps a ptr_table with the
pointer of the old variable as a key and the new variable as
a value, this allows it to check if something has been
cloned and not clone it again, but rather just use the value
and increase the refcount. If &quot;KEEP_PTR_TABLE&quot; is
not set then &quot;perl_clone&quot; will kill the ptr_table
using the function
&quot;ptr_table_free(PL_ptr_table);&nbsp;PL_ptr_table&nbsp;=&nbsp;NULL;&quot;.
A reason to keep it around is if you want to dup some of
your own variables which are outside the graph that perl
scans.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;CLONEf_CLONE_HOST&quot;
&minus; This is a win32 thing, it is ignored on unix, it
tells perl&rsquo;s win32host code (which is c++) to clone
itself, this is needed on win32 if you want to run two
threads at the same time, if you just want to do some stuff
in a separate perl interpreter and then throw it away and
return to the original one, you don&rsquo;t need to do
anything.</p>


<p style="margin-left:17%; margin-top: 1em">PerlInterpreter*
perl_clone(PerlInterpreter *proto_perl, <br>
UV flags)</p>

<p style="margin-left:11%;">&quot;PERL_MAGIC_arylen&quot;
<br>
&quot;PERL_MAGIC_arylen_p&quot; <br>
&quot;PERL_MAGIC_backref&quot; <br>
&quot;PERL_MAGIC_bm&quot; <br>
&quot;PERL_MAGIC_checkcall&quot; <br>
&quot;PERL_MAGIC_collxfrm&quot; <br>
&quot;PERL_MAGIC_dbfile&quot; <br>
&quot;PERL_MAGIC_dbline&quot; <br>
&quot;PERL_MAGIC_debugvar&quot; <br>
&quot;PERL_MAGIC_defelem&quot; <br>
&quot;PERL_MAGIC_env&quot; <br>
&quot;PERL_MAGIC_envelem&quot; <br>
&quot;PERL_MAGIC_ext&quot; <br>
&quot;PERL_MAGIC_fm&quot; <br>
&quot;PERL_MAGIC_hints&quot; <br>
&quot;PERL_MAGIC_hintselem&quot; <br>
&quot;PERL_MAGIC_isa&quot; <br>
&quot;PERL_MAGIC_isaelem&quot; <br>
&quot;PERL_MAGIC_lvref&quot; <br>
&quot;PERL_MAGIC_nkeys&quot; <br>
&quot;PERL_MAGIC_nonelem&quot; <br>
&quot;PERL_MAGIC_overload_table&quot; <br>
&quot;PERL_MAGIC_pos&quot; <br>
&quot;PERL_MAGIC_qr&quot; <br>
&quot;PERL_MAGIC_regdata&quot; <br>
&quot;PERL_MAGIC_regdatum&quot; <br>
&quot;PERL_MAGIC_regex_global&quot; <br>
&quot;PERL_MAGIC_rhash&quot; <br>
&quot;PERL_MAGIC_shared&quot; <br>
&quot;PERL_MAGIC_shared_scalar&quot; <br>
&quot;PERL_MAGIC_sig&quot; <br>
&quot;PERL_MAGIC_sigelem&quot; <br>
&quot;PERL_MAGIC_substr&quot; <br>
&quot;PERL_MAGIC_sv&quot; <br>
&quot;PERL_MAGIC_symtab&quot; <br>
&quot;PERL_MAGIC_taint&quot; <br>
&quot;PERL_MAGIC_tied&quot; <br>
&quot;PERL_MAGIC_tiedelem&quot; <br>
&quot;PERL_MAGIC_tiedscalar&quot; <br>
&quot;PERL_MAGIC_utf8&quot; <br>
&quot;PERL_MAGIC_uvar&quot; <br>
&quot;PERL_MAGIC_uvar_elem&quot; <br>
&quot;PERL_MAGIC_vec&quot; <br>
&quot;PERL_MAGIC_vstring&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:11%;">&quot;ptr_table_fetch&quot;</p>

<p style="margin-left:17%;">Look for &quot;sv&quot; in the
pointer-mapping table &quot;tbl&quot;, returning its value,
or <small>NULL</small> if not found.</p>

<p style="margin-left:17%; margin-top: 1em">void*
ptr_table_fetch(PTR_TBL_t *const tbl, const void *const
sv)</p>

<p style="margin-left:11%;">&quot;ptr_table_free&quot;</p>

<p style="margin-left:17%;">Clear and free a ptr table</p>

<p style="margin-left:17%; margin-top: 1em">void
ptr_table_free(PTR_TBL_t *const tbl)</p>

<p style="margin-left:11%;">&quot;ptr_table_new&quot;</p>

<p style="margin-left:17%;">Create a new pointer-mapping
table</p>

<p style="margin-left:17%; margin-top: 1em">PTR_TBL_t*
ptr_table_new()</p>


<p style="margin-left:11%;">&quot;ptr_table_split&quot;</p>

<p style="margin-left:17%;">Double the hash bucket size of
an existing ptr table</p>

<p style="margin-left:17%; margin-top: 1em">void
ptr_table_split(PTR_TBL_t *const tbl)</p>


<p style="margin-left:11%;">&quot;ptr_table_store&quot;</p>

<p style="margin-left:17%;">Add a new entry to a
pointer-mapping table &quot;tbl&quot;. In hash terms,
&quot;oldsv&quot; is the key; Cnewsv&gt; is the value.</p>

<p style="margin-left:17%; margin-top: 1em">The names
&quot;old&quot; and &quot;new&quot; are specific to the
core&rsquo;s typical use of ptr_tables in thread
cloning.</p>

<p style="margin-left:17%; margin-top: 1em">void
ptr_table_store(PTR_TBL_t *const tbl, <br>
const void *const oldsv, void *const newsv)</p>

<p style="margin-left:11%;">&quot;SvTIED_obj&quot;</p>

<p style="margin-left:17%;">Described in perlinterp.</p>

<p style="margin-left:17%; margin-top: 1em">SvTIED_obj(SV
*sv, MAGIC *mg)</p>

<h2>Memory Management
<a name="Memory Management"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;dump_mstats&quot;</p>

<p style="margin-left:17%;">When enabled by compiling with
&quot;&minus;DDEBUGGING_MSTATS&quot;, print out statistics
about malloc as two lines of numbers, one showing the length
of the free list for each size category, the second showing
the number of mallocs&nbsp;&minus;&nbsp;frees for each size
category.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;s&quot;,
if not <small>NULL,</small> is used as a phrase to include
in the output, such as
&quot;after&nbsp;compilation&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
dump_mstats(const char* s)</p>


<p style="margin-left:11%;">&quot;HASATTRIBUTE_MALLOC&quot;</p>

<p style="margin-left:17%;">Can we handle &quot;GCC&quot;
attribute for malloc-style functions.</p>


<p style="margin-left:11%;">&quot;HAS_MALLOC_GOOD_SIZE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;malloc_good_size&quot; routine is
available for use.</p>


<p style="margin-left:11%;">&quot;HAS_MALLOC_SIZE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;malloc_size&quot; routine is
available for use.</p>

<p style="margin-left:11%;">&quot;I_MALLOCMALLOC&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>malloc/malloc.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_MALLOCMALLOC <br>
#include &lt;mallocmalloc.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;MYMALLOC&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that we&rsquo;re using our own malloc.</p>

<p style="margin-left:11%;">&quot;Newx&quot; <br>
&quot;safemalloc&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;malloc&quot; function.</p>

<p style="margin-left:17%; margin-top: 1em">Memory obtained
by this should <b><small>ONLY</small></b> be freed with
&quot;Safefree&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">In 5.9.3,
<b>Newx()</b> and friends replace the older <b>New()</b>
<small>API,</small> and drops the first parameter, <i>x</i>,
a debug aid which allowed callers to identify themselves.
This aid has been superseded by a new build option,
<small>PERL_MEM_LOG</small> (see &quot;
<small>PERL_MEM_LOG&quot;</small> in perlhacktips). The
older <small>API</small> is still there for use in
<small>XS</small> modules supporting older perls.</p>

<p style="margin-left:17%; margin-top: 1em">void Newx
(void* ptr, int nitems, type) <br>
void* safemalloc(size_t size)</p>

<p style="margin-left:11%;">&quot;Newxc&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;malloc&quot; function, with cast.
See also &quot;Newx&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Memory obtained
by this should <b><small>ONLY</small></b> be freed with
&quot;Safefree&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
Newxc(void* ptr, int nitems, type, cast)</p>

<p style="margin-left:11%;">&quot;Newxz&quot; <br>
&quot;safecalloc&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;malloc&quot; function. The
allocated memory is zeroed with &quot;memzero&quot;. See
also &quot;Newx&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Memory obtained
by this should <b><small>ONLY</small></b> be freed with
&quot;Safefree&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void Newxz
(void* ptr, int nitems, type) <br>
void* safecalloc(size_t nitems, size_t item_size)</p>


<p style="margin-left:11%;">&quot;PERL_MALLOC_WRAP&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that we&rsquo;d like malloc wrap checks.</p>

<p style="margin-left:11%;">&quot;Renew&quot; <br>
&quot;saferealloc&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;realloc&quot; function.</p>

<p style="margin-left:17%; margin-top: 1em">Memory obtained
by this should <b><small>ONLY</small></b> be freed with
&quot;Safefree&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void Renew
(void* ptr, int nitems, type) <br>
void* saferealloc(void *ptr, size_t size)</p>

<p style="margin-left:11%;">&quot;Renewc&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;realloc&quot; function, with
cast.</p>

<p style="margin-left:17%; margin-top: 1em">Memory obtained
by this should <b><small>ONLY</small></b> be freed with
&quot;Safefree&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
Renewc(void* ptr, int nitems, type, cast)</p>

<p style="margin-left:11%;">&quot;Safefree&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;free&quot; function.</p>

<p style="margin-left:17%; margin-top: 1em">This should
<b><small>ONLY</small></b> be used on memory obtained using
&quot;Newx&quot; and friends.</p>

<p style="margin-left:17%; margin-top: 1em">void
Safefree(void* ptr)</p>

<p style="margin-left:11%;">&quot;safesyscalloc&quot;</p>

<p style="margin-left:17%;">Safe version of system&rsquo;s
<b>calloc()</b></p>

<p style="margin-left:17%; margin-top: 1em">Malloc_t
safesyscalloc(MEM_SIZE elements, MEM_SIZE size)</p>

<p style="margin-left:11%;">&quot;safesysfree&quot;</p>

<p style="margin-left:17%;">Safe version of system&rsquo;s
<b>free()</b></p>

<p style="margin-left:17%; margin-top: 1em">Free_t
safesysfree(Malloc_t where)</p>

<p style="margin-left:11%;">&quot;safesysmalloc&quot;</p>

<p style="margin-left:17%;">Paranoid version of
system&rsquo;s <b>malloc()</b></p>

<p style="margin-left:17%; margin-top: 1em">Malloc_t
safesysmalloc(MEM_SIZE nbytes)</p>

<p style="margin-left:11%;">&quot;safesysrealloc&quot;</p>

<p style="margin-left:17%;">Paranoid version of
system&rsquo;s <b>realloc()</b></p>

<p style="margin-left:17%; margin-top: 1em">Malloc_t
safesysrealloc(Malloc_t where, MEM_SIZE nbytes)</p>

<h2>MRO
<a name="MRO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These functions
are related to the method resolution order of perl classes
Also see perlmroapi. <br>
&quot;HvMROMETA&quot;</p>

<p style="margin-left:17%;">Described in perlmroapi.</p>

<p style="margin-left:17%; margin-top: 1em">struct mro_meta
* HvMROMETA(HV *hv)</p>


<p style="margin-left:11%;">&quot;mro_get_from_name&quot;</p>

<p style="margin-left:17%;">Returns the previously
registered mro with the given &quot;name&quot;, or
<small>NULL</small> if not registered. See
&quot;&quot;mro_register&quot;&quot;.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;mro_get_from_name&quot; must be explicitly called as
&quot;Perl_mro_get_from_name&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">const struct
mro_alg * Perl_mro_get_from_name(pTHX_ SV *name)</p>


<p style="margin-left:11%;">&quot;mro_get_linear_isa&quot;</p>

<p style="margin-left:17%;">Returns the mro linearisation
for the given stash. By default, this will be whatever
&quot;mro_get_linear_isa_dfs&quot; returns unless some other
<small>MRO</small> is in effect for the stash. The return
value is a read-only AV*.</p>

<p style="margin-left:17%; margin-top: 1em">You are
responsible for &quot;SvREFCNT_inc()&quot; on the return
value if you plan to store it anywhere semi-permanently
(otherwise it might be deleted out from under you the next
time the cache is invalidated).</p>

<p style="margin-left:17%; margin-top: 1em">AV*
mro_get_linear_isa(HV* stash)</p>


<p style="margin-left:11%;">&quot;MRO_GET_PRIVATE_DATA&quot;</p>

<p style="margin-left:17%;">Described in perlmroapi.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
MRO_GET_PRIVATE_DATA(struct mro_meta *const smeta, <br>
const struct mro_alg *const which)</p>


<p style="margin-left:11%;">&quot;mro_method_changed_in&quot;</p>

<p style="margin-left:17%;">Invalidates method caching on
any child classes of the given stash, so that they might
notice the changes in this one.</p>

<p style="margin-left:17%; margin-top: 1em">Ideally, all
instances of &quot;PL_sub_generation++&quot; in perl source
outside of <i>mro.c</i> should be replaced by calls to
this.</p>

<p style="margin-left:17%; margin-top: 1em">Perl
automatically handles most of the common ways a method might
be redefined. However, there are a few ways you could change
a method in a stash without the cache code noticing, in
which case you need to call this method afterwards:</p>

<p style="margin-left:17%; margin-top: 1em">1) Directly
manipulating the stash <small>HV</small> entries from
<small>XS</small> code.</p>

<p style="margin-left:17%; margin-top: 1em">2) Assigning a
reference to a readonly scalar constant into a stash entry
in order to create a constant subroutine (like
<i>constant.pm</i> does).</p>

<p style="margin-left:17%; margin-top: 1em">This same
method is available from pure perl via,
&quot;mro::method_changed_in(classname)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
mro_method_changed_in(HV* stash)</p>

<p style="margin-left:11%;">&quot;mro_register&quot;</p>

<p style="margin-left:17%;">Registers a custom mro plugin.
See perlmroapi for details on this and other mro
functions.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;mro_register&quot; must be explicitly called as
&quot;Perl_mro_register&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_mro_register(pTHX_ const struct mro_alg *mro)</p>

<p style="margin-left:11%;">&quot;mro_set_mro&quot;</p>

<p style="margin-left:17%;">Set &quot;meta&quot; to the
value contained in the registered mro plugin whose name is
&quot;name&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Croaks if
&quot;name&quot; hasn&rsquo;t been registered</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;mro_set_mro&quot; must be explicitly called as
&quot;Perl_mro_set_mro&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_mro_set_mro(pTHX_ struct mro_meta *const meta, <br>
SV *const name)</p>


<p style="margin-left:11%;">&quot;mro_set_private_data&quot;</p>

<p style="margin-left:17%;">Described in perlmroapi.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;mro_set_private_data&quot; must be explicitly called
as &quot;Perl_mro_set_private_data&quot; with an
&quot;aTHX_&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
Perl_mro_set_private_data(pTHX_ <br>
struct mro_meta *const smeta, <br>
const struct mro_alg *const which, <br>
SV *const data)</p>

<h2>Multicall Functions
<a name="Multicall Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;dMULTICALL&quot;</p>

<p style="margin-left:17%;">Declare local variables for a
multicall. See &quot; <small>LIGHTWEIGHT
CALLBACKS&quot;</small> in perlcall.</p>


<p style="margin-left:17%; margin-top: 1em">dMULTICALL;</p>

<p style="margin-left:11%;">&quot;MULTICALL&quot;</p>

<p style="margin-left:17%;">Make a lightweight callback.
See &quot; <small>LIGHTWEIGHT CALLBACKS&quot;</small> in
perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">MULTICALL;</p>

<p style="margin-left:11%;">&quot;POP_MULTICALL&quot;</p>

<p style="margin-left:17%;">Closing bracket for a
lightweight callback. See &quot; <small>LIGHTWEIGHT
CALLBACKS&quot;</small> in perlcall.</p>


<p style="margin-left:17%; margin-top: 1em">POP_MULTICALL;</p>

<p style="margin-left:11%;">&quot;PUSH_MULTICALL&quot;</p>

<p style="margin-left:17%;">Opening bracket for a
lightweight callback. See &quot; <small>LIGHTWEIGHT
CALLBACKS&quot;</small> in perlcall.</p>


<p style="margin-left:17%; margin-top: 1em">PUSH_MULTICALL(CV*
the_cv);</p>

<h2>Numeric Functions
<a name="Numeric Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;Atol&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;Atol&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Described in
perlhacktips.</p>

<p style="margin-left:17%; margin-top: 1em">Atol(const char
* nptr)</p>

<p style="margin-left:11%;">&quot;Atoul&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;Atoul&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Described in
perlhacktips.</p>

<p style="margin-left:17%; margin-top: 1em">Atoul(const
char * nptr)</p>

<p style="margin-left:11%;">&quot;Drand01&quot;</p>

<p style="margin-left:17%;">This macro is to be used to
generate uniformly distributed random numbers over the range
[0., 1.[. You may have to supply an &rsquo;extern double
&quot;drand48()&quot;;&rsquo; in your program since SunOS
4.1.3 doesn&rsquo;t provide you with anything relevant in
its headers. See &quot;HAS_DRAND48_PROTO&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">double
Drand01()</p>

<p style="margin-left:11%;">&quot;Gconvert&quot;</p>

<p style="margin-left:17%;">This preprocessor macro is
defined to convert a floating point number to a string
without a trailing decimal point. This emulates the behavior
of &quot;sprintf(&quot;%g&quot;)&quot;, but is sometimes
much more efficient. If &quot;gconvert()&quot; is not
available, but &quot;gcvt()&quot; drops the trailing decimal
point, then &quot;gcvt()&quot; is used. If all else fails, a
macro using &quot;sprintf(&quot;%g&quot;)&quot; is used.
Arguments for the Gconvert macro are: value, number of
digits, whether trailing zeros should be retained, and the
output buffer. The usual values are:</p>


<p style="margin-left:17%; margin-top: 1em">d_Gconvert='gconvert((x),(n),(t),(b))'
<br>
d_Gconvert='gcvt((x),(n),(b))' <br>
d_Gconvert='sprintf((b),&quot;%.*g&quot;,(n),(x))'</p>

<p style="margin-left:17%; margin-top: 1em">The last two
assume trailing zeros should not be kept.</p>

<p style="margin-left:17%; margin-top: 1em">char *
Gconvert(double x, Size_t n, bool t, char * b)</p>

<p style="margin-left:11%;">&quot;grok_atoUV&quot;</p>

<p style="margin-left:17%;">parse a string, looking for a
decimal unsigned integer.</p>

<p style="margin-left:17%; margin-top: 1em">On entry,
&quot;pv&quot; points to the beginning of the string;
&quot;valptr&quot; points to a <small>UV</small> that will
receive the converted value, if found; &quot;endptr&quot; is
either <small>NULL</small> or points to a variable that
points to one byte beyond the point in &quot;pv&quot; that
this routine should examine. If &quot;endptr&quot; is
<small>NULL,</small> &quot;pv&quot; is assumed to be
NUL-terminated.</p>

<p style="margin-left:17%; margin-top: 1em">Returns
<small>FALSE</small> if &quot;pv&quot; doesn&rsquo;t
represent a valid unsigned integer value (with no leading
zeros). Otherwise it returns <small>TRUE,</small> and sets
*valptr to that value.</p>

<p style="margin-left:17%; margin-top: 1em">If you
constrain the portion of &quot;pv&quot; that is looked at by
this function (by passing a non-NULL &quot;endptr&quot;),
and if the intial bytes of that portion form a valid value,
it will return <small>TRUE,</small> setting *endptr to the
byte following the final digit of the value. But if there is
no constraint at what&rsquo;s looked at, all of
&quot;pv&quot; must be valid in order for
<small>TRUE</small> to be returned. *endptr is unchanged
from its value on input if <small>FALSE</small> is
returned;</p>

<p style="margin-left:17%; margin-top: 1em">The only
characters this accepts are the decimal digits
&rsquo;0&rsquo;..&rsquo;9&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">As opposed to
<b>atoi</b>(3) or <b>strtol</b>(3), &quot;grok_atoUV&quot;
does <small>NOT</small> allow optional leading whitespace,
nor negative inputs. If such features are required, the
calling code needs to explicitly implement those.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
function returns <small>FALSE</small> for inputs that would
overflow a <small>UV,</small> or have leading zeros. Thus a
single 0 is accepted, but not 00 nor 01, 002,
<i>etc</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Background:
&quot;atoi&quot; has severe problems with illegal inputs, it
cannot be used for incremental parsing, and therefore should
be avoided &quot;atoi&quot; and &quot;strtol&quot; are also
affected by locale settings, which can also be seen as a bug
(global state controlled by user environment).</p>

<p style="margin-left:17%; margin-top: 1em">bool
grok_atoUV(const char* pv, UV* valptr, const char**
endptr)</p>

<p style="margin-left:11%;">&quot;grok_bin&quot;</p>

<p style="margin-left:17%;">converts a string representing
a binary number to numeric form.</p>

<p style="margin-left:17%; margin-top: 1em">On entry
&quot;start&quot; and *len_p give the string to scan, *flags
gives conversion flags, and &quot;result&quot; should be
&quot;NULL&quot; or a pointer to an <small>NV.</small> The
scan stops at the end of the string, or at just before the
first invalid character. Unless
&quot;PERL_SCAN_SILENT_ILLDIGIT&quot; is set in *flags,
encountering an invalid character (except <small>NUL</small>
) will also trigger a warning. On return *len_p is set to
the length of the scanned string, and *flags gives output
flags.</p>

<p style="margin-left:17%; margin-top: 1em">If the value is
&lt;= &quot;UV_MAX&quot; it is returned as a
<small>UV,</small> the output flags are clear, and nothing
is written to *result. If the value is &gt;
&quot;UV_MAX&quot;, &quot;grok_bin&quot; returns
&quot;UV_MAX&quot;, sets
&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot; in the output
flags, and writes an approximation of the correct value into
*result (which is an <small>NV</small> ; or the
approximation is discarded if &quot;result&quot; is
<small>NULL</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">The binary
number may optionally be prefixed with &quot;0b&quot; or
&quot;b&quot; unless &quot;PERL_SCAN_DISALLOW_PREFIX&quot;
is set in *flags on entry.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot; is set in *flags
then any or all pairs of digits may be separated from each
other by a single underscore; also a single leading
underscore is accepted.</p>

<p style="margin-left:17%; margin-top: 1em">UV
grok_bin(const char* start, STRLEN* len_p, I32* flags, <br>
NV *result)</p>

<p style="margin-left:11%;">&quot;grok_hex&quot;</p>

<p style="margin-left:17%;">converts a string representing
a hex number to numeric form.</p>

<p style="margin-left:17%; margin-top: 1em">On entry
&quot;start&quot; and *len_p give the string to scan, *flags
gives conversion flags, and &quot;result&quot; should be
&quot;NULL&quot; or a pointer to an <small>NV.</small> The
scan stops at the end of the string, or at just before the
first invalid character. Unless
&quot;PERL_SCAN_SILENT_ILLDIGIT&quot; is set in *flags,
encountering an invalid character (except <small>NUL</small>
) will also trigger a warning. On return *len_p is set to
the length of the scanned string, and *flags gives output
flags.</p>

<p style="margin-left:17%; margin-top: 1em">If the value is
&lt;= &quot;UV_MAX&quot; it is returned as a
<small>UV,</small> the output flags are clear, and nothing
is written to *result. If the value is &gt;
&quot;UV_MAX&quot;, &quot;grok_hex&quot; returns
&quot;UV_MAX&quot;, sets
&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot; in the output
flags, and writes an approximation of the correct value into
*result (which is an <small>NV</small> ; or the
approximation is discarded if &quot;result&quot; is
<small>NULL</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">The hex number
may optionally be prefixed with &quot;0x&quot; or
&quot;x&quot; unless &quot;PERL_SCAN_DISALLOW_PREFIX&quot;
is set in *flags on entry.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot; is set in *flags
then any or all pairs of digits may be separated from each
other by a single underscore; also a single leading
underscore is accepted.</p>

<p style="margin-left:17%; margin-top: 1em">UV
grok_hex(const char* start, STRLEN* len_p, I32* flags, <br>
NV *result)</p>

<p style="margin-left:11%;">&quot;grok_infnan&quot;</p>

<p style="margin-left:17%;">Helper for
&quot;grok_number()&quot;, accepts various ways of spelling
&quot;infinity&quot; or &quot;not a number&quot;, and
returns one of the following flag combinations:</p>


<p style="margin-left:17%; margin-top: 1em">IS_NUMBER_INFINITY
<br>
IS_NUMBER_NAN <br>
IS_NUMBER_INFINITY | IS_NUMBER_NEG <br>
IS_NUMBER_NAN | IS_NUMBER_NEG <br>
0</p>

<p style="margin-left:17%; margin-top: 1em">possibly
|&minus;ed with &quot;IS_NUMBER_TRAILING&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If an infinity
or a not-a-number is recognized, *sp will point to one byte
past the end of the recognized string. If the recognition
fails, zero is returned, and *sp will not move.</p>

<p style="margin-left:17%; margin-top: 1em">int
grok_infnan(const char** sp, const char *send)</p>

<p style="margin-left:11%;">&quot;grok_number&quot;</p>

<p style="margin-left:17%;">Identical to
&quot;grok_number_flags()&quot; with &quot;flags&quot; set
to zero.</p>

<p style="margin-left:17%; margin-top: 1em">int
grok_number(const char *pv, STRLEN len, UV *valuep)</p>


<p style="margin-left:11%;">&quot;grok_number_flags&quot;</p>

<p style="margin-left:17%;">Recognise (or not) a number.
The type of the number is returned (0 if unrecognised),
otherwise it is a bit-ORed combination of
&quot;IS_NUMBER_IN_UV&quot;,
&quot;IS_NUMBER_GREATER_THAN_UV_MAX&quot;,
&quot;IS_NUMBER_NOT_INT&quot;, &quot;IS_NUMBER_NEG&quot;,
&quot;IS_NUMBER_INFINITY&quot;, &quot;IS_NUMBER_NAN&quot;
(defined in perl.h).</p>

<p style="margin-left:17%; margin-top: 1em">If the value of
the number can fit in a <small>UV,</small> it is returned in
*valuep. &quot;IS_NUMBER_IN_UV&quot; will be set to indicate
that *valuep is valid, &quot;IS_NUMBER_IN_UV&quot; will
never be set unless *valuep is valid, but *valuep may have
been assigned to during processing even though
&quot;IS_NUMBER_IN_UV&quot; is not set on return. If
&quot;valuep&quot; is &quot;NULL&quot;,
&quot;IS_NUMBER_IN_UV&quot; will be set for the same cases
as when &quot;valuep&quot; is non&minus;&quot;NULL&quot;,
but no actual assignment (or <small>SEGV</small> ) will
occur.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;IS_NUMBER_NOT_INT&quot;
will be set with &quot;IS_NUMBER_IN_UV&quot; if trailing
decimals were seen (in which case *valuep gives the true
value truncated to an integer), and
&quot;IS_NUMBER_NEG&quot; if the number is negative (in
which case *valuep holds the absolute value).
&quot;IS_NUMBER_IN_UV&quot; is not set if &quot;e&quot;
notation was used or the number is larger than a
<small>UV.</small></p>


<p style="margin-left:17%; margin-top: 1em">&quot;flags&quot;
allows only &quot;PERL_SCAN_TRAILING&quot;, which allows for
trailing non-numeric text on an otherwise successful
<i>grok</i>, setting &quot;IS_NUMBER_TRAILING&quot; on the
result.</p>

<p style="margin-left:17%; margin-top: 1em">int
grok_number_flags(const char *pv, STRLEN len, UV *valuep,
<br>
U32 flags)</p>


<p style="margin-left:11%;">&quot;GROK_NUMERIC_RADIX&quot;</p>

<p style="margin-left:17%;">A synonym for
&quot;grok_numeric_radix&quot;</p>

<p style="margin-left:17%; margin-top: 1em">bool
GROK_NUMERIC_RADIX(NN const char **sp, NN const char
*send)</p>


<p style="margin-left:11%;">&quot;grok_numeric_radix&quot;</p>

<p style="margin-left:17%;">Scan and skip for a numeric
decimal separator (radix).</p>

<p style="margin-left:17%; margin-top: 1em">bool
grok_numeric_radix(const char **sp, const char *send)</p>

<p style="margin-left:11%;">&quot;grok_oct&quot;</p>

<p style="margin-left:17%;">converts a string representing
an octal number to numeric form.</p>

<p style="margin-left:17%; margin-top: 1em">On entry
&quot;start&quot; and *len_p give the string to scan, *flags
gives conversion flags, and &quot;result&quot; should be
&quot;NULL&quot; or a pointer to an <small>NV.</small> The
scan stops at the end of the string, or at just before the
first invalid character. Unless
&quot;PERL_SCAN_SILENT_ILLDIGIT&quot; is set in *flags,
encountering an invalid character (except <small>NUL</small>
) will also trigger a warning. On return *len_p is set to
the length of the scanned string, and *flags gives output
flags.</p>

<p style="margin-left:17%; margin-top: 1em">If the value is
&lt;= &quot;UV_MAX&quot; it is returned as a
<small>UV,</small> the output flags are clear, and nothing
is written to *result. If the value is &gt;
&quot;UV_MAX&quot;, &quot;grok_oct&quot; returns
&quot;UV_MAX&quot;, sets
&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot; in the output
flags, and writes an approximation of the correct value into
*result (which is an <small>NV</small> ; or the
approximation is discarded if &quot;result&quot; is
<small>NULL</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot; is set in *flags
then any or all pairs of digits may be separated from each
other by a single underscore; also a single leading
underscore is accepted.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;PERL_SCAN_DISALLOW_PREFIX&quot; flag is always treated
as being set for this function.</p>

<p style="margin-left:17%; margin-top: 1em">UV
grok_oct(const char* start, STRLEN* len_p, I32* flags, <br>
NV *result)</p>

<p style="margin-left:11%;">&quot;isinfnan&quot;</p>

<p style="margin-left:17%;">&quot;Perl_isinfnan()&quot; is
a utility function that returns true if the
<small>NV</small> argument is either an infinity or a
&quot;NaN&quot;, false otherwise. To test in more detail,
use &quot;Perl_isinf()&quot; and
&quot;Perl_isnan()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This is also
the logical inverse of <b>Perl_isfinite()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">bool
isinfnan(NV nv)</p>

<p style="margin-left:11%;">&quot;my_atof&quot;</p>

<p style="margin-left:17%;">&quot;atof&quot;(3), but
properly works with Perl locale handling, accepting a dot
radix character always, but also the current locale&rsquo;s
radix character if and only if called from within the
lexical scope of a Perl &quot;use locale&quot;
statement.</p>

<p style="margin-left:17%; margin-top: 1em">N.B.
&quot;s&quot; must be <small>NUL</small> terminated.</p>

<p style="margin-left:17%; margin-top: 1em">NV
my_atof(const char *s)</p>

<p style="margin-left:11%;">&quot;my_strtod&quot;</p>

<p style="margin-left:17%;">This function is equivalent to
the libc <b>strtod()</b> function, and is available even on
platforms that lack plain <b>strtod()</b>. Its return value
is the best available precision depending on platform
capabilities and <i>Configure</i> options.</p>

<p style="margin-left:17%; margin-top: 1em">It properly
handles the locale radix character, meaning it expects a dot
except when called from within the scope of
&quot;use&nbsp;locale&quot;, in which case the radix
character should be that specified by the current
locale.</p>

<p style="margin-left:17%; margin-top: 1em">The synonym
<b>Strtod()</b> may be used instead.</p>

<p style="margin-left:17%; margin-top: 1em">NV
my_strtod(const char * const s, char ** e)</p>

<p style="margin-left:11%;">&quot;PERL_ABS&quot;</p>

<p style="margin-left:17%;">Typeless &quot;abs&quot; or
&quot;fabs&quot;, <i>etc</i>. (The usage below indicates it
is for integers, but it works for any type.) Use instead of
these, since the C library ones force their argument to be
what it is expecting, potentially leading to disaster. But
also beware that this evaluates its argument twice, so no
&quot;x++&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
PERL_ABS(int x)</p>

<p style="margin-left:11%;">&quot;Perl_acos&quot; <br>
&quot;Perl_asin&quot; <br>
&quot;Perl_atan&quot; <br>
&quot;Perl_atan2&quot; <br>
&quot;Perl_ceil&quot; <br>
&quot;Perl_cos&quot; <br>
&quot;Perl_cosh&quot; <br>
&quot;Perl_exp&quot; <br>
&quot;Perl_floor&quot; <br>
&quot;Perl_fmod&quot; <br>
&quot;Perl_frexp&quot; <br>
&quot;Perl_isfinite&quot; <br>
&quot;Perl_isinf&quot; <br>
&quot;Perl_isnan&quot; <br>
&quot;Perl_ldexp&quot; <br>
&quot;Perl_log&quot; <br>
&quot;Perl_log10&quot; <br>
&quot;Perl_modf&quot; <br>
&quot;Perl_pow&quot; <br>
&quot;Perl_sin&quot; <br>
&quot;Perl_sinh&quot; <br>
&quot;Perl_sqrt&quot; <br>
&quot;Perl_tan&quot; <br>
&quot;Perl_tanh&quot;</p>

<p style="margin-left:17%;">These perform the corresponding
mathematical operation on the operand(s), using the libc
function designed for the task that has just enough
precision for an <small>NV</small> on this platform. If no
such function with sufficient precision exists, the highest
precision one available is used.</p>

<p style="margin-left:17%; margin-top: 1em">NV Perl_acos
(NV x) <br>
NV Perl_asin (NV x) <br>
NV Perl_atan (NV x) <br>
NV Perl_atan2 (NV x, NV y) <br>
NV Perl_ceil (NV x) <br>
NV Perl_cos (NV x) <br>
NV Perl_cosh (NV x) <br>
NV Perl_exp (NV x) <br>
NV Perl_floor (NV x) <br>
NV Perl_fmod (NV x, NV y) <br>
NV Perl_frexp (NV x, int *exp) <br>
IV Perl_isfinite(NV x) <br>
IV Perl_isinf (NV x) <br>
IV Perl_isnan (NV x) <br>
NV Perl_ldexp (NV x, int exp) <br>
NV Perl_log (NV x) <br>
NV Perl_log10 (NV x) <br>
NV Perl_modf (NV x, NV *iptr) <br>
NV Perl_pow (NV x, NV y) <br>
NV Perl_sin (NV x) <br>
NV Perl_sinh (NV x) <br>
NV Perl_sqrt (NV x) <br>
NV Perl_tan (NV x) <br>
NV Perl_tanh (NV x)</p>

<p style="margin-left:11%;">&quot;Perl_signbit&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;Perl_signbit&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Return a
non-zero integer if the sign bit on an <small>NV</small> is
set, and 0 if it is not.</p>

<p style="margin-left:17%; margin-top: 1em">If
<i>Configure</i> detects this system has a
&quot;signbit()&quot; that will work with our NVs, then we
just use it via the &quot;#define&quot; in <i>perl.h</i>.
Otherwise, fall back on this implementation. The main use of
this function is catching &quot;&minus;0.0&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;Configure&quot;
notes: This function is called 'Perl_signbit' instead of a
plain 'signbit' because it is easy to imagine a system
having a &quot;signbit()&quot; function or macro that
doesn&rsquo;t happen to work with our particular choice of
NVs. We shouldn&rsquo;t just re&minus;&quot;#define&quot;
&quot;signbit&quot; as &quot;Perl_signbit&quot; and expect
the standard system headers to be happy. Also, this is a
no-context function (no &quot;pTHX_&quot;) because
&quot;Perl_signbit()&quot; is usually
re&minus;&quot;#defined&quot; in <i>perl.h</i> as a simple
macro call to the system&rsquo;s &quot;signbit()&quot;.
Users should just always call
&quot;Perl_signbit()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
Perl_signbit(NV f)</p>

<p style="margin-left:11%;">&quot;PL_hexdigit&quot;</p>

<p style="margin-left:17%;">This array, indexed by an
integer, converts that value into the character that
represents it. For example, if the input is 8, the return
will be a string whose first character is &rsquo;8&rsquo;.
What is actually returned is a pointer into a string. All
you are interested in is the first character of that string.
To get uppercase letters (for the values 10..15), add 16 to
the index. Hence, &quot;PL_hexdigit[11]&quot; is 'b', and
&quot;PL_hexdigit[11+16]&quot; is 'B'. Adding 16 to an index
whose representation is &rsquo;0&rsquo;..&rsquo;9&rsquo;
yields the same as not adding 16. Indices outside the range
0..31 result in (bad) undedefined behavior.</p>

<p style="margin-left:11%;">&quot;READ_XDIGIT&quot;</p>

<p style="margin-left:17%;">Returns the value of an
ASCII-range hex digit and advances the string pointer.
Behaviour is only well defined when isXDIGIT(*str) is
true.</p>

<p style="margin-left:17%; margin-top: 1em">U8
READ_XDIGIT(char str*)</p>

<p style="margin-left:11%;">&quot;scan_bin&quot;</p>

<p style="margin-left:17%;">For backwards compatibility.
Use &quot;grok_bin&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">NV
scan_bin(const char* start, STRLEN len, STRLEN* retlen)</p>

<p style="margin-left:11%;">&quot;scan_hex&quot;</p>

<p style="margin-left:17%;">For backwards compatibility.
Use &quot;grok_hex&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">NV
scan_hex(const char* start, STRLEN len, STRLEN* retlen)</p>

<p style="margin-left:11%;">&quot;scan_oct&quot;</p>

<p style="margin-left:17%;">For backwards compatibility.
Use &quot;grok_oct&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">NV
scan_oct(const char* start, STRLEN len, STRLEN* retlen)</p>

<p style="margin-left:11%;">&quot;seedDrand01&quot;</p>

<p style="margin-left:17%;">This symbol defines the macro
to be used in seeding the random number generator (see
&quot;Drand01&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">void
seedDrand01(Rand_seed_t x)</p>

<p style="margin-left:11%;">&quot;Strtod&quot;</p>

<p style="margin-left:17%;">This is a synonym for
&quot;my_strtod&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">NV Strtod(NN
const char * const s, NULLOK char ** e)</p>

<p style="margin-left:11%;">&quot;Strtol&quot;</p>

<p style="margin-left:17%;">Platform and configuration
independent &quot;strtol&quot;. This expands to the
appropriate &quot;strotol&quot;&minus;like function based on
the platform and <i>Configure</i> options&gt;. For example
it could expand to &quot;strtoll&quot; or &quot;strtoq&quot;
instead of &quot;strtol&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">NV Strtol(NN
const char * const s, NULLOK char ** e, int base)</p>

<p style="margin-left:11%;">&quot;Strtoul&quot;</p>

<p style="margin-left:17%;">Platform and configuration
independent &quot;strtoul&quot;. This expands to the
appropriate &quot;strotoul&quot;&minus;like function based
on the platform and <i>Configure</i> options&gt;. For
example it could expand to &quot;strtoull&quot; or
&quot;strtouq&quot; instead of &quot;strtoul&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">NV Strtoul(NN
const char * const s, NULLOK char ** e, int base)</p>

<h2>Optrees
<a name="Optrees"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;alloccopstash&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;alloccopstash&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Available only
under threaded builds, this function allocates an entry in
&quot;PL_stashpad&quot; for the stash passed to it.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
alloccopstash(HV *hv)</p>

<p style="margin-left:11%;">&quot;BINOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;block_end&quot;</p>

<p style="margin-left:17%;">Handles compile-time scope
exit. &quot;floor&quot; is the savestack index returned by
&quot;block_start&quot;, and &quot;seq&quot; is the body of
the block. Returns the block, possibly modified.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
block_end(I32 floor, OP* seq)</p>

<p style="margin-left:11%;">&quot;block_start&quot;</p>

<p style="margin-left:17%;">Handles compile-time scope
entry. Arranges for hints to be restored on block exit and
also handles pad sequence numbers to make lexical variables
scope right. Returns a savestack index for use with
&quot;block_end&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
block_start(int full)</p>


<p style="margin-left:11%;">&quot;ck_entersub_args_list&quot;</p>

<p style="margin-left:17%;">Performs the default fixup of
the arguments part of an &quot;entersub&quot; op tree. This
consists of applying list context to each of the argument
ops. This is the standard treatment used on a call marked
with &quot;&amp;&quot;, or a method call, or a call through
a subroutine reference, or any other call where the callee
can&rsquo;t be identified at compile time, or a call where
the callee has no prototype.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
ck_entersub_args_list(OP *entersubop)</p>


<p style="margin-left:11%;">&quot;ck_entersub_args_proto&quot;</p>

<p style="margin-left:17%;">Performs the fixup of the
arguments part of an &quot;entersub&quot; op tree based on a
subroutine prototype. This makes various modifications to
the argument ops, from applying context up to inserting
&quot;refgen&quot; ops, and checking the number and
syntactic types of arguments, as directed by the prototype.
This is the standard treatment used on a subroutine call,
not marked with &quot;&amp;&quot;, where the callee can be
identified at compile time and has a prototype.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;protosv&quot;
supplies the subroutine prototype to be applied to the call.
It may be a normal defined scalar, of which the string value
will be used. Alternatively, for convenience, it may be a
subroutine object (a &quot;CV*&quot; that has been cast to
&quot;SV*&quot;) which has a prototype. The prototype
supplied, in whichever form, does not need to match the
actual callee referenced by the op tree.</p>

<p style="margin-left:17%; margin-top: 1em">If the argument
ops disagree with the prototype, for example by having an
unacceptable number of arguments, a valid op tree is
returned anyway. The error is reflected in the parser state,
normally resulting in a single exception at the top level of
parsing which covers all the compilation errors that
occurred. In the error message, the callee is referred to by
the name defined by the &quot;namegv&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
ck_entersub_args_proto(OP *entersubop, GV *namegv, <br>
SV *protosv)</p>


<p style="margin-left:11%;">&quot;ck_entersub_args_proto_or_list&quot;</p>

<p style="margin-left:17%;">Performs the fixup of the
arguments part of an &quot;entersub&quot; op tree either
based on a subroutine prototype or using default
list-context processing. This is the standard treatment used
on a subroutine call, not marked with &quot;&amp;&quot;,
where the callee can be identified at compile time.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;protosv&quot;
supplies the subroutine prototype to be applied to the call,
or indicates that there is no prototype. It may be a normal
scalar, in which case if it is defined then the string value
will be used as a prototype, and if it is undefined then
there is no prototype. Alternatively, for convenience, it
may be a subroutine object (a &quot;CV*&quot; that has been
cast to &quot;SV*&quot;), of which the prototype will be
used if it has one. The prototype (or lack thereof)
supplied, in whichever form, does not need to match the
actual callee referenced by the op tree.</p>

<p style="margin-left:17%; margin-top: 1em">If the argument
ops disagree with the prototype, for example by having an
unacceptable number of arguments, a valid op tree is
returned anyway. The error is reflected in the parser state,
normally resulting in a single exception at the top level of
parsing which covers all the compilation errors that
occurred. In the error message, the callee is referred to by
the name defined by the &quot;namegv&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
ck_entersub_args_proto_or_list(OP *entersubop, GV *namegv,
<br>
SV *protosv)</p>

<p style="margin-left:11%;">&quot;cv_const_sv&quot;</p>

<p style="margin-left:17%;">If &quot;cv&quot; is a constant
sub eligible for inlining, returns the constant value
returned by the sub. Otherwise, returns
&quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Constant subs
can be created with &quot;newCONSTSUB&quot; or as described
in &quot;Constant Functions&quot; in perlsub.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
cv_const_sv(const CV *const cv)</p>


<p style="margin-left:11%;">&quot;cv_get_call_checker&quot;</p>

<p style="margin-left:17%;">The original form of
&quot;cv_get_call_checker_flags&quot;, which does not return
checker flags. When using a checker function returned by
this function, it is only safe to call it with a genuine
<small>GV</small> as its &quot;namegv&quot; argument.</p>

<p style="margin-left:17%; margin-top: 1em">void
cv_get_call_checker(CV *cv, Perl_call_checker *ckfun_p, <br>
SV **ckobj_p)</p>


<p style="margin-left:11%;">&quot;cv_get_call_checker_flags&quot;</p>

<p style="margin-left:17%;">Retrieves the function that
will be used to fix up a call to &quot;cv&quot;.
Specifically, the function is applied to an
&quot;entersub&quot; op tree for a subroutine call, not
marked with &quot;&amp;&quot;, where the callee can be
identified at compile time as &quot;cv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The
C&minus;level function pointer is returned in *ckfun_p, an
<small>SV</small> argument for it is returned in *ckobj_p,
and control flags are returned in *ckflags_p. The function
is intended to be called in this manner:</p>

<p style="margin-left:17%; margin-top: 1em">entersubop =
(*ckfun_p)(aTHX_ entersubop, namegv, (*ckobj_p));</p>

<p style="margin-left:17%; margin-top: 1em">In this call,
&quot;entersubop&quot; is a pointer to the
&quot;entersub&quot; op, which may be replaced by the check
function, and &quot;namegv&quot; supplies the name that
should be used by the check function to refer to the callee
of the &quot;entersub&quot; op if it needs to emit any
diagnostics. It is permitted to apply the check function in
non-standard situations, such as to a call to a different
subroutine or to a method call.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;namegv&quot;
may not actually be a <small>GV.</small> If the
&quot;CALL_CHECKER_REQUIRE_GV&quot; bit is clear in
*ckflags_p, it is permitted to pass a <small>CV</small> or
other <small>SV</small> instead, anything that can be used
as the first argument to &quot;cv_name&quot;. If the
&quot;CALL_CHECKER_REQUIRE_GV&quot; bit is set in *ckflags_p
then the check function requires &quot;namegv&quot; to be a
genuine <small>GV.</small></p>

<p style="margin-left:17%; margin-top: 1em">By default, the
check function is Perl_ck_entersub_args_proto_or_list, the
<small>SV</small> parameter is &quot;cv&quot; itself, and
the &quot;CALL_CHECKER_REQUIRE_GV&quot; flag is clear. This
implements standard prototype processing. It can be changed,
for a particular subroutine, by
&quot;cv_set_call_checker_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;CALL_CHECKER_REQUIRE_GV&quot; bit is set in
&quot;gflags&quot; then it indicates that the caller only
knows about the genuine <small>GV</small> version of
&quot;namegv&quot;, and accordingly the corresponding bit
will always be set in *ckflags_p, regardless of the check
function&rsquo;s recorded requirements. If the
&quot;CALL_CHECKER_REQUIRE_GV&quot; bit is clear in
&quot;gflags&quot; then it indicates the caller knows about
the possibility of passing something other than a
<small>GV</small> as &quot;namegv&quot;, and accordingly the
corresponding bit may be either set or clear in *ckflags_p,
indicating the check function&rsquo;s recorded
requirements.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;gflags&quot;
is a bitset passed into
&quot;cv_get_call_checker_flags&quot;, in which only the
&quot;CALL_CHECKER_REQUIRE_GV&quot; bit currently has a
defined meaning (for which see above). All other bits should
be clear.</p>

<p style="margin-left:17%; margin-top: 1em">void
cv_get_call_checker_flags(CV *cv, U32 gflags, <br>
Perl_call_checker *ckfun_p, <br>
SV **ckobj_p, U32 *ckflags_p)</p>


<p style="margin-left:11%;">&quot;cv_set_call_checker&quot;</p>

<p style="margin-left:17%;">The original form of
&quot;cv_set_call_checker_flags&quot;, which passes it the
&quot;CALL_CHECKER_REQUIRE_GV&quot; flag for
backward-compatibility. The effect of that flag setting is
that the check function is guaranteed to get a genuine
<small>GV</small> as its &quot;namegv&quot; argument.</p>

<p style="margin-left:17%; margin-top: 1em">void
cv_set_call_checker(CV *cv, Perl_call_checker ckfun, <br>
SV *ckobj)</p>


<p style="margin-left:11%;">&quot;cv_set_call_checker_flags&quot;</p>

<p style="margin-left:17%;">Sets the function that will be
used to fix up a call to &quot;cv&quot;. Specifically, the
function is applied to an &quot;entersub&quot; op tree for a
subroutine call, not marked with &quot;&amp;&quot;, where
the callee can be identified at compile time as
&quot;cv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The
C&minus;level function pointer is supplied in
&quot;ckfun&quot;, an <small>SV</small> argument for it is
supplied in &quot;ckobj&quot;, and control flags are
supplied in &quot;ckflags&quot;. The function should be
defined like this:</p>

<p style="margin-left:17%; margin-top: 1em">STATIC OP *
ckfun(pTHX_ OP *op, GV *namegv, SV *ckobj)</p>

<p style="margin-left:17%; margin-top: 1em">It is intended
to be called in this manner:</p>

<p style="margin-left:17%; margin-top: 1em">entersubop =
ckfun(aTHX_ entersubop, namegv, ckobj);</p>

<p style="margin-left:17%; margin-top: 1em">In this call,
&quot;entersubop&quot; is a pointer to the
&quot;entersub&quot; op, which may be replaced by the check
function, and &quot;namegv&quot; supplies the name that
should be used by the check function to refer to the callee
of the &quot;entersub&quot; op if it needs to emit any
diagnostics. It is permitted to apply the check function in
non-standard situations, such as to a call to a different
subroutine or to a method call.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;namegv&quot;
may not actually be a <small>GV.</small> For efficiency,
perl may pass a <small>CV</small> or other <small>SV</small>
instead. Whatever is passed can be used as the first
argument to &quot;cv_name&quot;. You can force perl to pass
a <small>GV</small> by including
&quot;CALL_CHECKER_REQUIRE_GV&quot; in the
&quot;ckflags&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;ckflags&quot;
is a bitset, in which only the
&quot;CALL_CHECKER_REQUIRE_GV&quot; bit currently has a
defined meaning (for which see above). All other bits should
be clear.</p>

<p style="margin-left:17%; margin-top: 1em">The current
setting for a particular <small>CV</small> can be retrieved
by &quot;cv_get_call_checker_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
cv_set_call_checker_flags(CV *cv, Perl_call_checker ckfun,
<br>
SV *ckobj, U32 ckflags)</p>

<p style="margin-left:11%;">&quot;LINKLIST&quot;</p>

<p style="margin-left:17%;">Given the root of an optree,
link the tree in execution order using the
&quot;op_next&quot; pointers and return the first op
executed. If this has already been done, it will not be
redone, and &quot;o&minus;&gt;op_next&quot; will be
returned. If &quot;o&minus;&gt;op_next&quot; is not already
set, &quot;o&quot; should be at least an
&quot;UNOP&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">OP* LINKLIST(OP
*o)</p>

<p style="margin-left:11%;">&quot;LISTOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;LOGOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;LOOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;newASSIGNOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an assignment op. &quot;left&quot; and &quot;right&quot;
supply the parameters of the assignment; they are consumed
by this function and become part of the constructed op
tree.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;optype&quot; is &quot;OP_ANDASSIGN&quot;,
&quot;OP_ORASSIGN&quot;, or &quot;OP_DORASSIGN&quot;, then a
suitable conditional optree is constructed. If
&quot;optype&quot; is the opcode of a binary operator, such
as &quot;OP_BIT_OR&quot;, then an op is constructed that
performs the binary operation and assigns the result to the
left argument. Either way, if &quot;optype&quot; is non-zero
then &quot;flags&quot; has no effect.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;optype&quot; is zero, then a plain scalar or list
assignment is constructed. Which type of assignment it is is
automatically determined. &quot;flags&quot; gives the eight
bits of &quot;op_flags&quot;, except that
&quot;OPf_KIDS&quot; will be set automatically, and, shifted
up eight bits, the eight bits of &quot;op_private&quot;,
except that the bit with value 1 or 2 is automatically set
as required.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newASSIGNOP(I32 flags, OP* left, I32 optype, OP* right)</p>

<p style="margin-left:11%;">&quot;newATTRSUB&quot;</p>

<p style="margin-left:17%;">Construct a Perl subroutine,
also performing some surrounding jobs.</p>

<p style="margin-left:17%; margin-top: 1em">This is the
same as &quot;&quot;newATTRSUB_x&quot;&quot; in perlintern
with its &quot;o_is_gv&quot; parameter set to
<small>FALSE.</small> This means that if &quot;o&quot; is
null, the new sub will be anonymous; otherwise the name will
be derived from &quot;o&quot; in the way described (as with
all other details) in &quot;&quot;newATTRSUB_x&quot;&quot;
in perlintern.</p>

<p style="margin-left:17%; margin-top: 1em">CV*
newATTRSUB(I32 floor, OP *o, OP *proto, OP *attrs, OP
*block)</p>

<p style="margin-left:11%;">&quot;newBINOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any binary type. &quot;type&quot; is the opcode.
&quot;flags&quot; gives the eight bits of
&quot;op_flags&quot;, except that &quot;OPf_KIDS&quot; will
be set automatically, and, shifted up eight bits, the eight
bits of &quot;op_private&quot;, except that the bit with
value 1 or 2 is automatically set as required.
&quot;first&quot; and &quot;last&quot; supply up to two ops
to be the direct children of the binary op; they are
consumed by this function and become part of the constructed
op tree.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newBINOP(I32 type, I32 flags, OP* first, OP* last)</p>

<p style="margin-left:11%;">&quot;newCONDOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
a conditional-expression (&quot;cond_expr&quot;) op.
&quot;flags&quot; gives the eight bits of
&quot;op_flags&quot;, except that &quot;OPf_KIDS&quot; will
be set automatically, and, shifted up eight bits, the eight
bits of &quot;op_private&quot;, except that the bit with
value 1 is automatically set. &quot;first&quot; supplies the
expression selecting between the two branches, and
&quot;trueop&quot; and &quot;falseop&quot; supply the
branches; they are consumed by this function and become part
of the constructed op tree.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newCONDOP(I32 flags, OP* first, OP* trueop, OP* falseop)</p>

<p style="margin-left:11%;">&quot;newCONSTSUB&quot;</p>

<p style="margin-left:17%;">Behaves like
&quot;newCONSTSUB_flags&quot;, except that &quot;name&quot;
is nul-terminated rather than of counted length, and no
flags are set. (This means that &quot;name&quot; is always
interpreted as Latin&minus;1.)</p>

<p style="margin-left:17%; margin-top: 1em">CV*
newCONSTSUB(HV* stash, const char* name, SV* sv)</p>


<p style="margin-left:11%;">&quot;newCONSTSUB_flags&quot;</p>

<p style="margin-left:17%;">Construct a constant
subroutine, also performing some surrounding jobs. A scalar
constant-valued subroutine is eligible for inlining at
compile-time, and in Perl code can be created by
&quot;sub&nbsp;FOO&nbsp;()&nbsp;{&nbsp;123&nbsp;}&quot;.
Other kinds of constant subroutine have other treatment.</p>

<p style="margin-left:17%; margin-top: 1em">The subroutine
will have an empty prototype and will ignore any arguments
when called. Its constant behaviour is determined by
&quot;sv&quot;. If &quot;sv&quot; is null, the subroutine
will yield an empty list. If &quot;sv&quot; points to a
scalar, the subroutine will always yield that scalar. If
&quot;sv&quot; points to an array, the subroutine will
always yield a list of the elements of that array in list
context, or the number of elements in the array in scalar
context. This function takes ownership of one counted
reference to the scalar or array, and will arrange for the
object to live as long as the subroutine does. If
&quot;sv&quot; points to a scalar then the inlining assumes
that the value of the scalar will never change, so the
caller must ensure that the scalar is not subsequently
written to. If &quot;sv&quot; points to an array then no
such assumption is made, so it is ostensibly safe to mutate
the array or its elements, but whether this is really
supported has not been determined.</p>

<p style="margin-left:17%; margin-top: 1em">The subroutine
will have &quot;CvFILE&quot; set according to
&quot;PL_curcop&quot;. Other aspects of the subroutine will
be left in their default state. The caller is free to mutate
the subroutine beyond its initial state after this function
has returned.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;name&quot; is null then the subroutine will be
anonymous, with its &quot;CvGV&quot; referring to an
&quot;__ANON__&quot; glob. If &quot;name&quot; is non-null
then the subroutine will be named accordingly, referenced by
the appropriate glob. &quot;name&quot; is a string of length
&quot;len&quot; bytes giving a sigilless symbol name, in
<small>UTF&minus;8</small> if &quot;flags&quot; has the
&quot;SVf_UTF8&quot; bit set and in Latin&minus;1 otherwise.
The name may be either qualified or unqualified. If the name
is unqualified then it defaults to being in the stash
specified by &quot;stash&quot; if that is non-null, or to
&quot;PL_curstash&quot; if &quot;stash&quot; is null. The
symbol is always added to the stash if necessary, with
&quot;GV_ADDMULTI&quot; semantics.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;flags&quot;
should not have bits set other than
&quot;SVf_UTF8&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If there is
already a subroutine of the specified name, then the new sub
will replace the existing one in the glob. A warning may be
generated about the redefinition.</p>

<p style="margin-left:17%; margin-top: 1em">If the
subroutine has one of a few special names, such as
&quot;BEGIN&quot; or &quot;END&quot;, then it will be
claimed by the appropriate queue for automatic running of
phase-related subroutines. In this case the relevant glob
will be left not containing any subroutine, even if it did
contain one before. Execution of the subroutine will likely
be a no-op, unless &quot;sv&quot; was a tied array or the
caller modified the subroutine in some interesting way
before it was executed. In the case of &quot;BEGIN&quot;,
the treatment is buggy: the sub will be executed when only
half built, and may be deleted prematurely, possibly causing
a crash.</p>

<p style="margin-left:17%; margin-top: 1em">The function
returns a pointer to the constructed subroutine. If the sub
is anonymous then ownership of one counted reference to the
subroutine is transferred to the caller. If the sub is named
then the caller does not get ownership of a reference. In
most such cases, where the sub has a non-phase name, the sub
will be alive at the point it is returned by virtue of being
contained in the glob that names it. A phase-named
subroutine will usually be alive by virtue of the reference
owned by the phase&rsquo;s automatic run queue. A
&quot;BEGIN&quot; subroutine may have been destroyed already
by the time this function returns, but currently bugs occur
in that case before the caller gets control. It is the
caller&rsquo;s responsibility to ensure that it knows which
of these situations applies.</p>

<p style="margin-left:17%; margin-top: 1em">CV*
newCONSTSUB_flags(HV* stash, const char* name, STRLEN len,
<br>
U32 flags, SV* sv)</p>

<p style="margin-left:11%;">&quot;newDEFEROP&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;newDEFEROP&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Constructs and
returns a deferred-block statement that implements the
&quot;defer&quot; semantics. The &quot;block&quot; optree is
consumed by this function and becomes part of the returned
optree.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; argument carries additional flags to set
on the returned op, including the &quot;op_private&quot;
field.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newDEFEROP(I32 flags, OP *block)</p>

<p style="margin-left:11%;">&quot;newDEFSVOP&quot;</p>

<p style="margin-left:17%;">Constructs and returns an op to
access $_.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newDEFSVOP()</p>

<p style="margin-left:11%;">&quot;newFOROP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op tree expressing a &quot;foreach&quot; loop (iteration
through a list of values). This is a heavyweight loop, with
structure that allows exiting the loop by &quot;last&quot;
and suchlike.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;sv&quot;
optionally supplies the variable(s) that will be aliased to
each item in turn; if null, it defaults to $_.
&quot;expr&quot; supplies the list of values to iterate
over. &quot;block&quot; supplies the main body of the loop,
and &quot;cont&quot; optionally supplies a
&quot;continue&quot; block that operates as a second half of
the body. All of these optree inputs are consumed by this
function and become part of the constructed op tree.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;flags&quot;
gives the eight bits of &quot;op_flags&quot; for the
&quot;leaveloop&quot; op and, shifted up eight bits, the
eight bits of &quot;op_private&quot; for the
&quot;leaveloop&quot; op, except that (in both cases) some
bits will be set automatically.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newFOROP(I32 flags, OP* sv, OP* expr, OP* block, OP*
cont)</p>

<p style="margin-left:11%;">&quot;newGIVENOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op tree expressing a &quot;given&quot; block.
&quot;cond&quot; supplies the expression to whose value $_
will be locally aliased, and &quot;block&quot; supplies the
body of the &quot;given&quot; construct; they are consumed
by this function and become part of the constructed op tree.
&quot;defsv_off&quot; must be zero (it used to identity the
pad slot of lexical $_).</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newGIVENOP(OP* cond, OP* block, PADOFFSET defsv_off)</p>

<p style="margin-left:11%;">&quot;newGVOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any type that involves an embedded reference to a
<small>GV.</small> &quot;type&quot; is the opcode.
&quot;flags&quot; gives the eight bits of
&quot;op_flags&quot;. &quot;gv&quot; identifies the
<small>GV</small> that the op should reference; calling this
function does not transfer ownership of any reference to
it.</p>

<p style="margin-left:17%; margin-top: 1em">OP* newGVOP(I32
type, I32 flags, GV* gv)</p>

<p style="margin-left:11%;">&quot;newLISTOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any list type. &quot;type&quot; is the opcode.
&quot;flags&quot; gives the eight bits of
&quot;op_flags&quot;, except that &quot;OPf_KIDS&quot; will
be set automatically if required. &quot;first&quot; and
&quot;last&quot; supply up to two ops to be direct children
of the list op; they are consumed by this function and
become part of the constructed op tree.</p>

<p style="margin-left:17%; margin-top: 1em">For most list
operators, the check function expects all the kid ops to be
present already, so calling &quot;newLISTOP(OP_JOIN,
...)&quot; (e.g.) is not appropriate. What you want to do in
that case is create an op of type &quot;OP_LIST&quot;,
append more children to it, and then call
&quot;op_convert_list&quot;. See &quot;op_convert_list&quot;
for more information.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newLISTOP(I32 type, I32 flags, OP* first, OP* last)</p>

<p style="margin-left:11%;">&quot;newLOGOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
a logical (flow control) op. &quot;type&quot; is the opcode.
&quot;flags&quot; gives the eight bits of
&quot;op_flags&quot;, except that &quot;OPf_KIDS&quot; will
be set automatically, and, shifted up eight bits, the eight
bits of &quot;op_private&quot;, except that the bit with
value 1 is automatically set. &quot;first&quot; supplies the
expression controlling the flow, and &quot;other&quot;
supplies the side (alternate) chain of ops; they are
consumed by this function and become part of the constructed
op tree.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newLOGOP(I32 optype, I32 flags, OP *first, OP *other)</p>

<p style="margin-left:11%;">&quot;newLOOPEX&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
a loop-exiting op (such as &quot;goto&quot; or
&quot;last&quot;). &quot;type&quot; is the opcode.
&quot;label&quot; supplies the parameter determining the
target of the op; it is consumed by this function and
becomes part of the constructed op tree.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newLOOPEX(I32 type, OP* label)</p>

<p style="margin-left:11%;">&quot;newLOOPOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op tree expressing a loop. This is only a loop in the
control flow through the op tree; it does not have the
heavyweight loop structure that allows exiting the loop by
&quot;last&quot; and suchlike. &quot;flags&quot; gives the
eight bits of &quot;op_flags&quot; for the top-level op,
except that some bits will be set automatically as required.
&quot;expr&quot; supplies the expression controlling loop
iteration, and &quot;block&quot; supplies the body of the
loop; they are consumed by this function and become part of
the constructed op tree. &quot;debuggable&quot; is currently
unused and should always be 1.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newLOOPOP(I32 flags, I32 debuggable, OP* expr, OP*
block)</p>

<p style="margin-left:11%;">&quot;newMETHOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of method type with a method name evaluated at
runtime. &quot;type&quot; is the opcode. &quot;flags&quot;
gives the eight bits of &quot;op_flags&quot;, except that
&quot;OPf_KIDS&quot; will be set automatically, and, shifted
up eight bits, the eight bits of &quot;op_private&quot;,
except that the bit with value 1 is automatically set.
&quot;dynamic_meth&quot; supplies an op which evaluates
method name; it is consumed by this function and become part
of the constructed op tree. Supported optypes:
&quot;OP_METHOD&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newMETHOP(I32 type, I32 flags, OP* dynamic_meth)</p>


<p style="margin-left:11%;">&quot;newMETHOP_named&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of method type with a constant method name.
&quot;type&quot; is the opcode. &quot;flags&quot; gives the
eight bits of &quot;op_flags&quot;, and, shifted up eight
bits, the eight bits of &quot;op_private&quot;.
&quot;const_meth&quot; supplies a constant method name; it
must be a shared <small>COW</small> string. Supported
optypes: &quot;OP_METHOD_NAMED&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newMETHOP_named(I32 type, I32 flags, SV* const_meth)</p>

<p style="margin-left:11%;">&quot;newNULLLIST&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
a new &quot;stub&quot; op, which represents an empty list
expression.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newNULLLIST()</p>

<p style="margin-left:11%;">&quot;newOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any base type (any type that has no extra fields).
&quot;type&quot; is the opcode. &quot;flags&quot; gives the
eight bits of &quot;op_flags&quot;, and, shifted up eight
bits, the eight bits of &quot;op_private&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">OP* newOP(I32
optype, I32 flags)</p>

<p style="margin-left:11%;">&quot;newPADOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any type that involves a reference to a pad
element. &quot;type&quot; is the opcode. &quot;flags&quot;
gives the eight bits of &quot;op_flags&quot;. A pad slot is
automatically allocated, and is populated with
&quot;sv&quot;; this function takes ownership of one
reference to it.</p>

<p style="margin-left:17%; margin-top: 1em">This function
only exists if Perl has been compiled to use ithreads.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newPADOP(I32 type, I32 flags, SV* sv)</p>

<p style="margin-left:11%;">&quot;newPMOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any pattern matching type. &quot;type&quot; is the
opcode. &quot;flags&quot; gives the eight bits of
&quot;op_flags&quot; and, shifted up eight bits, the eight
bits of &quot;op_private&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">OP* newPMOP(I32
type, I32 flags)</p>

<p style="margin-left:11%;">&quot;newPVOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any type that involves an embedded C&minus;level
pointer ( <small>PV</small> ). &quot;type&quot; is the
opcode. &quot;flags&quot; gives the eight bits of
&quot;op_flags&quot;. &quot;pv&quot; supplies the
C&minus;level pointer. Depending on the op type, the memory
referenced by &quot;pv&quot; may be freed when the op is
destroyed. If the op is of a freeing type, &quot;pv&quot;
must have been allocated using
&quot;PerlMemShared_malloc&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">OP* newPVOP(I32
type, I32 flags, char* pv)</p>

<p style="margin-left:11%;">&quot;newRANGE&quot;</p>

<p style="margin-left:17%;">Constructs and returns a
&quot;range&quot; op, with subordinate &quot;flip&quot; and
&quot;flop&quot; ops. &quot;flags&quot; gives the eight bits
of &quot;op_flags&quot; for the &quot;flip&quot; op and,
shifted up eight bits, the eight bits of
&quot;op_private&quot; for both the &quot;flip&quot; and
&quot;range&quot; ops, except that the bit with value 1 is
automatically set. &quot;left&quot; and &quot;right&quot;
supply the expressions controlling the endpoints of the
range; they are consumed by this function and become part of
the constructed op tree.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newRANGE(I32 flags, OP* left, OP* right)</p>

<p style="margin-left:11%;">&quot;newSLICEOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an &quot;lslice&quot; (list slice) op. &quot;flags&quot;
gives the eight bits of &quot;op_flags&quot;, except that
&quot;OPf_KIDS&quot; will be set automatically, and, shifted
up eight bits, the eight bits of &quot;op_private&quot;,
except that the bit with value 1 or 2 is automatically set
as required. &quot;listval&quot; and &quot;subscript&quot;
supply the parameters of the slice; they are consumed by
this function and become part of the constructed op
tree.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newSLICEOP(I32 flags, OP* subscript, OP* listop)</p>

<p style="margin-left:11%;">&quot;newSTATEOP&quot;</p>

<p style="margin-left:17%;">Constructs a state op (
<small>COP</small> ). The state op is normally a
&quot;nextstate&quot; op, but will be a &quot;dbstate&quot;
op if debugging is enabled for currently-compiled code. The
state op is populated from &quot;PL_curcop&quot; (or
&quot;PL_compiling&quot;). If &quot;label&quot; is non-null,
it supplies the name of a label to attach to the state op;
this function takes ownership of the memory pointed at by
&quot;label&quot;, and will free it. &quot;flags&quot; gives
the eight bits of &quot;op_flags&quot; for the state op.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;o&quot; is null, the state op is returned. Otherwise
the state op is combined with &quot;o&quot; into a
&quot;lineseq&quot; list op, which is returned.
&quot;o&quot; is consumed by this function and becomes part
of the returned op tree.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newSTATEOP(I32 flags, char* label, OP* o)</p>

<p style="margin-left:11%;">&quot;newSUB&quot;</p>

<p style="margin-left:17%;">Like &quot;newATTRSUB&quot;,
but without attributes.</p>

<p style="margin-left:17%; margin-top: 1em">CV* newSUB(I32
floor, OP* o, OP* proto, OP* block)</p>

<p style="margin-left:11%;">&quot;newSVOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any type that involves an embedded
<small>SV.</small> &quot;type&quot; is the opcode.
&quot;flags&quot; gives the eight bits of
&quot;op_flags&quot;. &quot;sv&quot; gives the
<small>SV</small> to embed in the op; this function takes
ownership of one reference to it.</p>

<p style="margin-left:17%; margin-top: 1em">OP* newSVOP(I32
type, I32 flags, SV* sv)</p>

<p style="margin-left:11%;">&quot;newTRYCATCHOP&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;newTRYCATCHOP&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Constructs and
returns a conditional execution statement that implements
the &quot;try&quot;/&quot;catch&quot; semantics. First the
op tree in &quot;tryblock&quot; is executed, inside a
context that traps exceptions. If an exception occurs then
the optree in &quot;catchblock&quot; is executed, with the
trapped exception set into the lexical variable given by
&quot;catchvar&quot; (which must be an op of type
&quot;OP_PADSV&quot;). All the optrees are consumed by this
function and become part of the returned op tree.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; argument is currently ignored.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newTRYCATCHOP(I32 flags, OP* tryblock, OP *catchvar, <br>
OP* catchblock)</p>

<p style="margin-left:11%;">&quot;newUNOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op of any unary type. &quot;type&quot; is the opcode.
&quot;flags&quot; gives the eight bits of
&quot;op_flags&quot;, except that &quot;OPf_KIDS&quot; will
be set automatically if required, and, shifted up eight
bits, the eight bits of &quot;op_private&quot;, except that
the bit with value 1 is automatically set. &quot;first&quot;
supplies an optional op to be the direct child of the unary
op; it is consumed by this function and become part of the
constructed op tree.</p>

<p style="margin-left:17%; margin-top: 1em">OP* newUNOP(I32
type, I32 flags, OP* first)</p>

<p style="margin-left:11%;">&quot;newUNOP_AUX&quot;</p>

<p style="margin-left:17%;">Similar to &quot;newUNOP&quot;,
but creates an &quot;UNOP_AUX&quot; struct instead, with
&quot;op_aux&quot; initialised to &quot;aux&quot;</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newUNOP_AUX(I32 type, I32 flags, OP* first, <br>
UNOP_AUX_item *aux)</p>

<p style="margin-left:11%;">&quot;newWHENOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op tree expressing a &quot;when&quot; block.
&quot;cond&quot; supplies the test expression, and
&quot;block&quot; supplies the block that will be executed
if the test evaluates to true; they are consumed by this
function and become part of the constructed op tree.
&quot;cond&quot; will be interpreted DWIMically, often as a
comparison against $_, and may be null to generate a
&quot;default&quot; block.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newWHENOP(OP* cond, OP* block)</p>

<p style="margin-left:11%;">&quot;newWHILEOP&quot;</p>

<p style="margin-left:17%;">Constructs, checks, and returns
an op tree expressing a &quot;while&quot; loop. This is a
heavyweight loop, with structure that allows exiting the
loop by &quot;last&quot; and suchlike.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;loop&quot;
is an optional preconstructed &quot;enterloop&quot; op to
use in the loop; if it is null then a suitable op will be
constructed automatically. &quot;expr&quot; supplies the
loop&rsquo;s controlling expression. &quot;block&quot;
supplies the main body of the loop, and &quot;cont&quot;
optionally supplies a &quot;continue&quot; block that
operates as a second half of the body. All of these optree
inputs are consumed by this function and become part of the
constructed op tree.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;flags&quot;
gives the eight bits of &quot;op_flags&quot; for the
&quot;leaveloop&quot; op and, shifted up eight bits, the
eight bits of &quot;op_private&quot; for the
&quot;leaveloop&quot; op, except that (in both cases) some
bits will be set automatically. &quot;debuggable&quot; is
currently unused and should always be 1. &quot;has_my&quot;
can be supplied as true to force the loop body to be
enclosed in its own scope.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
newWHILEOP(I32 flags, I32 debuggable, LOOP* loop, OP* expr,
<br>
OP* block, OP* cont, I32 has_my)</p>

<p style="margin-left:11%;">&quot;newXS&quot;</p>

<p style="margin-left:17%;">Used by &quot;xsubpp&quot; to
hook up XSUBs as Perl subs. &quot;filename&quot; needs to be
static storage, as it is used directly as <b>CvFILE()</b>,
without a copy being made.</p>

<p style="margin-left:11%;">&quot;OA_BASEOP&quot; <br>
&quot;OA_BINOP&quot; <br>
&quot;OA_COP&quot; <br>
&quot;OA_LISTOP&quot; <br>
&quot;OA_LOGOP&quot; <br>
&quot;OA_PADOP&quot; <br>
&quot;OA_PMOP&quot; <br>
&quot;OA_PVOP_OR_SVOP&quot; <br>
&quot;OA_SVOP&quot; <br>
&quot;OA_UNOP&quot; <br>
&quot;OA_LOOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;OP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;op_append_elem&quot;</p>

<p style="margin-left:17%;">Append an item to the list of
ops contained directly within a list-type op, returning the
lengthened list. &quot;first&quot; is the list-type op, and
&quot;last&quot; is the op to append to the list.
&quot;optype&quot; specifies the intended opcode for the
list. If &quot;first&quot; is not already a list of the
right type, it will be upgraded into one. If either
&quot;first&quot; or &quot;last&quot; is null, the other is
returned unchanged.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_append_elem(I32 optype, OP* first, OP* last)</p>

<p style="margin-left:11%;">&quot;op_append_list&quot;</p>

<p style="margin-left:17%;">Concatenate the lists of ops
contained directly within two list-type ops, returning the
combined list. &quot;first&quot; and &quot;last&quot; are
the list-type ops to concatenate. &quot;optype&quot;
specifies the intended opcode for the list. If either
&quot;first&quot; or &quot;last&quot; is not already a list
of the right type, it will be upgraded into one. If either
&quot;first&quot; or &quot;last&quot; is null, the other is
returned unchanged.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_append_list(I32 optype, OP* first, OP* last)</p>

<p style="margin-left:11%;">&quot;OP_CLASS&quot;</p>

<p style="margin-left:17%;">Return the class of the
provided <small>OP:</small> that is, which of the *OP
structures it uses. For core ops this currently gets the
information out of &quot;PL_opargs&quot;, which does not
always accurately reflect the type used; in v5.26 onwards,
see also the function &quot;op_class&quot; which can do a
better job of determining the used type.</p>

<p style="margin-left:17%; margin-top: 1em">For custom ops
the type is returned from the registration, and it is up to
the registree to ensure it is accurate. The value returned
will be one of the &quot;OA_&quot;* constants from
<i>op.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">U32 OP_CLASS(OP
*o)</p>


<p style="margin-left:11%;">&quot;op_contextualize&quot;</p>

<p style="margin-left:17%;">Applies a syntactic context to
an op tree representing an expression. &quot;o&quot; is the
op tree, and &quot;context&quot; must be
&quot;G_SCALAR&quot;, &quot;G_LIST&quot;, or
&quot;G_VOID&quot; to specify the context to apply. The
modified op tree is returned.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_contextualize(OP* o, I32 context)</p>


<p style="margin-left:11%;">&quot;op_convert_list&quot;</p>

<p style="margin-left:17%;">Converts &quot;o&quot; into a
list op if it is not one already, and then converts it into
the specified &quot;type&quot;, calling its check function,
allocating a target if it needs one, and folding
constants.</p>

<p style="margin-left:17%; margin-top: 1em">A list-type op
is usually constructed one kid at a time via
&quot;newLISTOP&quot;, &quot;op_prepend_elem&quot; and
&quot;op_append_elem&quot;. Then finally it is passed to
&quot;op_convert_list&quot; to make it the right type.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_convert_list(I32 optype, I32 flags, OP* o)</p>

<p style="margin-left:11%;">&quot;OP_DESC&quot;</p>

<p style="margin-left:17%;">Return a short description of
the provided <small>OP.</small></p>

<p style="margin-left:17%; margin-top: 1em">const char *
OP_DESC(OP *o)</p>

<p style="margin-left:11%;">&quot;op_free&quot;</p>

<p style="margin-left:17%;">Free an op and its children.
Only use this when an op is no longer linked to from any
optree.</p>

<p style="margin-left:17%; margin-top: 1em">void
op_free(OP* arg)</p>

<p style="margin-left:11%;">&quot;OpHAS_SIBLING&quot;</p>

<p style="margin-left:17%;">Returns true if &quot;o&quot;
has a sibling</p>

<p style="margin-left:17%; margin-top: 1em">bool
OpHAS_SIBLING(OP *o)</p>

<p style="margin-left:11%;">&quot;OpLASTSIB_set&quot;</p>

<p style="margin-left:17%;">Marks &quot;o&quot; as having
no further siblings and marks o as having the specified
parent. See also &quot;OpMORESIB_set&quot; and
&quot;OpMAYBESIB_set&quot;. For a higher-level interface,
see &quot;op_sibling_splice&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
OpLASTSIB_set(OP *o, OP *parent)</p>

<p style="margin-left:11%;">&quot;op_linklist&quot;</p>

<p style="margin-left:17%;">This function is the
implementation of the &quot; <small>LINKLIST&quot;</small>
macro. It should not be called directly.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_linklist(OP *o)</p>

<p style="margin-left:11%;">&quot;op_lvalue&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;op_lvalue&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Propagate
lvalue (&quot;modifiable&quot;) context to an op and its
children. &quot;type&quot; represents the context type,
roughly based on the type of op that would do the modifying,
although &quot;local()&quot; is represented by
&quot;OP_NULL&quot;, because it has no op type of its own
(it is signalled by a flag on the lvalue op).</p>

<p style="margin-left:17%; margin-top: 1em">This function
detects things that can&rsquo;t be modified, such as
&quot;$x+1&quot;, and generates errors for them. For
example, &quot;$x+1 = 2&quot; would cause it to be called
with an op of type &quot;OP_ADD&quot; and a &quot;type&quot;
argument of &quot;OP_SASSIGN&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">It also flags
things that need to behave specially in an lvalue context,
such as &quot;$$x = 5&quot; which might have to vivify a
reference in $x.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_lvalue(OP* o, I32 type)</p>

<p style="margin-left:11%;">&quot;OpMAYBESIB_set&quot;</p>

<p style="margin-left:17%;">Conditionally does
&quot;OpMORESIB_set&quot; or &quot;OpLASTSIB_set&quot;
depending on whether &quot;sib&quot; is non-null. For a
higher-level interface, see
&quot;op_sibling_splice&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
OpMAYBESIB_set(OP *o, OP *sib, OP *parent)</p>

<p style="margin-left:11%;">&quot;OpMORESIB_set&quot;</p>

<p style="margin-left:17%;">Sets the sibling of
&quot;o&quot; to the non-zero value &quot;sib&quot;. See
also &quot;OpLASTSIB_set&quot; and
&quot;OpMAYBESIB_set&quot;. For a higher-level interface,
see &quot;op_sibling_splice&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
OpMORESIB_set(OP *o, OP *sib)</p>

<p style="margin-left:11%;">&quot;OP_NAME&quot;</p>

<p style="margin-left:17%;">Return the name of the provided
<small>OP.</small> For core ops this looks up the name from
the op_type; for custom ops from the op_ppaddr.</p>

<p style="margin-left:17%; margin-top: 1em">const char *
OP_NAME(OP *o)</p>

<p style="margin-left:11%;">&quot;op_null&quot;</p>

<p style="margin-left:17%;">Neutralizes an op when it is no
longer needed, but is still linked to from other ops.</p>

<p style="margin-left:17%; margin-top: 1em">void
op_null(OP* o)</p>

<p style="margin-left:11%;">&quot;op_parent&quot;</p>

<p style="margin-left:17%;">Returns the parent
<small>OP</small> of &quot;o&quot;, if it has a parent.
Returns &quot;NULL&quot; otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_parent(OP *o)</p>


<p style="margin-left:11%;">&quot;op_prepend_elem&quot;</p>

<p style="margin-left:17%;">Prepend an item to the list of
ops contained directly within a list-type op, returning the
lengthened list. &quot;first&quot; is the op to prepend to
the list, and &quot;last&quot; is the list-type op.
&quot;optype&quot; specifies the intended opcode for the
list. If &quot;last&quot; is not already a list of the right
type, it will be upgraded into one. If either
&quot;first&quot; or &quot;last&quot; is null, the other is
returned unchanged.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_prepend_elem(I32 optype, OP* first, OP* last)</p>

<p style="margin-left:11%;">&quot;op_scope&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;op_scope&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Wraps up an op
tree with some additional ops so that at runtime a dynamic
scope will be created. The original ops run in the new
dynamic scope, and then, provided that they exit normally,
the scope will be unwound. The additional ops used to create
and unwind the dynamic scope will normally be an
&quot;enter&quot;/&quot;leave&quot; pair, but a
&quot;scope&quot; op may be used instead if the ops are
simple enough to not need the full dynamic scope
structure.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_scope(OP* o)</p>

<p style="margin-left:11%;">&quot;OpSIBLING&quot;</p>

<p style="margin-left:17%;">Returns the sibling of
&quot;o&quot;, or &quot;NULL&quot; if there is no
sibling</p>

<p style="margin-left:17%; margin-top: 1em">OP*
OpSIBLING(OP *o)</p>


<p style="margin-left:11%;">&quot;op_sibling_splice&quot;</p>

<p style="margin-left:17%;">A general function for editing
the structure of an existing chain of op_sibling nodes. By
analogy with the perl-level &quot;splice()&quot; function,
allows you to delete zero or more sequential nodes,
replacing them with zero or more different nodes. Performs
the necessary op_first/op_last housekeeping on the parent
node and op_sibling manipulation on the children. The last
deleted node will be marked as the last node by updating the
op_sibling/op_sibparent or op_moresib field as
appropriate.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
op_next is not manipulated, and nodes are not freed; that is
the responsibility of the caller. It also won&rsquo;t create
a new list op for an empty list etc; use higher-level
functions like <b>op_append_elem()</b> for that.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;parent&quot;
is the parent node of the sibling chain. It may passed as
&quot;NULL&quot; if the splicing doesn&rsquo;t affect the
first or last op in the chain.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;start&quot;
is the node preceding the first node to be spliced. Node(s)
following it will be deleted, and ops will be inserted after
it. If it is &quot;NULL&quot;, the first node onwards is
deleted, and nodes are inserted at the beginning.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;del_count&quot;
is the number of nodes to delete. If zero, no nodes are
deleted. If &minus;1 or greater than or equal to the number
of remaining kids, all remaining kids are deleted.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;insert&quot;
is the first of a chain of nodes to be inserted in place of
the nodes. If &quot;NULL&quot;, no nodes are inserted.</p>

<p style="margin-left:17%; margin-top: 1em">The head of the
chain of deleted ops is returned, or &quot;NULL&quot; if no
ops were deleted.</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<p style="margin-left:17%; margin-top: 1em">action before
after returns <br>
&minus;&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus;&minus;&minus; <br>
P P <br>
splice(P, A, 2, X&minus;Y&minus;Z) | | B&minus;C <br>
A&minus;B&minus;C&minus;D A&minus;X&minus;Y&minus;Z&minus;D
<br>
P P <br>
splice(P, NULL, 1, X&minus;Y) | | A <br>
A&minus;B&minus;C&minus;D X&minus;Y&minus;B&minus;C&minus;D
<br>
P P <br>
splice(P, NULL, 3, NULL) | | A&minus;B&minus;C <br>
A&minus;B&minus;C&minus;D D <br>
P P <br>
splice(P, B, 0, X&minus;Y) | | NULL <br>
A&minus;B&minus;C&minus;D
A&minus;B&minus;X&minus;Y&minus;C&minus;D</p>

<p style="margin-left:17%; margin-top: 1em">For lower-level
direct manipulation of &quot;op_sibparent&quot; and
&quot;op_moresib&quot;, see &quot;OpMORESIB_set&quot;,
&quot;OpLASTSIB_set&quot;, &quot;OpMAYBESIB_set&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_sibling_splice(OP *parent, OP *start, int del_count, <br>
OP* insert)</p>

<p style="margin-left:11%;">&quot;OP_TYPE_IS&quot;</p>

<p style="margin-left:17%;">Returns true if the given
<small>OP</small> is not a &quot;NULL&quot; pointer and if
it is of the given type.</p>

<p style="margin-left:17%; margin-top: 1em">The negation of
this macro, &quot;OP_TYPE_ISNT&quot; is also available as
well as &quot;OP_TYPE_IS_NN&quot; and
&quot;OP_TYPE_ISNT_NN&quot; which elide the
<small>NULL</small> pointer check.</p>

<p style="margin-left:17%; margin-top: 1em">bool
OP_TYPE_IS(OP *o, Optype type)</p>


<p style="margin-left:11%;">&quot;OP_TYPE_IS_OR_WAS&quot;</p>

<p style="margin-left:17%;">Returns true if the given
<small>OP</small> is not a <small>NULL</small> pointer and
if it is of the given type or used to be before being
replaced by an <small>OP</small> of type
<small>OP_NULL.</small></p>

<p style="margin-left:17%; margin-top: 1em">The negation of
this macro, &quot;OP_TYPE_ISNT_AND_WASNT&quot; is also
available as well as &quot;OP_TYPE_IS_OR_WAS_NN&quot; and
&quot;OP_TYPE_ISNT_AND_WASNT_NN&quot; which elide the
&quot;NULL&quot; pointer check.</p>

<p style="margin-left:17%; margin-top: 1em">bool
OP_TYPE_IS_OR_WAS(OP *o, Optype type)</p>


<p style="margin-left:11%;">&quot;op_wrap_finally&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;op_wrap_finally&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Wraps the given
&quot;block&quot; optree fragment in its own scoped block,
arranging for the &quot;finally&quot; optree fragment to be
invoked when leaving that block for any reason. Both optree
fragments are consumed and the combined result is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">OP*
op_wrap_finally(OP *block, OP *finally)</p>

<p style="margin-left:11%;">&quot;peep_t&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;Perl_cpeep_t&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_opfreehook&quot;</p>

<p style="margin-left:17%;">When
non&minus;&quot;NULL&quot;, the function pointed by this
variable will be called each time an <small>OP</small> is
freed with the corresponding <small>OP</small> as the
argument. This allows extensions to free any extra attribute
they have locally attached to an <small>OP.</small> It is
also assured to first fire for the parent <small>OP</small>
and then for its kids.</p>

<p style="margin-left:17%; margin-top: 1em">When you
replace this variable, it is considered a good practice to
store the possibly previously installed hook and that you
recall it inside your own.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">Perl_ophook_t
PL_opfreehook</p>

<p style="margin-left:11%;">&quot;PL_peepp&quot;</p>

<p style="margin-left:17%;">Pointer to the per-subroutine
peephole optimiser. This is a function that gets called at
the end of compilation of a Perl subroutine (or equivalently
independent piece of Perl code) to perform fixups of some
ops and to perform small-scale optimisations. The function
is called once for each subroutine that is compiled, and is
passed, as sole parameter, a pointer to the op that is the
entry point to the subroutine. It modifies the op tree in
place.</p>

<p style="margin-left:17%; margin-top: 1em">The peephole
optimiser should never be completely replaced. Rather, add
code to it by wrapping the existing optimiser. The basic way
to do this can be seen in &quot;Compile pass 3: peephole
optimization&quot; in perlguts. If the new code wishes to
operate on ops throughout the subroutine&rsquo;s structure,
rather than just at the top level, it is likely to be more
convenient to wrap the &quot;PL_rpeepp&quot; hook.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">peep_t
PL_peepp</p>

<p style="margin-left:11%;">&quot;PL_rpeepp&quot;</p>

<p style="margin-left:17%;">Pointer to the recursive
peephole optimiser. This is a function that gets called at
the end of compilation of a Perl subroutine (or equivalently
independent piece of Perl code) to perform fixups of some
ops and to perform small-scale optimisations. The function
is called once for each chain of ops linked through their
&quot;op_next&quot; fields; it is recursively called to
handle each side chain. It is passed, as sole parameter, a
pointer to the op that is at the head of the chain. It
modifies the op tree in place.</p>

<p style="margin-left:17%; margin-top: 1em">The peephole
optimiser should never be completely replaced. Rather, add
code to it by wrapping the existing optimiser. The basic way
to do this can be seen in &quot;Compile pass 3: peephole
optimization&quot; in perlguts. If the new code wishes to
operate only on ops at a subroutine&rsquo;s top level,
rather than throughout the structure, it is likely to be
more convenient to wrap the &quot;PL_peepp&quot; hook.</p>

<p style="margin-left:17%; margin-top: 1em">On threaded
perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of
the creating thread&rsquo;s copy.</p>

<p style="margin-left:17%; margin-top: 1em">peep_t
PL_rpeepp</p>

<p style="margin-left:11%;">&quot;PMOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;rv2cv_op_cv&quot;</p>

<p style="margin-left:17%;">Examines an op, which is
expected to identify a subroutine at runtime, and attempts
to determine at compile time which subroutine it identifies.
This is normally used during Perl compilation to determine
whether a prototype can be applied to a function call.
&quot;cvop&quot; is the op being considered, normally an
&quot;rv2cv&quot; op. A pointer to the identified subroutine
is returned, if it could be determined statically, and a
null pointer is returned if it was not possible to determine
statically.</p>

<p style="margin-left:17%; margin-top: 1em">Currently, the
subroutine can be identified statically if the
<small>RV</small> that the &quot;rv2cv&quot; is to operate
on is provided by a suitable &quot;gv&quot; or
&quot;const&quot; op. A &quot;gv&quot; op is suitable if the
<small>GV</small> &rsquo;s <small>CV</small> slot is
populated. A &quot;const&quot; op is suitable if the
constant value must be an <small>RV</small> pointing to a
<small>CV.</small> Details of this process may change in
future versions of Perl. If the &quot;rv2cv&quot; op has the
&quot;OPpENTERSUB_AMPER&quot; flag set then no attempt is
made to identify the subroutine statically: this flag is
used to suppress compile-time magic on a subroutine call,
forcing it to use default runtime behaviour.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; has the bit
&quot;RV2CVOPCV_MARK_EARLY&quot; set, then the handling of a
<small>GV</small> reference is modified. If a
<small>GV</small> was examined and its <small>CV</small>
slot was found to be empty, then the &quot;gv&quot; op has
the &quot;OPpEARLY_CV&quot; flag set. If the op is not
optimised away, and the <small>CV</small> slot is later
populated with a subroutine having a prototype, that flag
eventually triggers the warning &quot;called too early to
check prototype&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; has the bit
&quot;RV2CVOPCV_RETURN_NAME_GV&quot; set, then instead of
returning a pointer to the subroutine it returns a pointer
to the <small>GV</small> giving the most appropriate name
for the subroutine in this context. Normally this is just
the &quot;CvGV&quot; of the subroutine, but for an anonymous
(&quot;CvANON&quot;) subroutine that is referenced through a
<small>GV</small> it will be the referencing
<small>GV.</small> The resulting &quot;GV*&quot; is cast to
&quot;CV*&quot; to be returned. A null pointer is returned
as usual if there is no statically-determinable
subroutine.</p>

<p style="margin-left:17%; margin-top: 1em">CV*
rv2cv_op_cv(OP *cvop, U32 flags)</p>

<p style="margin-left:11%;">&quot;UNOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;XOP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<h2>Pack and Unpack
<a name="Pack and Unpack"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;pack_cat&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;pack_cat&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">The engine
implementing &quot;pack()&quot; Perl function. Note:
parameters &quot;next_in_list&quot; and &quot;flags&quot;
are not used. This call should not be used; use
&quot;packlist&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
pack_cat(SV *cat, const char *pat, const char *patend, <br>
SV **beglist, SV **endlist, SV ***next_in_list, <br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;packlist&quot;</p>

<p style="margin-left:17%;">The engine implementing
&quot;pack()&quot; Perl function.</p>

<p style="margin-left:17%; margin-top: 1em">void
packlist(SV *cat, const char *pat, const char *patend, <br>
SV **beglist, SV **endlist)</p>

<p style="margin-left:11%;">&quot;unpack_str&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;unpack_str&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">The engine
implementing &quot;unpack()&quot; Perl function. Note:
parameters &quot;strbeg&quot;, &quot;new_s&quot; and
&quot;ocnt&quot; are not used. This call should not be used,
use &quot;unpackstring&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
unpack_str(const char *pat, const char *patend, <br>
const char *s, const char *strbeg, <br>
const char *strend, char **new_s, I32 ocnt, <br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;unpackstring&quot;</p>

<p style="margin-left:17%;">The engine implementing the
&quot;unpack()&quot; Perl function.</p>

<p style="margin-left:17%; margin-top: 1em">Using the
template &quot;pat..patend&quot;, this function unpacks the
string &quot;s..strend&quot; into a number of mortal SVs,
which it pushes onto the perl argument (@_) stack (so you
will need to issue a &quot;PUTBACK&quot; before and
&quot;SPAGAIN&quot; after the call to this function). It
returns the number of pushed elements.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;strend&quot; and &quot;patend&quot; pointers should
point to the byte following the last character of each
string.</p>

<p style="margin-left:17%; margin-top: 1em">Although this
function returns its values on the perl argument stack, it
doesn&rsquo;t take any parameters from that stack (and thus
in particular there&rsquo;s no need to do a
&quot;PUSHMARK&quot; before calling it, unlike
&quot;call_pv&quot; for example).</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
unpackstring(const char *pat, const char *patend, <br>
const char *s, const char *strend, <br>
U32 flags)</p>

<h2>Pad Data Structures
<a name="Pad Data Structures"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;CvPADLIST&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;CvPADLIST&quot; is <b>experimental</b> and may change
or be removed without notice.</p>


<p style="margin-left:17%; margin-top: 1em"><small>CV</small>
&rsquo;s can have CvPADLIST(cv) set to point to a
<small>PADLIST.</small> This is the <small>CV</small>
&rsquo;s scratchpad, which stores lexical variables and
opcode temporary and per-thread values.</p>

<p style="margin-left:17%; margin-top: 1em">For these
purposes &quot;formats&quot; are a kind-of <small>CV</small>
; eval&quot;&quot;s are too (except they&rsquo;re not
callable at will and are always thrown away after the
eval&quot;&quot; is done executing). Require&rsquo;d files
are simply evals without any outer lexical scope.</p>

<p style="margin-left:17%; margin-top: 1em">XSUBs do not
have a &quot;CvPADLIST&quot;. &quot;dXSTARG&quot; fetches
values from &quot;PL_curpad&quot;, but that is really the
callers pad (a slot of which is allocated by every
entersub). Do not get or set &quot;CvPADLIST&quot; if a
<small>CV</small> is an <small>XSUB</small> (as determined
by &quot;CvISXSUB()&quot;), &quot;CvPADLIST&quot; slot is
reused for a different internal purpose in XSUBs.</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>PADLIST</small> has a C array where pads are
stored.</p>

<p style="margin-left:17%; margin-top: 1em">The 0th entry
of the <small>PADLIST</small> is a
<small>PADNAMELIST</small> which represents the
&quot;names&quot; or rather the &quot;static type
information&quot; for lexicals. The individual elements of a
<small>PADNAMELIST</small> are PADNAMEs. Future refactorings
might stop the <small>PADNAMELIST</small> from being stored
in the <small>PADLIST</small> &rsquo;s array, so don&rsquo;t
rely on it. See &quot;PadlistNAMES&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The
CvDEPTH&rsquo;th entry of a <small>PADLIST</small> is a
<small>PAD</small> (an <small>AV</small> ) which is the
stack frame at that depth of recursion into the
<small>CV.</small> The 0th slot of a frame <small>AV</small>
is an <small>AV</small> which is @_. Other entries are
storage for variables and op targets.</p>

<p style="margin-left:17%; margin-top: 1em">Iterating over
the <small>PADNAMELIST</small> iterates over all possible
pad items. Pad slots for targets (&quot;SVs_PADTMP&quot;)
and GVs end up having &amp;PL_padname_undef
&quot;names&quot;, while slots for constants have
&amp;PL_padname_const &quot;names&quot; (see
&quot;pad_alloc&quot;). That &amp;PL_padname_undef and
&amp;PL_padname_const are used is an implementation detail
subject to change. To test for them, use
&quot;!PadnamePV(name)&quot; and
&quot;PadnamePV(name)&nbsp;&amp;&amp;&nbsp;!PadnameLEN(name)&quot;,
respectively.</p>

<p style="margin-left:17%; margin-top: 1em">Only
&quot;my&quot;/&quot;our&quot; variable slots get valid
names. The rest are op targets/GVs/constants which are
statically allocated or resolved at compile time. These
don&rsquo;t have names by which they can be looked up from
Perl code at run time through eval&quot;&quot; the way
&quot;my&quot;/&quot;our&quot; variables can be. Since they
can&rsquo;t be looked up by &quot;name&quot; but only by
their index allocated at compile time (which is usually in
&quot;PL_op&minus;&gt;op_targ&quot;), wasting a name
<small>SV</small> for them doesn&rsquo;t make sense.</p>

<p style="margin-left:17%; margin-top: 1em">The pad names
in the <small>PADNAMELIST</small> have their
<small>PV</small> holding the name of the variable. The
&quot;COP_SEQ_RANGE_LOW&quot; and &quot;_HIGH&quot; fields
form a range (low+1..high inclusive) of cop_seq numbers for
which the name is valid. During compilation, these fields
may hold the special value <small>PERL_PADSEQ_INTRO</small>
to indicate various stages:</p>


<p style="margin-left:17%; margin-top: 1em">COP_SEQ_RANGE_LOW
_HIGH <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus; <br>
PERL_PADSEQ_INTRO 0 variable not yet introduced: <br>
{ my ($x <br>
valid&minus;seq# PERL_PADSEQ_INTRO variable in scope: <br>
{ my ($x); <br>
valid&minus;seq# valid&minus;seq# compilation of scope
complete: <br>
{ my ($x); .... }</p>

<p style="margin-left:17%; margin-top: 1em">When a lexical
var hasn&rsquo;t yet been introduced, it already exists from
the perspective of duplicate declarations, but not for
variable lookups, e.g.</p>

<p style="margin-left:17%; margin-top: 1em">my ($x, $x); #
'&quot;my&quot; variable $x masks earlier declaration' <br>
my $x = $x; # equal to my $x = $::x;</p>

<p style="margin-left:17%; margin-top: 1em">For typed
lexicals &quot;PadnameTYPE&quot; points at the type stash.
For &quot;our&quot; lexicals, &quot;PadnameOURSTASH&quot;
points at the stash of the associated global (so that
duplicate &quot;our&quot; declarations in the same package
can be detected). &quot;PadnameGEN&quot; is sometimes used
to store the generation number during compilation.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;PadnameOUTER&quot; is set on the pad name, then that
slot in the frame <small>AV</small> is a
<small>REFCNT</small> &rsquo;ed reference to a lexical from
&quot;outside&quot;. Such entries are sometimes referred to
as &rsquo;fake&rsquo;. In this case, the name does not use
&rsquo;low&rsquo; and &rsquo;high&rsquo; to store a cop_seq
range, since it is in scope throughout. Instead
&rsquo;high&rsquo; stores some flags containing info about
the real lexical (is it declared in an anon, and is it
capable of being instantiated multiple times?), and for fake
ANONs, &rsquo;low&rsquo; contains the index within the
parent&rsquo;s pad where the lexical&rsquo;s value is
stored, to make cloning quicker.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&rsquo;name&rsquo; is &quot;&amp;&quot; the corresponding
entry in the <small>PAD</small> is a <small>CV</small>
representing a possible closure.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
formats are treated as anon subs, and are cloned each time
write is called (if necessary).</p>

<p style="margin-left:17%; margin-top: 1em">The flag
&quot;SVs_PADSTALE&quot; is cleared on lexicals each time
the &quot;my()&quot; is executed, and set on scope exit.
This allows the &quot;Variable $x is not available&quot;
warning to be generated in evals, such as</p>

<p style="margin-left:17%; margin-top: 1em">{ my $x = 1;
sub f { eval '$x'} } f();</p>

<p style="margin-left:17%; margin-top: 1em">For state vars,
&quot;SVs_PADSTALE&quot; is overloaded to mean &rsquo;not
yet initialised&rsquo;, but this internal state is stored in
a separate pad entry.</p>

<p style="margin-left:17%; margin-top: 1em">PADLIST *
CvPADLIST(CV *cv)</p>


<p style="margin-left:11%;">&quot;pad_add_name_pvs&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;pad_add_name_pvn&quot;, but takes a literal string
instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_add_name_pvs(&quot;name&quot;, U32 flags, HV *typestash,
<br>
HV *ourstash)</p>

<p style="margin-left:11%;">&quot;PadARRAY&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadARRAY&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The C array of
pad entries.</p>

<p style="margin-left:17%; margin-top: 1em">SV **
PadARRAY(PAD * pad)</p>


<p style="margin-left:11%;">&quot;pad_compname_type&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;pad_compname_type&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Looks up the
type of the lexical variable at position &quot;po&quot; in
the currently-compiling pad. If the variable is typed, the
stash of the class to which it is typed is returned. If not,
&quot;NULL&quot; is returned.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;&quot;PAD_COMPNAME_TYPE&quot;&quot; in perlintern
instead.</p>

<p style="margin-left:17%; margin-top: 1em">HV*
pad_compname_type(const PADOFFSET po)</p>

<p style="margin-left:11%;">&quot;pad_findmy_pvs&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;pad_findmy_pvn&quot;, but takes a literal string
instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">PADOFFSET
pad_findmy_pvs(&quot;name&quot;, U32 flags)</p>

<p style="margin-left:11%;">&quot;PadlistARRAY&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadlistARRAY&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The C array of
a padlist, containing the pads. Only subscript it with
numbers &gt;= 1, as the 0th entry is not guaranteed to
remain usable.</p>

<p style="margin-left:17%; margin-top: 1em">PAD **
PadlistARRAY(PADLIST * padlist)</p>

<p style="margin-left:11%;">&quot;PadlistMAX&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadlistMAX&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The index of
the last allocated space in the padlist. Note that the last
pad may be in an earlier slot. Any entries following it will
be &quot;NULL&quot; in that case.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
PadlistMAX(PADLIST * padlist)</p>

<p style="margin-left:11%;">&quot;PadlistNAMES&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadlistNAMES&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The names
associated with pad entries.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAMELIST *
PadlistNAMES(PADLIST * padlist)</p>


<p style="margin-left:11%;">&quot;PadlistNAMESARRAY&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadlistNAMESARRAY&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The C array of
pad names.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAME **
PadlistNAMESARRAY(PADLIST * padlist)</p>


<p style="margin-left:11%;">&quot;PadlistNAMESMAX&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadlistNAMESMAX&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The index of
the last pad name.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
PadlistNAMESMAX(PADLIST * padlist)</p>

<p style="margin-left:11%;">&quot;PadlistREFCNT&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadlistREFCNT&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The reference
count of the padlist. Currently this is always 1.</p>

<p style="margin-left:17%; margin-top: 1em">U32
PadlistREFCNT(PADLIST * padlist)</p>

<p style="margin-left:11%;">&quot;PadMAX&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadMAX&quot; is <b>experimental</b> and may change or
be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The index of
the last pad entry.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
PadMAX(PAD * pad)</p>

<p style="margin-left:11%;">&quot;PadnameLEN&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnameLEN&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The length of
the name.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
PadnameLEN(PADNAME * pn)</p>


<p style="margin-left:11%;">&quot;PadnamelistARRAY&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnamelistARRAY&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The C array of
pad names.</p>

<p style="margin-left:17%; margin-top: 1em">PADNAME **
PadnamelistARRAY(PADNAMELIST * pnl)</p>

<p style="margin-left:11%;">&quot;PadnamelistMAX&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnamelistMAX&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The index of
the last pad name.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
PadnamelistMAX(PADNAMELIST * pnl)</p>


<p style="margin-left:11%;">&quot;PadnamelistREFCNT&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnamelistREFCNT&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The reference
count of the pad name list.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
PadnamelistREFCNT(PADNAMELIST * pnl)</p>


<p style="margin-left:11%;">&quot;PadnamelistREFCNT_dec&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnamelistREFCNT_dec&quot; is <b>experimental</b> and
may change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Lowers the
reference count of the pad name list.</p>

<p style="margin-left:17%; margin-top: 1em">void
PadnamelistREFCNT_dec(PADNAMELIST * pnl)</p>

<p style="margin-left:11%;">&quot;PadnamePV&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnamePV&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The name stored
in the pad name struct. This returns &quot;NULL&quot; for a
target slot.</p>

<p style="margin-left:17%; margin-top: 1em">char *
PadnamePV(PADNAME * pn)</p>

<p style="margin-left:11%;">&quot;PadnameREFCNT&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnameREFCNT&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">The reference
count of the pad name.</p>

<p style="margin-left:17%; margin-top: 1em">SSize_t
PadnameREFCNT(PADNAME * pn)</p>


<p style="margin-left:11%;">&quot;PadnameREFCNT_dec&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnameREFCNT_dec&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Lowers the
reference count of the pad name.</p>

<p style="margin-left:17%; margin-top: 1em">void
PadnameREFCNT_dec(PADNAME * pn)</p>

<p style="margin-left:11%;">&quot;PadnameSV&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnameSV&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the pad
name as a mortal <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">SV *
PadnameSV(PADNAME * pn)</p>

<p style="margin-left:11%;">&quot;PadnameUTF8&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PadnameUTF8&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Whether
PadnamePV is in <small>UTF&minus;8.</small> Currently, this
is always true.</p>

<p style="margin-left:17%; margin-top: 1em">bool
PadnameUTF8(PADNAME * pn)</p>

<p style="margin-left:11%;">&quot;pad_new&quot;</p>

<p style="margin-left:17%;">Create a new padlist, updating
the global variables for the currently-compiling padlist to
point to the new padlist. The following flags can be
<small>OR</small> &rsquo;ed together:</p>

<p style="margin-left:17%; margin-top: 1em">padnew_CLONE
this pad is for a cloned CV <br>
padnew_SAVE save old globals on the save stack <br>
padnew_SAVESUB also save extra stuff for start of sub</p>

<p style="margin-left:17%; margin-top: 1em">PADLIST*
pad_new(int flags)</p>

<p style="margin-left:11%;">&quot;PL_comppad&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PL_comppad&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">During
compilation, this points to the array containing the values
part of the pad for the currently-compiling code. (At
runtime a <small>CV</small> may have many such value arrays;
at compile time just one is constructed.) At runtime, this
points to the array containing the currently-relevant values
for the pad for the currently-executing code.</p>


<p style="margin-left:11%;">&quot;PL_comppad_name&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PL_comppad_name&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">During
compilation, this points to the array containing the names
part of the pad for the currently-compiling code.</p>

<p style="margin-left:11%;">&quot;PL_curpad&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;PL_curpad&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Points directly
to the body of the &quot;PL_comppad&quot; array. (I.e., this
is &quot;PadARRAY(PL_comppad)&quot;.)</p>

<p style="margin-left:11%;">&quot;SVs_PADMY&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;SVs_PADMY&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Described in
perlguts.</p>

<p style="margin-left:11%;">&quot;SVs_PADTMP&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<h2>Password and Group access
<a name="Password and Group access"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;GRPASSWD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct group&quot; in
<i>grp.h</i> contains &quot;gr_passwd&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_ENDGRENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the getgrent routine is available for
finalizing sequential access of the group database.</p>

<p style="margin-left:11%;">&quot;HAS_ENDGRENT_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;endgrent_r&quot; routine is
available to endgrent re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_ENDPWENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;endpwent&quot; routine is available
for finalizing sequential access of the passwd database.</p>

<p style="margin-left:11%;">&quot;HAS_ENDPWENT_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;endpwent_r&quot; routine is
available to endpwent re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_GETGRENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;getgrent&quot; routine is available
for sequential access of the group database.</p>

<p style="margin-left:11%;">&quot;HAS_GETGRENT_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;getgrent_r&quot; routine is
available to getgrent re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_GETPWENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;getpwent&quot; routine is available
for sequential access of the passwd database. If this is not
available, the older &quot;getpw()&quot; function may be
available.</p>

<p style="margin-left:11%;">&quot;HAS_GETPWENT_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;getpwent_r&quot; routine is
available to getpwent re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_SETGRENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setgrent&quot; routine is available
for initializing sequential access of the group
database.</p>

<p style="margin-left:11%;">&quot;HAS_SETGRENT_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setgrent_r&quot; routine is
available to setgrent re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_SETPWENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setpwent&quot; routine is available
for initializing sequential access of the passwd
database.</p>

<p style="margin-left:11%;">&quot;HAS_SETPWENT_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setpwent_r&quot; routine is
available to setpwent re-entrantly.</p>

<p style="margin-left:11%;">&quot;PWAGE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct passwd&quot;
contains &quot;pw_age&quot;.</p>

<p style="margin-left:11%;">&quot;PWCHANGE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct passwd&quot;
contains &quot;pw_change&quot;.</p>

<p style="margin-left:11%;">&quot;PWCLASS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct passwd&quot;
contains &quot;pw_class&quot;.</p>

<p style="margin-left:11%;">&quot;PWCOMMENT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct passwd&quot;
contains &quot;pw_comment&quot;.</p>

<p style="margin-left:11%;">&quot;PWEXPIRE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct passwd&quot;
contains &quot;pw_expire&quot;.</p>

<p style="margin-left:11%;">&quot;PWGECOS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct passwd&quot;
contains &quot;pw_gecos&quot;.</p>

<p style="margin-left:11%;">&quot;PWPASSWD&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct passwd&quot;
contains &quot;pw_passwd&quot;.</p>

<p style="margin-left:11%;">&quot;PWQUOTA&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that &quot;struct passwd&quot;
contains &quot;pw_quota&quot;.</p>

<h2>Paths to system commands
<a name="Paths to system commands"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;CSH&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
contains the full pathname of csh.</p>

<p style="margin-left:11%;">&quot;LOC_SED&quot;</p>

<p style="margin-left:17%;">This symbol holds the complete
pathname to the sed program.</p>

<p style="margin-left:11%;">&quot;SH_PATH&quot;</p>

<p style="margin-left:17%;">This symbol contains the full
pathname to the shell used on this on this system to execute
Bourne shell scripts. Usually, this will be <i>/bin/sh</i>,
though it&rsquo;s possible that some systems will have
<i>/bin/ksh</i>, <i>/bin/pdksh</i>, <i>/bin/ash</i>,
<i>/bin/bash</i>, or even something such as
D:<i>/bin/sh.exe</i>.</p>

<h2>Prototype information
<a name="Prototype information"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;CRYPT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;crypt_r&quot;. It is zero if
&quot;d_crypt_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_crypt_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;CTERMID_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;ctermid_r&quot;. It is zero if
&quot;d_ctermid_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_ctermid_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;DRAND48_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;drand48_r&quot;. It is zero if
&quot;d_drand48_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_drand48_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;ENDGRENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;endgrent_r&quot;. It is zero if
&quot;d_endgrent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_endgrent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;ENDHOSTENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;endhostent_r&quot;. It is zero if
&quot;d_endhostent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_endhostent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;ENDNETENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;endnetent_r&quot;. It is zero if
&quot;d_endnetent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_endnetent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;ENDPROTOENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;endprotoent_r&quot;. It is zero if
&quot;d_endprotoent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_endprotoent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;ENDPWENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;endpwent_r&quot;. It is zero if
&quot;d_endpwent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_endpwent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;ENDSERVENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;endservent_r&quot;. It is zero if
&quot;d_endservent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_endservent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GDBMNDBM_H_USES_PROTOTYPES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>gdbm/ndbm.h</i> uses real &quot;ANSI&quot;
C prototypes instead of K&amp;R style function declarations
without any parameter information. While &quot;ANSI&quot; C
prototypes are supported in C <small>++</small> , K&amp;R
style function declarations will yield errors.</p>


<p style="margin-left:11%;">&quot;GDBM_NDBM_H_USES_PROTOTYPES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &lt;gdbm&minus;<i>ndbm.h</i>&gt; uses real
&quot;ANSI&quot; C prototypes instead of K&amp;R style
function declarations without any parameter information.
While &quot;ANSI&quot; C prototypes are supported in C
<small>++</small> , K&amp;R style function declarations will
yield errors.</p>


<p style="margin-left:11%;">&quot;GETGRENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getgrent_r&quot;. It is zero if
&quot;d_getgrent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getgrent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETGRGID_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getgrgid_r&quot;. It is zero if
&quot;d_getgrgid_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getgrgid_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETGRNAM_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getgrnam_r&quot;. It is zero if
&quot;d_getgrnam_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getgrnam_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETHOSTBYADDR_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;gethostbyaddr_r&quot;. It is zero if
&quot;d_gethostbyaddr_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_gethostbyaddr_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETHOSTBYNAME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;gethostbyname_r&quot;. It is zero if
&quot;d_gethostbyname_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_gethostbyname_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETHOSTENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;gethostent_r&quot;. It is zero if
&quot;d_gethostent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_gethostent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETLOGIN_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getlogin_r&quot;. It is zero if
&quot;d_getlogin_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getlogin_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETNETBYADDR_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getnetbyaddr_r&quot;. It is zero if
&quot;d_getnetbyaddr_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getnetbyaddr_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETNETBYNAME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getnetbyname_r&quot;. It is zero if
&quot;d_getnetbyname_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getnetbyname_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETNETENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getnetent_r&quot;. It is zero if
&quot;d_getnetent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getnetent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETPROTOBYNAME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getprotobyname_r&quot;. It is zero if
&quot;d_getprotobyname_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getprotobyname_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETPROTOBYNUMBER_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getprotobynumber_r&quot;. It is zero if
&quot;d_getprotobynumber_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getprotobynumber_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETPROTOENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getprotoent_r&quot;. It is zero if
&quot;d_getprotoent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getprotoent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETPWENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getpwent_r&quot;. It is zero if
&quot;d_getpwent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getpwent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETPWNAM_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getpwnam_r&quot;. It is zero if
&quot;d_getpwnam_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getpwnam_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETPWUID_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getpwuid_r&quot;. It is zero if
&quot;d_getpwuid_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getpwuid_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETSERVBYNAME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getservbyname_r&quot;. It is zero if
&quot;d_getservbyname_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getservbyname_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETSERVBYPORT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getservbyport_r&quot;. It is zero if
&quot;d_getservbyport_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getservbyport_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETSERVENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getservent_r&quot;. It is zero if
&quot;d_getservent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getservent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;GETSPNAM_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;getspnam_r&quot;. It is zero if
&quot;d_getspnam_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_getspnam_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;HAS_DBMINIT_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;dbminit()&quot; function. Otherwise, it is up to the
program to supply one. A good guess is</p>

<p style="margin-left:17%; margin-top: 1em">extern int
dbminit(char *);</p>


<p style="margin-left:11%;">&quot;HAS_DRAND48_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;drand48()&quot; function. Otherwise, it is up to the
program to supply one. A good guess is</p>

<p style="margin-left:17%; margin-top: 1em">extern double
drand48(void);</p>


<p style="margin-left:11%;">&quot;HAS_FLOCK_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;flock()&quot; function. Otherwise, it is up to the
program to supply one. A good guess is</p>

<p style="margin-left:17%; margin-top: 1em">extern int
flock(int, int);</p>


<p style="margin-left:11%;">&quot;HAS_GETHOST_PROTOS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>netdb.h</i> includes prototypes for
&quot;gethostent()&quot;, &quot;gethostbyname()&quot;, and
&quot;gethostbyaddr()&quot;. Otherwise, it is up to the
program to guess them. See netdbtype.U (part of metaconfig)
for probing for various &quot;Netdb_xxx_t&quot; types.</p>


<p style="margin-left:11%;">&quot;HAS_GETNET_PROTOS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>netdb.h</i> includes prototypes for
&quot;getnetent()&quot;, &quot;getnetbyname()&quot;, and
&quot;getnetbyaddr()&quot;. Otherwise, it is up to the
program to guess them. See netdbtype.U (part of metaconfig)
for probing for various &quot;Netdb_xxx_t&quot; types.</p>


<p style="margin-left:11%;">&quot;HAS_GETPROTO_PROTOS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>netdb.h</i> includes prototypes for
&quot;getprotoent()&quot;, &quot;getprotobyname()&quot;, and
&quot;getprotobyaddr()&quot;. Otherwise, it is up to the
program to guess them. See netdbtype.U (part of metaconfig)
for probing for various &quot;Netdb_xxx_t&quot; types.</p>


<p style="margin-left:11%;">&quot;HAS_GETSERV_PROTOS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>netdb.h</i> includes prototypes for
&quot;getservent()&quot;, &quot;getservbyname()&quot;, and
&quot;getservbyaddr()&quot;. Otherwise, it is up to the
program to guess them. See netdbtype.U (part of metaconfig)
for probing for various &quot;Netdb_xxx_t&quot; types.</p>


<p style="margin-left:11%;">&quot;HAS_MODFL_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;modfl()&quot; function. Otherwise, it is up to the
program to supply one.</p>

<p style="margin-left:11%;">&quot;HAS_SBRK_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;sbrk()&quot; function. Otherwise, it is up to the
program to supply one. Good guesses are</p>

<p style="margin-left:17%; margin-top: 1em">extern void*
sbrk(int); <br>
extern void* sbrk(size_t);</p>


<p style="margin-left:11%;">&quot;HAS_SETRESGID_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;setresgid()&quot; function. Otherwise, it is up to the
program to supply one. Good guesses are</p>

<p style="margin-left:17%; margin-top: 1em">extern int
setresgid(uid_t ruid, uid_t euid, uid_t suid);</p>


<p style="margin-left:11%;">&quot;HAS_SETRESUID_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;setresuid()&quot; function. Otherwise, it is up to the
program to supply one. Good guesses are</p>

<p style="margin-left:17%; margin-top: 1em">extern int
setresuid(uid_t ruid, uid_t euid, uid_t suid);</p>


<p style="margin-left:11%;">&quot;HAS_SHMAT_PROTOTYPE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the <i>sys/shm.h</i> includes a prototype for
&quot;shmat()&quot;. Otherwise, it is up to the program to
guess one. &quot;Shmat_t&quot; &quot;shmat(int, Shmat_t,
int)&quot; is a good guess, but not always right so it
should be emitted by the program only when
&quot;HAS_SHMAT_PROTOTYPE&quot; is not defined to avoid
conflicting defs.</p>


<p style="margin-left:11%;">&quot;HAS_SOCKATMARK_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;sockatmark()&quot; function. Otherwise, it is up to
the program to supply one. A good guess is</p>

<p style="margin-left:17%; margin-top: 1em">extern int
sockatmark(int);</p>


<p style="margin-left:11%;">&quot;HAS_SYSCALL_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;syscall()&quot; function. Otherwise, it is up to the
program to supply one. Good guesses are</p>

<p style="margin-left:17%; margin-top: 1em">extern int
syscall(int, ...); <br>
extern int syscall(long, ...);</p>


<p style="margin-left:11%;">&quot;HAS_TELLDIR_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;telldir()&quot; function. Otherwise, it is up to the
program to supply one. A good guess is</p>

<p style="margin-left:17%; margin-top: 1em">extern long
telldir(DIR*);</p>


<p style="margin-left:11%;">&quot;NDBM_H_USES_PROTOTYPES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>ndbm.h</i> uses real &quot;ANSI&quot; C
prototypes instead of K&amp;R style function declarations
without any parameter information. While &quot;ANSI&quot; C
prototypes are supported in C <small>++</small> , K&amp;R
style function declarations will yield errors.</p>

<p style="margin-left:11%;">&quot;RANDOM_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;random_r&quot;. It is zero if
&quot;d_random_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_random_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;READDIR_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;readdir_r&quot;. It is zero if
&quot;d_readdir_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_readdir_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SETGRENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;setgrent_r&quot;. It is zero if
&quot;d_setgrent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_setgrent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SETHOSTENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;sethostent_r&quot;. It is zero if
&quot;d_sethostent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_sethostent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SETLOCALE_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;setlocale_r&quot;. It is zero if
&quot;d_setlocale_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_setlocale_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SETNETENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;setnetent_r&quot;. It is zero if
&quot;d_setnetent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_setnetent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SETPROTOENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;setprotoent_r&quot;. It is zero if
&quot;d_setprotoent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_setprotoent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SETPWENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;setpwent_r&quot;. It is zero if
&quot;d_setpwent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_setpwent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SETSERVENT_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;setservent_r&quot;. It is zero if
&quot;d_setservent_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_setservent_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SRAND48_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;srand48_r&quot;. It is zero if
&quot;d_srand48_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_srand48_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;SRANDOM_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;srandom_r&quot;. It is zero if
&quot;d_srandom_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_srandom_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;STRERROR_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;strerror_r&quot;. It is zero if
&quot;d_strerror_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_strerror_r&quot; is defined.</p>

<p style="margin-left:11%;">&quot;TMPNAM_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;tmpnam_r&quot;. It is zero if
&quot;d_tmpnam_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_tmpnam_r&quot; is defined.</p>


<p style="margin-left:11%;">&quot;TTYNAME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;ttyname_r&quot;. It is zero if
&quot;d_ttyname_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_ttyname_r&quot; is defined.</p>

<h2>REGEXP Functions
<a name="REGEXP Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;pregcomp&quot;</p>

<p style="margin-left:17%;">Described in perlreguts.</p>

<p style="margin-left:17%; margin-top: 1em">REGEXP*
pregcomp(SV * const pattern, const U32 flags)</p>

<p style="margin-left:11%;">&quot;pregexec&quot;</p>

<p style="margin-left:17%;">Described in perlreguts.</p>

<p style="margin-left:17%; margin-top: 1em">I32
pregexec(REGEXP * const prog, char* stringarg, char* strend,
<br>
char* strbeg, SSize_t minend, SV* screamer, <br>
U32 nosave)</p>

<p style="margin-left:11%;">&quot;re_compile&quot;</p>

<p style="margin-left:17%;">Compile the regular expression
pattern &quot;pattern&quot;, returning a pointer to the
compiled object for later matching with the internal regex
engine.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is typically used by a custom regexp engine
&quot;.comp()&quot; function to hand off to the core regexp
engine those patterns it doesn&rsquo;t want to handle itself
(typically passing through the same flags it was called
with). In almost all other cases, a regexp should be
compiled by calling &quot;&quot;pregcomp&quot;&quot; to
compile using the currently active regexp engine.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;pattern&quot; is already a &quot;REGEXP&quot;, this
function does nothing but return a pointer to the input.
Otherwise the <small>PV</small> is extracted and treated
like a string representing a pattern. See perlre.</p>

<p style="margin-left:17%; margin-top: 1em">The possible
flags for &quot;rx_flags&quot; are documented in perlreapi.
Their names all begin with &quot;RXf_&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">REGEXP*
re_compile(SV * const pattern, U32 orig_rx_flags)</p>

<p style="margin-left:11%;">&quot;re_dup_guts&quot;</p>

<p style="margin-left:17%;">Duplicate a regexp.</p>

<p style="margin-left:17%; margin-top: 1em">This routine is
expected to clone a given regexp structure. It is only
compiled under <small>USE_ITHREADS.</small></p>

<p style="margin-left:17%; margin-top: 1em">After all of
the core data stored in struct regexp is duplicated the
&quot;regexp_engine.dupe&quot; method is used to copy any
private data stored in the *pprivate pointer. This allows
extensions to handle any duplication they need to do.</p>

<p style="margin-left:17%; margin-top: 1em">void
re_dup_guts(const REGEXP *sstr, REGEXP *dstr, <br>
CLONE_PARAMS* param)</p>


<p style="margin-left:11%;">&quot;REGEX_LOCALE_CHARSET&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>

<p style="margin-left:11%;">&quot;REGEXP&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>

<p style="margin-left:11%;">&quot;regexp_engine&quot;</p>

<p style="margin-left:17%;">When a regexp is compiled, its
&quot;engine&quot; field is then set to point at the
appropriate structure, so that when it needs to be used Perl
can find the right routines to do so.</p>

<p style="margin-left:17%; margin-top: 1em">In order to
install a new regexp handler, $^H{regcomp} is set to an
integer which (when casted appropriately) resolves to one of
these structures. When compiling, the &quot;comp&quot;
method is executed, and the resulting &quot;regexp&quot;
structure&rsquo;s engine field is expected to point back at
the same structure.</p>

<p style="margin-left:17%; margin-top: 1em">The pTHX_
symbol in the definition is a macro used by Perl under
threading to provide an extra argument to the routine
holding a pointer back to the interpreter that is executing
the regexp. So under threading all routines get an extra
argument.</p>


<p style="margin-left:11%;">&quot;regexp_paren_pair&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>

<p style="margin-left:11%;">&quot;regmatch_info&quot;</p>

<p style="margin-left:17%;">Some basic information about
the current match that is created by Perl_regexec_flags and
then passed to <b>regtry()</b>, <b>regmatch()</b> etc. It is
allocated as a local var on the stack, so nothing should be
stored in it that needs preserving or clearing up on
<b>croak()</b>. For that, see the aux_info and aux_info_eval
members of the regmatch_state union.</p>

<p style="margin-left:11%;">&quot;REXEC_COPY_STR&quot; <br>
&quot;REXEC_COPY_SKIP_PRE&quot; <br>
&quot;REXEC_COPY_SKIP_POST&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>

<p style="margin-left:11%;">&quot;RXapif_CLEAR&quot; <br>
&quot;RXapif_DELETE&quot; <br>
&quot;RXapif_EXISTS&quot; <br>
&quot;RXapif_FETCH&quot; <br>
&quot;RXapif_FIRSTKEY&quot; <br>
&quot;RXapif_NEXTKEY&quot; <br>
&quot;RXapif_SCALAR&quot; <br>
&quot;RXapif_STORE&quot; <br>
&quot;RXapif_ALL&quot; <br>
&quot;RXapif_ONE&quot; <br>
&quot;RXapif_REGNAME&quot; <br>
&quot;RXapif_REGNAMES&quot; <br>
&quot;RXapif_REGNAMES_COUNT&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>


<p style="margin-left:11%;">&quot;RX_BUFF_IDX_CARET_FULLMATCH&quot;
<br>
&quot;RX_BUFF_IDX_CARET_POSTMATCH&quot; <br>
&quot;RX_BUFF_IDX_CARET_PREMATCH&quot; <br>
&quot;RX_BUFF_IDX_FULLMATCH&quot; <br>
&quot;RX_BUFF_IDX_POSTMATCH&quot; <br>
&quot;RX_BUFF_IDX_PREMATCH&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>

<p style="margin-left:11%;">&quot;RXf_PMf_MULTILINE&quot;
<br>
&quot;RXf_PMf_SINGLELINE&quot; <br>
&quot;RXf_PMf_FOLD&quot; <br>
&quot;RXf_PMf_EXTENDED&quot; <br>
&quot;RXf_PMf_KEEPCOPY&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>

<p style="margin-left:11%;">&quot;RXf_SPLIT&quot; <br>
&quot;RXf_SKIPWHITE&quot; <br>
&quot;RXf_START_ONLY&quot; <br>
&quot;RXf_WHITE&quot; <br>
&quot;RXf_NULL&quot; <br>
&quot;RXf_NO_INPLACE_SUBST&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>


<p style="margin-left:11%;">&quot;RX_MATCH_COPIED&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>


<p style="margin-left:17%; margin-top: 1em">RX_MATCH_COPIED(const
REGEXP * rx)</p>

<p style="margin-left:11%;">&quot;RX_OFFS&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>

<p style="margin-left:17%; margin-top: 1em">RX_OFFS(const
REGEXP * rx_sv)</p>

<p style="margin-left:11%;">&quot;SvRX&quot;</p>

<p style="margin-left:17%;">Convenience macro to get the
<small>REGEXP</small> from a <small>SV.</small> This is
approximately equivalent to the following snippet:</p>

<p style="margin-left:17%; margin-top: 1em">if
(SvMAGICAL(sv)) <br>
mg_get(sv); <br>
if (SvROK(sv)) <br>
sv = MUTABLE_SV(SvRV(sv)); <br>
if (SvTYPE(sv) == SVt_REGEXP) <br>
return (REGEXP*) sv;</p>


<p style="margin-left:17%; margin-top: 1em">&quot;NULL&quot;
will be returned if a REGEXP* is not found.</p>

<p style="margin-left:17%; margin-top: 1em">REGEXP *
SvRX(SV *sv)</p>

<p style="margin-left:11%;">&quot;SvRXOK&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> (or the one it references) is
a <small>REGEXP.</small></p>

<p style="margin-left:17%; margin-top: 1em">If you want to
do something with the REGEXP* later use SvRX instead and
check for <small>NULL.</small></p>

<p style="margin-left:17%; margin-top: 1em">bool SvRXOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SV_SAVED_COPY&quot;</p>

<p style="margin-left:17%;">Described in perlreapi.</p>

<h2>Reports and Formats
<a name="Reports and Formats"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These are used
in the simple report generation feature of Perl. See
perlform. <br>
&quot;IoBOTTOM_GV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">GV *
IoBOTTOM_GV(IO *io)</p>

<p style="margin-left:11%;">&quot;IoBOTTOM_NAME&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">char *
IoBOTTOM_NAME(IO *io)</p>

<p style="margin-left:11%;">&quot;IoFMT_GV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">GV *
IoFMT_GV(IO *io)</p>

<p style="margin-left:11%;">&quot;IoFMT_NAME&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">char *
IoFMT_NAME(IO *io)</p>

<p style="margin-left:11%;">&quot;IoLINES&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">IV IoLINES(IO
*io)</p>

<p style="margin-left:11%;">&quot;IoLINES_LEFT&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">IV
IoLINES_LEFT(IO *io)</p>

<p style="margin-left:11%;">&quot;IoPAGE&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">IV IoPAGE(IO
*io)</p>

<p style="margin-left:11%;">&quot;IoPAGE_LEN&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">IV
IoPAGE_LEN(IO *io)</p>

<p style="margin-left:11%;">&quot;IoTOP_GV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">GV *
IoTOP_GV(IO *io)</p>

<p style="margin-left:11%;">&quot;IoTOP_NAME&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">char *
IoTOP_NAME(IO *io)</p>

<h2>Signals
<a name="Signals"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;HAS_SIGINFO_SI_ADDR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;siginfo_t&quot; has the
&quot;si_addr&quot; member</p>


<p style="margin-left:11%;">&quot;HAS_SIGINFO_SI_BAND&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;siginfo_t&quot; has the
&quot;si_band&quot; member</p>


<p style="margin-left:11%;">&quot;HAS_SIGINFO_SI_ERRNO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;siginfo_t&quot; has the
&quot;si_errno&quot; member</p>


<p style="margin-left:11%;">&quot;HAS_SIGINFO_SI_PID&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;siginfo_t&quot; has the
&quot;si_pid&quot; member</p>


<p style="margin-left:11%;">&quot;HAS_SIGINFO_SI_STATUS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;siginfo_t&quot; has the
&quot;si_status&quot; member</p>


<p style="margin-left:11%;">&quot;HAS_SIGINFO_SI_UID&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;siginfo_t&quot; has the
&quot;si_uid&quot; member</p>


<p style="margin-left:11%;">&quot;HAS_SIGINFO_SI_VALUE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;siginfo_t&quot; has the
&quot;si_value&quot; member</p>


<p style="margin-left:11%;">&quot;PERL_SIGNALS_UNSAFE_FLAG&quot;</p>

<p style="margin-left:17%;">If this bit in
&quot;PL_signals&quot; is set, the system is uing the
pre-Perl 5.8 unsafe signals. See &quot;
<small>PERL_SIGNALS&quot;</small> in perlrun and
&quot;Deferred Signals (Safe Signals)&quot; in perlipc.</p>

<p style="margin-left:17%; margin-top: 1em">U32
PERL_SIGNALS_UNSAFE_FLAG</p>

<p style="margin-left:11%;">&quot;rsignal&quot;</p>

<p style="margin-left:17%;">A wrapper for the C library
functions <b>sigaction</b>(2) or <b>signal</b>(2). Use this
instead of those libc functions, as the Perl version gives
the safest available implementation, and knows things that
interact with the rest of the perl interpreter.</p>

<p style="margin-left:17%; margin-top: 1em">Sighandler_t
rsignal(int i, Sighandler_t t)</p>

<p style="margin-left:11%;">&quot;rsignal_state&quot;</p>

<p style="margin-left:17%;">Returns a the current signal
handler for signal &quot;signo&quot;. See
&quot;&quot;rsignal&quot;&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Sighandler_t
rsignal_state(int i)</p>

<p style="margin-left:11%;">&quot;Sigjmp_buf&quot;</p>

<p style="margin-left:17%;">This is the buffer type to be
used with Sigsetjmp and Siglongjmp.</p>

<p style="margin-left:11%;">&quot;Siglongjmp&quot;</p>

<p style="margin-left:17%;">This macro is used in the same
way as &quot;siglongjmp()&quot;, but will invoke traditional
&quot;longjmp()&quot; if siglongjmp isn&rsquo;t available.
See &quot;HAS_SIGSETJMP&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
Siglongjmp(jmp_buf env, int val)</p>

<p style="margin-left:11%;">&quot;SIG_NAME&quot;</p>

<p style="margin-left:17%;">This symbol contains a list of
signal names in order of signal number. This is intended to
be used as a static array initialization, like this:</p>

<p style="margin-left:17%; margin-top: 1em">char
*sig_name[] = { SIG_NAME };</p>

<p style="margin-left:17%; margin-top: 1em">The signals in
the list are separated with commas, and each signal is
surrounded by double quotes. There is no leading
&quot;SIG&quot; in the signal name, i.e. &quot;SIGQUIT&quot;
is known as &quot;&quot;QUIT&quot;&quot;. Gaps in the signal
numbers (up to &quot;NSIG&quot;) are filled in with
&quot;NUMnn&quot;, etc., where nn is the actual signal
number (e.g. &quot;NUM37&quot;). The signal number for
&quot;sig_name[i]&quot; is stored in &quot;sig_num[i]&quot;.
The last element is 0 to terminate the list with a
&quot;NULL&quot;. This corresponds to the 0 at the end of
the &quot;sig_name_init&quot; list. Note that this variable
is initialized from the &quot;sig_name_init&quot;, not from
&quot;sig_name&quot; (which is unused).</p>

<p style="margin-left:11%;">&quot;SIG_NUM&quot;</p>

<p style="margin-left:17%;">This symbol contains a list of
signal numbers, in the same order as the
&quot;SIG_NAME&quot; list. It is suitable for static array
initialization, as in:</p>

<p style="margin-left:17%; margin-top: 1em">int sig_num[] =
{ SIG_NUM };</p>

<p style="margin-left:17%; margin-top: 1em">The signals in
the list are separated with commas, and the indices within
that list and the &quot;SIG_NAME&quot; list match, so
it&rsquo;s easy to compute the signal name from a number or
vice versa at the price of a small dynamic linear lookup.
Duplicates are allowed, but are moved to the end of the
list. The signal number corresponding to
&quot;sig_name[i]&quot; is &quot;sig_number[i]&quot;. if (i
&lt; &quot;NSIG&quot;) then &quot;sig_number[i]&quot; == i.
The last element is 0, corresponding to the 0 at the end of
the &quot;sig_name_init&quot; list. Note that this variable
is initialized from the &quot;sig_num_init&quot;, not from
&quot;sig_num&quot; (which is unused).</p>

<p style="margin-left:11%;">&quot;Sigsetjmp&quot;</p>

<p style="margin-left:17%;">This macro is used in the same
way as &quot;sigsetjmp()&quot;, but will invoke traditional
&quot;setjmp()&quot; if sigsetjmp isn&rsquo;t available. See
&quot;HAS_SIGSETJMP&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
Sigsetjmp(jmp_buf env, int savesigs)</p>

<p style="margin-left:11%;">&quot;SIG_SIZE&quot;</p>

<p style="margin-left:17%;">This variable contains the
number of elements of the &quot;SIG_NAME&quot; and
&quot;SIG_NUM&quot; arrays, excluding the final
&quot;NULL&quot; entry.</p>

<p style="margin-left:11%;">&quot;whichsig&quot; <br>
&quot;whichsig_pv&quot; <br>
&quot;whichsig_pvn&quot; <br>
&quot;whichsig_sv&quot;</p>

<p style="margin-left:17%;">These all convert a signal name
into its corresponding signal number; returning &minus;1 if
no corresponding number was found.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in the source of the signal name:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;whichsig_pv&quot;
takes the name from the &quot;NUL&quot;&minus;terminated
string starting at &quot;sig&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;whichsig&quot;
is merely a different spelling, a synonym, of
&quot;whichsig_pv&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;whichsig_pvn&quot;
takes the name from the string starting at &quot;sig&quot;,
with length &quot;len&quot; bytes.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;whichsig_sv&quot;
takes the name from the <small>PV</small> stored in the
<small>SV</small> &quot;sigsv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32 whichsig
(const char* sig) <br>
I32 whichsig_pv (const char* sig) <br>
I32 whichsig_pvn(const char* sig, STRLEN len) <br>
I32 whichsig_sv (SV* sigsv)</p>

<h2>Site configuration
<a name="Site configuration"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These variables
give details as to where various libraries, installation
destinations, <i>etc.</i>, go, as well as what various
installation options were selected <br>
&quot;ARCHLIB&quot;</p>

<p style="margin-left:17%;">This variable, if defined,
holds the name of the directory in which the user wants to
put architecture-dependent public library files for perl5.
It is most often a local directory such as
<i>/usr/local/lib</i>. Programs using this variable must be
prepared to deal with filename expansion. If
&quot;ARCHLIB&quot; is the same as &quot;PRIVLIB&quot;, it
is not defined, since presumably the program already
searches &quot;PRIVLIB&quot;.</p>

<p style="margin-left:11%;">&quot;ARCHLIB_EXP&quot;</p>

<p style="margin-left:17%;">This symbol contains the ~name
expanded version of &quot;ARCHLIB&quot;, to be used in
programs that are not prepared to deal with ~ expansion at
run-time.</p>

<p style="margin-left:11%;">&quot;ARCHNAME&quot;</p>

<p style="margin-left:17%;">This symbol holds a string
representing the architecture name. It may be used to
construct an architecture-dependant pathname where library
files may be held under a private library, for instance.</p>

<p style="margin-left:11%;">&quot;BIN&quot;</p>

<p style="margin-left:17%;">This symbol holds the path of
the bin directory where the package will be installed.
Program must be prepared to deal with ~name
substitution.</p>

<p style="margin-left:11%;">&quot;BIN_EXP&quot;</p>

<p style="margin-left:17%;">This symbol is the filename
expanded version of the &quot;BIN&quot; symbol, for programs
that do not want to deal with that at run-time.</p>


<p style="margin-left:11%;">&quot;INSTALL_USR_BIN_PERL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl is to be installed also as
<i>/usr/bin/perl</i>.</p>

<p style="margin-left:11%;">&quot;MULTIARCH&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
signifies that the build process will produce some binary
files that are going to be used in a cross-platform
environment. This is the case for example with the NeXT
&quot;fat&quot; binaries that contain executables for
several &quot;CPUs&quot;.</p>


<p style="margin-left:11%;">&quot;PERL_INC_VERSION_LIST&quot;</p>

<p style="margin-left:17%;">This variable specifies the
list of subdirectories in over which
<i>perl.c</i>:&quot;incpush()&quot; and <i>lib/lib.pm</i>
will automatically search when adding directories to
@&quot;INC&quot;, in a format suitable for a C
initialization string. See the &quot;inc_version_list&quot;
entry in Porting/Glossary for more details.</p>


<p style="margin-left:11%;">&quot;PERL_OTHERLIBDIRS&quot;</p>

<p style="margin-left:17%;">This variable contains a
colon-separated set of paths for the perl binary to search
for additional library files or modules. These directories
will be tacked to the end of @&quot;INC&quot;. Perl will
automatically search below each path for version&minus; and
architecture-specific directories. See
&quot;PERL_INC_VERSION_LIST&quot; for more details.</p>


<p style="margin-left:11%;">&quot;PERL_RELOCATABLE_INC&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that we&rsquo;d like to relocate entries in
@&quot;INC&quot; at run time based on the location of the
perl binary.</p>


<p style="margin-left:11%;">&quot;PERL_TARGETARCH&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates the target architecture Perl has been
cross-compiled to. Undefined if not a cross-compile.</p>

<p style="margin-left:11%;">&quot;PERL_USE_DEVEL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl was configured with
&quot;&minus;Dusedevel&quot;, to enable development
features. This should not be done for production builds.</p>


<p style="margin-left:11%;">&quot;PERL_VENDORARCH&quot;</p>

<p style="margin-left:17%;">If defined, this symbol
contains the name of a private library. The library is
private in the sense that it needn&rsquo;t be in
anyone&rsquo;s execution path, but it should be accessible
by the world. It may have a ~ on the front. The standard
distribution will put nothing in this directory. Vendors who
distribute perl may wish to place their own
architecture-dependent modules and extensions in this
directory with</p>

<p style="margin-left:17%; margin-top: 1em">MakeMaker
Makefile.PL INSTALLDIRS=vendor</p>

<p style="margin-left:17%; margin-top: 1em">or equivalent.
See &quot;INSTALL&quot; for details.</p>


<p style="margin-left:11%;">&quot;PERL_VENDORARCH_EXP&quot;</p>

<p style="margin-left:17%;">This symbol contains the ~name
expanded version of &quot;PERL_VENDORARCH&quot;, to be used
in programs that are not prepared to deal with ~ expansion
at run-time.</p>


<p style="margin-left:11%;">&quot;PERL_VENDORLIB_EXP&quot;</p>

<p style="margin-left:17%;">This symbol contains the ~name
expanded version of &quot;VENDORLIB&quot;, to be used in
programs that are not prepared to deal with ~ expansion at
run-time.</p>


<p style="margin-left:11%;">&quot;PERL_VENDORLIB_STEM&quot;</p>

<p style="margin-left:17%;">This define is
&quot;PERL_VENDORLIB_EXP&quot; with any trailing
version-specific component removed. The elements in
&quot;inc_version_list&quot; (&quot;inc_version_list&quot;.U
(part of metaconfig)) can be tacked onto this variable to
generate a list of directories to search.</p>

<p style="margin-left:11%;">&quot;PRIVLIB&quot;</p>

<p style="margin-left:17%;">This symbol contains the name
of the private library for this package. The library is
private in the sense that it needn&rsquo;t be in
anyone&rsquo;s execution path, but it should be accessible
by the world. The program should be prepared to do ~
expansion.</p>

<p style="margin-left:11%;">&quot;PRIVLIB_EXP&quot;</p>

<p style="margin-left:17%;">This symbol contains the ~name
expanded version of &quot;PRIVLIB&quot;, to be used in
programs that are not prepared to deal with ~ expansion at
run-time.</p>

<p style="margin-left:11%;">&quot;SITEARCH&quot;</p>

<p style="margin-left:17%;">This symbol contains the name
of the private library for this package. The library is
private in the sense that it needn&rsquo;t be in
anyone&rsquo;s execution path, but it should be accessible
by the world. The program should be prepared to do ~
expansion. The standard distribution will put nothing in
this directory. After perl has been installed, users may
install their own local architecture-dependent modules in
this directory with</p>

<p style="margin-left:17%; margin-top: 1em">MakeMaker
Makefile.PL</p>

<p style="margin-left:17%; margin-top: 1em">or equivalent.
See &quot;INSTALL&quot; for details.</p>

<p style="margin-left:11%;">&quot;SITEARCH_EXP&quot;</p>

<p style="margin-left:17%;">This symbol contains the ~name
expanded version of &quot;SITEARCH&quot;, to be used in
programs that are not prepared to deal with ~ expansion at
run-time.</p>

<p style="margin-left:11%;">&quot;SITELIB&quot;</p>

<p style="margin-left:17%;">This symbol contains the name
of the private library for this package. The library is
private in the sense that it needn&rsquo;t be in
anyone&rsquo;s execution path, but it should be accessible
by the world. The program should be prepared to do ~
expansion. The standard distribution will put nothing in
this directory. After perl has been installed, users may
install their own local architecture-independent modules in
this directory with</p>

<p style="margin-left:17%; margin-top: 1em">MakeMaker
Makefile.PL</p>

<p style="margin-left:17%; margin-top: 1em">or equivalent.
See &quot;INSTALL&quot; for details.</p>

<p style="margin-left:11%;">&quot;SITELIB_EXP&quot;</p>

<p style="margin-left:17%;">This symbol contains the ~name
expanded version of &quot;SITELIB&quot;, to be used in
programs that are not prepared to deal with ~ expansion at
run-time.</p>

<p style="margin-left:11%;">&quot;SITELIB_STEM&quot;</p>

<p style="margin-left:17%;">This define is
&quot;SITELIB_EXP&quot; with any trailing version-specific
component removed. The elements in
&quot;inc_version_list&quot; (&quot;inc_version_list&quot;.U
(part of metaconfig)) can be tacked onto this variable to
generate a list of directories to search.</p>

<p style="margin-left:11%;">&quot;STARTPERL&quot;</p>

<p style="margin-left:17%;">This variable contains the
string to put in front of a perl script to make sure (one
hopes) that it runs with perl and not some shell.</p>

<p style="margin-left:11%;">&quot;USE_64_BIT_ALL&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that 64&minus;bit integers should be used when
available. If not defined, the native integers will be used
(be they 32 or 64 bits). The maximal possible
64&minus;bitness is employed: <small>LP64</small> or
&quot;ILP64&quot;, meaning that you will be able to use more
than 2 gigabytes of memory. This mode is even more binary
incompatible than &quot;USE_64_BIT_INT&quot;. You may not be
able to run the resulting executable in a 32&minus;bit
&quot;CPU&quot; at all or you may need at least to reboot
your <small>OS</small> to 64&minus;bit mode.</p>

<p style="margin-left:11%;">&quot;USE_64_BIT_INT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that 64&minus;bit integers should be used when
available. If not defined, the native integers will be
employed (be they 32 or 64 bits). The minimal possible
64&minus;bitness is used, just enough to get 64&minus;bit
integers into Perl. This may mean using for example
&quot;long longs&quot;, while your memory may still be
limited to 2 gigabytes.</p>


<p style="margin-left:11%;">&quot;USE_BSD_GETPGRP&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that getpgrp needs one arguments whereas
&quot;USG&quot; one needs none.</p>


<p style="margin-left:11%;">&quot;USE_BSD_SETPGRP&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that setpgrp needs two arguments whereas
&quot;USG&quot; one needs none. See also
&quot;HAS_SETPGID&quot; for a &quot;POSIX&quot;
interface.</p>

<p style="margin-left:11%;">&quot;USE_CPLUSPLUS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that a C <small>++</small> compiler was used to
compiled Perl and will be used to compile extensions.</p>


<p style="margin-left:11%;">&quot;USE_CROSS_COMPILE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl is being cross-compiled.</p>


<p style="margin-left:11%;">&quot;USE_C_BACKTRACE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should be built with support for
backtrace.</p>

<p style="margin-left:11%;">&quot;USE_DTRACE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should be built with support for
DTrace.</p>


<p style="margin-left:11%;">&quot;USE_DYNAMIC_LOADING&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that dynamic loading of some sort is
available.</p>

<p style="margin-left:11%;">&quot;USE_FAST_STDIO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should be built to use &rsquo;fast
stdio&rsquo;. Defaults to define in Perls 5.8 and earlier,
to undef later.</p>

<p style="margin-left:11%;">&quot;USE_ITHREADS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should be built to use the
interpreter-based threading implementation.</p>


<p style="margin-left:11%;">&quot;USE_KERN_PROC_PATHNAME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that we can use sysctl with
&quot;KERN_PROC_PATHNAME&quot; to get a full path for the
executable, and hence convert $^X to an absolute path.</p>


<p style="margin-left:11%;">&quot;USE_LARGE_FILES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that large file support should be used when
available.</p>


<p style="margin-left:11%;">&quot;USE_LONG_DOUBLE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that long doubles should be used when
available.</p>

<p style="margin-left:11%;">&quot;USE_MORE_BITS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that 64&minus;bit interfaces and long doubles
should be used when available.</p>


<p style="margin-left:11%;">&quot;USE_NSGETEXECUTABLEPATH&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that we can use &quot;_NSGetExecutablePath&quot;
and realpath to get a full path for the executable, and
hence convert $^X to an absolute path.</p>

<p style="margin-left:11%;">&quot;USE_PERLIO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the PerlIO abstraction should be used
throughout. If not defined, stdio should be used in a fully
backward compatible manner.</p>

<p style="margin-left:11%;">&quot;USE_QUADMATH&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the quadmath library should be used when
available.</p>


<p style="margin-left:11%;">&quot;USE_REENTRANT_API&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should try to use the various
&quot;_r&quot; versions of library functions. This is
extremely experimental.</p>


<p style="margin-left:11%;">&quot;USE_SEMCTL_SEMID_DS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;struct semid_ds&quot; * is used for
semctl &quot;IPC_STAT&quot;.</p>


<p style="margin-left:11%;">&quot;USE_SEMCTL_SEMUN&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that &quot;union semun&quot; is used for semctl
&quot;IPC_STAT&quot;.</p>


<p style="margin-left:11%;">&quot;USE_SITECUSTOMIZE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that sitecustomize should be used.</p>

<p style="margin-left:11%;">&quot;USE_SOCKS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should be built to use socks.</p>


<p style="margin-left:11%;">&quot;USE_STAT_BLOCKS&quot;</p>

<p style="margin-left:17%;">This symbol is defined if this
system has a stat structure declaring &quot;st_blksize&quot;
and &quot;st_blocks&quot;.</p>

<p style="margin-left:11%;">&quot;USE_STDIO_BASE&quot;</p>

<p style="margin-left:17%;">This symbol is defined if the
&quot;_base&quot; field (or similar) of the stdio
&quot;FILE&quot; structure can be used to access the stdio
buffer for a file handle. If this is defined, then the
&quot;FILE_base(fp)&quot; macro will also be defined and
should be used to access this field. Also, the
&quot;FILE_bufsiz(fp)&quot; macro will be defined and should
be used to determine the number of bytes in the buffer.
&quot;USE_STDIO_BASE&quot; will never be defined unless
&quot;USE_STDIO_PTR&quot; is.</p>

<p style="margin-left:11%;">&quot;USE_STDIO_PTR&quot;</p>

<p style="margin-left:17%;">This symbol is defined if the
&quot;_ptr&quot; and &quot;_cnt&quot; fields (or similar) of
the stdio &quot;FILE&quot; structure can be used to access
the stdio buffer for a file handle. If this is defined, then
the &quot;FILE_ptr(fp)&quot; and &quot;FILE_cnt(fp)&quot;
macros will also be defined and should be used to access
these fields.</p>


<p style="margin-left:11%;">&quot;USE_STRICT_BY_DEFAULT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
enables additional defaults. At this time it only enables
implicit strict by default.</p>

<p style="margin-left:11%;">&quot;USE_THREADS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that Perl should be built to use threads. At
present, it is a synonym for and &quot;USE_ITHREADS&quot;,
but eventually the source ought to be changed to use this to
mean &quot;_any_&quot; threading implementation.</p>

<h2>Sockets configuration values
<a name="Sockets configuration values"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;HAS_SOCKADDR_IN6&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates the availability of &quot;struct
sockaddr_in6&quot;;</p>


<p style="margin-left:11%;">&quot;HAS_SOCKADDR_SA_LEN&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;struct sockaddr&quot; structure has
a member called &quot;sa_len&quot;, indicating the length of
the structure.</p>


<p style="margin-left:11%;">&quot;HAS_SOCKADDR_STORAGE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates the availability of &quot;struct
sockaddr_storage&quot;;</p>

<p style="margin-left:11%;">&quot;HAS_SOCKATMARK&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;sockatmark&quot; routine is
available to test whether a socket is at the out-of-band
mark.</p>

<p style="margin-left:11%;">&quot;HAS_SOCKET&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;BSD&quot; &quot;socket&quot;
interface is supported.</p>

<p style="margin-left:11%;">&quot;HAS_SOCKETPAIR&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;BSD&quot; &quot;socketpair()&quot;
call is supported.</p>


<p style="margin-left:11%;">&quot;HAS_SOCKS5_INIT&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;socks5_init&quot; routine is
available to initialize &quot;SOCKS&quot; 5.</p>

<p style="margin-left:11%;">&quot;I_SOCKS&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that <i>socks.h</i> exists and should be
included.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef I_SOCKS
<br>
#include &lt;socks.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_SYS_SOCKIO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates the <i>sys/sockio.h</i> should be included to get
socket ioctl options, like &quot;SIOCATMARK&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef
I_SYS_SOCKIO <br>
#include &lt;sys_sockio.h&gt; <br>
#endif</p>

<h2>Source Filters
<a name="Source Filters"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;filter_add&quot;</p>

<p style="margin-left:17%;">Described in perlfilter.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
filter_add(filter_t funcp, SV* datasv)</p>

<p style="margin-left:11%;">&quot;filter_del&quot;</p>

<p style="margin-left:17%;">Delete most recently added
instance of the filter function argument</p>

<p style="margin-left:17%; margin-top: 1em">void
filter_del(filter_t funcp)</p>

<p style="margin-left:11%;">&quot;filter_read&quot;</p>

<p style="margin-left:17%;">Described in perlfilter.</p>

<p style="margin-left:17%; margin-top: 1em">I32
filter_read(int idx, SV *buf_sv, int maxlen)</p>

<p style="margin-left:11%;">&quot;scan_vstring&quot;</p>

<p style="margin-left:17%;">Returns a pointer to the next
character after the parsed vstring, as well as updating the
passed in sv.</p>

<p style="margin-left:17%; margin-top: 1em">Function must
be called like</p>

<p style="margin-left:17%; margin-top: 1em">sv =
sv_2mortal(newSV(5)); <br>
s = scan_vstring(s,e,sv);</p>

<p style="margin-left:17%; margin-top: 1em">where s and e
are the start and end of the string. The sv should already
be large enough to store the vstring passed in, for
performance reasons.</p>

<p style="margin-left:17%; margin-top: 1em">This function
may croak if fatal warnings are enabled in the calling
scope, hence the sv_2mortal in the example (to prevent a
leak). Make sure to do SvREFCNT_inc afterwards if you use
sv_2mortal.</p>

<p style="margin-left:17%; margin-top: 1em">char*
scan_vstring(const char *s, const char *const e, SV *sv)</p>

<h2>Stack Manipulation Macros
<a name="Stack Manipulation Macros"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;dMARK&quot;</p>

<p style="margin-left:17%;">Declare a stack marker
variable, &quot;mark&quot;, for the <small>XSUB.</small> See
&quot;MARK&quot; and &quot;dORIGMARK&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">dMARK;</p>

<p style="margin-left:11%;">&quot;dORIGMARK&quot;</p>

<p style="margin-left:17%;">Saves the original stack mark
for the <small>XSUB.</small> See &quot;ORIGMARK&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">dORIGMARK;</p>

<p style="margin-left:11%;">&quot;dSP&quot;</p>

<p style="margin-left:17%;">Declares a local copy of
perl&rsquo;s stack pointer for the <small>XSUB,</small>
available via the &quot;SP&quot; macro. See
&quot;SP&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">dSP;</p>

<p style="margin-left:11%;">&quot;dTARGET&quot;</p>

<p style="margin-left:17%;">Declare that this function uses
&quot;TARG&quot;</p>

<p style="margin-left:17%; margin-top: 1em">dTARGET;</p>

<p style="margin-left:11%;">&quot;EXTEND&quot;</p>

<p style="margin-left:17%;">Used to extend the argument
stack for an <small>XSUB</small> &rsquo;s return values.
Once used, guarantees that there is room for at least
&quot;nitems&quot; to be pushed onto the stack.</p>

<p style="margin-left:17%; margin-top: 1em">void EXTEND(SP,
SSize_t nitems)</p>

<p style="margin-left:11%;">&quot;MARK&quot;</p>

<p style="margin-left:17%;">Stack marker variable for the
<small>XSUB.</small> See &quot;dMARK&quot;.</p>

<p style="margin-left:11%;">&quot;mPUSHi&quot;</p>

<p style="margin-left:17%;">Push an integer onto the stack.
The stack must have room for this element. Does not use
&quot;TARG&quot;. See also &quot;PUSHi&quot;,
&quot;mXPUSHi&quot; and &quot;XPUSHi&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void mPUSHi(IV
iv)</p>

<p style="margin-left:11%;">&quot;mPUSHn&quot;</p>

<p style="margin-left:17%;">Push a double onto the stack.
The stack must have room for this element. Does not use
&quot;TARG&quot;. See also &quot;PUSHn&quot;,
&quot;mXPUSHn&quot; and &quot;XPUSHn&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void mPUSHn(NV
nv)</p>

<p style="margin-left:11%;">&quot;mPUSHp&quot;</p>

<p style="margin-left:17%;">Push a string onto the stack.
The stack must have room for this element. The
&quot;len&quot; indicates the length of the string. Does not
use &quot;TARG&quot;. See also &quot;PUSHp&quot;,
&quot;mXPUSHp&quot; and &quot;XPUSHp&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
mPUSHp(char* str, STRLEN len)</p>

<p style="margin-left:11%;">&quot;mPUSHs&quot;</p>

<p style="margin-left:17%;">Push an <small>SV</small> onto
the stack and mortalizes the <small>SV.</small> The stack
must have room for this element. Does not use
&quot;TARG&quot;. See also &quot;PUSHs&quot; and
&quot;mXPUSHs&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void mPUSHs(SV*
sv)</p>

<p style="margin-left:11%;">&quot;mPUSHu&quot;</p>

<p style="margin-left:17%;">Push an unsigned integer onto
the stack. The stack must have room for this element. Does
not use &quot;TARG&quot;. See also &quot;PUSHu&quot;,
&quot;mXPUSHu&quot; and &quot;XPUSHu&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void mPUSHu(UV
uv)</p>

<p style="margin-left:11%;">&quot;mXPUSHi&quot;</p>

<p style="margin-left:17%;">Push an integer onto the stack,
extending the stack if necessary. Does not use
&quot;TARG&quot;. See also &quot;XPUSHi&quot;,
&quot;mPUSHi&quot; and &quot;PUSHi&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void mXPUSHi(IV
iv)</p>

<p style="margin-left:11%;">&quot;mXPUSHn&quot;</p>

<p style="margin-left:17%;">Push a double onto the stack,
extending the stack if necessary. Does not use
&quot;TARG&quot;. See also &quot;XPUSHn&quot;,
&quot;mPUSHn&quot; and &quot;PUSHn&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void mXPUSHn(NV
nv)</p>

<p style="margin-left:11%;">&quot;mXPUSHp&quot;</p>

<p style="margin-left:17%;">Push a string onto the stack,
extending the stack if necessary. The &quot;len&quot;
indicates the length of the string. Does not use
&quot;TARG&quot;. See also &quot;XPUSHp&quot;,
&quot;mPUSHp&quot; and &quot;PUSHp&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
mXPUSHp(char* str, STRLEN len)</p>

<p style="margin-left:11%;">&quot;mXPUSHs&quot;</p>

<p style="margin-left:17%;">Push an <small>SV</small> onto
the stack, extending the stack if necessary and mortalizes
the <small>SV.</small> Does not use &quot;TARG&quot;. See
also &quot;XPUSHs&quot; and &quot;mPUSHs&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
mXPUSHs(SV* sv)</p>

<p style="margin-left:11%;">&quot;mXPUSHu&quot;</p>

<p style="margin-left:17%;">Push an unsigned integer onto
the stack, extending the stack if necessary. Does not use
&quot;TARG&quot;. See also &quot;XPUSHu&quot;,
&quot;mPUSHu&quot; and &quot;PUSHu&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void mXPUSHu(UV
uv)</p>

<p style="margin-left:11%;">&quot;newXSproto&quot;</p>

<p style="margin-left:17%;">Used by &quot;xsubpp&quot; to
hook up XSUBs as Perl subs. Adds Perl prototypes to the
subs.</p>

<p style="margin-left:11%;">&quot;ORIGMARK&quot;</p>

<p style="margin-left:17%;">The original stack mark for the
<small>XSUB.</small> See &quot;dORIGMARK&quot;.</p>

<p style="margin-left:11%;">&quot;PL_markstack&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:11%;">&quot;PL_markstack_ptr&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_savestack&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:11%;">&quot;PL_savestack_ix&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_scopestack&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:11%;">&quot;PL_scopestack_ix&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>


<p style="margin-left:11%;">&quot;PL_scopestack_name&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_stack_base&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_stack_sp&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_tmps_floor&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_tmps_ix&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;PL_tmps_stack&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;POPi&quot;</p>

<p style="margin-left:17%;">Pops an integer off the
stack.</p>

<p style="margin-left:17%; margin-top: 1em">IV POPi</p>

<p style="margin-left:11%;">&quot;POPl&quot;</p>

<p style="margin-left:17%;">Pops a long off the stack.</p>

<p style="margin-left:17%; margin-top: 1em">long POPl</p>

<p style="margin-left:11%;">&quot;POPn&quot;</p>

<p style="margin-left:17%;">Pops a double off the
stack.</p>

<p style="margin-left:17%; margin-top: 1em">NV POPn</p>

<p style="margin-left:11%;">&quot;POPp&quot;</p>

<p style="margin-left:17%;">Pops a string off the
stack.</p>

<p style="margin-left:17%; margin-top: 1em">char* POPp</p>

<p style="margin-left:11%;">&quot;POPpbytex&quot;</p>

<p style="margin-left:17%;">Pops a string off the stack
which must consist of bytes i.e. characters &lt; 256.</p>

<p style="margin-left:17%; margin-top: 1em">char*
POPpbytex</p>

<p style="margin-left:11%;">&quot;POPpx&quot;</p>

<p style="margin-left:17%;">Pops a string off the stack.
Identical to POPp. There are two names for historical
reasons.</p>

<p style="margin-left:17%; margin-top: 1em">char* POPpx</p>

<p style="margin-left:11%;">&quot;POPs&quot;</p>

<p style="margin-left:17%;">Pops an <small>SV</small> off
the stack.</p>

<p style="margin-left:17%; margin-top: 1em">SV* POPs</p>

<p style="margin-left:11%;">&quot;POPu&quot;</p>

<p style="margin-left:17%;">Pops an unsigned integer off
the stack.</p>

<p style="margin-left:17%; margin-top: 1em">UV POPu</p>

<p style="margin-left:11%;">&quot;POPul&quot;</p>

<p style="margin-left:17%;">Pops an unsigned long off the
stack.</p>

<p style="margin-left:17%; margin-top: 1em">long POPul</p>

<p style="margin-left:11%;">&quot;PUSHi&quot;</p>

<p style="margin-left:17%;">Push an integer onto the stack.
The stack must have room for this element. Handles
&rsquo;set&rsquo; magic. Uses &quot;TARG&quot;, so
&quot;dTARGET&quot; or &quot;dXSTARG&quot; should be called
to declare it. Do not call multiple
&quot;TARG&quot;&minus;oriented macros to return lists from
<small>XSUB</small> &rsquo;s &minus; see &quot;mPUSHi&quot;
instead. See also &quot;XPUSHi&quot; and
&quot;mXPUSHi&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void PUSHi(IV
iv)</p>

<p style="margin-left:11%;">&quot;PUSHMARK&quot;</p>

<p style="margin-left:17%;">Opening bracket for arguments
on a callback. See &quot;PUTBACK&quot; and perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">void
PUSHMARK(SP)</p>

<p style="margin-left:11%;">&quot;PUSHmortal&quot;</p>

<p style="margin-left:17%;">Push a new mortal
<small>SV</small> onto the stack. The stack must have room
for this element. Does not use &quot;TARG&quot;. See also
&quot;PUSHs&quot;, &quot;XPUSHmortal&quot; and
&quot;XPUSHs&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
PUSHmortal</p>

<p style="margin-left:11%;">&quot;PUSHn&quot;</p>

<p style="margin-left:17%;">Push a double onto the stack.
The stack must have room for this element. Handles
&rsquo;set&rsquo; magic. Uses &quot;TARG&quot;, so
&quot;dTARGET&quot; or &quot;dXSTARG&quot; should be called
to declare it. Do not call multiple
&quot;TARG&quot;&minus;oriented macros to return lists from
<small>XSUB</small> &rsquo;s &minus; see &quot;mPUSHn&quot;
instead. See also &quot;XPUSHn&quot; and
&quot;mXPUSHn&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void PUSHn(NV
nv)</p>

<p style="margin-left:11%;">&quot;PUSHp&quot;</p>

<p style="margin-left:17%;">Push a string onto the stack.
The stack must have room for this element. The
&quot;len&quot; indicates the length of the string. Handles
&rsquo;set&rsquo; magic. Uses &quot;TARG&quot;, so
&quot;dTARGET&quot; or &quot;dXSTARG&quot; should be called
to declare it. Do not call multiple
&quot;TARG&quot;&minus;oriented macros to return lists from
<small>XSUB</small> &rsquo;s &minus; see &quot;mPUSHp&quot;
instead. See also &quot;XPUSHp&quot; and
&quot;mXPUSHp&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
PUSHp(char* str, STRLEN len)</p>

<p style="margin-left:11%;">&quot;PUSHs&quot;</p>

<p style="margin-left:17%;">Push an <small>SV</small> onto
the stack. The stack must have room for this element. Does
not handle &rsquo;set&rsquo; magic. Does not use
&quot;TARG&quot;. See also &quot;PUSHmortal&quot;,
&quot;XPUSHs&quot;, and &quot;XPUSHmortal&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void PUSHs(SV*
sv)</p>

<p style="margin-left:11%;">&quot;PUSHu&quot;</p>

<p style="margin-left:17%;">Push an unsigned integer onto
the stack. The stack must have room for this element.
Handles &rsquo;set&rsquo; magic. Uses &quot;TARG&quot;, so
&quot;dTARGET&quot; or &quot;dXSTARG&quot; should be called
to declare it. Do not call multiple
&quot;TARG&quot;&minus;oriented macros to return lists from
<small>XSUB</small> &rsquo;s &minus; see &quot;mPUSHu&quot;
instead. See also &quot;XPUSHu&quot; and
&quot;mXPUSHu&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void PUSHu(UV
uv)</p>

<p style="margin-left:11%;">&quot;PUTBACK&quot;</p>

<p style="margin-left:17%;">Closing bracket for
<small>XSUB</small> arguments. This is usually handled by
&quot;xsubpp&quot;. See &quot;PUSHMARK&quot; and perlcall
for other uses.</p>

<p style="margin-left:17%; margin-top: 1em">PUTBACK;</p>

<p style="margin-left:11%;">&quot;SAVEt_INT&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;SP&quot;</p>

<p style="margin-left:17%;">Stack pointer. This is usually
handled by &quot;xsubpp&quot;. See &quot;dSP&quot; and
&quot;SPAGAIN&quot;.</p>

<p style="margin-left:11%;">&quot;SPAGAIN&quot;</p>

<p style="margin-left:17%;">Refetch the stack pointer. Used
after a callback. See perlcall.</p>

<p style="margin-left:17%; margin-top: 1em">SPAGAIN;</p>

<p style="margin-left:11%;">&quot;SSNEW&quot; <br>
&quot;SSNEWa&quot; <br>
&quot;SSNEWt&quot; <br>
&quot;SSNEWat&quot;</p>

<p style="margin-left:17%;">These temporarily allocates
data on the savestack, returning an I32 index into the
savestack, because a pointer would get broken if the
savestack is moved on reallocation. Use
&quot;&quot;SSPTR&quot;&quot; to convert the returned index
into a pointer.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in that plain &quot;SSNEW&quot; allocates
&quot;size&quot; bytes; &quot;SSNEWt&quot; and
&quot;SSNEWat&quot; allocate &quot;size&quot; objects, each
of which is type &quot;type&quot;; and &lt;SSNEWa&gt; and
&quot;SSNEWat&quot; make sure to align the new data to an
&quot;align&quot; boundary. The most useful value for the
alignment is likely to be
&quot;&quot;MEM_ALIGNBYTES&quot;&quot;. The alignment will
be preserved through savestack reallocation <b>only</b> if
realloc returns data aligned to a size divisible by
&quot;align&quot;!</p>

<p style="margin-left:17%; margin-top: 1em">I32 SSNEW
(Size_t size) <br>
I32 SSNEWa (Size_t_size, Size_t align) <br>
I32 SSNEWt (Size_t size, type) <br>
I32 SSNEWat(Size_t_size, type, Size_t align)</p>

<p style="margin-left:11%;">&quot;SSPTR&quot; <br>
&quot;SSPTRt&quot;</p>

<p style="margin-left:17%;">These convert the
&quot;index&quot; returned by L/&lt;&quot;SSNEW&quot;&gt;
and kin into actual pointers.</p>

<p style="margin-left:17%; margin-top: 1em">The difference
is that &quot;SSPTR&quot; casts the result to
&quot;type&quot;, and &quot;SSPTRt&quot; casts it to a
pointer of that &quot;type&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">type SSPTR (I32
index, type) <br>
type * SSPTRt(I32 index, type)</p>

<p style="margin-left:11%;">&quot;TARG&quot;</p>

<p style="margin-left:17%;">&quot;TARG&quot; is short for
&quot;target&quot;. It is an entry in the pad that an OPs
&quot;op_targ&quot; refers to. It is scratchpad space, often
used as a return value for the <small>OP,</small> but some
use it for other purposes.</p>

<p style="margin-left:17%; margin-top: 1em">TARG;</p>

<p style="margin-left:11%;">&quot;TOPs&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;XPUSHi&quot;</p>

<p style="margin-left:17%;">Push an integer onto the stack,
extending the stack if necessary. Handles &rsquo;set&rsquo;
magic. Uses &quot;TARG&quot;, so &quot;dTARGET&quot; or
&quot;dXSTARG&quot; should be called to declare it. Do not
call multiple &quot;TARG&quot;&minus;oriented macros to
return lists from <small>XSUB</small> &rsquo;s &minus; see
&quot;mXPUSHi&quot; instead. See also &quot;PUSHi&quot; and
&quot;mPUSHi&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void XPUSHi(IV
iv)</p>

<p style="margin-left:11%;">&quot;XPUSHmortal&quot;</p>

<p style="margin-left:17%;">Push a new mortal
<small>SV</small> onto the stack, extending the stack if
necessary. Does not use &quot;TARG&quot;. See also
&quot;XPUSHs&quot;, &quot;PUSHmortal&quot; and
&quot;PUSHs&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
XPUSHmortal</p>

<p style="margin-left:11%;">&quot;XPUSHn&quot;</p>

<p style="margin-left:17%;">Push a double onto the stack,
extending the stack if necessary. Handles &rsquo;set&rsquo;
magic. Uses &quot;TARG&quot;, so &quot;dTARGET&quot; or
&quot;dXSTARG&quot; should be called to declare it. Do not
call multiple &quot;TARG&quot;&minus;oriented macros to
return lists from <small>XSUB</small> &rsquo;s &minus; see
&quot;mXPUSHn&quot; instead. See also &quot;PUSHn&quot; and
&quot;mPUSHn&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void XPUSHn(NV
nv)</p>

<p style="margin-left:11%;">&quot;XPUSHp&quot;</p>

<p style="margin-left:17%;">Push a string onto the stack,
extending the stack if necessary. The &quot;len&quot;
indicates the length of the string. Handles
&rsquo;set&rsquo; magic. Uses &quot;TARG&quot;, so
&quot;dTARGET&quot; or &quot;dXSTARG&quot; should be called
to declare it. Do not call multiple
&quot;TARG&quot;&minus;oriented macros to return lists from
<small>XSUB</small> &rsquo;s &minus; see &quot;mXPUSHp&quot;
instead. See also &quot;PUSHp&quot; and
&quot;mPUSHp&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
XPUSHp(char* str, STRLEN len)</p>

<p style="margin-left:11%;">&quot;XPUSHs&quot;</p>

<p style="margin-left:17%;">Push an <small>SV</small> onto
the stack, extending the stack if necessary. Does not handle
&rsquo;set&rsquo; magic. Does not use &quot;TARG&quot;. See
also &quot;XPUSHmortal&quot;, &quot;PUSHs&quot; and
&quot;PUSHmortal&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void XPUSHs(SV*
sv)</p>

<p style="margin-left:11%;">&quot;XPUSHu&quot;</p>

<p style="margin-left:17%;">Push an unsigned integer onto
the stack, extending the stack if necessary. Handles
&rsquo;set&rsquo; magic. Uses &quot;TARG&quot;, so
&quot;dTARGET&quot; or &quot;dXSTARG&quot; should be called
to declare it. Do not call multiple
&quot;TARG&quot;&minus;oriented macros to return lists from
<small>XSUB</small> &rsquo;s &minus; see &quot;mXPUSHu&quot;
instead. See also &quot;PUSHu&quot; and
&quot;mPUSHu&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void XPUSHu(UV
uv)</p>


<p style="margin-left:11%;">&quot;XS_APIVERSION_BOOTCHECK&quot;</p>

<p style="margin-left:17%;">Macro to verify that the perl
api version an <small>XS</small> module has been compiled
against matches the api version of the perl interpreter
it&rsquo;s being loaded into.</p>


<p style="margin-left:17%; margin-top: 1em">XS_APIVERSION_BOOTCHECK;</p>

<p style="margin-left:11%;">&quot;XSRETURN&quot;</p>

<p style="margin-left:17%;">Return from
<small>XSUB,</small> indicating number of items on the
stack. This is usually handled by &quot;xsubpp&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
XSRETURN(int nitems)</p>

<p style="margin-left:11%;">&quot;XSRETURN_EMPTY&quot;</p>

<p style="margin-left:17%;">Return an empty list from an
<small>XSUB</small> immediately.</p>


<p style="margin-left:17%; margin-top: 1em">XSRETURN_EMPTY;</p>

<p style="margin-left:11%;">&quot;XSRETURN_IV&quot;</p>

<p style="margin-left:17%;">Return an integer from an
<small>XSUB</small> immediately. Uses
&quot;XST_mIV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
XSRETURN_IV(IV iv)</p>

<p style="margin-left:11%;">&quot;XSRETURN_NO&quot;</p>

<p style="margin-left:17%;">Return &amp;PL_sv_no from an
<small>XSUB</small> immediately. Uses
&quot;XST_mNO&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">XSRETURN_NO;</p>

<p style="margin-left:11%;">&quot;XSRETURN_NV&quot;</p>

<p style="margin-left:17%;">Return a double from an
<small>XSUB</small> immediately. Uses
&quot;XST_mNV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
XSRETURN_NV(NV nv)</p>

<p style="margin-left:11%;">&quot;XSRETURN_PV&quot;</p>

<p style="margin-left:17%;">Return a copy of a string from
an <small>XSUB</small> immediately. Uses
&quot;XST_mPV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
XSRETURN_PV(char* str)</p>

<p style="margin-left:11%;">&quot;XSRETURN_UNDEF&quot;</p>

<p style="margin-left:17%;">Return &amp;PL_sv_undef from an
<small>XSUB</small> immediately. Uses
&quot;XST_mUNDEF&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">XSRETURN_UNDEF;</p>

<p style="margin-left:11%;">&quot;XSRETURN_UV&quot;</p>

<p style="margin-left:17%;">Return an integer from an
<small>XSUB</small> immediately. Uses
&quot;XST_mUV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
XSRETURN_UV(IV uv)</p>

<p style="margin-left:11%;">&quot;XSRETURN_YES&quot;</p>

<p style="margin-left:17%;">Return &amp;PL_sv_yes from an
<small>XSUB</small> immediately. Uses
&quot;XST_mYES&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">XSRETURN_YES;</p>

<p style="margin-left:11%;">&quot;XST_mIV&quot;</p>

<p style="margin-left:17%;">Place an integer into the
specified position &quot;pos&quot; on the stack. The value
is stored in a new mortal <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
XST_mIV(int pos, IV iv)</p>

<p style="margin-left:11%;">&quot;XST_mNO&quot;</p>

<p style="margin-left:17%;">Place &amp;PL_sv_no into the
specified position &quot;pos&quot; on the stack.</p>

<p style="margin-left:17%; margin-top: 1em">void
XST_mNO(int pos)</p>

<p style="margin-left:11%;">&quot;XST_mNV&quot;</p>

<p style="margin-left:17%;">Place a double into the
specified position &quot;pos&quot; on the stack. The value
is stored in a new mortal <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
XST_mNV(int pos, NV nv)</p>

<p style="margin-left:11%;">&quot;XST_mPV&quot;</p>

<p style="margin-left:17%;">Place a copy of a string into
the specified position &quot;pos&quot; on the stack. The
value is stored in a new mortal <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
XST_mPV(int pos, char* str)</p>

<p style="margin-left:11%;">&quot;XST_mUNDEF&quot;</p>

<p style="margin-left:17%;">Place &amp;PL_sv_undef into the
specified position &quot;pos&quot; on the stack.</p>

<p style="margin-left:17%; margin-top: 1em">void
XST_mUNDEF(int pos)</p>

<p style="margin-left:11%;">&quot;XST_mUV&quot;</p>

<p style="margin-left:17%;">Place an unsigned integer into
the specified position &quot;pos&quot; on the stack. The
value is stored in a new mortal <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
XST_mUV(int pos, UV uv)</p>

<p style="margin-left:11%;">&quot;XST_mYES&quot;</p>

<p style="margin-left:17%;">Place &amp;PL_sv_yes into the
specified position &quot;pos&quot; on the stack.</p>

<p style="margin-left:17%; margin-top: 1em">void
XST_mYES(int pos)</p>

<p style="margin-left:11%;">&quot;XS_VERSION&quot;</p>

<p style="margin-left:17%;">The version identifier for an
<small>XS</small> module. This is usually handled
automatically by &quot;ExtUtils::MakeMaker&quot;. See
&quot;XS_VERSION_BOOTCHECK&quot;.</p>


<p style="margin-left:11%;">&quot;XS_VERSION_BOOTCHECK&quot;</p>

<p style="margin-left:17%;">Macro to verify that a
<small>PM</small> module&rsquo;s $VERSION variable matches
the <small>XS</small> module&rsquo;s &quot;XS_VERSION&quot;
variable. This is usually handled automatically by
&quot;xsubpp&quot;. See &quot;The
<small>VERSIONCHECK:</small> Keyword&quot; in perlxs.</p>


<p style="margin-left:17%; margin-top: 1em">XS_VERSION_BOOTCHECK;</p>

<h2>String Handling
<a name="String Handling"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See also
&quot;Unicode Support&quot;. <br>
&quot;CAT2&quot;</p>

<p style="margin-left:17%;">This macro concatenates 2
tokens together.</p>

<p style="margin-left:17%; margin-top: 1em">token
CAT2(token x, token y)</p>

<p style="margin-left:11%;">&quot;Copy&quot; <br>
&quot;CopyD&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;memcpy&quot; function. The
&quot;src&quot; is the source, &quot;dest&quot; is the
destination, &quot;nitems&quot; is the number of items, and
&quot;type&quot; is the type. May fail on overlapping
copies. See also &quot;Move&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;CopyD&quot;
is like &quot;Copy&quot; but returns &quot;dest&quot;.
Useful for encouraging compilers to tail-call optimise.</p>

<p style="margin-left:17%; margin-top: 1em">void Copy
(void* src, void* dest, int nitems, type) <br>
void * CopyD(void* src, void* dest, int nitems, type)</p>

<p style="margin-left:11%;">&quot;delimcpy&quot;</p>

<p style="margin-left:17%;">Copy a source buffer to a
destination buffer, stopping at (but not including) the
first occurrence in the source of an unescaped (defined
below) delimiter byte, &quot;delim&quot;. The source is the
bytes between
&quot;from&quot;&nbsp;and&nbsp;&quot;from_end&quot;&nbsp;&minus;&nbsp;1.
Similarly, the dest is &quot;to&quot; up to
&quot;to_end&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The number of
bytes copied is written to *retlen.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
position of the first uncopied &quot;delim&quot; in the
&quot;from&quot; buffer, but if there is no such occurrence
before &quot;from_end&quot;, then &quot;from_end&quot; is
returned, and the entire buffer
&quot;from&quot;&nbsp;..&nbsp;&quot;from_end&quot;&nbsp;&minus;&nbsp;1
is copied.</p>

<p style="margin-left:17%; margin-top: 1em">If there is
room in the destination available after the copy, an extra
terminating safety &quot;NUL&quot; byte is appended (not
included in the returned length).</p>

<p style="margin-left:17%; margin-top: 1em">The error case
is if the destination buffer is not large enough to
accommodate everything that should be copied. In this
situation, a value larger than
&quot;to_end&quot;&nbsp;&minus;&nbsp;&quot;to&quot; is
written to *retlen, and as much of the source as fits will
be written to the destination. Not having room for the
safety &quot;NUL&quot; is not considered an error.</p>

<p style="margin-left:17%; margin-top: 1em">In the
following examples, let &quot;x&quot; be the delimiter, and
0 represent a &quot;NUL&quot; byte (
<b><small>NOT</small></b> the digit 0). Then we would
have</p>

<p style="margin-left:17%; margin-top: 1em">Source
Destination <br>
abcxdef abc0</p>

<p style="margin-left:17%; margin-top: 1em">provided the
destination buffer is at least 4 bytes long.</p>

<p style="margin-left:17%; margin-top: 1em">An escaped
delimiter is one which is immediately preceded by a single
backslash. Escaped delimiters are copied, and the copy
continues past the delimiter; the backslash is not
copied:</p>

<p style="margin-left:17%; margin-top: 1em">Source
Destination <br>
abc\xdef abcxdef0</p>

<p style="margin-left:17%; margin-top: 1em">(provided the
destination buffer is at least 8 bytes long).</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
actually somewhat more complicated than that. A sequence of
any odd number of backslashes escapes the following
delimiter, and the copy continues with exactly one of the
backslashes stripped.</p>

<p style="margin-left:17%; margin-top: 1em">Source
Destination <br>
abc\xdef abcxdef0 <br>
abc\\\xdef abc\\xdef0 <br>
abc\\\\\xdef abc\\\\xdef0</p>

<p style="margin-left:17%; margin-top: 1em">(as always, if
the destination is large enough)</p>

<p style="margin-left:17%; margin-top: 1em">An even number
of preceding backslashes does not escape the delimiter, so
that the copy stops just before it, and includes all the
backslashes (no stripping; zero is considered even):</p>

<p style="margin-left:17%; margin-top: 1em">Source
Destination <br>
abcxdef abc0 <br>
abc\\xdef abc\\0 <br>
abc\\\\xdef abc\\\\0</p>

<p style="margin-left:17%; margin-top: 1em">char*
delimcpy(char* to, const char* to_end, const char* from,
<br>
const char* from_end, const int delim, <br>
I32* retlen)</p>

<p style="margin-left:11%;">&quot;do_join&quot;</p>

<p style="margin-left:17%;">This performs a Perl
&quot;join&quot;, placing the joined output into
&quot;sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The elements to
join are in SVs, stored in a C array of pointers to SVs,
from **mark to &quot;**sp&nbsp;&minus;&nbsp;1&quot;. Hence
*mark is a reference to the first <small>SV.</small> Each
<small>SV</small> will be coerced into a <small>PV</small>
if not one already.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;delim&quot;
contains the string (or coerced into a string) that is to
separate each of the joined elements.</p>

<p style="margin-left:17%; margin-top: 1em">If any
component is in <small>UTF&minus;8,</small> the result will
be as well, and all non&minus;UTF&minus;8 components will be
converted to <small>UTF&minus;8</small> as necessary.</p>

<p style="margin-left:17%; margin-top: 1em">Magic and
tainting are handled.</p>

<p style="margin-left:17%; margin-top: 1em">void do_join(SV
*sv, SV *delim, SV **mark, SV **sp)</p>

<p style="margin-left:11%;">&quot;do_sprintf&quot;</p>

<p style="margin-left:17%;">This performs a Perl
&quot;sprintf&quot; placing the string output into
&quot;sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The elements to
format are in SVs, stored in a C array of pointers to SVs of
length &quot;len&quot;&gt; and beginning at **sarg. The
element referenced by *sarg is the format.</p>

<p style="margin-left:17%; margin-top: 1em">Magic and
tainting are handled.</p>

<p style="margin-left:17%; margin-top: 1em">void
do_sprintf(SV* sv, SSize_t len, SV** sarg)</p>

<p style="margin-left:11%;">&quot;fbm_compile&quot;</p>

<p style="margin-left:17%;">Analyzes the string in order to
make fast searches on it using &quot;fbm_instr()&quot; --
the Boyer-Moore algorithm.</p>

<p style="margin-left:17%; margin-top: 1em">void
fbm_compile(SV* sv, U32 flags)</p>

<p style="margin-left:11%;">&quot;fbm_instr&quot;</p>

<p style="margin-left:17%;">Returns the location of the
<small>SV</small> in the string delimited by &quot;big&quot;
and &quot;bigend&quot; (&quot;bigend&quot;) is the char
following the last char). It returns &quot;NULL&quot; if the
string can&rsquo;t be found. The &quot;sv&quot; does not
have to be &quot;fbm_compiled&quot;, but the search will not
be as fast then.</p>

<p style="margin-left:17%; margin-top: 1em">char*
fbm_instr(unsigned char* big, unsigned char* bigend, <br>
SV* littlestr, U32 flags)</p>

<p style="margin-left:11%;">&quot;foldEQ&quot;</p>

<p style="margin-left:17%;">Returns true if the leading
&quot;len&quot; bytes of the strings &quot;s1&quot; and
&quot;s2&quot; are the same case-insensitively; false
otherwise. Uppercase and lowercase <small>ASCII</small>
range bytes match themselves and their opposite case
counterparts. Non-cased and non-ASCII range bytes match only
themselves.</p>

<p style="margin-left:17%; margin-top: 1em">I32
foldEQ(const char* a, const char* b, I32 len)</p>

<p style="margin-left:11%;">&quot;ibcmp&quot;</p>

<p style="margin-left:17%;">This is a synonym for
&quot;(!&nbsp;foldEQ())&quot;</p>

<p style="margin-left:17%; margin-top: 1em">I32 ibcmp(const
char* a, const char* b, I32 len)</p>

<p style="margin-left:11%;">&quot;ibcmp_locale&quot;</p>

<p style="margin-left:17%;">This is a synonym for
&quot;(!&nbsp;foldEQ_locale())&quot;</p>

<p style="margin-left:17%; margin-top: 1em">I32
ibcmp_locale(const char* a, const char* b, I32 len)</p>

<p style="margin-left:11%;">&quot;ibcmp_utf8&quot;</p>

<p style="margin-left:17%;">This is a synonym for
&quot;(!&nbsp;foldEQ_utf8())&quot;</p>

<p style="margin-left:17%; margin-top: 1em">I32
ibcmp_utf8(const char *s1, char **pe1, UV l1, bool u1, <br>
const char *s2, char **pe2, UV l2, bool u2)</p>

<p style="margin-left:11%;">&quot;instr&quot;</p>

<p style="margin-left:17%;">Same as <b>strstr</b>(3), which
finds and returns a pointer to the first occurrence of the
NUL-terminated substring &quot;little&quot; in the
NUL-terminated string &quot;big&quot;, returning
<small>NULL</small> if not found. The terminating
<small>NUL</small> bytes are not compared.</p>

<p style="margin-left:17%; margin-top: 1em">char*
instr(const char* big, const char* little)</p>

<p style="margin-left:11%;">&quot;memCHRs&quot;</p>

<p style="margin-left:17%;">Returns the position of the
first occurence of the byte &quot;c&quot; in the literal
string &quot;list&quot;, or <small>NULL</small> if
&quot;c&quot; doesn&rsquo;t appear in &quot;list&quot;. All
bytes are treated as unsigned char. Thus this macro can be
used to determine if &quot;c&quot; is in a set of particular
characters. Unlike <b>strchr</b>(3), it works even if
&quot;c&quot; is &quot;NUL&quot; (and the set doesn&rsquo;t
include &quot;NUL&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">bool
memCHRs(&quot;list&quot;, char c)</p>

<p style="margin-left:11%;">&quot;memEQ&quot;</p>

<p style="margin-left:17%;">Test two buffers (which may
contain embedded &quot;NUL&quot; characters, to see if they
are equal. The &quot;len&quot; parameter indicates the
number of bytes to compare. Returns true or false. It is
undefined behavior if either of the buffers doesn&rsquo;t
contain at least &quot;len&quot; bytes.</p>

<p style="margin-left:17%; margin-top: 1em">bool
memEQ(char* s1, char* s2, STRLEN len)</p>

<p style="margin-left:11%;">&quot;memEQs&quot;</p>

<p style="margin-left:17%;">Like &quot;memEQ&quot;, but the
second string is a literal enclosed in double quotes,
&quot;l1&quot; gives the number of bytes in &quot;s1&quot;.
Returns true or false.</p>

<p style="margin-left:17%; margin-top: 1em">bool
memEQs(char* s1, STRLEN l1, &quot;s2&quot;)</p>

<p style="margin-left:11%;">&quot;memNE&quot;</p>

<p style="margin-left:17%;">Test two buffers (which may
contain embedded &quot;NUL&quot; characters, to see if they
are not equal. The &quot;len&quot; parameter indicates the
number of bytes to compare. Returns true or false. It is
undefined behavior if either of the buffers doesn&rsquo;t
contain at least &quot;len&quot; bytes.</p>

<p style="margin-left:17%; margin-top: 1em">bool
memNE(char* s1, char* s2, STRLEN len)</p>

<p style="margin-left:11%;">&quot;memNEs&quot;</p>

<p style="margin-left:17%;">Like &quot;memNE&quot;, but the
second string is a literal enclosed in double quotes,
&quot;l1&quot; gives the number of bytes in &quot;s1&quot;.
Returns true or false.</p>

<p style="margin-left:17%; margin-top: 1em">bool
memNEs(char* s1, STRLEN l1, &quot;s2&quot;)</p>

<p style="margin-left:11%;">&quot;Move&quot; <br>
&quot;MoveD&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;memmove&quot; function. The
&quot;src&quot; is the source, &quot;dest&quot; is the
destination, &quot;nitems&quot; is the number of items, and
&quot;type&quot; is the type. Can do overlapping moves. See
also &quot;Copy&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;MoveD&quot;
is like &quot;Move&quot; but returns &quot;dest&quot;.
Useful for encouraging compilers to tail-call optimise.</p>

<p style="margin-left:17%; margin-top: 1em">void Move
(void* src, void* dest, int nitems, type) <br>
void * MoveD(void* src, void* dest, int nitems, type)</p>

<p style="margin-left:11%;">&quot;my_snprintf&quot;</p>

<p style="margin-left:17%;">The C library
&quot;snprintf&quot; functionality, if available and
standards-compliant (uses &quot;vsnprintf&quot;, actually).
However, if the &quot;vsnprintf&quot; is not available, will
unfortunately use the unsafe &quot;vsprintf&quot; which can
overrun the buffer (there is an overrun check, but that may
be too late). Consider using &quot;sv_vcatpvf&quot; instead,
or getting &quot;vsnprintf&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
my_snprintf(char *buffer, const Size_t len, <br>
const char *format, ...)</p>

<p style="margin-left:11%;">&quot;my_sprintf&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;my_sprintf&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Do
<small>NOT</small> use this due to the possibility of
overflowing &quot;buffer&quot;. Instead use
<b>my_snprintf()</b></p>

<p style="margin-left:17%; margin-top: 1em">int
my_sprintf(NN char *buffer, NN const char *pat, ...)</p>

<p style="margin-left:11%;">&quot;my_strlcat&quot;</p>

<p style="margin-left:17%;">The C library
&quot;strlcat&quot; if available, or a Perl implementation
of it. This operates on C &quot;NUL&quot;&minus;terminated
strings.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;my_strlcat()&quot;
appends string &quot;src&quot; to the end of
&quot;dst&quot;. It will append at most
&quot;size&nbsp;&minus;&nbsp;strlen(dst)&nbsp;&minus;&nbsp;1&quot;
characters. It will then &quot;NUL&quot;&minus;terminate,
unless &quot;size&quot; is 0 or the original &quot;dst&quot;
string was longer than &quot;size&quot; (in practice this
should not happen as it means that either &quot;size&quot;
is incorrect or that &quot;dst&quot; is not a proper
&quot;NUL&quot;&minus;terminated string).</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;size&quot; is the full size of the destination buffer
and the result is guaranteed to be
&quot;NUL&quot;&minus;terminated if there is room. Note that
room for the &quot;NUL&quot; should be included in
&quot;size&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value is the total length that &quot;dst&quot; would have if
&quot;size&quot; is sufficiently large. Thus it is the
initial length of &quot;dst&quot; plus the length of
&quot;src&quot;. If &quot;size&quot; is smaller than the
return, the excess was not appended.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
my_strlcat(char *dst, const char *src, Size_t size)</p>

<p style="margin-left:11%;">&quot;my_strlcpy&quot;</p>

<p style="margin-left:17%;">The C library
&quot;strlcpy&quot; if available, or a Perl implementation
of it. This operates on C &quot;NUL&quot;&minus;terminated
strings.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;my_strlcpy()&quot;
copies up to &quot;size&nbsp;&minus;&nbsp;1&quot; characters
from the string &quot;src&quot; to &quot;dst&quot;,
&quot;NUL&quot;&minus;terminating the result if
&quot;size&quot; is not 0.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value is the total length &quot;src&quot; would be if the
copy completely succeeded. If it is larger than
&quot;size&quot;, the excess was not copied.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
my_strlcpy(char *dst, const char *src, Size_t size)</p>

<p style="margin-left:11%;">&quot;my_strnlen&quot;</p>

<p style="margin-left:17%;">The C library
&quot;strnlen&quot; if available, or a Perl implementation
of it.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;my_strnlen()&quot;
computes the length of the string, up to &quot;maxlen&quot;
characters. It will never attempt to address more than
&quot;maxlen&quot; characters, making it suitable for use
with strings that are not guaranteed to be
NUL-terminated.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
my_strnlen(const char *str, Size_t maxlen)</p>

<p style="margin-left:11%;">&quot;my_vsnprintf&quot;</p>

<p style="margin-left:17%;">The C library
&quot;vsnprintf&quot; if available and standards-compliant.
However, if the &quot;vsnprintf&quot; is not available, will
unfortunately use the unsafe &quot;vsprintf&quot; which can
overrun the buffer (there is an overrun check, but that may
be too late). Consider using &quot;sv_vcatpvf&quot; instead,
or getting &quot;vsnprintf&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">int
my_vsnprintf(char *buffer, const Size_t len, <br>
const char *format, va_list ap)</p>

<p style="margin-left:11%;">&quot;ninstr&quot;</p>

<p style="margin-left:17%;">Find the first (leftmost)
occurrence of a sequence of bytes within another sequence.
This is the Perl version of &quot;strstr()&quot;, extended
to handle arbitrary sequences, potentially containing
embedded &quot;NUL&quot; characters (&quot;NUL&quot; is what
the initial &quot;n&quot; in the function name stands for;
some systems have an equivalent, &quot;memmem()&quot;, but
with a somewhat different <small>API</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">Another way of
thinking about this function is finding a needle in a
haystack. &quot;big&quot; points to the first byte in the
haystack. &quot;big_end&quot; points to one byte beyond the
final byte in the haystack. &quot;little&quot; points to the
first byte in the needle. &quot;little_end&quot; points to
one byte beyond the final byte in the needle. All the
parameters must be non&minus;&quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The function
returns &quot;NULL&quot; if there is no occurrence of
&quot;little&quot; within &quot;big&quot;. If
&quot;little&quot; is the empty string, &quot;big&quot; is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">Because this
function operates at the byte level, and because of the
inherent characteristics of <small>UTF&minus;8</small> (or
UTF-EBCDIC), it will work properly if both the needle and
the haystack are strings with the same UTF&minus;8ness, but
not if the UTF&minus;8ness differs.</p>

<p style="margin-left:17%; margin-top: 1em">char*
ninstr(const char* big, const char* bigend, <br>
const char* little, const char* lend)</p>

<p style="margin-left:11%;">&quot;Nullch&quot;</p>

<p style="margin-left:17%;">Null character pointer. (No
longer available when &quot;PERL_CORE&quot; is defined.)</p>

<p style="margin-left:11%;">&quot;PL_na&quot;</p>

<p style="margin-left:17%;">A scratch pad variable in which
to store a &quot;STRLEN&quot; value. If would have been
better named something like &quot;PL_temp_strlen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">It is is
typically used with &quot;SvPV&quot; when one is actually
planning to discard the returned length, (hence the length
is &quot;Not Applicable&quot;, which is how this variable
got its name).</p>

<p style="margin-left:17%; margin-top: 1em">It is usually
more efficient to either declare a local variable and use
that instead, or to use the &quot;SvPV_nolen&quot;
macro.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
PL_na</p>

<p style="margin-left:11%;">&quot;rninstr&quot;</p>

<p style="margin-left:17%;">Like &quot;ninstr&quot;, but
instead finds the final (rightmost) occurrence of a sequence
of bytes within another sequence, returning &quot;NULL&quot;
if there is no such occurrence.</p>

<p style="margin-left:17%; margin-top: 1em">char*
rninstr(const char* big, const char* bigend, <br>
const char* little, const char* lend)</p>

<p style="margin-left:11%;">&quot;savepv&quot;</p>

<p style="margin-left:17%;">Perl&rsquo;s version of
&quot;strdup()&quot;. Returns a pointer to a newly allocated
string which is a duplicate of &quot;pv&quot;. The size of
the string is determined by &quot;strlen()&quot;, which
means it may not contain embedded &quot;NUL&quot; characters
and must have a trailing &quot;NUL&quot;. To prevent memory
leaks, the memory allocated for the new string needs to be
freed when no longer needed. This can be done with the
&quot;Safefree&quot; function, or
&quot;SAVEFREEPV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">On some
platforms, Windows for example, all allocated memory owned
by a thread is deallocated when that thread ends. So if you
need that not to happen, you need to use the shared memory
functions, such as &quot;savesharedpv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
savepv(const char* pv)</p>

<p style="margin-left:11%;">&quot;savepvn&quot;</p>

<p style="margin-left:17%;">Perl&rsquo;s version of what
&quot;strndup()&quot; would be if it existed. Returns a
pointer to a newly allocated string which is a duplicate of
the first &quot;len&quot; bytes from &quot;pv&quot;, plus a
trailing &quot;NUL&quot; byte. The memory allocated for the
new string can be freed with the &quot;Safefree()&quot;
function.</p>

<p style="margin-left:17%; margin-top: 1em">On some
platforms, Windows for example, all allocated memory owned
by a thread is deallocated when that thread ends. So if you
need that not to happen, you need to use the shared memory
functions, such as &quot;savesharedpvn&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
savepvn(const char* pv, Size_t len)</p>

<p style="margin-left:11%;">&quot;savepvs&quot;</p>

<p style="margin-left:17%;">Like &quot;savepvn&quot;, but
takes a literal string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">char*
savepvs(&quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;savesharedpv&quot;</p>

<p style="margin-left:17%;">A version of
&quot;savepv()&quot; which allocates the duplicate string in
memory which is shared between threads.</p>

<p style="margin-left:17%; margin-top: 1em">char*
savesharedpv(const char* pv)</p>

<p style="margin-left:11%;">&quot;savesharedpvn&quot;</p>

<p style="margin-left:17%;">A version of
&quot;savepvn()&quot; which allocates the duplicate string
in memory which is shared between threads. (With the
specific difference that a &quot;NULL&quot; pointer is not
acceptable)</p>

<p style="margin-left:17%; margin-top: 1em">char*
savesharedpvn(const char *const pv, const STRLEN len)</p>

<p style="margin-left:11%;">&quot;savesharedpvs&quot;</p>

<p style="margin-left:17%;">A version of
&quot;savepvs()&quot; which allocates the duplicate string
in memory which is shared between threads.</p>

<p style="margin-left:17%; margin-top: 1em">char*
savesharedpvs(&quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;savesharedsvpv&quot;</p>

<p style="margin-left:17%;">A version of
&quot;savesharedpv()&quot; which allocates the duplicate
string in memory which is shared between threads.</p>

<p style="margin-left:17%; margin-top: 1em">char*
savesharedsvpv(SV *sv)</p>

<p style="margin-left:11%;">&quot;savesvpv&quot;</p>

<p style="margin-left:17%;">A version of
&quot;savepv()&quot;/&quot;savepvn()&quot; which gets the
string to duplicate from the passed in <small>SV</small>
using &quot;SvPV()&quot;</p>

<p style="margin-left:17%; margin-top: 1em">On some
platforms, Windows for example, all allocated memory owned
by a thread is deallocated when that thread ends. So if you
need that not to happen, you need to use the shared memory
functions, such as &quot;savesharedsvpv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
savesvpv(SV* sv)</p>

<p style="margin-left:11%;">&quot;strEQ&quot;</p>

<p style="margin-left:17%;">Test two
&quot;NUL&quot;&minus;terminated strings to see if they are
equal. Returns true or false.</p>

<p style="margin-left:17%; margin-top: 1em">bool
strEQ(char* s1, char* s2)</p>

<p style="margin-left:11%;">&quot;strGE&quot;</p>

<p style="margin-left:17%;">Test two
&quot;NUL&quot;&minus;terminated strings to see if the
first, &quot;s1&quot;, is greater than or equal to the
second, &quot;s2&quot;. Returns true or false.</p>

<p style="margin-left:17%; margin-top: 1em">bool
strGE(char* s1, char* s2)</p>

<p style="margin-left:11%;">&quot;strGT&quot;</p>

<p style="margin-left:17%;">Test two
&quot;NUL&quot;&minus;terminated strings to see if the
first, &quot;s1&quot;, is greater than the second,
&quot;s2&quot;. Returns true or false.</p>

<p style="margin-left:17%; margin-top: 1em">bool
strGT(char* s1, char* s2)</p>

<p style="margin-left:11%;">&quot;STRINGIFY&quot;</p>

<p style="margin-left:17%;">This macro surrounds its token
with double quotes.</p>

<p style="margin-left:17%; margin-top: 1em">string
STRINGIFY(token x)</p>

<p style="margin-left:11%;">&quot;strLE&quot;</p>

<p style="margin-left:17%;">Test two
&quot;NUL&quot;&minus;terminated strings to see if the
first, &quot;s1&quot;, is less than or equal to the second,
&quot;s2&quot;. Returns true or false.</p>

<p style="margin-left:17%; margin-top: 1em">bool
strLE(char* s1, char* s2)</p>

<p style="margin-left:11%;">&quot;STRLEN&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;strLT&quot;</p>

<p style="margin-left:17%;">Test two
&quot;NUL&quot;&minus;terminated strings to see if the
first, &quot;s1&quot;, is less than the second,
&quot;s2&quot;. Returns true or false.</p>

<p style="margin-left:17%; margin-top: 1em">bool
strLT(char* s1, char* s2)</p>

<p style="margin-left:11%;">&quot;strNE&quot;</p>

<p style="margin-left:17%;">Test two
&quot;NUL&quot;&minus;terminated strings to see if they are
different. Returns true or false.</p>

<p style="margin-left:17%; margin-top: 1em">bool
strNE(char* s1, char* s2)</p>

<p style="margin-left:11%;">&quot;strnEQ&quot;</p>

<p style="margin-left:17%;">Test two
&quot;NUL&quot;&minus;terminated strings to see if they are
equal. The &quot;len&quot; parameter indicates the number of
bytes to compare. Returns true or false. (A wrapper for
&quot;strncmp&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">bool
strnEQ(char* s1, char* s2, STRLEN len)</p>

<p style="margin-left:11%;">&quot;strnNE&quot;</p>

<p style="margin-left:17%;">Test two
&quot;NUL&quot;&minus;terminated strings to see if they are
different. The &quot;len&quot; parameter indicates the
number of bytes to compare. Returns true or false. (A
wrapper for &quot;strncmp&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">bool
strnNE(char* s1, char* s2, STRLEN len)</p>

<p style="margin-left:11%;">&quot;STR_WITH_LEN&quot;</p>

<p style="margin-left:17%;">Returns two comma separated
tokens of the input literal string, and its length. This is
convenience macro which helps out in some <small>API</small>
calls. Note that it can&rsquo;t be used as an argument to
macros or functions that under some configurations might be
macros, which means that it requires the full Perl_xxx(aTHX_
...) form for any <small>API</small> calls where it&rsquo;s
used.</p>

<p style="margin-left:17%; margin-top: 1em">pair
STR_WITH_LEN(&quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;Zero&quot; <br>
&quot;ZeroD&quot;</p>

<p style="margin-left:17%;">The XSUB-writer&rsquo;s
interface to the C &quot;memzero&quot; function. The
&quot;dest&quot; is the destination, &quot;nitems&quot; is
the number of items, and &quot;type&quot; is the type.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;ZeroD&quot;
is like &quot;Zero&quot; but returns &quot;dest&quot;.
Useful for encouraging compilers to tail-call optimise.</p>

<p style="margin-left:17%; margin-top: 1em">void Zero
(void* dest, int nitems, type) <br>
void * ZeroD(void* dest, int nitems, type)</p>

<h2>SV Flags
<a name="SV Flags"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;SVt_IV&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_NULL&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_NV&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PV&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVAV&quot;</p>

<p style="margin-left:17%;">Type flag for arrays. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVCV&quot;</p>

<p style="margin-left:17%;">Type flag for subroutines. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVFM&quot;</p>

<p style="margin-left:17%;">Type flag for formats. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVGV&quot;</p>

<p style="margin-left:17%;">Type flag for typeglobs. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVHV&quot;</p>

<p style="margin-left:17%;">Type flag for hashes. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVIO&quot;</p>

<p style="margin-left:17%;">Type flag for I/O objects. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVIV&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVLV&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVMG&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_PVNV&quot;</p>

<p style="margin-left:17%;">Type flag for scalars. See
&quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;SVt_REGEXP&quot;</p>

<p style="margin-left:17%;">Type flag for regular
expressions. See &quot;svtype&quot;.</p>

<p style="margin-left:11%;">&quot;svtype&quot;</p>

<p style="margin-left:17%;">An enum of flags for Perl
types. These are found in the file <i>sv.h</i> in the
&quot;svtype&quot; enum. Test these flags with the
&quot;SvTYPE&quot; macro.</p>

<p style="margin-left:17%; margin-top: 1em">The types
are:</p>

<p style="margin-left:17%; margin-top: 1em">SVt_NULL <br>
SVt_IV <br>
SVt_NV <br>
SVt_RV <br>
SVt_PV <br>
SVt_PVIV <br>
SVt_PVNV <br>
SVt_PVMG <br>
SVt_INVLIST <br>
SVt_REGEXP <br>
SVt_PVGV <br>
SVt_PVLV <br>
SVt_PVAV <br>
SVt_PVHV <br>
SVt_PVCV <br>
SVt_PVFM <br>
SVt_PVIO</p>

<p style="margin-left:17%; margin-top: 1em">These are most
easily explained from the bottom up.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SVt_PVIO&quot;
is for I/O objects, &quot;SVt_PVFM&quot; for formats,
&quot;SVt_PVCV&quot; for subroutines, &quot;SVt_PVHV&quot;
for hashes and &quot;SVt_PVAV&quot; for arrays.</p>

<p style="margin-left:17%; margin-top: 1em">All the others
are scalar types, that is, things that can be bound to a
&quot;$&quot; variable. For these, the internal types are
mostly orthogonal to types in the Perl language.</p>

<p style="margin-left:17%; margin-top: 1em">Hence, checking
&quot;SvTYPE(sv) &lt; SVt_PVAV&quot; is the best way to see
whether something is a scalar.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SVt_PVGV&quot;
represents a typeglob. If &quot;!SvFAKE(sv)&quot;, then it
is a real, incoercible typeglob. If &quot;SvFAKE(sv)&quot;,
then it is a scalar to which a typeglob has been assigned.
Assigning to it again will stop it from being a typeglob.
&quot;SVt_PVLV&quot; represents a scalar that delegates to
another scalar behind the scenes. It is used, e.g., for the
return value of &quot;substr&quot; and for tied hash and
array elements. It can hold any scalar value, including a
typeglob. &quot;SVt_REGEXP&quot; is for regular expressions.
&quot;SVt_INVLIST&quot; is for Perl core internal use
only.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SVt_PVMG&quot;
represents a &quot;normal&quot; scalar (not a typeglob,
regular expression, or delegate). Since most scalars do not
need all the internal fields of a <small>PVMG,</small> we
save memory by allocating smaller structs when possible. All
the other types are just simpler forms of
&quot;SVt_PVMG&quot;, with fewer internal fields.
&quot;SVt_NULL&quot; can only hold undef. &quot;SVt_IV&quot;
can hold undef, an integer, or a reference.
(&quot;SVt_RV&quot; is an alias for &quot;SVt_IV&quot;,
which exists for backward compatibility.) &quot;SVt_NV&quot;
can hold any of those or a double. &quot;SVt_PV&quot; can
only hold &quot;undef&quot; or a string.
&quot;SVt_PVIV&quot; is a superset of &quot;SVt_PV&quot; and
&quot;SVt_IV&quot;. &quot;SVt_PVNV&quot; is similar.
&quot;SVt_PVMG&quot; can hold anything &quot;SVt_PVNV&quot;
can hold, but it can, but does not have to, be blessed or
magical.</p>

<h2>SV Handling
<a name="SV Handling"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;boolSV&quot;</p>

<p style="margin-left:17%;">Returns a true
<small>SV</small> if &quot;b&quot; is a true value, or a
false <small>SV</small> if &quot;b&quot; is 0.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;PL_sv_yes&quot; and &quot;PL_sv_no&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
boolSV(bool b)</p>

<p style="margin-left:11%;">&quot;croak_xs_usage&quot;</p>

<p style="margin-left:17%;">A specialised variant of
&quot;croak()&quot; for emitting the usage message for
xsubs</p>


<p style="margin-left:17%; margin-top: 1em">croak_xs_usage(cv,
&quot;eee_yow&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">works out the
package name and subroutine name from &quot;cv&quot;, and
then calls &quot;croak()&quot;. Hence if &quot;cv&quot; is
&amp;ouch::awk, it would call &quot;croak&quot; as:</p>


<p style="margin-left:17%; margin-top: 1em">Perl_croak(aTHX_
&quot;Usage: %&quot; SVf &quot;::%&quot; SVf
&quot;(%s)&quot;, &quot;ouch&quot; &quot;awk&quot;, <br>
&quot;eee_yow&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">void
croak_xs_usage(const CV *const cv, const char *const
params)</p>

<p style="margin-left:11%;">&quot;DEFSV&quot;</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
associated with $_</p>

<p style="margin-left:17%; margin-top: 1em">SV * DEFSV</p>

<p style="margin-left:11%;">&quot;DEFSV_set&quot;</p>

<p style="margin-left:17%;">Associate &quot;sv&quot; with
$_</p>

<p style="margin-left:17%; margin-top: 1em">void
DEFSV_set(SV * sv)</p>

<p style="margin-left:11%;">&quot;get_sv&quot;</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
of the specified Perl scalar. &quot;flags&quot; are passed
to &quot;&quot;gv_fetchpv&quot;&quot;. If &quot;GV_ADD&quot;
is set and the Perl variable does not exist then it will be
created. If &quot;flags&quot; is zero and the variable does
not exist then <small>NULL</small> is returned.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
the &quot;perl_get_sv()&quot; form is <b>deprecated</b>.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
get_sv(const char *name, I32 flags)</p>

<p style="margin-left:11%;">&quot;isGV_with_GP&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
or not &quot;sv&quot; is a <small>GV</small> with a pointer
to a <small>GP</small> (glob pointer).</p>

<p style="margin-left:17%; margin-top: 1em">bool
isGV_with_GP(SV * sv)</p>


<p style="margin-left:11%;">&quot;looks_like_number&quot;</p>

<p style="margin-left:17%;">Test if the content of an
<small>SV</small> looks like a number (or is a number).
&quot;Inf&quot; and &quot;Infinity&quot; are treated as
numbers (so will not issue a non-numeric warning), even if
your &quot;atof()&quot; doesn&rsquo;t grok them. Get-magic
is ignored.</p>

<p style="margin-left:17%; margin-top: 1em">I32
looks_like_number(SV *const sv)</p>

<p style="margin-left:11%;">&quot;MUTABLE_PTR&quot; <br>
&quot;MUTABLE_AV&quot; <br>
&quot;MUTABLE_CV&quot; <br>
&quot;MUTABLE_GV&quot; <br>
&quot;MUTABLE_HV&quot; <br>
&quot;MUTABLE_IO&quot; <br>
&quot;MUTABLE_SV&quot;</p>

<p style="margin-left:17%;">The
&quot;MUTABLE_<i>*</i>&quot;() macros cast pointers to the
types shown, in such a way (compiler permitting) that
casting away const-ness will give a warning; e.g.:</p>

<p style="margin-left:17%; margin-top: 1em">const SV *sv =
...; <br>
AV *av1 = (AV*)sv; &lt;== BAD: the const has been silently
<br>
cast away <br>
AV *av2 = MUTABLE_AV(sv); &lt;== GOOD: it may warn</p>


<p style="margin-left:17%; margin-top: 1em">&quot;MUTABLE_PTR&quot;
is the base macro used to derive new casts. The other
already-built-in ones return pointers to what their names
indicate.</p>

<p style="margin-left:17%; margin-top: 1em">void *
MUTABLE_PTR(void * p) <br>
AV * MUTABLE_AV (AV * p) <br>
CV * MUTABLE_CV (CV * p) <br>
GV * MUTABLE_GV (GV * p) <br>
HV * MUTABLE_HV (HV * p) <br>
IO * MUTABLE_IO (IO * p) <br>
SV * MUTABLE_SV (SV * p)</p>

<p style="margin-left:11%;">&quot;newRV&quot; <br>
&quot;newRV_inc&quot;</p>

<p style="margin-left:17%;">These are identical. They
create an <small>RV</small> wrapper for an
<small>SV.</small> The reference count for the original
<small>SV</small> is incremented.</p>

<p style="margin-left:17%; margin-top: 1em">SV* newRV(SV
*const sv)</p>

<p style="margin-left:11%;">&quot;newRV_noinc&quot;</p>

<p style="margin-left:17%;">Creates an <small>RV</small>
wrapper for an <small>SV.</small> The reference count for
the original <small>SV</small> is <b>not</b>
incremented.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newRV_noinc(SV *const tmpRef)</p>

<p style="margin-left:11%;">&quot;newSV&quot;</p>

<p style="margin-left:17%;">Creates a new
<small>SV.</small> A non-zero &quot;len&quot; parameter
indicates the number of bytes of preallocated string space
the <small>SV</small> should have. An extra byte for a
trailing &quot;NUL&quot; is also reserved.
(&quot;SvPOK&quot; is not set for the <small>SV</small> even
if string space is allocated.) The reference count for the
new <small>SV</small> is set to 1.</p>

<p style="margin-left:17%; margin-top: 1em">In 5.9.3,
&quot;newSV()&quot; replaces the older &quot;NEWSV()&quot;
<small>API,</small> and drops the first parameter, <i>x</i>,
a debug aid which allowed callers to identify themselves.
This aid has been superseded by a new build option,
&quot;PERL_MEM_LOG&quot; (see &quot;
<small>PERL_MEM_LOG&quot;</small> in perlhacktips). The
older <small>API</small> is still there for use in
<small>XS</small> modules supporting older perls.</p>

<p style="margin-left:17%; margin-top: 1em">SV* newSV(const
STRLEN len)</p>

<p style="margin-left:11%;">&quot;newSVhek&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
from the hash key structure. It will generate scalars that
point to the shared string table where possible. Returns a
new (undefined) <small>SV</small> if &quot;hek&quot; is
<small>NULL.</small></p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVhek(const HEK *const hek)</p>

<p style="margin-left:11%;">&quot;newSViv&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
and copies an integer into it. The reference count for the
<small>SV</small> is set to 1.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSViv(const IV i)</p>

<p style="margin-left:11%;">&quot;newSVnv&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
and copies a floating point value into it. The reference
count for the <small>SV</small> is set to 1.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVnv(const NV n)</p>

<p style="margin-left:11%;">&quot;newSVpadname&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;newSVpadname&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Creates a new
<small>SV</small> containing the pad name.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpadname(PADNAME *pn)</p>

<p style="margin-left:11%;">&quot;newSVpv&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
and copies a string (which may contain &quot;NUL&quot;
(&quot;\0&quot;) characters) into it. The reference count
for the <small>SV</small> is set to 1. If &quot;len&quot; is
zero, Perl will compute the length using
&quot;strlen()&quot;, (which means if you use this option,
that &quot;s&quot; can&rsquo;t have embedded &quot;NUL&quot;
characters and has to have a terminating &quot;NUL&quot;
byte).</p>

<p style="margin-left:17%; margin-top: 1em">This function
can cause reliability issues if you are likely to pass in
empty strings that are not null terminated, because it will
run strlen on the string and potentially run past valid
memory.</p>

<p style="margin-left:17%; margin-top: 1em">Using
&quot;newSVpvn&quot; is a safer alternative for non
&quot;NUL&quot; terminated strings. For string literals use
&quot;newSVpvs&quot; instead. This function will work fine
for &quot;NUL&quot; terminated strings, but if you want to
avoid the if statement on whether to call &quot;strlen&quot;
use &quot;newSVpvn&quot; instead (calling &quot;strlen&quot;
yourself).</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpv(const char *const s, const STRLEN len)</p>

<p style="margin-left:11%;">&quot;newSVpvf&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
and initializes it with the string formatted like
&quot;sv_catpvf&quot;.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;newSVpvf&quot; must be explicitly called as
&quot;Perl_newSVpvf&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
Perl_newSVpvf(pTHX_ const char *const pat, ...)</p>


<p style="margin-left:11%;">&quot;newSVpvf_nocontext&quot;</p>

<p style="margin-left:17%;">Like &quot;newSVpvf&quot; but
does not take a thread context (&quot;aTHX&quot;) parameter,
so is used in situations where the caller doesn&rsquo;t
already have the thread context.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpvf_nocontext(const char *const pat, ...)</p>

<p style="margin-left:11%;">&quot;newSVpvn&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
and copies a string into it, which may contain
&quot;NUL&quot; characters (&quot;\0&quot;) and other binary
data. The reference count for the <small>SV</small> is set
to 1. Note that if &quot;len&quot; is zero, Perl will create
a zero length (Perl) string. You are responsible for
ensuring that the source buffer is at least &quot;len&quot;
bytes long. If the &quot;buffer&quot; argument is
<small>NULL</small> the new <small>SV</small> will be
undefined.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpvn(const char *const buffer, const STRLEN len)</p>

<p style="margin-left:11%;">&quot;newSVpvn_flags&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
and copies a string (which may contain &quot;NUL&quot;
(&quot;\0&quot;) characters) into it. The reference count
for the <small>SV</small> is set to 1. Note that if
&quot;len&quot; is zero, Perl will create a zero length
string. You are responsible for ensuring that the source
string is at least &quot;len&quot; bytes long. If the
&quot;s&quot; argument is <small>NULL</small> the new
<small>SV</small> will be undefined. Currently the only flag
bits accepted are &quot;SVf_UTF8&quot; and
&quot;SVs_TEMP&quot;. If &quot;SVs_TEMP&quot; is set, then
&quot;sv_2mortal()&quot; is called on the result before
returning. If &quot;SVf_UTF8&quot; is set, &quot;s&quot; is
considered to be in <small>UTF&minus;8</small> and the
&quot;SVf_UTF8&quot; flag will be set on the new
<small>SV.</small> &quot;newSVpvn_utf8()&quot; is a
convenience wrapper for this function, defined as</p>

<p style="margin-left:17%; margin-top: 1em">#define
newSVpvn_utf8(s, len, u) \ <br>
newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpvn_flags(const char *const s, const STRLEN len, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;newSVpvn_share&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
with its &quot;SvPVX_const&quot; pointing to a shared string
in the string table. If the string does not already exist in
the table, it is created first. Turns on the
&quot;SvIsCOW&quot; flag (or &quot;READONLY&quot; and
&quot;FAKE&quot; in 5.16 and earlier). If the
&quot;hash&quot; parameter is non-zero, that value is used;
otherwise the hash is computed. The string&rsquo;s hash can
later be retrieved from the <small>SV</small> with the
&quot;SvSHARED_HASH&quot; macro. The idea here is that as
the string table is used for shared hash keys these strings
will have &quot;SvPVX_const == HeKEY&quot; and hash lookup
will avoid string compare.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpvn_share(const char* s, I32 len, U32 hash)</p>

<p style="margin-left:11%;">&quot;newSVpvn_utf8&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
and copies a string (which may contain &quot;NUL&quot;
(&quot;\0&quot;) characters) into it. If &quot;utf8&quot; is
true, calls &quot;SvUTF8_on&quot; on the new
<small>SV.</small> Implemented as a wrapper around
&quot;newSVpvn_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpvn_utf8(const char* s, STRLEN len, U32 utf8)</p>

<p style="margin-left:11%;">&quot;newSVpvs&quot;</p>

<p style="margin-left:17%;">Like &quot;newSVpvn&quot;, but
takes a literal string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpvs(&quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;newSVpvs_flags&quot;</p>

<p style="margin-left:17%;">Like
&quot;newSVpvn_flags&quot;, but takes a literal string
instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpvs_flags(&quot;literal string&quot;, U32 flags)</p>

<p style="margin-left:11%;">&quot;newSVpv_share&quot;</p>

<p style="margin-left:17%;">Like
&quot;newSVpvn_share&quot;, but takes a
&quot;NUL&quot;&minus;terminated string instead of a
string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpv_share(const char* s, U32 hash)</p>

<p style="margin-left:11%;">&quot;newSVpvs_share&quot;</p>

<p style="margin-left:17%;">Like
&quot;newSVpvn_share&quot;, but takes a literal string
instead of a string/length pair and omits the hash
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVpvs_share(&quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;newSVrv&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
for the existing <small>RV,</small> &quot;rv&quot;, to point
to. If &quot;rv&quot; is not an <small>RV</small> then it
will be upgraded to one. If &quot;classname&quot; is
non-null then the new <small>SV</small> will be blessed in
the specified package. The new <small>SV</small> is returned
and its reference count is 1. The reference count 1 is owned
by &quot;rv&quot;. See also <b>newRV_inc()</b> and
<b>newRV_noinc()</b> for creating a new <small>RV</small>
properly.</p>

<p style="margin-left:17%; margin-top: 1em">SV* newSVrv(SV
*const rv, const char *const classname)</p>

<p style="margin-left:11%;">&quot;newSVsv&quot; <br>
&quot;newSVsv_nomg&quot; <br>
&quot;newSVsv_flags&quot;</p>

<p style="margin-left:17%;">These create a new
<small>SV</small> which is an exact duplicate of the
original <small>SV</small> (using &quot;sv_setsv&quot;.)</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;newSVsv&quot; performs &rsquo;get&rsquo;
magic; &quot;newSVsv_nomg&quot; skips any magic; and
&quot;newSVsv_flags&quot; allows you to explicitly set a
&quot;flags&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">SV* newSVsv (SV
*const old) <br>
SV* newSVsv_nomg (SV *const old) <br>
SV* newSVsv_flags(SV *const old, I32 flags)</p>

<p style="margin-left:11%;">&quot;newSV_type&quot;</p>

<p style="margin-left:17%;">Creates a new
<small>SV,</small> of the type specified. The reference
count for the new <small>SV</small> is set to 1.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSV_type(const svtype type)</p>


<p style="margin-left:11%;">&quot;newSV_type_mortal&quot;</p>

<p style="margin-left:17%;">Creates a new mortal
<small>SV,</small> of the type specified. The reference
count for the new <small>SV</small> is set to 1.</p>

<p style="margin-left:17%; margin-top: 1em">This is
equivalent to <br>
SV* sv = sv_2mortal(newSV_type(&lt;some type&gt;)) and <br>
SV* sv = <b>sv_newmortal()</b>; <br>
sv_upgrade(sv, &lt;some_type&gt;) but should be more
efficient than both of them. (Unless sv_2mortal is inlined
at some point in the future.)</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSV_type_mortal(const svtype type)</p>

<p style="margin-left:11%;">&quot;newSVuv&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
and copies an unsigned integer into it. The reference count
for the <small>SV</small> is set to 1.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
newSVuv(const UV u)</p>

<p style="margin-left:11%;">&quot;Nullsv&quot;</p>

<p style="margin-left:17%;">Null <small>SV</small> pointer.
(No longer available when &quot;PERL_CORE&quot; is
defined.)</p>

<p style="margin-left:11%;">&quot;PL_sv_no&quot;</p>

<p style="margin-left:17%;">This is the &quot;false&quot;
<small>SV.</small> It is readonly. See
&quot;PL_sv_yes&quot;. Always refer to this as
&amp;PL_sv_no.</p>

<p style="margin-left:17%; margin-top: 1em">SV PL_sv_no</p>

<p style="margin-left:11%;">&quot;PL_sv_undef&quot;</p>

<p style="margin-left:17%;">This is the &quot;undef&quot;
<small>SV.</small> It is readonly. Always refer to this as
&amp;PL_sv_undef.</p>

<p style="margin-left:17%; margin-top: 1em">SV
PL_sv_undef</p>

<p style="margin-left:11%;">&quot;PL_sv_yes&quot;</p>

<p style="margin-left:17%;">This is the &quot;true&quot;
<small>SV.</small> It is readonly. See &quot;PL_sv_no&quot;.
Always refer to this as &amp;PL_sv_yes.</p>

<p style="margin-left:17%; margin-top: 1em">SV
PL_sv_yes</p>

<p style="margin-left:11%;">&quot;PL_sv_zero&quot;</p>

<p style="margin-left:17%;">This readonly <small>SV</small>
has a zero numeric value and a &quot;0&quot; string value.
It&rsquo;s similar to &quot;PL_sv_no&quot; except for its
string value. Can be used as a cheap alternative to
mXPUSHi(0) for example. Always refer to this as
&amp;PL_sv_zero. Introduced in 5.28.</p>

<p style="margin-left:17%; margin-top: 1em">SV
PL_sv_zero</p>

<p style="margin-left:11%;">&quot;SAVE_DEFSV&quot;</p>

<p style="margin-left:17%;">Localize $_. See
&quot;Localizing changes&quot; in perlguts.</p>

<p style="margin-left:17%; margin-top: 1em">void
SAVE_DEFSV</p>

<p style="margin-left:11%;">&quot;sortsv&quot;</p>

<p style="margin-left:17%;">In-place sort an array of
<small>SV</small> pointers with the given comparison
routine.</p>

<p style="margin-left:17%; margin-top: 1em">Currently this
always uses mergesort. See &quot;sortsv_flags&quot; for a
more flexible routine.</p>

<p style="margin-left:17%; margin-top: 1em">void
sortsv(SV** array, size_t num_elts, SVCOMPARE_t cmp)</p>

<p style="margin-left:11%;">&quot;sortsv_flags&quot;</p>

<p style="margin-left:17%;">In-place sort an array of
<small>SV</small> pointers with the given comparison
routine, with various SORTf_* flag options.</p>

<p style="margin-left:17%; margin-top: 1em">void
sortsv_flags(SV** array, size_t num_elts, SVCOMPARE_t cmp,
<br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;SV&quot;</p>

<p style="margin-left:17%;">Described in perlguts.</p>

<p style="margin-left:11%;">&quot;sv_2cv&quot;</p>

<p style="margin-left:17%;">Using various gambits, try to
get a <small>CV</small> from an <small>SV</small> ; in
addition, try if possible to set *st and *gvp to the stash
and <small>GV</small> associated with it. The flags in
&quot;lref&quot; are passed to &quot;gv_fetchsv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">CV* sv_2cv(SV*
sv, HV **const st, GV **const gvp, const I32 lref)</p>

<p style="margin-left:11%;">&quot;sv_2io&quot;</p>

<p style="margin-left:17%;">Using various gambits, try to
get an <small>IO</small> from an <small>SV:</small> the
<small>IO</small> slot if its a <small>GV</small> ; or the
recursive result if we&rsquo;re an <small>RV</small> ; or
the <small>IO</small> slot of the symbol named after the
<small>PV</small> if we&rsquo;re a string.</p>


<p style="margin-left:17%; margin-top: 1em">&rsquo;Get&rsquo;
magic is ignored on the &quot;sv&quot; passed in, but will
be called on &quot;SvRV(sv)&quot; if &quot;sv&quot; is an
<small>RV.</small></p>

<p style="margin-left:17%; margin-top: 1em">IO* sv_2io(SV
*const sv)</p>

<p style="margin-left:11%;">&quot;sv_2iv_flags&quot;</p>

<p style="margin-left:17%;">Return the integer value of an
<small>SV,</small> doing any necessary string conversion. If
&quot;flags&quot; has the &quot;SV_GMAGIC&quot; bit set,
does an &quot;mg_get()&quot; first. Normally used via the
&quot;SvIV(sv)&quot; and &quot;SvIVx(sv)&quot; macros.</p>

<p style="margin-left:17%; margin-top: 1em">IV
sv_2iv_flags(SV *const sv, const I32 flags)</p>

<p style="margin-left:11%;">&quot;sv_2mortal&quot;</p>

<p style="margin-left:17%;">Marks an existing
<small>SV</small> as mortal. The <small>SV</small> will be
destroyed &quot;soon&quot;, either by an explicit call to
&quot;FREETMPS&quot;, or by an implicit call at places such
as statement boundaries. &quot;SvTEMP()&quot; is turned on
which means that the <small>SV</small> &rsquo;s string
buffer can be &quot;stolen&quot; if this <small>SV</small>
is copied. See also &quot;sv_newmortal&quot; and
&quot;sv_mortalcopy&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_2mortal(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_2nv_flags&quot;</p>

<p style="margin-left:17%;">Return the num value of an
<small>SV,</small> doing any necessary string or integer
conversion. If &quot;flags&quot; has the
&quot;SV_GMAGIC&quot; bit set, does an &quot;mg_get()&quot;
first. Normally used via the &quot;SvNV(sv)&quot; and
&quot;SvNVx(sv)&quot; macros.</p>

<p style="margin-left:17%; margin-top: 1em">NV
sv_2nv_flags(SV *const sv, const I32 flags)</p>

<p style="margin-left:11%;">&quot;sv_2pv&quot; <br>
&quot;sv_2pv_flags&quot;</p>

<p style="margin-left:17%;">These implement the various
forms of the &quot;&quot;SvPV&quot;&quot; in perlapi macros.
The macros are the preferred interface.</p>

<p style="margin-left:17%; margin-top: 1em">These return a
pointer to the string value of an <small>SV</small>
(coercing it to a string if necessary), and set *lp to its
length in bytes.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in that plain &quot;sv_2pvbyte&quot; always processes
&rsquo;get&rsquo; magic; and &quot;sv_2pvbyte_flags&quot;
processes &rsquo;get&rsquo; magic if and only if
&quot;flags&quot; contains &quot;SV_GMAGIC&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char* sv_2pv
(SV *sv, STRLEN *lp) <br>
char* sv_2pv_flags(SV *const sv, STRLEN *const lp, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_2pvbyte&quot; <br>
&quot;sv_2pvbyte_flags&quot;</p>

<p style="margin-left:17%;">These implement the various
forms of the &quot;&quot;SvPVbyte&quot;&quot; in perlapi
macros. The macros are the preferred interface.</p>

<p style="margin-left:17%; margin-top: 1em">These return a
pointer to the byte-encoded representation of the
<small>SV,</small> and set *lp to its length. If the
<small>SV</small> is marked as being encoded as
<small>UTF&minus;8,</small> it will be downgraded, if
possible, to a byte string. If the <small>SV</small> cannot
be downgraded, they croak.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in that plain &quot;sv_2pvbyte&quot; always processes
&rsquo;get&rsquo; magic; and &quot;sv_2pvbyte_flags&quot;
processes &rsquo;get&rsquo; magic if and only if
&quot;flags&quot; contains &quot;SV_GMAGIC&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_2pvbyte (SV *sv, STRLEN *const lp) <br>
char* sv_2pvbyte_flags(SV *sv, STRLEN *const lp, const U32
flags)</p>

<p style="margin-left:11%;">&quot;sv_2pvutf8&quot; <br>
&quot;sv_2pvutf8_flags&quot;</p>

<p style="margin-left:17%;">These implement the various
forms of the &quot;&quot;SvPVutf8&quot;&quot; in perlapi
macros. The macros are the preferred interface.</p>

<p style="margin-left:17%; margin-top: 1em">These return a
pointer to the UTF&minus;8&minus;encoded representation of
the <small>SV,</small> and set *lp to its length in bytes.
They may cause the <small>SV</small> to be upgraded to
<small>UTF&minus;8</small> as a side-effect.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in that plain &quot;sv_2pvutf8&quot; always processes
&rsquo;get&rsquo; magic; and &quot;sv_2pvutf8_flags&quot;
processes &rsquo;get&rsquo; magic if and only if
&quot;flags&quot; contains &quot;SV_GMAGIC&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_2pvutf8 (SV *sv, STRLEN *const lp) <br>
char* sv_2pvutf8_flags(SV *sv, STRLEN *const lp, const U32
flags)</p>

<p style="margin-left:11%;">&quot;sv_2uv_flags&quot;</p>

<p style="margin-left:17%;">Return the unsigned integer
value of an <small>SV,</small> doing any necessary string
conversion. If &quot;flags&quot; has the
&quot;SV_GMAGIC&quot; bit set, does an &quot;mg_get()&quot;
first. Normally used via the &quot;SvUV(sv)&quot; and
&quot;SvUVx(sv)&quot; macros.</p>

<p style="margin-left:17%; margin-top: 1em">UV
sv_2uv_flags(SV *const sv, const I32 flags)</p>

<p style="margin-left:11%;">&quot;SvAMAGIC&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
&quot;sv&quot; has overloading (active magic) enabled or
not.</p>

<p style="margin-left:17%; margin-top: 1em">bool
SvAMAGIC(SV * sv)</p>

<p style="margin-left:11%;">&quot;sv_backoff&quot;</p>

<p style="margin-left:17%;">Remove any string offset. You
should normally use the &quot;SvOOK_off&quot; macro wrapper
instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_backoff(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_bless&quot;</p>

<p style="margin-left:17%;">Blesses an <small>SV</small>
into a specified package. The <small>SV</small> must be an
<small>RV.</small> The package must be designated by its
stash (see &quot;gv_stashpv&quot;). The reference count of
the <small>SV</small> is unaffected.</p>

<p style="margin-left:17%; margin-top: 1em">SV* sv_bless(SV
*const sv, HV *const stash)</p>

<p style="margin-left:11%;">&quot;sv_catpv&quot; <br>
&quot;sv_catpv_flags&quot; <br>
&quot;sv_catpv_mg&quot; <br>
&quot;sv_catpv_nomg&quot;</p>

<p style="margin-left:17%;">These concatenate the
&quot;NUL&quot;&minus;terminated string &quot;sstr&quot;
onto the end of the string which is in the
<small>SV.</small> If the <small>SV</small> has the
<small>UTF&minus;8</small> status set, then the bytes
appended should be valid <small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in how they handle magic:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpv_mg&quot;
performs both &rsquo;get&rsquo; and &rsquo;set&rsquo;
magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpv&quot;
performs only &rsquo;get&rsquo; magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpv_nomg&quot;
skips all magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpv_flags&quot;
has an extra &quot;flags&quot; parameter which allows you to
specify any combination of magic handling (using
&quot;SV_GMAGIC&quot; and/or &quot;SV_SMAGIC&quot;), and to
also override the <small>UTF&minus;8</small> handling. By
supplying the &quot;SV_CATUTF8&quot; flag, the appended
string is forced to be interpreted as
<small>UTF&minus;8</small> ; by supplying instead the
&quot;SV_CATBYTES&quot; flag, it will be interpreted as just
bytes. Either the <small>SV</small> or the string appended
will be upgraded to <small>UTF&minus;8</small> if
necessary.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_catpv
(SV *const dsv, const char* sstr) <br>
void sv_catpv_flags(SV *dsv, const char *sstr, const I32
flags) <br>
void sv_catpv_mg (SV *const dsv, const char *const sstr)
<br>
void sv_catpv_nomg (SV *const dsv, const char* sstr)</p>

<p style="margin-left:11%;">&quot;sv_catpvf&quot; <br>
&quot;sv_catpvf_nocontext&quot; <br>
&quot;sv_catpvf_mg&quot; <br>
&quot;sv_catpvf_mg_nocontext&quot;</p>

<p style="margin-left:17%;">These process their arguments
like &quot;sprintf&quot;, and append the formatted output to
an <small>SV.</small> As with &quot;sv_vcatpvfn&quot;,
argument reordering is not supporte when called with a
non-null C&minus;style variable argument list.</p>

<p style="margin-left:17%; margin-top: 1em">If the appended
data contains &quot;wide&quot; characters (including, but
not limited to, SVs with a <small>UTF&minus;8 PV</small>
formatted with %s, and characters &gt;255 formatted with
%c), the original <small>SV</small> might get upgraded to
<small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">If the original
<small>SV</small> was <small>UTF&minus;8,</small> the
pattern should be valid <small>UTF&minus;8</small> ; if the
original <small>SV</small> was bytes, the pattern should be
too.</p>

<p style="margin-left:17%; margin-top: 1em">All perform
&rsquo;get&rsquo; magic, but only &quot;sv_catpvf_mg&quot;
and &quot;sv_catpvf_mg_nocontext&quot; perform
&rsquo;set&rsquo; magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpvf_nocontext&quot;
and &quot;sv_catpvf_mg_nocontext&quot; do not take a thread
context (&quot;aTHX&quot;) parameter, so are used in
situations where the caller doesn&rsquo;t already have the
thread context.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;sv_catpvf&quot; must be explicitly called as
&quot;Perl_sv_catpvf&quot; with an &quot;aTHX_&quot;
parameter.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;sv_catpvf_mg&quot; must be explicitly called as
&quot;Perl_sv_catpvf_mg&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_sv_catpvf (pTHX_ SV *const sv, <br>
const char *const pat, ...) <br>
void sv_catpvf_nocontext (SV *const sv, const char *const
pat, <br>
...) <br>
void Perl_sv_catpvf_mg (pTHX_ SV *const sv, <br>
const char *const pat, ...) <br>
void sv_catpvf_mg_nocontext(SV *const sv, const char *const
pat, <br>
...)</p>

<p style="margin-left:11%;">&quot;sv_catpvn&quot; <br>
&quot;sv_catpvn_flags&quot; <br>
&quot;sv_catpvn_mg&quot; <br>
&quot;sv_catpvn_nomg&quot;</p>

<p style="margin-left:17%;">These concatenate the
&quot;len&quot; bytes of the string beginning at
&quot;ptr&quot; onto the end of the string which is in
&quot;dsv&quot;. The caller must make sure &quot;ptr&quot;
contains at least &quot;len&quot; bytes.</p>

<p style="margin-left:17%; margin-top: 1em">For all but
&quot;sv_catpvn_flags&quot;, the string appended is assumed
to be valid <small>UTF&minus;8</small> if the
<small>SV</small> has the <small>UTF&minus;8</small> status
set, and a string of bytes otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">They differ in
that:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpvn_mg&quot;
performs both &rsquo;get&rsquo; and &rsquo;set&rsquo; magic
on &quot;dsv&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpvn&quot;
performs only &rsquo;get&rsquo; magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpvn_nomg&quot;
skips all magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpvn_flags&quot;
has an extra &quot;flags&quot; parameter which allows you to
specify any combination of magic handling (using
&quot;SV_GMAGIC&quot; and/or &quot;SV_SMAGIC&quot;) and to
also override the <small>UTF&minus;8</small> handling. By
supplying the &quot;SV_CATBYTES&quot; flag, the appended
string is interpreted as plain bytes; by supplying instead
the &quot;SV_CATUTF8&quot; flag, it will be interpreted as
<small>UTF&minus;8,</small> and the &quot;dsv&quot; will be
upgraded to <small>UTF&minus;8</small> if necessary.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catpvn&quot;,
&quot;sv_catpvn_mg&quot;, and &quot;sv_catpvn_nomg&quot; are
implemented in terms of &quot;sv_catpvn_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_catpvn
(SV *dsv, const char *sstr, STRLEN len) <br>
void sv_catpvn_flags(SV *const dsv, const char *sstr, <br>
const STRLEN len, const I32 flags) <br>
void sv_catpvn_mg (SV *dsv, const char *sstr, STRLEN len)
<br>
void sv_catpvn_nomg (SV *dsv, const char *sstr, STRLEN
len)</p>

<p style="margin-left:11%;">&quot;sv_catpvs&quot;</p>

<p style="margin-left:17%;">Like &quot;sv_catpvn&quot;, but
takes a literal string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_catpvs(SV* sv, &quot;literal string&quot;)</p>


<p style="margin-left:11%;">&quot;sv_catpvs_flags&quot;</p>

<p style="margin-left:17%;">Like
&quot;sv_catpvn_flags&quot;, but takes a literal string
instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_catpvs_flags(SV* sv, &quot;literal string&quot;, I32
flags)</p>

<p style="margin-left:11%;">&quot;sv_catpvs_mg&quot;</p>

<p style="margin-left:17%;">Like &quot;sv_catpvn_mg&quot;,
but takes a literal string instead of a string/length
pair.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_catpvs_mg(SV* sv, &quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;sv_catpvs_nomg&quot;</p>

<p style="margin-left:17%;">Like
&quot;sv_catpvn_nomg&quot;, but takes a literal string
instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_catpvs_nomg(SV* sv, &quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;sv_catsv&quot; <br>
&quot;sv_catsv_flags&quot; <br>
&quot;sv_catsv_mg&quot; <br>
&quot;sv_catsv_nomg&quot;</p>

<p style="margin-left:17%;">These concatenate the string
from <small>SV</small> &quot;sstr&quot; onto the end of the
string in <small>SV</small> &quot;dsv&quot;. If
&quot;sstr&quot; is null, these are no-ops; otherwise only
&quot;dsv&quot; is modified.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in what magic they perform:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catsv_mg&quot;
performs &rsquo;get&rsquo; magic on both SVs before the
copy, and &rsquo;set&rsquo; magic on &quot;dsv&quot;
afterwards.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catsv&quot;
performs just &rsquo;get&rsquo; magic, on both SVs.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catsv_nomg&quot;
skips all magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catsv_flags&quot;
has an extra &quot;flags&quot; parameter which allows you to
use &quot;SV_GMAGIC&quot; and/or &quot;SV_SMAGIC&quot; to
specify any combination of magic handling (although either
both or neither <small>SV</small> will have
&rsquo;get&rsquo; magic applied to it.)</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_catsv&quot;,
&quot;sv_catsv_mg&quot;, and &quot;sv_catsv_nomg&quot; are
implemented in terms of &quot;sv_catsv_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_catsv
(SV *dsv, SV *sstr) <br>
void sv_catsv_flags(SV *const dsv, SV *const sstr, <br>
const I32 flags) <br>
void sv_catsv_mg (SV *dsv, SV *sstr) <br>
void sv_catsv_nomg (SV *dsv, SV *sstr)</p>

<p style="margin-left:11%;">&quot;sv_chop&quot;</p>

<p style="margin-left:17%;">Efficient removal of characters
from the beginning of the string buffer.
&quot;SvPOK(sv)&quot;, or at least &quot;SvPOKp(sv)&quot;,
must be true and &quot;ptr&quot; must be a pointer to
somewhere inside the string buffer. &quot;ptr&quot; becomes
the first character of the adjusted string. Uses the
&quot;OOK&quot; hack. On return, only &quot;SvPOK(sv)&quot;
and &quot;SvPOKp(sv)&quot; among the &quot;OK&quot; flags
will be true.</p>

<p style="margin-left:17%; margin-top: 1em">Beware: after
this function returns, &quot;ptr&quot; and SvPVX_const(sv)
may no longer refer to the same chunk of data.</p>

<p style="margin-left:17%; margin-top: 1em">The unfortunate
similarity of this function&rsquo;s name to that of
Perl&rsquo;s &quot;chop&quot; operator is strictly
coincidental. This function works from the left;
&quot;chop&quot; works from the right.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_chop(SV
*const sv, const char *const ptr)</p>

<p style="margin-left:11%;">&quot;sv_clear&quot;</p>

<p style="margin-left:17%;">Clear an <small>SV:</small>
call any destructors, free up any memory used by the body,
and free the body itself. The <small>SV</small> &rsquo;s
head is <i>not</i> freed, although its type is set to all
1&rsquo;s so that it won&rsquo;t inadvertently be assumed to
be live during global destruction etc. This function should
only be called when &quot;REFCNT&quot; is zero. Most of the
time you&rsquo;ll want to call &quot;sv_free()&quot; (or its
macro wrapper &quot;SvREFCNT_dec&quot;) instead.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_clear(SV *const orig_sv)</p>

<p style="margin-left:11%;">&quot;sv_cmp&quot;</p>

<p style="margin-left:17%;">Compares the strings in two
SVs. Returns &minus;1, 0, or 1 indicating whether the string
in &quot;sv1&quot; is less than, equal to, or greater than
the string in &quot;sv2&quot;. Is <small>UTF&minus;8</small>
and 'use&nbsp;bytes' aware, handles get magic, and will
coerce its args to strings if necessary. See also
&quot;sv_cmp_locale&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32 sv_cmp(SV
*const sv1, SV *const sv2)</p>

<p style="margin-left:11%;">&quot;sv_cmp_flags&quot;</p>

<p style="margin-left:17%;">Compares the strings in two
SVs. Returns &minus;1, 0, or 1 indicating whether the string
in &quot;sv1&quot; is less than, equal to, or greater than
the string in &quot;sv2&quot;. Is <small>UTF&minus;8</small>
and 'use&nbsp;bytes' aware and will coerce its args to
strings if necessary. If the flags has the
&quot;SV_GMAGIC&quot; bit set, it handles get magic. See
also &quot;sv_cmp_locale_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32
sv_cmp_flags(SV *const sv1, SV *const sv2, const U32
flags)</p>

<p style="margin-left:11%;">&quot;sv_cmp_locale&quot;</p>

<p style="margin-left:17%;">Compares the strings in two SVs
in a locale-aware manner. Is <small>UTF&minus;8</small> and
'use&nbsp;bytes' aware, handles get magic, and will coerce
its args to strings if necessary. See also
&quot;sv_cmp&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32
sv_cmp_locale(SV *const sv1, SV *const sv2)</p>


<p style="margin-left:11%;">&quot;sv_cmp_locale_flags&quot;</p>

<p style="margin-left:17%;">Compares the strings in two SVs
in a locale-aware manner. Is <small>UTF&minus;8</small> and
'use&nbsp;bytes' aware and will coerce its args to strings
if necessary. If the flags contain &quot;SV_GMAGIC&quot;, it
handles get magic. See also &quot;sv_cmp_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32
sv_cmp_locale_flags(SV *const sv1, SV *const sv2, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_collxfrm&quot;</p>

<p style="margin-left:17%;">This calls
&quot;sv_collxfrm_flags&quot; with the
<small>SV_GMAGIC</small> flag. See
&quot;sv_collxfrm_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_collxfrm(SV *const sv, STRLEN *const nxp)</p>


<p style="margin-left:11%;">&quot;sv_collxfrm_flags&quot;</p>

<p style="margin-left:17%;">Add Collate Transform magic to
an <small>SV</small> if it doesn&rsquo;t already have it. If
the flags contain &quot;SV_GMAGIC&quot;, it handles
get-magic.</p>

<p style="margin-left:17%; margin-top: 1em">Any scalar
variable may carry &quot;PERL_MAGIC_collxfrm&quot; magic
that contains the scalar data of the variable, but
transformed to such a format that a normal memory comparison
can be used to compare the data according to the locale
settings.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_collxfrm_flags(SV *const sv, STRLEN *const nxp, <br>
I32 const flags)</p>

<p style="margin-left:11%;">&quot;sv_copypv&quot; <br>
&quot;sv_copypv_nomg&quot; <br>
&quot;sv_copypv_flags&quot;</p>

<p style="margin-left:17%;">These copy a stringified
representation of the source <small>SV</small> into the
destination <small>SV.</small> They automatically perform
coercion of numeric values into strings. Guaranteed to
preserve the &quot;UTF8&quot; flag even from overloaded
objects. Similar in nature to &quot;sv_2pv[_flags]&quot; but
they operate directly on an <small>SV</small> instead of
just the string. Mostly they use
&quot;&quot;sv_2pv_flags&quot;&quot; to do the work, except
when that would lose the <small>UTF&minus;8</small>
&rsquo;ness of the <small>PV.</small></p>

<p style="margin-left:17%; margin-top: 1em">The three forms
differ only in whether or not they perform &rsquo;get
magic&rsquo; on &quot;sv&quot;. &quot;sv_copypv_nomg&quot;
skips &rsquo;get magic&rsquo;; &quot;sv_copypv&quot;
performs it; and &quot;sv_copypv_flags&quot; either performs
it (if the &quot;SV_GMAGIC&quot; bit is set in
&quot;flags&quot;) or doesn&rsquo;t (if that bit is
cleared).</p>

<p style="margin-left:17%; margin-top: 1em">void sv_copypv
(SV *const dsv, SV *const ssv) <br>
void sv_copypv_nomg (SV *const dsv, SV *const ssv) <br>
void sv_copypv_flags(SV *const dsv, SV *const ssv, <br>
const I32 flags)</p>

<p style="margin-left:11%;">&quot;SvCUR&quot;</p>

<p style="margin-left:17%;">Returns the length, in bytes,
of the <small>PV</small> inside the <small>SV.</small> Note
that this may not match Perl&rsquo;s &quot;length&quot;; for
that, use &quot;sv_len_utf8(sv)&quot;. See &quot;SvLEN&quot;
also.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
SvCUR(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvCUR_set&quot;</p>

<p style="margin-left:17%;">Sets the current length, in
bytes, of the C string which is in the <small>SV.</small>
See &quot;SvCUR&quot; and &quot;SvIV_set&quot;&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvCUR_set(SV* sv, STRLEN len)</p>

<p style="margin-left:11%;">&quot;sv_dec&quot; <br>
&quot;sv_dec_nomg&quot;</p>

<p style="margin-left:17%;">These auto-decrement the value
in the <small>SV,</small> doing string to numeric conversion
if necessary. They both handle operator overloading.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_dec&quot;
handles &rsquo;get&rsquo; magic; &quot;sv_dec_nomg&quot;
skips &rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_dec(SV
*const sv)</p>


<p style="margin-left:11%;">&quot;sv_derived_from&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;sv_derived_from_pv&quot;, but doesn&rsquo;t take a
&quot;flags&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_derived_from(SV* sv, const char *const name)</p>


<p style="margin-left:11%;">&quot;sv_derived_from_pv&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;sv_derived_from_pvn&quot;, but takes a nul-terminated
string instead of a string/length pair.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_derived_from_pv(SV* sv, const char *const name, <br>
U32 flags)</p>


<p style="margin-left:11%;">&quot;sv_derived_from_pvn&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> is derived from the specified
class <i>at the C level</i>. To check derivation at the Perl
level, call &quot;isa()&quot; as a normal Perl method.</p>

<p style="margin-left:17%; margin-top: 1em">Currently, the
only significant value for &quot;flags&quot; is
SVf_UTF8.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_derived_from_pvn(SV* sv, const char *const name, <br>
const STRLEN len, U32 flags)</p>


<p style="margin-left:11%;">&quot;sv_derived_from_sv&quot;</p>

<p style="margin-left:17%;">Exactly like
&quot;sv_derived_from_pvn&quot;, but takes the name string
in the form of an <small>SV</small> instead of a
string/length pair. This is the advised form.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_derived_from_sv(SV* sv, SV *namesv, U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_does&quot;</p>

<p style="margin-left:17%;">Like &quot;sv_does_pv&quot;,
but doesn&rsquo;t take a &quot;flags&quot; parameter.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_does(SV* sv, const char *const name)</p>

<p style="margin-left:11%;">&quot;sv_does_pv&quot;</p>

<p style="margin-left:17%;">Like &quot;sv_does_sv&quot;,
but takes a nul-terminated string instead of an
<small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_does_pv(SV* sv, const char *const name, U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_does_pvn&quot;</p>

<p style="margin-left:17%;">Like &quot;sv_does_sv&quot;,
but takes a string/length pair instead of an
<small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_does_pvn(SV* sv, const char *const name, <br>
const STRLEN len, U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_does_sv&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> performs a specific, named
role. The <small>SV</small> can be a Perl object or the name
of a Perl class.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_does_sv(SV* sv, SV* namesv, U32 flags)</p>

<p style="margin-left:11%;">&quot;SvEND&quot;</p>

<p style="margin-left:17%;">Returns a pointer to the spot
just after the last character in the string which is in the
<small>SV,</small> where there is usually a trailing
&quot;NUL&quot; character (even though Perl scalars do not
strictly require it). See &quot;SvCUR&quot;. Access the
character as &quot;*(SvEND(sv))&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Warning: If
&quot;SvCUR&quot; is equal to &quot;SvLEN&quot;, then
&quot;SvEND&quot; points to unallocated memory.</p>

<p style="margin-left:17%; margin-top: 1em">char* SvEND(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_eq&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the strings in the two SVs are identical. Is
<small>UTF&minus;8</small> and 'use&nbsp;bytes' aware,
handles get magic, and will coerce its args to strings if
necessary.</p>

<p style="margin-left:17%; margin-top: 1em">This function
does not handle operator overloading. For a version that
does, see instead &quot;sv_streq&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32 sv_eq(SV*
sv1, SV* sv2)</p>

<p style="margin-left:11%;">&quot;sv_eq_flags&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the strings in the two SVs are identical. Is
<small>UTF&minus;8</small> and 'use&nbsp;bytes' aware and
coerces its args to strings if necessary. If the flags has
the &quot;SV_GMAGIC&quot; bit set, it handles get-magic,
too.</p>

<p style="margin-left:17%; margin-top: 1em">This function
does not handle operator overloading. For a version that
does, see instead &quot;sv_streq_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">I32
sv_eq_flags(SV* sv1, SV* sv2, const U32 flags)</p>


<p style="margin-left:11%;">&quot;sv_force_normal&quot;</p>

<p style="margin-left:17%;">Undo various types of fakery on
an <small>SV:</small> if the <small>PV</small> is a shared
string, make a private copy; if we&rsquo;re a ref, stop
refing; if we&rsquo;re a glob, downgrade to an
&quot;xpvmg&quot;. See also
&quot;sv_force_normal_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_force_normal(SV *sv)</p>


<p style="margin-left:11%;">&quot;sv_force_normal_flags&quot;</p>

<p style="margin-left:17%;">Undo various types of fakery on
an <small>SV,</small> where fakery means &quot;more
than&quot; a string: if the <small>PV</small> is a shared
string, make a private copy; if we&rsquo;re a ref, stop
refing; if we&rsquo;re a glob, downgrade to an
&quot;xpvmg&quot;; if we&rsquo;re a copy-on-write scalar,
this is the on-write time when we do the copy, and is also
used locally; if this is a vstring, drop the vstring magic.
If &quot;SV_COW_DROP_PV&quot; is set then a copy-on-write
scalar drops its <small>PV</small> buffer (if any) and
becomes &quot;SvPOK_off&quot; rather than making a copy.
(Used where this scalar is about to be set to some other
value.) In addition, the &quot;flags&quot; parameter gets
passed to &quot;sv_unref_flags()&quot; when unreffing.
&quot;sv_force_normal&quot; calls this function with flags
set to 0.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is expected to be used to signal to perl that this
<small>SV</small> is about to be written to, and any extra
book-keeping needs to be taken care of. Hence, it croaks on
read-only values.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_force_normal_flags(SV *const sv, const U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_free&quot;</p>

<p style="margin-left:17%;">Decrement an <small>SV</small>
&rsquo;s reference count, and if it drops to zero, call
&quot;sv_clear&quot; to invoke destructors and free up any
memory used by the body; finally, deallocating the
<small>SV</small> &rsquo;s head itself. Normally called via
a wrapper macro &quot;SvREFCNT_dec&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_free(SV
*const sv)</p>

<p style="margin-left:11%;">&quot;SvGAMAGIC&quot;</p>

<p style="margin-left:17%;">Returns true if the
<small>SV</small> has get magic or overloading. If either is
true then the scalar is active data, and has the potential
to return a new value every time it is accessed. Hence you
must be careful to only read it once per user logical
operation and work with that returned value. If neither is
true then the scalar&rsquo;s value cannot change unless
written to.</p>

<p style="margin-left:17%; margin-top: 1em">U32
SvGAMAGIC(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvGETMAGIC&quot;</p>

<p style="margin-left:17%;">Invokes &quot;mg_get&quot; on
an <small>SV</small> if it has &rsquo;get&rsquo; magic. For
example, this will call &quot;FETCH&quot; on a tied
variable. This macro evaluates its argument more than
once.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvGETMAGIC(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_gets&quot;</p>

<p style="margin-left:17%;">Get a line from the filehandle
and store it into the <small>SV,</small> optionally
appending to the currently-stored string. If
&quot;append&quot; is not 0, the line is appended to the
<small>SV</small> instead of overwriting it.
&quot;append&quot; should be set to the byte offset that the
appended string should start at in the <small>SV</small>
(typically, &quot;SvCUR(sv)&quot; is a suitable choice).</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_gets(SV *const sv, PerlIO *const fp, I32 append)</p>


<p style="margin-left:11%;">&quot;sv_get_backrefs&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;sv_get_backrefs&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;sv&quot; is the target of a weak reference then it
returns the back references structure associated with the
sv; otherwise return &quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">When returning
a non-null result the type of the return is relevant. If it
is an <small>AV</small> then the elements of the
<small>AV</small> are the weak reference RVs which point at
this item. If it is any other type then the item itself is
the weak reference.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;Perl_sv_add_backref()&quot;,
&quot;Perl_sv_del_backref()&quot;,
&quot;Perl_sv_kill_backrefs()&quot;</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_get_backrefs(SV *const sv)</p>

<p style="margin-left:11%;">&quot;SvGROW&quot;</p>

<p style="margin-left:17%;">Expands the character buffer in
the <small>SV</small> so that it has room for the indicated
number of bytes (remember to reserve space for an extra
trailing &quot;NUL&quot; character). Calls
&quot;sv_grow&quot; to perform the expansion if necessary.
Returns a pointer to the character buffer. <small>SV</small>
must be of type &gt;= &quot;SVt_PV&quot;. One alternative is
to call &quot;sv_grow&quot; if you are not sure of the type
of <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">You might
mistakenly think that &quot;len&quot; is the number of bytes
to add to the existing size, but instead it is the total
size &quot;sv&quot; should be.</p>

<p style="margin-left:17%; margin-top: 1em">char *
SvGROW(SV* sv, STRLEN len)</p>

<p style="margin-left:11%;">&quot;sv_inc&quot; <br>
&quot;sv_inc_nomg&quot;</p>

<p style="margin-left:17%;">These auto-increment the value
in the <small>SV,</small> doing string to numeric conversion
if necessary. They both handle operator overloading.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;sv_inc&quot; performs &rsquo;get&rsquo;
magic; &quot;sv_inc_nomg&quot; skips any magic.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_inc(SV
*const sv)</p>

<p style="margin-left:11%;">&quot;sv_insert&quot;</p>

<p style="margin-left:17%;">Inserts and/or replaces a
string at the specified offset/length within the
<small>SV.</small> Similar to the Perl &quot;substr()&quot;
function, with &quot;littlelen&quot; bytes starting at
&quot;little&quot; replacing &quot;len&quot; bytes of the
string in &quot;bigstr&quot; starting at &quot;offset&quot;.
Handles get magic.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_insert(SV *const bigstr, const STRLEN offset, <br>
const STRLEN len, const char *const little, <br>
const STRLEN littlelen)</p>


<p style="margin-left:11%;">&quot;sv_insert_flags&quot;</p>

<p style="margin-left:17%;">Same as &quot;sv_insert&quot;,
but the extra &quot;flags&quot; are passed to the
&quot;SvPV_force_flags&quot; that applies to
&quot;bigstr&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_insert_flags(SV *const bigstr, const STRLEN offset, <br>
const STRLEN len, const char *little, <br>
const STRLEN littlelen, const U32 flags)</p>

<p style="margin-left:11%;">&quot;SvIOK&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> contains an integer.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvIOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvIOK_notUV&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> contains a signed integer.</p>

<p style="margin-left:17%; margin-top: 1em">bool
SvIOK_notUV(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvIOK_off&quot;</p>

<p style="margin-left:17%;">Unsets the <small>IV</small>
status of an <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
SvIOK_off(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvIOK_on&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is an integer.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvIOK_on(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvIOK_only&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is an integer and disables all other &quot;OK&quot;
bits.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvIOK_only(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvIOK_only_UV&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is an unsigned integer and disables all other
&quot;OK&quot; bits.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvIOK_only_UV(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvIOKp&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> contains an integer. Checks
the <b>private</b> setting. Use &quot;SvIOK&quot;
instead.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvIOKp(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvIOK_UV&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> contains an integer that must
be interpreted as unsigned. A non-negative integer whose
value is within the range of both an <small>IV</small> and a
<small>UV</small> may be flagged as either &quot;SvUOK&quot;
or &quot;SvIOK&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
SvIOK_UV(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_isa&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> is blessed into the specified
class.</p>

<p style="margin-left:17%; margin-top: 1em">This does not
check for subtypes or method overloading. Use
&quot;sv_isa_sv&quot; to verify an inheritance relationship
in the same way as the &quot;isa&quot; operator by
respecting any &quot;isa()&quot; method overloading; or
&quot;sv_derived_from_sv&quot; to test directly on the
actual object type.</p>

<p style="margin-left:17%; margin-top: 1em">int sv_isa(SV*
sv, const char *const name)</p>

<p style="margin-left:11%;">&quot;sv_isa_sv&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;sv_isa_sv&quot; is <b>experimental</b> and may change
or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Returns a
boolean indicating whether the <small>SV</small> is an
object reference and is derived from the specified class,
respecting any &quot;isa()&quot; method overloading it may
have. Returns false if &quot;sv&quot; is not a reference to
an object, or is not derived from the specified class.</p>

<p style="margin-left:17%; margin-top: 1em">This is the
function used to implement the behaviour of the
&quot;isa&quot; operator.</p>

<p style="margin-left:17%; margin-top: 1em">Does not invoke
magic on &quot;sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Not to be
confused with the older &quot;sv_isa&quot; function, which
does not use an overloaded &quot;isa()&quot; method, nor
will check subclassing.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_isa_sv(SV* sv, SV* namesv)</p>

<p style="margin-left:11%;">&quot;SvIsBOOL&quot;</p>

<p style="margin-left:17%;">Returns true if the
<small>SV</small> is one of the special boolean constants
(PL_sv_yes or PL_sv_no), or is a regular <small>SV</small>
whose last assignment stored a copy of one.</p>

<p style="margin-left:17%; margin-top: 1em">bool
SvIsBOOL(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvIsCOW&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> is Copy-On-Write (either
shared hash key scalars, or full Copy On Write scalars if
5.9.0 is configured for <small>COW</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvIsCOW(SV*
sv)</p>


<p style="margin-left:11%;">&quot;SvIsCOW_shared_hash&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> is Copy-On-Write shared hash
key scalar.</p>

<p style="margin-left:17%; margin-top: 1em">bool
SvIsCOW_shared_hash(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_isobject&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> is an <small>RV</small>
pointing to a blessed object. If the <small>SV</small> is
not an <small>RV,</small> or if the object is not blessed,
then this will return false.</p>

<p style="margin-left:17%; margin-top: 1em">int
sv_isobject(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvIV&quot; <br>
&quot;SvIVx&quot; <br>
&quot;SvIV_nomg&quot;</p>

<p style="margin-left:17%;">These coerce the given
<small>SV</small> to <small>IV</small> and return it. The
returned value in many circumstances will get stored in
&quot;sv&quot;&rsquo;s <small>IV</small> slot, but not in
all cases. (Use &quot;sv_setiv&quot; to make sure it
does).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvIVx&quot;
is different from the others in that it is guaranteed to
evaluate &quot;sv&quot; exactly once; the others may
evaluate it multiple times. Only use this form if
&quot;sv&quot; is an expression with side effects, otherwise
use the more efficient &quot;SvIV&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvIV_nomg&quot;
is the same as &quot;SvIV&quot;, but does not perform
&rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">IV SvIV(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvIV_set&quot;</p>

<p style="margin-left:17%;">Set the value of the
<small>IV</small> pointer in sv to val. It is possible to
perform the same function of this macro with an lvalue
assignment to &quot;SvIVX&quot;. With future Perls, however,
it will be more efficient to use &quot;SvIV_set&quot;
instead of the lvalue assignment to &quot;SvIVX&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvIV_set(SV* sv, IV val)</p>

<p style="margin-left:11%;">&quot;SvIVX&quot;</p>

<p style="margin-left:17%;">Returns the raw value in the
<small>SV</small> &rsquo;s <small>IV</small> slot, without
checks or conversions. Only use when you are sure
&quot;SvIOK&quot; is true. See also &quot;SvIV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">IV SvIVX(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvLEN&quot;</p>

<p style="margin-left:17%;">Returns the size of the string
buffer in the <small>SV,</small> not including any part
attributable to &quot;SvOOK&quot;. See
&quot;SvCUR&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
SvLEN(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_len&quot;</p>

<p style="margin-left:17%;">Returns the length of the
string in the <small>SV.</small> Handles magic and type
coercion and sets the <small>UTF8</small> flag
appropriately. See also &quot;SvCUR&quot;, which gives raw
access to the &quot;xpv_cur&quot; slot.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
sv_len(SV *const sv)</p>

<p style="margin-left:11%;">&quot;SvLEN_set&quot;</p>

<p style="margin-left:17%;">Set the size of the string
buffer for the <small>SV.</small> See &quot;SvLEN&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvLEN_set(SV* sv, STRLEN len)</p>

<p style="margin-left:11%;">&quot;sv_len_utf8&quot; <br>
&quot;sv_len_utf8_nomg&quot;</p>

<p style="margin-left:17%;">These return the number of
characters in the string in an <small>SV,</small> counting
wide <small>UTF&minus;8</small> bytes as a single character.
Both handle type coercion. They differ only in that
&quot;sv_len_utf8&quot; performs &rsquo;get&rsquo; magic;
&quot;sv_len_utf8_nomg&quot; skips any magic.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
sv_len_utf8(SV *const sv)</p>

<p style="margin-left:11%;">&quot;SvLOCK&quot;</p>

<p style="margin-left:17%;">Arranges for a mutual exclusion
lock to be obtained on &quot;sv&quot; if a suitable module
has been loaded.</p>

<p style="margin-left:17%; margin-top: 1em">void SvLOCK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_magic&quot;</p>

<p style="margin-left:17%;">Adds magic to an
<small>SV.</small> First upgrades &quot;sv&quot; to type
&quot;SVt_PVMG&quot; if necessary, then adds a new magic
item of type &quot;how&quot; to the head of the magic
list.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;sv_magicext&quot; (which &quot;sv_magic&quot; now
calls) for a description of the handling of the
&quot;name&quot; and &quot;namlen&quot; arguments.</p>

<p style="margin-left:17%; margin-top: 1em">You need to use
&quot;sv_magicext&quot; to add magic to
&quot;SvREADONLY&quot; SVs and also to add more than one
instance of the same &quot;how&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_magic(SV *const sv, SV *const obj, const int how, <br>
const char *const name, const I32 namlen)</p>

<p style="margin-left:11%;">&quot;sv_magicext&quot;</p>

<p style="margin-left:17%;">Adds magic to an
<small>SV,</small> upgrading it if necessary. Applies the
supplied &quot;vtable&quot; and returns a pointer to the
magic added.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;sv_magicext&quot; will allow things that
&quot;sv_magic&quot; will not. In particular, you can add
magic to &quot;SvREADONLY&quot; SVs, and add more than one
instance of the same &quot;how&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;namlen&quot; is greater than zero then a
&quot;savepvn&quot; <i>copy</i> of &quot;name&quot; is
stored, if &quot;namlen&quot; is zero then &quot;name&quot;
is stored as-is and &minus; as another special case &minus;
if &quot;(name &amp;&amp; namlen == HEf_SVKEY)&quot; then
&quot;name&quot; is assumed to contain an SV* and is stored
as-is with its &quot;REFCNT&quot; incremented.</p>

<p style="margin-left:17%; margin-top: 1em">(This is now
used as a subroutine by &quot;sv_magic&quot;.)</p>

<p style="margin-left:17%; margin-top: 1em">MAGIC *
sv_magicext(SV *const sv, SV *const obj, const int how, <br>
const MGVTBL *const vtbl, <br>
const char *const name, const I32 namlen)</p>

<p style="margin-left:11%;">&quot;SvMAGIC_set&quot;</p>

<p style="margin-left:17%;">Set the value of the
<small>MAGIC</small> pointer in &quot;sv&quot; to val. See
&quot;SvIV_set&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvMAGIC_set(SV* sv, MAGIC* val)</p>

<p style="margin-left:11%;">&quot;sv_mortalcopy&quot;</p>

<p style="margin-left:17%;">Creates a new <small>SV</small>
which is a copy of the original <small>SV</small> (using
&quot;sv_setsv&quot;). The new <small>SV</small> is marked
as mortal. It will be destroyed &quot;soon&quot;, either by
an explicit call to &quot;FREETMPS&quot;, or by an implicit
call at places such as statement boundaries. See also
&quot;sv_newmortal&quot; and &quot;sv_2mortal&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_mortalcopy(SV *const oldsv)</p>


<p style="margin-left:11%;">&quot;sv_mortalcopy_flags&quot;</p>

<p style="margin-left:17%;">Like &quot;sv_mortalcopy&quot;,
but the extra &quot;flags&quot; are passed to the
&quot;sv_setsv_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_mortalcopy_flags(SV *const oldsv, U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_newmortal&quot;</p>

<p style="margin-left:17%;">Creates a new null
<small>SV</small> which is mortal. The reference count of
the <small>SV</small> is set to 1. It will be destroyed
&quot;soon&quot;, either by an explicit call to
&quot;FREETMPS&quot;, or by an implicit call at places such
as statement boundaries. See also &quot;sv_mortalcopy&quot;
and &quot;sv_2mortal&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_newmortal()</p>

<p style="margin-left:11%;">&quot;SvNIOK&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> contains a number, integer or
double.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvNIOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvNIOK_off&quot;</p>

<p style="margin-left:17%;">Unsets the <small>NV/IV</small>
status of an <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
SvNIOK_off(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvNIOKp&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> contains a number, integer or
double. Checks the <b>private</b> setting. Use
&quot;SvNIOK&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvNIOKp(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvNOK&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> contains a double.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvNOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvNOK_off&quot;</p>

<p style="margin-left:17%;">Unsets the <small>NV</small>
status of an <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
SvNOK_off(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvNOK_on&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is a double.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvNOK_on(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvNOK_only&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is a double and disables all other <small>OK</small>
bits.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvNOK_only(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvNOKp&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> contains a double. Checks the
<b>private</b> setting. Use &quot;SvNOK&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvNOKp(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_nolocking&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;sv_nolocking&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Dummy routine
which &quot;locks&quot; an <small>SV</small> when there is
no locking module present. Exists to avoid test for a
&quot;NULL&quot; function pointer and because it could
potentially warn under some level of strict-ness.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;Superseded&quot;
by &quot;sv_nosharing()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_nolocking(SV *sv)</p>

<p style="margin-left:11%;">&quot;sv_nounlocking&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;sv_nounlocking&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Dummy routine
which &quot;unlocks&quot; an <small>SV</small> when there is
no locking module present. Exists to avoid test for a
&quot;NULL&quot; function pointer and because it could
potentially warn under some level of strict-ness.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;Superseded&quot;
by &quot;sv_nosharing()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_nounlocking(SV *sv)</p>

<p style="margin-left:11%;">&quot;sv_numeq&quot;</p>

<p style="margin-left:17%;">A convenient shortcut for
calling &quot;sv_numeq_flags&quot; with the
&quot;SV_GMAGIC&quot; flag. This function basically behaves
like the Perl code &quot;$sv1 == $sv2&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_numeq(SV* sv1, SV* sv2)</p>

<p style="margin-left:11%;">&quot;sv_numeq_flags&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the numbers in the two SVs are identical. If the
flags argument has the &quot;SV_GMAGIC&quot; bit set, it
handles get-magic too. Will coerce its args to numbers if
necessary. Treats &quot;NULL&quot; as undef.</p>

<p style="margin-left:17%; margin-top: 1em">If flags does
not have the &quot;SV_SKIP_OVERLOAD&quot; bit set, an
attempt to use &quot;==&quot; overloading will be made. If
such overloading does not exist or the flag is set, then
regular numerical comparison will be used instead.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_numeq_flags(SV* sv1, SV* sv2, const U32 flags)</p>

<p style="margin-left:11%;">&quot;SvNV&quot; <br>
&quot;SvNVx&quot; <br>
&quot;SvNV_nomg&quot;</p>

<p style="margin-left:17%;">These coerce the given
<small>SV</small> to <small>NV</small> and return it. The
returned value in many circumstances will get stored in
&quot;sv&quot;&rsquo;s <small>NV</small> slot, but not in
all cases. (Use &quot;sv_setnv&quot; to make sure it
does).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvNVx&quot;
is different from the others in that it is guaranteed to
evaluate &quot;sv&quot; exactly once; the others may
evaluate it multiple times. Only use this form if
&quot;sv&quot; is an expression with side effects, otherwise
use the more efficient &quot;SvNV&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvNV_nomg&quot;
is the same as &quot;SvNV&quot;, but does not perform
&rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">NV SvNV(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvNV_set&quot;</p>

<p style="margin-left:17%;">Set the value of the
<small>NV</small> pointer in &quot;sv&quot; to val. See
&quot;SvIV_set&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvNV_set(SV* sv, NV val)</p>

<p style="margin-left:11%;">&quot;SvNVX&quot;</p>

<p style="margin-left:17%;">Returns the raw value in the
<small>SV</small> &rsquo;s <small>NV</small> slot, without
checks or conversions. Only use when you are sure
&quot;SvNOK&quot; is true. See also &quot;SvNV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">NV SvNVX(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvOK&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the value is defined. This is only meaningful for
scalars.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvOOK&quot;</p>

<p style="margin-left:17%;">Returns a U32 indicating
whether the pointer to the string buffer is offset. This
hack is used internally to speed up removal of characters
from the beginning of a &quot;SvPV&quot;. When
&quot;SvOOK&quot; is true, then the start of the allocated
string buffer is actually &quot;SvOOK_offset()&quot; bytes
before &quot;SvPVX&quot;. This offset used to be stored in
&quot;SvIVX&quot;, but is now stored within the spare part
of the buffer.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvOOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvOOK_off&quot;</p>

<p style="margin-left:17%;">Remove any string offset.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvOOK_off(SV * sv)</p>

<p style="margin-left:11%;">&quot;SvOOK_offset&quot;</p>

<p style="margin-left:17%;">Reads into &quot;len&quot; the
offset from &quot;SvPVX&quot; back to the true start of the
allocated buffer, which will be non-zero if
&quot;sv_chop&quot; has been used to efficiently remove
characters from start of the buffer. Implemented as a macro,
which takes the address of &quot;len&quot;, which must be of
type &quot;STRLEN&quot;. Evaluates &quot;sv&quot; more than
once. Sets &quot;len&quot; to 0 if &quot;SvOOK(sv)&quot; is
false.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvOOK_offset(SV*sv, STRLEN len)</p>

<p style="margin-left:11%;">&quot;SvPOK&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> contains a character
string.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvPOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvPOK_off&quot;</p>

<p style="margin-left:17%;">Unsets the <small>PV</small>
status of an <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
SvPOK_off(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvPOK_on&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is a string.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvPOK_on(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvPOK_only&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is a string and disables all other &quot;OK&quot; bits.
Will also turn off the <small>UTF&minus;8</small>
status.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvPOK_only(SV* sv)</p>


<p style="margin-left:11%;">&quot;SvPOK_only_UTF8&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is a string and disables all other &quot;OK&quot; bits,
and leaves the <small>UTF&minus;8</small> status as it
was.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvPOK_only_UTF8(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvPOKp&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
whether the <small>SV</small> contains a character string.
Checks the <b>private</b> setting. Use &quot;SvPOK&quot;
instead.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvPOKp(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_pos_b2u&quot;</p>

<p style="margin-left:17%;">Converts the value pointed to
by &quot;offsetp&quot; from a count of bytes from the start
of the string, to a count of the equivalent number of
<small>UTF&minus;8</small> chars. Handles magic and type
coercion.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;sv_pos_b2u_flags&quot; in preference, which correctly
handles strings longer than 2Gb.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_pos_b2u(SV *const sv, I32 *const offsetp)</p>


<p style="margin-left:11%;">&quot;sv_pos_b2u_flags&quot;</p>

<p style="margin-left:17%;">Converts &quot;offset&quot;
from a count of bytes from the start of the string, to a
count of the equivalent number of <small>UTF&minus;8</small>
chars. Handles type coercion. &quot;flags&quot; is passed to
&quot;SvPV_flags&quot;, and usually should be
&quot;SV_GMAGIC|SV_CONST_RETURN&quot; to handle magic.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
sv_pos_b2u_flags(SV *const sv, STRLEN const offset, <br>
U32 flags)</p>

<p style="margin-left:11%;">&quot;sv_pos_u2b&quot;</p>

<p style="margin-left:17%;">Converts the value pointed to
by &quot;offsetp&quot; from a count of
<small>UTF&minus;8</small> chars from the start of the
string, to a count of the equivalent number of bytes; if
&quot;lenp&quot; is non-zero, it does the same to
&quot;lenp&quot;, but this time starting from the offset,
rather than from the start of the string. Handles magic and
type coercion.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;sv_pos_u2b_flags&quot; in preference, which correctly
handles strings longer than 2Gb.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_pos_u2b(SV *const sv, I32 *const offsetp, <br>
I32 *const lenp)</p>


<p style="margin-left:11%;">&quot;sv_pos_u2b_flags&quot;</p>

<p style="margin-left:17%;">Converts the offset from a
count of <small>UTF&minus;8</small> chars from the start of
the string, to a count of the equivalent number of bytes; if
&quot;lenp&quot; is non-zero, it does the same to
&quot;lenp&quot;, but this time starting from
&quot;offset&quot;, rather than from the start of the
string. Handles type coercion. &quot;flags&quot; is passed
to &quot;SvPV_flags&quot;, and usually should be
&quot;SV_GMAGIC|SV_CONST_RETURN&quot; to handle magic.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
sv_pos_u2b_flags(SV *const sv, STRLEN uoffset, <br>
STRLEN *const lenp, U32 flags)</p>

<p style="margin-left:11%;">&quot;SvPV&quot; <br>
&quot;SvPVx&quot; <br>
&quot;SvPV_nomg&quot; <br>
&quot;SvPV_nolen&quot; <br>
&quot;SvPVx_nolen&quot; <br>
&quot;SvPV_nomg_nolen&quot; <br>
&quot;SvPV_mutable&quot; <br>
&quot;SvPV_const&quot; <br>
&quot;SvPVx_const&quot; <br>
&quot;SvPV_nolen_const&quot; <br>
&quot;SvPVx_nolen_const&quot; <br>
&quot;SvPV_nomg_const&quot; <br>
&quot;SvPV_nomg_const_nolen&quot; <br>
&quot;SvPV_flags&quot; <br>
&quot;SvPV_flags_const&quot; <br>
&quot;SvPV_flags_mutable&quot; <br>
&quot;SvPVbyte&quot; <br>
&quot;SvPVbyte_nomg&quot; <br>
&quot;SvPVbyte_nolen&quot; <br>
&quot;SvPVbytex_nolen&quot; <br>
&quot;SvPVbytex&quot; <br>
&quot;SvPVbyte_or_null&quot; <br>
&quot;SvPVbyte_or_null_nomg&quot; <br>
&quot;SvPVutf8&quot; <br>
&quot;SvPVutf8x&quot; <br>
&quot;SvPVutf8_nomg&quot; <br>
&quot;SvPVutf8_nolen&quot; <br>
&quot;SvPVutf8_or_null&quot; <br>
&quot;SvPVutf8_or_null_nomg&quot;</p>

<p style="margin-left:17%;">All these return a pointer to
the string in &quot;sv&quot;, or a stringified form of
&quot;sv&quot; if it does not contain a string. The
<small>SV</small> may cache the stringified version becoming
&quot;SvPOK&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This is a very
basic and common operation, so there are lots of slightly
different versions of it.</p>

<p style="margin-left:17%; margin-top: 1em">Note that there
is no guarantee that the return value of
&quot;SvPV(sv)&quot;, for example, is equal to
&quot;SvPVX(sv)&quot;, or that &quot;SvPVX(sv)&quot;
contains valid data, or that successive calls to
&quot;SvPV(sv)&quot; (or another of these forms) will return
the same pointer value each time. This is due to the way
that things like overloading and Copy-On-Write are handled.
In these cases, the return value may point to a temporary
buffer or similar. If you absolutely need the
&quot;SvPVX&quot; field to be valid (for example, if you
intend to write to it), then see &quot;SvPV_force&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The differences
between the forms are:</p>

<p style="margin-left:17%; margin-top: 1em">The forms with
neither &quot;byte&quot; nor &quot;utf8&quot; in their names
(e.g., &quot;SvPV&quot; or &quot;SvPV_nolen&quot;) can
expose the <small>SV</small> &rsquo;s internal string
buffer. If that buffer consists entirely of bytes
0&minus;255 and includes any bytes above 127, then you
<b><small>MUST</small></b> consult &quot;SvUTF8&quot; to
determine the actual code points the string is meant to
contain. Generally speaking, it is probably safer to prefer
&quot;SvPVbyte&quot;, &quot;SvPVutf8&quot;, and the like.
See &quot;How do I pass a Perl string to a C library?&quot;
in perlguts for more details.</p>

<p style="margin-left:17%; margin-top: 1em">The forms with
&quot;flags&quot; in their names allow you to use the
&quot;flags&quot; parameter to specify to process
&rsquo;get&rsquo; magic (by setting the
&quot;SV_GMAGIC&quot; flag) or to skip &rsquo;get&rsquo;
magic (by clearing it). The other forms process
&rsquo;get&rsquo; magic, except for the ones with
&quot;nomg&quot; in their names, which skip
&rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">The forms that
take a &quot;len&quot; parameter will set that variable to
the byte length of the resultant string (these are macros,
so don&rsquo;t use &amp;len).</p>

<p style="margin-left:17%; margin-top: 1em">The forms with
&quot;nolen&quot; in their names indicate they don&rsquo;t
have a &quot;len&quot; parameter. They should be used only
when it is known that the <small>PV</small> is a C string,
terminated by a <small>NUL</small> byte, and without
intermediate <small>NUL</small> characters; or when you
don&rsquo;t care about its length.</p>

<p style="margin-left:17%; margin-top: 1em">The forms with
&quot;const&quot; in their names return
&quot;const&nbsp;char&nbsp;*&quot; so that the compiler will
hopefully complain if you were to try to modify the contents
of the string (unless you cast away const yourself).</p>

<p style="margin-left:17%; margin-top: 1em">The other forms
return a mutable pointer so that the string is modifiable by
the caller; this is emphasized for the ones with
&quot;mutable&quot; in their names.</p>

<p style="margin-left:17%; margin-top: 1em">The forms whose
name ends in &quot;x&quot; are the same as the corresponding
form without the &quot;x&quot;, but the &quot;x&quot; form
is guaranteed to evaluate &quot;sv&quot; exactly once, with
a slight loss of efficiency. Use this if &quot;sv&quot; is
an expression with side effects.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVutf8&quot;
is like &quot;SvPV&quot;, but converts &quot;sv&quot; to
<small>UTF&minus;8</small> first if not already
<small>UTF&minus;8.</small> Similiarly, the other forms with
&quot;utf8&quot; in their names correspond to their
respective forms without.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVutf8_or_null&quot;
and &quot;SvPVutf8_or_null_nomg&quot; don&rsquo;t have
corresponding non&minus;&quot;utf8&quot; forms. Instead they
are like &quot;SvPVutf8_nomg&quot;, but when &quot;sv&quot;
is undef, they return &quot;NULL&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVbyte&quot;
is like &quot;SvPV&quot;, but converts &quot;sv&quot; to
byte representation first if currently encoded as
<small>UTF&minus;8.</small> If &quot;sv&quot; cannot be
downgraded from <small>UTF&minus;8,</small> it croaks.
Similiarly, the other forms with &quot;byte&quot; in their
names correspond to their respective forms without.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVbyte_or_null&quot;
doesn&rsquo;t have a corresponding
non&minus;&quot;byte&quot; form. Instead it is like
&quot;SvPVbyte&quot;, but when &quot;sv&quot; is undef, it
returns &quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char* SvPV (SV*
sv, STRLEN len) <br>
char* SvPVx (SV* sv, STRLEN len) <br>
char* SvPV_nomg (SV* sv, STRLEN len) <br>
char* SvPV_nolen (SV* sv) <br>
char* SvPVx_nolen (SV* sv) <br>
char* SvPV_nomg_nolen (SV* sv) <br>
char* SvPV_mutable (SV* sv, STRLEN len) <br>
const char* SvPV_const (SV* sv, STRLEN len) <br>
const char* SvPVx_const (SV* sv, STRLEN len) <br>
const char* SvPV_nolen_const (SV* sv) <br>
const char* SvPVx_nolen_const (SV* sv) <br>
const char* SvPV_nomg_const (SV* sv, STRLEN len) <br>
const char* SvPV_nomg_const_nolen(SV* sv) <br>
char * SvPV_flags (SV * sv, STRLEN len, <br>
U32 flags) <br>
const char * SvPV_flags_const (SV * sv, STRLEN len, <br>
U32 flags) <br>
char * SvPV_flags_mutable (SV * sv, STRLEN len, <br>
U32 flags) <br>
char* SvPVbyte (SV* sv, STRLEN len) <br>
char* SvPVbyte_nomg (SV* sv, STRLEN len) <br>
char* SvPVbyte_nolen (SV* sv) <br>
char* SvPVbytex_nolen (SV* sv) <br>
char* SvPVbytex (SV* sv, STRLEN len) <br>
char* SvPVbyte_or_null (SV* sv, STRLEN len) <br>
char* SvPVbyte_or_null_nomg(SV* sv, STRLEN len) <br>
char* SvPVutf8 (SV* sv, STRLEN len) <br>
char* SvPVutf8x (SV* sv, STRLEN len) <br>
char* SvPVutf8_nomg (SV* sv, STRLEN len) <br>
char* SvPVutf8_nolen (SV* sv) <br>
char* SvPVutf8_or_null (SV* sv, STRLEN len) <br>
char* SvPVutf8_or_null_nomg(SV* sv, STRLEN len)</p>

<p style="margin-left:11%;">&quot;SvPVCLEAR&quot;</p>

<p style="margin-left:17%;">Ensures that sv is a SVt_PV and
that its SvCUR is 0, and that it is properly null
terminated. Equivalent to sv_setpvs(&quot;&quot;), but more
efficient.</p>

<p style="margin-left:17%; margin-top: 1em">char *
SvPVCLEAR(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvPV_force&quot; <br>
&quot;SvPV_force_nolen&quot; <br>
&quot;SvPVx_force&quot; <br>
&quot;SvPV_force_nomg&quot; <br>
&quot;SvPV_force_nomg_nolen&quot; <br>
&quot;SvPV_force_mutable&quot; <br>
&quot;SvPV_force_flags&quot; <br>
&quot;SvPV_force_flags_nolen&quot; <br>
&quot;SvPV_force_flags_mutable&quot; <br>
&quot;SvPVbyte_force&quot; <br>
&quot;SvPVbytex_force&quot; <br>
&quot;SvPVutf8_force&quot; <br>
&quot;SvPVutf8x_force&quot;</p>

<p style="margin-left:17%;">These are like
&quot;SvPV&quot;, returning the string in the
<small>SV,</small> but will force the <small>SV</small> into
containing a string (&quot;SvPOK&quot;), and only a string
(&quot;SvPOK_only&quot;), by hook or by crook. You need to
use one of these &quot;force&quot; routines if you are going
to update the &quot;SvPVX&quot; directly.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
coercing an arbitrary scalar into a plain <small>PV</small>
will potentially strip useful data from it. For example if
the <small>SV</small> was &quot;SvROK&quot;, then the
referent will have its reference count decremented, and the
<small>SV</small> itself may be converted to an
&quot;SvPOK&quot; scalar with a string buffer containing a
value such as &quot;ARRAY(0x1234)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The differences
between the forms are:</p>

<p style="margin-left:17%; margin-top: 1em">The forms with
&quot;flags&quot; in their names allow you to use the
&quot;flags&quot; parameter to specify to perform
&rsquo;get&rsquo; magic (by setting the
&quot;SV_GMAGIC&quot; flag) or to skip &rsquo;get&rsquo;
magic (by clearing it). The other forms do perform
&rsquo;get&rsquo; magic, except for the ones with
&quot;nomg&quot; in their names, which skip
&rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">The forms that
take a &quot;len&quot; parameter will set that variable to
the byte length of the resultant string (these are macros,
so don&rsquo;t use &amp;len).</p>

<p style="margin-left:17%; margin-top: 1em">The forms with
&quot;nolen&quot; in their names indicate they don&rsquo;t
have a &quot;len&quot; parameter. They should be used only
when it is known that the <small>PV</small> is a C string,
terminated by a <small>NUL</small> byte, and without
intermediate <small>NUL</small> characters; or when you
don&rsquo;t care about its length.</p>

<p style="margin-left:17%; margin-top: 1em">The forms with
&quot;mutable&quot; in their names are effectively the same
as those without, but the name emphasizes that the string is
modifiable by the caller, which it is in all the forms.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVutf8_force&quot;
is like &quot;SvPV_force&quot;, but converts &quot;sv&quot;
to <small>UTF&minus;8</small> first if not already
<small>UTF&minus;8.</small></p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVutf8x_force&quot;
is like &quot;SvPVutf8_force&quot;, but guarantees to
evaluate &quot;sv&quot; only once; use the more efficient
&quot;SvPVutf8_force&quot; otherwise.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVbyte_force&quot;
is like &quot;SvPV_force&quot;, but converts &quot;sv&quot;
to byte representation first if currently encoded as
<small>UTF&minus;8.</small> If the <small>SV</small> cannot
be downgraded from <small>UTF&minus;8,</small> this
croaks.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVbytex_force&quot;
is like &quot;SvPVbyte_force&quot;, but guarantees to
evaluate &quot;sv&quot; only once; use the more efficient
&quot;SvPVbyte_force&quot; otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">char*
SvPV_force (SV* sv, STRLEN len) <br>
char* SvPV_force_nolen (SV* sv) <br>
char* SvPVx_force (SV* sv, STRLEN len) <br>
char* SvPV_force_nomg (SV* sv, STRLEN len) <br>
char* SvPV_force_nomg_nolen (SV * sv) <br>
char* SvPV_force_mutable (SV * sv, STRLEN len) <br>
char* SvPV_force_flags (SV * sv, STRLEN len, U32 flags) <br>
char* SvPV_force_flags_nolen (SV * sv, U32 flags) <br>
char* SvPV_force_flags_mutable(SV * sv, STRLEN len, U32
flags) <br>
char* SvPVbyte_force (SV* sv, STRLEN len) <br>
char* SvPVbytex_force (SV* sv, STRLEN len) <br>
char* SvPVutf8_force (SV* sv, STRLEN len) <br>
char* SvPVutf8x_force (SV* sv, STRLEN len)</p>

<p style="margin-left:11%;">&quot;SvPV_free&quot;</p>

<p style="margin-left:17%;">Frees the <small>PV</small>
buffer in &quot;sv&quot;, leaving things in a precarious
state, so should only be used as part of a larger
operation</p>

<p style="margin-left:17%; margin-top: 1em">void
SvPV_free(SV * sv)</p>


<p style="margin-left:11%;">&quot;sv_pvn_force_flags&quot;</p>

<p style="margin-left:17%;">Get a sensible string out of
the <small>SV</small> somehow. If &quot;flags&quot; has the
&quot;SV_GMAGIC&quot; bit set, will &quot;mg_get&quot; on
&quot;sv&quot; if appropriate, else not.
&quot;sv_pvn_force&quot; and &quot;sv_pvn_force_nomg&quot;
are implemented in terms of this function. You normally want
to use the various wrapper macros instead: see
&quot;SvPV_force&quot; and &quot;SvPV_force_nomg&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_pvn_force_flags(SV *const sv, STRLEN *const lp, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;SvPV_renew&quot;</p>

<p style="margin-left:17%;">Low level micro optimization of
&quot;SvGROW&quot;. It is generally better to use
&quot;SvGROW&quot; instead. This is because
&quot;SvPV_renew&quot; ignores potential issues that
&quot;SvGROW&quot; handles. &quot;sv&quot; needs to have a
real &quot;PV&quot; that is unencombered by things like
<small>COW.</small> Using &quot;SV_CHECK_THINKFIRST&quot; or
&quot;SV_CHECK_THINKFIRST_COW_DROP&quot; before calling this
should clean it up, but why not just use &quot;SvGROW&quot;
if you&rsquo;re not sure about the provenance?</p>

<p style="margin-left:17%; margin-top: 1em">void
SvPV_renew(SV* sv, STRLEN len)</p>

<p style="margin-left:11%;">&quot;SvPV_set&quot;</p>

<p style="margin-left:17%;">This is probably not what you
want to use, you probably wanted &quot;sv_usepvn_flags&quot;
or &quot;sv_setpvn&quot; or &quot;sv_setpvs&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Set the value
of the <small>PV</small> pointer in &quot;sv&quot; to the
Perl allocated &quot;NUL&quot;&minus;terminated string
&quot;val&quot;. See also &quot;SvIV_set&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Remember to
free the previous <small>PV</small> buffer. There are many
things to check. Beware that the existing pointer may be
involved in copy-on-write or other mischief, so do
&quot;SvOOK_off(sv)&quot; and use
&quot;sv_force_normal&quot; or &quot;SvPV_force&quot; (or
check the &quot;SvIsCOW&quot; flag) first to make sure this
modification is safe. Then finally, if it is not a
<small>COW,</small> call &quot;SvPV_free&quot; to free the
previous <small>PV</small> buffer.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvPV_set(SV* sv, char* val)</p>

<p style="margin-left:11%;">&quot;SvPVX&quot; <br>
&quot;SvPVXx&quot; <br>
&quot;SvPVX_const&quot; <br>
&quot;SvPVX_mutable&quot;</p>

<p style="margin-left:17%;">These return a pointer to the
physical string in the <small>SV.</small> The
<small>SV</small> must contain a string. Prior to 5.9.3 it
is not safe to execute these unless the <small>SV</small>
&rsquo;s type &gt;= &quot;SVt_PV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">These are also
used to store the name of an autoloaded subroutine in an
<small>XS AUTOLOAD</small> routine. See &quot;Autoloading
with XSUBs&quot; in perlguts.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVXx&quot;
is identical to &quot;SvPVX&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVX_mutable&quot;
is merely a synonym for &quot;SvPVX&quot;, but its name
emphasizes that the string is modifiable by the caller.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvPVX_const&quot;
differs in that the return value has been cast so that the
compiler will complain if you were to try to modify the
contents of the string, (unless you cast away const
yourself).</p>

<p style="margin-left:17%; margin-top: 1em">char* SvPVX
(SV* sv) <br>
char* SvPVXx (SV* sv) <br>
const char* SvPVX_const (SV* sv) <br>
char* SvPVX_mutable(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvPVXtrue&quot;</p>

<p style="margin-left:17%;">Note: This macro may evaluate
&quot;sv&quot; more than once.</p>

<p style="margin-left:17%; margin-top: 1em">Returns a
boolean as to whether or not &quot;sv&quot; contains a
<small>PV</small> that is considered <small>TRUE.
FALSE</small> is returned if &quot;sv&quot; doesn&rsquo;t
contain a <small>PV,</small> or if the <small>PV</small> it
does contain is zero length, or consists of just the single
character &rsquo;0&rsquo;. Every other <small>PV</small>
value is considered <small>TRUE.</small></p>

<p style="margin-left:17%; margin-top: 1em">bool
SvPVXtrue(SV * sv)</p>

<p style="margin-left:11%;">&quot;SvREADONLY&quot;</p>

<p style="margin-left:17%;">Returns true if the argument is
readonly, otherwise returns false. Exposed to perl code via
<b>Internals::SvREADONLY()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">U32
SvREADONLY(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvREADONLY_off&quot;</p>

<p style="margin-left:17%;">Mark an object as not-readonly.
Exactly what this mean depends on the object type. Exposed
to perl code via <b>Internals::SvREADONLY()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">U32
SvREADONLY_off(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvREADONLY_on&quot;</p>

<p style="margin-left:17%;">Mark an object as readonly.
Exactly what this means depends on the object type. Exposed
to perl code via <b>Internals::SvREADONLY()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">U32
SvREADONLY_on(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_ref&quot;</p>

<p style="margin-left:17%;">Returns a <small>SV</small>
describing what the <small>SV</small> passed in is a
reference to.</p>

<p style="margin-left:17%; margin-top: 1em">dst can be a
<small>SV</small> to be set to the description or
<small>NULL,</small> in which case a mortal
<small>SV</small> is returned.</p>

<p style="margin-left:17%; margin-top: 1em">If ob is true
and the <small>SV</small> is blessed, the description is the
class name, otherwise it is the type of the <small>SV,
&quot;SCALAR&quot;, &quot;ARRAY&quot;</small> etc.</p>

<p style="margin-left:17%; margin-top: 1em">SV* sv_ref(SV
*dst, const SV *const sv, const int ob)</p>

<p style="margin-left:11%;">&quot;SvREFCNT&quot;</p>

<p style="margin-left:17%;">Returns the value of the
object&rsquo;s reference count. Exposed to perl code via
<b>Internals::SvREFCNT()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">U32
SvREFCNT(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvREFCNT_dec&quot; <br>
&quot;SvREFCNT_dec_NN&quot;</p>

<p style="margin-left:17%;">These decrement the reference
count of the given <small>SV.</small></p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_dec_NN&quot;
may only be used when &quot;sv&quot; is known to not be
&quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvREFCNT_dec(SV *sv)</p>

<p style="margin-left:11%;">&quot;SvREFCNT_inc&quot; <br>
&quot;SvREFCNT_inc_NN&quot; <br>
&quot;SvREFCNT_inc_void&quot; <br>
&quot;SvREFCNT_inc_void_NN&quot; <br>
&quot;SvREFCNT_inc_simple&quot; <br>
&quot;SvREFCNT_inc_simple_NN&quot; <br>
&quot;SvREFCNT_inc_simple_void&quot; <br>
&quot;SvREFCNT_inc_simple_void_NN&quot;</p>

<p style="margin-left:17%;">These all increment the
reference count of the given <small>SV.</small> The ones
without &quot;void&quot; in their names return the
<small>SV.</small></p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_inc&quot;
is the base operation; the rest are optimizations if various
input constraints are known to be true; hence, all can be
replaced with &quot;SvREFCNT_inc&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_inc_NN&quot;
can only be used if you know &quot;sv&quot; is not
&quot;NULL&quot;. Since we don&rsquo;t have to check the
NULLness, it&rsquo;s faster and smaller.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_inc_void&quot;
can only be used if you don&rsquo;t need the return value.
The macro doesn&rsquo;t need to return a meaningful
value.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_inc_void_NN&quot;
can only be used if you both don&rsquo;t need the return
value, and you know that &quot;sv&quot; is not
&quot;NULL&quot;. The macro doesn&rsquo;t need to return a
meaningful value, or check for NULLness, so it&rsquo;s
smaller and faster.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_inc_simple&quot;
can only be used with expressions without side effects.
Since we don&rsquo;t have to store a temporary value,
it&rsquo;s faster.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_inc_simple_NN&quot;
can only be used with expressions without side effects and
you know &quot;sv&quot; is not &quot;NULL&quot;. Since we
don&rsquo;t have to store a temporary value, nor check for
NULLness, it&rsquo;s faster and smaller.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_inc_simple_void&quot;
can only be used with expressions without side effects and
you don&rsquo;t need the return value.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvREFCNT_inc_simple_void_NN&quot;
can only be used with expressions without side effects, you
don&rsquo;t need the return value, and you know
&quot;sv&quot; is not &quot;NULL&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
SvREFCNT_inc (SV *sv) <br>
SV * SvREFCNT_inc_NN (SV *sv) <br>
void SvREFCNT_inc_void (SV *sv) <br>
void SvREFCNT_inc_void_NN (SV* sv) <br>
SV* SvREFCNT_inc_simple (SV* sv) <br>
SV* SvREFCNT_inc_simple_NN (SV* sv) <br>
void SvREFCNT_inc_simple_void (SV* sv) <br>
void SvREFCNT_inc_simple_void_NN(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_reftype&quot;</p>

<p style="margin-left:17%;">Returns a string describing
what the <small>SV</small> is a reference to.</p>

<p style="margin-left:17%; margin-top: 1em">If ob is true
and the <small>SV</small> is blessed, the string is the
class name, otherwise it is the type of the <small>SV,
&quot;SCALAR&quot;, &quot;ARRAY&quot;</small> etc.</p>

<p style="margin-left:17%; margin-top: 1em">const char*
sv_reftype(const SV *const sv, const int ob)</p>

<p style="margin-left:11%;">&quot;sv_replace&quot;</p>

<p style="margin-left:17%;">Make the first argument a copy
of the second, then delete the original. The target
<small>SV</small> physically takes over ownership of the
body of the source <small>SV</small> and inherits its flags;
however, the target keeps any magic it owns, and any magic
in the source is discarded. Note that this is a rather
specialist <small>SV</small> copying operation; most of the
time you&rsquo;ll want to use &quot;sv_setsv&quot; or one of
its many macro front-ends.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_replace(SV *const sv, SV *const nsv)</p>

<p style="margin-left:11%;">&quot;sv_report_used&quot;</p>

<p style="margin-left:17%;">Dump the contents of all SVs
not yet freed (debugging aid).</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_report_used()</p>

<p style="margin-left:11%;">&quot;sv_reset&quot;</p>

<p style="margin-left:17%;">Underlying implementation for
the &quot;reset&quot; Perl function. Note that the
perl-level function is vaguely deprecated.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_reset(const char* s, HV *const stash)</p>

<p style="margin-left:11%;">&quot;SvROK&quot;</p>

<p style="margin-left:17%;">Tests if the <small>SV</small>
is an <small>RV.</small></p>

<p style="margin-left:17%; margin-top: 1em">U32 SvROK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvROK_off&quot;</p>

<p style="margin-left:17%;">Unsets the <small>RV</small>
status of an <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
SvROK_off(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvROK_on&quot;</p>

<p style="margin-left:17%;">Tells an <small>SV</small> that
it is an <small>RV.</small></p>

<p style="margin-left:17%; margin-top: 1em">void
SvROK_on(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvRV&quot;</p>

<p style="margin-left:17%;">Dereferences an
<small>RV</small> to return the <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">SV* SvRV(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvRV_set&quot;</p>

<p style="margin-left:17%;">Set the value of the
<small>RV</small> pointer in &quot;sv&quot; to val. See
&quot;SvIV_set&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvRV_set(SV* sv, SV* val)</p>

<p style="margin-left:11%;">&quot;sv_rvunweaken&quot;</p>

<p style="margin-left:17%;">Unweaken a reference: Clear the
&quot;SvWEAKREF&quot; flag on this <small>RV</small> ;
remove the backreference to this <small>RV</small> from the
array of backreferences associated with the target
<small>SV,</small> increment the refcount of the target.
Silently ignores &quot;undef&quot; and warns on non-weak
references.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_rvunweaken(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_rvweaken&quot;</p>

<p style="margin-left:17%;">Weaken a reference: set the
&quot;SvWEAKREF&quot; flag on this <small>RV</small> ; give
the referred-to <small>SV</small>
&quot;PERL_MAGIC_backref&quot; magic if it hasn&rsquo;t
already; and push a back-reference to this <small>RV</small>
onto the array of backreferences associated with that magic.
If the <small>RV</small> is magical, set magic will be
called after the <small>RV</small> is cleared. Silently
ignores &quot;undef&quot; and warns on already-weak
references.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_rvweaken(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_setbool&quot; <br>
&quot;sv_setbool_mg&quot;</p>

<p style="margin-left:17%;">These set an <small>SV</small>
to a true or false boolean value, upgrading first if
necessary.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;sv_setbool_mg&quot; handles
&rsquo;set&rsquo; magic; &quot;sv_setbool&quot; does
not.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_setbool(SV *sv, bool b)</p>

<p style="margin-left:11%;">&quot;sv_setiv&quot; <br>
&quot;sv_setiv_mg&quot;</p>

<p style="margin-left:17%;">These copy an integer into the
given <small>SV,</small> upgrading first if necessary.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;sv_setiv_mg&quot; handles
&rsquo;set&rsquo; magic; &quot;sv_setiv&quot; does not.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_setiv
(SV *const sv, const IV num) <br>
void sv_setiv_mg(SV *const sv, const IV i)</p>

<p style="margin-left:11%;">&quot;SvSETMAGIC&quot;</p>

<p style="margin-left:17%;">Invokes &quot;mg_set&quot; on
an <small>SV</small> if it has &rsquo;set&rsquo; magic. This
is necessary after modifying a scalar, in case it is a
magical variable like $| or a tied variable (it calls
&quot;STORE&quot;). This macro evaluates its argument more
than once.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvSETMAGIC(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_setnv&quot; <br>
&quot;sv_setnv_mg&quot;</p>

<p style="margin-left:17%;">These copy a double into the
given <small>SV,</small> upgrading first if necessary.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;sv_setnv_mg&quot; handles
&rsquo;set&rsquo; magic; &quot;sv_setnv&quot; does not.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_setnv(SV *const sv, const NV num)</p>

<p style="margin-left:11%;">&quot;sv_setpv&quot; <br>
&quot;sv_setpv_mg&quot; <br>
&quot;sv_setpvn&quot; <br>
&quot;sv_setpvn_fresh&quot; <br>
&quot;sv_setpvn_mg&quot; <br>
&quot;sv_setpvs&quot; <br>
&quot;sv_setpvs_mg&quot;</p>

<p style="margin-left:17%;">These copy a string into the
<small>SV</small> &quot;sv&quot;, making sure it is
&quot;SvPOK_only&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">In the
&quot;pvs&quot; forms, the string must be a C literal
string, enclosed in double quotes.</p>

<p style="margin-left:17%; margin-top: 1em">In the
&quot;pvn&quot; forms, the first byte of the string is
pointed to by &quot;ptr&quot;, and &quot;len&quot; indicates
the number of bytes to be copied, potentially including
embedded &quot;NUL&quot; characters.</p>

<p style="margin-left:17%; margin-top: 1em">In the plain
&quot;pv&quot; forms, &quot;ptr&quot; points to a
NUL-terminated C string. That is, it points to the first
byte of the string, and the copy proceeds up through the
first enountered &quot;NUL&quot; byte.</p>

<p style="margin-left:17%; margin-top: 1em">In the forms
that take a &quot;ptr&quot; argument, if it is
<small>NULL,</small> the <small>SV</small> will become
undefined.</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>UTF&minus;8</small> flag is not changed by these
functions. A terminating <small>NUL</small> byte is
guaranteed in the result.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;_mg&quot; forms handle &rsquo;set&rsquo; magic; the
other forms skip all magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setpvn_fresh&quot;
is a cut-down alternative to &quot;sv_setpvn&quot;, intended
<small>ONLY</small> to be used with a fresh sv that has been
upgraded to a SVt_PV, SVt_PVIV, SVt_PVNV, or SVt_PVMG.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_setpv
(SV *const sv, const char *const ptr) <br>
void sv_setpv_mg (SV *const sv, const char *const ptr) <br>
void sv_setpvn (SV *const sv, const char *const ptr, <br>
const STRLEN len) <br>
void sv_setpvn_fresh(SV *const sv, const char *const ptr,
<br>
const STRLEN len) <br>
void sv_setpvn_mg (SV *const sv, const char *const ptr, <br>
const STRLEN len) <br>
void sv_setpvs (SV* sv, &quot;literal string&quot;) <br>
void sv_setpvs_mg (SV* sv, &quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;sv_setpvf&quot; <br>
&quot;sv_setpvf_nocontext&quot; <br>
&quot;sv_setpvf_mg&quot; <br>
&quot;sv_setpvf_mg_nocontext&quot;</p>

<p style="margin-left:17%;">These work like
&quot;sv_catpvf&quot; but copy the text into the
<small>SV</small> instead of appending it.</p>

<p style="margin-left:17%; margin-top: 1em">The differences
between these are:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setpvf_mg&quot;
and &quot;sv_setpvf_mg_nocontext&quot; perform
&rsquo;set&rsquo; magic; &quot;sv_setpvf&quot; and
&quot;sv_setpvf_nocontext&quot; skip all magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setpvf_nocontext&quot;
and &quot;sv_setpvf_mg_nocontext&quot; do not take a thread
context (&quot;aTHX&quot;) parameter, so are used in
situations where the caller doesn&rsquo;t already have the
thread context.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;sv_setpvf&quot; must be explicitly called as
&quot;Perl_sv_setpvf&quot; with an &quot;aTHX_&quot;
parameter.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;sv_setpvf_mg&quot; must be explicitly called as
&quot;Perl_sv_setpvf_mg&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_sv_setpvf (pTHX_ SV *const sv, <br>
const char *const pat, ...) <br>
void sv_setpvf_nocontext (SV *const sv, const char *const
pat, <br>
...) <br>
void Perl_sv_setpvf_mg (pTHX_ SV *const sv, <br>
const char *const pat, ...) <br>
void sv_setpvf_mg_nocontext(SV *const sv, const char *const
pat, <br>
...)</p>

<p style="margin-left:11%;">&quot;sv_setpviv&quot; <br>
&quot;sv_setpviv_mg&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove both forms from a future release of
Perl. Do not use them for new code; remove them from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">These copy an
integer into the given <small>SV,</small> also updating its
string value.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;sv_setpviv_mg&quot; performs
&rsquo;set&rsquo; magic; &quot;sv_setpviv&quot; skips any
magic.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_setpviv
(SV *const sv, const IV num) <br>
void sv_setpviv_mg(SV *const sv, const IV iv)</p>


<p style="margin-left:11%;">&quot;sv_setpv_bufsize&quot;</p>

<p style="margin-left:17%;">Sets the <small>SV</small> to
be a string of cur bytes length, with at least len bytes
available. Ensures that there is a null byte at SvEND.
Returns a char * pointer to the SvPV buffer.</p>

<p style="margin-left:17%; margin-top: 1em">char *
sv_setpv_bufsize(SV *const sv, const STRLEN cur, <br>
const STRLEN len)</p>

<p style="margin-left:11%;">&quot;sv_setref_iv&quot;</p>

<p style="margin-left:17%;">Copies an integer into a new
<small>SV,</small> optionally blessing the
<small>SV.</small> The &quot;rv&quot; argument will be
upgraded to an <small>RV.</small> That <small>RV</small>
will be modified to point to the new <small>SV.</small> The
&quot;classname&quot; argument indicates the package for the
blessing. Set &quot;classname&quot; to &quot;NULL&quot; to
avoid the blessing. The new <small>SV</small> will have a
reference count of 1, and the <small>RV</small> will be
returned.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_setref_iv(SV *const rv, const char *const classname, <br>
const IV iv)</p>

<p style="margin-left:11%;">&quot;sv_setref_nv&quot;</p>

<p style="margin-left:17%;">Copies a double into a new
<small>SV,</small> optionally blessing the
<small>SV.</small> The &quot;rv&quot; argument will be
upgraded to an <small>RV.</small> That <small>RV</small>
will be modified to point to the new <small>SV.</small> The
&quot;classname&quot; argument indicates the package for the
blessing. Set &quot;classname&quot; to &quot;NULL&quot; to
avoid the blessing. The new <small>SV</small> will have a
reference count of 1, and the <small>RV</small> will be
returned.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_setref_nv(SV *const rv, const char *const classname, <br>
const NV nv)</p>

<p style="margin-left:11%;">&quot;sv_setref_pv&quot;</p>

<p style="margin-left:17%;">Copies a pointer into a new
<small>SV,</small> optionally blessing the
<small>SV.</small> The &quot;rv&quot; argument will be
upgraded to an <small>RV.</small> That <small>RV</small>
will be modified to point to the new <small>SV.</small> If
the &quot;pv&quot; argument is &quot;NULL&quot;, then
&quot;PL_sv_undef&quot; will be placed into the
<small>SV.</small> The &quot;classname&quot; argument
indicates the package for the blessing. Set
&quot;classname&quot; to &quot;NULL&quot; to avoid the
blessing. The new <small>SV</small> will have a reference
count of 1, and the <small>RV</small> will be returned.</p>

<p style="margin-left:17%; margin-top: 1em">Do not use with
other Perl types such as <small>HV, AV, SV, CV,</small>
because those objects will become corrupted by the pointer
copy process.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;sv_setref_pvn&quot; copies the string while this
copies the pointer.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_setref_pv(SV *const rv, const char *const classname, <br>
void *const pv)</p>

<p style="margin-left:11%;">&quot;sv_setref_pvn&quot;</p>

<p style="margin-left:17%;">Copies a string into a new
<small>SV,</small> optionally blessing the
<small>SV.</small> The length of the string must be
specified with &quot;n&quot;. The &quot;rv&quot; argument
will be upgraded to an <small>RV.</small> That
<small>RV</small> will be modified to point to the new
<small>SV.</small> The &quot;classname&quot; argument
indicates the package for the blessing. Set
&quot;classname&quot; to &quot;NULL&quot; to avoid the
blessing. The new <small>SV</small> will have a reference
count of 1, and the <small>RV</small> will be returned.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;sv_setref_pv&quot; copies the pointer while this
copies the string.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_setref_pvn(SV *const rv, const char *const classname,
<br>
const char *const pv, const STRLEN n)</p>

<p style="margin-left:11%;">&quot;sv_setref_pvs&quot;</p>

<p style="margin-left:17%;">Like &quot;sv_setref_pvn&quot;,
but takes a literal string instead of a string/length
pair.</p>

<p style="margin-left:17%; margin-top: 1em">SV *
sv_setref_pvs(SV *const rv, const char *const classname,
<br>
&quot;literal string&quot;)</p>

<p style="margin-left:11%;">&quot;sv_setref_uv&quot;</p>

<p style="margin-left:17%;">Copies an unsigned integer into
a new <small>SV,</small> optionally blessing the
<small>SV.</small> The &quot;rv&quot; argument will be
upgraded to an <small>RV.</small> That <small>RV</small>
will be modified to point to the new <small>SV.</small> The
&quot;classname&quot; argument indicates the package for the
blessing. Set &quot;classname&quot; to &quot;NULL&quot; to
avoid the blessing. The new <small>SV</small> will have a
reference count of 1, and the <small>RV</small> will be
returned.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
sv_setref_uv(SV *const rv, const char *const classname, <br>
const UV uv)</p>

<p style="margin-left:11%;">&quot;sv_setrv_inc&quot; <br>
&quot;sv_setrv_inc_mg&quot;</p>

<p style="margin-left:17%;">As &quot;sv_setrv_noinc&quot;
but increments the reference count of <i>ref</i>.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setrv_inc_mg&quot;
will invoke &rsquo;set&rsquo; magic on the <small>SV</small>
; &quot;sv_setrv_inc&quot; will not.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_setrv_inc(SV *const sv, SV *const ref)</p>

<p style="margin-left:11%;">&quot;sv_setrv_noinc&quot; <br>
&quot;sv_setrv_noinc_mg&quot;</p>

<p style="margin-left:17%;">Copies an <small>SV</small>
pointer into the given <small>SV</small> as an
<small>SV</small> reference, upgrading it if necessary.
After this, &quot;SvRV(sv)&quot; is equal to <i>ref</i>.
This does not adjust the reference count of <i>ref</i>. The
reference <i>ref</i> must not be <small>NULL.</small></p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setrv_noinc_mg&quot;
will invoke &rsquo;set&rsquo; magic on the <small>SV</small>
; &quot;sv_setrv_noinc&quot; will not.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_setrv_noinc(SV *const sv, SV *const ref)</p>

<p style="margin-left:11%;">&quot;SvSetSV&quot; <br>
&quot;SvSetMagicSV&quot; <br>
&quot;SvSetSV_nosteal&quot; <br>
&quot;SvSetMagicSV_nosteal&quot;</p>

<p style="margin-left:17%;">if &quot;dsv&quot; is the same
as &quot;ssv&quot;, these do nothing. Otherwise they all
call some form of &quot;sv_setsv&quot;. They may evaluate
their arguments more than once.</p>

<p style="margin-left:17%; margin-top: 1em">The only
differences are:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvSetMagicSV&quot;
and &quot;SvSetMagicSV_nosteal&quot; perform any required
&rsquo;set&rsquo; magic afterwards on the destination
<small>SV</small> ; &quot;SvSetSV&quot; and
&quot;SvSetSV_nosteal&quot; do not.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvSetSV_nosteal&quot;
&quot;SvSetMagicSV_nosteal&quot; call a non-destructive
version of &quot;sv_setsv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvSetSV(SV* dsv, SV* ssv)</p>

<p style="margin-left:11%;">&quot;sv_setsv&quot; <br>
&quot;sv_setsv_flags&quot; <br>
&quot;sv_setsv_mg&quot; <br>
&quot;sv_setsv_nomg&quot;</p>

<p style="margin-left:17%;">These copy the contents of the
source <small>SV</small> &quot;ssv&quot; into the
destination <small>SV</small> &quot;dsv&quot;.
&quot;ssv&quot; may be destroyed if it is mortal, so
don&rsquo;t use these functions if the source
<small>SV</small> needs to be reused. Loosely speaking, they
perform a copy-by-value, obliterating any previous content
of the destination.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setsv&quot;
calls &rsquo;get&rsquo; magic on &quot;ssv&quot;, but skips
&rsquo;set&rsquo; magic on &quot;dsv&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setsv_mg&quot;
calls both &rsquo;get&rsquo; magic on &quot;ssv&quot; and
&rsquo;set&rsquo; magic on &quot;dsv&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setsv_nomg&quot;
skips all magic.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setsv_flags&quot;
has a &quot;flags&quot; parameter which you can use to
specify any combination of magic handling, and also you can
specify &quot;SV_NOSTEAL&quot; so that the buffers of temps
will not be stolen.</p>

<p style="margin-left:17%; margin-top: 1em">You probably
want to instead use one of the assortment of wrappers, such
as &quot;SvSetSV&quot;, &quot;SvSetSV_nosteal&quot;,
&quot;SvSetMagicSV&quot; and
&quot;SvSetMagicSV_nosteal&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_setsv_flags&quot;
is the primary function for copying scalars, and most other
copy-ish functions and macros use it underneath.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_setsv
(SV *dsv, SV *ssv) <br>
void sv_setsv_flags(SV *dsv, SV *ssv, const I32 flags) <br>
void sv_setsv_mg (SV *const dsv, SV *const ssv) <br>
void sv_setsv_nomg (SV *dsv, SV *ssv)</p>

<p style="margin-left:11%;">&quot;sv_setuv&quot; <br>
&quot;sv_setuv_mg&quot;</p>

<p style="margin-left:17%;">These copy an unsigned integer
into the given <small>SV,</small> upgrading first if
necessary.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;sv_setuv_mg&quot; handles
&rsquo;set&rsquo; magic; &quot;sv_setuv&quot; does not.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_setuv
(SV *const sv, const UV num) <br>
void sv_setuv_mg(SV *const sv, const UV u)</p>

<p style="margin-left:11%;">&quot;sv_set_undef&quot;</p>

<p style="margin-left:17%;">Equivalent to
&quot;sv_setsv(sv, &amp;PL_sv_undef)&quot;, but more
efficient. Doesn&rsquo;t handle set magic.</p>

<p style="margin-left:17%; margin-top: 1em">The perl
equivalent is &quot;$sv = undef;&quot;. Note that it
doesn&rsquo;t free any string buffer, unlike &quot;undef
$sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Introduced in
perl 5.25.12.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_set_undef(SV *sv)</p>

<p style="margin-left:11%;">&quot;SvSHARE&quot;</p>

<p style="margin-left:17%;">Arranges for &quot;sv&quot; to
be shared between threads if a suitable module has been
loaded.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvSHARE(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvSHARED_HASH&quot;</p>

<p style="margin-left:17%;">Returns the hash for
&quot;sv&quot; created by &quot;newSVpvn_share&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">struct hek*
SvSHARED_HASH(SV * sv)</p>

<p style="margin-left:11%;">&quot;SvSTASH&quot;</p>

<p style="margin-left:17%;">Returns the stash of the
<small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">HV* SvSTASH(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvSTASH_set&quot;</p>

<p style="margin-left:17%;">Set the value of the
<small>STASH</small> pointer in &quot;sv&quot; to val. See
&quot;SvIV_set&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvSTASH_set(SV* sv, HV* val)</p>

<p style="margin-left:11%;">&quot;sv_streq&quot;</p>

<p style="margin-left:17%;">A convenient shortcut for
calling &quot;sv_streq_flags&quot; with the
&quot;SV_GMAGIC&quot; flag. This function basically behaves
like the Perl code &quot;$sv1 eq $sv2&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_streq(SV* sv1, SV* sv2)</p>

<p style="margin-left:11%;">&quot;sv_streq_flags&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the strings in the two SVs are identical. If the
flags argument has the &quot;SV_GMAGIC&quot; bit set, it
handles get-magic too. Will coerce its args to strings if
necessary. Treats &quot;NULL&quot; as undef. Correctly
handles the <small>UTF8</small> flag.</p>

<p style="margin-left:17%; margin-top: 1em">If flags does
not have the &quot;SV_SKIP_OVERLOAD&quot; bit set, an
attempt to use &quot;eq&quot; overloading will be made. If
such overloading does not exist or the flag is set, then
regular string comparison will be used instead.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_streq_flags(SV* sv1, SV* sv2, const U32 flags)</p>

<p style="margin-left:11%;">&quot;SvTRUE&quot; <br>
&quot;SvTRUEx&quot; <br>
&quot;SvTRUE_nomg&quot; <br>
&quot;SvTRUE_NN&quot; <br>
&quot;SvTRUE_nomg_NN&quot;</p>

<p style="margin-left:17%;">These return a boolean
indicating whether Perl would evaluate the <small>SV</small>
as true or false. See &quot;SvOK&quot; for a
defined/undefined test.</p>

<p style="margin-left:17%; margin-top: 1em">As of Perl
5.32, all are guaranteed to evaluate &quot;sv&quot; only
once. Prior to that release, only &quot;SvTRUEx&quot;
guaranteed single evaluation; now &quot;SvTRUEx&quot; is
identical to &quot;SvTRUE&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvTRUE_nomg&quot;
and &quot;TRUE_nomg_NN&quot; do not perform
&rsquo;get&rsquo; magic; the others do unless the scalar is
already &quot;SvPOK&quot;, &quot;SvIOK&quot;, or
&quot;SvNOK&quot; (the public, not the private flags).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvTRUE_NN&quot;
is like &quot;SvTRUE&quot;, but &quot;sv&quot; is assumed to
be non-null ( <small>NN</small> ). If there is a possibility
that it is <small>NULL,</small> use plain
&quot;SvTRUE&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvTRUE_nomg_NN&quot;
is like &quot;SvTRUE_nomg&quot;, but &quot;sv&quot; is
assumed to be non-null ( <small>NN</small> ). If there is a
possibility that it is <small>NULL,</small> use plain
&quot;SvTRUE_nomg&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool SvTRUE(SV
*sv)</p>

<p style="margin-left:11%;">&quot;SvTYPE&quot;</p>

<p style="margin-left:17%;">Returns the type of the
<small>SV.</small> See &quot;svtype&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">svtype
SvTYPE(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvUNLOCK&quot;</p>

<p style="margin-left:17%;">Releases a mutual exclusion
lock on &quot;sv&quot; if a suitable module has been
loaded.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvUNLOCK(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_unmagic&quot;</p>

<p style="margin-left:17%;">Removes all magic of type
&quot;type&quot; from an <small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">int
sv_unmagic(SV *const sv, const int type)</p>

<p style="margin-left:11%;">&quot;sv_unmagicext&quot;</p>

<p style="margin-left:17%;">Removes all magic of type
&quot;type&quot; with the specified &quot;vtbl&quot; from an
<small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">int
sv_unmagicext(SV *const sv, const int type, MGVTBL
*vtbl)</p>

<p style="margin-left:11%;">&quot;sv_unref&quot;</p>

<p style="margin-left:17%;">Unsets the <small>RV</small>
status of the <small>SV,</small> and decrements the
reference count of whatever was being referenced by the
<small>RV.</small> This can almost be thought of as a
reversal of &quot;newSVrv&quot;. This is
&quot;sv_unref_flags&quot; with the &quot;flag&quot; being
zero. See &quot;SvROK_off&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_unref(SV* sv)</p>

<p style="margin-left:11%;">&quot;sv_unref_flags&quot;</p>

<p style="margin-left:17%;">Unsets the <small>RV</small>
status of the <small>SV,</small> and decrements the
reference count of whatever was being referenced by the
<small>RV.</small> This can almost be thought of as a
reversal of &quot;newSVrv&quot;. The &quot;cflags&quot;
argument can contain &quot;SV_IMMEDIATE_UNREF&quot; to force
the reference count to be decremented (otherwise the
decrementing is conditional on the reference count being
different from one or the reference being a readonly
<small>SV</small> ). See &quot;SvROK_off&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_unref_flags(SV *const ref, const U32 flags)</p>

<p style="margin-left:11%;">&quot;SvUOK&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> contains an integer that must
be interpreted as unsigned. A non-negative integer whose
value is within the range of both an <small>IV</small> and a
<small>UV</small> may be flagged as either &quot;SvUOK&quot;
or &quot;SvIOK&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool SvUOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvUPGRADE&quot;</p>

<p style="margin-left:17%;">Used to upgrade an
<small>SV</small> to a more complex form. Uses
&quot;sv_upgrade&quot; to perform the upgrade if necessary.
See &quot;svtype&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvUPGRADE(SV* sv, svtype type)</p>

<p style="margin-left:11%;">&quot;sv_upgrade&quot;</p>

<p style="margin-left:17%;">Upgrade an <small>SV</small> to
a more complex form. Generally adds a new body type to the
<small>SV,</small> then copies across as much information as
possible from the old body. It croaks if the
<small>SV</small> is already in a more complex form than
requested. You generally want to use the
&quot;SvUPGRADE&quot; macro wrapper, which checks the type
before calling &quot;sv_upgrade&quot;, and hence does not
croak. See also &quot;svtype&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_upgrade(SV *const sv, svtype new_type)</p>

<p style="margin-left:11%;">&quot;sv_usepvn&quot; <br>
&quot;sv_usepvn_mg&quot; <br>
&quot;sv_usepvn_flags&quot;</p>

<p style="margin-left:17%;">These tell an <small>SV</small>
to use &quot;ptr&quot; for its string value. Normally SVs
have their string stored inside the <small>SV,</small> but
these tell the <small>SV</small> to use an external string
instead.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;ptr&quot;
should point to memory that was allocated by
&quot;&quot;Newx&quot;&quot;. It must be the start of a
&quot;Newx&quot;&minus;ed block of memory, and not a pointer
to the middle of it (beware of &quot;OOK&quot; and
copy-on-write), and not be from a non&minus;&quot;Newx&quot;
memory allocator like &quot;malloc&quot;. The string length,
&quot;len&quot;, must be supplied. By default this function
will &quot;&quot;Renew&quot;&quot; (i.e. realloc, move) the
memory pointed to by &quot;ptr&quot;, so that the pointer
should not be freed or used by the programmer after giving
it to &quot;sv_usepvn&quot;, and neither should any pointers
from &quot;behind&quot; that pointer (<i>e.g.</i>,
&quot;ptr&quot;&nbsp;+&nbsp;1) be used.</p>

<p style="margin-left:17%; margin-top: 1em">In the
&quot;sv_usepvn_flags&quot; form, if
&quot;flags&nbsp;&amp;&nbsp;SV_SMAGIC&quot; is true,
&quot;SvSETMAGIC&quot; is called before returning. And if
&quot;flags&nbsp;&amp;&nbsp;SV_HAS_TRAILING_NUL&quot; is
true, then &quot;ptr[len]&quot; must be &quot;NUL&quot;, and
the realloc will be skipped (<i>i.e.</i>, the buffer is
actually at least 1 byte longer than &quot;len&quot;, and
already meets the requirements for storing in
&quot;SvPVX&quot;).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_usepvn&quot;
is merely &quot;sv_usepvn_flags&quot; with &quot;flags&quot;
set to 0, so &rsquo;set&rsquo; magic is skipped.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_usepvn_mg&quot;
is merely &quot;sv_usepvn_flags&quot; with &quot;flags&quot;
set to &quot;SV_SMAGIC&quot;, so &rsquo;set&rsquo; magic is
performed.</p>

<p style="margin-left:17%; margin-top: 1em">void sv_usepvn
(SV* sv, char* ptr, STRLEN len) <br>
void sv_usepvn_mg (SV *sv, char *ptr, STRLEN len) <br>
void sv_usepvn_flags(SV *const sv, char* ptr, const STRLEN
len, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;SvUTF8&quot;</p>

<p style="margin-left:17%;">Returns a U32 value indicating
the <small>UTF&minus;8</small> status of an
<small>SV.</small> If things are set-up properly, this
indicates whether or not the <small>SV</small> contains
<small>UTF&minus;8</small> encoded data. You should use this
<i>after</i> a call to &quot;SvPV&quot; or one of its
variants, in case any call to string overloading updates the
internal flag.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
take into account the bytes pragma, use &quot;DO_UTF8&quot;
instead.</p>

<p style="margin-left:17%; margin-top: 1em">U32 SvUTF8(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_utf8_decode&quot;</p>

<p style="margin-left:17%;">If the <small>PV</small> of the
<small>SV</small> is an octet sequence in Perl&rsquo;s
extended <small>UTF&minus;8</small> and contains a
multiple-byte character, the &quot;SvUTF8&quot; flag is
turned on so that it looks like a character. If the
<small>PV</small> contains only single-byte characters, the
&quot;SvUTF8&quot; flag stays off. Scans <small>PV</small>
for validity and returns <small>FALSE</small> if the
<small>PV</small> is invalid <small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_utf8_decode(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_utf8_downgrade&quot;
<br>
&quot;sv_utf8_downgrade_flags&quot; <br>
&quot;sv_utf8_downgrade_nomg&quot;</p>

<p style="margin-left:17%;">These attempt to convert the
<small>PV</small> of an <small>SV</small> from characters to
bytes. If the <small>PV</small> contains a character that
cannot fit in a byte, this conversion will fail; in this
case, &quot;FALSE&quot; is returned if &quot;fail_ok&quot;
is true; otherwise they croak.</p>

<p style="margin-left:17%; margin-top: 1em">They are not a
general purpose Unicode to byte encoding interface: use the
&quot;Encode&quot; extension for that.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_utf8_downgrade&quot;
processes &rsquo;get&rsquo; magic on &quot;sv&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_utf8_downgrade_nomg&quot;
does not.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;sv_utf8_downgrade_flags&quot;
has an additional &quot;flags&quot; parameter in which you
can specify &quot;SV_GMAGIC&quot; to process
&rsquo;get&rsquo; magic, or leave it cleared to not process
&rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_utf8_downgrade (SV *const sv, const bool fail_ok) <br>
bool sv_utf8_downgrade_flags(SV *const sv, const bool
fail_ok, <br>
const U32 flags) <br>
bool sv_utf8_downgrade_nomg (SV *const sv, const bool
fail_ok)</p>

<p style="margin-left:11%;">&quot;sv_utf8_encode&quot;</p>

<p style="margin-left:17%;">Converts the <small>PV</small>
of an <small>SV</small> to <small>UTF&minus;8,</small> but
then turns the &quot;SvUTF8&quot; flag off so that it looks
like octets again.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_utf8_encode(SV *const sv)</p>

<p style="margin-left:11%;">&quot;sv_utf8_upgrade&quot;
<br>
&quot;sv_utf8_upgrade_nomg&quot; <br>
&quot;sv_utf8_upgrade_flags&quot; <br>
&quot;sv_utf8_upgrade_flags_grow&quot;</p>

<p style="margin-left:17%;">These convert the
<small>PV</small> of an <small>SV</small> to its
UTF&minus;8&minus;encoded form. The <small>SV</small> is
forced to string form if it is not already. They always set
the &quot;SvUTF8&quot; flag to avoid future validity checks
even if the whole string is the same in
<small>UTF&minus;8</small> as not. They return the number of
bytes in the converted string</p>

<p style="margin-left:17%; margin-top: 1em">The forms
differ in just two ways. The main difference is whether or
not they perform &rsquo;get magic&rsquo; on &quot;sv&quot;.
&quot;sv_utf8_upgrade_nomg&quot; skips &rsquo;get
magic&rsquo;; &quot;sv_utf8_upgrade&quot; performs it; and
&quot;sv_utf8_upgrade_flags&quot; and
&quot;sv_utf8_upgrade_flags_grow&quot; either perform it (if
the &quot;SV_GMAGIC&quot; bit is set in &quot;flags&quot;)
or don&rsquo;t (if that bit is cleared).</p>

<p style="margin-left:17%; margin-top: 1em">The other
difference is that &quot;sv_utf8_upgrade_flags_grow&quot;
has an additional parameter, &quot;extra&quot;, which allows
the caller to specify an amount of space to be reserved as
spare beyond what is needed for the actual conversion. This
is used when the caller knows it will soon be needing yet
more space, and it is more efficient to request space from
the system in a single call. This form is otherwise
identical to &quot;sv_utf8_upgrade_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">These are not a
general purpose byte encoding to Unicode interface: use the
Encode extension for that.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;SV_FORCE_UTF8_UPGRADE&quot; flag is now ignored.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
sv_utf8_upgrade (SV *sv) <br>
STRLEN sv_utf8_upgrade_nomg (SV *sv) <br>
STRLEN sv_utf8_upgrade_flags (SV *const sv, const I32 flags)
<br>
STRLEN sv_utf8_upgrade_flags_grow(SV *const sv, const I32
flags, <br>
STRLEN extra)</p>

<p style="margin-left:11%;">&quot;SvUTF8_off&quot;</p>

<p style="margin-left:17%;">Unsets the
<small>UTF&minus;8</small> status of an <small>SV</small>
(the data is not changed, just the flag). Do not use
frivolously.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvUTF8_off(SV *sv)</p>

<p style="margin-left:11%;">&quot;SvUTF8_on&quot;</p>

<p style="margin-left:17%;">Turn on the
<small>UTF&minus;8</small> status of an <small>SV</small>
(the data is not changed, just the flag). Do not use
frivolously.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvUTF8_on(SV *sv)</p>

<p style="margin-left:11%;">&quot;SvUV&quot; <br>
&quot;SvUVx&quot; <br>
&quot;SvUV_nomg&quot;</p>

<p style="margin-left:17%;">These coerce the given
<small>SV</small> to <small>UV</small> and return it. The
returned value in many circumstances will get stored in
&quot;sv&quot;&rsquo;s <small>UV</small> slot, but not in
all cases. (Use &quot;sv_setuv&quot; to make sure it
does).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvUVx&quot;
is different from the others in that it is guaranteed to
evaluate &quot;sv&quot; exactly once; the others may
evaluate it multiple times. Only use this form if
&quot;sv&quot; is an expression with side effects, otherwise
use the more efficient &quot;SvUV&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;SvUV_nomg&quot;
is the same as &quot;SvUV&quot;, but does not perform
&rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">UV SvUV(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvUV_set&quot;</p>

<p style="margin-left:17%;">Set the value of the
<small>UV</small> pointer in &quot;sv&quot; to val. See
&quot;SvIV_set&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvUV_set(SV* sv, UV val)</p>

<p style="margin-left:11%;">&quot;SvUVX&quot;</p>

<p style="margin-left:17%;">Returns the raw value in the
<small>SV</small> &rsquo;s <small>UV</small> slot, without
checks or conversions. Only use when you are sure
&quot;SvIOK&quot; is true. See also &quot;SvUV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">UV SvUVX(SV*
sv)</p>

<p style="margin-left:11%;">&quot;SvUVXx&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;SvUVXx&quot; from a future
release of Perl. Do not use it for new code; remove it from
existing code.</p>

<p style="margin-left:17%; margin-top: 1em">This is an
unnecessary synonym for &quot;SvUVX&quot;</p>

<p style="margin-left:17%; margin-top: 1em">UV SvUVXx(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_vcatpvf&quot; <br>
&quot;sv_vcatpvf_mg&quot;</p>

<p style="margin-left:17%;">These process their arguments
like &quot;sv_vcatpvfn&quot; called with a non-null
C&minus;style variable argument list, and append the
formatted output to &quot;sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;sv_vcatpvf_mg&quot; performs
&rsquo;set&rsquo; magic; &quot;sv_vcatpvf&quot; skips
&rsquo;set&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">Both perform
&rsquo;get&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">They are
usually accessed via their frontends &quot;sv_catpvf&quot;
and &quot;sv_catpvf_mg&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_vcatpvf(SV *const sv, const char *const pat, <br>
va_list *const args)</p>

<p style="margin-left:11%;">&quot;sv_vcatpvfn&quot; <br>
&quot;sv_vcatpvfn_flags&quot;</p>

<p style="margin-left:17%;">These process their arguments
like vsprintf(3) and append the formatted output to an
<small>SV.</small> They use an array of SVs if the
C&minus;style variable argument list is missing
(&quot;NULL&quot;). Argument reordering (using format
specifiers like &quot;%2$d&quot; or &quot;%*2$d&quot;) is
supported only when using an array of SVs; using a
C&minus;style &quot;va_list&quot; argument list with a
format string that uses argument reordering will yield an
exception.</p>

<p style="margin-left:17%; margin-top: 1em">When running
with taint checks enabled, they indicate via
&quot;maybe_tainted&quot; if results are untrustworthy
(often due to the use of locales).</p>

<p style="margin-left:17%; margin-top: 1em">They assume
that &quot;pat&quot; has the same utf8&minus;ness as
&quot;sv&quot;. It&rsquo;s the caller&rsquo;s responsibility
to ensure that this is so.</p>

<p style="margin-left:17%; margin-top: 1em">They differ in
that &quot;sv_vcatpvfn_flags&quot; has a &quot;flags&quot;
parameter in which you can set or clear the
&quot;SV_GMAGIC&quot; and/or <small>SV_SMAGIC</small> flags,
to specify which magic to handle or not handle; whereas
plain &quot;sv_vcatpvfn&quot; always specifies both
&rsquo;get&rsquo; and &rsquo;set&rsquo; magic.</p>

<p style="margin-left:17%; margin-top: 1em">They are
usually used via one of the frontends
&quot;&quot;sv_vcatpvf&quot;&quot; and
&quot;&quot;sv_vcatpvf_mg&quot;&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_vcatpvfn (SV *const sv, const char *const pat, <br>
const STRLEN patlen, va_list *const args, <br>
SV **const svargs, const Size_t sv_count, <br>
bool *const maybe_tainted) <br>
void sv_vcatpvfn_flags(SV *const sv, const char *const pat,
<br>
const STRLEN patlen, va_list *const args, <br>
SV **const svargs, const Size_t sv_count, <br>
bool *const maybe_tainted, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;SvVOK&quot;</p>

<p style="margin-left:17%;">Returns a boolean indicating
whether the <small>SV</small> contains a v&minus;string.</p>

<p style="margin-left:17%; margin-top: 1em">bool SvVOK(SV*
sv)</p>

<p style="margin-left:11%;">&quot;sv_vsetpvf&quot; <br>
&quot;sv_vsetpvf_mg&quot;</p>

<p style="margin-left:17%;">These work like
&quot;sv_vcatpvf&quot; but copy the text into the
<small>SV</small> instead of appending it.</p>

<p style="margin-left:17%; margin-top: 1em">They differ
only in that &quot;sv_vsetpvf_mg&quot; performs
&rsquo;set&rsquo; magic; &quot;sv_vsetpvf&quot; skips all
magic.</p>

<p style="margin-left:17%; margin-top: 1em">They are
usually used via their frontends, &quot;sv_setpvf&quot; and
&quot;sv_setpvf_mg&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_vsetpvf(SV *const sv, const char *const pat, <br>
va_list *const args)</p>

<p style="margin-left:11%;">&quot;sv_vsetpvfn&quot;</p>

<p style="margin-left:17%;">Works like
&quot;sv_vcatpvfn&quot; but copies the text into the
<small>SV</small> instead of appending it.</p>

<p style="margin-left:17%; margin-top: 1em">Usually used
via one of its frontends &quot;&quot;sv_vsetpvf&quot;&quot;
and &quot;&quot;sv_vsetpvf_mg&quot;&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_vsetpvfn(SV *const sv, const char *const pat, <br>
const STRLEN patlen, va_list *const args, <br>
SV **const svargs, const Size_t sv_count, <br>
bool *const maybe_tainted)</p>

<p style="margin-left:11%;">&quot;SvVSTRING_mg&quot;</p>

<p style="margin-left:17%;">Returns the vstring magic, or
<small>NULL</small> if none</p>

<p style="margin-left:17%; margin-top: 1em">MAGIC*
SvVSTRING_mg(SV * sv)</p>

<p style="margin-left:11%;">&quot;vnewSVpvf&quot;</p>

<p style="margin-left:17%;">Like &quot;newSVpvf&quot; but
the arguments are an encapsulated argument list.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
vnewSVpvf(const char *const pat, va_list *const args)</p>

<h2>Tainting
<a name="Tainting"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;SvTAINT&quot;</p>

<p style="margin-left:17%;">Taints an <small>SV</small> if
tainting is enabled, and if some input to the current
expression is tainted--usually a variable, but possibly also
implicit inputs such as locale settings. &quot;SvTAINT&quot;
propagates that taintedness to the outputs of an expression
in a pessimistic fashion; i.e., without paying attention to
precisely which outputs are influenced by which inputs.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvTAINT(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvTAINTED&quot;</p>

<p style="margin-left:17%;">Checks to see if an
<small>SV</small> is tainted. Returns <small>TRUE</small> if
it is, <small>FALSE</small> if not.</p>

<p style="margin-left:17%; margin-top: 1em">bool
SvTAINTED(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvTAINTED_off&quot;</p>

<p style="margin-left:17%;">Untaints an <small>SV.</small>
Be <i>very</i> careful with this routine, as it
short-circuits some of Perl&rsquo;s fundamental security
features. <small>XS</small> module authors should not use
this function unless they fully understand all the
implications of unconditionally untainting the value.
Untainting should be done in the standard perl fashion, via
a carefully crafted regexp, rather than directly untainting
variables.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvTAINTED_off(SV* sv)</p>

<p style="margin-left:11%;">&quot;SvTAINTED_on&quot;</p>

<p style="margin-left:17%;">Marks an <small>SV</small> as
tainted if tainting is enabled.</p>

<p style="margin-left:17%; margin-top: 1em">void
SvTAINTED_on(SV* sv)</p>

<h2>Time
<a name="Time"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;ASCTIME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;asctime_r&quot;. It is zero if
&quot;d_asctime_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_asctime_r&quot; is defined.</p>

<p style="margin-left:11%;">&quot;CTIME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;ctime_r&quot;. It is zero if
&quot;d_ctime_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_ctime_r&quot; is defined.</p>

<p style="margin-left:11%;">&quot;GMTIME_MAX&quot;</p>

<p style="margin-left:17%;">This symbol contains the
maximum value for the &quot;time_t&quot; offset that the
system function gmtime () accepts, and defaults to 0</p>

<p style="margin-left:11%;">&quot;GMTIME_MIN&quot;</p>

<p style="margin-left:17%;">This symbol contains the
minimum value for the &quot;time_t&quot; offset that the
system function gmtime () accepts, and defaults to 0</p>

<p style="margin-left:11%;">&quot;GMTIME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;gmtime_r&quot;. It is zero if
&quot;d_gmtime_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_gmtime_r&quot; is defined.</p>

<p style="margin-left:11%;">&quot;HAS_ASCTIME64&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;asctime64&quot; () routine is
available to do the 64bit variant of asctime ()</p>

<p style="margin-left:11%;">&quot;HAS_ASCTIME_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;asctime_r&quot; routine is
available to asctime re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_CTIME64&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;ctime64&quot; () routine is
available to do the 64bit variant of ctime ()</p>

<p style="margin-left:11%;">&quot;HAS_CTIME_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;ctime_r&quot; routine is available
to ctime re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_DIFFTIME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;difftime&quot; routine is
available.</p>

<p style="margin-left:11%;">&quot;HAS_DIFFTIME64&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;difftime64&quot; () routine is
available to do the 64bit variant of difftime ()</p>

<p style="margin-left:11%;">&quot;HAS_FUTIMES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;futimes&quot; routine is available
to change file descriptor time stamps with &quot;struct
timevals&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_GETITIMER&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;getitimer&quot; routine is
available to return interval timers.</p>


<p style="margin-left:11%;">&quot;HAS_GETTIMEOFDAY&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;gettimeofday()&quot; system call is
available for a sub-second accuracy clock. Usually, the file
<i>sys/resource.h</i> needs to be included (see
&quot;I_SYS_RESOURCE&quot;). The type &quot;Timeval&quot;
should be used to refer to &quot;&quot;struct
timeval&quot;&quot;.</p>

<p style="margin-left:11%;">&quot;HAS_GMTIME64&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;gmtime64&quot; () routine is
available to do the 64bit variant of gmtime ()</p>

<p style="margin-left:11%;">&quot;HAS_GMTIME_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;gmtime_r&quot; routine is available
to gmtime re-entrantly.</p>


<p style="margin-left:11%;">&quot;HAS_LOCALTIME64&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;localtime64&quot; () routine is
available to do the 64bit variant of localtime ()</p>


<p style="margin-left:11%;">&quot;HAS_LOCALTIME_R&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;localtime_r&quot; routine is
available to localtime re-entrantly.</p>

<p style="margin-left:11%;">&quot;HAS_MKTIME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;mktime&quot; routine is
available.</p>

<p style="margin-left:11%;">&quot;HAS_MKTIME64&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;mktime64&quot; () routine is
available to do the 64bit variant of mktime ()</p>

<p style="margin-left:11%;">&quot;HAS_NANOSLEEP&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;nanosleep&quot; system call is
available to sleep with 1E&minus;9 sec accuracy.</p>

<p style="margin-left:11%;">&quot;HAS_SETITIMER&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;setitimer&quot; routine is
available to set interval timers.</p>

<p style="margin-left:11%;">&quot;HAS_STRFTIME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;strftime&quot; routine is available
to do time formatting.</p>

<p style="margin-left:11%;">&quot;HAS_TIME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;time()&quot; routine exists.</p>

<p style="margin-left:11%;">&quot;HAS_TIMEGM&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;timegm&quot; routine is available
to do the opposite of gmtime ()</p>

<p style="margin-left:11%;">&quot;HAS_TIMES&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;times()&quot; routine exists. Note
that this became obsolete on some systems
(&quot;SUNOS&quot;), which now use &quot;getrusage()&quot;.
It may be necessary to include <i>sys/times.h</i>.</p>


<p style="margin-left:11%;">&quot;HAS_TM_TM_GMTOFF&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that the &quot;struct tm&quot;
has a &quot;tm_gmtoff&quot; field.</p>

<p style="margin-left:11%;">&quot;HAS_TM_TM_ZONE&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that the &quot;struct tm&quot;
has a &quot;tm_zone&quot; field.</p>

<p style="margin-left:11%;">&quot;HAS_TZNAME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;tzname[]&quot; array is available
to access timezone names.</p>

<p style="margin-left:11%;">&quot;HAS_USLEEP&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the &quot;usleep&quot; routine is available
to let the process sleep on a sub-second accuracy.</p>


<p style="margin-left:11%;">&quot;HAS_USLEEP_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates that the system provides a prototype for the
&quot;usleep()&quot; function. Otherwise, it is up to the
program to supply one. A good guess is</p>

<p style="margin-left:17%; margin-top: 1em">extern int
usleep(useconds_t);</p>

<p style="margin-left:11%;">&quot;I_TIME&quot;</p>

<p style="margin-left:17%;">This symbol is always defined,
and indicates to the C program that it should include
<i>time.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef I_TIME
<br>
#include &lt;time.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;I_UTIME&quot;</p>

<p style="margin-left:17%;">This symbol, if defined,
indicates to the C program that it should include
<i>utime.h</i>.</p>

<p style="margin-left:17%; margin-top: 1em">#ifdef I_UTIME
<br>
#include &lt;utime.h&gt; <br>
#endif</p>

<p style="margin-left:11%;">&quot;LOCALTIME_MAX&quot;</p>

<p style="margin-left:17%;">This symbol contains the
maximum value for the &quot;time_t&quot; offset that the
system function localtime () accepts, and defaults to 0</p>

<p style="margin-left:11%;">&quot;LOCALTIME_MIN&quot;</p>

<p style="margin-left:17%;">This symbol contains the
minimum value for the &quot;time_t&quot; offset that the
system function localtime () accepts, and defaults to 0</p>


<p style="margin-left:11%;">&quot;LOCALTIME_R_NEEDS_TZSET&quot;</p>

<p style="margin-left:17%;">Many libc&rsquo;s
&quot;localtime_r&quot; implementations do not call tzset,
making them differ from &quot;localtime()&quot;, and making
timezone changes using $&quot;ENV&quot;{ <small>TZ</small> }
without explicitly calling tzset impossible. This symbol
makes us call tzset before &quot;localtime_r&quot;</p>


<p style="margin-left:11%;">&quot;LOCALTIME_R_PROTO&quot;</p>

<p style="margin-left:17%;">This symbol encodes the
prototype of &quot;localtime_r&quot;. It is zero if
&quot;d_localtime_r&quot; is undef, and one of the
&quot;REENTRANT_PROTO_T_ABC&quot; macros of <i>reentr.h</i>
if &quot;d_localtime_r&quot; is defined.</p>

<p style="margin-left:11%;">&quot;L_R_TZSET&quot;</p>

<p style="margin-left:17%;">If &quot;localtime_r()&quot;
needs tzset, it is defined in this define</p>

<p style="margin-left:11%;">&quot;mini_mktime&quot;</p>

<p style="margin-left:17%;">normalise
&quot;struct&nbsp;tm&quot; values without the
<b>localtime()</b> semantics (and overhead) of
<b>mktime()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">void
mini_mktime(struct tm *ptm)</p>

<p style="margin-left:11%;">&quot;my_strftime&quot;</p>

<p style="margin-left:17%;"><b>strftime()</b>, but with a
different <small>API</small> so that the return value is a
pointer to the formatted result (which <small>MUST</small>
be arranged to be <small>FREED BY THE CALLER</small> ). This
allows this function to increase the buffer size as needed,
so that the caller doesn&rsquo;t have to worry about
that.</p>

<p style="margin-left:17%; margin-top: 1em">Note that yday
and wday effectively are ignored by this function, as
<b>mini_mktime()</b> overwrites them</p>

<p style="margin-left:17%; margin-top: 1em">Also note that
this is always executed in the underlying locale of the
program, giving localized results.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;my_strftime&quot; must be explicitly called as
&quot;Perl_my_strftime&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">char *
Perl_my_strftime(pTHX_ const char *fmt, int sec, int min,
<br>
int hour, int mday, int mon, int year, <br>
int wday, int yday, int isdst)</p>

<h2>Typedef names
<a name="Typedef names"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;DB_Hash_t&quot;</p>

<p style="margin-left:17%;">This symbol contains the type
of the prefix structure element in the <i>db.h</i> header
file. In older versions of <small>DB,</small> it was int,
while in newer ones it is &quot;size_t&quot;.</p>

<p style="margin-left:11%;">&quot;DB_Prefix_t&quot;</p>

<p style="margin-left:17%;">This symbol contains the type
of the prefix structure element in the <i>db.h</i> header
file. In older versions of <small>DB,</small> it was int,
while in newer ones it is &quot;u_int32_t&quot;.</p>

<p style="margin-left:11%;">&quot;Direntry_t&quot;</p>

<p style="margin-left:17%;">This symbol is set to
&rsquo;&quot;struct direct&quot;&rsquo; or
&rsquo;&quot;struct dirent&quot;&rsquo; depending on whether
dirent is available or not. You should use this pseudo type
to portably declare your directory entries.</p>

<p style="margin-left:11%;">&quot;Fpos_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
to declare file positions in libc. It can be
&quot;fpos_t&quot;, long, uint, etc... It may be necessary
to include <i>sys/types.h</i> to get any typedef&rsquo;ed
information.</p>

<p style="margin-left:11%;">&quot;Free_t&quot;</p>

<p style="margin-left:17%;">This variable contains the
return type of &quot;free()&quot;. It is usually void, but
occasionally int.</p>

<p style="margin-left:11%;">&quot;Gid_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the return
type of &quot;getgid()&quot; and the type of argument to
&quot;setrgid()&quot; and related functions. Typically, it
is the type of group ids in the kernel. It can be int,
ushort, &quot;gid_t&quot;, etc... It may be necessary to
include <i>sys/types.h</i> to get any typedef&rsquo;ed
information.</p>

<p style="margin-left:11%;">&quot;Gid_t_f&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a &quot;Gid_t&quot;.</p>

<p style="margin-left:11%;">&quot;Gid_t_sign&quot;</p>

<p style="margin-left:17%;">This symbol holds the
signedness of a &quot;Gid_t&quot;. 1 for unsigned, &minus;1
for signed.</p>

<p style="margin-left:11%;">&quot;Gid_t_size&quot;</p>

<p style="margin-left:17%;">This symbol holds the size of a
&quot;Gid_t&quot; in bytes.</p>

<p style="margin-left:11%;">&quot;Groups_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
for the second argument to &quot;getgroups()&quot; and
&quot;setgroups()&quot;. Usually, this is the same as
gidtype (&quot;gid_t&quot;) , but sometimes it isn&rsquo;t.
It can be int, ushort, &quot;gid_t&quot;, etc... It may be
necessary to include <i>sys/types.h</i> to get any
typedef&rsquo;ed information. This is only required if you
have &quot;getgroups()&quot; or
&quot;setgroups()&quot;..</p>

<p style="margin-left:11%;">&quot;Malloc_t&quot;</p>

<p style="margin-left:17%;">This symbol is the type of
pointer returned by malloc and realloc.</p>

<p style="margin-left:11%;">&quot;Mmap_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the return
type of the &quot;mmap()&quot; system call (and
simultaneously the type of the first argument). Usually set
to &rsquo;void *&rsquo; or
&rsquo;&quot;caddr_t&quot;&rsquo;.</p>

<p style="margin-left:11%;">&quot;Mode_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
to declare file modes for systems calls. It is usually
&quot;mode_t&quot;, but may be int or unsigned short. It may
be necessary to include <i>sys/types.h</i> to get any
typedef&rsquo;ed information.</p>

<p style="margin-left:11%;">&quot;Netdb_hlen_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
for the 2nd argument to &quot;gethostbyaddr()&quot;.</p>

<p style="margin-left:11%;">&quot;Netdb_host_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
for the 1st argument to &quot;gethostbyaddr()&quot;.</p>

<p style="margin-left:11%;">&quot;Netdb_name_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
for the argument to &quot;gethostbyname()&quot;.</p>

<p style="margin-left:11%;">&quot;Netdb_net_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
for the 1st argument to &quot;getnetbyaddr()&quot;.</p>

<p style="margin-left:11%;">&quot;Off_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
to declare offsets in the kernel. It can be int, long,
&quot;off_t&quot;, etc... It may be necessary to include
<i>sys/types.h</i> to get any typedef&rsquo;ed
information.</p>

<p style="margin-left:11%;">&quot;Off_t_size&quot;</p>

<p style="margin-left:17%;">This symbol holds the number of
bytes used by the &quot;Off_t&quot;.</p>

<p style="margin-left:11%;">&quot;Pid_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
to declare process ids in the kernel. It can be int, uint,
&quot;pid_t&quot;, etc... It may be necessary to include
<i>sys/types.h</i> to get any typedef&rsquo;ed
information.</p>

<p style="margin-left:11%;">&quot;Rand_seed_t&quot;</p>

<p style="margin-left:17%;">This symbol defines the type of
the argument of the random seed function.</p>


<p style="margin-left:11%;">&quot;Select_fd_set_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
for the 2nd, 3rd, and 4th arguments to select. Usually, this
is &rsquo;&quot;fd_set&quot; *&rsquo;, if
&quot;HAS_FD_SET&quot; is defined, and &rsquo;int *&rsquo;
otherwise. This is only useful if you have
&quot;select()&quot;, of course.</p>

<p style="margin-left:11%;">&quot;Shmat_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the return
type of the &quot;shmat()&quot; system call. Usually set to
&rsquo;void *&rsquo; or &rsquo;char *&rsquo;.</p>

<p style="margin-left:11%;">&quot;Signal_t&quot;</p>

<p style="margin-left:17%;">This symbol&rsquo;s value is
either &quot;void&quot; or &quot;int&quot;, corresponding to
the appropriate return type of a signal handler. Thus, you
can declare a signal handler using
&quot;&quot;Signal_t&quot; (*handler)()&quot;, and define
the handler using &quot;&quot;Signal_t&quot;
&quot;handler(sig)&quot;&quot;.</p>

<p style="margin-left:11%;">&quot;Size_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
to declare length parameters for string functions. It is
usually &quot;size_t&quot;, but may be unsigned long, int,
etc. It may be necessary to include <i>sys/types.h</i> to
get any typedef&rsquo;ed information.</p>

<p style="margin-left:11%;">&quot;Size_t_size&quot;</p>

<p style="margin-left:17%;">This symbol holds the size of a
&quot;Size_t&quot; in bytes.</p>

<p style="margin-left:11%;">&quot;Sock_size_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
for the size argument of various socket calls (just the base
type, not the pointer-to).</p>

<p style="margin-left:11%;">&quot;SSize_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
by functions that return a count of bytes or an error
condition. It must be a signed type. It is usually
&quot;ssize_t&quot;, but may be long or int, etc. It may be
necessary to include <i>sys/types.h</i> or <i>unistd.h</i>
to get any typedef&rsquo;ed information. We will pick a type
such that &quot;sizeof(SSize_t)&quot; ==
&quot;sizeof(Size_t)&quot;.</p>

<p style="margin-left:11%;">&quot;Time_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type
returned by &quot;time()&quot;. It can be long, or
&quot;time_t&quot; on &quot;BSD&quot; sites (in which case
<i>sys/types.h</i> should be included).</p>

<p style="margin-left:11%;">&quot;Uid_t&quot;</p>

<p style="margin-left:17%;">This symbol holds the type used
to declare user ids in the kernel. It can be int, ushort,
&quot;uid_t&quot;, etc... It may be necessary to include
<i>sys/types.h</i> to get any typedef&rsquo;ed
information.</p>

<p style="margin-left:11%;">&quot;Uid_t_f&quot;</p>

<p style="margin-left:17%;">This symbol defines the format
string used for printing a &quot;Uid_t&quot;.</p>

<p style="margin-left:11%;">&quot;Uid_t_sign&quot;</p>

<p style="margin-left:17%;">This symbol holds the
signedness of a &quot;Uid_t&quot;. 1 for unsigned, &minus;1
for signed.</p>

<p style="margin-left:11%;">&quot;Uid_t_size&quot;</p>

<p style="margin-left:17%;">This symbol holds the size of a
&quot;Uid_t&quot; in bytes.</p>

<h2>Unicode Support
<a name="Unicode Support"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">&quot;Unicode
Support&quot; in perlguts has an introduction to this
<small>API.</small></p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Character classification&quot;, &quot;Character case
changing&quot;, and &quot;String Handling&quot;. Various
functions outside this section also work specially with
Unicode. Search for the string &quot;utf8&quot; in this
document. <br>
&quot;BOM_UTF8&quot;</p>

<p style="margin-left:17%;">This is a macro that evaluates
to a string constant of the <small>UTF&minus;8</small> bytes
that define the Unicode <small>BYTE ORDER MARK</small>
(U+FEFF) for the platform that perl is compiled on. This
allows code to use a mnemonic for this character that works
on both <small>ASCII</small> and <small>EBCDIC</small>
platforms. &quot;sizeof(BOM_UTF8)&nbsp;&minus;&nbsp;1&quot;
can be used to get its length in bytes.</p>

<p style="margin-left:11%;">&quot;bytes_cmp_utf8&quot;</p>

<p style="margin-left:17%;">Compares the sequence of
characters (stored as octets) in &quot;b&quot;,
&quot;blen&quot; with the sequence of characters (stored as
<small>UTF&minus;8</small> ) in &quot;u&quot;,
&quot;ulen&quot;. Returns 0 if they are equal, &minus;1 or
&minus;2 if the first string is less than the second string,
+1 or +2 if the first string is greater than the second
string.</p>

<p style="margin-left:17%; margin-top: 1em">&minus;1 or +1
is returned if the shorter string was identical to the start
of the longer string. &minus;2 or +2 is returned if there
was a difference between characters within the strings.</p>

<p style="margin-left:17%; margin-top: 1em">int
bytes_cmp_utf8(const U8 *b, STRLEN blen, const U8 *u, <br>
STRLEN ulen)</p>


<p style="margin-left:11%;">&quot;bytes_from_utf8&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;bytes_from_utf8&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Converts a
potentially <small>UTF&minus;8</small> encoded string
&quot;s&quot; of length *lenp into native byte encoding. On
input, the boolean *is_utf8p gives whether or not
&quot;s&quot; is actually encoded in
<small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">Unlike
&quot;utf8_to_bytes&quot; but like
&quot;bytes_to_utf8&quot;, this is non-destructive of the
input string.</p>

<p style="margin-left:17%; margin-top: 1em">Do nothing if
*is_utf8p is 0, or if there are code points in the string
not expressible in native byte encoding. In these cases,
*is_utf8p and *lenp are unchanged, and the return value is
the original &quot;s&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise,
*is_utf8p is set to 0, and the return value is a pointer to
a newly created string containing a downgraded copy of
&quot;s&quot;, and whose length is returned in *lenp,
updated. The new string is &quot;NUL&quot;&minus;terminated.
The caller is responsible for arranging for the memory used
by this string to get freed.</p>

<p style="margin-left:17%; margin-top: 1em">Upon successful
return, the number of variants in the string can be computed
by having saved the value of *lenp before the call, and
subtracting the after-call value of *lenp from it.</p>

<p style="margin-left:17%; margin-top: 1em">U8*
bytes_from_utf8(const U8 *s, STRLEN *lenp, bool
*is_utf8p)</p>

<p style="margin-left:11%;">&quot;bytes_to_utf8&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;bytes_to_utf8&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Converts a
string &quot;s&quot; of length *lenp bytes from the native
encoding into <small>UTF&minus;8.</small> Returns a pointer
to the newly-created string, and sets *lenp to reflect the
new length in bytes. The caller is responsible for arranging
for the memory used by this string to get freed.</p>

<p style="margin-left:17%; margin-top: 1em">Upon successful
return, the number of variants in the string can be computed
by having saved the value of *lenp before the call, and
subtracting it from the after-call value of *lenp.</p>

<p style="margin-left:17%; margin-top: 1em">A
&quot;NUL&quot; character will be written after the end of
the string.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
convert to <small>UTF&minus;8</small> from encodings other
than the native (Latin1 or <small>EBCDIC</small> ), see
&quot;sv_recode_to_utf8&quot;().</p>

<p style="margin-left:17%; margin-top: 1em">U8*
bytes_to_utf8(const U8 *s, STRLEN *lenp)</p>

<p style="margin-left:11%;">&quot;DO_UTF8&quot;</p>

<p style="margin-left:17%;">Returns a bool giving whether
or not the <small>PV</small> in &quot;sv&quot; is to be
treated as being encoded in <small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">You should use
this <i>after</i> a call to &quot;SvPV()&quot; or one of its
variants, in case any call to string overloading updates the
internal <small>UTF&minus;8</small> encoding flag.</p>

<p style="margin-left:17%; margin-top: 1em">bool
DO_UTF8(SV* sv)</p>

<p style="margin-left:11%;">&quot;foldEQ_utf8&quot;</p>

<p style="margin-left:17%;">Returns true if the leading
portions of the strings &quot;s1&quot; and &quot;s2&quot;
(either or both of which may be in
<small>UTF&minus;8</small> ) are the same
case-insensitively; false otherwise. How far into the
strings to compare is determined by other input
parameters.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;u1&quot; is true, the string &quot;s1&quot; is assumed
to be in UTF&minus;8&minus;encoded Unicode; otherwise it is
assumed to be in native 8&minus;bit encoding.
Correspondingly for &quot;u2&quot; with respect to
&quot;s2&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If the byte
length &quot;l1&quot; is non-zero, it says how far into
&quot;s1&quot; to check for fold equality. In other words,
&quot;s1&quot;+&quot;l1&quot; will be used as a goal to
reach. The scan will not be considered to be a match unless
the goal is reached, and scanning won&rsquo;t continue past
that goal. Correspondingly for &quot;l2&quot; with respect
to &quot;s2&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;pe1&quot; is non&minus;&quot;NULL&quot; and the
pointer it points to is not &quot;NULL&quot;, that pointer
is considered an end pointer to the position 1 byte past the
maximum point in &quot;s1&quot; beyond which scanning will
not continue under any circumstances. (This routine assumes
that <small>UTF&minus;8</small> encoded input strings are
not malformed; malformed input can cause it to read past
&quot;pe1&quot;). This means that if both &quot;l1&quot; and
&quot;pe1&quot; are specified, and &quot;pe1&quot; is less
than &quot;s1&quot;+&quot;l1&quot;, the match will never be
successful because it can never get as far as its goal (and
in fact is asserted against). Correspondingly for
&quot;pe2&quot; with respect to &quot;s2&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">At least one of
&quot;s1&quot; and &quot;s2&quot; must have a goal (at least
one of &quot;l1&quot; and &quot;l2&quot; must be non-zero),
and if both do, both have to be reached for a successful
match. Also, if the fold of a character is multiple
characters, all of them must be matched (see tr21 reference
below for &rsquo;folding&rsquo;).</p>

<p style="margin-left:17%; margin-top: 1em">Upon a
successful match, if &quot;pe1&quot; is
non&minus;&quot;NULL&quot;, it will be set to point to the
beginning of the <i>next</i> character of &quot;s1&quot;
beyond what was matched. Correspondingly for &quot;pe2&quot;
and &quot;s2&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">For
case-insensitiveness, the &quot;casefolding&quot; of Unicode
is used instead of upper/lowercasing both the characters,
see &lt;https://www.unicode.org/reports/tr21/&gt; (Case
Mappings).</p>

<p style="margin-left:17%; margin-top: 1em">I32
foldEQ_utf8(const char *s1, char **pe1, UV l1, bool u1, <br>
const char *s2, char **pe2, UV l2, bool u2)</p>


<p style="margin-left:11%;">&quot;is_ascii_string&quot;</p>

<p style="margin-left:17%;">This is a misleadingly-named
synonym for &quot;is_utf8_invariant_string&quot;. On
ASCII-ish platforms, the name isn&rsquo;t misleading: the
ASCII-range characters are exactly the
<small>UTF&minus;8</small> invariants. But
<small>EBCDIC</small> machines have more invariants than
just the <small>ASCII</small> characters, so
&quot;is_utf8_invariant_string&quot; is preferred.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_ascii_string(const U8* const s, STRLEN len)</p>


<p style="margin-left:11%;">&quot;is_c9strict_utf8_string&quot;</p>

<p style="margin-left:17%;">Returns <small>TRUE</small> if
the first &quot;len&quot; bytes of string &quot;s&quot; form
a valid UTF&minus;8&minus;encoded string that conforms to
Unicode Corrigendum #9
&lt;http://www.unicode.org/versions/corrigendum9.html&gt;;
otherwise it returns <small>FALSE.</small> If
&quot;len&quot; is 0, it will be calculated using strlen(s)
(which means if you use this option, that &quot;s&quot;
can&rsquo;t have embedded &quot;NUL&quot; characters and has
to have a terminating &quot;NUL&quot; byte). Note that all
characters being <small>ASCII</small> constitute &rsquo;a
valid <small>UTF&minus;8</small> string&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">This function
returns <small>FALSE</small> for strings containing any code
points above the Unicode max of 0x10FFFF or surrogate code
points, but accepts non-character code points per
Corrigendum #9
&lt;http://www.unicode.org/versions/corrigendum9.html&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_invariant_string&quot;,
&quot;is_utf8_invariant_string_loc&quot;,
&quot;is_utf8_string&quot;,
&quot;is_utf8_string_flags&quot;,
&quot;is_utf8_string_loc&quot;,
&quot;is_utf8_string_loc_flags&quot;,
&quot;is_utf8_string_loclen&quot;,
&quot;is_utf8_string_loclen_flags&quot;,
&quot;is_utf8_fixed_width_buf_flags&quot;,
&quot;is_utf8_fixed_width_buf_loc_flags&quot;,
&quot;is_utf8_fixed_width_buf_loclen_flags&quot;,
&quot;is_strict_utf8_string&quot;,
&quot;is_strict_utf8_string_loc&quot;,
&quot;is_strict_utf8_string_loclen&quot;,
&quot;is_c9strict_utf8_string_loc&quot;, and
&quot;is_c9strict_utf8_string_loclen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_c9strict_utf8_string(const U8 *s, STRLEN len)</p>


<p style="margin-left:11%;">&quot;is_c9strict_utf8_string_loc&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_c9strict_utf8_string&quot; but stores the location
of the failure (in the case of &quot;utf8ness failure&quot;)
or the location &quot;s&quot;+&quot;len&quot; (in the case
of &quot;utf8ness success&quot;) in the &quot;ep&quot;
pointer.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_c9strict_utf8_string_loclen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_c9strict_utf8_string_loc(const U8 *s, STRLEN len, <br>
const U8 **ep)</p>


<p style="margin-left:11%;">&quot;is_c9strict_utf8_string_loclen&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_c9strict_utf8_string&quot; but stores the location
of the failure (in the case of &quot;utf8ness failure&quot;)
or the location &quot;s&quot;+&quot;len&quot; (in the case
of &quot;utf8ness success&quot;) in the &quot;ep&quot;
pointer, and the number of <small>UTF&minus;8</small>
encoded characters in the &quot;el&quot; pointer.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_c9strict_utf8_string_loc&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_c9strict_utf8_string_loclen(const U8 *s, STRLEN len, <br>
const U8 **ep, STRLEN *el)</p>


<p style="margin-left:11%;">&quot;isC9_STRICT_UTF8_CHAR&quot;</p>

<p style="margin-left:17%;">Evaluates to non-zero if the
first few bytes of the string starting at &quot;s&quot; and
looking no further than &quot;e&nbsp;&minus;&nbsp;1&quot;
are well-formed <small>UTF&minus;8</small> that represents
some Unicode non-surrogate code point; otherwise it
evaluates to 0. If non-zero, the value gives how many bytes
starting at &quot;s&quot; comprise the code point&rsquo;s
representation. Any bytes remaining before &quot;e&quot;,
but beyond the ones needed to form the first code point in
&quot;s&quot;, are not examined.</p>

<p style="margin-left:17%; margin-top: 1em">The largest
acceptable code point is the Unicode maximum 0x10FFFF. This
differs from &quot;isSTRICT_UTF8_CHAR&quot; only in that it
accepts non-character code points. This corresponds to
Unicode Corrigendum #9
&lt;http://www.unicode.org/versions/corrigendum9.html&gt;.
which said that non-character code points are merely
discouraged rather than completely forbidden in open
interchange. See &quot;Noncharacter code points&quot; in
perlunicode.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;isUTF8_CHAR&quot; to check for Perl&rsquo;s extended
<small>UTF&minus;8</small> ; and
&quot;isUTF8_CHAR_flags&quot; for a more customized
definition.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;is_c9strict_utf8_string&quot;,
&quot;is_c9strict_utf8_string_loc&quot;, and
&quot;is_c9strict_utf8_string_loclen&quot; to check entire
strings.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
isC9_STRICT_UTF8_CHAR(const U8 * const s0, <br>
const U8 * const e)</p>


<p style="margin-left:11%;">&quot;is_invariant_string&quot;</p>

<p style="margin-left:17%;">This is a somewhat
misleadingly-named synonym for
&quot;is_utf8_invariant_string&quot;.
&quot;is_utf8_invariant_string&quot; is preferred, as it
indicates under what conditions the string is invariant.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_invariant_string(const U8* const s, STRLEN len)</p>


<p style="margin-left:11%;">&quot;isSTRICT_UTF8_CHAR&quot;</p>

<p style="margin-left:17%;">Evaluates to non-zero if the
first few bytes of the string starting at &quot;s&quot; and
looking no further than &quot;e&nbsp;&minus;&nbsp;1&quot;
are well-formed <small>UTF&minus;8</small> that represents
some Unicode code point completely acceptable for open
interchange between all applications; otherwise it evaluates
to 0. If non-zero, the value gives how many bytes starting
at &quot;s&quot; comprise the code point&rsquo;s
representation. Any bytes remaining before &quot;e&quot;,
but beyond the ones needed to form the first code point in
&quot;s&quot;, are not examined.</p>

<p style="margin-left:17%; margin-top: 1em">The largest
acceptable code point is the Unicode maximum 0x10FFFF, and
must not be a surrogate nor a non-character code point. Thus
this excludes any code point from Perl&rsquo;s extended
<small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">This is used to
efficiently decide if the next few bytes in &quot;s&quot; is
legal Unicode-acceptable <small>UTF&minus;8</small> for a
single character.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;isC9_STRICT_UTF8_CHAR&quot; to use the Unicode
Corrigendum #9
&lt;http://www.unicode.org/versions/corrigendum9.html&gt;
definition of allowable code points; &quot;isUTF8_CHAR&quot;
to check for Perl&rsquo;s extended
<small>UTF&minus;8</small> ; and
&quot;isUTF8_CHAR_flags&quot; for a more customized
definition.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;is_strict_utf8_string&quot;,
&quot;is_strict_utf8_string_loc&quot;, and
&quot;is_strict_utf8_string_loclen&quot; to check entire
strings.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
isSTRICT_UTF8_CHAR(const U8 * const s0, <br>
const U8 * const e)</p>


<p style="margin-left:11%;">&quot;is_strict_utf8_string&quot;</p>

<p style="margin-left:17%;">Returns <small>TRUE</small> if
the first &quot;len&quot; bytes of string &quot;s&quot; form
a valid UTF&minus;8&minus;encoded string that is fully
interchangeable by any application using Unicode rules;
otherwise it returns <small>FALSE.</small> If
&quot;len&quot; is 0, it will be calculated using strlen(s)
(which means if you use this option, that &quot;s&quot;
can&rsquo;t have embedded &quot;NUL&quot; characters and has
to have a terminating &quot;NUL&quot; byte). Note that all
characters being <small>ASCII</small> constitute &rsquo;a
valid <small>UTF&minus;8</small> string&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">This function
returns <small>FALSE</small> for strings containing any code
points above the Unicode max of 0x10FFFF, surrogate code
points, or non-character code points.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_invariant_string&quot;,
&quot;is_utf8_invariant_string_loc&quot;,
&quot;is_utf8_string&quot;,
&quot;is_utf8_string_flags&quot;,
&quot;is_utf8_string_loc&quot;,
&quot;is_utf8_string_loc_flags&quot;,
&quot;is_utf8_string_loclen&quot;,
&quot;is_utf8_string_loclen_flags&quot;,
&quot;is_utf8_fixed_width_buf_flags&quot;,
&quot;is_utf8_fixed_width_buf_loc_flags&quot;,
&quot;is_utf8_fixed_width_buf_loclen_flags&quot;,
&quot;is_strict_utf8_string_loc&quot;,
&quot;is_strict_utf8_string_loclen&quot;,
&quot;is_c9strict_utf8_string&quot;,
&quot;is_c9strict_utf8_string_loc&quot;, and
&quot;is_c9strict_utf8_string_loclen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_strict_utf8_string(const U8 *s, STRLEN len)</p>


<p style="margin-left:11%;">&quot;is_strict_utf8_string_loc&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_strict_utf8_string&quot; but stores the location of
the failure (in the case of &quot;utf8ness failure&quot;) or
the location &quot;s&quot;+&quot;len&quot; (in the case of
&quot;utf8ness success&quot;) in the &quot;ep&quot;
pointer.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_strict_utf8_string_loclen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_strict_utf8_string_loc(const U8 *s, STRLEN len, <br>
const U8 **ep)</p>


<p style="margin-left:11%;">&quot;is_strict_utf8_string_loclen&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_strict_utf8_string&quot; but stores the location of
the failure (in the case of &quot;utf8ness failure&quot;) or
the location &quot;s&quot;+&quot;len&quot; (in the case of
&quot;utf8ness success&quot;) in the &quot;ep&quot; pointer,
and the number of <small>UTF&minus;8</small> encoded
characters in the &quot;el&quot; pointer.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_strict_utf8_string_loc&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_strict_utf8_string_loclen(const U8 *s, STRLEN len, <br>
const U8 **ep, STRLEN *el)</p>

<p style="margin-left:11%;">&quot;is_utf8_char&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;is_utf8_char&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Tests if some
arbitrary number of bytes begins in a valid
<small>UTF&minus;8</small> character. Note that an
<small>INVARIANT</small> (i.e. <small>ASCII</small> on
non-EBCDIC machines) character is a valid
<small>UTF&minus;8</small> character. The actual number of
bytes in the <small>UTF&minus;8</small> character will be
returned if it is valid, otherwise 0.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is deprecated due to the possibility that malformed input
could cause reading beyond the end of the input buffer. Use
&quot;isUTF8_CHAR&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
is_utf8_char(const U8 *s)</p>


<p style="margin-left:11%;">&quot;is_utf8_char_buf&quot;</p>

<p style="margin-left:17%;">This is identical to the macro
&quot;isUTF8_CHAR&quot; in perlapi.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
is_utf8_char_buf(const U8 *buf, const U8 *buf_end)</p>


<p style="margin-left:11%;">&quot;is_utf8_fixed_width_buf_flags&quot;</p>

<p style="margin-left:17%;">Returns <small>TRUE</small> if
the fixed-width buffer starting at &quot;s&quot; with length
&quot;len&quot; is entirely valid
<small>UTF&minus;8,</small> subject to the restrictions
given by &quot;flags&quot;; otherwise it returns
<small>FALSE.</small></p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; is 0, any well-formed
<small>UTF&minus;8,</small> as extended by Perl, is accepted
without restriction. If the final few bytes of the buffer do
not form a complete code point, this will return
<small>TRUE</small> anyway, provided that
&quot;is_utf8_valid_partial_char_flags&quot; returns
<small>TRUE</small> for them.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; in non-zero, it can be any combination of
the &quot;UTF8_DISALLOW_<i>foo</i>&quot; flags accepted by
&quot;utf8n_to_uvchr&quot;, and with the same meanings.</p>

<p style="margin-left:17%; margin-top: 1em">This function
differs from &quot;is_utf8_string_flags&quot; only in that
the latter returns <small>FALSE</small> if the final few
bytes of the string don&rsquo;t form a complete code
point.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_fixed_width_buf_flags(const U8 * const s, <br>
STRLEN len, const U32 flags)</p>


<p style="margin-left:11%;">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_utf8_fixed_width_buf_loc_flags&quot; but stores the
number of complete, valid characters found in the
&quot;el&quot; pointer.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_fixed_width_buf_loclen_flags(const U8 * const s,
<br>
STRLEN len, <br>
const U8 **ep, <br>
STRLEN *el, <br>
const U32 flags)</p>


<p style="margin-left:11%;">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_utf8_fixed_width_buf_flags&quot; but stores the
location of the failure in the &quot;ep&quot; pointer. If
the function returns <small>TRUE,</small> *ep will point to
the beginning of any partial character at the end of the
buffer; if there is no partial character *ep will contain
&quot;s&quot;+&quot;len&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_fixed_width_buf_loclen_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_fixed_width_buf_loc_flags(const U8 * const s, <br>
STRLEN len, const U8 **ep, <br>
const U32 flags)</p>


<p style="margin-left:11%;">&quot;is_utf8_invariant_string&quot;</p>

<p style="margin-left:17%;">Returns <small>TRUE</small> if
the first &quot;len&quot; bytes of the string &quot;s&quot;
are the same regardless of the <small>UTF&minus;8</small>
encoding of the string (or UTF-EBCDIC encoding on
<small>EBCDIC</small> machines); otherwise it returns
<small>FALSE.</small> That is, it returns
<small>TRUE</small> if they are <small>UTF&minus;8</small>
invariant. On ASCII-ish machines, all the
<small>ASCII</small> characters and only the
<small>ASCII</small> characters fit this definition. On
<small>EBCDIC</small> machines, the ASCII-range characters
are invariant, but so also are the C1 controls.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;len&quot; is 0, it will be calculated using strlen(s),
(which means if you use this option, that &quot;s&quot;
can&rsquo;t have embedded &quot;NUL&quot; characters and has
to have a terminating &quot;NUL&quot; byte).</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_string&quot;,
&quot;is_utf8_string_flags&quot;,
&quot;is_utf8_string_loc&quot;,
&quot;is_utf8_string_loc_flags&quot;,
&quot;is_utf8_string_loclen&quot;,
&quot;is_utf8_string_loclen_flags&quot;,
&quot;is_utf8_fixed_width_buf_flags&quot;,
&quot;is_utf8_fixed_width_buf_loc_flags&quot;,
&quot;is_utf8_fixed_width_buf_loclen_flags&quot;,
&quot;is_strict_utf8_string&quot;,
&quot;is_strict_utf8_string_loc&quot;,
&quot;is_strict_utf8_string_loclen&quot;,
&quot;is_c9strict_utf8_string&quot;,
&quot;is_c9strict_utf8_string_loc&quot;, and
&quot;is_c9strict_utf8_string_loclen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_invariant_string(const U8* const s, STRLEN len)</p>


<p style="margin-left:11%;">&quot;is_utf8_invariant_string_loc&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_utf8_invariant_string&quot; but upon failure,
stores the location of the first <small>UTF&minus;8</small>
variant character in the &quot;ep&quot; pointer; if all
characters are <small>UTF&minus;8</small> invariant, this
function does not change the contents of *ep.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_invariant_string_loc(const U8* const s, STRLEN len,
<br>
const U8 ** ep)</p>

<p style="margin-left:11%;">&quot;is_utf8_string&quot;</p>

<p style="margin-left:17%;">Returns <small>TRUE</small> if
the first &quot;len&quot; bytes of string &quot;s&quot; form
a valid Perl&minus;extended&minus;UTF&minus;8 string;
returns <small>FALSE</small> otherwise. If &quot;len&quot;
is 0, it will be calculated using strlen(s) (which means if
you use this option, that &quot;s&quot; can&rsquo;t have
embedded &quot;NUL&quot; characters and has to have a
terminating &quot;NUL&quot; byte). Note that all characters
being <small>ASCII</small> constitute &rsquo;a valid
<small>UTF&minus;8</small> string&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">This function
considers Perl&rsquo;s extended <small>UTF&minus;8</small>
to be valid. That means that code points above Unicode,
surrogates, and non-character code points are considered
valid by this function. Use
&quot;is_strict_utf8_string&quot;,
&quot;is_c9strict_utf8_string&quot;, or
&quot;is_utf8_string_flags&quot; to restrict what code
points are considered valid.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_invariant_string&quot;,
&quot;is_utf8_invariant_string_loc&quot;,
&quot;is_utf8_string_loc&quot;,
&quot;is_utf8_string_loclen&quot;,
&quot;is_utf8_fixed_width_buf_flags&quot;,
&quot;is_utf8_fixed_width_buf_loc_flags&quot;,
&quot;is_utf8_fixed_width_buf_loclen_flags&quot;,</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_string(const U8 *s, STRLEN len)</p>


<p style="margin-left:11%;">&quot;is_utf8_string_flags&quot;</p>

<p style="margin-left:17%;">Returns <small>TRUE</small> if
the first &quot;len&quot; bytes of string &quot;s&quot; form
a valid <small>UTF&minus;8</small> string, subject to the
restrictions imposed by &quot;flags&quot;; returns
<small>FALSE</small> otherwise. If &quot;len&quot; is 0, it
will be calculated using strlen(s) (which means if you use
this option, that &quot;s&quot; can&rsquo;t have embedded
&quot;NUL&quot; characters and has to have a terminating
&quot;NUL&quot; byte). Note that all characters being
<small>ASCII</small> constitute &rsquo;a valid
<small>UTF&minus;8</small> string&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; is 0, this gives the same results as
&quot;is_utf8_string&quot;; if &quot;flags&quot; is
&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;, this gives
the same results as &quot;is_strict_utf8_string&quot;; and
if &quot;flags&quot; is
&quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;, this gives
the same results as &quot;is_c9strict_utf8_string&quot;.
Otherwise &quot;flags&quot; may be any combination of the
&quot;UTF8_DISALLOW_<i>foo</i>&quot; flags understood by
&quot;utf8n_to_uvchr&quot;, with the same meanings.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_invariant_string&quot;,
&quot;is_utf8_invariant_string_loc&quot;,
&quot;is_utf8_string&quot;, &quot;is_utf8_string_loc&quot;,
&quot;is_utf8_string_loc_flags&quot;,
&quot;is_utf8_string_loclen&quot;,
&quot;is_utf8_string_loclen_flags&quot;,
&quot;is_utf8_fixed_width_buf_flags&quot;,
&quot;is_utf8_fixed_width_buf_loc_flags&quot;,
&quot;is_utf8_fixed_width_buf_loclen_flags&quot;,
&quot;is_strict_utf8_string&quot;,
&quot;is_strict_utf8_string_loc&quot;,
&quot;is_strict_utf8_string_loclen&quot;,
&quot;is_c9strict_utf8_string&quot;,
&quot;is_c9strict_utf8_string_loc&quot;, and
&quot;is_c9strict_utf8_string_loclen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_string_flags(const U8 *s, STRLEN len, <br>
const U32 flags)</p>


<p style="margin-left:11%;">&quot;is_utf8_string_loc&quot;</p>

<p style="margin-left:17%;">Like &quot;is_utf8_string&quot;
but stores the location of the failure (in the case of
&quot;utf8ness failure&quot;) or the location
&quot;s&quot;+&quot;len&quot; (in the case of &quot;utf8ness
success&quot;) in the &quot;ep&quot; pointer.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_string_loclen&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_string_loc(const U8 *s, const STRLEN len, <br>
const U8 **ep)</p>


<p style="margin-left:11%;">&quot;is_utf8_string_loclen&quot;</p>

<p style="margin-left:17%;">Like &quot;is_utf8_string&quot;
but stores the location of the failure (in the case of
&quot;utf8ness failure&quot;) or the location
&quot;s&quot;+&quot;len&quot; (in the case of &quot;utf8ness
success&quot;) in the &quot;ep&quot; pointer, and the number
of <small>UTF&minus;8</small> encoded characters in the
&quot;el&quot; pointer.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_string_loc&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_string_loclen(const U8 *s, STRLEN len, <br>
const U8 **ep, STRLEN *el)</p>


<p style="margin-left:11%;">&quot;is_utf8_string_loclen_flags&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_utf8_string_flags&quot; but stores the location of
the failure (in the case of &quot;utf8ness failure&quot;) or
the location &quot;s&quot;+&quot;len&quot; (in the case of
&quot;utf8ness success&quot;) in the &quot;ep&quot; pointer,
and the number of <small>UTF&minus;8</small> encoded
characters in the &quot;el&quot; pointer.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_string_loc_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_string_loclen_flags(const U8 *s, STRLEN len, <br>
const U8 **ep, STRLEN *el, <br>
const U32 flags)</p>


<p style="margin-left:11%;">&quot;is_utf8_string_loc_flags&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_utf8_string_flags&quot; but stores the location of
the failure (in the case of &quot;utf8ness failure&quot;) or
the location &quot;s&quot;+&quot;len&quot; (in the case of
&quot;utf8ness success&quot;) in the &quot;ep&quot;
pointer.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;is_utf8_string_loclen_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_string_loc_flags(const U8 *s, STRLEN len, <br>
const U8 **ep, const U32 flags)</p>


<p style="margin-left:11%;">&quot;is_utf8_valid_partial_char&quot;</p>

<p style="margin-left:17%;">Returns 0 if the sequence of
bytes starting at &quot;s&quot; and looking no further than
&quot;e&nbsp;&minus;&nbsp;1&quot; is the
<small>UTF&minus;8</small> encoding, as extended by Perl,
for one or more code points. Otherwise, it returns 1 if
there exists at least one non-empty sequence of bytes that
when appended to sequence &quot;s&quot;, starting at
position &quot;e&quot; causes the entire sequence to be the
well-formed <small>UTF&minus;8</small> of some code point;
otherwise returns 0.</p>

<p style="margin-left:17%; margin-top: 1em">In other words
this returns <small>TRUE</small> if &quot;s&quot; points to
a partial UTF&minus;8&minus;encoded code point.</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
when a fixed-length buffer is being tested for being
well-formed <small>UTF&minus;8,</small> but the final few
bytes in it don&rsquo;t comprise a full character; that is,
it is split somewhere in the middle of the final code
point&rsquo;s <small>UTF&minus;8</small> representation.
(Presumably when the buffer is refreshed with the next chunk
of data, the new first bytes will complete the partial code
point.) This function is used to verify that the final bytes
in the current buffer are in fact the legal beginning of
some code point, so that if they aren&rsquo;t, the failure
can be signalled without having to wait for the next
read.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_valid_partial_char(const U8 * const s0, <br>
const U8 * const e)</p>


<p style="margin-left:11%;">&quot;is_utf8_valid_partial_char_flags&quot;</p>

<p style="margin-left:17%;">Like
&quot;is_utf8_valid_partial_char&quot;, it returns a boolean
giving whether or not the input is a valid
<small>UTF&minus;8</small> encoded partial character, but it
takes an extra parameter, &quot;flags&quot;, which can
further restrict which code points are considered valid.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; is 0, this behaves identically to
&quot;is_utf8_valid_partial_char&quot;. Otherwise
&quot;flags&quot; can be any combination of the
&quot;UTF8_DISALLOW_<i>foo</i>&quot; flags accepted by
&quot;utf8n_to_uvchr&quot;. If there is any sequence of
bytes that can complete the input partial character in such
a way that a non-prohibited character is formed, the
function returns <small>TRUE</small> ; otherwise
<small>FALSE.</small> Non character code points cannot be
determined based on partial character input. But many of the
other possible excluded types can be determined from just
the first one or two bytes.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_utf8_valid_partial_char_flags(const U8 * const s0, <br>
const U8 * const e, <br>
const U32 flags)</p>

<p style="margin-left:11%;">&quot;isUTF8_CHAR&quot;</p>

<p style="margin-left:17%;">Evaluates to non-zero if the
first few bytes of the string starting at &quot;s&quot; and
looking no further than &quot;e&nbsp;&minus;&nbsp;1&quot;
are well-formed <small>UTF&minus;8,</small> as extended by
Perl, that represents some code point; otherwise it
evaluates to 0. If non-zero, the value gives how many bytes
starting at &quot;s&quot; comprise the code point&rsquo;s
representation. Any bytes remaining before &quot;e&quot;,
but beyond the ones needed to form the first code point in
&quot;s&quot;, are not examined.</p>

<p style="margin-left:17%; margin-top: 1em">The code point
can be any that will fit in an <small>IV</small> on this
machine, using Perl&rsquo;s extension to official
<small>UTF&minus;8</small> to represent those higher than
the Unicode maximum of 0x10FFFF. That means that this macro
is used to efficiently decide if the next few bytes in
&quot;s&quot; is legal <small>UTF&minus;8</small> for a
single character.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;isSTRICT_UTF8_CHAR&quot; to restrict the acceptable
code points to those defined by Unicode to be fully
interchangeable across applications;
&quot;isC9_STRICT_UTF8_CHAR&quot; to use the Unicode
Corrigendum #9
&lt;http://www.unicode.org/versions/corrigendum9.html&gt;
definition of allowable code points; and
&quot;isUTF8_CHAR_flags&quot; for a more customized
definition.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;is_utf8_string&quot;, &quot;is_utf8_string_loc&quot;,
and &quot;is_utf8_string_loclen&quot; to check entire
strings.</p>

<p style="margin-left:17%; margin-top: 1em">Note also that
a <small>UTF&minus;8</small> &quot;invariant&quot; character
(i.e. <small>ASCII</small> on non-EBCDIC machines) is a
valid <small>UTF&minus;8</small> character.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
isUTF8_CHAR(const U8 * const s0, const U8 * const e)</p>


<p style="margin-left:11%;">&quot;isUTF8_CHAR_flags&quot;</p>

<p style="margin-left:17%;">Evaluates to non-zero if the
first few bytes of the string starting at &quot;s&quot; and
looking no further than &quot;e&nbsp;&minus;&nbsp;1&quot;
are well-formed <small>UTF&minus;8,</small> as extended by
Perl, that represents some code point, subject to the
restrictions given by &quot;flags&quot;; otherwise it
evaluates to 0. If non-zero, the value gives how many bytes
starting at &quot;s&quot; comprise the code point&rsquo;s
representation. Any bytes remaining before &quot;e&quot;,
but beyond the ones needed to form the first code point in
&quot;s&quot;, are not examined.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; is 0, this gives the same results as
&quot;isUTF8_CHAR&quot;; if &quot;flags&quot; is
&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;, this gives
the same results as &quot;isSTRICT_UTF8_CHAR&quot;; and if
&quot;flags&quot; is
&quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;, this gives
the same results as &quot;isC9_STRICT_UTF8_CHAR&quot;.
Otherwise &quot;flags&quot; may be any combination of the
&quot;UTF8_DISALLOW_<i>foo</i>&quot; flags understood by
&quot;utf8n_to_uvchr&quot;, with the same meanings.</p>

<p style="margin-left:17%; margin-top: 1em">The three
alternative macros are for the most commonly needed
validations; they are likely to run somewhat faster than
this more general one, as they can be inlined into your
code.</p>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;is_utf8_string_flags&quot;,
&quot;is_utf8_string_loc_flags&quot;, and
&quot;is_utf8_string_loclen_flags&quot; to check entire
strings.</p>

<p style="margin-left:17%; margin-top: 1em">Size_t
isUTF8_CHAR_flags(const U8 * const s0, const U8 * const e,
<br>
const U32 flags)</p>


<p style="margin-left:11%;">&quot;LATIN1_TO_NATIVE&quot;</p>

<p style="margin-left:17%;">Returns the native equivalent
of the input Latin&minus;1 code point (including
<small>ASCII</small> and control characters) given by
&quot;ch&quot;. Thus, &quot;LATIN1_TO_NATIVE(66)&quot; on
<small>EBCDIC</small> platforms returns 194. These each
represent the character &quot;B&quot; on their respective
platforms. On <small>ASCII</small> platforms no conversion
is needed, so this macro expands to just its input, adding
no time nor space requirements to the implementation.</p>

<p style="margin-left:17%; margin-top: 1em">For conversion
of code points potentially larger than will fit in a
character, use &quot; <small>UNI_TO_NATIVE&quot;</small>
.</p>

<p style="margin-left:17%; margin-top: 1em">U8
LATIN1_TO_NATIVE(U8 ch)</p>


<p style="margin-left:11%;">&quot;NATIVE_TO_LATIN1&quot;</p>

<p style="margin-left:17%;">Returns the Latin&minus;1
(including <small>ASCII</small> and control characters)
equivalent of the input native code point given by
&quot;ch&quot;. Thus, &quot;NATIVE_TO_LATIN1(193)&quot; on
<small>EBCDIC</small> platforms returns 65. These each
represent the character &quot;A&quot; on their respective
platforms. On <small>ASCII</small> platforms no conversion
is needed, so this macro expands to just its input, adding
no time nor space requirements to the implementation.</p>

<p style="margin-left:17%; margin-top: 1em">For conversion
of code points potentially larger than will fit in a
character, use &quot; <small>NATIVE_TO_UNI&quot;</small>
.</p>

<p style="margin-left:17%; margin-top: 1em">U8
NATIVE_TO_LATIN1(U8 ch)</p>

<p style="margin-left:11%;">&quot;NATIVE_TO_UNI&quot;</p>

<p style="margin-left:17%;">Returns the Unicode equivalent
of the input native code point given by &quot;ch&quot;.
Thus, &quot;NATIVE_TO_UNI(195)&quot; on
<small>EBCDIC</small> platforms returns 67. These each
represent the character &quot;C&quot; on their respective
platforms. On <small>ASCII</small> platforms no conversion
is needed, so this macro expands to just its input, adding
no time nor space requirements to the implementation.</p>

<p style="margin-left:17%; margin-top: 1em">UV
NATIVE_TO_UNI(UV ch)</p>

<p style="margin-left:11%;">&quot;pv_uni_display&quot;</p>

<p style="margin-left:17%;">Build to the scalar
&quot;dsv&quot; a displayable version of the
<small>UTF&minus;8</small> encoded string &quot;spv&quot;,
length &quot;len&quot;, the displayable version being at
most &quot;pvlim&quot; bytes long (if longer, the rest is
truncated and &quot;...&quot; will be appended).</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; argument can have
&quot;UNI_DISPLAY_ISPRINT&quot; set to display
&quot;isPRINT()&quot;able characters as themselves,
&quot;UNI_DISPLAY_BACKSLASH&quot; to display the
&quot;\\[nrfta\\]&quot; as the backslashed versions (like
&quot;\n&quot;) (&quot;UNI_DISPLAY_BACKSLASH&quot; is
preferred over &quot;UNI_DISPLAY_ISPRINT&quot; for
&quot;\\&quot;). &quot;UNI_DISPLAY_QQ&quot; (and its alias
&quot;UNI_DISPLAY_REGEX&quot;) have both
&quot;UNI_DISPLAY_BACKSLASH&quot; and
&quot;UNI_DISPLAY_ISPRINT&quot; turned on.</p>

<p style="margin-left:17%; margin-top: 1em">Additionally,
there is now &quot;UNI_DISPLAY_BACKSPACE&quot; which allows
&quot;\b&quot; for a backspace, but only when
&quot;UNI_DISPLAY_BACKSLASH&quot; also is set.</p>

<p style="margin-left:17%; margin-top: 1em">The pointer to
the <small>PV</small> of the &quot;dsv&quot; is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;sv_uni_display&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">char*
pv_uni_display(SV *dsv, const U8 *spv, STRLEN len, <br>
STRLEN pvlim, UV flags)</p>


<p style="margin-left:11%;">&quot;REPLACEMENT_CHARACTER_UTF8&quot;</p>

<p style="margin-left:17%;">This is a macro that evaluates
to a string constant of the <small>UTF&minus;8</small> bytes
that define the Unicode <small>REPLACEMENT CHARACTER</small>
(U+FFFD) for the platform that perl is compiled on. This
allows code to use a mnemonic for this character that works
on both <small>ASCII</small> and <small>EBCDIC</small>
platforms.
&quot;sizeof(REPLACEMENT_CHARACTER_UTF8)&nbsp;&minus;&nbsp;1&quot;
can be used to get its length in bytes.</p>

<p style="margin-left:11%;">&quot;sv_cat_decode&quot;</p>

<p style="margin-left:17%;">&quot;encoding&quot; is assumed
to be an &quot;Encode&quot; object, the <small>PV</small> of
&quot;ssv&quot; is assumed to be octets in that encoding and
decoding the input starts from the position which
&quot;(PV&nbsp;+&nbsp;*offset)&quot; pointed to.
&quot;dsv&quot; will be concatenated with the decoded
<small>UTF&minus;8</small> string from &quot;ssv&quot;.
Decoding will terminate when the string &quot;tstr&quot;
appears in decoding output or the input ends on the
<small>PV</small> of &quot;ssv&quot;. The value which
&quot;offset&quot; points will be modified to the last input
position on &quot;ssv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Returns
<small>TRUE</small> if the terminator was found, else
returns <small>FALSE.</small></p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_cat_decode(SV* dsv, SV *encoding, SV *ssv, int *offset,
<br>
char* tstr, int tlen)</p>


<p style="margin-left:11%;">&quot;sv_recode_to_utf8&quot;</p>

<p style="margin-left:17%;">&quot;encoding&quot; is assumed
to be an &quot;Encode&quot; object, on entry the
<small>PV</small> of &quot;sv&quot; is assumed to be octets
in that encoding, and &quot;sv&quot; will be converted into
Unicode (and <small>UTF&minus;8</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;sv&quot; already is <small>UTF&minus;8</small> (or if
it is not &quot;POK&quot;), or if &quot;encoding&quot; is
not a reference, nothing is done to &quot;sv&quot;. If
&quot;encoding&quot; is not an &quot;Encode::XS&quot;
Encoding object, bad things will happen. (See encoding and
Encode.)</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>PV</small> of &quot;sv&quot; is returned.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_recode_to_utf8(SV* sv, SV *encoding)</p>

<p style="margin-left:11%;">&quot;sv_uni_display&quot;</p>

<p style="margin-left:17%;">Build to the scalar
&quot;dsv&quot; a displayable version of the scalar
&quot;sv&quot;, the displayable version being at most
&quot;pvlim&quot; bytes long (if longer, the rest is
truncated and &quot;...&quot; will be appended).</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;flags&quot; argument is as in
&quot;pv_uni_display&quot;().</p>

<p style="margin-left:17%; margin-top: 1em">The pointer to
the <small>PV</small> of the &quot;dsv&quot; is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">char*
sv_uni_display(SV *dsv, SV *ssv, STRLEN pvlim, UV flags)</p>


<p style="margin-left:11%;">&quot;UNICODE_IS_NONCHAR&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
or not &quot;uv&quot; is one of the Unicode non-character
code points</p>

<p style="margin-left:17%; margin-top: 1em">bool
UNICODE_IS_NONCHAR(const UV uv)</p>


<p style="margin-left:11%;">&quot;UNICODE_IS_REPLACEMENT&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
or not &quot;uv&quot; is the Unicode <small>REPLACEMENT
CHARACTER</small></p>

<p style="margin-left:17%; margin-top: 1em">bool
UNICODE_IS_REPLACEMENT(const UV uv)</p>


<p style="margin-left:11%;">&quot;UNICODE_IS_SUPER&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
or not &quot;uv&quot; is above the maximum legal Unicode
code point of U+10FFFF.</p>

<p style="margin-left:17%; margin-top: 1em">bool
UNICODE_IS_SUPER(const UV uv)</p>


<p style="margin-left:11%;">&quot;UNICODE_IS_SURROGATE&quot;</p>

<p style="margin-left:17%;">Returns a boolean as to whether
or not &quot;uv&quot; is one of the Unicode surrogate code
points</p>

<p style="margin-left:17%; margin-top: 1em">bool
UNICODE_IS_SURROGATE(const UV uv)</p>


<p style="margin-left:11%;">&quot;UNICODE_REPLACEMENT&quot;</p>

<p style="margin-left:17%;">Evaluates to 0xFFFD, the code
point of the Unicode <small>REPLACEMENT
CHARACTER</small></p>

<p style="margin-left:11%;">&quot;UNI_TO_NATIVE&quot;</p>

<p style="margin-left:17%;">Returns the native equivalent
of the input Unicode code point given by &quot;ch&quot;.
Thus, &quot;UNI_TO_NATIVE(68)&quot; on <small>EBCDIC</small>
platforms returns 196. These each represent the character
&quot;D&quot; on their respective platforms. On
<small>ASCII</small> platforms no conversion is needed, so
this macro expands to just its input, adding no time nor
space requirements to the implementation.</p>

<p style="margin-left:17%; margin-top: 1em">UV
UNI_TO_NATIVE(UV ch)</p>

<p style="margin-left:11%;">&quot;utf8n_to_uvchr&quot;</p>

<p style="margin-left:17%;"><small>THIS FUNCTION SHOULD BE
USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.</small> Most
code should use &quot;utf8_to_uvchr_buf&quot;() rather than
call this directly.</p>

<p style="margin-left:17%; margin-top: 1em">Bottom level
<small>UTF&minus;8</small> decode routine. Returns the
native code point value of the first character in the string
&quot;s&quot;, which is assumed to be in
<small>UTF&minus;8</small> (or UTF-EBCDIC) encoding, and no
longer than &quot;curlen&quot; bytes; *retlen (if
&quot;retlen&quot; isn&rsquo;t <small>NULL</small> ) will be
set to the length, in bytes, of that character.</p>

<p style="margin-left:17%; margin-top: 1em">The value of
&quot;flags&quot; determines the behavior when &quot;s&quot;
does not point to a well-formed <small>UTF&minus;8</small>
character. If &quot;flags&quot; is 0, encountering a
malformation causes zero to be returned and *retlen is set
so that (&quot;s&quot;&nbsp;+&nbsp;*retlen) is the next
possible position in &quot;s&quot; that could begin a
non-malformed character. Also, if <small>UTF&minus;8</small>
warnings haven&rsquo;t been lexically disabled, a warning is
raised. Some <small>UTF&minus;8</small> input sequences may
contain multiple malformations. This function tries to find
every possible one in each call, so multiple warnings can be
raised for the same sequence.</p>

<p style="margin-left:17%; margin-top: 1em">Various
<small>ALLOW</small> flags can be set in &quot;flags&quot;
to allow (and not warn on) individual types of
malformations, such as the sequence being overlong (that is,
when there is a shorter sequence that can express the same
code point; overlong sequences are expressly forbidden in
the <small>UTF&minus;8</small> standard due to potential
security issues). Another malformation example is the first
byte of a character not being a legal first byte. See
<i>utf8.h</i> for the list of such flags. Even if allowed,
this function generally returns the Unicode
<small>REPLACEMENT CHARACTER</small> when it encounters a
malformation. There are flags in <i>utf8.h</i> to override
this behavior for the overlong malformations, but
don&rsquo;t do that except for very specialized
purposes.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;UTF8_CHECK_ONLY&quot; flag overrides the behavior when
a non-allowed (by other flags) malformation is found. If
this flag is set, the routine assumes that the caller will
raise a warning, and this function will silently just set
&quot;retlen&quot; to &quot;&minus;1&quot; (cast to
&quot;STRLEN&quot;) and return zero.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
<small>API</small> requires disambiguation between
successful decoding a &quot;NUL&quot; character, and an
error return (unless the &quot;UTF8_CHECK_ONLY&quot; flag is
set), as in both cases, 0 is returned, and, depending on the
malformation, &quot;retlen&quot; may be set to 1. To
disambiguate, upon a zero return, see if the first byte of
&quot;s&quot; is 0 as well. If so, the input was a
&quot;NUL&quot;; if not, the input had an error. Or you can
use &quot;utf8n_to_uvchr_error&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Certain code
points are considered problematic. These are Unicode
surrogates, Unicode non-characters, and code points above
the Unicode maximum of 0x10FFFF. By default these are
considered regular code points, but certain situations
warrant special handling for them, which can be specified
using the &quot;flags&quot; parameter. If &quot;flags&quot;
contains &quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;, all
three classes are treated as malformations and handled as
such. The flags &quot;UTF8_DISALLOW_SURROGATE&quot;,
&quot;UTF8_DISALLOW_NONCHAR&quot;, and
&quot;UTF8_DISALLOW_SUPER&quot; (meaning above the legal
Unicode maximum) can be set to disallow these categories
individually. &quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;
restricts the allowed inputs to the strict
<small>UTF&minus;8</small> traditionally defined by Unicode.
Use &quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot; to use
the strictness definition given by Unicode Corrigendum #9
&lt;https://www.unicode.org/versions/corrigendum9.html&gt;.
The difference between traditional strictness and C9
strictness is that the latter does not forbid non-character
code points. (They are still discouraged, however.) For more
discussion see &quot;Noncharacter code points&quot; in
perlunicode.</p>

<p style="margin-left:17%; margin-top: 1em">The flags
&quot;UTF8_WARN_ILLEGAL_INTERCHANGE&quot;,
&quot;UTF8_WARN_ILLEGAL_C9_INTERCHANGE&quot;,
&quot;UTF8_WARN_SURROGATE&quot;,
&quot;UTF8_WARN_NONCHAR&quot;, and
&quot;UTF8_WARN_SUPER&quot; will cause warning messages to
be raised for their respective categories, but otherwise the
code points are considered valid (not malformations). To get
a category to both be treated as a malformation and raise a
warning, specify both the <small>WARN</small> and
<small>DISALLOW</small> flags. (But note that warnings are
not raised if lexically disabled nor if
&quot;UTF8_CHECK_ONLY&quot; is also specified.)</p>

<p style="margin-left:17%; margin-top: 1em">Extremely high
code points were never specified in any standard, and
require an extension to <small>UTF&minus;8</small> to
express, which Perl does. It is likely that programs written
in something other than Perl would not be able to read files
that contain these; nor would Perl understand files written
by something that uses a different extension. For these
reasons, there is a separate set of flags that can warn
and/or disallow these extremely high code points, even if
other above-Unicode ones are accepted. They are the
&quot;UTF8_WARN_PERL_EXTENDED&quot; and
&quot;UTF8_DISALLOW_PERL_EXTENDED&quot; flags. For more
information see &quot;UTF8_GOT_PERL_EXTENDED&quot;. Of
course &quot;UTF8_DISALLOW_SUPER&quot; will treat all
above-Unicode code points, including these, as
malformations. (Note that the Unicode standard considers
anything above 0x10FFFF to be illegal, but there are
standards predating it that allow up to 0x7FFF_FFFF (2**31
&minus;1))</p>

<p style="margin-left:17%; margin-top: 1em">A somewhat
misleadingly named synonym for
&quot;UTF8_WARN_PERL_EXTENDED&quot; is retained for backward
compatibility: &quot;UTF8_WARN_ABOVE_31_BIT&quot;.
Similarly, &quot;UTF8_DISALLOW_ABOVE_31_BIT&quot; is usable
instead of the more accurately named
&quot;UTF8_DISALLOW_PERL_EXTENDED&quot;. The names are
misleading because these flags can apply to code points that
actually do fit in 31 bits. This happens on
<small>EBCDIC</small> platforms, and sometimes when the
overlong malformation is also present. The new names
accurately describe the situation in all cases.</p>

<p style="margin-left:17%; margin-top: 1em">All other code
points corresponding to Unicode characters, including
private use and those yet to be assigned, are never
considered malformed and never warn.</p>

<p style="margin-left:17%; margin-top: 1em">UV
utf8n_to_uvchr(const U8 *s, STRLEN curlen, STRLEN *retlen,
<br>
const U32 flags)</p>


<p style="margin-left:11%;">&quot;utf8n_to_uvchr_error&quot;</p>

<p style="margin-left:17%;"><small>THIS FUNCTION SHOULD BE
USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.</small> Most
code should use &quot;utf8_to_uvchr_buf&quot;() rather than
call this directly.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is for code that needs to know what the precise
malformation(s) are when an error is found. If you also need
to know the generated warning messages, use
&quot;utf8n_to_uvchr_msgs&quot;() instead.</p>

<p style="margin-left:17%; margin-top: 1em">It is like
&quot;utf8n_to_uvchr&quot; but it takes an extra parameter
placed after all the others, &quot;errors&quot;. If this
parameter is 0, this function behaves identically to
&quot;utf8n_to_uvchr&quot;. Otherwise, &quot;errors&quot;
should be a pointer to a &quot;U32&quot; variable, which
this function sets to indicate any errors found. Upon
return, if *errors is 0, there were no errors found.
Otherwise, *errors is the bit-wise &quot;OR&quot; of the
bits described in the list below. Some of these bits will be
set if a malformation is found, even if the input
&quot;flags&quot; parameter indicates that the given
malformation is allowed; those exceptions are noted: <br>
&quot;UTF8_GOT_PERL_EXTENDED&quot;</p>

<p style="margin-left:23%;">The input sequence is not
standard <small>UTF&minus;8,</small> but a Perl extension.
This bit is set only if the input &quot;flags&quot;
parameter contains either the
&quot;UTF8_DISALLOW_PERL_EXTENDED&quot; or the
&quot;UTF8_WARN_PERL_EXTENDED&quot; flags.</p>

<p style="margin-left:23%; margin-top: 1em">Code points
above 0x7FFF_FFFF (2**31 &minus; 1) were never specified in
any standard, and so some extension must be used to express
them. Perl uses a natural extension to
<small>UTF&minus;8</small> to represent the ones up to
2**36&minus;1, and invented a further extension to represent
even higher ones, so that any code point that fits in a
64&minus;bit word can be represented. Text using these
extensions is not likely to be portable to non-Perl code. We
lump both of these extensions together and refer to them as
Perl extended <small>UTF&minus;8.</small> There exist other
extensions that people have invented, incompatible with
Perl&rsquo;s.</p>

<p style="margin-left:23%; margin-top: 1em">On
<small>EBCDIC</small> platforms starting in Perl v5.24, the
Perl extension for representing extremely high code points
kicks in at 0x3FFF_FFFF (2**30 &minus;1), which is lower
than on <small>ASCII.</small> Prior to that, code points
2**31 and higher were simply unrepresentable, and a
different, incompatible method was used to represent code
points between 2**30 and 2**31 &minus; 1.</p>

<p style="margin-left:23%; margin-top: 1em">On both
platforms, <small>ASCII</small> and <small>EBCDIC,</small>
&quot;UTF8_GOT_PERL_EXTENDED&quot; is set if Perl extended
<small>UTF&minus;8</small> is used.</p>

<p style="margin-left:23%; margin-top: 1em">In earlier
Perls, this bit was named &quot;UTF8_GOT_ABOVE_31_BIT&quot;,
which you still may use for backward compatibility. That
name is misleading, as this flag may be set when the code
point actually does fit in 31 bits. This happens on
<small>EBCDIC</small> platforms, and sometimes when the
overlong malformation is also present. The new name
accurately describes the situation in all cases.</p>


<p style="margin-left:17%;">&quot;UTF8_GOT_CONTINUATION&quot;</p>

<p style="margin-left:23%;">The input sequence was
malformed in that the first byte was a
<small>UTF&minus;8</small> continuation byte.</p>

<p style="margin-left:17%;">&quot;UTF8_GOT_EMPTY&quot;</p>

<p style="margin-left:23%;">The input &quot;curlen&quot;
parameter was 0.</p>

<p style="margin-left:17%;">&quot;UTF8_GOT_LONG&quot;</p>

<p style="margin-left:23%;">The input sequence was
malformed in that there is some other sequence that
evaluates to the same code point, but that sequence is
shorter than this one.</p>

<p style="margin-left:23%; margin-top: 1em">Until Unicode
3.1, it was legal for programs to accept this malformation,
but it was discovered that this created security issues.</p>


<p style="margin-left:17%;">&quot;UTF8_GOT_NONCHAR&quot;</p>

<p style="margin-left:23%;">The code point represented by
the input <small>UTF&minus;8</small> sequence is for a
Unicode non-character code point. This bit is set only if
the input &quot;flags&quot; parameter contains either the
&quot;UTF8_DISALLOW_NONCHAR&quot; or the
&quot;UTF8_WARN_NONCHAR&quot; flags.</p>


<p style="margin-left:17%;">&quot;UTF8_GOT_NON_CONTINUATION&quot;</p>

<p style="margin-left:23%;">The input sequence was
malformed in that a non-continuation type byte was found in
a position where only a continuation type one should be. See
also &quot;UTF8_GOT_SHORT&quot;.</p>


<p style="margin-left:17%;">&quot;UTF8_GOT_OVERFLOW&quot;</p>

<p style="margin-left:23%;">The input sequence was
malformed in that it is for a code point that is not
representable in the number of bits available in an
<small>IV</small> on the current platform.</p>

<p style="margin-left:17%;">&quot;UTF8_GOT_SHORT&quot;</p>

<p style="margin-left:23%;">The input sequence was
malformed in that &quot;curlen&quot; is smaller than
required for a complete sequence. In other words, the input
is for a partial character sequence.</p>


<p style="margin-left:23%; margin-top: 1em">&quot;UTF8_GOT_SHORT&quot;
and &quot;UTF8_GOT_NON_CONTINUATION&quot; both indicate a
too short sequence. The difference is that
&quot;UTF8_GOT_NON_CONTINUATION&quot; indicates always that
there is an error, while &quot;UTF8_GOT_SHORT&quot; means
that an incomplete sequence was looked at. If no other flags
are present, it means that the sequence was valid as far as
it went. Depending on the application, this could mean one
of three things:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="71%">


<p>The &quot;curlen&quot; length parameter passed in was
too small, and the function was prevented from examining all
the necessary bytes.</p></td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="71%">


<p>The buffer being looked at is based on reading data, and
the data received so far stopped in the middle of a
character, so that the next read will read the remainder of
this character. (It is up to the caller to deal with the
split bytes somehow.)</p></td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="2%">


<p>&bull;</p></td>
<td width="4%"></td>
<td width="71%">


<p>This is a real error, and the partial sequence is all
we&rsquo;re going to get.</p></td></tr>
</table>

<p style="margin-left:17%;">&quot;UTF8_GOT_SUPER&quot;</p>

<p style="margin-left:23%;">The input sequence was
malformed in that it is for a non-Unicode code point; that
is, one above the legal Unicode maximum. This bit is set
only if the input &quot;flags&quot; parameter contains
either the &quot;UTF8_DISALLOW_SUPER&quot; or the
&quot;UTF8_WARN_SUPER&quot; flags.</p>


<p style="margin-left:17%;">&quot;UTF8_GOT_SURROGATE&quot;</p>

<p style="margin-left:23%;">The input sequence was
malformed in that it is for a &minus;Unicode
<small>UTF&minus;16</small> surrogate code point. This bit
is set only if the input &quot;flags&quot; parameter
contains either the &quot;UTF8_DISALLOW_SURROGATE&quot; or
the &quot;UTF8_WARN_SURROGATE&quot; flags.</p>

<p style="margin-left:17%; margin-top: 1em">To do your own
error handling, call this function with the
&quot;UTF8_CHECK_ONLY&quot; flag to suppress any warnings,
and then examine the *errors return.</p>

<p style="margin-left:17%; margin-top: 1em">UV
utf8n_to_uvchr_error(const U8 *s, STRLEN curlen, <br>
STRLEN *retlen, const U32 flags, <br>
U32 * errors)</p>


<p style="margin-left:11%;">&quot;utf8n_to_uvchr_msgs&quot;</p>

<p style="margin-left:17%;"><small>THIS FUNCTION SHOULD BE
USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.</small> Most
code should use &quot;utf8_to_uvchr_buf&quot;() rather than
call this directly.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is for code that needs to know what the precise
malformation(s) are when an error is found, and wants the
corresponding warning and/or error messages to be returned
to the caller rather than be displayed. All messages that
would have been displayed if all lexical warnings are
enabled will be returned.</p>

<p style="margin-left:17%; margin-top: 1em">It is just like
&quot;utf8n_to_uvchr_error&quot; but it takes an extra
parameter placed after all the others, &quot;msgs&quot;. If
this parameter is 0, this function behaves identically to
&quot;utf8n_to_uvchr_error&quot;. Otherwise,
&quot;msgs&quot; should be a pointer to an &quot;AV *&quot;
variable, in which this function creates a new
<small>AV</small> to contain any appropriate messages. The
elements of the array are ordered so that the first message
that would have been displayed is in the 0th element, and so
on. Each element is a hash with three key-value pairs, as
follows: <br>
&quot;text&quot;</p>

<p style="margin-left:23%;">The text of the message as a
&quot;SVpv&quot;.</p>


<p style="margin-left:17%;">&quot;warn_categories&quot;</p>

<p style="margin-left:23%;">The warning category (or
categories) packed into a &quot;SVuv&quot;.</p>

<p style="margin-left:17%;">&quot;flag&quot;</p>

<p style="margin-left:23%;">A single flag bit associated
with this message, in a &quot;SVuv&quot;. The bit
corresponds to some bit in the *errors return value, such as
&quot;UTF8_GOT_LONG&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
important to note that specifying this parameter as non-null
will cause any warnings this function would otherwise
generate to be suppressed, and instead be placed in *msgs.
The caller can check the lexical warnings state (or not)
when choosing what to do with the returned messages.</p>

<p style="margin-left:17%; margin-top: 1em">If the flag
&quot;UTF8_CHECK_ONLY&quot; is passed, no warnings are
generated, and hence no <small>AV</small> is created.</p>

<p style="margin-left:17%; margin-top: 1em">The caller, of
course, is responsible for freeing any returned
<small>AV.</small></p>

<p style="margin-left:17%; margin-top: 1em">UV
utf8n_to_uvchr_msgs(const U8 *s, STRLEN curlen, <br>
STRLEN *retlen, const U32 flags, <br>
U32 * errors, AV ** msgs)</p>

<p style="margin-left:11%;">&quot;UTF8SKIP&quot;</p>

<p style="margin-left:17%;">returns the number of bytes a
non-malformed <small>UTF&minus;8</small> encoded character
whose first (perhaps only) byte is pointed to by
&quot;s&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If there is a
possibility of malformed input, use instead: <br>
&quot;UTF8_SAFE_SKIP&quot; if you know the maximum ending
pointer in the <br>
buffer pointed to by &quot;s&quot;; or <br>
&quot;UTF8_CHK_SKIP&quot; if you don&rsquo;t know it.</p>

<p style="margin-left:17%; margin-top: 1em">It is better to
restructure your code so the end pointer is passed down so
that you know what it actually is at the point of this call,
but if that isn&rsquo;t possible, &quot;UTF8_CHK_SKIP&quot;
can minimize the chance of accessing beyond the end of the
input buffer.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
UTF8SKIP(char* s)</p>

<p style="margin-left:11%;">&quot;UTF8_CHK_SKIP&quot;</p>

<p style="margin-left:17%;">This is a safer version of
&quot;UTF8SKIP&quot;, but still not as safe as
&quot;UTF8_SAFE_SKIP&quot;. This version doesn&rsquo;t
blindly assume that the input string pointed to by
&quot;s&quot; is well-formed, but verifies that there
isn&rsquo;t a <small>NUL</small> terminating character
before the expected end of the next character in
&quot;s&quot;. The length &quot;UTF8_CHK_SKIP&quot; returns
stops just before any such <small>NUL.</small></p>

<p style="margin-left:17%; margin-top: 1em">Perl tends to
add NULs, as an insurance policy, after the end of strings
in <small>SV</small> &rsquo;s, so it is likely that using
this macro will prevent inadvertent reading beyond the end
of the input buffer, even if it is malformed
<small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">This macro is
intended to be used by <small>XS</small> modules where the
inputs could be malformed, and it isn&rsquo;t feasible to
restructure to use the safer &quot;UTF8_SAFE_SKIP&quot;, for
example when interfacing with a C library.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
UTF8_CHK_SKIP(char* s)</p>

<p style="margin-left:11%;">&quot;utf8_distance&quot;</p>

<p style="margin-left:17%;">Returns the number of
<small>UTF&minus;8</small> characters between the
<small>UTF&minus;8</small> pointers &quot;a&quot; and
&quot;b&quot;.</p>


<p style="margin-left:17%; margin-top: 1em"><small>WARNING:</small>
use only if you *know* that the pointers point inside the
same <small>UTF&minus;8</small> buffer.</p>

<p style="margin-left:17%; margin-top: 1em">IV
utf8_distance(const U8 *a, const U8 *b)</p>

<p style="margin-left:11%;">&quot;utf8_hop&quot;</p>

<p style="margin-left:17%;">Return the
<small>UTF&minus;8</small> pointer &quot;s&quot; displaced
by &quot;off&quot; characters, either forward or
backward.</p>


<p style="margin-left:17%; margin-top: 1em"><small>WARNING:</small>
do not use the following unless you *know* &quot;off&quot;
is within the <small>UTF&minus;8</small> data pointed to by
&quot;s&quot; *and* that on entry &quot;s&quot; is aligned
on the first byte of character or just after the last byte
of a character.</p>

<p style="margin-left:17%; margin-top: 1em">U8*
utf8_hop(const U8 *s, SSize_t off)</p>

<p style="margin-left:11%;">&quot;utf8_hop_back&quot;</p>

<p style="margin-left:17%;">Return the
<small>UTF&minus;8</small> pointer &quot;s&quot; displaced
by up to &quot;off&quot; characters, backward.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;off&quot;
must be non-positive.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;s&quot;
must be after or equal to &quot;start&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">When moving
backward it will not move before &quot;start&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Will not exceed
this limit even if the string is not valid &quot;
<small>UTF&minus;8&quot;.</small></p>

<p style="margin-left:17%; margin-top: 1em">U8*
utf8_hop_back(const U8 *s, SSize_t off, const U8 *start)</p>


<p style="margin-left:11%;">&quot;utf8_hop_forward&quot;</p>

<p style="margin-left:17%;">Return the
<small>UTF&minus;8</small> pointer &quot;s&quot; displaced
by up to &quot;off&quot; characters, forward.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;off&quot;
must be non-negative.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;s&quot;
must be before or equal to &quot;end&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">When moving
forward it will not move beyond &quot;end&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Will not exceed
this limit even if the string is not valid &quot;
<small>UTF&minus;8&quot;.</small></p>

<p style="margin-left:17%; margin-top: 1em">U8*
utf8_hop_forward(const U8 *s, SSize_t off, const U8
*end)</p>

<p style="margin-left:11%;">&quot;utf8_hop_safe&quot;</p>

<p style="margin-left:17%;">Return the
<small>UTF&minus;8</small> pointer &quot;s&quot; displaced
by up to &quot;off&quot; characters, either forward or
backward.</p>

<p style="margin-left:17%; margin-top: 1em">When moving
backward it will not move before &quot;start&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">When moving
forward it will not move beyond &quot;end&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Will not exceed
those limits even if the string is not valid &quot;
<small>UTF&minus;8&quot;.</small></p>

<p style="margin-left:17%; margin-top: 1em">U8*
utf8_hop_safe(const U8 *s, SSize_t off, const U8 *start,
<br>
const U8 *end)</p>


<p style="margin-left:11%;">&quot;UTF8_IS_INVARIANT&quot;</p>

<p style="margin-left:17%;">Evaluates to 1 if the byte
&quot;c&quot; represents the same character when encoded in
<small>UTF&minus;8</small> as when not; otherwise evaluates
to 0. <small>UTF&minus;8</small> invariant characters can be
copied as-is when converting to/from
<small>UTF&minus;8,</small> saving time.</p>

<p style="margin-left:17%; margin-top: 1em">In spite of the
name, this macro gives the correct result if the input
string from which &quot;c&quot; comes is not encoded in
<small>UTF&minus;8.</small></p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;UVCHR_IS_INVARIANT&quot; for checking if a
<small>UV</small> is invariant.</p>

<p style="margin-left:17%; margin-top: 1em">bool
UTF8_IS_INVARIANT(char c)</p>


<p style="margin-left:11%;">&quot;UTF8_IS_NONCHAR&quot;</p>

<p style="margin-left:17%;">Evaluates to non-zero if the
first few bytes of the string starting at &quot;s&quot; and
looking no further than &quot;e&nbsp;&minus;&nbsp;1&quot;
are well-formed <small>UTF&minus;8</small> that represents
one of the Unicode non-character code points; otherwise it
evaluates to 0. If non-zero, the value gives how many bytes
starting at &quot;s&quot; comprise the code point&rsquo;s
representation.</p>

<p style="margin-left:17%; margin-top: 1em">bool
UTF8_IS_NONCHAR(const U8 *s, const U8 *e)</p>


<p style="margin-left:11%;">&quot;UTF8_IS_REPLACEMENT&quot;</p>

<p style="margin-left:17%;">Evaluates to non-zero if the
first few bytes of the string starting at &quot;s&quot; and
looking no further than &quot;e&nbsp;&minus;&nbsp;1&quot;
are well-formed <small>UTF&minus;8</small> that represents
the Unicode <small>REPLACEMENT CHARACTER</small> ; otherwise
it evaluates to 0. If non-zero, the value gives how many
bytes starting at &quot;s&quot; comprise the code
point&rsquo;s representation.</p>

<p style="margin-left:17%; margin-top: 1em">bool
UTF8_IS_REPLACEMENT(const U8 *s, const U8 *e)</p>

<p style="margin-left:11%;">&quot;UTF8_IS_SUPER&quot;</p>

<p style="margin-left:17%;">Recall that Perl recognizes an
extension to <small>UTF&minus;8</small> that can encode code
points larger than the ones defined by Unicode, which are
0..0x10FFFF.</p>

<p style="margin-left:17%; margin-top: 1em">This macro
evaluates to non-zero if the first few bytes of the string
starting at &quot;s&quot; and looking no further than
&quot;e&nbsp;&minus;&nbsp;1&quot; are from this
<small>UTF&minus;8</small> extension; otherwise it evaluates
to 0. If non-zero, the return is how many bytes starting at
&quot;s&quot; comprise the code point&rsquo;s
representation.</p>

<p style="margin-left:17%; margin-top: 1em">0 is returned
if the bytes are not well-formed extended
<small>UTF&minus;8,</small> or if they represent a code
point that cannot fit in a <small>UV</small> on the current
platform. Hence this macro can give different results when
run on a 64&minus;bit word machine than on one with a
32&minus;bit word size.</p>

<p style="margin-left:17%; margin-top: 1em">Note that it is
illegal in Perl to have code points that are larger than
what can fit in an <small>IV</small> on the current machine;
and illegal in Unicode to have any that this macro
matches</p>

<p style="margin-left:17%; margin-top: 1em">bool
UTF8_IS_SUPER(const U8 *s, const U8 *e)</p>


<p style="margin-left:11%;">&quot;UTF8_IS_SURROGATE&quot;</p>

<p style="margin-left:17%;">Evaluates to non-zero if the
first few bytes of the string starting at &quot;s&quot; and
looking no further than &quot;e&nbsp;&minus;&nbsp;1&quot;
are well-formed <small>UTF&minus;8</small> that represents
one of the Unicode surrogate code points; otherwise it
evaluates to 0. If non-zero, the value gives how many bytes
starting at &quot;s&quot; comprise the code point&rsquo;s
representation.</p>

<p style="margin-left:17%; margin-top: 1em">bool
UTF8_IS_SURROGATE(const U8 *s, const U8 *e)</p>

<p style="margin-left:11%;">&quot;utf8_length&quot;</p>

<p style="margin-left:17%;">Returns the number of
characters in the sequence of UTF&minus;8&minus;encoded
bytes starting at &quot;s&quot; and ending at the byte just
before &quot;e&quot;. If &lt;s&gt; and &lt;e&gt; point to
the same place, it returns 0 with no warning raised.</p>

<p style="margin-left:17%; margin-top: 1em">If &quot;e &lt;
s&quot; or if the scan would end up past &quot;e&quot;, it
raises a <small>UTF8</small> warning and returns the number
of valid characters.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
utf8_length(const U8* s, const U8 *e)</p>

<p style="margin-left:11%;">&quot;UTF8_MAXBYTES&quot;</p>

<p style="margin-left:17%;">The maximum width of a single
<small>UTF&minus;8</small> encoded character, in bytes.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
Strictly speaking Perl&rsquo;s <small>UTF&minus;8</small>
should not be called <small>UTF&minus;8</small> since
<small>UTF&minus;8</small> is an encoding of Unicode, and
Unicode&rsquo;s upper limit, 0x10FFFF, can be expressed with
4 bytes. However, Perl thinks of <small>UTF&minus;8</small>
as a way to encode non-negative integers in a binary format,
even those above Unicode.</p>


<p style="margin-left:11%;">&quot;UTF8_MAXBYTES_CASE&quot;</p>

<p style="margin-left:17%;">The maximum number of
<small>UTF&minus;8</small> bytes a single Unicode character
can uppercase/lowercase/titlecase/fold into.</p>

<p style="margin-left:11%;">&quot;UTF8_SAFE_SKIP&quot;</p>

<p style="margin-left:17%;">returns 0 if
&quot;s&nbsp;&gt;=&nbsp;e&quot;; otherwise returns the
number of bytes in the <small>UTF&minus;8</small> encoded
character whose first byte is pointed to by &quot;s&quot;.
But it never returns beyond &quot;e&quot;. On
<small>DEBUGGING</small> builds, it asserts that
&quot;s&nbsp;&lt;=&nbsp;e&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
UTF8_SAFE_SKIP(char* s, char* e)</p>

<p style="margin-left:11%;">&quot;UTF8_SKIP&quot;</p>

<p style="margin-left:17%;">This is a synonym for
&quot;UTF8SKIP&quot;</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
UTF8_SKIP(char* s)</p>

<p style="margin-left:11%;">&quot;utf8_to_bytes&quot;</p>

<p style="margin-left:17%;"><small>NOTE:</small>
&quot;utf8_to_bytes&quot; is <b>experimental</b> and may
change or be removed without notice.</p>

<p style="margin-left:17%; margin-top: 1em">Converts a
string &quot;s&quot; of length *lenp from
<small>UTF&minus;8</small> into native byte encoding. Unlike
&quot;bytes_to_utf8&quot;, this over-writes the original
string, and updates *lenp to contain the new length. Returns
zero on failure (leaving &quot;s&quot; unchanged) setting
*lenp to &minus;1.</p>

<p style="margin-left:17%; margin-top: 1em">Upon successful
return, the number of variants in the string can be computed
by having saved the value of *lenp before the call, and
subtracting the after-call value of *lenp from it.</p>

<p style="margin-left:17%; margin-top: 1em">If you need a
copy of the string, see &quot;bytes_from_utf8&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">U8*
utf8_to_bytes(U8 *s, STRLEN *lenp)</p>

<p style="margin-left:11%;">&quot;utf8_to_uvchr&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;utf8_to_uvchr&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
native code point of the first character in the string
&quot;s&quot; which is assumed to be in
<small>UTF&minus;8</small> encoding; &quot;retlen&quot; will
be set to the length, in bytes, of that character.</p>

<p style="margin-left:17%; margin-top: 1em">Some, but not
all, <small>UTF&minus;8</small> malformations are detected,
and in fact, some malformed input could cause reading beyond
the end of the input buffer, which is why this function is
deprecated. Use &quot;utf8_to_uvchr_buf&quot; instead.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;s&quot; points to one of the detected malformations,
and <small>UTF8</small> warnings are enabled, zero is
returned and *retlen is set (if &quot;retlen&quot;
isn&rsquo;t &quot;NULL&quot;) to &minus;1. If those warnings
are off, the computed value if well-defined (or the Unicode
<small>REPLACEMENT CHARACTER,</small> if not) is silently
returned, and *retlen is set (if &quot;retlen&quot;
isn&rsquo;t <small>NULL</small> ) so that
(&quot;s&quot;&nbsp;+&nbsp;*retlen) is the next possible
position in &quot;s&quot; that could begin a non-malformed
character. See &quot;utf8n_to_uvchr&quot; for details on
when the <small>REPLACEMENT CHARACTER</small> is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">UV
utf8_to_uvchr(const U8 *s, STRLEN *retlen)</p>


<p style="margin-left:11%;">&quot;utf8_to_uvchr_buf&quot;</p>

<p style="margin-left:17%;">Returns the native code point
of the first character in the string &quot;s&quot; which is
assumed to be in <small>UTF&minus;8</small> encoding;
&quot;send&quot; points to 1 beyond the end of
&quot;s&quot;. *retlen will be set to the length, in bytes,
of that character.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;s&quot; does not point to a well-formed
<small>UTF&minus;8</small> character and <small>UTF8</small>
warnings are enabled, zero is returned and *retlen is set
(if &quot;retlen&quot; isn&rsquo;t &quot;NULL&quot;) to
&minus;1. If those warnings are off, the computed value, if
well-defined (or the Unicode <small>REPLACEMENT
CHARACTER</small> if not), is silently returned, and *retlen
is set (if &quot;retlen&quot; isn&rsquo;t &quot;NULL&quot;)
so that (&quot;s&quot;&nbsp;+&nbsp;*retlen) is the next
possible position in &quot;s&quot; that could begin a
non-malformed character. See &quot;utf8n_to_uvchr&quot; for
details on when the <small>REPLACEMENT CHARACTER</small> is
returned.</p>

<p style="margin-left:17%; margin-top: 1em">UV
utf8_to_uvchr_buf(const U8 *s, const U8 *send, STRLEN
*retlen)</p>


<p style="margin-left:11%;">&quot;UVCHR_IS_INVARIANT&quot;</p>

<p style="margin-left:17%;">Evaluates to 1 if the
representation of code point &quot;cp&quot; is the same
whether or not it is encoded in <small>UTF&minus;8</small> ;
otherwise evaluates to 0. <small>UTF&minus;8</small>
invariant characters can be copied as-is when converting
to/from <small>UTF&minus;8,</small> saving time.
&quot;cp&quot; is Unicode if above 255; otherwise is
platform-native.</p>

<p style="margin-left:17%; margin-top: 1em">bool
UVCHR_IS_INVARIANT(UV cp)</p>

<p style="margin-left:11%;">&quot;UVCHR_SKIP&quot;</p>

<p style="margin-left:17%;">returns the number of bytes
required to represent the code point &quot;cp&quot; when
encoded as <small>UTF&minus;8.</small> &quot;cp&quot; is a
native ( <small>ASCII</small> or <small>EBCDIC</small> )
code point if less than 255; a Unicode code point
otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
UVCHR_SKIP(UV cp)</p>

<p style="margin-left:11%;">&quot;uvchr_to_utf8&quot;</p>

<p style="margin-left:17%;">Adds the
<small>UTF&minus;8</small> representation of the native code
point &quot;uv&quot; to the end of the string &quot;d&quot;;
&quot;d&quot; should have at least
&quot;UVCHR_SKIP(uv)+1&quot; (up to
&quot;UTF8_MAXBYTES+1&quot;) free bytes available. The
return value is the pointer to the byte after the end of the
new character. In other words,</p>

<p style="margin-left:17%; margin-top: 1em">d =
uvchr_to_utf8(d, uv);</p>

<p style="margin-left:17%; margin-top: 1em">is the
recommended wide native character-aware way of saying</p>

<p style="margin-left:17%; margin-top: 1em">*(d++) =
uv;</p>

<p style="margin-left:17%; margin-top: 1em">This function
accepts any code point from 0..&quot;IV_MAX&quot; as input.
&quot;IV_MAX&quot; is typically 0x7FFF_FFFF in a
32&minus;bit word.</p>

<p style="margin-left:17%; margin-top: 1em">It is possible
to forbid or warn on non-Unicode code points, or those that
may be problematic by using
&quot;uvchr_to_utf8_flags&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">U8*
uvchr_to_utf8(U8 *d, UV uv)</p>


<p style="margin-left:11%;">&quot;uvchr_to_utf8_flags&quot;</p>

<p style="margin-left:17%;">Adds the
<small>UTF&minus;8</small> representation of the native code
point &quot;uv&quot; to the end of the string &quot;d&quot;;
&quot;d&quot; should have at least
&quot;UVCHR_SKIP(uv)+1&quot; (up to
&quot;UTF8_MAXBYTES+1&quot;) free bytes available. The
return value is the pointer to the byte after the end of the
new character. In other words,</p>

<p style="margin-left:17%; margin-top: 1em">d =
uvchr_to_utf8_flags(d, uv, flags);</p>

<p style="margin-left:17%; margin-top: 1em">or, in most
cases,</p>

<p style="margin-left:17%; margin-top: 1em">d =
uvchr_to_utf8_flags(d, uv, 0);</p>

<p style="margin-left:17%; margin-top: 1em">This is the
Unicode-aware way of saying</p>

<p style="margin-left:17%; margin-top: 1em">*(d++) =
uv;</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;flags&quot; is 0, this function accepts any code point
from 0..&quot;IV_MAX&quot; as input. &quot;IV_MAX&quot; is
typically 0x7FFF_FFFF in a 32&minus;bit word.</p>

<p style="margin-left:17%; margin-top: 1em">Specifying
&quot;flags&quot; can further restrict what is allowed and
not warned on, as follows:</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;uv&quot; is a Unicode surrogate code point and
&quot;UNICODE_WARN_SURROGATE&quot; is set, the function will
raise a warning, provided <small>UTF8</small> warnings are
enabled. If instead &quot;UNICODE_DISALLOW_SURROGATE&quot;
is set, the function will fail and return
<small>NULL.</small> If both flags are set, the function
will both warn and return <small>NULL.</small></p>

<p style="margin-left:17%; margin-top: 1em">Similarly, the
&quot;UNICODE_WARN_NONCHAR&quot; and
&quot;UNICODE_DISALLOW_NONCHAR&quot; flags affect how the
function handles a Unicode non-character.</p>

<p style="margin-left:17%; margin-top: 1em">And likewise,
the &quot;UNICODE_WARN_SUPER&quot; and
&quot;UNICODE_DISALLOW_SUPER&quot; flags affect the handling
of code points that are above the Unicode maximum of
0x10FFFF. Languages other than Perl may not be able to
accept files that contain these.</p>

<p style="margin-left:17%; margin-top: 1em">The flag
&quot;UNICODE_WARN_ILLEGAL_INTERCHANGE&quot; selects all
three of the above <small>WARN</small> flags; and
&quot;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&quot; selects all
three <small>DISALLOW</small> flags.
&quot;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&quot; restricts
the allowed inputs to the strict <small>UTF&minus;8</small>
traditionally defined by Unicode. Similarly,
&quot;UNICODE_WARN_ILLEGAL_C9_INTERCHANGE&quot; and
&quot;UNICODE_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot; are
shortcuts to select the above-Unicode and surrogate flags,
but not the non-character ones, as defined in Unicode
Corrigendum #9
&lt;https://www.unicode.org/versions/corrigendum9.html&gt;.
See &quot;Noncharacter code points&quot; in perlunicode.</p>

<p style="margin-left:17%; margin-top: 1em">Extremely high
code points were never specified in any standard, and
require an extension to <small>UTF&minus;8</small> to
express, which Perl does. It is likely that programs written
in something other than Perl would not be able to read files
that contain these; nor would Perl understand files written
by something that uses a different extension. For these
reasons, there is a separate set of flags that can warn
and/or disallow these extremely high code points, even if
other above-Unicode ones are accepted. They are the
&quot;UNICODE_WARN_PERL_EXTENDED&quot; and
&quot;UNICODE_DISALLOW_PERL_EXTENDED&quot; flags. For more
information see &quot;UTF8_GOT_PERL_EXTENDED&quot;. Of
course &quot;UNICODE_DISALLOW_SUPER&quot; will treat all
above-Unicode code points, including these, as
malformations. (Note that the Unicode standard considers
anything above 0x10FFFF to be illegal, but there are
standards predating it that allow up to 0x7FFF_FFFF (2**31
&minus;1))</p>

<p style="margin-left:17%; margin-top: 1em">A somewhat
misleadingly named synonym for
&quot;UNICODE_WARN_PERL_EXTENDED&quot; is retained for
backward compatibility:
&quot;UNICODE_WARN_ABOVE_31_BIT&quot;. Similarly,
&quot;UNICODE_DISALLOW_ABOVE_31_BIT&quot; is usable instead
of the more accurately named
&quot;UNICODE_DISALLOW_PERL_EXTENDED&quot;. The names are
misleading because on <small>EBCDIC</small> platforms,these
flags can apply to code points that actually do fit in 31
bits. The new names accurately describe the situation in all
cases.</p>

<p style="margin-left:17%; margin-top: 1em">U8*
uvchr_to_utf8_flags(U8 *d, UV uv, UV flags)</p>


<p style="margin-left:11%;">&quot;uvchr_to_utf8_flags_msgs&quot;</p>

<p style="margin-left:17%;"><small>THIS FUNCTION SHOULD BE
USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.</small></p>

<p style="margin-left:17%; margin-top: 1em">Most code
should use &quot;&quot;uvchr_to_utf8_flags&quot;()&quot;
rather than call this directly.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is for code that wants any warning and/or error messages to
be returned to the caller rather than be displayed. All
messages that would have been displayed if all lexical
warnings are enabled will be returned.</p>

<p style="margin-left:17%; margin-top: 1em">It is just like
&quot;uvchr_to_utf8_flags&quot; but it takes an extra
parameter placed after all the others, &quot;msgs&quot;. If
this parameter is 0, this function behaves identically to
&quot;uvchr_to_utf8_flags&quot;. Otherwise, &quot;msgs&quot;
should be a pointer to an &quot;HV *&quot; variable, in
which this function creates a new <small>HV</small> to
contain any appropriate messages. The hash has three
key-value pairs, as follows: <br>
&quot;text&quot;</p>

<p style="margin-left:23%;">The text of the message as a
&quot;SVpv&quot;.</p>


<p style="margin-left:17%;">&quot;warn_categories&quot;</p>

<p style="margin-left:23%;">The warning category (or
categories) packed into a &quot;SVuv&quot;.</p>

<p style="margin-left:17%;">&quot;flag&quot;</p>

<p style="margin-left:23%;">A single flag bit associated
with this message, in a &quot;SVuv&quot;. The bit
corresponds to some bit in the *errors return value, such as
&quot;UNICODE_GOT_SURROGATE&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
important to note that specifying this parameter as non-null
will cause any warnings this function would otherwise
generate to be suppressed, and instead be placed in *msgs.
The caller can check the lexical warnings state (or not)
when choosing what to do with the returned messages.</p>

<p style="margin-left:17%; margin-top: 1em">The caller, of
course, is responsible for freeing any returned
<small>HV.</small></p>

<p style="margin-left:17%; margin-top: 1em">U8*
uvchr_to_utf8_flags_msgs(U8 *d, UV uv, UV flags, HV **
msgs)</p>

<h2>Utility Functions
<a name="Utility Functions"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;C_ARRAY_END&quot;</p>

<p style="margin-left:17%;">Returns a pointer to one
element past the final element of the input C array.</p>

<p style="margin-left:17%; margin-top: 1em">void *
C_ARRAY_END(void *a)</p>

<p style="margin-left:11%;">&quot;C_ARRAY_LENGTH&quot;</p>

<p style="margin-left:17%;">Returns the number of elements
in the input C array (so you want your zero-based indices to
be less than but not equal to).</p>

<p style="margin-left:17%; margin-top: 1em">STRLEN
C_ARRAY_LENGTH(void *a)</p>

<p style="margin-left:11%;">&quot;getcwd_sv&quot;</p>

<p style="margin-left:17%;">Fill &quot;sv&quot; with
current working directory</p>

<p style="margin-left:17%; margin-top: 1em">int
getcwd_sv(SV* sv)</p>


<p style="margin-left:11%;">&quot;IN_PERL_COMPILETIME&quot;</p>

<p style="margin-left:17%;">Returns 1 if this macro is
being called during the compilation phase of the program;
otherwise 0;</p>

<p style="margin-left:17%; margin-top: 1em">bool
IN_PERL_COMPILETIME</p>


<p style="margin-left:11%;">&quot;IN_PERL_RUNTIME&quot;</p>

<p style="margin-left:17%;">Returns 1 if this macro is
being called during the execution phase of the program;
otherwise 0;</p>

<p style="margin-left:17%; margin-top: 1em">bool
IN_PERL_RUNTIME</p>


<p style="margin-left:11%;">&quot;IS_SAFE_SYSCALL&quot;</p>

<p style="margin-left:17%;">Same as
&quot;is_safe_syscall&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool
IS_SAFE_SYSCALL(NN const char *pv, STRLEN len, <br>
NN const char *what, NN const char *op_name)</p>


<p style="margin-left:11%;">&quot;is_safe_syscall&quot;</p>

<p style="margin-left:17%;">Test that the given
&quot;pv&quot; (with length &quot;len&quot;) doesn&rsquo;t
contain any internal &quot;NUL&quot; characters. If it does,
set &quot;errno&quot; to &quot;ENOENT&quot;, optionally warn
using the &quot;syscalls&quot; category, and return
<small>FALSE.</small></p>

<p style="margin-left:17%; margin-top: 1em">Return
<small>TRUE</small> if the name is safe.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;what&quot;
and &quot;op_name&quot; are used in any warning.</p>

<p style="margin-left:17%; margin-top: 1em">Used by the
&quot;IS_SAFE_SYSCALL()&quot; macro.</p>

<p style="margin-left:17%; margin-top: 1em">bool
is_safe_syscall(const char *pv, STRLEN len, <br>
const char *what, const char *op_name)</p>

<p style="margin-left:11%;">&quot;my_setenv&quot;</p>

<p style="margin-left:17%;">A wrapper for the C library
<b>setenv</b>(3). Don&rsquo;t use the latter, as the perl
version has desirable safeguards</p>

<p style="margin-left:17%; margin-top: 1em">void
my_setenv(const char* nam, const char* val)</p>

<p style="margin-left:11%;">&quot;phase_name&quot;</p>

<p style="margin-left:17%;">Returns the given phase&rsquo;s
name as a NUL-terminated string.</p>

<p style="margin-left:17%; margin-top: 1em">For example, to
print a stack trace that includes the current interpreter
phase you might do:</p>

<p style="margin-left:17%; margin-top: 1em">const char*
phase_name = phase_name(PL_phase); <br>
mess(&quot;This is weird. (Perl phase: %s)&quot;,
phase_name);</p>

<p style="margin-left:17%; margin-top: 1em">const char
*const phase_name(enum perl_phase)</p>

<p style="margin-left:11%;">&quot;Poison&quot;</p>

<p style="margin-left:17%;">PoisonWith(0xEF) for catching
access to freed memory.</p>

<p style="margin-left:17%; margin-top: 1em">void
Poison(void* dest, int nitems, type)</p>

<p style="margin-left:11%;">&quot;PoisonFree&quot;</p>

<p style="margin-left:17%;">PoisonWith(0xEF) for catching
access to freed memory.</p>

<p style="margin-left:17%; margin-top: 1em">void
PoisonFree(void* dest, int nitems, type)</p>

<p style="margin-left:11%;">&quot;PoisonNew&quot;</p>

<p style="margin-left:17%;">PoisonWith(0xAB) for catching
access to allocated but uninitialized memory.</p>

<p style="margin-left:17%; margin-top: 1em">void
PoisonNew(void* dest, int nitems, type)</p>

<p style="margin-left:11%;">&quot;PoisonWith&quot;</p>

<p style="margin-left:17%;">Fill up memory with a byte
pattern (a byte repeated over and over again) that hopefully
catches attempts to access uninitialized memory.</p>

<p style="margin-left:17%; margin-top: 1em">void
PoisonWith(void* dest, int nitems, type, U8 byte)</p>

<p style="margin-left:11%;">&quot;StructCopy&quot;</p>

<p style="margin-left:17%;">This is an
architecture-independent macro to copy one structure to
another.</p>

<p style="margin-left:17%; margin-top: 1em">void
StructCopy(type *src, type *dest, type)</p>

<p style="margin-left:11%;">&quot;sv_destroyable&quot;</p>

<p style="margin-left:17%;">Dummy routine which reports
that object can be destroyed when there is no sharing module
present. It ignores its single <small>SV</small> argument,
and returns &rsquo;true&rsquo;. Exists to avoid test for a
&quot;NULL&quot; function pointer and because it could
potentially warn under some level of strict-ness.</p>

<p style="margin-left:17%; margin-top: 1em">bool
sv_destroyable(SV *sv)</p>

<p style="margin-left:11%;">&quot;sv_nosharing&quot;</p>

<p style="margin-left:17%;">Dummy routine which
&quot;shares&quot; an <small>SV</small> when there is no
sharing module present. Or &quot;locks&quot; it. Or
&quot;unlocks&quot; it. In other words, ignores its single
<small>SV</small> argument. Exists to avoid test for a
&quot;NULL&quot; function pointer and because it could
potentially warn under some level of strict-ness.</p>

<p style="margin-left:17%; margin-top: 1em">void
sv_nosharing(SV *sv)</p>

<h2>Versioning
<a name="Versioning"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;new_version&quot;</p>

<p style="margin-left:17%;">Returns a new version object
based on the passed in <small>SV:</small></p>

<p style="margin-left:17%; margin-top: 1em">SV *sv =
new_version(SV *ver);</p>

<p style="margin-left:17%; margin-top: 1em">Does not alter
the passed in ver <small>SV.</small> See
&quot;upg_version&quot; if you want to upgrade the
<small>SV.</small></p>

<p style="margin-left:17%; margin-top: 1em">SV*
new_version(SV *ver)</p>

<p style="margin-left:11%;">&quot;PERL_REVISION&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;PERL_REVISION&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">The major
number component of the perl interpreter currently being
compiled or executing. This has been 5 from 1993 into
2020.</p>

<p style="margin-left:17%; margin-top: 1em">Instead use one
of the version comparison macros. See
&quot;PERL_VERSION_EQ&quot;.</p>


<p style="margin-left:11%;">&quot;PERL_SUBVERSION&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;PERL_SUBVERSION&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">The micro
number component of the perl interpreter currently being
compiled or executing. In stable releases this gives the dot
release number for maintenance updates. In development
releases this gives a tag for a snapshot of the status at
various points in the development cycle.</p>

<p style="margin-left:17%; margin-top: 1em">Instead use one
of the version comparison macros. See
&quot;PERL_VERSION_EQ&quot;.</p>

<p style="margin-left:11%;">&quot;PERL_VERSION&quot;</p>

<p style="margin-left:17%;">&quot;<b>DEPRECATED!</b>&quot;
It is planned to remove &quot;PERL_VERSION&quot; from a
future release of Perl. Do not use it for new code; remove
it from existing code.</p>

<p style="margin-left:17%; margin-top: 1em">The minor
number component of the perl interpreter currently being
compiled or executing. Between 1993 into 2020, this has
ranged from 0 to 33.</p>

<p style="margin-left:17%; margin-top: 1em">Instead use one
of the version comparison macros. See
&quot;PERL_VERSION_EQ&quot;.</p>

<p style="margin-left:11%;">&quot;PERL_VERSION_EQ&quot;
<br>
&quot;PERL_VERSION_NE&quot; <br>
&quot;PERL_VERSION_LT&quot; <br>
&quot;PERL_VERSION_LE&quot; <br>
&quot;PERL_VERSION_GT&quot; <br>
&quot;PERL_VERSION_GE&quot;</p>

<p style="margin-left:17%;">Returns whether or not the perl
currently being compiled has the specified relationship to
the perl given by the parameters. For example,</p>

<p style="margin-left:17%; margin-top: 1em">#if
PERL_VERSION_GT(5,24,2) <br>
code that will only be compiled on perls after v5.24.2 <br>
#else <br>
fallback code <br>
#endif</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
is usable in making compile-time decisions</p>

<p style="margin-left:17%; margin-top: 1em">You may use the
special value &rsquo;*&rsquo; for the final number to mean
<small>ALL</small> possible values for it. Thus,</p>

<p style="margin-left:17%; margin-top: 1em">#if
PERL_VERSION_EQ(5,31,'*')</p>

<p style="margin-left:17%; margin-top: 1em">means all perls
in the 5.31 series. And</p>

<p style="margin-left:17%; margin-top: 1em">#if
PERL_VERSION_NE(5,24,'*')</p>

<p style="margin-left:17%; margin-top: 1em">means all perls
<small>EXCEPT 5.24</small> ones. And</p>

<p style="margin-left:17%; margin-top: 1em">#if
PERL_VERSION_LE(5,9,'*')</p>

<p style="margin-left:17%; margin-top: 1em">is
effectively</p>

<p style="margin-left:17%; margin-top: 1em">#if
PERL_VERSION_LT(5,10,0)</p>

<p style="margin-left:17%; margin-top: 1em">This means you
don&rsquo;t have to think so much when converting from the
existing deprecated &quot;PERL_VERSION&quot; to using this
macro:</p>

<p style="margin-left:17%; margin-top: 1em">#if
PERL_VERSION &lt;= 9</p>

<p style="margin-left:17%; margin-top: 1em">becomes</p>

<p style="margin-left:17%; margin-top: 1em">#if
PERL_VERSION_LE(5,9,'*')</p>

<p style="margin-left:17%; margin-top: 1em">bool
PERL_VERSION_EQ(const U8 major, const U8 minor, <br>
const U8 patch)</p>


<p style="margin-left:11%;">&quot;prescan_version&quot;</p>

<p style="margin-left:17%;">Validate that a given string
can be parsed as a version object, but doesn&rsquo;t
actually perform the parsing. Can use either strict or lax
validation rules. Can optionally set a number of hint
variables to save the parsing code some time when
tokenizing.</p>

<p style="margin-left:17%; margin-top: 1em">const char*
prescan_version(const char *s, bool strict, <br>
const char** errstr, bool *sqv, <br>
int *ssaw_decimal, int *swidth, <br>
bool *salpha)</p>

<p style="margin-left:11%;">&quot;scan_version&quot;</p>

<p style="margin-left:17%;">Returns a pointer to the next
character after the parsed version string, as well as
upgrading the passed in <small>SV</small> to an
<small>RV.</small></p>

<p style="margin-left:17%; margin-top: 1em">Function must
be called with an already existing <small>SV</small>
like</p>

<p style="margin-left:17%; margin-top: 1em">sv = newSV(0);
<br>
s = scan_version(s, SV *sv, bool qv);</p>

<p style="margin-left:17%; margin-top: 1em">Performs some
preprocessing to the string to ensure that it has the
correct characteristics of a version. Flags the object if it
contains an underscore (which denotes this is an alpha
version). The boolean qv denotes that the version should be
interpreted as if it had multiple decimals, even if it
doesn&rsquo;t.</p>

<p style="margin-left:17%; margin-top: 1em">const char*
scan_version(const char *s, SV *rv, bool qv)</p>

<p style="margin-left:11%;">&quot;upg_version&quot;</p>

<p style="margin-left:17%;">In-place upgrade of the
supplied <small>SV</small> to a version object.</p>

<p style="margin-left:17%; margin-top: 1em">SV *sv =
upg_version(SV *sv, bool qv);</p>

<p style="margin-left:17%; margin-top: 1em">Returns a
pointer to the upgraded <small>SV.</small> Set the boolean
qv if you want to force this <small>SV</small> to be
interpreted as an &quot;extended&quot; version.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
upg_version(SV *ver, bool qv)</p>

<p style="margin-left:11%;">&quot;vcmp&quot;</p>

<p style="margin-left:17%;">Version object aware cmp. Both
operands must already have been converted into version
objects.</p>

<p style="margin-left:17%; margin-top: 1em">int vcmp(SV
*lhv, SV *rhv)</p>

<p style="margin-left:11%;">&quot;vnormal&quot;</p>

<p style="margin-left:17%;">Accepts a version object and
returns the normalized string representation. Call like:</p>

<p style="margin-left:17%; margin-top: 1em">sv =
vnormal(rv);</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
you can pass either the object directly or the
<small>SV</small> contained within the
<small>RV.</small></p>

<p style="margin-left:17%; margin-top: 1em">The
<small>SV</small> returned has a refcount of 1.</p>

<p style="margin-left:17%; margin-top: 1em">SV* vnormal(SV
*vs)</p>

<p style="margin-left:11%;">&quot;vnumify&quot;</p>

<p style="margin-left:17%;">Accepts a version object and
returns the normalized floating point representation. Call
like:</p>

<p style="margin-left:17%; margin-top: 1em">sv =
vnumify(rv);</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
you can pass either the object directly or the
<small>SV</small> contained within the
<small>RV.</small></p>

<p style="margin-left:17%; margin-top: 1em">The
<small>SV</small> returned has a refcount of 1.</p>

<p style="margin-left:17%; margin-top: 1em">SV* vnumify(SV
*vs)</p>

<p style="margin-left:11%;">&quot;vstringify&quot;</p>

<p style="margin-left:17%;">In order to maintain maximum
compatibility with earlier versions of Perl, this function
will return either the floating point notation or the
multiple dotted notation, depending on whether the original
version contained 1 or more dots, respectively.</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>SV</small> returned has a refcount of 1.</p>

<p style="margin-left:17%; margin-top: 1em">SV*
vstringify(SV *vs)</p>

<p style="margin-left:11%;">&quot;vverify&quot;</p>

<p style="margin-left:17%;">Validates that the
<small>SV</small> contains valid internal structure for a
version object. It may be passed either the version object (
<small>RV</small> ) or the hash itself ( <small>HV</small>
). If the structure is valid, it returns the
<small>HV.</small> If the structure is invalid, it returns
<small>NULL.</small></p>

<p style="margin-left:17%; margin-top: 1em">SV *hv =
vverify(sv);</p>

<p style="margin-left:17%; margin-top: 1em">Note that it
only confirms the bare minimum structure (so as not to get
confused by derived classes which may contain additional
hash entries):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>The <small>SV</small> is an <small>HV</small> or a
reference to an <small>HV</small></p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>The hash contains a &quot;version&quot; key</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>The &quot;version&quot; key has a reference to an
<small>AV</small> as its value</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">SV* vverify(SV
*vs)</p>

<h2>Warning and Dieing
<a name="Warning and Dieing"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In all these
calls, the &quot;U32 w<i>n</i>&quot; parameters are warning
category constants. You can see the ones currently available
in &quot;Category Hierarchy&quot; in warnings, just
capitalize all letters in the names and prefix them by
&quot;WARN_&quot;. So, for example, the category
&quot;void&quot; used in a perl program becomes
&quot;WARN_VOID&quot; when used in <small>XS</small> code
and passed to one of the calls below. <br>
&quot;ckWARN&quot; <br>
&quot;ckWARN2&quot; <br>
&quot;ckWARN3&quot; <br>
&quot;ckWARN4&quot;</p>

<p style="margin-left:17%;">These return a boolean as to
whether or not warnings are enabled for any of the warning
category(ies) parameters: &quot;w&quot;, &quot;w1&quot;,
....</p>

<p style="margin-left:17%; margin-top: 1em">Should any of
the categories by default be enabled even if not within the
scope of &quot;use&nbsp;warnings&quot;, instead use the
&quot;ckWARN_d&quot; macros.</p>

<p style="margin-left:17%; margin-top: 1em">The categories
must be completely independent, one may not be subclassed
from the other.</p>

<p style="margin-left:17%; margin-top: 1em">bool ckWARN
(U32 w) <br>
bool ckWARN2(U32 w1, U32 w2) <br>
bool ckWARN3(U32 w1, U32 w2, U32 w3) <br>
bool ckWARN4(U32 w1, U32 w2, U32 w3, U32 w4)</p>

<p style="margin-left:11%;">&quot;ckWARN_d&quot; <br>
&quot;ckWARN2_d&quot; <br>
&quot;ckWARN3_d&quot; <br>
&quot;ckWARN4_d&quot;</p>

<p style="margin-left:17%;">Like &quot;ckWARN&quot;, but
for use if and only if the warning category(ies) is by
default enabled even if not within the scope of
&quot;use&nbsp;warnings&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">bool ckWARN_d
(U32 w) <br>
bool ckWARN2_d(U32 w1, U32 w2) <br>
bool ckWARN3_d(U32 w1, U32 w2, U32 w3) <br>
bool ckWARN4_d(U32 w1, U32 w2, U32 w3, U32 w4)</p>

<p style="margin-left:11%;">&quot;ck_warner&quot; <br>
&quot;ck_warner_d&quot;</p>

<p style="margin-left:17%;">If none of the warning
categories given by &quot;err&quot; are enabled, do nothing;
otherwise call &quot;warner&quot; or
&quot;warner_nocontext&quot; with the passed-in
parameters;.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;err&quot;
must be one of the &quot;packWARN&quot;,
&quot;packWARN2&quot;, &quot;packWARN3&quot;,
&quot;packWARN4&quot; macros populated with the appropriate
number of warning categories.</p>

<p style="margin-left:17%; margin-top: 1em">The two forms
differ only in that &quot;ck_warner_d&quot; should be used
if warnings for any of the categories are by default
enabled.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;ck_warner&quot; must be explicitly called as
&quot;Perl_ck_warner&quot; with an &quot;aTHX_&quot;
parameter.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;ck_warner_d&quot; must be explicitly called as
&quot;Perl_ck_warner_d&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_ck_warner(pTHX_ U32 err, const char* pat, ...)</p>

<p style="margin-left:11%;">&quot;CLEAR_ERRSV&quot;</p>

<p style="margin-left:17%;">Clear the contents of $@,
setting it to the empty string.</p>

<p style="margin-left:17%; margin-top: 1em">This replaces
any read-only <small>SV</small> with a fresh
<small>SV</small> and removes any magic.</p>

<p style="margin-left:17%; margin-top: 1em">void
CLEAR_ERRSV()</p>

<p style="margin-left:11%;">&quot;croak&quot; <br>
&quot;croak_nocontext&quot;</p>

<p style="margin-left:17%;">These are <small>XS</small>
interfaces to Perl&rsquo;s &quot;die&quot; function.</p>

<p style="margin-left:17%; margin-top: 1em">They take a
sprintf-style format pattern and argument list, which are
used to generate a string message. If the message does not
end with a newline, then it will be extended with some
indication of the current location in the code, as described
for &quot;mess_sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The error
message will be used as an exception, by default returning
control to the nearest enclosing &quot;eval&quot;, but
subject to modification by a $SIG{__DIE__} handler. In any
case, these croak functions never return normally.</p>

<p style="margin-left:17%; margin-top: 1em">For historical
reasons, if &quot;pat&quot; is null then the contents of
&quot;ERRSV&quot; ($@) will be used as an error message or
object instead of building an error message from arguments.
If you want to throw a non-string object, or build an error
message in an <small>SV</small> yourself, it is preferable
to use the &quot;croak_sv&quot; function, which does not
involve clobbering &quot;ERRSV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The two forms
differ only in that &quot;croak_nocontext&quot; does not
take a thread context (&quot;aTHX&quot;) parameter. It is
usually preferred as it takes up fewer bytes of code than
plain &quot;Perl_croak&quot;, and time is rarely a critical
resource when you are about to throw an exception.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;croak&quot; must be explicitly called as
&quot;Perl_croak&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void Perl_croak
(pTHX_ const char* pat, ...) <br>
void croak_nocontext(const char* pat, ...)</p>


<p style="margin-left:11%;">&quot;croak_no_modify&quot;</p>

<p style="margin-left:17%;">This encapsulates a common
reason for dying, generating terser object code than using
the generic &quot;Perl_croak&quot;. It is exactly equivalent
to &quot;Perl_croak(aTHX_ &quot;%s&quot;,
PL_no_modify)&quot; (which expands to something like
&quot;Modification of a read-only value
attempted&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">Less code used
on exception code paths reduces <small>CPU</small> cache
pressure.</p>

<p style="margin-left:17%; margin-top: 1em">void
croak_no_modify()</p>

<p style="margin-left:11%;">&quot;croak_sv&quot;</p>

<p style="margin-left:17%;">This is an <small>XS</small>
interface to Perl&rsquo;s &quot;die&quot; function.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;baseex&quot;
is the error message or object. If it is a reference, it
will be used as-is. Otherwise it is used as a string, and if
it does not end with a newline then it will be extended with
some indication of the current location in the code, as
described for &quot;mess_sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The error
message or object will be used as an exception, by default
returning control to the nearest enclosing &quot;eval&quot;,
but subject to modification by a $SIG{__DIE__} handler. In
any case, the &quot;croak_sv&quot; function never returns
normally.</p>

<p style="margin-left:17%; margin-top: 1em">To die with a
simple string message, the &quot;croak&quot; function may be
more convenient.</p>

<p style="margin-left:17%; margin-top: 1em">void
croak_sv(SV *baseex)</p>

<p style="margin-left:11%;">&quot;die&quot; <br>
&quot;die_nocontext&quot;</p>

<p style="margin-left:17%;">These behave the same as
&quot;croak&quot;, except for the return type. They should
be used only where the &quot;OP *&quot; return type is
required. They never actually return.</p>

<p style="margin-left:17%; margin-top: 1em">The two forms
differ only in that &quot;die_nocontext&quot; does not take
a thread context (&quot;aTHX&quot;) parameter, so is used in
situations where the caller doesn&rsquo;t already have the
thread context.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;die&quot; must be explicitly called as
&quot;Perl_die&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">OP* Perl_die
(pTHX_ const char* pat, ...) <br>
OP* die_nocontext(const char* pat, ...)</p>

<p style="margin-left:11%;">&quot;die_sv&quot;</p>

<p style="margin-left:17%;">This behaves the same as
&quot;croak_sv&quot;, except for the return type. It should
be used only where the &quot;OP *&quot; return type is
required. The function never actually returns.</p>

<p style="margin-left:17%; margin-top: 1em">OP* die_sv(SV
*baseex)</p>

<p style="margin-left:11%;">&quot;ERRSV&quot;</p>

<p style="margin-left:17%;">Returns the <small>SV</small>
for $@, creating it if needed.</p>

<p style="margin-left:17%; margin-top: 1em">SV * ERRSV</p>

<p style="margin-left:11%;">&quot;packWARN&quot; <br>
&quot;packWARN2&quot; <br>
&quot;packWARN3&quot; <br>
&quot;packWARN4&quot;</p>

<p style="margin-left:17%;">These macros are used to pack
warning categories into a single U32 to pass to macros and
functions that take a warning category parameter. The number
of categories to pack is given by the name, with a
corresponding number of category parameters passed.</p>

<p style="margin-left:17%; margin-top: 1em">U32 packWARN
(U32 w1) <br>
U32 packWARN2(U32 w1, U32 w2) <br>
U32 packWARN3(U32 w1, U32 w2, U32 w3) <br>
U32 packWARN4(U32 w1, U32 w2, U32 w3, U32 w4)</p>

<p style="margin-left:11%;">&quot;SANE_ERRSV&quot;</p>

<p style="margin-left:17%;">Clean up <small>ERRSV</small>
so we can safely set it.</p>

<p style="margin-left:17%; margin-top: 1em">This replaces
any read-only <small>SV</small> with a fresh writable copy
and removes any magic.</p>

<p style="margin-left:17%; margin-top: 1em">void
SANE_ERRSV()</p>

<p style="margin-left:11%;">&quot;vcroak&quot;</p>

<p style="margin-left:17%;">This is an <small>XS</small>
interface to Perl&rsquo;s &quot;die&quot; function.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;pat&quot;
and &quot;args&quot; are a sprintf-style format pattern and
encapsulated argument list. These are used to generate a
string message. If the message does not end with a newline,
then it will be extended with some indication of the current
location in the code, as described for
&quot;mess_sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The error
message will be used as an exception, by default returning
control to the nearest enclosing &quot;eval&quot;, but
subject to modification by a $SIG{__DIE__} handler. In any
case, the &quot;croak&quot; function never returns
normally.</p>

<p style="margin-left:17%; margin-top: 1em">For historical
reasons, if &quot;pat&quot; is null then the contents of
&quot;ERRSV&quot; ($@) will be used as an error message or
object instead of building an error message from arguments.
If you want to throw a non-string object, or build an error
message in an <small>SV</small> yourself, it is preferable
to use the &quot;croak_sv&quot; function, which does not
involve clobbering &quot;ERRSV&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">void
vcroak(const char* pat, va_list* args)</p>

<p style="margin-left:11%;">&quot;vwarn&quot;</p>

<p style="margin-left:17%;">This is an <small>XS</small>
interface to Perl&rsquo;s &quot;warn&quot; function.</p>

<p style="margin-left:17%; margin-top: 1em">This is like
&quot;warn&quot;, but &quot;args&quot; are an encapsulated
argument list.</p>

<p style="margin-left:17%; margin-top: 1em">Unlike with
&quot;vcroak&quot;, &quot;pat&quot; is not permitted to be
null.</p>

<p style="margin-left:17%; margin-top: 1em">void
vwarn(const char* pat, va_list* args)</p>

<p style="margin-left:11%;">&quot;vwarner&quot;</p>

<p style="margin-left:17%;">This is like
&quot;warner&quot;, but &quot;args&quot; are an encapsulated
argument list.</p>

<p style="margin-left:17%; margin-top: 1em">void
vwarner(U32 err, const char* pat, va_list* args)</p>

<p style="margin-left:11%;">&quot;warn&quot; <br>
&quot;warn_nocontext&quot;</p>

<p style="margin-left:17%;">These are <small>XS</small>
interfaces to Perl&rsquo;s &quot;warn&quot; function.</p>

<p style="margin-left:17%; margin-top: 1em">They take a
sprintf-style format pattern and argument list, which are
used to generate a string message. If the message does not
end with a newline, then it will be extended with some
indication of the current location in the code, as described
for &quot;mess_sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The error
message or object will by default be written to standard
error, but this is subject to modification by a
$SIG{__WARN__} handler.</p>

<p style="margin-left:17%; margin-top: 1em">Unlike with
&quot;croak&quot;, &quot;pat&quot; is not permitted to be
null.</p>

<p style="margin-left:17%; margin-top: 1em">The two forms
differ only in that &quot;warn_nocontext&quot; does not take
a thread context (&quot;aTHX&quot;) parameter, so is used in
situations where the caller doesn&rsquo;t already have the
thread context.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;warn&quot; must be explicitly called as
&quot;Perl_warn&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void Perl_warn
(pTHX_ const char* pat, ...) <br>
void warn_nocontext(const char* pat, ...)</p>

<p style="margin-left:11%;">&quot;warner&quot; <br>
&quot;warner_nocontext&quot;</p>

<p style="margin-left:17%;">These output a warning of the
specified category (or categories) given by &quot;err&quot;,
using the sprintf-style format pattern &quot;pat&quot;, and
argument list.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;err&quot;
must be one of the &quot;packWARN&quot;,
&quot;packWARN2&quot;, &quot;packWARN3&quot;,
&quot;packWARN4&quot; macros populated with the appropriate
number of warning categories. If any of the warning
categories they specify is fatal, a fatal exception is
thrown.</p>

<p style="margin-left:17%; margin-top: 1em">In any event a
message is generated by the pattern and arguments. If the
message does not end with a newline, then it will be
extended with some indication of the current location in the
code, as described for &quot;mess_sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The error
message or object will by default be written to standard
error, but this is subject to modification by a
$SIG{__WARN__} handler.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;pat&quot;
is not permitted to be null.</p>

<p style="margin-left:17%; margin-top: 1em">The two forms
differ only in that &quot;warner_nocontext&quot; does not
take a thread context (&quot;aTHX&quot;) parameter, so is
used in situations where the caller doesn&rsquo;t already
have the thread context.</p>

<p style="margin-left:17%; margin-top: 1em">These functions
differ from the similarly named &quot;warn&quot; functions,
in that the latter are for <small>XS</small> code to
unconditionally display a warning, whereas these are for
code that may be compiling a perl program, and does extra
checking to see if the warning should be fatal.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
&quot;warner&quot; must be explicitly called as
&quot;Perl_warner&quot; with an &quot;aTHX_&quot;
parameter.</p>

<p style="margin-left:17%; margin-top: 1em">void
Perl_warner (pTHX_ U32 err, const char* pat, ...) <br>
void warner_nocontext(U32 err, const char* pat, ...)</p>

<p style="margin-left:11%;">&quot;warn_sv&quot;</p>

<p style="margin-left:17%;">This is an <small>XS</small>
interface to Perl&rsquo;s &quot;warn&quot; function.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;baseex&quot;
is the error message or object. If it is a reference, it
will be used as-is. Otherwise it is used as a string, and if
it does not end with a newline then it will be extended with
some indication of the current location in the code, as
described for &quot;mess_sv&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The error
message or object will by default be written to standard
error, but this is subject to modification by a
$SIG{__WARN__} handler.</p>

<p style="margin-left:17%; margin-top: 1em">To warn with a
simple string message, the &quot;warn&quot; function may be
more convenient.</p>

<p style="margin-left:17%; margin-top: 1em">void warn_sv(SV
*baseex)</p>

<h2>XS
<a name="XS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>xsubpp</i>
compiles <small>XS</small> code into C. See
&quot;xsubpp&quot; in perlutil. <br>
&quot;aMY_CXT&quot;</p>

<p style="margin-left:17%;">Described in perlxs.</p>

<p style="margin-left:11%;">&quot;aMY_CXT_&quot;</p>

<p style="margin-left:17%;">Described in perlxs.</p>

<p style="margin-left:11%;">&quot;_aMY_CXT&quot;</p>

<p style="margin-left:17%;">Described in perlxs.</p>

<p style="margin-left:11%;">&quot;ax&quot;</p>

<p style="margin-left:17%;">Variable which is setup by
&quot;xsubpp&quot; to indicate the stack base offset, used
by the &quot;ST&quot;, &quot;XSprePUSH&quot; and
&quot;XSRETURN&quot; macros. The &quot;dMARK&quot; macro
must be called prior to setup the &quot;MARK&quot;
variable.</p>

<p style="margin-left:17%; margin-top: 1em">I32 ax</p>

<p style="margin-left:11%;">&quot;CLASS&quot;</p>

<p style="margin-left:17%;">Variable which is setup by
&quot;xsubpp&quot; to indicate the class name for a C
<small>++</small> XS <big>constructor. This is always a
&quot;char*&quot;. See &quot;THIS&quot;.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>char*
CLASS</big></p>

<p style="margin-left:11%;"><big>&quot;dAX&quot;</big></p>

<p style="margin-left:17%;"><big>Sets up the &quot;ax&quot;
variable. This is usually handled automatically by
&quot;xsubpp&quot; by calling &quot;dXSARGS&quot;.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>dAX;</big></p>


<p style="margin-left:11%;"><big>&quot;dAXMARK&quot;</big></p>

<p style="margin-left:17%;"><big>Sets up the &quot;ax&quot;
variable and stack marker variable &quot;mark&quot;. This is
usually handled automatically by &quot;xsubpp&quot; by
calling &quot;dXSARGS&quot;.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>dAXMARK;</big></p>


<p style="margin-left:11%;"><big>&quot;dITEMS&quot;</big></p>

<p style="margin-left:17%;"><big>Sets up the
&quot;items&quot; variable. This is usually handled
automatically by &quot;xsubpp&quot; by calling
&quot;dXSARGS&quot;.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>dITEMS;</big></p>


<p style="margin-left:11%;"><big>&quot;dMY_CXT&quot;</big></p>

<p style="margin-left:17%;"><big>Described in
perlxs.</big></p>


<p style="margin-left:11%;"><big>&quot;dMY_CXT_SV&quot;</big></p>

<p style="margin-left:17%;"><big>Now a placeholder that
declares nothing</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>dMY_CXT_SV;</big></p>


<p style="margin-left:11%;"><big>&quot;dUNDERBAR&quot;</big></p>

<p style="margin-left:17%;"><big>Sets up any variable
needed by the &quot;UNDERBAR&quot; macro. It used to define
&quot;padoff_du&quot;, but it is currently a noop. However,
it is strongly advised to still use it for ensuring past and
future compatibility.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>dUNDERBAR;</big></p>


<p style="margin-left:11%;"><big>&quot;dXSARGS&quot;</big></p>

<p style="margin-left:17%;"><big>Sets up stack and mark
pointers for an</big> XSUB, <big>calling &quot;dSP&quot; and
&quot;dMARK&quot;. Sets up the &quot;ax&quot; and
&quot;items&quot; variables by calling &quot;dAX&quot; and
&quot;dITEMS&quot;. This is usually handled automatically by
&quot;xsubpp&quot;.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>dXSARGS;</big></p>


<p style="margin-left:11%;"><big>&quot;dXSI32&quot;</big></p>

<p style="margin-left:17%;"><big>Sets up the &quot;ix&quot;
variable for an</big> XSUB <big>which has aliases. This is
usually handled automatically by
&quot;xsubpp&quot;.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>dXSI32;</big></p>


<p style="margin-left:11%;"><big>&quot;items&quot;</big></p>

<p style="margin-left:17%;"><big>Variable which is setup by
&quot;xsubpp&quot; to indicate the number of items on the
stack. See &quot;Variable-length Parameter Lists&quot; in
perlxs.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>I32
items</big></p>

<p style="margin-left:11%;"><big>&quot;ix&quot;</big></p>

<p style="margin-left:17%;"><big>Variable which is setup by
&quot;xsubpp&quot; to indicate which of an</big> XSUB
<big>&rsquo;s aliases was used to invoke it. See
&quot;The</big> ALIAS: <big>Keyword&quot; in
perlxs.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>I32
ix</big></p>


<p style="margin-left:11%;"><big>&quot;MY_CXT&quot;</big></p>

<p style="margin-left:17%;"><big>Described in
perlxs.</big></p>


<p style="margin-left:11%;"><big>&quot;MY_CXT_CLONE&quot;</big></p>

<p style="margin-left:17%;"><big>Described in
perlxs.</big></p>


<p style="margin-left:11%;"><big>&quot;MY_CXT_INIT&quot;</big></p>

<p style="margin-left:17%;"><big>Described in
perlxs.</big></p>


<p style="margin-left:11%;"><big>&quot;pMY_CXT&quot;</big></p>

<p style="margin-left:17%;"><big>Described in
perlxs.</big></p>


<p style="margin-left:11%;"><big>&quot;pMY_CXT_&quot;</big></p>

<p style="margin-left:17%;"><big>Described in
perlxs.</big></p>


<p style="margin-left:11%;"><big>&quot;_pMY_CXT&quot;</big></p>

<p style="margin-left:17%;"><big>Described in
perlxs.</big></p>


<p style="margin-left:11%;"><big>&quot;RETVAL&quot;</big></p>

<p style="margin-left:17%;"><big>Variable which is setup by
&quot;xsubpp&quot; to hold the return value for an</big>
XSUB. <big>This is always the proper type for the</big>
XSUB. <big>See &quot;The</big> RETVAL <big>Variable&quot; in
perlxs.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>type
RETVAL</big></p>

<p style="margin-left:11%;"><big>&quot;ST&quot;</big></p>

<p style="margin-left:17%;"><big>Used to access elements on
the</big> XSUB <big>&rsquo;s stack.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>SV* ST(int
ix)</big></p>


<p style="margin-left:11%;"><big>&quot;START_MY_CXT&quot;</big></p>

<p style="margin-left:17%;"><big>Described in
perlxs.</big></p>


<p style="margin-left:11%;"><big>&quot;THIS&quot;</big></p>

<p style="margin-left:17%;"><big>Variable which is setup by
&quot;xsubpp&quot; to designate the object in a C</big> ++
<big>XSUB. <big>This is always the proper type for the
C</big> ++ <big>object. See &quot;CLASS&quot; and
&quot;Using</big> XS <big>With C</big> ++ <big>&quot; in
perlxs.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>type
THIS</big></big></p>


<p style="margin-left:11%;"><big><big>&quot;UNDERBAR&quot;</big></big></p>

<p style="margin-left:17%;"><big><big>The SV* corresponding
to the $_ variable. Works even if there is a lexical $_ in
scope.</big></big></p>


<p style="margin-left:11%;"><big><big>&quot;XS&quot;</big></big></p>

<p style="margin-left:17%;"><big><big>Macro to declare
an</big> XSUB <big>and its C parameter list. This is handled
by &quot;xsubpp&quot;. It is the same as using the more
explicit &quot;XS_EXTERNAL&quot; macro; the latter is
preferred.</big></big></p>


<p style="margin-left:11%;"><big><big>&quot;XS_EXTERNAL&quot;</big></big></p>

<p style="margin-left:17%;"><big><big>Macro to declare
an</big> XSUB <big>and its C parameter list explicitly
exporting the symbols.</big></big></p>


<p style="margin-left:11%;"><big><big>&quot;XS_INTERNAL&quot;</big></big></p>

<p style="margin-left:17%;"><big><big>Macro to declare
an</big> XSUB <big>and its C parameter list without
exporting the symbols. This is handled by &quot;xsubpp&quot;
and generally preferable over exporting the</big> XSUB
<big>symbols unnecessarily.</big></big></p>


<p style="margin-left:11%;"><big><big>&quot;XSPROTO&quot;</big></big></p>

<p style="margin-left:17%;"><big><big>Macro used by
&quot;XS_INTERNAL&quot; and &quot;XS_EXTERNAL&quot; to
declare a function prototype. You probably shouldn&rsquo;t
be using this directly yourself.</big></big></p>

<h2>Undocumented elements
<a name="Undocumented elements"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big><big>The
following functions have been flagged as part of the
public</big> API, <big>but are currently undocumented. Use
them at your own risk, as the interfaces are subject to
change. Functions that are not listed in this document are
not intended for public use, and should</big> NOT <big>be
used under any circumstances.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>If
you feel you need to use one of these functions, first send
email to perl5&minus;porters@perl.org
&lt;mailto:perl5-porters@perl.org&gt;. It may be that there
is a good reason for the function not being documented, and
it should be removed from this list; or it may just be that
no one has gotten around to documenting it. In the latter
case, you will be asked to submit a patch to document the
function. Once your patch is accepted, it will indicate that
the interface is stable (unless it is explicitly marked
otherwise) and usable by you.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>clone_params_del
gv_name_set newANONSUB save_helem <br>
clone_params_new hv_free_ent newAVREF save_helem_flags <br>
do_close hv_ksplit newCVREF save_pushi32ptr <br>
do_open hv_name_set newGVREF save_pushptr <br>
do_openn my_failure_exit newHVREF save_pushptrptr <br>
gv_autoload_pv newANONATTRSUB newSVREF start_subparse <br>
gv_autoload_pvn newANONHASH save_aelem sv_dup <br>
gv_autoload_sv newANONLIST save_aelem_flags
sv_dup_inc</big></big></p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big>Until
May 1997, this document was maintained by Jeff Okamoto
&lt;okamoto@corp.hp.com&gt;. It is now maintained as part of
Perl itself.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>With
lots of help and suggestions from Dean Roehrich, Malcolm
Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul
Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider
Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy
Sarathy.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big>API
<big>Listing originally by Dean Roehrich
&lt;roehrich@cray.com&gt;.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Updated
to be autogenerated from comments in the source by Benjamin
Stuhl.</big></big></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><i>config.h</i>,
perlapio, perlcall, perlclib, perlembed, perlfilter,
perlguts, perlhacktips, perlintern, perlinterp, perliol,
perlmroapi, perlreapi, perlreguts, perlxs</big></big></p>
<hr>
</body>
</html>
