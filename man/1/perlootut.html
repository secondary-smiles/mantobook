<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLOOTUT</title>

</head>
<body>
<h1>perlootut</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlootut
&minus; Object&minus;Oriented Programming in Perl
Tutorial</p>

<h2>DATE
<a name="DATE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
was created in February, 2011, and the last major revision
was in February, 2013.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
reading this in the future then it&rsquo;s possible that the
state of the art has changed. We recommend you start by
reading the perlootut document in the latest stable release
of Perl, rather than this version.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
provides an introduction to object-oriented programming in
Perl. It begins with a brief overview of the concepts behind
object oriented design. Then it introduces several different
<small>OO</small> systems from <small>CPAN</small>
&lt;https://www.cpan.org&gt; which build on top of what Perl
provides.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
Perl&rsquo;s built-in <small>OO</small> system is very
minimal, leaving you to do most of the work. This minimalism
made a lot of sense in 1994, but in the years since Perl 5.0
we&rsquo;ve seen a number of common patterns emerge in Perl
<small>OO.</small> Fortunately, Perl&rsquo;s flexibility has
allowed a rich ecosystem of Perl <small>OO</small> systems
to flourish.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
know how Perl <small>OO</small> works under the hood, the
perlobj document explains the nitty gritty details.</p>

<p style="margin-left:11%; margin-top: 1em">This document
assumes that you already understand the basics of Perl
syntax, variable types, operators, and subroutine calls. If
you don&rsquo;t understand these concepts yet, please read
perlintro first. You should also read the perlsyn, perlop,
and perlsub documents.</p>

<h2>OBJECT-ORIENTED FUNDAMENTALS
<a name="OBJECT-ORIENTED FUNDAMENTALS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Most object
systems share a number of common concepts. You&rsquo;ve
probably heard terms like &quot;class&quot;, &quot;object,
&quot;method&quot;, and &quot;attribute&quot; before.
Understanding the concepts will make it much easier to read
and write object-oriented code. If you&rsquo;re already
familiar with these terms, you should still skim this
section, since it explains each concept in terms of
Perl&rsquo;s <small>OO</small> implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Perl&rsquo;s
<small>OO</small> system is class-based. Class-based
<small>OO</small> is fairly common. It&rsquo;s used by Java,
C <small>++</small> , C#, Python, Ruby, and many other
languages. There are other object orientation paradigms as
well. JavaScript is the most popular language to use another
paradigm. JavaScript&rsquo;s <small>OO</small> system is
prototype-based.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Object</b>
<br>
An <b>object</b> is a data structure that bundles together
data and subroutines which operate on that data. An
object&rsquo;s data is called <b>attributes</b>, and its
subroutines are called <b>methods</b>. An object can be
thought of as a noun (a person, a web service, a
computer).</p>

<p style="margin-left:11%; margin-top: 1em">An object
represents a single discrete thing. For example, an object
might represent a file. The attributes for a file object
might include its path, content, and last modification time.
If we created an object to represent <i>/etc/hostname</i> on
a machine named &quot;foo.example.com&quot;, that
object&rsquo;s path would be &quot;/etc/hostname&quot;, its
content would be &quot;foo\n&quot;, and it&rsquo;s last
modification time would be 1304974868 seconds since the
beginning of the epoch.</p>

<p style="margin-left:11%; margin-top: 1em">The methods
associated with a file might include &quot;rename()&quot;
and &quot;write()&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">In Perl most
objects are hashes, but the <small>OO</small> systems we
recommend keep you from having to worry about this. In
practice, it&rsquo;s best to consider an object&rsquo;s
internal data structure opaque.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Class</b>
<br>
A <b>class</b> defines the behavior of a category of
objects. A class is a name for a category (like
&quot;File&quot;), and a class also defines the behavior of
objects in that category.</p>

<p style="margin-left:11%; margin-top: 1em">All objects
belong to a specific class. For example, our
<i>/etc/hostname</i> object belongs to the &quot;File&quot;
class. When we want to create a specific object, we start
with its class, and <b>construct</b> or <b>instantiate</b>
an object. A specific object is often referred to as an
<b>instance</b> of a class.</p>

<p style="margin-left:11%; margin-top: 1em">In Perl, any
package can be a class. The difference between a package
which is a class and one which isn&rsquo;t is based on how
the package is used. Here&rsquo;s our &quot;class
declaration&quot; for the &quot;File&quot; class:</p>

<p style="margin-left:11%; margin-top: 1em">package
File;</p>

<p style="margin-left:11%; margin-top: 1em">In Perl, there
is no special keyword for constructing an object. However,
most <small>OO</small> modules on <small>CPAN</small> use a
method named &quot;new()&quot; to construct a new
object:</p>

<p style="margin-left:11%; margin-top: 1em">my $hostname =
File&minus;&gt;new( <br>
path =&gt; '/etc/hostname', <br>
content =&gt; &quot;foo\n&quot;, <br>
last_mod_time =&gt; 1304974868, <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">(Don&rsquo;t
worry about that &quot;&minus;&gt;&quot; operator, it will
be explained later.)</p>


<p style="margin-left:11%; margin-top: 1em"><i>Blessing</i></p>

<p style="margin-left:11%; margin-top: 1em">As we said
earlier, most Perl objects are hashes, but an object can be
an instance of any Perl data type (scalar, array, etc.).
Turning a plain data structure into an object is done by
<b>blessing</b> that data structure using Perl&rsquo;s
&quot;bless&quot; function.</p>

<p style="margin-left:11%; margin-top: 1em">While we
strongly suggest you don&rsquo;t build your objects from
scratch, you should know the term <b>bless</b>. A
<b>blessed</b> data structure (aka &quot;a referent&quot;)
is an object. We sometimes say that an object has been
&quot;blessed into a class&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Once a referent
has been blessed, the &quot;blessed&quot; function from the
Scalar::Util core module can tell us its class name. This
subroutine returns an object&rsquo;s class when passed an
object, and false otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">use
Scalar::Util 'blessed'; <br>
print blessed($hash); # undef <br>
print blessed($hostname); # File</p>


<p style="margin-left:11%; margin-top: 1em"><i>Constructor</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<b>constructor</b> creates a new object. In Perl, a
class&rsquo;s constructor is just another method, unlike
some other languages, which provide syntax for constructors.
Most Perl classes use &quot;new&quot; as the name for their
constructor:</p>

<p style="margin-left:11%; margin-top: 1em">my $file =
File&minus;&gt;new(...);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Methods</b>
<br>
You already learned that a <b>method</b> is a subroutine
that operates on an object. You can think of a method as the
things that an object can <i>do</i>. If an object is a noun,
then methods are its verbs (save, print, open).</p>

<p style="margin-left:11%; margin-top: 1em">In Perl,
methods are simply subroutines that live in a class&rsquo;s
package. Methods are always written to receive the object as
their first argument:</p>

<p style="margin-left:11%; margin-top: 1em">sub print_info
{ <br>
my $self = shift; <br>
print &quot;This file is at &quot;, $self&minus;&gt;path,
&quot;\n&quot;; <br>
} <br>
$file&minus;&gt;print_info; <br>
# The file is at /etc/hostname</p>

<p style="margin-left:11%; margin-top: 1em">What makes a
method special is <i>how it&rsquo;s called</i>. The arrow
operator (&quot;&minus;&gt;&quot;) tells Perl that we are
calling a method.</p>

<p style="margin-left:11%; margin-top: 1em">When we make a
method call, Perl arranges for the method&rsquo;s
<b>invocant</b> to be passed as the first argument.
<b>Invocant</b> is a fancy name for the thing on the left
side of the arrow. The invocant can either be a class name
or an object. We can also pass additional arguments to the
method:</p>

<p style="margin-left:11%; margin-top: 1em">sub print_info
{ <br>
my $self = shift; <br>
my $prefix = shift // &quot;This file is at &quot;; <br>
print $prefix, &quot;, &quot;, $self&minus;&gt;path,
&quot;\n&quot;; <br>
} <br>
$file&minus;&gt;print_info(&quot;The file is located at
&quot;); <br>
# The file is located at /etc/hostname</p>


<p style="margin-left:11%; margin-top: 1em"><b>Attributes</b>
<br>
Each class can define its <b>attributes</b>. When we
instantiate an object, we assign values to those attributes.
For example, every &quot;File&quot; object has a path.
Attributes are sometimes called <b>properties</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Perl has no
special syntax for attributes. Under the hood, attributes
are often stored as keys in the object&rsquo;s underlying
hash, but don&rsquo;t worry about this.</p>

<p style="margin-left:11%; margin-top: 1em">We recommend
that you only access attributes via <b>accessor</b> methods.
These are methods that can get or set the value of each
attribute. We saw this earlier in the
&quot;print_info()&quot; example, which calls
&quot;$self&minus;&gt;path&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You might also
see the terms <b>getter</b> and <b>setter</b>. These are two
types of accessors. A getter gets the attribute&rsquo;s
value, while a setter sets it. Another term for a setter is
<b>mutator</b></p>

<p style="margin-left:11%; margin-top: 1em">Attributes are
typically defined as read-only or read-write. Read-only
attributes can only be set when the object is first created,
while read-write attributes can be altered at any time.</p>

<p style="margin-left:11%; margin-top: 1em">The value of an
attribute may itself be another object. For example, instead
of returning its last mod time as a number, the
&quot;File&quot; class could return a DateTime object
representing that value.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s
possible to have a class that does not expose any publicly
settable attributes. Not every class has attributes and
methods.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Polymorphism
<br>
Polymorphism</b> is a fancy way of saying that objects from
two different classes share an <small>API.</small> For
example, we could have &quot;File&quot; and
&quot;WebPage&quot; classes which both have a
&quot;print_content()&quot; method. This method might
produce different output for each class, but they share a
common interface.</p>

<p style="margin-left:11%; margin-top: 1em">While the two
classes may differ in many ways, when it comes to the
&quot;print_content()&quot; method, they are the same. This
means that we can try to call the
&quot;print_content()&quot; method on an object of either
class, and <b>we don&rsquo;t have to know what class the
object belongs to!</b></p>

<p style="margin-left:11%; margin-top: 1em">Polymorphism is
one of the key concepts of object-oriented design.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Inheritance
<br>
Inheritance</b> lets you create a specialized version of an
existing class. Inheritance lets the new class reuse the
methods and attributes of another class.</p>

<p style="margin-left:11%; margin-top: 1em">For example, we
could create an &quot;File::MP3&quot; class which
<b>inherits</b> from &quot;File&quot;. An
&quot;File::MP3&quot; <b>is-a</b> <i>more specific</i> type
of &quot;File&quot;. All mp3 files are files, but not all
files are mp3 files.</p>

<p style="margin-left:11%; margin-top: 1em">We often refer
to inheritance relationships as <b>parent-child</b> or
&quot;superclass&quot;/&quot;subclass&quot; relationships.
Sometimes we say that the child has an <b>is-a</b>
relationship with its parent class.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;File&quot;
is a <b>superclass</b> of &quot;File::MP3&quot;, and
&quot;File::MP3&quot; is a <b>subclass</b> of
&quot;File&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">package
File::MP3; <br>
use parent 'File';</p>

<p style="margin-left:11%; margin-top: 1em">The parent
module is one of several ways that Perl lets you define
inheritance relationships.</p>

<p style="margin-left:11%; margin-top: 1em">Perl allows
multiple inheritance, which means that a class can inherit
from multiple parents. While this is possible, we strongly
recommend against it. Generally, you can use <b>roles</b> to
do everything you can do with multiple inheritance, but in a
cleaner way.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
there&rsquo;s nothing wrong with defining multiple
subclasses of a given class. This is both common and safe.
For example, we might define
&quot;File::MP3::FixedBitrate&quot; and
&quot;File::MP3::VariableBitrate&quot; classes to
distinguish between different types of mp3 file.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Overriding
methods and method resolution</i></p>

<p style="margin-left:11%; margin-top: 1em">Inheritance
allows two classes to share code. By default, every method
in the parent class is also available in the child. The
child can explicitly <b>override</b> a parent&rsquo;s method
to provide its own implementation. For example, if we have
an &quot;File::MP3&quot; object, it has the
&quot;print_info()&quot; method from &quot;File&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">my $cage =
File::MP3&minus;&gt;new( <br>
path =&gt;
'mp3s/My&minus;Body&minus;Is&minus;a&minus;Cage.mp3', <br>
content =&gt; $mp3_data, <br>
last_mod_time =&gt; 1304974868, <br>
title =&gt; 'My Body Is a Cage', <br>
); <br>
$cage&minus;&gt;print_info; <br>
# The file is at
mp3s/My&minus;Body&minus;Is&minus;a&minus;Cage.mp3</p>

<p style="margin-left:11%; margin-top: 1em">If we wanted to
include the mp3&rsquo;s title in the greeting, we could
override the method:</p>

<p style="margin-left:11%; margin-top: 1em">package
File::MP3; <br>
use parent 'File'; <br>
sub print_info { <br>
my $self = shift; <br>
print &quot;This file is at &quot;, $self&minus;&gt;path,
&quot;\n&quot;; <br>
print &quot;Its title is &quot;, $self&minus;&gt;title,
&quot;\n&quot;; <br>
} <br>
$cage&minus;&gt;print_info; <br>
# The file is at
mp3s/My&minus;Body&minus;Is&minus;a&minus;Cage.mp3 <br>
# Its title is My Body Is a Cage</p>

<p style="margin-left:11%; margin-top: 1em">The process of
determining what method should be used is called <b>method
resolution</b>. What Perl does is look at the object&rsquo;s
class first (&quot;File::MP3&quot; in this case). If that
class defines the method, then that class&rsquo;s version of
the method is called. If not, Perl looks at each parent
class in turn. For &quot;File::MP3&quot;, its only parent is
&quot;File&quot;. If &quot;File::MP3&quot; does not define
the method, but &quot;File&quot; does, then Perl calls the
method in &quot;File&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If
&quot;File&quot; inherited from &quot;DataSource&quot;,
which inherited from &quot;Thing&quot;, then Perl would keep
looking &quot;up the chain&quot; if necessary.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to explicitly call a parent method from a child:</p>

<p style="margin-left:11%; margin-top: 1em">package
File::MP3; <br>
use parent 'File'; <br>
sub print_info { <br>
my $self = shift; <br>
$self&minus;&gt;SUPER::print_info(); <br>
print &quot;Its title is &quot;, $self&minus;&gt;title,
&quot;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;SUPER::&quot; bit tells Perl to look for the
&quot;print_info()&quot; in the &quot;File::MP3&quot;
class&rsquo;s inheritance chain. When it finds the parent
class that implements this method, the method is called.</p>

<p style="margin-left:11%; margin-top: 1em">We mentioned
multiple inheritance earlier. The main problem with multiple
inheritance is that it greatly complicates method
resolution. See perlobj for more details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Encapsulation
<br>
Encapsulation</b> is the idea that an object is opaque. When
another developer uses your class, they don&rsquo;t need to
know <i>how</i> it is implemented, they just need to know
<i>what</i> it does.</p>

<p style="margin-left:11%; margin-top: 1em">Encapsulation
is important for several reasons. First, it allows you to
separate the public <small>API</small> from the private
implementation. This means you can change that
implementation without breaking the <small>API.</small></p>

<p style="margin-left:11%; margin-top: 1em">Second, when
classes are well encapsulated, they become easier to
subclass. Ideally, a subclass uses the same APIs to access
object data that its parent class uses. In reality,
subclassing sometimes involves violating encapsulation, but
a good <small>API</small> can minimize the need to do
this.</p>

<p style="margin-left:11%; margin-top: 1em">We mentioned
earlier that most Perl objects are implemented as hashes
under the hood. The principle of encapsulation tells us that
we should not rely on this. Instead, we should use accessor
methods to access the data in that hash. The object systems
that we recommend below all automate the generation of
accessor methods. If you use one of them, you should never
have to access the object as a hash directly.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Composition</b>
<br>
In object-oriented code, we often find that one object
references another object. This is called
<b>composition</b>, or a <b>has-a</b> relationship.</p>

<p style="margin-left:11%; margin-top: 1em">Earlier, we
mentioned that the &quot;File&quot; class&rsquo;s
&quot;last_mod_time&quot; accessor could return a DateTime
object. This is a perfect example of composition. We could
go even further, and make the &quot;path&quot; and
&quot;content&quot; accessors return objects as well. The
&quot;File&quot; class would then be <b>composed</b> of
several other objects.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Roles <br>
Roles</b> are something that a class <i>does</i>, rather
than something that it <i>is</i>. Roles are relatively new
to Perl, but have become rather popular. Roles are
<b>applied</b> to classes. Sometimes we say that classes
<b>consume</b> roles.</p>

<p style="margin-left:11%; margin-top: 1em">Roles are an
alternative to inheritance for providing polymorphism.
Let&rsquo;s assume we have two classes, &quot;Radio&quot;
and &quot;Computer&quot;. Both of these things have on/off
switches. We want to model that in our class
definitions.</p>

<p style="margin-left:11%; margin-top: 1em">We could have
both classes inherit from a common parent, like
&quot;Machine&quot;, but not all machines have on/off
switches. We could create a parent class called
&quot;HasOnOffSwitch&quot;, but that is very artificial.
Radios and computers are not specializations of this parent.
This parent is really a rather ridiculous creation.</p>

<p style="margin-left:11%; margin-top: 1em">This is where
roles come in. It makes a lot of sense to create a
&quot;HasOnOffSwitch&quot; role and apply it to both
classes. This role would define a known <small>API</small>
like providing &quot;turn_on()&quot; and
&quot;turn_off()&quot; methods.</p>

<p style="margin-left:11%; margin-top: 1em">Perl does not
have any built-in way to express roles. In the past, people
just bit the bullet and used multiple inheritance. Nowadays,
there are several good choices on <small>CPAN</small> for
using roles.</p>

<p style="margin-left:11%; margin-top: 1em"><b>When to Use
<small>OO</small></b> <br>
Object Orientation is not the best solution to every
problem. In <i>Perl Best Practices</i> (copyright 2004,
Published by O&rsquo;Reilly Media, Inc.), Damian Conway
provides a list of criteria to use when deciding if
<small>OO</small> is the right fit for your problem:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The system being designed is large, or is likely to
become large.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The data can be aggregated into obvious structures,
especially if there&rsquo;s a large amount of data in each
aggregate.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The various types of data aggregate form a natural
hierarchy that facilitates the use of inheritance and
polymorphism.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You have a piece of data on which many different
operations are applied.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You need to perform the same general operations on
related types of data, but with slight variations depending
on the specific type of data the operations are applied
to.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>It&rsquo;s likely you&rsquo;ll have to add new data
types later.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The typical interactions between pieces of data are best
represented by operators.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The implementation of individual components of the
system is likely to change over time.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The system design is already object-oriented.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Large numbers of other programmers will be using your
code modules.</p></td></tr>
</table>

<h2>PERL OO SYSTEMS
<a name="PERL OO SYSTEMS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As we mentioned
before, Perl&rsquo;s built-in <small>OO</small> system is
very minimal, but also quite flexible. Over the years, many
people have developed systems which build on top of
Perl&rsquo;s built-in system to provide more features and
convenience.</p>

<p style="margin-left:11%; margin-top: 1em">We strongly
recommend that you use one of these systems. Even the most
minimal of them eliminates a lot of repetitive boilerplate.
There&rsquo;s really no good reason to write your classes
from scratch in Perl.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
interested in the guts underlying these systems, check out
perlobj.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Moose</b>
<br>
Moose bills itself as a &quot;postmodern object system for
Perl 5&quot;. Don&rsquo;t be scared, the
&quot;postmodern&quot; label is a callback to Larry&rsquo;s
description of Perl as &quot;the first postmodern computer
language&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Moose&quot;
provides a complete, modern <small>OO</small> system. Its
biggest influence is the Common Lisp Object System, but it
also borrows ideas from Smalltalk and several other
languages. &quot;Moose&quot; was created by Stevan Little,
and draws heavily from his work on the Raku
<small>OO</small> design.</p>

<p style="margin-left:11%; margin-top: 1em">Here is our
&quot;File&quot; class using &quot;Moose&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">package File;
<br>
use Moose; <br>
has path =&gt; ( is =&gt; 'ro' ); <br>
has content =&gt; ( is =&gt; 'ro' ); <br>
has last_mod_time =&gt; ( is =&gt; 'ro' ); <br>
sub print_info { <br>
my $self = shift; <br>
print &quot;This file is at &quot;, $self&minus;&gt;path,
&quot;\n&quot;; <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Moose&quot;
provides a number of features:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p style="margin-top: 1em">Declarative sugar</p></td>
<td width="57%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;Moose&quot;
provides a layer of declarative &quot;sugar&quot; for
defining classes. That sugar is just a set of exported
functions that make declaring how your class works simpler
and more palatable. This lets you describe <i>what</i> your
class is, rather than having to tell Perl <i>how</i> to
implement your class.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;has()&quot; subroutine declares an attribute, and
&quot;Moose&quot; automatically creates accessors for these
attributes. It also takes care of creating a
&quot;new()&quot; method for you. This constructor knows
about the attributes you declared, so you can set them when
creating a new &quot;File&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p style="margin-top: 1em">Roles built-in</p></td>
<td width="62%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;Moose&quot;
lets you define roles the same way you define classes:</p>

<p style="margin-left:17%; margin-top: 1em">package
HasOnOffSwitch; <br>
use Moose::Role; <br>
has is_on =&gt; ( <br>
is =&gt; 'rw', <br>
isa =&gt; 'Bool', <br>
); <br>
sub turn_on { <br>
my $self = shift; <br>
$self&minus;&gt;is_on(1); <br>
} <br>
sub turn_off { <br>
my $self = shift; <br>
$self&minus;&gt;is_on(0); <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">A miniature type system</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In the example
above, you can see that we passed &quot;isa =&gt;
'Bool'&quot; to &quot;has()&quot; when creating our
&quot;is_on&quot; attribute. This tells &quot;Moose&quot;
that this attribute must be a boolean value. If we try to
set it to an invalid value, our code will throw an
error.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="54%">


<p style="margin-top: 1em">Full introspection and
manipulation</p> </td>
<td width="29%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Perl&rsquo;s
built-in introspection features are fairly minimal.
&quot;Moose&quot; builds on top of them and creates a full
introspection layer for your classes. This lets you ask
questions like &quot;what methods does the File class
implement?&quot; It also lets you modify your classes
programmatically.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em">Self-hosted and extensible</p></td>
<td width="43%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;Moose&quot;
describes itself using its own introspection
<small>API.</small> Besides being a cool trick, this means
that you can extend &quot;Moose&quot; using
&quot;Moose&quot; itself.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p style="margin-top: 1em">Rich ecosystem</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">There is a rich
ecosystem of &quot;Moose&quot; extensions on
<small>CPAN</small> under the MooseX
&lt;https://metacpan.org/search?q=MooseX&gt; namespace. In
addition, many modules on <small>CPAN</small> already use
&quot;Moose&quot;, providing you with lots of examples to
learn from.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p style="margin-top: 1em">Many more features</p></td>
<td width="55%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;Moose&quot;
is a very powerful tool, and we can&rsquo;t cover all of its
features here. We encourage you to learn more by reading the
&quot;Moose&quot; documentation, starting with Moose::Manual
&lt;https://metacpan.org/pod/Moose::Manual&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Of course,
&quot;Moose&quot; isn&rsquo;t perfect.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Moose&quot;
can make your code slower to load. &quot;Moose&quot; itself
is not small, and it does a <i>lot</i> of code generation
when you define your class. This code generation means that
your runtime code is as fast as it can be, but you pay for
this when your modules are first loaded.</p>

<p style="margin-left:11%; margin-top: 1em">This load time
hit can be a problem when startup speed is important, such
as with a command-line script or a &quot;plain vanilla&quot;
<small>CGI</small> script that must be loaded each time it
is executed.</p>

<p style="margin-left:11%; margin-top: 1em">Before you
panic, know that many people do use &quot;Moose&quot; for
command-line tools and other startup-sensitive code. We
encourage you to try &quot;Moose&quot; out first before
worrying about startup speed.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Moose&quot;
also has several dependencies on other modules. Most of
these are small stand-alone modules, a number of which have
been spun off from &quot;Moose&quot;. &quot;Moose&quot;
itself, and some of its dependencies, require a compiler. If
you need to install your software on a system without a
compiler, or if having <i>any</i> dependencies is a problem,
then &quot;Moose&quot; may not be right for you.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Moo</i></p>

<p style="margin-left:11%; margin-top: 1em">If you try
&quot;Moose&quot; and find that one of these issues is
preventing you from using &quot;Moose&quot;, we encourage
you to consider Moo next. &quot;Moo&quot; implements a
subset of &quot;Moose&quot;&rsquo;s functionality in a
simpler package. For most features that it does implement,
the end-user <small>API</small> is <i>identical</i> to
&quot;Moose&quot;, meaning you can switch from
&quot;Moo&quot; to &quot;Moose&quot; quite easily.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Moo&quot;
does not implement most of &quot;Moose&quot;&rsquo;s
introspection <small>API,</small> so it&rsquo;s often faster
when loading your modules. Additionally, none of its
dependencies require <small>XS,</small> so it can be
installed on machines without a compiler.</p>

<p style="margin-left:11%; margin-top: 1em">One of
&quot;Moo&quot;&rsquo;s most compelling features is its
interoperability with &quot;Moose&quot;. When someone tries
to use &quot;Moose&quot;&rsquo;s introspection
<small>API</small> on a &quot;Moo&quot; class or role, it is
transparently inflated into a &quot;Moose&quot; class or
role. This makes it easier to incorporate
&quot;Moo&quot;&minus;using code into a &quot;Moose&quot;
code base and vice versa.</p>

<p style="margin-left:11%; margin-top: 1em">For example, a
&quot;Moose&quot; class can subclass a &quot;Moo&quot; class
using &quot;extends&quot; or consume a &quot;Moo&quot; role
using &quot;with&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;Moose&quot; authors hope that one day &quot;Moo&quot;
can be made obsolete by improving &quot;Moose&quot; enough,
but for now it provides a worthwhile alternative to
&quot;Moose&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Class::Accessor</b>
<br>
Class::Accessor is the polar opposite of &quot;Moose&quot;.
It provides very few features, nor is it self-hosting.</p>

<p style="margin-left:11%; margin-top: 1em">It is, however,
very simple, pure Perl, and it has no non-core dependencies.
It also provides a &quot;Moose-like&quot; <small>API</small>
on demand for the features it supports.</p>

<p style="margin-left:11%; margin-top: 1em">Even though it
doesn&rsquo;t do much, it is still preferable to writing
your own classes from scratch.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
our &quot;File&quot; class with
&quot;Class::Accessor&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">package File;
<br>
use Class::Accessor 'antlers'; <br>
has path =&gt; ( is =&gt; 'ro' ); <br>
has content =&gt; ( is =&gt; 'ro' ); <br>
has last_mod_time =&gt; ( is =&gt; 'ro' ); <br>
sub print_info { <br>
my $self = shift; <br>
print &quot;This file is at &quot;, $self&minus;&gt;path,
&quot;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;antlers&quot; import flag tells
&quot;Class::Accessor&quot; that you want to define your
attributes using &quot;Moose&quot;&minus;like syntax. The
only parameter that you can pass to &quot;has&quot; is
&quot;is&quot;. We recommend that you use this Moose-like
syntax if you choose &quot;Class::Accessor&quot; since it
means you will have a smoother upgrade path if you later
decide to move to &quot;Moose&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Like
&quot;Moose&quot;, &quot;Class::Accessor&quot; generates
accessor methods and a constructor for your class.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Class::Tiny</b>
<br>
Finally, we have Class::Tiny. This module truly lives up to
its name. It has an incredibly minimal <small>API</small>
and absolutely no dependencies on any recent Perl. Still, we
think it&rsquo;s a lot easier to use than writing your own
<small>OO</small> code from scratch.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
our &quot;File&quot; class once more:</p>

<p style="margin-left:11%; margin-top: 1em">package File;
<br>
use Class::Tiny qw( path content last_mod_time ); <br>
sub print_info { <br>
my $self = shift; <br>
print &quot;This file is at &quot;, $self&minus;&gt;path,
&quot;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
it!</p>

<p style="margin-left:11%; margin-top: 1em">With
&quot;Class::Tiny&quot;, all accessors are read-write. It
generates a constructor for you, as well as the accessors
you define.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use Class::Tiny::Antlers for &quot;Moose&quot;&minus;like
syntax.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Role::Tiny</b>
<br>
As we mentioned before, roles provide an alternative to
inheritance, but Perl does not have any built-in role
support. If you choose to use Moose, it comes with a
full-fledged role implementation. However, if you use one of
our other recommended <small>OO</small> modules, you can
still use roles with Role::Tiny</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Role::Tiny&quot;
provides some of the same features as Moose&rsquo;s role
system, but in a much smaller package. Most notably, it
doesn&rsquo;t support any sort of attribute declaration, so
you have to do that by hand. Still, it&rsquo;s useful, and
works well with &quot;Class::Accessor&quot; and
&quot;Class::Tiny&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>OO</small>
System Summary</b> <br>
Here&rsquo;s a brief recap of the options we covered:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em">Moose</p></td>
<td width="75%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;Moose&quot;
is the maximal option. It has a lot of features, a big
ecosystem, and a thriving user base. We also covered Moo
briefly. &quot;Moo&quot; is &quot;Moose&quot; lite, and a
reasonable alternative when Moose doesn&rsquo;t work for
your application.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p style="margin-top: 1em">Class::Accessor</p></td>
<td width="60%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;Class::Accessor&quot;
does a lot less than &quot;Moose&quot;, and is a nice
alternative if you find &quot;Moose&quot; overwhelming.
It&rsquo;s been around a long time and is well
battle-tested. It also has a minimal &quot;Moose&quot;
compatibility mode which makes moving from
&quot;Class::Accessor&quot; to &quot;Moose&quot; easy.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">


<p style="margin-top: 1em">Class::Tiny</p></td>
<td width="66%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;Class::Tiny&quot;
is the absolute minimal option. It has no dependencies, and
almost no syntax to learn. It&rsquo;s a good option for a
super minimal environment and for throwing something
together quickly without having to worry about details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em">Role::Tiny</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Use
&quot;Role::Tiny&quot; with &quot;Class::Accessor&quot; or
&quot;Class::Tiny&quot; if you find yourself considering
multiple inheritance. If you go with &quot;Moose&quot;, it
comes with its own role implementation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Other
<small>OO</small> Systems</b> <br>
There are literally dozens of other OO-related modules on
<small>CPAN</small> besides those covered here, and
you&rsquo;re likely to run across one or more of them if you
work with other people&rsquo;s code.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
plenty of code in the wild does all of its <small>OO</small>
&quot;by hand&quot;, using just the Perl built-in
<small>OO</small> features. If you need to maintain such
code, you should read perlobj to understand exactly how
Perl&rsquo;s built-in <small>OO</small> works.</p>

<h2>CONCLUSION
<a name="CONCLUSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As we said
before, Perl&rsquo;s minimal <small>OO</small> system has
led to a profusion of <small>OO</small> systems on
<small>CPAN.</small> While you can still drop down to the
bare metal and write your classes by hand, there&rsquo;s
really no reason to do that with modern Perl.</p>

<p style="margin-left:11%; margin-top: 1em">For small
systems, Class::Tiny and Class::Accessor both provide
minimal object systems that take care of basic boilerplate
for you.</p>

<p style="margin-left:11%; margin-top: 1em">For bigger
projects, Moose provides a rich set of features that will
let you focus on implementing your business logic. Moo
provides a nice alternative to Moose when you want a lot of
features but need faster compile time or to avoid
<small>XS.</small></p>

<p style="margin-left:11%; margin-top: 1em">We encourage
you to play with and evaluate Moose, Moo, Class::Accessor,
and Class::Tiny to see which <small>OO</small> system is
right for you.</p>
<hr>
</body>
</html>
