<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLTHRTUT</title>

</head>
<body>
<h1>perlthrtut</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlthrtut
&minus; Tutorial on threads in Perl</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This tutorial
describes the use of Perl interpreter threads (sometimes
referred to as <i>ithreads</i>). In this model, each thread
runs in its own Perl interpreter, and any data sharing
between threads must be explicit. The user-level interface
for <i>ithreads</i> uses the threads class.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
: There was another older Perl threading flavor called the
5.005 model that used the threads class. This old model was
known to have problems, is deprecated, and was removed for
release 5.10. You are strongly encouraged to migrate any
existing 5.005 threads code to the new model as soon as
possible.</p>

<p style="margin-left:11%; margin-top: 1em">You can see
which (or neither) threading flavour you have by running
&quot;perl &minus;V&quot; and looking at the
&quot;Platform&quot; section. If you have
&quot;useithreads=define&quot; you have ithreads, if you
have &quot;use5005threads=define&quot; you have 5.005
threads. If you have neither, you don&rsquo;t have any
thread support built in. If you have both, you are in
trouble.</p>

<p style="margin-left:11%; margin-top: 1em">The threads and
threads::shared modules are included in the core Perl
distribution. Additionally, they are maintained as a
separate modules on <small>CPAN,</small> so you can check
there for any updates.</p>

<h2>What Is A Thread Anyway?
<a name="What Is A Thread Anyway?"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A thread is a
flow of control through a program with a single execution
point.</p>

<p style="margin-left:11%; margin-top: 1em">Sounds an awful
lot like a process, doesn&rsquo;t it? Well, it should.
Threads are one of the pieces of a process. Every process
has at least one thread and, up until now, every process
running Perl had only one thread. With 5.8, though, you can
create extra threads. We&rsquo;re going to show you how,
when, and why.</p>

<h2>Threaded Program Models
<a name="Threaded Program Models"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are three
basic ways that you can structure a threaded program. Which
model you choose depends on what you need your program to
do. For many non-trivial threaded programs, you&rsquo;ll
need to choose different models for different pieces of your
program.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Boss/Worker</b>
<br>
The boss/worker model usually has one <i>boss</i> thread and
one or more <i>worker</i> threads. The boss thread gathers
or generates tasks that need to be done, then parcels those
tasks out to the appropriate worker thread.</p>

<p style="margin-left:11%; margin-top: 1em">This model is
common in <small>GUI</small> and server programs, where a
main thread waits for some event and then passes that event
to the appropriate worker threads for processing. Once the
event has been passed on, the boss thread goes back to
waiting for another event.</p>

<p style="margin-left:11%; margin-top: 1em">The boss thread
does relatively little work. While tasks aren&rsquo;t
necessarily performed faster than with any other method, it
tends to have the best user-response times.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Work
Crew</b> <br>
In the work crew model, several threads are created that do
essentially the same thing to different pieces of data. It
closely mirrors classical parallel processing and vector
processors, where a large array of processors do the exact
same thing to many pieces of data.</p>

<p style="margin-left:11%; margin-top: 1em">This model is
particularly useful if the system running the program will
distribute multiple threads across different processors. It
can also be useful in ray tracing or rendering engines,
where the individual threads can pass on interim results to
give the user visual feedback.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Pipeline</b>
<br>
The pipeline model divides up a task into a series of steps,
and passes the results of one step on to the thread
processing the next. Each thread does one thing to each
piece of data and passes the results to the next thread in
line.</p>

<p style="margin-left:11%; margin-top: 1em">This model
makes the most sense if you have multiple processors so two
or more threads will be executing in parallel, though it can
often make sense in other contexts as well. It tends to keep
the individual tasks small and simple, as well as allowing
some parts of the pipeline to block (on I/O or system calls,
for example) while other parts keep going. If you&rsquo;re
running different parts of the pipeline on different
processors you may also take advantage of the caches on each
processor.</p>

<p style="margin-left:11%; margin-top: 1em">This model is
also handy for a form of recursive programming where, rather
than having a subroutine call itself, it instead creates
another thread. Prime and Fibonacci generators both map well
to this form of the pipeline model. (A version of a prime
number generator is presented later on.)</p>

<h2>What kind of threads are Perl threads?
<a name="What kind of threads are Perl threads?"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you have
experience with other thread implementations, you might find
that things aren&rsquo;t quite what you expect. It&rsquo;s
very important to remember when dealing with Perl threads
that <i>Perl Threads Are Not X Threads</i> for all values of
X. They aren&rsquo;t <small>POSIX</small> threads, or
DecThreads, or Java&rsquo;s Green threads, or Win32 threads.
There are similarities, and the broad concepts are the same,
but if you start looking for implementation details
you&rsquo;re going to be either disappointed or confused.
Possibly both.</p>

<p style="margin-left:11%; margin-top: 1em">This is not to
say that Perl threads are completely different from
everything that&rsquo;s ever come before. They&rsquo;re not.
Perl&rsquo;s threading model owes a lot to other thread
models, especially <small>POSIX.</small> Just as Perl is not
C, though, Perl threads are not <small>POSIX</small>
threads. So if you find yourself looking for mutexes, or
thread priorities, it&rsquo;s time to step back a bit and
think about what you want to do and how Perl can do it.</p>

<p style="margin-left:11%; margin-top: 1em">However, it is
important to remember that Perl threads cannot magically do
things unless your operating system&rsquo;s threads allow
it. So if your system blocks the entire process on
&quot;sleep()&quot;, Perl usually will, as well.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Perl Threads
Are Different.</b></p>

<h2>Thread-Safe Modules
<a name="Thread-Safe Modules"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The addition of
threads has changed Perl&rsquo;s internals substantially.
There are implications for people who write modules with
<small>XS</small> code or external libraries. However, since
Perl data is not shared among threads by default, Perl
modules stand a high chance of being thread-safe or can be
made thread-safe easily. Modules that are not tagged as
thread-safe should be tested or code reviewed before being
used in production code.</p>

<p style="margin-left:11%; margin-top: 1em">Not all modules
that you might use are thread-safe, and you should always
assume a module is unsafe unless the documentation says
otherwise. This includes modules that are distributed as
part of the core. Threads are a relatively new feature, and
even some of the standard modules aren&rsquo;t
thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">Even if a
module is thread-safe, it doesn&rsquo;t mean that the module
is optimized to work well with threads. A module could
possibly be rewritten to utilize the new features in
threaded Perl to increase performance in a threaded
environment.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
using a module that&rsquo;s not thread-safe for some reason,
you can protect yourself by using it from one, and only one
thread at all. If you need multiple threads to access such a
module, you can use semaphores and lots of programming
discipline to control access to it. Semaphores are covered
in &quot;Basic semaphores&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Thread-Safety of System Libraries&quot;.</p>

<h2>Thread Basics
<a name="Thread Basics"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The threads
module provides the basic functions you need to write
threaded programs. In the following sections, we&rsquo;ll
cover the basics, showing you what you need to do to create
a threaded program. After that, we&rsquo;ll go over some of
the features of the threads module that make threaded
programming easier.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Basic Thread
Support</b> <br>
Thread support is a Perl compile-time option. It&rsquo;s
something that&rsquo;s turned on or off when Perl is built
at your site, rather than when your programs are compiled.
If your Perl wasn&rsquo;t compiled with thread support
enabled, then any attempt to use threads will fail.</p>

<p style="margin-left:11%; margin-top: 1em">Your programs
can use the Config module to check whether threads are
enabled. If your program can&rsquo;t run without them, you
can say something like:</p>

<p style="margin-left:11%; margin-top: 1em">use Config;
<br>
$Config{useithreads} or <br>
die('Recompile Perl with threads to run this program.');</p>

<p style="margin-left:11%; margin-top: 1em">A
possibly-threaded program using a possibly-threaded module
might have code like this:</p>

<p style="margin-left:11%; margin-top: 1em">use Config;
<br>
use MyMod; <br>
BEGIN { <br>
if ($Config{useithreads}) { <br>
# We have threads <br>
require MyMod_threaded; <br>
import MyMod_threaded; <br>
} else { <br>
require MyMod_unthreaded; <br>
import MyMod_unthreaded; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Since code that
runs both with and without threads is usually pretty messy,
it&rsquo;s best to isolate the thread-specific code in its
own module. In our example above, that&rsquo;s what
&quot;MyMod_threaded&quot; is, and it&rsquo;s only imported
if we&rsquo;re running on a threaded Perl.</p>

<p style="margin-left:11%; margin-top: 1em"><b>A Note about
the Examples</b> <br>
In a real situation, care should be taken that all threads
are finished executing before the program exits. That care
has <b>not</b> been taken in these examples in the interest
of simplicity. Running these examples <i>as is</i> will
produce error messages, usually caused by the fact that
there are still threads running when the program exits. You
should not be alarmed by this.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Creating
Threads</b> <br>
The threads module provides the tools you need to create new
threads. Like any other module, you need to tell Perl that
you want to use it; &quot;use threads;&quot; imports all the
pieces you need to create basic threads.</p>

<p style="margin-left:11%; margin-top: 1em">The simplest,
most straightforward way to create a thread is with
&quot;create()&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
my $thr = threads&minus;&gt;create(\&amp;sub1); <br>
sub sub1 { <br>
print(&quot;In the thread\n&quot;); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;create()&quot; method takes a reference to a
subroutine and creates a new thread that starts executing in
the referenced subroutine. Control then passes both to the
subroutine and the caller.</p>

<p style="margin-left:11%; margin-top: 1em">If you need to,
your program can pass parameters to the subroutine as part
of the thread startup. Just include the list of parameters
as part of the &quot;threads&minus;&gt;create()&quot; call,
like this:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
my $Param3 = 'foo'; <br>
my $thr1 = threads&minus;&gt;create(\&amp;sub1, 'Param 1',
'Param 2', $Param3); <br>
my @ParamList = (42, 'Hello', 3.14); <br>
my $thr2 = threads&minus;&gt;create(\&amp;sub1, @ParamList);
<br>
my $thr3 = threads&minus;&gt;create(\&amp;sub1, qw(Param1
Param2 Param3)); <br>
sub sub1 { <br>
my @InboundParameters = @_; <br>
print(&quot;In the thread\n&quot;); <br>
print('Got parameters &gt;',
join('&lt;&gt;',@InboundParameters), &quot;&lt;\n&quot;);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The last
example illustrates another feature of threads. You can
spawn off several threads using the same subroutine. Each
thread executes the same subroutine, but in a separate
thread with a separate environment and potentially separate
arguments.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;new()&quot;
is a synonym for &quot;create()&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Waiting For
A Thread To Exit</b> <br>
Since threads are also subroutines, they can return values.
To wait for a thread to exit and extract any values it might
return, you can use the &quot;join()&quot; method:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
my ($thr) = threads&minus;&gt;create(\&amp;sub1); <br>
my @ReturnData = $thr&minus;&gt;join(); <br>
print('Thread returned ', join(', ', @ReturnData),
&quot;\n&quot;); <br>
sub sub1 { return ('Fifty&minus;six', 'foo', 2); }</p>

<p style="margin-left:11%; margin-top: 1em">In the example
above, the &quot;join()&quot; method returns as soon as the
thread ends. In addition to waiting for a thread to finish
and gathering up any values that the thread might have
returned, &quot;join()&quot; also performs any
<small>OS</small> cleanup necessary for the thread. That
cleanup might be important, especially for long-running
programs that spawn lots of threads. If you don&rsquo;t want
the return values and don&rsquo;t want to wait for the
thread to finish, you should call the &quot;detach()&quot;
method instead, as described next.</p>


<p style="margin-left:11%; margin-top: 1em"><small>NOTE:</small>
In the example above, the thread returns a list, thus
necessitating that the thread creation call be made in list
context (i.e., &quot;my ($thr)&quot;). See
&quot;$thr&minus;&gt;<b>join()</b>&quot; in threads and
&quot; <small>THREAD CONTEXT&quot;</small> in threads for
more details on thread context and return values.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Ignoring A
Thread</b> <br>
&quot;join()&quot; does three things: it waits for a thread
to exit, cleans up after it, and returns any data the thread
may have produced. But what if you&rsquo;re not interested
in the thread&rsquo;s return values, and you don&rsquo;t
really care when the thread finishes? All you want is for
the thread to get cleaned up after when it&rsquo;s done.</p>

<p style="margin-left:11%; margin-top: 1em">In this case,
you use the &quot;detach()&quot; method. Once a thread is
detached, it&rsquo;ll run until it&rsquo;s finished; then
Perl will clean up after it automatically.</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
my $thr = threads&minus;&gt;create(\&amp;sub1); # Spawn the
thread <br>
$thr&minus;&gt;detach(); # Now we officially don't care any
more <br>
sleep(15); # Let thread run for awhile <br>
sub sub1 { <br>
my $count = 0; <br>
while (1) { <br>
$count++; <br>
print(&quot;\$count is $count\n&quot;); <br>
sleep(1); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Once a thread
is detached, it may not be joined, and any return data that
it might have produced (if it was done and waiting for a
join) is lost.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;detach()&quot;
can also be called as a class method to allow a thread to
detach itself:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
my $thr = threads&minus;&gt;create(\&amp;sub1); <br>
sub sub1 { <br>
threads&minus;&gt;detach(); <br>
# Do more work <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Process and
Thread Termination</b> <br>
With threads one must be careful to make sure they all have
a chance to run to completion, assuming that is what you
want.</p>

<p style="margin-left:11%; margin-top: 1em">An action that
terminates a process will terminate <i>all</i> running
threads. <b>die()</b> and <b>exit()</b> have this property,
and perl does an exit when the main thread exits, perhaps
implicitly by falling off the end of your code, even if
that&rsquo;s not what you want.</p>

<p style="margin-left:11%; margin-top: 1em">As an example
of this case, this code prints the message &quot;Perl exited
with active threads: 2 running and unjoined&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
my $thr1 = threads&minus;&gt;new(\&amp;thrsub,
&quot;test1&quot;); <br>
my $thr2 = threads&minus;&gt;new(\&amp;thrsub,
&quot;test2&quot;); <br>
sub thrsub { <br>
my ($message) = @_; <br>
sleep 1; <br>
print &quot;thread $message\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">But when the
following lines are added at the end:</p>


<p style="margin-left:11%; margin-top: 1em">$thr1&minus;&gt;join();
<br>
$thr2&minus;&gt;join();</p>

<p style="margin-left:11%; margin-top: 1em">it prints two
lines of output, a perhaps more useful outcome.</p>

<h2>Threads And Data
<a name="Threads And Data"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Now that
we&rsquo;ve covered the basics of threads, it&rsquo;s time
for our next topic: Data. Threading introduces a couple of
complications to data access that non-threaded programs
never need to worry about.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Shared And
Unshared Data</b> <br>
The biggest difference between Perl <i>ithreads</i> and the
old 5.005 style threading, or for that matter, to most other
threading systems out there, is that by default, no data is
shared. When a new Perl thread is created, all the data
associated with the current thread is copied to the new
thread, and is subsequently private to that new thread! This
is similar in feel to what happens when a Unix process
forks, except that in this case, the data is just copied to
a different part of memory within the same process rather
than a real fork taking place.</p>

<p style="margin-left:11%; margin-top: 1em">To make use of
threading, however, one usually wants the threads to share
at least some data between themselves. This is done with the
threads::shared module and the &quot;:shared&quot;
attribute:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use threads::shared; <br>
my $foo :shared = 1; <br>
my $bar = 1; <br>
threads&minus;&gt;create(sub { $foo++; $bar++;
})&minus;&gt;join(); <br>
print(&quot;$foo\n&quot;); # Prints 2 since $foo is shared
<br>
print(&quot;$bar\n&quot;); # Prints 1 since $bar is not
shared</p>

<p style="margin-left:11%; margin-top: 1em">In the case of
a shared array, all the array&rsquo;s elements are shared,
and for a shared hash, all the keys and values are shared.
This places restrictions on what may be assigned to shared
array and hash elements: only simple values or references to
shared variables are allowed &minus; this is so that a
private variable can&rsquo;t accidentally become shared. A
bad assignment will cause the thread to die. For
example:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use threads::shared; <br>
my $var = 1; <br>
my $svar :shared = 2; <br>
my %hash :shared; <br>
... create some threads ... <br>
$hash{a} = 1; # All threads see exists($hash{a}) <br>
# and $hash{a} == 1 <br>
$hash{a} = $var; # okay &minus; copy&minus;by&minus;value:
same effect as previous <br>
$hash{a} = $svar; # okay &minus; copy&minus;by&minus;value:
same effect as previous <br>
$hash{a} = \$svar; # okay &minus; a reference to a shared
variable <br>
$hash{a} = \$var; # This will die <br>
delete($hash{a}); # okay &minus; all threads will see
!exists($hash{a})</p>

<p style="margin-left:11%; margin-top: 1em">Note that a
shared variable guarantees that if two or more threads try
to modify it at the same time, the internal state of the
variable will not become corrupted. However, there are no
guarantees beyond this, as explained in the next
section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Thread
Pitfalls: Races</b> <br>
While threads bring a new set of useful tools, they also
bring a number of pitfalls. One pitfall is the race
condition:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use threads::shared; <br>
my $x :shared = 1; <br>
my $thr1 = threads&minus;&gt;create(\&amp;sub1); <br>
my $thr2 = threads&minus;&gt;create(\&amp;sub2); <br>
$thr1&minus;&gt;join(); <br>
$thr2&minus;&gt;join(); <br>
print(&quot;$x\n&quot;); <br>
sub sub1 { my $foo = $x; $x = $foo + 1; } <br>
sub sub2 { my $bar = $x; $x = $bar + 1; }</p>

<p style="margin-left:11%; margin-top: 1em">What do you
think $x will be? The answer, unfortunately, is <i>it
depends</i>. Both &quot;sub1()&quot; and &quot;sub2()&quot;
access the global variable $x, once to read and once to
write. Depending on factors ranging from your thread
implementation&rsquo;s scheduling algorithm to the phase of
the moon, $x can be 2 or 3.</p>

<p style="margin-left:11%; margin-top: 1em">Race conditions
are caused by unsynchronized access to shared data. Without
explicit synchronization, there&rsquo;s no way to be sure
that nothing has happened to the shared data between the
time you access it and the time you update it. Even this
simple code fragment has the possibility of error:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
my $x :shared = 2; <br>
my $y :shared; <br>
my $z :shared; <br>
my $thr1 = threads&minus;&gt;create(sub { $y = $x; $x = $y +
1; }); <br>
my $thr2 = threads&minus;&gt;create(sub { $z = $x; $x = $z +
1; }); <br>
$thr1&minus;&gt;join(); <br>
$thr2&minus;&gt;join();</p>

<p style="margin-left:11%; margin-top: 1em">Two threads
both access $x. Each thread can potentially be interrupted
at any point, or be executed in any order. At the end, $x
could be 3 or 4, and both $y and $z could be 2 or 3.</p>

<p style="margin-left:11%; margin-top: 1em">Even &quot;$x
+= 5&quot; or &quot;$x++&quot; are not guaranteed to be
atomic.</p>

<p style="margin-left:11%; margin-top: 1em">Whenever your
program accesses data or resources that can be accessed by
other threads, you must take steps to coordinate access or
risk data inconsistency and race conditions. Note that Perl
will protect its internals from your race conditions, but it
won&rsquo;t protect you from you.</p>

<h2>Synchronization and control
<a name="Synchronization and control"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perl provides a
number of mechanisms to coordinate the interactions between
themselves and their data, to avoid race conditions and the
like. Some of these are designed to resemble the common
techniques used in thread libraries such as
&quot;pthreads&quot;; others are Perl-specific. Often, the
standard techniques are clumsy and difficult to get right
(such as condition waits). Where possible, it is usually
easier to use Perlish techniques such as queues, which
remove some of the hard work involved.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Controlling
access: lock()</b> <br>
The &quot;lock()&quot; function takes a shared variable and
puts a lock on it. No other thread may lock the variable
until the variable is unlocked by the thread holding the
lock. Unlocking happens automatically when the locking
thread exits the block that contains the call to the
&quot;lock()&quot; function. Using &quot;lock()&quot; is
straightforward: This example has several threads doing some
calculations in parallel, and occasionally updating a
running total:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use threads::shared; <br>
my $total :shared = 0; <br>
sub calc { <br>
while (1) { <br>
my $result; <br>
# (... do some calculations and set $result ...) <br>
{ <br>
lock($total); # Block until we obtain the lock <br>
$total += $result; <br>
} # Lock implicitly released at end of scope <br>
last if $result == 0; <br>
} <br>
} <br>
my $thr1 = threads&minus;&gt;create(\&amp;calc); <br>
my $thr2 = threads&minus;&gt;create(\&amp;calc); <br>
my $thr3 = threads&minus;&gt;create(\&amp;calc); <br>
$thr1&minus;&gt;join(); <br>
$thr2&minus;&gt;join(); <br>
$thr3&minus;&gt;join(); <br>
print(&quot;total=$total\n&quot;);</p>


<p style="margin-left:11%; margin-top: 1em">&quot;lock()&quot;
blocks the thread until the variable being locked is
available. When &quot;lock()&quot; returns, your thread can
be sure that no other thread can lock that variable until
the block containing the lock exits.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s
important to note that locks don&rsquo;t prevent access to
the variable in question, only lock attempts. This is in
keeping with Perl&rsquo;s longstanding tradition of
courteous programming, and the advisory file locking that
&quot;flock()&quot; gives you.</p>

<p style="margin-left:11%; margin-top: 1em">You may lock
arrays and hashes as well as scalars. Locking an array,
though, will not block subsequent locks on array elements,
just lock attempts on the array itself.</p>

<p style="margin-left:11%; margin-top: 1em">Locks are
recursive, which means it&rsquo;s okay for a thread to lock
a variable more than once. The lock will last until the
outermost &quot;lock()&quot; on the variable goes out of
scope. For example:</p>

<p style="margin-left:11%; margin-top: 1em">my $x :shared;
<br>
doit(); <br>
sub doit { <br>
{ <br>
{ <br>
lock($x); # Wait for lock <br>
lock($x); # NOOP &minus; we already have the lock <br>
{ <br>
lock($x); # NOOP <br>
{ <br>
lock($x); # NOOP <br>
lockit_some_more(); <br>
} <br>
} <br>
} # *** Implicit unlock here *** <br>
} <br>
} <br>
sub lockit_some_more { <br>
lock($x); # NOOP <br>
} # Nothing happens here</p>

<p style="margin-left:11%; margin-top: 1em">Note that there
is no &quot;unlock()&quot; function &minus; the only way to
unlock a variable is to allow it to go out of scope.</p>

<p style="margin-left:11%; margin-top: 1em">A lock can
either be used to guard the data contained within the
variable being locked, or it can be used to guard something
else, like a section of code. In this latter case, the
variable in question does not hold any useful data, and
exists only for the purpose of being locked. In this
respect, the variable behaves like the mutexes and basic
semaphores of traditional thread libraries.</p>

<p style="margin-left:11%; margin-top: 1em"><b>A Thread
Pitfall: Deadlocks</b> <br>
Locks are a handy tool to synchronize access to data, and
using them properly is the key to safe shared data.
Unfortunately, locks aren&rsquo;t without their dangers,
especially when multiple locks are involved. Consider the
following code:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
my $x :shared = 4; <br>
my $y :shared = 'foo'; <br>
my $thr1 = threads&minus;&gt;create(sub { <br>
lock($x); <br>
sleep(20); <br>
lock($y); <br>
}); <br>
my $thr2 = threads&minus;&gt;create(sub { <br>
lock($y); <br>
sleep(20); <br>
lock($x); <br>
});</p>

<p style="margin-left:11%; margin-top: 1em">This program
will probably hang until you kill it. The only way it
won&rsquo;t hang is if one of the two threads acquires both
locks first. A guaranteed-to-hang version is more
complicated, but the principle is the same.</p>

<p style="margin-left:11%; margin-top: 1em">The first
thread will grab a lock on $x, then, after a pause during
which the second thread has probably had time to do some
work, try to grab a lock on $y. Meanwhile, the second thread
grabs a lock on $y, then later tries to grab a lock on $x.
The second lock attempt for both threads will block, each
waiting for the other to release its lock.</p>

<p style="margin-left:11%; margin-top: 1em">This condition
is called a deadlock, and it occurs whenever two or more
threads are trying to get locks on resources that the others
own. Each thread will block, waiting for the other to
release a lock on a resource. That never happens, though,
since the thread with the resource is itself waiting for a
lock to be released.</p>

<p style="margin-left:11%; margin-top: 1em">There are a
number of ways to handle this sort of problem. The best way
is to always have all threads acquire locks in the exact
same order. If, for example, you lock variables $x, $y, and
$z, always lock $x before $y, and $y before $z. It&rsquo;s
also best to hold on to locks for as short a period of time
to minimize the risks of deadlock.</p>

<p style="margin-left:11%; margin-top: 1em">The other
synchronization primitives described below can suffer from
similar problems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Queues:
Passing Data Around</b> <br>
A queue is a special thread-safe object that lets you put
data in one end and take it out the other without having to
worry about synchronization issues. They&rsquo;re pretty
straightforward, and look like this:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use Thread::Queue; <br>
my $DataQueue = Thread::Queue&minus;&gt;new(); <br>
my $thr = threads&minus;&gt;create(sub { <br>
while (my $DataElement = $DataQueue&minus;&gt;dequeue()) {
<br>
print(&quot;Popped $DataElement off the queue\n&quot;); <br>
} <br>
}); <br>
$DataQueue&minus;&gt;enqueue(12); <br>
$DataQueue&minus;&gt;enqueue(&quot;A&quot;, &quot;B&quot;,
&quot;C&quot;); <br>
sleep(10); <br>
$DataQueue&minus;&gt;enqueue(undef); <br>
$thr&minus;&gt;join();</p>

<p style="margin-left:11%; margin-top: 1em">You create the
queue with &quot;Thread::Queue&minus;&gt;new()&quot;. Then
you can add lists of scalars onto the end with
&quot;enqueue()&quot;, and pop scalars off the front of it
with &quot;dequeue()&quot;. A queue has no fixed size, and
can grow as needed to hold everything pushed on to it.</p>

<p style="margin-left:11%; margin-top: 1em">If a queue is
empty, &quot;dequeue()&quot; blocks until another thread
enqueues something. This makes queues ideal for event loops
and other communications between threads.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Semaphores:
Synchronizing Data Access</b> <br>
Semaphores are a kind of generic locking mechanism. In their
most basic form, they behave very much like lockable
scalars, except that they can&rsquo;t hold data, and that
they must be explicitly unlocked. In their advanced form,
they act like a kind of counter, and can allow multiple
threads to have the <i>lock</i> at any one time.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Basic
semaphores</b> <br>
Semaphores have two methods, &quot;down()&quot; and
&quot;up()&quot;: &quot;down()&quot; decrements the resource
count, while &quot;up()&quot; increments it. Calls to
&quot;down()&quot; will block if the semaphore&rsquo;s
current count would decrement below zero. This program gives
a quick demonstration:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use Thread::Semaphore; <br>
my $semaphore = Thread::Semaphore&minus;&gt;new(); <br>
my $GlobalVariable :shared = 0; <br>
$thr1 = threads&minus;&gt;create(\&amp;sample_sub, 1); <br>
$thr2 = threads&minus;&gt;create(\&amp;sample_sub, 2); <br>
$thr3 = threads&minus;&gt;create(\&amp;sample_sub, 3); <br>
sub sample_sub { <br>
my $SubNumber = shift(@_); <br>
my $TryCount = 10; <br>
my $LocalCopy; <br>
sleep(1); <br>
while ($TryCount&minus;&minus;) { <br>
$semaphore&minus;&gt;down(); <br>
$LocalCopy = $GlobalVariable; <br>
print(&quot;$TryCount tries left for sub $SubNumber &quot;
<br>
.&quot;(\$GlobalVariable is $GlobalVariable)\n&quot;); <br>
sleep(2); <br>
$LocalCopy++; <br>
$GlobalVariable = $LocalCopy; <br>
$semaphore&minus;&gt;up(); <br>
} <br>
} <br>
$thr1&minus;&gt;join(); <br>
$thr2&minus;&gt;join(); <br>
$thr3&minus;&gt;join();</p>

<p style="margin-left:11%; margin-top: 1em">The three
invocations of the subroutine all operate in sync. The
semaphore, though, makes sure that only one thread is
accessing the global variable at once.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Advanced
Semaphores</b> <br>
By default, semaphores behave like locks, letting only one
thread &quot;down()&quot; them at a time. However, there are
other uses for semaphores.</p>

<p style="margin-left:11%; margin-top: 1em">Each semaphore
has a counter attached to it. By default, semaphores are
created with the counter set to one, &quot;down()&quot;
decrements the counter by one, and &quot;up()&quot;
increments by one. However, we can override any or all of
these defaults simply by passing in different values:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use Thread::Semaphore; <br>
my $semaphore = Thread::Semaphore&minus;&gt;new(5); <br>
# Creates a semaphore with the counter set to five <br>
my $thr1 = threads&minus;&gt;create(\&amp;sub1); <br>
my $thr2 = threads&minus;&gt;create(\&amp;sub1); <br>
sub sub1 { <br>
$semaphore&minus;&gt;down(5); # Decrements the counter by
five <br>
# Do stuff here <br>
$semaphore&minus;&gt;up(5); # Increment the counter by five
<br>
} <br>
$thr1&minus;&gt;detach(); <br>
$thr2&minus;&gt;detach();</p>

<p style="margin-left:11%; margin-top: 1em">If
&quot;down()&quot; attempts to decrement the counter below
zero, it blocks until the counter is large enough. Note that
while a semaphore can be created with a starting count of
zero, any &quot;up()&quot; or &quot;down()&quot; always
changes the counter by at least one, and so
&quot;$semaphore&minus;&gt;down(0)&quot; is the same as
&quot;$semaphore&minus;&gt;down(1)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The question,
of course, is why would you do something like this? Why
create a semaphore with a starting count that&rsquo;s not
one, or why decrement or increment it by more than one? The
answer is resource availability. Many resources that you
want to manage access for can be safely used by more than
one thread at once.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
let&rsquo;s take a <small>GUI</small> driven program. It has
a semaphore that it uses to synchronize access to the
display, so only one thread is ever drawing at once. Handy,
but of course you don&rsquo;t want any thread to start
drawing until things are properly set up. In this case, you
can create a semaphore with a counter set to zero, and up it
when things are ready for drawing.</p>

<p style="margin-left:11%; margin-top: 1em">Semaphores with
counters greater than one are also useful for establishing
quotas. Say, for example, that you have a number of threads
that can do I/O at once. You don&rsquo;t want all the
threads reading or writing at once though, since that can
potentially swamp your I/O channels, or deplete your
process&rsquo;s quota of filehandles. You can use a
semaphore initialized to the number of concurrent I/O
requests (or open files) that you want at any one time, and
have your threads quietly block and unblock themselves.</p>

<p style="margin-left:11%; margin-top: 1em">Larger
increments or decrements are handy in those cases where a
thread needs to check out or return a number of resources at
once.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Waiting for
a Condition</b> <br>
The functions &quot;cond_wait()&quot; and
&quot;cond_signal()&quot; can be used in conjunction with
locks to notify co-operating threads that a resource has
become available. They are very similar in use to the
functions found in &quot;pthreads&quot;. However for most
purposes, queues are simpler to use and more intuitive. See
threads::shared for more details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Giving up
control</b> <br>
There are times when you may find it useful to have a thread
explicitly give up the <small>CPU</small> to another thread.
You may be doing something processor-intensive and want to
make sure that the user-interface thread gets called
frequently. Regardless, there are times that you might want
a thread to give up the processor.</p>

<p style="margin-left:11%; margin-top: 1em">Perl&rsquo;s
threading package provides the &quot;yield()&quot; function
that does this. &quot;yield()&quot; is pretty
straightforward, and works like this:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
sub loop { <br>
my $thread = shift; <br>
my $foo = 50; <br>
while($foo&minus;&minus;) { print(&quot;In thread
$thread\n&quot;); } <br>
threads&minus;&gt;yield(); <br>
$foo = 50; <br>
while($foo&minus;&minus;) { print(&quot;In thread
$thread\n&quot;); } <br>
} <br>
my $thr1 = threads&minus;&gt;create(\&amp;loop, 'first');
<br>
my $thr2 = threads&minus;&gt;create(\&amp;loop, 'second');
<br>
my $thr3 = threads&minus;&gt;create(\&amp;loop,
'third');</p>

<p style="margin-left:11%; margin-top: 1em">It is important
to remember that &quot;yield()&quot; is only a hint to give
up the <small>CPU,</small> it depends on your hardware,
<small>OS</small> and threading libraries what actually
happens. <b>On many operating systems, yield() is a
no-op.</b> Therefore it is important to note that one should
not build the scheduling of the threads around
&quot;yield()&quot; calls. It might work on your platform
but it won&rsquo;t work on another platform.</p>

<h2>General Thread Utility Routines
<a name="General Thread Utility Routines"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">We&rsquo;ve
covered the workhorse parts of Perl&rsquo;s threading
package, and with these tools you should be well on your way
to writing threaded code and packages. There are a few
useful little pieces that didn&rsquo;t really fit in
anyplace else.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What Thread
Am I In?</b> <br>
The &quot;threads&minus;&gt;self()&quot; class method
provides your program with a way to get an object
representing the thread it&rsquo;s currently in. You can use
this object in the same way as the ones returned from thread
creation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Thread
IDs</b> <br>
&quot;tid()&quot; is a thread object method that returns the
thread <small>ID</small> of the thread the object
represents. Thread IDs are integers, with the main thread in
a program being 0. Currently Perl assigns a unique
<small>TID</small> to every thread ever created in your
program, assigning the first thread to be created a
<small>TID</small> of 1, and increasing the
<small>TID</small> by 1 for each new thread that&rsquo;s
created. When used as a class method,
&quot;threads&minus;&gt;tid()&quot; can be used by a thread
to get its own <small>TID.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>Are These
Threads The Same?</b> <br>
The &quot;equal()&quot; method takes two thread objects and
returns true if the objects represent the same thread, and
false if they don&rsquo;t.</p>

<p style="margin-left:11%; margin-top: 1em">Thread objects
also have an overloaded &quot;==&quot; comparison so that
you can do comparison on them as you would with normal
objects.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What Threads
Are Running?</b> <br>
&quot;threads&minus;&gt;list()&quot; returns a list of
thread objects, one for each thread that&rsquo;s currently
running and not detached. Handy for a number of things,
including cleaning up at the end of your program (from the
main Perl thread, of course):</p>

<p style="margin-left:11%; margin-top: 1em"># Loop through
all the threads <br>
foreach my $thr (threads&minus;&gt;list()) { <br>
$thr&minus;&gt;join(); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If some threads
have not finished running when the main Perl thread ends,
Perl will warn you about it and die, since it is impossible
for Perl to clean up itself while other threads are
running.</p>


<p style="margin-left:11%; margin-top: 1em"><small>NOTE:</small>
The main Perl thread (thread 0) is in a <i>detached</i>
state, and so does not appear in the list returned by
&quot;threads&minus;&gt;list()&quot;.</p>

<h2>A Complete Example
<a name="A Complete Example"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Confused yet?
It&rsquo;s time for an example program to show some of the
things we&rsquo;ve covered. This program finds prime numbers
using threads.</p>

<p style="margin-left:11%; margin-top: 1em">1
#!/usr/bin/perl <br>
2 # prime&minus;pthread, courtesy of Tom Christiansen <br>
3 <br>
4 use v5.36; <br>
5 <br>
6 use threads; <br>
7 use Thread::Queue; <br>
8 <br>
9 sub check_num ($upstream, $cur_prime) { <br>
10 my $kid; <br>
11 my $downstream = Thread::Queue&minus;&gt;new(); <br>
12 while (my $num = $upstream&minus;&gt;dequeue()) { <br>
13 next unless ($num % $cur_prime); <br>
14 if ($kid) { <br>
15 $downstream&minus;&gt;enqueue($num); <br>
16 } else { <br>
17 print(&quot;Found prime: $num\n&quot;); <br>
18 $kid = threads&minus;&gt;create(\&amp;check_num,
$downstream, $num); <br>
19 if (! $kid) { <br>
20 warn(&quot;Sorry. Ran out of threads.\n&quot;); <br>
21 last; <br>
22 } <br>
23 } <br>
24 } <br>
25 if ($kid) { <br>
26 $downstream&minus;&gt;enqueue(undef); <br>
27 $kid&minus;&gt;join(); <br>
28 } <br>
29 } <br>
30 <br>
31 my $stream = Thread::Queue&minus;&gt;new(3..1000, undef);
<br>
32 check_num($stream, 2);</p>

<p style="margin-left:11%; margin-top: 1em">This program
uses the pipeline model to generate prime numbers. Each
thread in the pipeline has an input queue that feeds numbers
to be checked, a prime number that it&rsquo;s responsible
for, and an output queue into which it funnels numbers that
have failed the check. If the thread has a number
that&rsquo;s failed its check and there&rsquo;s no child
thread, then the thread must have found a new prime number.
In that case, a new child thread is created for that prime
and stuck on the end of the pipeline.</p>

<p style="margin-left:11%; margin-top: 1em">This probably
sounds a bit more confusing than it really is, so
let&rsquo;s go through this program piece by piece and see
what it does. (For those of you who might be trying to
remember exactly what a prime number is, it&rsquo;s a number
that&rsquo;s only evenly divisible by itself and 1.)</p>

<p style="margin-left:11%; margin-top: 1em">The bulk of the
work is done by the &quot;check_num()&quot; subroutine,
which takes a reference to its input queue and a prime
number that it&rsquo;s responsible for. We create a new
queue (line 11) and reserve a scalar for the thread that
we&rsquo;re likely to create later (line 10).</p>

<p style="margin-left:11%; margin-top: 1em">The while loop
from line 12 to line 24 grabs a scalar off the input queue
and checks against the prime this thread is responsible for.
Line 13 checks to see if there&rsquo;s a remainder when we
divide the number to be checked by our prime. If there is
one, the number must not be evenly divisible by our prime,
so we need to either pass it on to the next thread if
we&rsquo;ve created one (line 15) or create a new thread if
we haven&rsquo;t.</p>

<p style="margin-left:11%; margin-top: 1em">The new thread
creation is line 18. We pass on to it a reference to the
queue we&rsquo;ve created, and the prime number we&rsquo;ve
found. In lines 19 through 22, we check to make sure that
our new thread got created, and if not, we stop checking any
remaining numbers in the queue.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, once
the loop terminates (because we got a 0 or &quot;undef&quot;
in the queue, which serves as a note to terminate), we pass
on the notice to our child, and wait for it to exit if
we&rsquo;ve created a child (lines 25 and 28).</p>

<p style="margin-left:11%; margin-top: 1em">Meanwhile, back
in the main thread, we first create a queue (line 31) and
queue up all the numbers from 3 to 1000 for checking, plus a
termination notice. Then all we have to do to get the ball
rolling is pass the queue and the first prime to the
&quot;check_num()&quot; subroutine (line 32).</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
how it works. It&rsquo;s pretty simple; as with many Perl
programs, the explanation is much longer than the
program.</p>

<h2>Different implementations of threads
<a name="Different implementations of threads"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Some background
on thread implementations from the operating system
viewpoint. There are three basic categories of threads:
user-mode threads, kernel threads, and multiprocessor kernel
threads.</p>

<p style="margin-left:11%; margin-top: 1em">User-mode
threads are threads that live entirely within a program and
its libraries. In this model, the <small>OS</small> knows
nothing about threads. As far as it&rsquo;s concerned, your
process is just a process.</p>

<p style="margin-left:11%; margin-top: 1em">This is the
easiest way to implement threads, and the way most OSes
start. The big disadvantage is that, since the
<small>OS</small> knows nothing about threads, if one thread
blocks they all do. Typical blocking activities include most
system calls, most I/O, and things like
&quot;sleep()&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Kernel threads
are the next step in thread evolution. The <small>OS</small>
knows about kernel threads, and makes allowances for them.
The main difference between a kernel thread and a user-mode
thread is blocking. With kernel threads, things that block a
single thread don&rsquo;t block other threads. This is not
the case with user-mode threads, where the kernel blocks at
the process level and not the thread level.</p>

<p style="margin-left:11%; margin-top: 1em">This is a big
step forward, and can give a threaded program quite a
performance boost over non-threaded programs. Threads that
block performing I/O, for example, won&rsquo;t block threads
that are doing other things. Each process still has only one
thread running at once, though, regardless of how many CPUs
a system might have.</p>

<p style="margin-left:11%; margin-top: 1em">Since kernel
threading can interrupt a thread at any time, they will
uncover some of the implicit locking assumptions you may
make in your program. For example, something as simple as
&quot;$x = $x + 2&quot; can behave unpredictably with kernel
threads if $x is visible to other threads, as another thread
may have changed $x between the time it was fetched on the
right hand side and the time the new value is stored.</p>

<p style="margin-left:11%; margin-top: 1em">Multiprocessor
kernel threads are the final step in thread support. With
multiprocessor kernel threads on a machine with multiple
CPUs, the <small>OS</small> may schedule two or more threads
to run simultaneously on different CPUs.</p>

<p style="margin-left:11%; margin-top: 1em">This can give a
serious performance boost to your threaded program, since
more than one thread will be executing at the same time. As
a tradeoff, though, any of those nagging synchronization
issues that might not have shown with basic kernel threads
will appear with a vengeance.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the different levels of <small>OS</small> involvement in
threads, different OSes (and different thread
implementations for a particular <small>OS</small> )
allocate <small>CPU</small> cycles to threads in different
ways.</p>

<p style="margin-left:11%; margin-top: 1em">Cooperative
multitasking systems have running threads give up control if
one of two things happen. If a thread calls a yield
function, it gives up control. It also gives up control if
the thread does something that would cause it to block, such
as perform I/O. In a cooperative multitasking
implementation, one thread can starve all the others for
<small>CPU</small> time if it so chooses.</p>

<p style="margin-left:11%; margin-top: 1em">Preemptive
multitasking systems interrupt threads at regular intervals
while the system decides which thread should run next. In a
preemptive multitasking system, one thread usually
won&rsquo;t monopolize the <small>CPU.</small></p>

<p style="margin-left:11%; margin-top: 1em">On some
systems, there can be cooperative and preemptive threads
running simultaneously. (Threads running with realtime
priorities often behave cooperatively, for example, while
threads running at normal priorities behave
preemptively.)</p>

<p style="margin-left:11%; margin-top: 1em">Most modern
operating systems support preemptive multitasking
nowadays.</p>

<h2>Performance considerations
<a name="Performance considerations"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The main thing
to bear in mind when comparing Perl&rsquo;s <i>ithreads</i>
to other threading models is the fact that for each new
thread created, a complete copy of all the variables and
data of the parent thread has to be taken. Thus, thread
creation can be quite expensive, both in terms of memory
usage and time spent in creation. The ideal way to reduce
these costs is to have a relatively short number of
long-lived threads, all created fairly early on (before the
base thread has accumulated too much data). Of course, this
may not always be possible, so compromises have to be made.
However, after a thread has been created, its performance
and extra memory usage should be little different than
ordinary code.</p>

<p style="margin-left:11%; margin-top: 1em">Also note that
under the current implementation, shared variables use a
little more memory and are a little slower than ordinary
variables.</p>

<h2>Process-scope Changes
<a name="Process-scope Changes"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note that while
threads themselves are separate execution threads and Perl
data is thread-private unless explicitly shared, the threads
can affect process-scope state, affecting all the
threads.</p>

<p style="margin-left:11%; margin-top: 1em">The most common
example of this is changing the current working directory
using &quot;chdir()&quot;. One thread calls
&quot;chdir()&quot;, and the working directory of all the
threads changes.</p>

<p style="margin-left:11%; margin-top: 1em">Even more
drastic example of a process-scope change is
&quot;chroot()&quot;: the root directory of all the threads
changes, and no thread can undo it (as opposed to
&quot;chdir()&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Further
examples of process-scope changes include
&quot;umask()&quot; and changing uids and gids.</p>

<p style="margin-left:11%; margin-top: 1em">Thinking of
mixing &quot;fork()&quot; and threads? Please lie down and
wait until the feeling passes. Be aware that the semantics
of &quot;fork()&quot; vary between platforms. For example,
some Unix systems copy all the current threads into the
child process, while others only copy the thread that called
&quot;fork()&quot;. You have been warned!</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
mixing signals and threads may be problematic.
Implementations are platform-dependent, and even the
<small>POSIX</small> semantics may not be what you expect
(and Perl doesn&rsquo;t even give you the full <small>POSIX
API</small> ). For example, there is no way to guarantee
that a signal sent to a multi-threaded Perl application will
get intercepted by any particular thread. (However, a
recently added feature does provide the capability to send
signals between threads. See &quot; <small>THREAD
SIGNALLING&quot;</small> in threads for more details.)</p>

<h2>Thread-Safety of System Libraries
<a name="Thread-Safety of System Libraries"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Whether various
library calls are thread-safe is outside the control of
Perl. Calls often suffering from not being thread-safe
include: &quot;localtime()&quot;, &quot;gmtime()&quot;,
functions fetching user, group and network information (such
as &quot;getgrent()&quot;, &quot;gethostent()&quot;,
&quot;getnetent()&quot; and so on), &quot;readdir()&quot;,
&quot;rand()&quot;, and &quot;srand()&quot;. In general,
calls that depend on some global external state.</p>

<p style="margin-left:11%; margin-top: 1em">If the system
Perl is compiled in has thread-safe variants of such calls,
they will be used. Beyond that, Perl is at the mercy of the
thread-safety or &minus;unsafety of the calls. Please
consult your C library call documentation.</p>

<p style="margin-left:11%; margin-top: 1em">On some
platforms the thread-safe library interfaces may fail if the
result buffer is too small (for example the user group
databases may be rather large, and the reentrant interfaces
may have to carry around a full snapshot of those
databases). Perl will start with a small buffer, but keep
retrying and growing the result buffer until the result
fits. If this limitless growing sounds bad for security or
memory consumption reasons you can recompile Perl with
&quot;PERL_REENTRANT_MAXSIZE&quot; defined to the maximum
number of bytes you will allow.</p>

<h2>Conclusion
<a name="Conclusion"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A complete
thread tutorial could fill a book (and has, many times), but
with what we&rsquo;ve covered in this introduction, you
should be well on your way to becoming a threaded Perl
expert.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Annotated
<small>POD</small> for threads:
&lt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Latest version
of threads on <small>CPAN:</small>
&lt;https://metacpan.org/pod/threads&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Annotated
<small>POD</small> for threads::shared:
&lt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads%3A%3Ashared&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Latest version
of threads::shared on <small>CPAN:</small>
&lt;https://metacpan.org/pod/threads::shared&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Perl threads
mailing list:
&lt;https://lists.perl.org/list/ithreads.html&gt;</p>

<h2>Bibliography
<a name="Bibliography"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
short bibliography courtesy of Juergen Christoffel:</p>


<p style="margin-left:11%; margin-top: 1em"><b>Introductory
Texts</b> <br>
Birrell, Andrew D. An Introduction to Programming with
Threads. Digital Equipment Corporation, 1989, DEC-SRC
Research Report #35 online as
&lt;https://www.hpl.hp.com/techreports/Compaq&minus;DEC/SRC&minus;RR&minus;35.pdf&gt;
(highly recommended)</p>

<p style="margin-left:11%; margin-top: 1em">Robbins, Kay.
A., and Steven Robbins. Practical Unix Programming: A Guide
to Concurrency, Communication, and Multithreading.
Prentice-Hall, 1996.</p>

<p style="margin-left:11%; margin-top: 1em">Lewis, Bill,
and Daniel J. Berg. Multithreaded Programming with Pthreads.
Prentice Hall, 1997, <small>ISBN
0&minus;13&minus;443698&minus;9</small> (a well-written
introduction to threads).</p>

<p style="margin-left:11%; margin-top: 1em">Nelson, Greg
(editor). Systems Programming with Modula&minus;3. Prentice
Hall, 1991, <small>ISBN
0&minus;13&minus;590464&minus;1.</small></p>

<p style="margin-left:11%; margin-top: 1em">Nichols,
Bradford, Dick Buttlar, and Jacqueline Proulx Farrell.
Pthreads Programming. O&rsquo;Reilly &amp; Associates, 1996,
<small>ISBN 156592&minus;115&minus;1</small> (covers
<small>POSIX</small> threads).</p>

<p style="margin-left:11%; margin-top: 1em"><b>OS-Related
References</b> <br>
Boykin, Joseph, David Kirschen, Alan Langerman, and Susan
LoVerso. Programming under Mach. Addison-Wesley, 1994,
<small>ISBN 0&minus;201&minus;52739&minus;1.</small></p>

<p style="margin-left:11%; margin-top: 1em">Tanenbaum,
Andrew S. Distributed Operating Systems. Prentice Hall,
1995, <small>ISBN 0&minus;13&minus;219908&minus;4</small>
(great textbook).</p>

<p style="margin-left:11%; margin-top: 1em">Silberschatz,
Abraham, and Peter B. Galvin. Operating System Concepts, 4th
ed. Addison-Wesley, 1995, <small>ISBN
0&minus;201&minus;59292&minus;4</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>Other
References</b> <br>
Arnold, Ken and James Gosling. The Java Programming
Language, 2nd ed. Addison-Wesley, 1998, <small>ISBN
0&minus;201&minus;31006&minus;6.</small></p>


<p style="margin-left:11%; margin-top: 1em">comp.programming.threads
<small>FAQ,</small>
&lt;http://www.serpentine.com/~bos/threads&minus;faq/&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Le Sergent, T.
and B. Berthomieu. &quot;Incremental MultiThreaded Garbage
Collection on Virtually Shared Memory Architectures&quot; in
Memory Management: Proc. of the International Workshop
<small>IWMM 92,</small> St. Malo, France, September 1992,
Yves Bekkers and Jacques Cohen, eds. Springer, 1992,
<small>ISBN 3540&minus;55940&minus;X</small> (real-life
thread applications).</p>

<p style="margin-left:11%; margin-top: 1em">Artur Bergman,
&quot;Where Wizards Fear To Tread&quot;, June 11, 2002,
&lt;http://www.perl.com/pub/a/2002/06/11/threads.html&gt;</p>

<h2>Acknowledgements
<a name="Acknowledgements"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Thanks (in no
particular order) to Chaim Frenkel, Steve Fink, Gurusamy
Sarathy, Ilya Zakharevich, Benjamin Sugars, Juergen
Christoffel, Joshua Pritikin, and Alan Burlison, for their
help in reality-checking and polishing this article. Big
thanks to Tom Christiansen for his rewrite of the prime
number generator.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Dan Sugalski
&lt;dan@sidhe.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Slightly
modified by Arthur Bergman to fit the new thread
model/module.</p>

<p style="margin-left:11%; margin-top: 1em">Reworked
slightly by Joerg Walter &lt;jwalt@cpan.org&gt; to be more
concise about thread-safety of Perl code.</p>

<p style="margin-left:11%; margin-top: 1em">Rearranged
slightly by Elizabeth Mattijsen &lt;liz@dijkmat.nl&gt; to
put less emphasis on <b>yield()</b>.</p>

<h2>Copyrights
<a name="Copyrights"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The original
version of this article originally appeared in The Perl
Journal #10, and is copyright 1998 The Perl Journal. It
appears courtesy of Jon Orwant and The Perl Journal. This
document may be distributed under the same terms as Perl
itself.</p>
<hr>
</body>
</html>
