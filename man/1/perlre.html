<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLRE</title>

</head>
<body>
<h1>perlre</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlre &minus;
Perl regular expressions</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page
describes the syntax of regular expressions in Perl.</p>

<p style="margin-left:11%; margin-top: 1em">If you
haven&rsquo;t used regular expressions before, a tutorial
introduction is available in perlretut. If you know just a
little about them, a quick-start introduction is available
in perlrequick.</p>

<p style="margin-left:11%; margin-top: 1em">Except for
&quot;The Basics&quot; section, this page assumes you are
familiar with regular expression basics, like what is a
&quot;pattern&quot;, what does it look like, and how it is
basically used. For a reference on how they are used, plus
various examples of the same, see discussions of
&quot;m//&quot;, &quot;s///&quot;, &quot;qr//&quot; and
&quot;??&quot; in &quot;Regexp Quote-Like Operators&quot; in
perlop.</p>

<p style="margin-left:11%; margin-top: 1em">New in v5.22,
&quot;use re 'strict'&quot; applies stricter rules than
otherwise when compiling regular expression patterns. It can
find things that, while legal, may not be what you
intended.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
Basics</b> <br>
Regular expressions are strings with the very particular
syntax and meaning described in this document and auxiliary
documents referred to by this one. The strings are called
&quot;patterns&quot;. Patterns are used to determine if some
other string, called the &quot;target&quot;, has (or
doesn&rsquo;t have) the characteristics specified by the
pattern. We call this &quot;matching&quot; the target string
against the pattern. Usually the match is done by having the
target be the first operand, and the pattern be the second
operand, of one of the two binary operators &quot;=~&quot;
and &quot;!~&quot;, listed in &quot;Binding Operators&quot;
in perlop; and the pattern will have been converted from an
ordinary string by one of the operators in &quot;Regexp
Quote-Like Operators&quot; in perlop, like so:</p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m/abc/</p>

<p style="margin-left:11%; margin-top: 1em">This evaluates
to true if and only if the string in the variable $foo
contains somewhere in it, the sequence of characters
&quot;a&quot;, &quot;b&quot;, then &quot;c&quot;. (The
&quot;=~ m&quot;, or match operator, is described in
&quot;m/PATTERN/msixpodualngc&quot; in perlop.)</p>

<p style="margin-left:11%; margin-top: 1em">Patterns that
aren&rsquo;t already stored in some variable must be
delimited, at both ends, by delimiter characters. These are
often, as in the example above, forward slashes, and the
typical way a pattern is written in documentation is with
those slashes. In most cases, the delimiter is the same
character, fore and aft, but there are a few cases where a
character looks like it has a mirror-image mate, where the
opening version is the beginning delimiter, and the closing
one is the ending delimiter, like</p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m&lt;abc&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Most times, the
pattern is evaluated in double-quotish context, but it is
possible to choose delimiters to force single-quotish,
like</p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m'abc'</p>

<p style="margin-left:11%; margin-top: 1em">If the pattern
contains its delimiter within it, that delimiter must be
escaped. Prefixing it with a backslash (<i>e.g.</i>,
&quot;/foo\/bar/&quot;) serves this purpose.</p>

<p style="margin-left:11%; margin-top: 1em">Any single
character in a pattern matches that same character in the
target string, unless the character is a
<i>metacharacter</i> with a special meaning described in
this document. A sequence of non-metacharacters matches the
same sequence in the target string, as we saw above with
&quot;m/abc/&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Only a few
characters (all of them being <small>ASCII</small>
punctuation characters) are metacharacters. The most
commonly used one is a dot &quot;.&quot;, which normally
matches almost any character (including a dot itself).</p>

<p style="margin-left:11%; margin-top: 1em">You can cause
characters that normally function as metacharacters to be
interpreted literally by prefixing them with a
&quot;\&quot;, just like the pattern&rsquo;s delimiter must
be escaped if it also occurs within the pattern. Thus,
&quot;\.&quot; matches just a literal dot, &quot;.&quot;
instead of its normal meaning. This means that the backslash
is also a metacharacter, so &quot;\\&quot; matches a single
&quot;\&quot;. And a sequence that contains an escaped
metacharacter matches the same sequence (but without the
escape) in the target string. So, the pattern
&quot;/blur\\fl/&quot; would match any target string that
contains the sequence &quot;blur\fl&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
metacharacter &quot;|&quot; is used to match one thing or
another. Thus</p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m/this|that/</p>

<p style="margin-left:11%; margin-top: 1em">is
<small>TRUE</small> if and only if $foo contains either the
sequence &quot;this&quot; or the sequence &quot;that&quot;.
Like all metacharacters, prefixing the &quot;|&quot; with a
backslash makes it match the plain punctuation character; in
its case, the <small>VERTICAL LINE.</small></p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m/this\|that/</p>

<p style="margin-left:11%; margin-top: 1em">is
<small>TRUE</small> if and only if $foo contains the
sequence &quot;this|that&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You
aren&rsquo;t limited to just a single &quot;|&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m/fee|fie|foe|fum/</p>

<p style="margin-left:11%; margin-top: 1em">is
<small>TRUE</small> if and only if $foo contains any of
those 4 sequences from the children&rsquo;s story &quot;Jack
and the Beanstalk&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">As you can see,
the &quot;|&quot; binds less tightly than a sequence of
ordinary characters. We can override this by using the
grouping metacharacters, the parentheses &quot;(&quot; and
&quot;)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m/th(is|at) thing/</p>

<p style="margin-left:11%; margin-top: 1em">is
<small>TRUE</small> if and only if $foo contains either the
sequence &quot;this&nbsp;thing&quot; or the sequence
&quot;that&nbsp;thing&quot;. The portions of the string that
match the portions of the pattern enclosed in parentheses
are normally made available separately for use later in the
pattern, substitution, or program. This is called
&quot;capturing&quot;, and it can get complicated. See
&quot;Capture groups&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The first
alternative includes everything from the last pattern
delimiter (&quot;(&quot;, &quot;(?:&quot; (described later),
<i>etc</i>. or the beginning of the pattern) up to the first
&quot;|&quot;, and the last alternative contains everything
from the last &quot;|&quot; to the next closing pattern
delimiter. That&rsquo;s why it&rsquo;s common practice to
include alternatives in parentheses: to minimize confusion
about where they start and end.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatives
are tried from left to right, so the first alternative found
for which the entire expression matches, is the one that is
chosen. This means that alternatives are not necessarily
greedy. For example: when matching &quot;foo|foot&quot;
against &quot;barefoot&quot;, only the &quot;foo&quot; part
will match, as that is the first alternative tried, and it
successfully matches the target string. (This might not seem
important, but it is important when you are capturing
matched text using parentheses.)</p>

<p style="margin-left:11%; margin-top: 1em">Besides taking
away the special meaning of a metacharacter, a prefixed
backslash changes some letter and digit characters away from
matching just themselves to instead have special meaning.
These are called &quot;escape sequences&quot;, and all such
are described in perlrebackslash. A backslash sequence (of a
letter or digit) that doesn&rsquo;t currently have special
meaning to Perl will raise a warning if warnings are
enabled, as those are reserved for potential future use.</p>

<p style="margin-left:11%; margin-top: 1em">One such
sequence is &quot;\b&quot;, which matches a boundary of some
sort. &quot;\b{wb}&quot; and a few others give specialized
types of boundaries. (They are all described in detail
starting at &quot;\b{}, \b, \B{}, \B&quot; in
perlrebackslash.) Note that these don&rsquo;t match
characters, but the zero-width spaces between characters.
They are an example of a zero-width assertion. Consider
again,</p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m/fee|fie|foe|fum/</p>

<p style="margin-left:11%; margin-top: 1em">It evaluates to
<small>TRUE</small> if, besides those 4 words, any of the
sequences &quot;feed&quot;, &quot;field&quot;,
&quot;Defoe&quot;, &quot;fume&quot;, and many others are in
$foo. By judicious use of &quot;\b&quot; (or better (because
it is designed to handle natural language)
&quot;\b{wb}&quot;), we can make sure that only the
Giant&rsquo;s words are matched:</p>

<p style="margin-left:11%; margin-top: 1em">$foo =~
m/\b(fee|fie|foe|fum)\b/ <br>
$foo =~ m/\b{wb}(fee|fie|foe|fum)\b{wb}/</p>

<p style="margin-left:11%; margin-top: 1em">The final
example shows that the characters &quot;{&quot; and
&quot;}&quot; are metacharacters.</p>

<p style="margin-left:11%; margin-top: 1em">Another use for
escape sequences is to specify characters that cannot (or
which you prefer not to) be written literally. These are
described in detail in &quot;Character Escapes&quot; in
perlrebackslash, but the next three paragraphs briefly
describe some of them.</p>

<p style="margin-left:11%; margin-top: 1em">Various control
characters can be written in C language style:
&quot;\n&quot; matches a newline, &quot;\t&quot; a tab,
&quot;\r&quot; a carriage return, &quot;\f&quot; a form
feed, <i>etc</i>.</p>

<p style="margin-left:11%; margin-top: 1em">More generally,
&quot;\<i>nnn</i>&quot;, where <i>nnn</i> is a string of
three octal digits, matches the character whose native code
point is <i>nnn</i>. You can easily run into trouble if you
don&rsquo;t have exactly three digits. So always use three,
or since Perl 5.14, you can use &quot;\o{...}&quot; to
specify any number of octal digits.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
&quot;\x<i>nn</i>&quot;, where <i>nn</i> are hexadecimal
digits, matches the character whose native ordinal is
<i>nn</i>. Again, not using exactly two digits is a recipe
for disaster, but you can use &quot;\x{...}&quot; to specify
any number of hex digits.</p>

<p style="margin-left:11%; margin-top: 1em">Besides being a
metacharacter, the &quot;.&quot; is an example of a
&quot;character class&quot;, something that can match any
single character of a given set of them. In its case, the
set is just about all possible characters. Perl predefines
several character classes besides the &quot;.&quot;; there
is a separate reference page about just these,
perlrecharclass.</p>

<p style="margin-left:11%; margin-top: 1em">You can define
your own custom character classes, by putting into your
pattern in the appropriate place(s), a list of all the
characters you want in the set. You do this by enclosing the
list within &quot;[]&quot; bracket characters. These are
called &quot;bracketed character classes&quot; when we are
being precise, but often the word &quot;bracketed&quot; is
dropped. (Dropping it usually doesn&rsquo;t cause
confusion.) This means that the &quot;[&quot; character is
another metacharacter. It doesn&rsquo;t match anything just
by itself; it is used only to tell Perl that what follows it
is a bracketed character class. If you want to match a
literal left square bracket, you must escape it, like
&quot;\[&quot;. The matching &quot;]&quot; is also a
metacharacter; again it doesn&rsquo;t match anything by
itself, but just marks the end of your custom class to Perl.
It is an example of a &quot;sometimes metacharacter&quot;.
It isn&rsquo;t a metacharacter if there is no corresponding
&quot;[&quot;, and matches its literal self:</p>

<p style="margin-left:11%; margin-top: 1em">print
&quot;]&quot; =~ /]/; # prints 1</p>

<p style="margin-left:11%; margin-top: 1em">The list of
characters within the character class gives the set of
characters matched by the class. &quot;[abc]&quot; matches a
single &quot;a&quot; or &quot;b&quot; or &quot;c&quot;. But
if the first character after the &quot;[&quot; is
&quot;^&quot;, the class instead matches any character not
in the list. Within a list, the &quot;&minus;&quot;
character specifies a range of characters, so that
&quot;a&minus;z&quot; represents all characters between
&quot;a&quot; and &quot;z&quot;, inclusive. If you want
either &quot;&minus;&quot; or &quot;]&quot; itself to be a
member of a class, put it at the start of the list (possibly
after a &quot;^&quot;), or escape it with a backslash.
&quot;&minus;&quot; is also taken literally when it is at
the end of the list, just before the closing &quot;]&quot;.
(The following all specify the same class of three
characters: &quot;[&minus;az]&quot;,
&quot;[az&minus;]&quot;, and &quot;[a\&minus;z]&quot;. All
are different from &quot;[a&minus;z]&quot;, which specifies
a class containing twenty-six characters, even on
EBCDIC-based character sets.)</p>

<p style="margin-left:11%; margin-top: 1em">There is lots
more to bracketed character classes; full details are in
&quot;Bracketed Character Classes&quot; in
perlrecharclass.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Metacharacters</i></p>

<p style="margin-left:11%; margin-top: 1em">&quot;The
Basics&quot; introduced some of the metacharacters. This
section gives them all. Most of them have the same meaning
as in the <i>egrep</i> command.</p>

<p style="margin-left:11%; margin-top: 1em">Only the
&quot;\&quot; is always a metacharacter. The others are
metacharacters just sometimes. The following tables lists
all of them, summarizes their use, and gives the contexts
where they are metacharacters. Outside those contexts or if
prefixed by a &quot;\&quot;, they match their corresponding
punctuation character. In some cases, their meaning varies
depending on various pattern modifiers that alter the
default behaviors. See &quot;Modifiers&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">PURPOSE WHERE
<br>
\ Escape the next character Always, except when <br>
escaped by another \ <br>
^ Match the beginning of the string Not in [] <br>
(or line, if /m is used) <br>
^ Complement the [] class At the beginning of [] <br>
. Match any single character except newline Not in [] <br>
(under /s, includes newline) <br>
$ Match the end of the string Not in [], but can <br>
(or before newline at the end of the mean interpolate a <br>
string; or before any newline if /m is scalar <br>
used) <br>
| Alternation Not in [] <br>
() Grouping Not in [] <br>
[ Start Bracketed Character class Not in [] <br>
] End Bracketed Character class Only in [], and <br>
not first <br>
* Matches the preceding element 0 or more Not in [] <br>
times <br>
+ Matches the preceding element 1 or more Not in [] <br>
times <br>
? Matches the preceding element 0 or 1 Not in [] <br>
times <br>
{ Starts a sequence that gives number(s) Not in [] <br>
of times the preceding element can be <br>
matched <br>
{ when following certain escape sequences <br>
starts a modifier to the meaning of the <br>
sequence <br>
} End sequence started by { <br>
&minus; Indicates a range Only in [] interior <br>
# Beginning of comment, extends to line end Only with /x
modifier</p>

<p style="margin-left:11%; margin-top: 1em">Notice that
most of the metacharacters lose their special meaning when
they occur in a bracketed character class, except
&quot;^&quot; has a different meaning when it is at the
beginning of such a class. And &quot;&minus;&quot; and
&quot;]&quot; are metacharacters only at restricted
positions within bracketed character classes; while
&quot;}&quot; is a metacharacter only when closing a special
construct started by &quot;{&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">In
double-quotish context, as is usually the case, you need to
be careful about &quot;$&quot; and the non-metacharacter
&quot;@&quot;. Those could interpolate variables, which may
or may not be what you intended.</p>

<p style="margin-left:11%; margin-top: 1em">These rules
were designed for compactness of expression, rather than
legibility and maintainability. The &quot;/x and /xx&quot;
pattern modifiers allow you to insert white space to improve
readability. And use of &quot;re&nbsp;'strict'&quot; adds
extra checking to catch some typos that might silently
compile into something unintended.</p>

<p style="margin-left:11%; margin-top: 1em">By default, the
&quot;^&quot; character is guaranteed to match only the
beginning of the string, the &quot;$&quot; character only
the end (or before the newline at the end), and Perl does
certain optimizations with the assumption that the string
contains only one line. Embedded newlines will not be
matched by &quot;^&quot; or &quot;$&quot;. You may, however,
wish to treat a string as a multi-line buffer, such that the
&quot;^&quot; will match after any newline within the string
(except if the newline is the last character in the string),
and &quot;$&quot; will match before any newline. At the cost
of a little more overhead, you can do this by using the
&quot;/m&quot; modifier on the pattern match operator.
(Older programs did this by setting $*, but this option was
removed in perl 5.10.)</p>

<p style="margin-left:11%; margin-top: 1em">To simplify
multi-line substitutions, the &quot;.&quot; character never
matches a newline unless you use the &quot;/s&quot;
modifier, which in effect tells Perl to pretend the string
is a single line--even if it isn&rsquo;t.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Modifiers</b>
<i><br>
Overview</i></p>

<p style="margin-left:11%; margin-top: 1em">The default
behavior for matching can be changed, using various
modifiers. Modifiers that relate to the interpretation of
the pattern are listed just below. Modifiers that alter the
way a pattern is used by Perl are detailed in &quot;Regexp
Quote-Like Operators&quot; in perlop and &quot;Gory details
of parsing quoted constructs&quot; in perlop. Modifiers can
be added dynamically; see &quot;Extended Patterns&quot;
below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&quot;m&quot;</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>Treat the string being matched against as multiple
lines. That is, change &quot;^&quot; and &quot;$&quot; from
matching the start of the string&rsquo;s first line and the
end of its last line to matching the start and end of each
line within the string.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&quot;s&quot;</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>Treat the string as single line. That is, change
&quot;.&quot; to match any character whatsoever, even a
newline, which normally it would not match.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Used together,
as &quot;/ms&quot;, they let the &quot;.&quot; match any
character whatsoever, while still allowing &quot;^&quot; and
&quot;$&quot; to match, respectively, just after and just
before newlines within the string.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>&quot;i&quot;</b></p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Do case-insensitive pattern
matching. For example, &quot;A&quot; will match
&quot;a&quot; under &quot;/i&quot;.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If locale
matching rules are in effect, the case map is taken from the
current locale for code points less than 255, and from
Unicode rules for larger code points. However, matches that
would cross the Unicode rules/non&minus;Unicode rules
boundary (ords 255/256) will not succeed, unless the locale
is a <small>UTF&minus;8</small> one. See perllocale.</p>

<p style="margin-left:17%; margin-top: 1em">There are a
number of Unicode characters that match a sequence of
multiple characters under &quot;/i&quot;. For example,
&quot;LATIN SMALL LIGATURE FI&quot; should match the
sequence &quot;fi&quot;. Perl is not currently able to do
this when the multiple characters are in the pattern and are
split between groupings, or when one or more are quantified.
Thus</p>

<p style="margin-left:17%; margin-top: 1em">&quot;\N{LATIN
SMALL LIGATURE FI}&quot; =~ /fi/i; # Matches <br>
&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /[fi][fi]/i; #
Doesn't match! <br>
&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi*/i; # Doesn't
match! <br>
# The below doesn't match, and it isn't clear what $1 and $2
would <br>
# be even if it did!! <br>
&quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /(f)(i)/i; #
Doesn't match!</p>

<p style="margin-left:17%; margin-top: 1em">Perl
doesn&rsquo;t match multiple characters in a bracketed
character class unless the character that maps to them is
explicitly mentioned, and it doesn&rsquo;t match them at all
if the character class is inverted, which otherwise could be
highly confusing. See &quot;Bracketed Character
Classes&quot; in perlrecharclass, and &quot;Negation&quot;
in perlrecharclass.</p>

<p style="margin-left:11%;"><b>&quot;x&quot;</b> and
<b>&quot;xx&quot;</b></p>

<p style="margin-left:17%;">Extend your pattern&rsquo;s
legibility by permitting whitespace and comments. Details in
&quot;/x and /xx&quot;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&quot;p&quot;</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>Preserve the string matched such that
&quot;${^PREMATCH}&quot;, &quot;${^MATCH}&quot;, and
&quot;${^POSTMATCH}&quot; are available for use after
matching.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In Perl 5.20
and higher this is ignored. Due to a new copy-on-write
mechanism, &quot;${^PREMATCH}&quot;, &quot;${^MATCH}&quot;,
and &quot;${^POSTMATCH}&quot; will be available after the
match regardless of the modifier.</p>

<p style="margin-left:11%;"><b>&quot;a&quot;</b>,
<b>&quot;d&quot;</b>, <b>&quot;l&quot;</b>, and
<b>&quot;u&quot;</b></p>

<p style="margin-left:17%;">These modifiers, all new in
5.14, affect which character-set rules (Unicode,
<i>etc</i>.) are used, as described below in &quot;Character
set modifiers&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>&quot;n&quot;</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>Prevent the grouping metacharacters &quot;()&quot; from
capturing. This modifier, new in 5.22, will stop $1, $2,
<i>etc</i>... from being filled in.</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;hello&quot;
=~ /(hi|hello)/; # $1 is &quot;hello&quot; <br>
&quot;hello&quot; =~ /(hi|hello)/n; # $1 is undef</p>

<p style="margin-left:17%; margin-top: 1em">This is
equivalent to putting &quot;?:&quot; at the beginning of
every capturing group:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;hello&quot;
=~ /(?:hi|hello)/; # $1 is undef</p>

<p style="margin-left:17%; margin-top: 1em">&quot;/n&quot;
can be negated on a per-group basis. Alternatively, named
captures may still be used.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;hello&quot;
=~ /(?&minus;n:(hi|hello))/n; # $1 is &quot;hello&quot; <br>
&quot;hello&quot; =~ /(?&lt;greet&gt;hi|hello)/n; # $1 is
&quot;hello&quot;, $+{greet} is <br>
# &quot;hello&quot;</p>

<p style="margin-left:11%;">Other Modifiers</p>

<p style="margin-left:17%;">There are a number of flags
that can be found at the end of regular expression
constructs that are <i>not</i> generic regular expression
flags, but apply to the operation being performed, like
matching or substitution (&quot;m//&quot; or
&quot;s///&quot; respectively).</p>

<p style="margin-left:17%; margin-top: 1em">Flags described
further in &quot;Using regular expressions in Perl&quot; in
perlretut are:</p>

<p style="margin-left:17%; margin-top: 1em">c &minus; keep
the current position during repeated matching <br>
g &minus; globally match the pattern repeatedly in the
string</p>


<p style="margin-left:17%; margin-top: 1em">Substitution-specific
modifiers described in
&quot;s/PATTERN/REPLACEMENT/msixpodualngcer&quot; in perlop
are:</p>

<p style="margin-left:17%; margin-top: 1em">e &minus;
evaluate the right&minus;hand side as an expression <br>
ee &minus; evaluate the right side as a string then eval the
result <br>
o &minus; pretend to optimize your code, but actually
introduce bugs <br>
r &minus; perform non&minus;destructive substitution and
return the new value</p>

<p style="margin-left:11%; margin-top: 1em">Regular
expression modifiers are usually written in documentation as
<i>e.g.</i>, &quot;the &quot;/x&quot; modifier&quot;, even
though the delimiter in question might not really be a
slash. The modifiers &quot;/imnsxadlup&quot; may also be
embedded within the regular expression itself using the
&quot;(?...)&quot; construct, see &quot;Extended
Patterns&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Details on
some modifiers</i></p>

<p style="margin-left:11%; margin-top: 1em">Some of the
modifiers require more explanation than given in the
&quot;Overview&quot; above.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;/x&quot;
and &quot;/xx&quot;</p>

<p style="margin-left:11%; margin-top: 1em">A single
&quot;/x&quot; tells the regular expression parser to ignore
most whitespace that is neither backslashed nor within a
bracketed character class. You can use this to break up your
regular expression into more readable parts. Also, the
&quot;#&quot; character is treated as a metacharacter
introducing a comment that runs up to the pattern&rsquo;s
closing delimiter, or to the end of the current line if the
pattern extends onto the next line. Hence, this is very much
like an ordinary Perl code comment. (You can include the
closing delimiter within the comment only if you precede it
with a backslash, so be careful!)</p>

<p style="margin-left:11%; margin-top: 1em">Use of
&quot;/x&quot; means that if you want real whitespace or
&quot;#&quot; characters in the pattern (outside a bracketed
character class, which is unaffected by &quot;/x&quot;),
then you&rsquo;ll either have to escape them (using
backslashes or &quot;\Q...\E&quot;) or encode them using
octal, hex, or &quot;\N{}&quot; or &quot;\p{name=...}&quot;
escapes. It is ineffective to try to continue a comment onto
the next line by escaping the &quot;\n&quot; with a
backslash or &quot;\Q&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You can use
&quot;(?#text)&quot; to create a comment that ends earlier
than the end of the current line, but &quot;text&quot; also
can&rsquo;t contain the closing delimiter unless escaped
with a backslash.</p>

<p style="margin-left:11%; margin-top: 1em">A common
pitfall is to forget that &quot;#&quot; characters (outside
a bracketed character class) begin a comment under
&quot;/x&quot; and are not matched literally. Just keep that
in mind when trying to puzzle out why a particular
&quot;/x&quot; pattern isn&rsquo;t working as expected.
Inside a bracketed character class, &quot;#&quot; retains
its non-special, literal meaning.</p>

<p style="margin-left:11%; margin-top: 1em">Starting in
Perl v5.26, if the modifier has a second &quot;x&quot;
within it, the effect of a single &quot;/x&quot; is
increased. The only difference is that inside bracketed
character classes, non-escaped (by a backslash)
<small>SPACE</small> and <small>TAB</small> characters are
not added to the class, and hence can be inserted to make
the classes more readable:</p>

<p style="margin-left:11%; margin-top: 1em">/ [d&minus;e
g&minus;i 3&minus;7]/xx <br>
/[ ! @ &quot; # $ % ^ &amp; * () = ? &lt;&gt; ' ]/xx</p>

<p style="margin-left:11%; margin-top: 1em">may be easier
to grasp than the squashed equivalents</p>


<p style="margin-left:11%; margin-top: 1em">/[d&minus;eg&minus;i3&minus;7]/
<br>
/[!@&quot;#$%^&amp;*()=?&lt;&gt;']/</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
unfortunately doesn&rsquo;t mean that your bracketed classes
can contain comments or extend over multiple lines. A
&quot;#&quot; inside a character class is still just a
literal &quot;#&quot;, and doesn&rsquo;t introduce a
comment. And, unless the closing bracket is on the same line
as the opening one, the newline character (and everything on
the next line(s) until terminated by a &quot;]&quot; will be
part of the class, just as if you&rsquo;d written
&quot;\n&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Taken together,
these features go a long way towards making Perl&rsquo;s
regular expressions more readable. Here&rsquo;s an
example:</p>

<p style="margin-left:11%; margin-top: 1em"># Delete (most)
C comments. <br>
$program =~ s { <br>
/\* # Match the opening delimiter. <br>
.*? # Match a minimal number of characters. <br>
\*/ # Match the closing delimiter. <br>
} []gsx;</p>

<p style="margin-left:11%; margin-top: 1em">Note that
anything inside a &quot;\Q...\E&quot; stays unaffected by
&quot;/x&quot;. And note that &quot;/x&quot; doesn&rsquo;t
affect space interpretation within a single multi-character
construct. For example &quot;(?:...)&quot; can&rsquo;t have
a space between the &quot;(&quot;, &quot;?&quot;, and
&quot;:&quot;. Within any delimiters for such a construct,
allowed spaces are not affected by &quot;/x&quot;, and
depend on the construct. For example, all constructs using
curly braces as delimiters, such as &quot;\x{...}&quot; can
have blanks within but adjacent to the braces, but not
elsewhere, and no non-blank space characters. An exception
are Unicode properties which follow Unicode rules, for which
see &quot;Properties accessible through \p{} and \P{}&quot;
in perluniprops.</p>

<p style="margin-left:11%; margin-top: 1em">The set of
characters that are deemed whitespace are those that Unicode
calls &quot;Pattern White Space&quot;, namely:</p>

<p style="margin-left:11%; margin-top: 1em">U+0009
CHARACTER TABULATION <br>
U+000A LINE FEED <br>
U+000B LINE TABULATION <br>
U+000C FORM FEED <br>
U+000D CARRIAGE RETURN <br>
U+0020 SPACE <br>
U+0085 NEXT LINE <br>
U+200E LEFT&minus;TO&minus;RIGHT MARK <br>
U+200F RIGHT&minus;TO&minus;LEFT MARK <br>
U+2028 LINE SEPARATOR <br>
U+2029 PARAGRAPH SEPARATOR</p>

<p style="margin-left:11%; margin-top: 1em">Character set
modifiers</p>


<p style="margin-left:11%; margin-top: 1em">&quot;/d&quot;,
&quot;/u&quot;, &quot;/a&quot;, and &quot;/l&quot;,
available starting in 5.14, are called the character set
modifiers; they affect the character set rules used for the
regular expression.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;/d&quot;, &quot;/u&quot;, and &quot;/l&quot; modifiers
are not likely to be of much use to you, and so you need not
worry about them very much. They exist for Perl&rsquo;s
internal use, so that complex regular expression data
structures can be automatically serialized and later exactly
reconstituted, including all their nuances. But, since Perl
can&rsquo;t keep a secret, and there may be rare instances
where they are useful, they are documented here.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;/a&quot; modifier, on the other hand, may be useful.
Its purpose is to allow code that is to work mostly on
<small>ASCII</small> data to not have to concern itself with
Unicode.</p>

<p style="margin-left:11%; margin-top: 1em">Briefly,
&quot;/l&quot; sets the character set to that of whatever
<b>L</b>ocale is in effect at the time of the execution of
the pattern match.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;/u&quot;
sets the character set to <b>U</b>nicode.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;/a&quot;
also sets the character set to Unicode, <small>BUT</small>
adds several restrictions for <b>A</b>SCII-safe
matching.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;/d&quot;
is the old, problematic, pre&minus;5.14 <b>D</b>efault
character set behavior. Its only use is to force that old
behavior.</p>

<p style="margin-left:11%; margin-top: 1em">At any given
time, exactly one of these modifiers is in effect. Their
existence allows Perl to keep the originally compiled
behavior of a regular expression, regardless of what rules
are in effect when it is actually executed. And if it is
interpolated into a larger regex, the original&rsquo;s rules
continue to apply to it, and don&rsquo;t affect the other
parts.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;/l&quot; and &quot;/u&quot; modifiers are
automatically selected for regular expressions compiled
within the scope of various pragmas, and we recommend that
in general, you use those pragmas instead of specifying
these modifiers explicitly. For one thing, the modifiers
affect only pattern matching, and do not extend to even any
replacement done, whereas using the pragmas gives consistent
results for all appropriate operations within their scopes.
For example,</p>


<p style="margin-left:11%; margin-top: 1em">s/foo/\Ubar/il</p>

<p style="margin-left:11%; margin-top: 1em">will match
&quot;foo&quot; using the locale&rsquo;s rules for
case-insensitive matching, but the &quot;/l&quot; does not
affect how the &quot;\U&quot; operates. Most likely you want
both of them to use locale rules. To do this, instead
compile the regular expression within the scope of &quot;use
locale&quot;. This both implicitly adds the &quot;/l&quot;,
and applies locale rules to the &quot;\U&quot;. The lesson
is to &quot;use locale&quot;, and not &quot;/l&quot;
explicitly.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, it
would be better to use &quot;use feature
'unicode_strings'&quot; instead of,</p>


<p style="margin-left:11%; margin-top: 1em">s/foo/\Lbar/iu</p>

<p style="margin-left:11%; margin-top: 1em">to get Unicode
rules, as the &quot;\L&quot; in the former (but not
necessarily the latter) would also use Unicode rules.</p>

<p style="margin-left:11%; margin-top: 1em">More detail on
each of the modifiers follows. Most likely you don&rsquo;t
need to know this detail for &quot;/l&quot;, &quot;/u&quot;,
and &quot;/d&quot;, and can skip ahead to /a.</p>

<p style="margin-left:11%; margin-top: 1em">/l</p>

<p style="margin-left:11%; margin-top: 1em">means to use
the current locale&rsquo;s rules (see perllocale) when
pattern matching. For example, &quot;\w&quot; will match the
&quot;word&quot; characters of that locale, and
&quot;/i&quot; case-insensitive matching will match
according to the locale&rsquo;s case folding rules. The
locale used will be the one in effect at the time of
execution of the pattern match. This may not be the same as
the compilation-time locale, and can differ from one match
to another if there is an intervening call of the
<b>setlocale()</b> function.</p>

<p style="margin-left:11%; margin-top: 1em">Prior to v5.20,
Perl did not support multi-byte locales. Starting then,
<small>UTF&minus;8</small> locales are supported. No other
multi byte locales are ever likely to be supported. However,
in all locales, one can have code points above 255 and these
will always be treated as Unicode no matter what locale is
in effect.</p>

<p style="margin-left:11%; margin-top: 1em">Under Unicode
rules, there are a few case-insensitive matches that cross
the 255/256 boundary. Except for <small>UTF&minus;8</small>
locales in Perls v5.20 and later, these are disallowed under
&quot;/l&quot;. For example, 0xFF (on <small>ASCII</small>
platforms) does not caselessly match the character at 0x178,
&quot;LATIN CAPITAL LETTER Y WITH DIAERESIS&quot;, because
0xFF may not be &quot;LATIN SMALL LETTER Y WITH
DIAERESIS&quot; in the current locale, and Perl has no way
of knowing if that character even exists in the locale, much
less what code point it is.</p>

<p style="margin-left:11%; margin-top: 1em">In a
<small>UTF&minus;8</small> locale in v5.20 and later, the
only visible difference between locale and non-locale in
regular expressions should be tainting, if your perl
supports taint checking (see perlsec).</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
may be specified to be the default by &quot;use
locale&quot;, but see &quot;Which character set modifier is
in effect?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">/u</p>

<p style="margin-left:11%; margin-top: 1em">means to use
Unicode rules when pattern matching. On <small>ASCII</small>
platforms, this means that the code points between 128 and
255 take on their Latin&minus;1 (
<small>ISO&minus;8859&minus;1</small> ) meanings (which are
the same as Unicode&rsquo;s). (Otherwise Perl considers
their meanings to be undefined.) Thus, under this modifier,
the <small>ASCII</small> platform effectively becomes a
Unicode platform; and hence, for example, &quot;\w&quot;
will match any of the more than 100_000 word characters in
Unicode.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike most
locales, which are specific to a language and country pair,
Unicode classifies all the characters that are letters
<i>somewhere</i> in the world as &quot;\w&quot;. For
example, your locale might not think that &quot;LATIN SMALL
LETTER ETH&quot; is a letter (unless you happen to speak
Icelandic), but Unicode does. Similarly, all the characters
that are decimal digits somewhere in the world will match
&quot;\d&quot;; this is hundreds, not 10, possible matches.
And some of those digits look like some of the 10
<small>ASCII</small> digits, but mean a different number, so
a human could easily think a number is a different quantity
than it really is. For example, &quot;BENGALI DIGIT
FOUR&quot; (U+09EA) looks very much like an &quot;ASCII
DIGIT EIGHT&quot; (U+0038), and &quot;LEPCHA DIGIT SIX&quot;
(U+1C46) looks very much like an &quot;ASCII DIGIT
FIVE&quot; (U+0035). And, &quot;\d+&quot;, may match strings
of digits that are a mixture from different writing systems,
creating a security issue. A fraudulent website, for
example, could display the price of something using U+1C46,
and it would appear to the user that something cost 500
units, but it really costs 600. A browser that enforced
script runs (&quot;Script Runs&quot;) would prevent that
fraudulent display. &quot;<b>num()</b>&quot; in Unicode::UCD
can also be used to sort this out. Or the &quot;/a&quot;
modifier can be used to force &quot;\d&quot; to match just
the <small>ASCII 0</small> through 9.</p>

<p style="margin-left:11%; margin-top: 1em">Also, under
this modifier, case-insensitive matching works on the full
set of Unicode characters. The &quot;KELVIN SIGN&quot;, for
example matches the letters &quot;k&quot; and &quot;K&quot;;
and &quot;LATIN SMALL LIGATURE FF&quot; matches the sequence
&quot;ff&quot;, which, if you&rsquo;re not prepared, might
make it look like a hexadecimal constant, presenting another
potential security issue. See
&lt;https://unicode.org/reports/tr36&gt; for a detailed
discussion of Unicode security issues.</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
may be specified to be the default by &quot;use feature
'unicode_strings&quot;, &quot;use locale
':not_characters'&quot;, or &quot;use v5.12&quot; (or
higher), but see &quot;Which character set modifier is in
effect?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">/d</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>IMPORTANT:</small></b>
Because of the unpredictable behaviors this modifier causes,
only use it to maintain weird backward compatibilities. Use
the &quot;unicode_strings&quot; feature in new code to avoid
inadvertently enabling this modifier by default.</p>

<p style="margin-left:11%; margin-top: 1em">What does this
modifier do? It &quot;Depends&quot;!</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
means to use platform-native matching rules except when
there is cause to use Unicode rules instead, as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the target string&rsquo;s <small>UTF8</small> flag (see
below) is set; or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern&rsquo;s <small>UTF8</small> flag (see below)
is set; or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern explicitly mentions a code point that is
above 255 (say by &quot;\x{100}&quot;); or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern uses a Unicode name (&quot;\N{...}&quot;);
or</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern uses a Unicode property (&quot;\p{...}&quot;
or &quot;\P{...}&quot;); or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern uses a Unicode break (&quot;\b{...}&quot; or
&quot;\B{...}&quot;); or</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>7.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern uses &quot;(?[ ])&quot;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>8.</p></td>
<td width="3%"></td>
<td width="83%">


<p>the pattern uses &quot;(*script_run: ...)&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Regarding the
&quot; <small>UTF8</small> flag&quot; references above:
normally Perl applications shouldn&rsquo;t think about that
flag. It&rsquo;s part of Perl&rsquo;s internals, so it can
change whenever Perl wants. &quot;/d&quot; may thus cause
unpredictable results. See &quot;The &quot;Unicode
Bug&quot;&quot; in perlunicode. This bug has become rather
infamous, leading to yet other (without swearing) names for
this modifier like &quot;Dicey&quot; and
&quot;Dodgy&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Here are some
examples of how that works on an <small>ASCII</small>
platform:</p>

<p style="margin-left:11%; margin-top: 1em">$str =
&quot;\xDF&quot;; # <br>
utf8::downgrade($str); # $str is not UTF8&minus;flagged.
<br>
$str =~ /^\w/; # No match, since no UTF8 flag. <br>
$str .= &quot;\x{0e0b}&quot;; # Now $str is
UTF8&minus;flagged. <br>
$str =~ /^\w/; # Match! $str is now UTF8&minus;flagged. <br>
chop $str; <br>
$str =~ /^\w/; # Still a match! $str retains its UTF8
flag.</p>

<p style="margin-left:11%; margin-top: 1em">Under
Perl&rsquo;s default configuration this modifier is
automatically selected by default when none of the others
are, so yet another name for it (unfortunately) is
&quot;Default&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Whenever you
can, use the &quot;unicode_strings&quot; to cause to be the
default instead.</p>

<p style="margin-left:11%; margin-top: 1em">/a (and
/aa)</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
stands for ASCII-restrict (or ASCII-safe). This modifier may
be doubled-up to increase its effect.</p>

<p style="margin-left:11%; margin-top: 1em">When it appears
singly, it causes the sequences &quot;\d&quot;,
&quot;\s&quot;, &quot;\w&quot;, and the Posix character
classes to match only in the <small>ASCII</small> range.
They thus revert to their pre&minus;5.6, pre-Unicode
meanings. Under &quot;/a&quot;, &quot;\d&quot; always means
precisely the digits &quot;0&quot; to &quot;9&quot;;
&quot;\s&quot; means the five characters &quot;[
\f\n\r\t]&quot;, and starting in Perl v5.18, the vertical
tab; &quot;\w&quot; means the 63 characters
&quot;[A&minus;Za&minus;z0&minus;9_]&quot;; and likewise,
all the Posix classes such as &quot;[[:print:]]&quot; match
only the appropriate ASCII-range characters.</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
is useful for people who only incidentally use Unicode, and
who do not wish to be burdened with its complexities and
security concerns.</p>

<p style="margin-left:11%; margin-top: 1em">With
&quot;/a&quot;, one can write &quot;\d&quot; with confidence
that it will only match <small>ASCII</small> characters, and
should the need arise to match beyond <small>ASCII,</small>
you can instead use &quot;\p{Digit}&quot; (or
&quot;\p{Word}&quot; for &quot;\w&quot;). There are similar
&quot;\p{...}&quot; constructs that can match beyond
<small>ASCII</small> both white space (see
&quot;Whitespace&quot; in perlrecharclass), and Posix
classes (see &quot; <small>POSIX</small> Character
Classes&quot; in perlrecharclass). Thus, this modifier
doesn&rsquo;t mean you can&rsquo;t use Unicode, it means
that to get Unicode matching you must explicitly use a
construct (&quot;\p{}&quot;, &quot;\P{}&quot;) that signals
Unicode.</p>

<p style="margin-left:11%; margin-top: 1em">As you would
expect, this modifier causes, for example, &quot;\D&quot; to
mean the same thing as &quot;[^0&minus;9]&quot;; in fact,
all non-ASCII characters match &quot;\D&quot;,
&quot;\S&quot;, and &quot;\W&quot;. &quot;\b&quot; still
means to match at the boundary between &quot;\w&quot; and
&quot;\W&quot;, using the &quot;/a&quot; definitions of them
(similarly for &quot;\B&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise,
&quot;/a&quot; behaves like the &quot;/u&quot; modifier, in
that case-insensitive matching uses Unicode rules; for
example, &quot;k&quot; will match the Unicode
&quot;\N{KELVIN SIGN}&quot; under &quot;/i&quot; matching,
and code points in the Latin1 range, above
<small>ASCII</small> will have Unicode rules when it comes
to case-insensitive matching.</p>

<p style="margin-left:11%; margin-top: 1em">To forbid
ASCII/non&minus;ASCII matches (like &quot;k&quot; with
&quot;\N{KELVIN SIGN}&quot;), specify the &quot;a&quot;
twice, for example &quot;/aai&quot; or &quot;/aia&quot;.
(The first occurrence of &quot;a&quot; restricts the
&quot;\d&quot;, <i>etc</i>., and the second occurrence adds
the &quot;/i&quot; restrictions.) But, note that code points
outside the <small>ASCII</small> range will use Unicode
rules for &quot;/i&quot; matching, so the modifier
doesn&rsquo;t really restrict things to just
<small>ASCII</small> ; it just forbids the intermixing of
<small>ASCII</small> and non-ASCII.</p>

<p style="margin-left:11%; margin-top: 1em">To summarize,
this modifier provides protection for applications that
don&rsquo;t wish to be exposed to all of Unicode. Specifying
it twice gives added protection.</p>

<p style="margin-left:11%; margin-top: 1em">This modifier
may be specified to be the default by &quot;use re
'/a'&quot; or &quot;use re '/aa'&quot;. If you do so, you
may actually have occasion to use the &quot;/u&quot;
modifier explicitly if there are a few regular expressions
where you do want full Unicode rules (but even here,
it&rsquo;s best if everything were under feature
&quot;unicode_strings&quot;, along with the &quot;use re
'/aa'&quot;). Also see &quot;Which character set modifier is
in effect?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Which character
set modifier is in effect?</p>

<p style="margin-left:11%; margin-top: 1em">Which of these
modifiers is in effect at any given point in a regular
expression depends on a fairly complex set of interactions.
These have been designed so that in general you don&rsquo;t
have to worry about it, but this section gives the gory
details. As explained below in &quot;Extended Patterns&quot;
it is possible to explicitly specify modifiers that apply
only to portions of a regular expression. The innermost
always has priority over any outer ones, and one applying to
the whole expression has priority over any of the default
settings that are described in the remainder of this
section.</p>

<p style="margin-left:11%; margin-top: 1em">The &quot;use
re '/foo'&quot; pragma can be used to set default modifiers
(including these) for regular expressions compiled within
its scope. This pragma has precedence over the other pragmas
listed below that also change the defaults.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise,
&quot;use locale&quot; sets the default modifier to
&quot;/l&quot;; and &quot;use feature
'unicode_strings&quot;, or &quot;use v5.12&quot; (or higher)
set the default to &quot;/u&quot; when not in the same scope
as either &quot;use locale&quot; or &quot;use bytes&quot;.
(&quot;use locale ':not_characters'&quot; also sets the
default to &quot;/u&quot;, overriding any plain &quot;use
locale&quot;.) Unlike the mechanisms mentioned above, these
affect operations besides regular expressions pattern
matching, and so give more consistent results with other
operators, including using &quot;\U&quot;, &quot;\l&quot;,
<i>etc</i>. in substitution replacements.</p>

<p style="margin-left:11%; margin-top: 1em">If none of the
above apply, for backwards compatibility reasons, the
&quot;/d&quot; modifier is the one in effect by default. As
this can lead to unexpected results, it is best to specify
which other rule set should be used.</p>

<p style="margin-left:11%; margin-top: 1em">Character set
modifier behavior prior to Perl 5.14</p>

<p style="margin-left:11%; margin-top: 1em">Prior to 5.14,
there were no explicit modifiers, but &quot;/l&quot; was
implied for regexes compiled within the scope of &quot;use
locale&quot;, and &quot;/d&quot; was implied otherwise.
However, interpolating a regex into a larger regex would
ignore the original compilation in favor of whatever was in
effect at the time of the second compilation. There were a
number of inconsistencies (bugs) with the &quot;/d&quot;
modifier, where Unicode rules would be used when
inappropriate, and vice versa. &quot;\p{}&quot; did not
imply Unicode rules, and neither did all occurrences of
&quot;\N{}&quot;, until 5.12.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Regular
Expressions</b> <i><br>
Quantifiers</i></p>

<p style="margin-left:11%; margin-top: 1em">Quantifiers are
used when a particular portion of a pattern needs to match a
certain number (or numbers) of times. If there isn&rsquo;t a
quantifier the number of times to match is exactly one. The
following standard quantifiers are recognized:</p>

<p style="margin-left:11%; margin-top: 1em">* Match 0 or
more times <br>
+ Match 1 or more times <br>
? Match 1 or 0 times <br>
{n} Match exactly n times <br>
{n,} Match at least n times <br>
{,n} Match at most n times <br>
{n,m} Match at least n but not more than m times</p>

<p style="margin-left:11%; margin-top: 1em">(If a
non-escaped curly bracket occurs in a context other than one
of the quantifiers listed above, where it does not form part
of a backslashed sequence like &quot;\x{...}&quot;, it is
either a fatal syntax error, or treated as a regular
character, generally with a deprecation warning raised. To
escape it, you can precede it with a backslash
(&quot;\{&quot;) or enclose it within square brackets
(&quot;[{]&quot;). This change will allow for future syntax
extensions (like making the lower bound of a quantifier
optional), and better error checking of quantifiers).</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;*&quot; quantifier is equivalent to &quot;{0,}&quot;,
the &quot;+&quot; quantifier to &quot;{1,}&quot;, and the
&quot;?&quot; quantifier to &quot;{0,1}&quot;. <i>n</i> and
<i>m</i> are limited to non-negative integral values less
than a preset limit defined when perl is built. This is
usually 65534 on the most common platforms. The actual limit
can be seen in the error message generated by code such as
this:</p>

<p style="margin-left:11%; margin-top: 1em">$_ **= $_ , /
{$_} / for 2 .. 42;</p>

<p style="margin-left:11%; margin-top: 1em">By default, a
quantified subpattern is &quot;greedy&quot;, that is, it
will match as many times as possible (given a particular
starting location) while still allowing the rest of the
pattern to match. If you want it to match the minimum number
of times possible, follow the quantifier with a
&quot;?&quot;. Note that the meanings don&rsquo;t change,
just the &quot;greediness&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">*? Match 0 or
more times, not greedily <br>
+? Match 1 or more times, not greedily <br>
?? Match 0 or 1 time, not greedily <br>
{n}? Match exactly n times, not greedily (redundant) <br>
{n,}? Match at least n times, not greedily <br>
{,n}? Match at most n times, not greedily <br>
{n,m}? Match at least n but not more than m times, not
greedily</p>

<p style="margin-left:11%; margin-top: 1em">Normally when a
quantified subpattern does not allow the rest of the overall
pattern to match, Perl will backtrack. However, this
behaviour is sometimes undesirable. Thus Perl provides the
&quot;possessive&quot; quantifier form as well.</p>

<p style="margin-left:11%; margin-top: 1em">*+ Match 0 or
more times and give nothing back <br>
++ Match 1 or more times and give nothing back <br>
?+ Match 0 or 1 time and give nothing back <br>
{n}+ Match exactly n times and give nothing back (redundant)
<br>
{n,}+ Match at least n times and give nothing back <br>
{,n}+ Match at most n times and give nothing back <br>
{n,m}+ Match at least n but not more than m times and give
nothing back</p>

<p style="margin-left:11%; margin-top: 1em">For
instance,</p>

<p style="margin-left:11%; margin-top: 1em">'aaaa' =~
/a++a/</p>

<p style="margin-left:11%; margin-top: 1em">will never
match, as the &quot;a++&quot; will gobble up all the
&quot;a&quot;&rsquo;s in the string and won&rsquo;t leave
any for the remaining part of the pattern. This feature can
be extremely useful to give perl hints about where it
shouldn&rsquo;t backtrack. For instance, the typical
&quot;match a double-quoted string&quot; problem can be most
efficiently performed when written as:</p>


<p style="margin-left:11%; margin-top: 1em">/&quot;(?:[^&quot;\\]++|\\.)*+&quot;/</p>

<p style="margin-left:11%; margin-top: 1em">as we know that
if the final quote does not match, backtracking will not
help. See the independent subexpression
&quot;(?&gt;<i>pattern</i>)&quot; for more details;
possessive quantifiers are just syntactic sugar for that
construct. For instance the above example could also be
written as follows:</p>


<p style="margin-left:11%; margin-top: 1em">/&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
possessive quantifier modifier can not be combined with the
non-greedy modifier. This is because it would make no sense.
Consider the follow equivalency table:</p>

<p style="margin-left:11%; margin-top: 1em">Illegal Legal
<br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus;&minus; <br>
X??+ X{0} <br>
X+?+ X{1} <br>
X{min,max}?+ X{min}</p>

<p style="margin-left:11%; margin-top: 1em"><i>Escape
sequences</i></p>

<p style="margin-left:11%; margin-top: 1em">Because
patterns are processed as double-quoted strings, the
following also work:</p>

<p style="margin-left:11%; margin-top: 1em">\t tab (HT,
TAB) <br>
\n newline (LF, NL) <br>
\r return (CR) <br>
\f form feed (FF) <br>
\a alarm (bell) (BEL) <br>
\e escape (think troff) (ESC) <br>
\cK control char (example: VT) <br>
\x{}, \x00 character whose ordinal is the given hexadecimal
number <br>
\N{name} named Unicode character or character sequence <br>
\N{U+263D} Unicode character (example: FIRST QUARTER MOON)
<br>
\o{}, \000 character whose ordinal is the given octal number
<br>
\l lowercase next char (think vi) <br>
\u uppercase next char (think vi) <br>
\L lowercase until \E (think vi) <br>
\U uppercase until \E (think vi) <br>
\Q quote (disable) pattern metacharacters until \E <br>
\E end either case modification or quoted section, think
vi</p>

<p style="margin-left:11%; margin-top: 1em">Details are in
&quot;Quote and Quote-like Operators&quot; in perlop.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Character
Classes and other Special Escapes</i></p>

<p style="margin-left:11%; margin-top: 1em">In addition,
Perl defines the following:</p>

<p style="margin-left:11%; margin-top: 1em">Sequence Note
Description <br>
[...] [1] Match a character according to the rules of the
<br>
bracketed character class defined by the &quot;...&quot;.
<br>
Example: [a&minus;z] matches &quot;a&quot; or &quot;b&quot;
or &quot;c&quot; ... or &quot;z&quot; <br>
[[:...:]] [2] Match a character according to the rules of
the POSIX <br>
character class &quot;...&quot; within the outer bracketed
<br>
character class. Example: [[:upper:]] matches any <br>
uppercase character. <br>
(?[...]) [8] Extended bracketed character class <br>
\w [3] Match a &quot;word&quot; character (alphanumeric plus
&quot;_&quot;, plus <br>
other connector punctuation chars plus Unicode <br>
marks) <br>
\W [3] Match a non&minus;&quot;word&quot; character <br>
\s [3] Match a whitespace character <br>
\S [3] Match a non&minus;whitespace character <br>
\d [3] Match a decimal digit character <br>
\D [3] Match a non&minus;digit character <br>
\pP [3] Match P, named property. Use \p{Prop} for longer
names <br>
\PP [3] Match non&minus;P <br>
\X [4] Match Unicode &quot;eXtended grapheme cluster&quot;
<br>
\1 [5] Backreference to a specific capture group or buffer.
<br>
'1' may actually be any positive integer. <br>
\g1 [5] Backreference to a specific or previous group, <br>
\g{&minus;1} [5] The number may be negative indicating a
relative <br>
previous group and may optionally be wrapped in <br>
curly brackets for safer parsing. <br>
\g{name} [5] Named backreference <br>
\k&lt;name&gt; [5] Named backreference <br>
\k'name' [5] Named backreference <br>
\k{name} [5] Named backreference <br>
\K [6] Keep the stuff left of the \K, don't include it in
$&amp; <br>
\N [7] Any character but \n. Not affected by /s modifier
<br>
\v [3] Vertical whitespace <br>
\V [3] Not vertical whitespace <br>
\h [3] Horizontal whitespace <br>
\H [3] Not horizontal whitespace <br>
\R [4] Linebreak</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">See &quot;Bracketed Character
Classes&quot; in perlrecharclass for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot; <small>POSIX</small> Character Classes&quot;
in perlrecharclass for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[3]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Unicode Character Properties&quot; in
perlunicode for details</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[4]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Misc&quot; in perlrebackslash for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[5]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Capture groups&quot; below for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[6]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Extended Patterns&quot; below for details.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[7]</p></td>
<td width="2%"></td>
<td width="83%">


<p>Note that &quot;\N&quot; has two meanings. When of the
form &quot;\N{<i>NAME</i>}&quot;, it matches the character
or character sequence whose name is
<i><small>NAME</small></i> ; and similarly when of the form
&quot;\N{U+<i>hex</i>}&quot;, it matches the character whose
Unicode code point is <i>hex</i>. Otherwise it matches any
character but &quot;\n&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[8]</p></td>
<td width="2%"></td>
<td width="83%">


<p>See &quot;Extended Bracketed Character Classes&quot; in
perlrecharclass for details.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><i>Assertions</i></p>

<p style="margin-left:11%; margin-top: 1em">Besides
&quot;^&quot; and &quot;$&quot;, Perl defines the following
zero-width assertions:</p>

<p style="margin-left:11%; margin-top: 1em">\b{} Match at
Unicode boundary of specified type <br>
\B{} Match where corresponding \b{} doesn't match <br>
\b Match a \w\W or \W\w boundary <br>
\B Match except at a \w\W or \W\w boundary <br>
\A Match only at beginning of string <br>
\Z Match only at end of string, or before newline at the end
<br>
\z Match only at end of string <br>
\G Match only at pos() (e.g. at the end&minus;of&minus;match
position <br>
of prior m//g)</p>

<p style="margin-left:11%; margin-top: 1em">A Unicode
boundary (&quot;\b{}&quot;), available starting in v5.22, is
a spot between two characters, or before the first character
in the string, or after the final character in the string
where certain criteria defined by Unicode are met. See
&quot;\b{}, \b, \B{}, \B&quot; in perlrebackslash for
details.</p>

<p style="margin-left:11%; margin-top: 1em">A word boundary
(&quot;\b&quot;) is a spot between two characters that has a
&quot;\w&quot; on one side of it and a &quot;\W&quot; on the
other side of it (in either order), counting the imaginary
characters off the beginning and end of the string as
matching a &quot;\W&quot;. (Within character classes
&quot;\b&quot; represents backspace rather than a word
boundary, just as it normally does in any double-quoted
string.) The &quot;\A&quot; and &quot;\Z&quot; are just like
&quot;^&quot; and &quot;$&quot;, except that they
won&rsquo;t match multiple times when the &quot;/m&quot;
modifier is used, while &quot;^&quot; and &quot;$&quot; will
match at every internal line boundary. To match the actual
end of the string and not ignore an optional trailing
newline, use &quot;\z&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;\G&quot; assertion can be used to chain global matches
(using &quot;m//g&quot;), as described in &quot;Regexp
Quote-Like Operators&quot; in perlop. It is also useful when
writing &quot;lex&quot;&minus;like scanners, when you have
several patterns that you want to match against consequent
substrings of your string; see the previous reference. The
actual location where &quot;\G&quot; will match can also be
influenced by using &quot;pos()&quot; as an lvalue: see
&quot;pos&quot; in perlfunc. Note that the rule for
zero-length matches (see &quot;Repeated Patterns Matching a
Zero-length Substring&quot;) is modified somewhat, in that
contents to the left of &quot;\G&quot; are not counted when
determining the length of the match. Thus the following will
not match forever:</p>

<p style="margin-left:11%; margin-top: 1em">my $string =
'ABC'; <br>
pos($string) = 1; <br>
while ($string =~ /(.\G)/g) { <br>
print $1; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">It will print
&rsquo;A&rsquo; and then terminate, as it considers the
match to be zero-width, and thus will not match at the same
position twice in a row.</p>

<p style="margin-left:11%; margin-top: 1em">It is worth
noting that &quot;\G&quot; improperly used can result in an
infinite loop. Take care when using patterns that include
&quot;\G&quot; in an alternation.</p>

<p style="margin-left:11%; margin-top: 1em">Note also that
&quot;s///&quot; will refuse to overwrite part of a
substitution that has already been replaced; so for example
this will stop after the first iteration, rather than
iterating its way backwards through the string:</p>

<p style="margin-left:11%; margin-top: 1em">$_ =
&quot;123456789&quot;; <br>
pos = 6; <br>
s/.(?=.\G)/X/g; <br>
print; # prints 1234X6789, not XXXXX6789</p>

<p style="margin-left:11%; margin-top: 1em"><i>Capture
groups</i></p>

<p style="margin-left:11%; margin-top: 1em">The grouping
construct &quot;( ... )&quot; creates capture groups (also
referred to as capture buffers). To refer to the current
contents of a group later on, within the same pattern, use
&quot;\g1&quot; (or &quot;\g{1}&quot;) for the first,
&quot;\g2&quot; (or &quot;\g{2}&quot;) for the second, and
so on. This is called a <i>backreference</i>.</p>

<p style="margin-left:11%; margin-top: 1em">There is no
limit to the number of captured substrings that you may use.
Groups are numbered with the leftmost open parenthesis being
number 1, <i>etc</i>. If a group did not match, the
associated backreference won&rsquo;t match either. (This can
happen if the group is optional, or in a different branch of
an alternation.) You can omit the &quot;g&quot;, and write
&quot;\1&quot;, <i>etc</i>, but there are some issues with
this form, described below.</p>

<p style="margin-left:11%; margin-top: 1em">You can also
refer to capture groups relatively, by using a negative
number, so that &quot;\g&minus;1&quot; and
&quot;\g{&minus;1}&quot; both refer to the immediately
preceding capture group, and &quot;\g&minus;2&quot; and
&quot;\g{&minus;2}&quot; both refer to the group before it.
For example:</p>

<p style="margin-left:11%; margin-top: 1em">/ <br>
(Y) # group 1 <br>
( # group 2 <br>
(X) # group 3 <br>
\g{&minus;1} # backref to group 3 <br>
\g{&minus;3} # backref to group 1 <br>
) <br>
/x</p>

<p style="margin-left:11%; margin-top: 1em">would match the
same as &quot;/(Y) ( (X) \g3 \g1 )/x&quot;. This allows you
to interpolate regexes into larger regexes and not have to
worry about the capture groups being renumbered.</p>

<p style="margin-left:11%; margin-top: 1em">You can
dispense with numbers altogether and create named capture
groups. The notation is
&quot;(?&lt;<i>name</i>&gt;...)&quot; to declare and
&quot;\g{<i>name</i>}&quot; to reference. (To be compatible
with .Net regular expressions, &quot;\g{<i>name</i>}&quot;
may also be written as &quot;\k{<i>name</i>}&quot;,
&quot;\k&lt;<i>name</i>&gt;&quot; or
&quot;\k'<i>name</i>'&quot;.) <i>name</i> must not begin
with a number, nor contain hyphens. When different groups
within the same pattern have the same name, any reference to
that name assumes the leftmost defined group. Named groups
count in absolute and relative numbering, and so can also be
referred to by those numbers. (It&rsquo;s possible to do
things with named capture groups that would otherwise
require &quot;(??{})&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">Capture group
contents are dynamically scoped and available to you outside
the pattern until the end of the enclosing block or until
the next successful match, whichever comes first. (See
&quot;Compound Statements&quot; in perlsyn.) You can refer
to them by absolute number (using &quot;$1&quot; instead of
&quot;\g1&quot;, <i>etc</i>); or by name via the
&quot;%+&quot; hash, using &quot;$+{<i>name</i>}&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Braces are
required in referring to named capture groups, but are
optional for absolute or relative numbered ones. Braces are
safer when creating a regex by concatenating smaller
strings. For example if you have &quot;qr/$a$b/&quot;, and
$a contained &quot;\g1&quot;, and $b contained
&quot;37&quot;, you would get &quot;/\g137/&quot; which is
probably not what you intended.</p>

<p style="margin-left:11%; margin-top: 1em">If you use
braces, you may also optionally add any number of blank
(space or tab) characters within but adjacent to the braces,
like &quot;\g{&nbsp;&minus;1&nbsp;}&quot;, or
&quot;\k{&nbsp;<i>name&nbsp;</i>}&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;\g&quot; and &quot;\k&quot; notations were introduced
in Perl 5.10.0. Prior to that there were no named nor
relative numbered capture groups. Absolute numbered groups
were referred to using &quot;\1&quot;, &quot;\2&quot;,
<i>etc</i>., and this notation is still accepted (and likely
always will be). But it leads to some ambiguities if there
are more than 9 capture groups, as &quot;\10&quot; could
mean either the tenth capture group, or the character whose
ordinal in octal is 010 (a backspace in <small>ASCII</small>
). Perl resolves this ambiguity by interpreting
&quot;\10&quot; as a backreference only if at least 10 left
parentheses have opened before it. Likewise &quot;\11&quot;
is a backreference only if at least 11 left parentheses have
opened before it. And so on. &quot;\1&quot; through
&quot;\9&quot; are always interpreted as backreferences.
There are several examples below that illustrate these
perils. You can avoid the ambiguity by always using
&quot;\g{}&quot; or &quot;\g&quot; if you mean capturing
groups; and for octal constants always using
&quot;\o{}&quot;, or for &quot;\077&quot; and below, using 3
digits padded with leading zeros, since a leading zero
implies an octal constant.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;\<i>digit</i>&quot; notation also works in certain
circumstances outside the pattern. See &quot;Warning on \1
Instead of $1&quot; below for details.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">s/^([^ ]*) *([^
]*)/$2 $1/; # swap first two words <br>
/(.)\g1/ # find first doubled char <br>
and print &quot;'$1' is the first doubled character\n&quot;;
<br>
/(?&lt;char&gt;.)\k&lt;char&gt;/ # ... a different way <br>
and print &quot;'$+{char}' is the first doubled
character\n&quot;; <br>
/(?'char'.)\g1/ # ... mix and match <br>
and print &quot;'$1' is the first doubled character\n&quot;;
<br>
if (/Time: (..):(..):(..)/) { # parse out values <br>
$hours = $1; <br>
$minutes = $2; <br>
$seconds = $3; <br>
} <br>
/(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/ # \g10 is a backreference
<br>
/(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/ # \10 is octal <br>
/((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/ # \10 is a backreference
<br>
/((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 is octal <br>
$a = '(.)\1'; # Creates problems when concatenated. <br>
$b = '(.)\g{1}'; # Avoids the problems. <br>
&quot;aa&quot; =~ /${a}/; # True <br>
&quot;aa&quot; =~ /${b}/; # True <br>
&quot;aa0&quot; =~ /${a}0/; # False! <br>
&quot;aa0&quot; =~ /${b}0/; # True <br>
&quot;aa\x08&quot; =~ /${a}0/; # True! <br>
&quot;aa\x08&quot; =~ /${b}0/; # False</p>

<p style="margin-left:11%; margin-top: 1em">Several special
variables also refer back to portions of the previous match.
$+ returns whatever the last bracket match matched. $&amp;
returns the entire matched string. (At one point $0 did
also, but now it returns the name of the program.)
&quot;$`&quot; returns everything before the matched string.
&quot;$'&quot; returns everything after the matched string.
And $^N contains whatever was matched by the most-recently
closed group (submatch). $^N can be used in extended
patterns (see below), for example to assign a submatch to a
variable.</p>

<p style="margin-left:11%; margin-top: 1em">These special
variables, like the &quot;%+&quot; hash and the numbered
match variables ($1, $2, $3, <i>etc</i>.) are dynamically
scoped until the end of the enclosing block or until the
next successful match, whichever comes first. (See
&quot;Compound Statements&quot; in perlsyn.)</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;@{^CAPTURE}&quot; array may be used to access
<small>ALL</small> of the capture buffers as an array
without needing to know how many there are. For instance</p>


<p style="margin-left:11%; margin-top: 1em">$string=~/$pattern/
and @captured = @{^CAPTURE};</p>

<p style="margin-left:11%; margin-top: 1em">will place a
copy of each capture variable, $1, $2 etc, into the
@captured array.</p>

<p style="margin-left:11%; margin-top: 1em">Be aware that
when interpolating a subscript of the
&quot;@{^CAPTURE}&quot; array you must use demarcated curly
brace notation:</p>

<p style="margin-left:11%; margin-top: 1em">print
&quot;@{^CAPTURE[0]}&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">See
&quot;Demarcated variable names using braces&quot; in
perldata for more on this notation.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series
of more specific cases and remembers the best match.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WARNING</small></b>
: If your code is to run on Perl 5.16 or earlier, beware
that once Perl sees that you need one of $&amp;,
&quot;$`&quot;, or &quot;$'&quot; anywhere in the program,
it has to provide them for every pattern match. This may
substantially slow your program.</p>

<p style="margin-left:11%; margin-top: 1em">Perl uses the
same mechanism to produce $1, $2, <i>etc</i>, so you also
pay a price for each pattern that contains capturing
parentheses. (To avoid this cost while retaining the
grouping behaviour, use the extended regular expression
&quot;(?: ... )&quot; instead.) But if you never use $&amp;,
&quot;$`&quot; or &quot;$'&quot;, then patterns
<i>without</i> capturing parentheses will not be penalized.
So avoid $&amp;, &quot;$'&quot;, and &quot;$`&quot; if you
can, but if you can&rsquo;t (and some algorithms really
appreciate them), once you&rsquo;ve used them once, use them
at will, because you&rsquo;ve already paid the price.</p>

<p style="margin-left:11%; margin-top: 1em">Perl 5.16
introduced a slightly more efficient mechanism that notes
separately whether each of &quot;$`&quot;, $&amp;, and
&quot;$'&quot; have been seen, and thus may only need to
copy part of the string. Perl 5.20 introduced a much more
efficient copy-on-write mechanism which eliminates any
slowdown.</p>

<p style="margin-left:11%; margin-top: 1em">As another
workaround for this problem, Perl 5.10.0 introduced
&quot;${^PREMATCH}&quot;, &quot;${^MATCH}&quot; and
&quot;${^POSTMATCH}&quot;, which are equivalent to
&quot;$`&quot;, $&amp; and &quot;$'&quot;, <b>except</b>
that they are only guaranteed to be defined after a
successful match that was executed with the &quot;/p&quot;
(preserve) modifier. The use of these variables incurs no
global performance penalty, unlike their punctuation
character equivalents, however at the trade-off that you
have to tell perl when you want to use them. As of Perl
5.20, these three variables are equivalent to
&quot;$`&quot;, $&amp; and &quot;$'&quot;, and
&quot;/p&quot; is ignored.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Quoting
metacharacters</b> <br>
Backslashed metacharacters in Perl are alphanumeric, such as
&quot;\b&quot;, &quot;\w&quot;, &quot;\n&quot;. Unlike some
other regular expression languages, there are no backslashed
symbols that aren&rsquo;t alphanumeric. So anything that
looks like &quot;\\&quot;, &quot;\(&quot;, &quot;\)&quot;,
&quot;\[&quot;, &quot;\]&quot;, &quot;\{&quot;, or
&quot;\}&quot; is always interpreted as a literal character,
not a metacharacter. This was once used in a common idiom to
disable or quote the special meanings of regular expression
metacharacters in a string that you want to use for a
pattern. Simply quote all non&minus;&quot;word&quot;
characters:</p>

<p style="margin-left:11%; margin-top: 1em">$pattern =~
s/(\W)/\\$1/g;</p>

<p style="margin-left:11%; margin-top: 1em">(If &quot;use
locale&quot; is set, then this depends on the current
locale.) Today it is more common to use the
&quot;quotemeta()&quot; function or the &quot;\Q&quot;
metaquoting escape sequence to disable all
metacharacters&rsquo; special meanings like this:</p>


<p style="margin-left:11%; margin-top: 1em">/$unquoted\Q$quoted\E$unquoted/</p>

<p style="margin-left:11%; margin-top: 1em">Beware that if
you put literal backslashes (those not inside interpolated
variables) between &quot;\Q&quot; and &quot;\E&quot;,
double-quotish backslash interpolation may lead to confusing
results. If you <i>need</i> to use literal backslashes
within &quot;\Q...\E&quot;, consult &quot;Gory details of
parsing quoted constructs&quot; in perlop.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;quotemeta()&quot;
and &quot;\Q&quot; are fully described in
&quot;quotemeta&quot; in perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Extended
Patterns</b> <br>
Perl also defines a consistent extension syntax for features
not found in standard tools like <b>awk</b> and <b>lex</b>.
The syntax for most of these is a pair of parentheses with a
question mark as the first thing within the parentheses. The
character after the question mark indicates the
extension.</p>

<p style="margin-left:11%; margin-top: 1em">A question mark
was chosen for this and for the minimal-matching construct
because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop
and &quot;question&quot; exactly what is going on.
That&rsquo;s psychology.... <br>
&quot;(?#<i>text</i>)&quot;</p>

<p style="margin-left:17%;">A comment. The <i>text</i> is
ignored. Note that Perl closes the comment as soon as it
sees a &quot;)&quot;, so there is no way to put a literal
&quot;)&quot; in the comment. The pattern&rsquo;s closing
delimiter must be escaped by a backslash if it appears in
the comment.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;/x&quot; for another way to have comments in
patterns.</p>

<p style="margin-left:17%; margin-top: 1em">Note that a
comment can go just about anywhere, except in the middle of
an escape sequence. Examples:</p>


<p style="margin-left:17%; margin-top: 1em">qr/foo(?#comment)bar/'
# Matches 'foobar' <br>
# The pattern below matches 'abcd', 'abccd', or 'abcccd'
<br>
qr/abc(?#comment between literal and its quantifier){1,3}d/
<br>
# The pattern below generates a syntax error, because the
'\p' must <br>
# be followed immediately by a '{'. <br>
qr/\p(?#comment between \p and its property name){Any}/ <br>
# The pattern below generates a syntax error, because the
initial <br>
# '\(' is a literal opening parenthesis, and so there is
nothing <br>
# for the closing ')' to match <br>
qr/\(?#the backslash means this isn't a comment)p{Any}/ <br>
# Comments can be used to fold long patterns into multiple
lines <br>
qr/First part of a long regex(?# <br>
)remaining part/</p>


<p style="margin-left:11%;">&quot;(?adlupimnsx&minus;imnsx)&quot;
<br>
&quot;(?^alupimnsx)&quot;</p>

<p style="margin-left:17%;">Zero or more embedded
pattern-match modifiers, to be turned on (or turned off if
preceded by &quot;&minus;&quot;) for the remainder of the
pattern or the remainder of the enclosing pattern group (if
any).</p>

<p style="margin-left:17%; margin-top: 1em">This is
particularly useful for dynamically-generated patterns, such
as those read in from a configuration file, taken from an
argument, or specified in a table somewhere. Consider the
case where some patterns want to be case-sensitive and some
do not: The case-insensitive ones merely need to include
&quot;(?i)&quot; at the front of the pattern. For
example:</p>

<p style="margin-left:17%; margin-top: 1em">$pattern =
&quot;foobar&quot;; <br>
if ( /$pattern/i ) { } <br>
# more flexible: <br>
$pattern = &quot;(?i)foobar&quot;; <br>
if ( /$pattern/ ) { }</p>

<p style="margin-left:17%; margin-top: 1em">These modifiers
are restored at the end of the enclosing group. For
example,</p>

<p style="margin-left:17%; margin-top: 1em">( (?i) blah )
\s+ \g1</p>

<p style="margin-left:17%; margin-top: 1em">will match
&quot;blah&quot; in any case, some spaces, and an exact
(<i>including the case</i>!) repetition of the previous
word, assuming the &quot;/x&quot; modifier, and no
&quot;/i&quot; modifier outside this group.</p>

<p style="margin-left:17%; margin-top: 1em">These modifiers
do not carry over into named subpatterns called in the
enclosing group. In other words, a pattern such as
&quot;((?i)(?&amp;<i>NAME</i>))&quot; does not change the
case-sensitivity of the <i><small>NAME</small></i>
pattern.</p>

<p style="margin-left:17%; margin-top: 1em">A modifier is
overridden by later occurrences of this construct in the
same scope containing the same modifier, so that</p>


<p style="margin-left:17%; margin-top: 1em">/((?im)foo(?&minus;m)bar)/</p>

<p style="margin-left:17%; margin-top: 1em">matches all of
&quot;foobar&quot; case insensitively, but uses
&quot;/m&quot; rules for only the &quot;foo&quot; portion.
The &quot;a&quot; flag overrides &quot;aa&quot; as well;
likewise &quot;aa&quot; overrides &quot;a&quot;. The same
goes for &quot;x&quot; and &quot;xx&quot;. Hence, in</p>


<p style="margin-left:17%; margin-top: 1em">/(?&minus;x)foo/xx</p>

<p style="margin-left:17%; margin-top: 1em">both
&quot;/x&quot; and &quot;/xx&quot; are turned off during
matching &quot;foo&quot;. And in</p>

<p style="margin-left:17%; margin-top: 1em">/(?x)foo/x</p>

<p style="margin-left:17%; margin-top: 1em">&quot;/x&quot;
but <small>NOT</small> &quot;/xx&quot; is turned on for
matching &quot;foo&quot;. (One might mistakenly think that
since the inner &quot;(?x)&quot; is already in the scope of
&quot;/x&quot;, that the result would effectively be the sum
of them, yielding &quot;/xx&quot;. It doesn&rsquo;t work
that way.) Similarly, doing something like
&quot;(?xx&minus;x)foo&quot; turns off all &quot;x&quot;
behavior for matching &quot;foo&quot;, it is not that you
subtract 1 &quot;x&quot; from 2 to get 1 &quot;x&quot;
remaining.</p>

<p style="margin-left:17%; margin-top: 1em">Any of these
modifiers can be set to apply globally to all regular
expressions compiled within the scope of a &quot;use
re&quot;. See &quot;&rsquo;/flags&rsquo; mode&quot; in
re.</p>

<p style="margin-left:17%; margin-top: 1em">Starting in
Perl 5.14, a &quot;^&quot; (caret or circumflex accent)
immediately after the &quot;?&quot; is a shorthand
equivalent to &quot;d&minus;imnsx&quot;. Flags (except
&quot;d&quot;) may follow the caret to override it. But a
minus sign is not legal with it.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
&quot;a&quot;, &quot;d&quot;, &quot;l&quot;, &quot;p&quot;,
and &quot;u&quot; modifiers are special in that they can
only be enabled, not disabled, and the &quot;a&quot;,
&quot;d&quot;, &quot;l&quot;, and &quot;u&quot; modifiers
are mutually exclusive: specifying one de-specifies the
others, and a maximum of one (or two &quot;a&quot;&rsquo;s)
may appear in the construct. Thus, for example,
&quot;(?&minus;p)&quot; will warn when compiled under
&quot;use warnings&quot;; &quot;(?&minus;d:...)&quot; and
&quot;(?dl:...)&quot; are fatal errors.</p>

<p style="margin-left:17%; margin-top: 1em">Note also that
the &quot;p&quot; modifier is special in that its presence
anywhere in a pattern has a global effect.</p>

<p style="margin-left:17%; margin-top: 1em">Having zero
modifiers makes this a no-op (so why did you specify it,
unless it&rsquo;s generated code), and starting in v5.30,
warns under &quot;use re 'strict'&quot;.</p>

<p style="margin-left:11%;">&quot;(?:<i>pattern</i>)&quot;
<br>
&quot;(?adluimnsx&minus;imnsx:<i>pattern</i>)&quot; <br>
&quot;(?^aluimnsx:<i>pattern</i>)&quot;</p>

<p style="margin-left:17%;">This is for clustering, not
capturing; it groups subexpressions like &quot;()&quot;, but
doesn&rsquo;t make backreferences as &quot;()&quot; does.
So</p>

<p style="margin-left:17%; margin-top: 1em">@fields =
split(/\b(?:a|b|c)\b/)</p>

<p style="margin-left:17%; margin-top: 1em">matches the
same field delimiters as</p>

<p style="margin-left:17%; margin-top: 1em">@fields =
split(/\b(a|b|c)\b/)</p>

<p style="margin-left:17%; margin-top: 1em">but
doesn&rsquo;t spit out the delimiters themselves as extra
fields (even though that&rsquo;s the behaviour of
&quot;split&quot; in perlfunc when its pattern contains
capturing groups). It&rsquo;s also cheaper not to capture
characters if you don&rsquo;t need to.</p>

<p style="margin-left:17%; margin-top: 1em">Any letters
between &quot;?&quot; and &quot;:&quot; act as flags
modifiers as with &quot;(?adluimnsx&minus;imnsx)&quot;. For
example,</p>


<p style="margin-left:17%; margin-top: 1em">/(?s&minus;i:more.*than).*million/i</p>

<p style="margin-left:17%; margin-top: 1em">is equivalent
to the more verbose</p>


<p style="margin-left:17%; margin-top: 1em">/(?:(?s&minus;i)more.*than).*million/i</p>

<p style="margin-left:17%; margin-top: 1em">Note that any
&quot;()&quot; constructs enclosed within this one will
still capture unless the &quot;/n&quot; modifier is in
effect.</p>

<p style="margin-left:17%; margin-top: 1em">Like the
&quot;(?adlupimnsx&minus;imnsx)&quot; construct,
&quot;aa&quot; and &quot;a&quot; override each other, as do
&quot;xx&quot; and &quot;x&quot;. They are not additive. So,
doing something like &quot;(?xx&minus;x:foo)&quot; turns off
all &quot;x&quot; behavior for matching &quot;foo&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Starting in
Perl 5.14, a &quot;^&quot; (caret or circumflex accent)
immediately after the &quot;?&quot; is a shorthand
equivalent to &quot;d&minus;imnsx&quot;. Any positive flags
(except &quot;d&quot;) may follow the caret, so</p>

<p style="margin-left:17%; margin-top: 1em">(?^x:foo)</p>

<p style="margin-left:17%; margin-top: 1em">is equivalent
to</p>


<p style="margin-left:17%; margin-top: 1em">(?x&minus;imns:foo)</p>

<p style="margin-left:17%; margin-top: 1em">The caret tells
Perl that this cluster doesn&rsquo;t inherit the flags of
any surrounding pattern, but uses the system defaults
(&quot;d&minus;imnsx&quot;), modified by any flags
specified.</p>

<p style="margin-left:17%; margin-top: 1em">The caret
allows for simpler stringification of compiled regular
expressions. These look like</p>


<p style="margin-left:17%; margin-top: 1em">(?^:pattern)</p>

<p style="margin-left:17%; margin-top: 1em">with any
non-default flags appearing between the caret and the colon.
A test that looks at such stringification thus doesn&rsquo;t
need to have the system default flags hard-coded in it, just
the caret. If new flags are added to Perl, the meaning of
the caret&rsquo;s expansion will change to include the
default for those flags, so the test will still work,
unchanged.</p>

<p style="margin-left:17%; margin-top: 1em">Specifying a
negative flag after the caret is an error, as the flag is
redundant.</p>

<p style="margin-left:17%; margin-top: 1em">Mnemonic for
&quot;(?^...)&quot;: A fresh beginning since the usual use
of a caret is to match at the beginning.</p>


<p style="margin-left:11%;">&quot;(?|<i>pattern</i>)&quot;</p>

<p style="margin-left:17%;">This is the &quot;branch
reset&quot; pattern, which has the special property that the
capture groups are numbered from the same starting point in
each alternation branch. It is available starting from perl
5.10.0.</p>

<p style="margin-left:17%; margin-top: 1em">Capture groups
are numbered from left to right, but inside this construct
the numbering is restarted for each branch.</p>

<p style="margin-left:17%; margin-top: 1em">The numbering
within each branch will be as normal, and any groups
following this construct will be numbered as though the
construct contained only one branch, that being the one with
the most capture groups in it.</p>

<p style="margin-left:17%; margin-top: 1em">This construct
is useful when you want to capture one of a number of
alternative matches.</p>

<p style="margin-left:17%; margin-top: 1em">Consider the
following pattern. The numbers underneath show in which
group the captured content will be stored.</p>

<p style="margin-left:17%; margin-top: 1em"># before
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;branch&minus;reset&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
after <br>
/ ( a ) (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
<br>
# 1 2 2 3 2 3 4</p>

<p style="margin-left:17%; margin-top: 1em">Be careful when
using the branch reset pattern in combination with named
captures. Named captures are implemented as being aliases to
numbered groups holding the captures, and that interferes
with the implementation of the branch reset pattern. If you
are using named captures in a branch reset pattern,
it&rsquo;s best to use the same names, in the same order, in
each of the alternations:</p>

<p style="margin-left:17%; margin-top: 1em">/(?|
(?&lt;a&gt; x ) (?&lt;b&gt; y ) <br>
| (?&lt;a&gt; z ) (?&lt;b&gt; w )) /x</p>

<p style="margin-left:17%; margin-top: 1em">Not doing so
may lead to surprises:</p>

<p style="margin-left:17%; margin-top: 1em">&quot;12&quot;
=~ /(?| (?&lt;a&gt; \d+ ) | (?&lt;b&gt; \D+))/x; <br>
say $+{a}; # Prints '12' <br>
say $+{b}; # *Also* prints '12'.</p>

<p style="margin-left:17%; margin-top: 1em">The problem
here is that both the group named &quot;a&quot; and the
group named &quot;b&quot; are aliases for the group
belonging to $1.</p>

<p style="margin-left:11%;">Lookaround Assertions</p>

<p style="margin-left:17%;">Lookaround assertions are
zero-width patterns which match a specific pattern without
including it in $&amp;. Positive assertions match when their
subpattern matches, negative assertions match when their
subpattern fails. Lookbehind matches text up to the current
match position, lookahead matches text following the current
match position. <br>
&quot;(?=<i>pattern</i>)&quot; <br>
&quot;(*pla:<i>pattern</i>)&quot; <br>
&quot;(*positive_lookahead:<i>pattern</i>)&quot;</p>

<p style="margin-left:23%;">A zero-width positive lookahead
assertion. For example, &quot;/\w+(?=\t)/&quot; matches a
word followed by a tab, without including the tab in
$&amp;.</p>

<p style="margin-left:17%;">&quot;(?!<i>pattern</i>)&quot;
<br>
&quot;(*nla:<i>pattern</i>)&quot; <br>
&quot;(*negative_lookahead:<i>pattern</i>)&quot;</p>

<p style="margin-left:23%;">A zero-width negative lookahead
assertion. For example &quot;/foo(?!bar)/&quot; matches any
occurrence of &quot;foo&quot; that isn&rsquo;t followed by
&quot;bar&quot;. Note however that lookahead and lookbehind
are <small>NOT</small> the same thing. You cannot use this
for lookbehind.</p>

<p style="margin-left:23%; margin-top: 1em">If you are
looking for a &quot;bar&quot; that isn&rsquo;t preceded by a
&quot;foo&quot;, &quot;/(?!foo)bar/&quot; will not do what
you want. That&rsquo;s because the &quot;(?!foo)&quot; is
just saying that the next thing cannot be
&quot;foo&quot;&minus;&minus;and it&rsquo;s not, it&rsquo;s
a &quot;bar&quot;, so &quot;foobar&quot; will match. Use
lookbehind instead (see below).</p>


<p style="margin-left:17%;">&quot;(?&lt;=<i>pattern</i>)&quot;
<br>
&quot;\K&quot; <br>
&quot;(*plb:<i>pattern</i>)&quot; <br>
&quot;(*positive_lookbehind:<i>pattern</i>)&quot;</p>

<p style="margin-left:23%;">A zero-width positive
lookbehind assertion. For example,
&quot;/(?&lt;=\t)\w+/&quot; matches a word that follows a
tab, without including the tab in $&amp;.</p>

<p style="margin-left:23%; margin-top: 1em">Prior to Perl
5.30, it worked only for fixed-width lookbehind, but
starting in that release, it can handle variable lengths
from 1 to 255 characters as an experimental feature. The
feature is enabled automatically if you use a variable
length positive lookbehind assertion.</p>

<p style="margin-left:23%; margin-top: 1em">In Perl 5.35.10
the scope of the experimental nature of this construct has
been reduced, and experimental warnings will only be
produced when the construct contains capturing parenthesis.
The warnings will be raised at pattern compilation time,
unless turned off, in the &quot;experimental::vlb&quot;
category. This is to warn you that the exact contents of
capturing buffers in a variable length positive lookbehind
is not well defined and is subject to change in a future
release of perl.</p>

<p style="margin-left:23%; margin-top: 1em">Currently if
you use capture buffers inside of a positive variable length
lookbehind the result will be the longest and thus leftmost
match possible. This means that</p>


<p style="margin-left:23%; margin-top: 1em">&quot;aax&quot;
=~ /(?=x)(?&lt;=(a|aa))/ <br>
&quot;aax&quot; =~ /(?=x)(?&lt;=(aa|a))/ <br>
&quot;aax&quot; =~ /(?=x)(?&lt;=(a{1,2}?)/ <br>
&quot;aax&quot; =~ /(?=x)(?&lt;=(a{1,2})/</p>

<p style="margin-left:23%; margin-top: 1em">will all result
in $1 containing &quot;aa&quot;. It is possible in a future
release of perl we will change this behavior.</p>

<p style="margin-left:23%; margin-top: 1em">There is a
special form of this construct, called &quot;\K&quot;
(available since Perl 5.10.0), which causes the regex engine
to &quot;keep&quot; everything it had matched prior to the
&quot;\K&quot; and not include it in $&amp;. This
effectively provides non-experimental variable-length
lookbehind of any length.</p>

<p style="margin-left:23%; margin-top: 1em">And, there is a
technique that can be used to handle variable length
lookbehinds on earlier releases, and longer than 255
characters. It is described in
&lt;http://www.drregex.com/2019/02/variable&minus;length&minus;lookbehinds&minus;actually.html&gt;.</p>

<p style="margin-left:23%; margin-top: 1em">Note that under
&quot;/i&quot;, a few single characters match two or three
other characters. This makes them variable length, and the
255 length applies to the maximum number of characters in
the match. For example &quot;qr/\N{LATIN SMALL LETTER SHARP
S}/i&quot; matches the sequence &quot;ss&quot;. Your
lookbehind assertion could contain 127 Sharp S characters
under &quot;/i&quot;, but adding a 128th would generate a
compilation error, as that could match 256 &quot;s&quot;
characters in a row.</p>

<p style="margin-left:23%; margin-top: 1em">The use of
&quot;\K&quot; inside of another lookaround assertion is
allowed, but the behaviour is currently not well
defined.</p>

<p style="margin-left:23%; margin-top: 1em">For various
reasons &quot;\K&quot; may be significantly more efficient
than the equivalent &quot;(?&lt;=...)&quot; construct, and
it is especially useful in situations where you want to
efficiently remove something following something else in a
string. For instance</p>


<p style="margin-left:23%; margin-top: 1em">s/(foo)bar/$1/g;</p>

<p style="margin-left:23%; margin-top: 1em">can be
rewritten as the much more efficient</p>


<p style="margin-left:23%; margin-top: 1em">s/foo\Kbar//g;</p>

<p style="margin-left:23%; margin-top: 1em">Use of the
non-greedy modifier &quot;?&quot; may not give you the
expected results if it is within a capturing group within
the construct.</p>


<p style="margin-left:17%;">&quot;(?&lt;!<i>pattern</i>)&quot;
<br>
&quot;(*nlb:<i>pattern</i>)&quot; <br>
&quot;(*negative_lookbehind:<i>pattern</i>)&quot;</p>

<p style="margin-left:23%;">A zero-width negative
lookbehind assertion. For example
&quot;/(?&lt;!bar)foo/&quot; matches any occurrence of
&quot;foo&quot; that does not follow &quot;bar&quot;.</p>

<p style="margin-left:23%; margin-top: 1em">Prior to Perl
5.30, it worked only for fixed-width lookbehind, but
starting in that release, it can handle variable lengths
from 1 to 255 characters as an experimental feature. The
feature is enabled automatically if you use a variable
length negative lookbehind assertion.</p>

<p style="margin-left:23%; margin-top: 1em">In Perl 5.35.10
the scope of the experimental nature of this construct has
been reduced, and experimental warnings will only be
produced when the construct contains capturing parentheses.
The warnings will be raised at pattern compilation time,
unless turned off, in the &quot;experimental::vlb&quot;
category. This is to warn you that the exact contents of
capturing buffers in a variable length negative lookbehind
is not well defined and is subject to change in a future
release of perl.</p>

<p style="margin-left:23%; margin-top: 1em">Currently if
you use capture buffers inside of a negative variable length
lookbehind the result may not be what you expect, for
instance:</p>

<p style="margin-left:23%; margin-top: 1em">say
&quot;axfoo&quot;=~/(?=foo)(?&lt;!(a|ax)(?{ say $1 }))/ ?
&quot;y&quot; : &quot;n&quot;;</p>

<p style="margin-left:23%; margin-top: 1em">will output the
following:</p>

<p style="margin-left:23%; margin-top: 1em">a <br>
no</p>

<p style="margin-left:23%; margin-top: 1em">which does not
make sense as this should print out &quot;ax&quot; as the
&quot;a&quot; does not line up at the correct place. Another
example would be:</p>

<p style="margin-left:23%; margin-top: 1em">say &quot;yes:
'$1&minus;$2'&quot; if
&quot;aayfoo&quot;=~/(?=foo)(?&lt;!(a|aa)(a|aa)x)/;</p>

<p style="margin-left:23%; margin-top: 1em">will output the
following:</p>

<p style="margin-left:23%; margin-top: 1em">yes:
'aa&minus;a'</p>

<p style="margin-left:23%; margin-top: 1em">It is possible
in a future release of perl we will change this behavior so
both of these examples produced more reasonable output.</p>

<p style="margin-left:23%; margin-top: 1em">Note that we
are confident that the construct will match and reject
patterns appropriately, the undefined behavior strictly
relates to the value of the capture buffer during or after
matching.</p>

<p style="margin-left:23%; margin-top: 1em">There is a
technique that can be used to handle variable length
lookbehind on earlier releases, and longer than 255
characters. It is described in
&lt;http://www.drregex.com/2019/02/variable&minus;length&minus;lookbehinds&minus;actually.html&gt;.</p>

<p style="margin-left:23%; margin-top: 1em">Note that under
&quot;/i&quot;, a few single characters match two or three
other characters. This makes them variable length, and the
255 length applies to the maximum number of characters in
the match. For example &quot;qr/\N{LATIN SMALL LETTER SHARP
S}/i&quot; matches the sequence &quot;ss&quot;. Your
lookbehind assertion could contain 127 Sharp S characters
under &quot;/i&quot;, but adding a 128th would generate a
compilation error, as that could match 256 &quot;s&quot;
characters in a row.</p>

<p style="margin-left:23%; margin-top: 1em">Use of the
non-greedy modifier &quot;?&quot; may not give you the
expected results if it is within a capturing group within
the construct.</p>


<p style="margin-left:11%;">&quot;(?&lt;<i>NAME</i>&gt;<i>pattern</i>)&quot;
<br>
&quot;(?'<i>NAME</i>'<i>pattern</i>)&quot;</p>

<p style="margin-left:17%;">A named capture group.
Identical in every respect to normal capturing parentheses
&quot;()&quot; but for the additional fact that the group
can be referred to by name in various regular expression
constructs (like &quot;\g{<i>NAME</i>}&quot;) and can be
accessed by name after a successful match via &quot;%+&quot;
or &quot;%&minus;&quot;. See perlvar for more details on the
&quot;%+&quot; and &quot;%&minus;&quot; hashes.</p>

<p style="margin-left:17%; margin-top: 1em">If multiple
distinct capture groups have the same name, then
$+{<i>NAME</i>} will refer to the leftmost defined group in
the match.</p>

<p style="margin-left:17%; margin-top: 1em">The forms
&quot;(?'<i>NAME</i>'<i>pattern</i>)&quot; and
&quot;(?&lt;<i>NAME</i>&gt;<i>pattern</i>)&quot; are
equivalent.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
While the notation of this construct is the same as the
similar function in .NET regexes, the behavior is not. In
Perl the groups are numbered sequentially regardless of
being named or not. Thus in the pattern</p>


<p style="margin-left:17%; margin-top: 1em">/(x)(?&lt;foo&gt;y)(z)/</p>

<p style="margin-left:17%; margin-top: 1em">$+{foo} will be
the same as $2, and $3 will contain &rsquo;z&rsquo; instead
of the opposite which is what a .NET regex hacker might
expect.</p>

<p style="margin-left:17%; margin-top: 1em">Currently
<i><small>NAME</small></i> is restricted to simple
identifiers only. In other words, it must match
&quot;/^[_A&minus;Za&minus;z][_A&minus;Za&minus;z0&minus;9]*\z/&quot;
or its Unicode extension (see utf8), though it isn&rsquo;t
extended by the locale (see perllocale).</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
In order to make things easier for programmers with
experience with the Python or <small>PCRE</small> regex
engines, the pattern
&quot;(?P&lt;<i>NAME</i>&gt;<i>pattern</i>)&quot; may be
used instead of
&quot;(?&lt;<i>NAME</i>&gt;<i>pattern</i>)&quot;; however
this form does not support the use of single quotes as a
delimiter for the name.</p>


<p style="margin-left:11%;">&quot;\k&lt;<i>NAME</i>&gt;&quot;
<br>
&quot;\k'<i>NAME</i>'&quot; <br>
&quot;\k{<i>NAME</i>}&quot;</p>

<p style="margin-left:17%;">Named backreference. Similar to
numeric backreferences, except that the group is designated
by name and not number. If multiple groups have the same
name then it refers to the leftmost defined group in the
current match.</p>

<p style="margin-left:17%; margin-top: 1em">It is an error
to refer to a name not defined by a
&quot;(?&lt;<i>NAME</i>&gt;)&quot; earlier in the
pattern.</p>

<p style="margin-left:17%; margin-top: 1em">All three forms
are equivalent, although with &quot;\k{ <i>NAME</i> }&quot;,
you may optionally have blanks within but adjacent to the
braces, as shown.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
In order to make things easier for programmers with
experience with the Python or <small>PCRE</small> regex
engines, the pattern &quot;(?P=<i>NAME</i>)&quot; may be
used instead of &quot;\k&lt;<i>NAME</i>&gt;&quot;.</p>

<p style="margin-left:11%;">&quot;(?{ <i>code</i>
})&quot;</p>

<p style="margin-left:17%;"><b><small>WARNING</small></b> :
Using this feature safely requires that you understand its
limitations. Code executed that has side effects may not
perform identically from version to version due to the
effect of future optimisations in the regex engine. For more
information on this, see &quot;Embedded Code Execution
Frequency&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This zero-width
assertion executes any embedded Perl code. It always
succeeds, and its return value is set as $^R.</p>

<p style="margin-left:17%; margin-top: 1em">In literal
patterns, the code is parsed at the same time as the
surrounding code. While within the pattern, control is
passed temporarily back to the perl parser, until the
logically-balancing closing brace is encountered. This is
similar to the way that an array index expression in a
literal string is handled, for example</p>


<p style="margin-left:17%; margin-top: 1em">&quot;abc$array[
1 + f('[') + g()]def&quot;</p>

<p style="margin-left:17%; margin-top: 1em">In particular,
braces do not need to be balanced:</p>

<p style="margin-left:17%; margin-top: 1em">s/abc(?{
f('{'); })/def/</p>

<p style="margin-left:17%; margin-top: 1em">Even in a
pattern that is interpolated and compiled at run-time,
literal code blocks will be compiled once, at perl compile
time; the following prints &quot;
<small>ABCD&quot;:</small></p>

<p style="margin-left:17%; margin-top: 1em">print
&quot;D&quot;; <br>
my $qr = qr/(?{ BEGIN { print &quot;A&quot; } })/; <br>
my $foo = &quot;foo&quot;; <br>
/$foo$qr(?{ BEGIN { print &quot;B&quot; } })/; <br>
BEGIN { print &quot;C&quot; }</p>

<p style="margin-left:17%; margin-top: 1em">In patterns
where the text of the code is derived from run-time
information rather than appearing literally in a source code
/pattern/, the code is compiled at the same time that the
pattern is compiled, and for reasons of security, &quot;use
re 'eval'&quot; must be in scope. This is to stop
user-supplied patterns containing code snippets from being
executable.</p>

<p style="margin-left:17%; margin-top: 1em">In situations
where you need to enable this with &quot;use re
'eval'&quot;, you should also have taint checking enabled,
if your perl supports it. Better yet, use the carefully
constrained evaluation within a Safe compartment. See
perlsec for details about both these mechanisms.</p>

<p style="margin-left:17%; margin-top: 1em">From the
viewpoint of parsing, lexical variable scope and
closures,</p>

<p style="margin-left:17%; margin-top: 1em">/AAA(?{ BBB
})CCC/</p>

<p style="margin-left:17%; margin-top: 1em">behaves
approximately like</p>

<p style="margin-left:17%; margin-top: 1em">/AAA/
&amp;&amp; do { BBB } &amp;&amp; /CCC/</p>

<p style="margin-left:17%; margin-top: 1em">Similarly,</p>

<p style="margin-left:17%; margin-top: 1em">qr/AAA(?{ BBB
})CCC/</p>

<p style="margin-left:17%; margin-top: 1em">behaves
approximately like</p>

<p style="margin-left:17%; margin-top: 1em">sub { /AAA/
&amp;&amp; do { BBB } &amp;&amp; /CCC/ }</p>

<p style="margin-left:17%; margin-top: 1em">In
particular:</p>

<p style="margin-left:17%; margin-top: 1em">{ my $i = 1; $r
= qr/(?{ print $i })/ } <br>
my $i = 2; <br>
/$r/; # prints &quot;1&quot;</p>

<p style="margin-left:17%; margin-top: 1em">Inside a
&quot;(?{...})&quot; block, $_ refers to the string the
regular expression is matching against. You can also use
&quot;pos()&quot; to know what is the current position of
matching within this string.</p>

<p style="margin-left:17%; margin-top: 1em">The code block
introduces a new scope from the perspective of lexical
variable declarations, but <b>not</b> from the perspective
of &quot;local&quot; and similar localizing behaviours. So
later code blocks within the same pattern will still see the
values which were localized in earlier blocks. These
accumulated localizations are undone either at the end of a
successful match, or if the assertion is backtracked
(compare &quot;Backtracking&quot;). For example,</p>

<p style="margin-left:17%; margin-top: 1em">$_ = 'a' x 8;
<br>
m&lt; <br>
(?{ $cnt = 0 }) # Initialize $cnt. <br>
( <br>
a <br>
(?{ <br>
local $cnt = $cnt + 1; # Update $cnt, <br>
# backtracking&minus;safe. <br>
}) <br>
)* <br>
aaaa <br>
(?{ $res = $cnt }) # On success copy to <br>
# non&minus;localized location. <br>
&gt;x;</p>

<p style="margin-left:17%; margin-top: 1em">will initially
increment $cnt up to 8; then during backtracking, its value
will be unwound back to 4, which is the value assigned to
$res. At the end of the regex execution, $cnt will be wound
back to its initial value of 0.</p>

<p style="margin-left:17%; margin-top: 1em">This assertion
may be used as the condition in a</p>


<p style="margin-left:17%; margin-top: 1em">(?(condition)yes&minus;pattern|no&minus;pattern)</p>

<p style="margin-left:17%; margin-top: 1em">switch. If
<i>not</i> used in this way, the result of evaluation of
<i>code</i> is put into the special variable $^R. This
happens immediately, so $^R can be used from other &quot;(?{
<i>code</i> })&quot; assertions inside the same regular
expression.</p>

<p style="margin-left:17%; margin-top: 1em">The assignment
to $^R above is properly localized, so the old value of $^R
is restored if the assertion is backtracked; compare
&quot;Backtracking&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
special variable $^N is particularly useful with code blocks
to capture the results of submatches in variables without
having to keep track of the number of nested parentheses.
For example:</p>

<p style="margin-left:17%; margin-top: 1em">$_ = &quot;The
brown fox jumps over the lazy dog&quot;; <br>
/the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i;
<br>
print &quot;color = $color, animal = $animal\n&quot;;</p>

<p style="margin-left:11%;">&quot;(??{ <i>code</i>
})&quot;</p>

<p style="margin-left:17%;"><b><small>WARNING</small></b> :
Using this feature safely requires that you understand its
limitations. Code executed that has side effects may not
perform identically from version to version due to the
effect of future optimisations in the regex engine. For more
information on this, see &quot;Embedded Code Execution
Frequency&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This is a
&quot;postponed&quot; regular subexpression. It behaves in
<i>exactly</i> the same way as a &quot;(?{ <i>code</i>
})&quot; code block as described above, except that its
return value, rather than being assigned to $^R, is treated
as a pattern, compiled if it&rsquo;s a string (or used as-is
if its a qr// object), then matched as if it were inserted
instead of this construct.</p>

<p style="margin-left:17%; margin-top: 1em">During the
matching of this sub-pattern, it has its own set of captures
which are valid during the sub-match, but are discarded once
control returns to the main pattern. For example, the
following matches, with the inner pattern capturing
&quot;B&quot; and matching &quot; <small>BB&quot;,</small>
while the outer pattern captures &quot;A&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">my $inner =
'(.)\1'; <br>
&quot;ABBA&quot; =~ /^(.)(??{ $inner })\1/; <br>
print $1; # prints &quot;A&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
means that there is no way for the inner pattern to refer to
a capture group defined outside. (The code block itself can
use $1, <i>etc</i>., to refer to the enclosing
pattern&rsquo;s capture groups.) Thus, although</p>

<p style="margin-left:17%; margin-top: 1em">('a' x
100)=~/(??{'(.)' x 100})/</p>

<p style="margin-left:17%; margin-top: 1em"><i>will</i>
match, it will <i>not</i> set $1 on exit.</p>

<p style="margin-left:17%; margin-top: 1em">The following
pattern matches a parenthesized group:</p>

<p style="margin-left:17%; margin-top: 1em">$re = qr{ <br>
\( <br>
(?: <br>
(?&gt; [^()]+ ) # Non&minus;parens without backtracking <br>
| <br>
(??{ $re }) # Group with matching parens <br>
)* <br>
\) <br>
}x;</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;(?<i>PARNO</i>)&quot; for a different, more efficient
way to accomplish the same task.</p>

<p style="margin-left:17%; margin-top: 1em">Executing a
postponed regular expression too many times without
consuming any input string will also result in a fatal
error. The depth at which that happens is compiled into
perl, so it can be changed with a custom build.</p>

<p style="margin-left:11%;">&quot;(?<i>PARNO</i>)&quot;
&quot;(?&minus;<i>PARNO</i>)&quot;
&quot;(?+<i>PARNO</i>)&quot; &quot;(?R)&quot;
&quot;(?0)&quot;</p>

<p style="margin-left:17%;">Recursive subpattern. Treat the
contents of a given capture buffer in the current pattern as
an independent subpattern and attempt to match it at the
current position in the string. Information about capture
state from the caller for things like backreferences is
available to the subpattern, but capture buffers set by the
subpattern are not visible to the caller.</p>

<p style="margin-left:17%; margin-top: 1em">Similar to
&quot;(??{ <i>code</i> })&quot; except that it does not
involve executing any code or potentially compiling a
returned pattern string; instead it treats the part of the
current pattern contained within a specified capture group
as an independent pattern that must match at the current
position. Also different is the treatment of capture
buffers, unlike &quot;(??{ <i>code</i> })&quot; recursive
patterns have access to their caller&rsquo;s match state, so
one can use backreferences safely.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>PARNO</small></i>
is a sequence of digits (not starting with 0) whose value
reflects the paren-number of the capture group to recurse
to. &quot;(?R)&quot; recurses to the beginning of the whole
pattern. &quot;(?0)&quot; is an alternate syntax for
&quot;(?R)&quot;. If <i><small>PARNO</small></i> is preceded
by a plus or minus sign then it is assumed to be relative,
with negative numbers indicating preceding capture groups
and positive ones following. Thus &quot;(?&minus;1)&quot;
refers to the most recently declared group, and
&quot;(?+1)&quot; indicates the next group to be declared.
Note that the counting for relative recursion differs from
that of relative backreferences, in that with recursion
unclosed groups <b>are</b> included.</p>

<p style="margin-left:17%; margin-top: 1em">The following
pattern matches a function &quot;foo()&quot; which may
contain balanced parentheses as the argument.</p>

<p style="margin-left:17%; margin-top: 1em">$re = qr{ ( #
paren group 1 (full function) <br>
foo <br>
( # paren group 2 (parens) <br>
\( <br>
( # paren group 3 (contents of parens) <br>
(?: <br>
(?&gt; [^()]+ ) # Non&minus;parens without backtracking <br>
| <br>
(?2) # Recurse to start of paren group 2 <br>
)* <br>
) <br>
\) <br>
) <br>
) <br>
}x;</p>

<p style="margin-left:17%; margin-top: 1em">If the pattern
was used as follows</p>


<p style="margin-left:17%; margin-top: 1em">'foo(bar(baz)+baz(bop))'=~/$re/
<br>
and print &quot;\$1 = $1\n&quot;, <br>
&quot;\$2 = $2\n&quot;, <br>
&quot;\$3 = $3\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">the output
produced should be the following:</p>

<p style="margin-left:17%; margin-top: 1em">$1 =
foo(bar(baz)+baz(bop)) <br>
$2 = (bar(baz)+baz(bop)) <br>
$3 = bar(baz)+baz(bop)</p>

<p style="margin-left:17%; margin-top: 1em">If there is no
corresponding capture group defined, then it is a fatal
error. Recursing deeply without consuming any input string
will also result in a fatal error. The depth at which that
happens is compiled into perl, so it can be changed with a
custom build.</p>

<p style="margin-left:17%; margin-top: 1em">The following
shows how using negative indexing can make it easier to
embed recursive patterns inside of a &quot;qr//&quot;
construct for later use:</p>

<p style="margin-left:17%; margin-top: 1em">my $parens =
qr/(\((?:[^()]++|(?&minus;1))*+\))/; <br>
if (/foo $parens \s+ \+ \s+ bar $parens/x) { <br>
# do something here... <br>
}</p>

<p style="margin-left:17%; margin-top: 1em"><b>Note</b>
that this pattern does not behave the same way as the
equivalent <small>PCRE</small> or Python construct of the
same form. In Perl you can backtrack into a recursed group,
in <small>PCRE</small> and Python the recursed into group is
treated as atomic. Also, modifiers are resolved at compile
time, so constructs like &quot;(?i:(?1))&quot; or
&quot;(?:(?i)(?1))&quot; do not affect how the sub-pattern
will be processed.</p>


<p style="margin-left:11%;">&quot;(?&amp;<i>NAME</i>)&quot;</p>

<p style="margin-left:17%;">Recurse to a named subpattern.
Identical to &quot;(?<i>PARNO</i>)&quot; except that the
parenthesis to recurse to is determined by name. If multiple
parentheses have the same name, then it recurses to the
leftmost.</p>

<p style="margin-left:17%; margin-top: 1em">It is an error
to refer to a name that is not declared somewhere in the
pattern.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
In order to make things easier for programmers with
experience with the Python or <small>PCRE</small> regex
engines the pattern &quot;(?P&gt;<i>NAME</i>)&quot; may be
used instead of &quot;(?&amp;<i>NAME</i>)&quot;.</p>


<p style="margin-left:11%;">&quot;(?(<i>condition</i>)<i>yes&minus;pattern</i>|<i>no&minus;pattern</i>)&quot;
<br>

&quot;(?(<i>condition</i>)<i>yes&minus;pattern</i>)&quot;</p>

<p style="margin-left:17%;">Conditional expression. Matches
<i>yes-pattern</i> if <i>condition</i> yields a true value,
matches <i>no-pattern</i> otherwise. A missing pattern
always matches.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;(<i>condition</i>)&quot;
should be one of: <br>
an integer in parentheses</p>

<p style="margin-left:23%;">(which is valid if the
corresponding pair of parentheses matched);</p>

<p style="margin-left:17%;">a lookahead/lookbehind/evaluate
zero-width assertion; <br>
a name in angle brackets or single quotes</p>

<p style="margin-left:23%;">(which is valid if a group with
the given name matched);</p>

<p style="margin-left:17%;">the special symbol
&quot;(R)&quot;</p>

<p style="margin-left:23%;">(true when evaluated inside of
recursion or eval). Additionally the &quot;R&quot; may be
followed by a number, (which will be true when evaluated
when recursing inside of the appropriate group), or by
&quot;&amp;<i>NAME</i>&quot;, in which case it will be true
only when evaluated during recursion in the named group.</p>

<p style="margin-left:17%; margin-top: 1em">Here&rsquo;s a
summary of the possible predicates: <br>
&quot;(1)&quot; &quot;(2)&quot; ...</p>

<p style="margin-left:23%;">Checks if the numbered
capturing group has matched something. Full syntax:
&quot;(?(1)then|else)&quot;</p>


<p style="margin-left:17%;">&quot;(&lt;<i>NAME</i>&gt;)&quot;
&quot;('<i>NAME</i>')&quot;</p>

<p style="margin-left:23%;">Checks if a group with the
given name has matched something. Full syntax:
&quot;(?(&lt;name&gt;)then|else)&quot;</p>

<p style="margin-left:17%;">&quot;(?=...)&quot;
&quot;(?!...)&quot; &quot;(?&lt;=...)&quot;
&quot;(?&lt;!...)&quot;</p>

<p style="margin-left:23%;">Checks whether the pattern
matches (or does not match, for the &quot;!&quot; variants).
Full syntax:
&quot;(?(?=<i>lookahead</i>)<i>then</i>|<i>else</i>)&quot;</p>

<p style="margin-left:17%;">&quot;(?{ <i>CODE</i>
})&quot;</p>

<p style="margin-left:23%;">Treats the return value of the
code block as the condition. Full syntax: &quot;(?(?{
<i>code</i> })<i>then</i>|<i>else</i>)&quot;</p>

<p style="margin-left:17%;">&quot;(R)&quot;</p>

<p style="margin-left:23%;">Checks if the expression has
been evaluated inside of recursion. Full syntax:
&quot;(?(R)<i>then</i>|<i>else</i>)&quot;</p>

<p style="margin-left:17%;">&quot;(R1)&quot;
&quot;(R2)&quot; ...</p>

<p style="margin-left:23%;">Checks if the expression has
been evaluated while executing directly inside of the
n&minus;th capture group. This check is the regex equivalent
of</p>

<p style="margin-left:23%; margin-top: 1em">if
((caller(0))[3] eq 'subname') { ... }</p>

<p style="margin-left:23%; margin-top: 1em">In other words,
it does not check the full recursion stack.</p>

<p style="margin-left:23%; margin-top: 1em">Full syntax:
&quot;(?(R1)<i>then</i>|<i>else</i>)&quot;</p>


<p style="margin-left:17%;">&quot;(R&amp;<i>NAME</i>)&quot;</p>

<p style="margin-left:23%;">Similar to &quot;(R1)&quot;,
this predicate checks to see if we&rsquo;re executing
directly inside of the leftmost group with a given name
(this is the same logic used by
&quot;(?&amp;<i>NAME</i>)&quot; to disambiguate). It does
not check the full stack, but only the name of the innermost
active recursion. Full syntax:
&quot;(?(R&amp;<i>name</i>)<i>then</i>|<i>else</i>)&quot;</p>

<p style="margin-left:17%;">&quot;(DEFINE)&quot;</p>

<p style="margin-left:23%;">In this case, the yes-pattern
is never directly executed, and no no-pattern is allowed.
Similar in spirit to &quot;(?{0})&quot; but more efficient.
See below for details. Full syntax:
&quot;(?(DEFINE)<i>definitions</i>...)&quot;</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<p style="margin-left:17%; margin-top: 1em">m{ ( \( )? <br>
[^()]+ <br>
(?(1) \) ) <br>
}x</p>

<p style="margin-left:17%; margin-top: 1em">matches a chunk
of non-parentheses, possibly included in parentheses
themselves.</p>

<p style="margin-left:17%; margin-top: 1em">A special form
is the &quot;(DEFINE)&quot; predicate, which never executes
its yes-pattern directly, and does not allow a no-pattern.
This allows one to define subpatterns which will be executed
only by the recursion mechanism. This way, you can define a
set of regular expression rules that can be bundled into any
pattern you choose.</p>

<p style="margin-left:17%; margin-top: 1em">It is
recommended that for this usage you put the
<small>DEFINE</small> block at the end of the pattern, and
that you name any subpatterns defined within it.</p>

<p style="margin-left:17%; margin-top: 1em">Also,
it&rsquo;s worth noting that patterns defined this way
probably will not be as efficient, as the optimizer is not
very clever about handling them.</p>

<p style="margin-left:17%; margin-top: 1em">An example of
how this might be used is as follows:</p>


<p style="margin-left:17%; margin-top: 1em">/(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))
<br>
(?(DEFINE) <br>
(?&lt;NAME_PAT&gt;....) <br>
(?&lt;ADDRESS_PAT&gt;....) <br>
)/x</p>

<p style="margin-left:17%; margin-top: 1em">Note that
capture groups matched inside of recursion are not
accessible after the recursion returns, so the extra layer
of capturing groups is necessary. Thus $+{NAME_PAT} would
not be defined even though $+{NAME} would be.</p>

<p style="margin-left:17%; margin-top: 1em">Finally, keep
in mind that subpatterns created inside a
<small>DEFINE</small> block count towards the absolute and
relative number of captures, so this:</p>

<p style="margin-left:17%; margin-top: 1em">my @captures =
&quot;a&quot; =~ /(.) # First capture <br>
(?(DEFINE) <br>
(?&lt;EXAMPLE&gt; 1 ) # Second capture <br>
)/x; <br>
say scalar @captures;</p>

<p style="margin-left:17%; margin-top: 1em">Will output 2,
not 1. This is particularly important if you intend to
compile the definitions with the &quot;qr//&quot; operator,
and later interpolate them in another pattern.</p>


<p style="margin-left:11%;">&quot;(?&gt;<i>pattern</i>)&quot;
<br>
&quot;(*atomic:<i>pattern</i>)&quot;</p>

<p style="margin-left:17%;">An &quot;independent&quot;
subexpression, one which matches the substring that a
standalone <i>pattern</i> would match if anchored at the
given position, and it matches <i>nothing other than this
substring</i>. This construct is useful for optimizations of
what would otherwise be &quot;eternal&quot; matches, because
it will not backtrack (see &quot;Backtracking&quot;). It may
also be useful in places where the &quot;grab all you can,
and do not give anything back&quot; semantic is
desirable.</p>

<p style="margin-left:17%; margin-top: 1em">For example:
&quot;^(?&gt;a*)ab&quot; will never match, since
&quot;(?&gt;a*)&quot; (anchored at the beginning of string,
as above) will match <i>all</i> characters &quot;a&quot; at
the beginning of string, leaving no &quot;a&quot; for
&quot;ab&quot; to match. In contrast, &quot;a*ab&quot; will
match the same as &quot;a+b&quot;, since the match of the
subgroup &quot;a*&quot; is influenced by the following group
&quot;ab&quot; (see &quot;Backtracking&quot;). In
particular, &quot;a*&quot; inside &quot;a*ab&quot; will
match fewer characters than a standalone &quot;a*&quot;,
since this makes the tail match.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;(?&gt;<i>pattern</i>)&quot;
does not disable backtracking altogether once it has
matched. It is still possible to backtrack past the
construct, but not into it. So
&quot;((?&gt;a*)|(?&gt;b*))ar&quot; will still match
&quot;bar&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">An effect
similar to &quot;(?&gt;<i>pattern</i>)&quot; may be achieved
by writing &quot;(?=(<i>pattern</i>))\g{&minus;1}&quot;.
This matches the same substring as a standalone
&quot;a+&quot;, and the following &quot;\g{&minus;1}&quot;
eats the matched string; it therefore makes a zero-length
assertion into an analogue of &quot;(?&gt;...)&quot;. (The
difference between these two constructs is that the second
one uses a capturing group, thus shifting ordinals of
backreferences in the rest of a regular expression.)</p>

<p style="margin-left:17%; margin-top: 1em">Consider this
pattern:</p>

<p style="margin-left:17%; margin-top: 1em">m{ \( <br>
( <br>
[^()]+ # x+ <br>
| <br>
\( [^()]* \) <br>
)+ <br>
\) <br>
}x</p>

<p style="margin-left:17%; margin-top: 1em">That will
efficiently match a nonempty group with matching parentheses
two levels deep or less. However, if there is no such group,
it will take virtually forever on a long string.
That&rsquo;s because there are so many different ways to
split a long string into several substrings. This is what
&quot;(.+)+&quot; is doing, and &quot;(.+)+&quot; is similar
to a subpattern of the above pattern. Consider how the
pattern above detects no-match on
&quot;((()aaaaaaaaaaaaaaaaaa&quot; in several seconds, but
that each extra letter doubles this time. This exponential
performance will make it appear that your program has hung.
However, a tiny change to this pattern</p>

<p style="margin-left:17%; margin-top: 1em">m{ \( <br>
( <br>
(?&gt; [^()]+ ) # change x+ above to (?&gt; x+ ) <br>
| <br>
\( [^()]* \) <br>
)+ <br>
\) <br>
}x</p>

<p style="margin-left:17%; margin-top: 1em">which uses
&quot;(?&gt;...)&quot; matches exactly when the one above
does (verifying this yourself would be a productive
exercise), but finishes in a fourth the time when used on a
similar string with 1000000 &quot;a&quot;s. Be aware,
however, that, when this construct is followed by a
quantifier, it currently triggers a warning message under
the &quot;use warnings&quot; pragma or <b>&minus;w</b>
switch saying it &quot;matches null string many times in
regex&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">On simple
groups, such as the pattern &quot;(?&gt; [^()]+ )&quot;, a
comparable effect may be achieved by negative lookahead, as
in &quot;[^()]+ (?! [^()] )&quot;. This was only 4 times
slower on a string with 1000000 &quot;a&quot;s.</p>

<p style="margin-left:17%; margin-top: 1em">The &quot;grab
all you can, and do not give anything back&quot; semantic is
desirable in many situations where on the first sight a
simple &quot;()*&quot; looks like the correct solution.
Suppose we parse text with comments being delimited by
&quot;#&quot; followed by some optional (horizontal)
whitespace. Contrary to its appearance, &quot;#[ \t]*&quot;
<i>is not</i> the correct subexpression to match the comment
delimiter, because it may &quot;give up&quot; some
whitespace if the remainder of the pattern can be made to
match that way. The correct answer is either one of
these:</p>

<p style="margin-left:17%; margin-top: 1em">(?&gt;#[ \t]*)
<br>
#[ \t]*(?![ \t])</p>

<p style="margin-left:17%; margin-top: 1em">For example, to
grab non-empty comments into $1, one should use either one
of these:</p>

<p style="margin-left:17%; margin-top: 1em">/ (?&gt; \# [
\t]* ) ( .+ ) /x; <br>
/ \# [ \t]* ( [^ \t] .* ) /x;</p>

<p style="margin-left:17%; margin-top: 1em">Which one you
pick depends on which of these expressions better reflects
the above specification of comments.</p>

<p style="margin-left:17%; margin-top: 1em">In some
literature this construct is called &quot;atomic
matching&quot; or &quot;possessive matching&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Possessive
quantifiers are equivalent to putting the item they are
applied to inside of one of these constructs. The following
equivalences apply:</p>

<p style="margin-left:17%; margin-top: 1em">Quantifier Form
Bracketing Form <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
PAT*+ (?&gt;PAT*) <br>
PAT++ (?&gt;PAT+) <br>
PAT?+ (?&gt;PAT?) <br>
PAT{min,max}+ (?&gt;PAT{min,max})</p>

<p style="margin-left:17%; margin-top: 1em">Nested
&quot;(?&gt;...)&quot; constructs are not no-ops, even if at
first glance they might seem to be. This is because the
nested &quot;(?&gt;...)&quot; can restrict internal
backtracking that otherwise might occur. For example,</p>


<p style="margin-left:17%; margin-top: 1em">&quot;abc&quot;
=~ /(?&gt;a[bc]*c)/</p>

<p style="margin-left:17%; margin-top: 1em">matches,
but</p>


<p style="margin-left:17%; margin-top: 1em">&quot;abc&quot;
=~ /(?&gt;a(?&gt;[bc]*)c)/</p>

<p style="margin-left:17%; margin-top: 1em">does not.</p>

<p style="margin-left:11%;">&quot;(?[ ])&quot;</p>

<p style="margin-left:17%;">See &quot;Extended Bracketed
Character Classes&quot; in perlrecharclass.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Backtracking</b>
<small><br>
NOTE:</small> This section presents an abstract
approximation of regular expression behavior. For a more
rigorous (and complicated) view of the rules involved in
selecting a match among possible alternatives, see
&quot;Combining <small>RE</small> Pieces&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">A fundamental
feature of regular expression matching involves the notion
called <i>backtracking</i>, which is currently used (when
needed) by all regular non-possessive expression
quantifiers, namely &quot;*&quot;, &quot;*?&quot;,
&quot;+&quot;, &quot;+?&quot;, &quot;{n,m}&quot;, and
&quot;{n,m}?&quot;. Backtracking is often optimized
internally, but the general principle outlined here is
valid.</p>

<p style="margin-left:11%; margin-top: 1em">For a regular
expression to match, the <i>entire</i> regular expression
must match, not just part of it. So if the beginning of a
pattern containing a quantifier succeeds in a way that
causes later parts in the pattern to fail, the matching
engine backs up and recalculates the beginning
part--that&rsquo;s why it&rsquo;s called backtracking.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of backtracking: Let&rsquo;s say you want to find
the word following &quot;foo&quot; in the string &quot;Food
is on the foo table.&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">$_ = &quot;Food
is on the foo table.&quot;; <br>
if ( /\b(foo)\s+(\w+)/i ) { <br>
print &quot;$2 follows $1.\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">When the match
runs, the first part of the regular expression
(&quot;\b(foo)&quot;) finds a possible match right at the
beginning of the string, and loads up $1 with
&quot;Foo&quot;. However, as soon as the matching engine
sees that there&rsquo;s no whitespace following the
&quot;Foo&quot; that it had saved in $1, it realizes its
mistake and starts over again one character after where it
had the tentative match. This time it goes all the way until
the next occurrence of &quot;foo&quot;. The complete regular
expression matches this time, and you get the expected
output of &quot;table follows foo.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes
minimal matching can help a lot. Imagine you&rsquo;d like to
match everything between &quot;foo&quot; and
&quot;bar&quot;. Initially, you write something like
this:</p>

<p style="margin-left:11%; margin-top: 1em">$_ = &quot;The
food is under the bar in the barn.&quot;; <br>
if ( /foo(.*)bar/ ) { <br>
print &quot;got &lt;$1&gt;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Which perhaps
unexpectedly yields:</p>

<p style="margin-left:11%; margin-top: 1em">got &lt;d is
under the bar in the &gt;</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
because &quot;.*&quot; was greedy, so you get everything
between the <i>first</i> &quot;foo&quot; and the <i>last</i>
&quot;bar&quot;. Here it&rsquo;s more effective to use
minimal matching to make sure you get the text between a
&quot;foo&quot; and the first &quot;bar&quot;
thereafter.</p>

<p style="margin-left:11%; margin-top: 1em">if (
/foo(.*?)bar/ ) { print &quot;got &lt;$1&gt;\n&quot; } <br>
got &lt;d is under the &gt;</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
another example. Let&rsquo;s say you&rsquo;d like to match a
number at the end of a string, and you also want to keep the
preceding part of the match. So you write this:</p>

<p style="margin-left:11%; margin-top: 1em">$_ = &quot;I
have 2 numbers: 53147&quot;; <br>
if ( /(.*)(\d*)/ ) { # Wrong! <br>
print &quot;Beginning is &lt;$1&gt;, number is
&lt;$2&gt;.\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">That
won&rsquo;t work at all, because &quot;.*&quot; was greedy
and gobbled up the whole string. As &quot;\d*&quot; can
match on an empty string the complete regular expression
matched successfully.</p>

<p style="margin-left:11%; margin-top: 1em">Beginning is
&lt;I have 2 numbers: 53147&gt;, number is &lt;&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Here are some
variants, most of which don&rsquo;t work:</p>

<p style="margin-left:11%; margin-top: 1em">$_ = &quot;I
have 2 numbers: 53147&quot;; <br>
@pats = qw{ <br>
(.*)(\d*) <br>
(.*)(\d+) <br>
(.*?)(\d*) <br>
(.*?)(\d+) <br>
(.*)(\d+)$ <br>
(.*?)(\d+)$ <br>
(.*)\b(\d+)$ <br>
(.*\D)(\d+)$ <br>
}; <br>
for $pat (@pats) { <br>
printf &quot;%&minus;12s &quot;, $pat; <br>
if ( /$pat/ ) { <br>
print &quot;&lt;$1&gt; &lt;$2&gt;\n&quot;; <br>
} else { <br>
print &quot;FAIL\n&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">That will print
out:</p>

<p style="margin-left:11%; margin-top: 1em">(.*)(\d*) &lt;I
have 2 numbers: 53147&gt; &lt;&gt; <br>
(.*)(\d+) &lt;I have 2 numbers: 5314&gt; &lt;7&gt; <br>
(.*?)(\d*) &lt;&gt; &lt;&gt; <br>
(.*?)(\d+) &lt;I have &gt; &lt;2&gt; <br>
(.*)(\d+)$ &lt;I have 2 numbers: 5314&gt; &lt;7&gt; <br>
(.*?)(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt; <br>
(.*)\b(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt; <br>
(.*\D)(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;</p>

<p style="margin-left:11%; margin-top: 1em">As you see,
this can be a bit tricky. It&rsquo;s important to realize
that a regular expression is merely a set of assertions that
gives a definition of success. There may be 0, 1, or several
different ways that the definition might succeed against a
particular string. And if there are multiple ways it might
succeed, you need to understand backtracking to know which
variety of success you will achieve.</p>

<p style="margin-left:11%; margin-top: 1em">When using
lookahead assertions and negations, this can all get even
trickier. Imagine you&rsquo;d like to find a sequence of
non-digits not followed by &quot;123&quot;. You might try to
write that as</p>

<p style="margin-left:11%; margin-top: 1em">$_ =
&quot;ABC123&quot;; <br>
if ( /^\D*(?!123)/ ) { # Wrong! <br>
print &quot;Yup, no 123 in $_\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">But that
isn&rsquo;t going to match; at least, not the way
you&rsquo;re hoping. It claims that there is no 123 in the
string. Here&rsquo;s a clearer picture of why that pattern
matches, contrary to popular expectations:</p>

<p style="margin-left:11%; margin-top: 1em">$x = 'ABC123';
<br>
$y = 'ABC445'; <br>
print &quot;1: got $1\n&quot; if $x =~ /^(ABC)(?!123)/; <br>
print &quot;2: got $1\n&quot; if $y =~ /^(ABC)(?!123)/; <br>
print &quot;3: got $1\n&quot; if $x =~ /^(\D*)(?!123)/; <br>
print &quot;4: got $1\n&quot; if $y =~ /^(\D*)(?!123)/;</p>

<p style="margin-left:11%; margin-top: 1em">This prints</p>

<p style="margin-left:11%; margin-top: 1em">2: got ABC <br>
3: got AB <br>
4: got ABC</p>

<p style="margin-left:11%; margin-top: 1em">You might have
expected test 3 to fail because it seems to a more general
purpose version of test 1. The important difference between
them is that test 3 contains a quantifier (&quot;\D*&quot;)
and so can use backtracking, whereas test 1 will not.
What&rsquo;s happening is that you&rsquo;ve asked &quot;Is
it true that at the start of $x, following 0 or more
non-digits, you have something that&rsquo;s not 123?&quot;
If the pattern matcher had let &quot;\D*&quot; expand to
&quot; <small>ABC&quot;,</small> this would have caused the
whole pattern to fail.</p>

<p style="margin-left:11%; margin-top: 1em">The search
engine will initially match &quot;\D*&quot; with &quot;
<small>ABC&quot;.</small> Then it will try to match
&quot;(?!123)&quot; with &quot;123&quot;, which fails. But
because a quantifier (&quot;\D*&quot;) has been used in the
regular expression, the search engine can backtrack and
retry the match differently in the hope of matching the
complete regular expression.</p>

<p style="margin-left:11%; margin-top: 1em">The pattern
really, <i>really</i> wants to succeed, so it uses the
standard pattern back-off-and-retry and lets &quot;\D*&quot;
expand to just &quot; <small>AB&quot;</small> this time. Now
there&rsquo;s indeed something following &quot;
<small>AB&quot;</small> that is not &quot;123&quot;.
It&rsquo;s &quot;C123&quot;, which suffices.</p>

<p style="margin-left:11%; margin-top: 1em">We can deal
with this by using both an assertion and a negation.
We&rsquo;ll say that the first part in $1 must be followed
both by a digit and by something that&rsquo;s not
&quot;123&quot;. Remember that the lookaheads are zero-width
expressions--they only look, but don&rsquo;t consume any of
the string in their match. So rewriting this way produces
what you&rsquo;d expect; that is, case 5 will fail, but case
6 succeeds:</p>

<p style="margin-left:11%; margin-top: 1em">print &quot;5:
got $1\n&quot; if $x =~ /^(\D*)(?=\d)(?!123)/; <br>
print &quot;6: got $1\n&quot; if $y =~
/^(\D*)(?=\d)(?!123)/; <br>
6: got ABC</p>

<p style="margin-left:11%; margin-top: 1em">In other words,
the two zero-width assertions next to each other work as
though they&rsquo;re ANDed together, just as you&rsquo;d use
any built-in assertions: &quot;/^$/&quot; matches only if
you&rsquo;re at the beginning of the line <small>AND</small>
the end of the line simultaneously. The deeper underlying
truth is that juxtaposition in regular expressions always
means <small>AND,</small> except when you write an explicit
<small>OR</small> using the vertical bar. &quot;/ab/&quot;
means match &quot;a&quot; <small>AND</small> (then) match
&quot;b&quot;, although the attempted matches are made at
different positions because &quot;a&quot; is not a
zero-width assertion, but a one-width assertion.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WARNING</small></b>
: Particularly complicated regular expressions can take
exponential time to solve because of the immense number of
possible ways they can use backtracking to try for a match.
For example, without internal optimizations done by the
regular expression engine, this will take a painfully long
time to run:</p>

<p style="margin-left:11%; margin-top: 1em">'aaaaaaaaaaaa'
=~ /((a{0,5}){0,5})*[c]/</p>

<p style="margin-left:11%; margin-top: 1em">And if you used
&quot;*&quot;&rsquo;s in the internal groups instead of
limiting them to 0 through 5 matches, then it would take
forever--or until you ran out of stack space. Moreover,
these internal optimizations are not always applicable. For
example, if you put &quot;{0,5}&quot; instead of
&quot;*&quot; on the external group, no current optimization
is applicable, and the match takes a long time to
finish.</p>

<p style="margin-left:11%; margin-top: 1em">A powerful tool
for optimizing such beasts is what is known as an
&quot;independent group&quot;, which does not backtrack (see
&quot;(?&gt;pattern)&quot;). Note also that zero-length
lookahead/lookbehind assertions will not backtrack to make
the tail match, since they are in &quot;logical&quot;
context: only whether they match is considered relevant. For
an example where side-effects of lookahead <i>might</i> have
influenced the following match, see
&quot;(?&gt;pattern)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Script
Runs</b> <br>
A script run is basically a sequence of characters, all from
the same Unicode script (see &quot;Scripts&quot; in
perlunicode), such as Latin or Greek. In most places a
single word would never be written in multiple scripts,
unless it is a spoofing attack. An infamous example, is</p>

<p style="margin-left:11%; margin-top: 1em">paypal.com</p>

<p style="margin-left:11%; margin-top: 1em">Those letters
could all be Latin (as in the example just above), or they
could be all Cyrillic (except for the dot), or they could be
a mixture of the two. In the case of an internet address the
&quot;.com&quot; would be in Latin, And any Cyrillic ones
would cause it to be a mixture, not a script run. Someone
clicking on such a link would not be directed to the real
Paypal website, but an attacker would craft a look-alike one
to attempt to gather sensitive information from the
person.</p>

<p style="margin-left:11%; margin-top: 1em">Starting in
Perl 5.28, it is now easy to detect strings that
aren&rsquo;t script runs. Simply enclose just about any
pattern like either of these:</p>


<p style="margin-left:11%; margin-top: 1em">(*script_run:pattern)
<br>
(*sr:pattern)</p>

<p style="margin-left:11%; margin-top: 1em">What happens is
that after <i>pattern</i> succeeds in matching, it is
subjected to the additional criterion that every character
in it must be from the same script (see exceptions below).
If this isn&rsquo;t true, backtracking occurs until
something all in the same script is found that matches, or
all possibilities are exhausted. This can cause a lot of
backtracking, but generally, only malicious input will
result in this, though the slow down could cause a denial of
service attack. If your needs permit, it is best to make the
pattern atomic to cut down on the amount of backtracking.
This is so likely to be what you want, that instead of
writing this:</p>


<p style="margin-left:11%; margin-top: 1em">(*script_run:(?&gt;pattern))</p>

<p style="margin-left:11%; margin-top: 1em">you can write
either of these:</p>


<p style="margin-left:11%; margin-top: 1em">(*atomic_script_run:pattern)
<br>
(*asr:pattern)</p>

<p style="margin-left:11%; margin-top: 1em">(See
&quot;(?&gt;<i>pattern</i>)&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">In Taiwan,
Japan, and Korea, it is common for text to have a mixture of
characters from their native scripts and base Chinese. Perl
follows Unicode&rsquo;s <small>UTS 39</small>
(&lt;https://unicode.org/reports/tr39/&gt;) Unicode Security
Mechanisms in allowing such mixtures. For example, the
Japanese scripts Katakana and Hiragana are commonly mixed
together in practice, along with some Chinese characters,
and hence are treated as being in a single script run by
Perl.</p>

<p style="margin-left:11%; margin-top: 1em">The rules used
for matching decimal digits are slightly stricter. Many
scripts have their own sets of digits equivalent to the
Western 0 through 9 ones. A few, such as Arabic, have more
than one set. For a string to be considered a script run,
all digits in it must come from the same set of ten, as
determined by the first digit encountered. As an
example,</p>


<p style="margin-left:11%; margin-top: 1em">qr/(*script_run:
\d+ \b )/x</p>

<p style="margin-left:11%; margin-top: 1em">guarantees that
the digits matched will all be from the same set of 10. You
won&rsquo;t get a look-alike digit from a different script
that has a different value than what it appears to be.</p>

<p style="margin-left:11%; margin-top: 1em">Unicode has
three pseudo scripts that are handled specially.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Unknown&quot;
is applied to code points whose meaning has yet to be
determined. Perl currently will match as a script run, any
single character string consisting of one of these code
points. But any string longer than one code point containing
one of these will not be considered a script run.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Inherited&quot;
is applied to characters that modify another, such as an
accent of some type. These are considered to be in the
script of the master character, and so never cause a script
run to not match.</p>

<p style="margin-left:11%; margin-top: 1em">The other one
is &quot;Common&quot;. This consists of mostly punctuation,
emoji, and characters used in mathematics and music, the
<small>ASCII</small> digits 0 through 9, and full-width
forms of these digits. These characters can appear
intermixed in text in many of the world&rsquo;s scripts.
These also don&rsquo;t cause a script run to not match. But
like other scripts, all digits in a run must come from the
same set of 10.</p>

<p style="margin-left:11%; margin-top: 1em">This construct
is non-capturing. You can add parentheses to <i>pattern</i>
to capture, if desired. You will have to do this if you plan
to use &quot;(*ACCEPT) (*ACCEPT:arg)&quot; and not have it
bypass the script run checking.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;Script_Extensions&quot; property as modified by
<small>UTS 39</small>
(&lt;https://unicode.org/reports/tr39/&gt;) is used as the
basis for this feature.</p>

<p style="margin-left:11%; margin-top: 1em">To
summarize,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>All length 0 or length 1 sequences are script runs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>A longer sequence is a script run if and only if
<b>all</b> of the following conditions are met:</p></td></tr>
</table>

<p style="margin-left:17%;">1.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="77%">


<p style="margin-top: 1em">No code point in the sequence
has the &quot;Script_Extension&quot; property of
&quot;Unknown&quot;.</p> </td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">This currently
means that all code points in the sequence have been
assigned by Unicode to be characters that aren&rsquo;t
private use nor surrogate code points.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="77%">


<p style="margin-top: 1em">All characters in the sequence
come from the Common script and/or the Inherited script
and/or a single other script.</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">The script of a
character is determined by the &quot;Script_Extensions&quot;
property as modified by <small>UTS 39</small>
(&lt;https://unicode.org/reports/tr39/&gt;), as described
above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="3%"></td>
<td width="77%">


<p style="margin-top: 1em">All decimal digits in the
sequence come from the same block of 10 consecutive
digits.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Special
Backtracking Control Verbs</b> <br>
These special patterns are generally of the form
&quot;(*<i>VERB</i>:<i>arg</i>)&quot;. Unless otherwise
stated the <i>arg</i> argument is optional; in some cases,
it is mandatory.</p>

<p style="margin-left:11%; margin-top: 1em">Any pattern
containing a special backtracking verb that allows an
argument has the special behaviour that when executed it
sets the current package&rsquo;s $REGERROR and $REGMARK
variables. When doing so the following rules apply:</p>

<p style="margin-left:11%; margin-top: 1em">On failure, the
$REGERROR variable will be set to the <i>arg</i> value of
the verb pattern, if the verb was involved in the failure of
the match. If the <i>arg</i> part of the pattern was
omitted, then $REGERROR will be set to the name of the last
&quot;(*MARK:<i>NAME</i>)&quot; pattern executed, or to
<small>TRUE</small> if there was none. Also, the $REGMARK
variable will be set to <small>FALSE.</small></p>

<p style="margin-left:11%; margin-top: 1em">On a successful
match, the $REGERROR variable will be set to
<small>FALSE,</small> and the $REGMARK variable will be set
to the name of the last &quot;(*MARK:<i>NAME</i>)&quot;
pattern executed. See the explanation for the
&quot;(*MARK:<i>NAME</i>)&quot; verb below for more
details.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE:</small></b>
$REGERROR and $REGMARK are not magic variables like $1 and
most other regex-related variables. They are not local to a
scope, nor readonly, but instead are volatile package
variables similar to $AUTOLOAD. They are set in the package
containing the code that <i>executed</i> the regex (rather
than the one that compiled it, where those differ). If
necessary, you can use &quot;local&quot; to localize changes
to these variables to a specific scope before executing a
regex.</p>

<p style="margin-left:11%; margin-top: 1em">If a pattern
does not contain a special backtracking verb that allows an
argument, then $REGERROR and $REGMARK are not touched at
all. <br>
Verbs</p>

<p style="margin-left:15%;">&quot;(*PRUNE)&quot;
&quot;(*PRUNE:<i>NAME</i>)&quot;</p>

<p style="margin-left:22%;">This zero-width pattern prunes
the backtracking tree at the current point when backtracked
into on failure. Consider the pattern &quot;/<i>A</i>
(*PRUNE) <i>B</i>/&quot;, where <i>A</i> and <i>B</i> are
complex patterns. Until the &quot;(*PRUNE)&quot; verb is
reached, <i>A</i> may backtrack as necessary to match. Once
it is reached, matching continues in <i>B</i>, which may
also backtrack as necessary; however, should B not match,
then no further backtracking will take place, and the
pattern will fail outright at the current starting
position.</p>

<p style="margin-left:22%; margin-top: 1em">The following
example counts all the possible matching strings in a
pattern (without actually matching any of them).</p>

<p style="margin-left:22%; margin-top: 1em">'aaab' =~
/a+b?(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/; <br>
print &quot;Count=$count\n&quot;;</p>

<p style="margin-left:22%; margin-top: 1em">which
produces:</p>

<p style="margin-left:22%; margin-top: 1em">aaab <br>
aaa <br>
aa <br>
a <br>
aab <br>
aa <br>
a <br>
ab <br>
a <br>
Count=9</p>

<p style="margin-left:22%; margin-top: 1em">If we add a
&quot;(*PRUNE)&quot; before the count like the following</p>

<p style="margin-left:22%; margin-top: 1em">'aaab' =~
/a+b?(*PRUNE)(?{print &quot;$&amp;\n&quot;;
$count++})(*FAIL)/; <br>
print &quot;Count=$count\n&quot;;</p>

<p style="margin-left:22%; margin-top: 1em">we prevent
backtracking and find the count of the longest matching
string at each matching starting point like so:</p>

<p style="margin-left:22%; margin-top: 1em">aaab <br>
aab <br>
ab <br>
Count=3</p>

<p style="margin-left:22%; margin-top: 1em">Any number of
&quot;(*PRUNE)&quot; assertions may be used in a
pattern.</p>

<p style="margin-left:22%; margin-top: 1em">See also
&quot;(?&gt;<i>pattern</i>)&quot; and possessive quantifiers
for other ways to control backtracking. In some cases, the
use of &quot;(*PRUNE)&quot; can be replaced with a
&quot;(?&gt;pattern)&quot; with no functional difference;
however, &quot;(*PRUNE)&quot; can be used to handle cases
that cannot be expressed using a &quot;(?&gt;pattern)&quot;
alone.</p>

<p style="margin-left:15%;">&quot;(*SKIP)&quot;
&quot;(*SKIP:<i>NAME</i>)&quot;</p>

<p style="margin-left:22%;">This zero-width pattern is
similar to &quot;(*PRUNE)&quot;, except that on failure it
also signifies that whatever text that was matched leading
up to the &quot;(*SKIP)&quot; pattern being executed cannot
be part of <i>any</i> match of this pattern. This
effectively means that the regex engine &quot;skips&quot;
forward to this position on failure and tries to match
again, (assuming that there is sufficient room to
match).</p>

<p style="margin-left:22%; margin-top: 1em">The name of the
&quot;(*SKIP:<i>NAME</i>)&quot; pattern has special
significance. If a &quot;(*MARK:<i>NAME</i>)&quot; was
encountered while matching, then it is that position which
is used as the &quot;skip point&quot;. If no
&quot;(*MARK)&quot; of that name was encountered, then the
&quot;(*SKIP)&quot; operator has no effect. When used
without a name the &quot;skip point&quot; is where the match
point was when executing the &quot;(*SKIP)&quot;
pattern.</p>

<p style="margin-left:22%; margin-top: 1em">Compare the
following to the examples in &quot;(*PRUNE)&quot;; note the
string is twice as long:</p>

<p style="margin-left:22%; margin-top: 1em">'aaabaaab' =~
/a+b?(*SKIP)(?{print &quot;$&amp;\n&quot;;
$count++})(*FAIL)/; <br>
print &quot;Count=$count\n&quot;;</p>

<p style="margin-left:22%; margin-top: 1em">outputs</p>

<p style="margin-left:22%; margin-top: 1em">aaab <br>
aaab <br>
Count=2</p>

<p style="margin-left:22%; margin-top: 1em">Once the
&rsquo;aaab&rsquo; at the start of the string has matched,
and the &quot;(*SKIP)&quot; executed, the next starting
point will be where the cursor was when the
&quot;(*SKIP)&quot; was executed.</p>


<p style="margin-left:15%;">&quot;(*MARK:<i>NAME</i>)&quot;
&quot;(*:<i>NAME</i>)&quot;</p>

<p style="margin-left:22%;">This zero-width pattern can be
used to mark the point reached in a string when a certain
part of the pattern has been successfully matched. This mark
may be given a name. A later &quot;(*SKIP)&quot; pattern
will then skip forward to that point if backtracked into on
failure. Any number of &quot;(*MARK)&quot; patterns are
allowed, and the <i><small>NAME</small></i> portion may be
duplicated.</p>

<p style="margin-left:22%; margin-top: 1em">In addition to
interacting with the &quot;(*SKIP)&quot; pattern,
&quot;(*MARK:<i>NAME</i>)&quot; can be used to
&quot;label&quot; a pattern branch, so that after matching,
the program can determine which branches of the pattern were
involved in the match.</p>

<p style="margin-left:22%; margin-top: 1em">When a match is
successful, the $REGMARK variable will be set to the name of
the most recently executed &quot;(*MARK:<i>NAME</i>)&quot;
that was involved in the match.</p>

<p style="margin-left:22%; margin-top: 1em">This can be
used to determine which branch of a pattern was matched
without using a separate capture group for each branch,
which in turn can result in a performance improvement, as
perl cannot optimize &quot;/(?:(x)|(y)|(z))/&quot; as
efficiently as something like
&quot;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">When a match
has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the
$REGERROR variable will be set to the name of the most
recently executed &quot;(*MARK:<i>NAME</i>)&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">See
&quot;(*SKIP)&quot; for more details.</p>

<p style="margin-left:22%; margin-top: 1em">As a shortcut
&quot;(*MARK:<i>NAME</i>)&quot; can be written
&quot;(*:<i>NAME</i>)&quot;.</p>

<p style="margin-left:15%;">&quot;(*THEN)&quot;
&quot;(*THEN:<i>NAME</i>)&quot;</p>

<p style="margin-left:22%;">This is similar to the
&quot;cut group&quot; operator &quot;::&quot; from Raku.
Like &quot;(*PRUNE)&quot;, this verb always matches, and
when backtracked into on failure, it causes the regex engine
to try the next alternation in the innermost enclosing group
(capturing or otherwise) that has alternations. The two
branches of a
&quot;(?(<i>condition</i>)<i>yes&minus;pattern</i>|<i>no&minus;pattern</i>)&quot;
do not count as an alternation, as far as
&quot;(*THEN)&quot; is concerned.</p>

<p style="margin-left:22%; margin-top: 1em">Its name comes
from the observation that this operation combined with the
alternation operator (&quot;|&quot;) can be used to create
what is essentially a pattern-based if/then/else block:</p>

<p style="margin-left:22%; margin-top: 1em">( COND (*THEN)
FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )</p>

<p style="margin-left:22%; margin-top: 1em">Note that if
this operator is used and <small>NOT</small> inside of an
alternation then it acts exactly like the
&quot;(*PRUNE)&quot; operator.</p>

<p style="margin-left:22%; margin-top: 1em">/ A (*PRUNE) B
/</p>

<p style="margin-left:22%; margin-top: 1em">is the same
as</p>

<p style="margin-left:22%; margin-top: 1em">/ A (*THEN) B
/</p>

<p style="margin-left:22%; margin-top: 1em">but</p>

<p style="margin-left:22%; margin-top: 1em">/ ( A (*THEN) B
| C ) /</p>

<p style="margin-left:22%; margin-top: 1em">is not the same
as</p>

<p style="margin-left:22%; margin-top: 1em">/ ( A (*PRUNE)
B | C ) /</p>

<p style="margin-left:22%; margin-top: 1em">as after
matching the <i>A</i> but failing on the <i>B</i> the
&quot;(*THEN)&quot; verb will backtrack and try <i>C</i>;
but the &quot;(*PRUNE)&quot; verb will simply fail.</p>

<p style="margin-left:15%;">&quot;(*COMMIT)&quot;
&quot;(*COMMIT:<i>arg</i>)&quot;</p>

<p style="margin-left:22%;">This is the Raku &quot;commit
pattern&quot; &quot;&lt;commit&gt;&quot; or &quot;:::&quot;.
It&rsquo;s a zero-width pattern similar to
&quot;(*SKIP)&quot;, except that when backtracked into on
failure it causes the match to fail outright. No further
attempts to find a valid match by advancing the start
pointer will occur again. For example,</p>

<p style="margin-left:22%; margin-top: 1em">'aaabaaab' =~
/a+b?(*COMMIT)(?{print &quot;$&amp;\n&quot;;
$count++})(*FAIL)/; <br>
print &quot;Count=$count\n&quot;;</p>

<p style="margin-left:22%; margin-top: 1em">outputs</p>

<p style="margin-left:22%; margin-top: 1em">aaab <br>
Count=1</p>

<p style="margin-left:22%; margin-top: 1em">In other words,
once the &quot;(*COMMIT)&quot; has been entered, and if the
pattern does not match, the regex engine will not try any
further matching on the rest of the string.</p>

<p style="margin-left:15%;">&quot;(*FAIL)&quot;
&quot;(*F)&quot; &quot;(*FAIL:<i>arg</i>)&quot;</p>

<p style="margin-left:22%;">This pattern matches nothing
and always fails. It can be used to force the engine to
backtrack. It is equivalent to &quot;(?!)&quot;, but easier
to read. In fact, &quot;(?!)&quot; gets optimised into
&quot;(*FAIL)&quot; internally. You can provide an argument
so that if the match fails because of this &quot;FAIL&quot;
directive the argument can be obtained from $REGERROR.</p>

<p style="margin-left:22%; margin-top: 1em">It is probably
useful only when combined with &quot;(?{})&quot; or
&quot;(??{})&quot;.</p>

<p style="margin-left:15%;">&quot;(*ACCEPT)&quot;
&quot;(*ACCEPT:<i>arg</i>)&quot;</p>

<p style="margin-left:22%;">This pattern matches nothing
and causes the end of successful matching at the point at
which the &quot;(*ACCEPT)&quot; pattern was encountered,
regardless of whether there is actually more to match in the
string. When inside of a nested pattern, such as recursion,
or in a subpattern dynamically generated via
&quot;(??{})&quot;, only the innermost pattern is ended
immediately.</p>

<p style="margin-left:22%; margin-top: 1em">If the
&quot;(*ACCEPT)&quot; is inside of capturing groups then the
groups are marked as ended at the point at which the
&quot;(*ACCEPT)&quot; was encountered. For instance:</p>

<p style="margin-left:22%; margin-top: 1em">'AB' =~ /(A
(A|B(*ACCEPT)|C) D)(E)/x;</p>

<p style="margin-left:22%; margin-top: 1em">will match, and
$1 will be &quot;AB&quot; and $2 will be &quot;B&quot;, $3
will not be set. If another branch in the inner parentheses
was matched, such as in the string &rsquo;
<small>ACDE</small> &rsquo;, then the &quot;D&quot; and
&quot;E&quot; would have to be matched as well.</p>

<p style="margin-left:22%; margin-top: 1em">You can provide
an argument, which will be available in the var $REGMARK
after the match completes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Warning on
&quot;\1&quot; Instead of $1</b> <br>
Some people get too used to writing things like:</p>

<p style="margin-left:11%; margin-top: 1em">$pattern =~
s/(\W)/\\\1/g;</p>

<p style="margin-left:11%; margin-top: 1em">This is
grandfathered (for \1 to \9) for the <small>RHS</small> of a
substitute to avoid shocking the <b>sed</b> addicts, but
it&rsquo;s a dirty habit to get into. That&rsquo;s because
in PerlThink, the righthand side of an &quot;s///&quot; is a
double-quoted string. &quot;\1&quot; in the usual
double-quoted string means a control-A. The customary Unix
meaning of &quot;\1&quot; is kludged in for
&quot;s///&quot;. However, if you get into the habit of
doing that, you get yourself into trouble if you then add an
&quot;/e&quot; modifier.</p>

<p style="margin-left:11%; margin-top: 1em">s/(\d+)/ \1 + 1
/eg; # causes warning under &minus;w</p>

<p style="margin-left:11%; margin-top: 1em">Or if you try
to do</p>


<p style="margin-left:11%; margin-top: 1em">s/(\d+)/\1000/;</p>

<p style="margin-left:11%; margin-top: 1em">You can&rsquo;t
disambiguate that by saying &quot;\{1}000&quot;, whereas you
can fix it with &quot;${1}000&quot;. The operation of
interpolation should not be confused with the operation of
matching a backreference. Certainly they mean two different
things on the <i>left</i> side of the &quot;s///&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Repeated
Patterns Matching a Zero-length Substring <small><br>
WARNING</small></b> : Difficult material (and prose) ahead.
This section needs a rewrite.</p>

<p style="margin-left:11%; margin-top: 1em">Regular
expressions provide a terse and powerful programming
language. As with most other power tools, power comes
together with the ability to wreak havoc.</p>

<p style="margin-left:11%; margin-top: 1em">A common abuse
of this power stems from the ability to make infinite loops
using regular expressions, with something as innocuous
as:</p>

<p style="margin-left:11%; margin-top: 1em">'foo' =~ m{ (
o? )* }x;</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;o?&quot; matches at the beginning of
&quot;&quot;foo&quot;&quot;, and since the position in the
string is not moved by the match, &quot;o?&quot; would match
again and again because of the &quot;*&quot; quantifier.
Another common way to create a similar cycle is with the
looping modifier &quot;/g&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">@matches = (
'foo' =~ m{ o? }xg );</p>

<p style="margin-left:11%; margin-top: 1em">or</p>

<p style="margin-left:11%; margin-top: 1em">print
&quot;match: &lt;$&amp;&gt;\n&quot; while 'foo' =~ m{ o?
}xg;</p>

<p style="margin-left:11%; margin-top: 1em">or the loop
implied by &quot;split()&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">However, long
experience has shown that many programming tasks may be
significantly simplified by using repeated subexpressions
that may match zero-length substrings. Here&rsquo;s a simple
example being:</p>

<p style="margin-left:11%; margin-top: 1em">@chars = split
//, $string; # // is not magic in split <br>
($whitewashed = $string) =~ s/()/ /g; # parens avoid magic
s// /</p>

<p style="margin-left:11%; margin-top: 1em">Thus Perl
allows such constructs, by <i>forcefully breaking the
infinite loop</i>. The rules for this are different for
lower-level loops given by the greedy quantifiers
&quot;*+{}&quot;, and for higher-level ones like the
&quot;/g&quot; modifier or &quot;split()&quot; operator.</p>

<p style="margin-left:11%; margin-top: 1em">The lower-level
loops are <i>interrupted</i> (that is, the loop is broken)
when Perl detects that a repeated expression matched a
zero-length substring. Thus</p>

<p style="margin-left:11%; margin-top: 1em">m{ (?:
NON_ZERO_LENGTH | ZERO_LENGTH )* }x;</p>

<p style="margin-left:11%; margin-top: 1em">is made
equivalent to</p>

<p style="margin-left:11%; margin-top: 1em">m{ (?:
NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;</p>

<p style="margin-left:11%; margin-top: 1em">For example,
this program</p>

<p style="margin-left:11%; margin-top: 1em">#!perl &minus;l
<br>
&quot;aaaaab&quot; =~ / <br>
(?: <br>
a # non&minus;zero <br>
| # or <br>
(?{print &quot;hello&quot;}) # print hello whenever this
<br>
# branch is tried <br>
(?=(b)) # zero&minus;width assertion <br>
)* # any number of times <br>
/x; <br>
print $&amp;; <br>
print $1;</p>

<p style="margin-left:11%; margin-top: 1em">prints</p>

<p style="margin-left:11%; margin-top: 1em">hello <br>
aaaaa <br>
b</p>

<p style="margin-left:11%; margin-top: 1em">Notice that
&quot;hello&quot; is only printed once, as when Perl sees
that the sixth iteration of the outermost &quot;(?:)*&quot;
matches a zero-length string, it stops the
&quot;*&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
higher-level loops preserve an additional state between
iterations: whether the last match was zero-length. To break
the loop, the following match after a zero-length match is
prohibited to have a length of zero. This prohibition
interacts with backtracking (see &quot;Backtracking&quot;),
and so the <i>second best</i> match is chosen if the
<i>best</i> match is of zero length.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<p style="margin-left:11%; margin-top: 1em">$_ = 'bar';
<br>
s/\w??/&lt;$&amp;&gt;/g;</p>

<p style="margin-left:11%; margin-top: 1em">results in
&quot;&lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;&quot;.
At each position of the string the best match given by
non-greedy &quot;??&quot; is the zero-length match, and the
<i>second best</i> match is what is matched by
&quot;\w&quot;. Thus zero-length matches alternate with
one-character-long matches.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, for
repeated &quot;m/()/g&quot; the second-best match is the
match at the position one notch further in the string.</p>

<p style="margin-left:11%; margin-top: 1em">The additional
state of being <i>matched with zero-length</i> is associated
with the matched string, and is reset by each assignment to
&quot;pos()&quot;. Zero-length matches at the end of the
previous match are ignored during &quot;split&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Combining
<small>RE</small> Pieces</b> <br>
Each of the elementary pieces of regular expressions which
were described before (such as &quot;ab&quot; or
&quot;\Z&quot;) could match at most one substring at the
given position of the input string. However, in a typical
regular expression these elementary pieces are combined into
more complicated patterns using combining operators
&quot;ST&quot;, &quot;S|T&quot;, &quot;S*&quot; <i>etc</i>.
(in these examples &quot;S&quot; and &quot;T&quot; are
regular subexpressions).</p>

<p style="margin-left:11%; margin-top: 1em">Such
combinations can include alternatives, leading to a problem
of choice: if we match a regular expression &quot;a|ab&quot;
against &quot;abc&quot;, will it match substring
&quot;a&quot; or &quot;ab&quot;? One way to describe which
substring is actually matched is the concept of backtracking
(see &quot;Backtracking&quot;). However, this description is
too low-level and makes you think in terms of a particular
implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Another
description starts with notions of
&quot;better&quot;/&quot;worse&quot;. All the substrings
which may be matched by the given regular expression can be
sorted from the &quot;best&quot; match to the
&quot;worst&quot; match, and it is the &quot;best&quot;
match which is chosen. This substitutes the question of
&quot;what is chosen?&quot; by the question of &quot;which
matches are better, and which are worse?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Again, for
elementary pieces there is no such question, since at most
one match at a given position is possible. This section
describes the notion of better/worse for combining
operators. In the description below &quot;S&quot; and
&quot;T&quot; are regular subexpressions. <br>
&quot;ST&quot;</p>

<p style="margin-left:17%;">Consider two possible matches,
&quot;AB&quot; and &quot;A'B'&quot;, &quot;A&quot; and
&quot;A'&quot; are substrings which can be matched by
&quot;S&quot;, &quot;B&quot; and &quot;B'&quot; are
substrings which can be matched by &quot;T&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;A&quot; is a better match for &quot;S&quot; than
&quot;A'&quot;, &quot;AB&quot; is a better match than
&quot;A'B'&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;A&quot; and &quot;A'&quot; coincide: &quot;AB&quot; is
a better match than &quot;AB'&quot; if &quot;B&quot; is a
better match for &quot;T&quot; than &quot;B'&quot;.</p>

<p style="margin-left:11%;">&quot;S|T&quot;</p>

<p style="margin-left:17%;">When &quot;S&quot; can match,
it is a better match than when only &quot;T&quot; can
match.</p>

<p style="margin-left:17%; margin-top: 1em">Ordering of two
matches for &quot;S&quot; is the same as for &quot;S&quot;.
Similar for two matches for &quot;T&quot;.</p>


<p style="margin-left:11%;">&quot;S{REPEAT_COUNT}&quot;</p>

<p style="margin-left:17%;">Matches as &quot;SSS...S&quot;
(repeated as many times as necessary).</p>

<p style="margin-left:11%;">&quot;S{min,max}&quot;</p>

<p style="margin-left:17%;">Matches as
&quot;S{max}|S{max&minus;1}|...|S{min+1}|S{min}&quot;.</p>

<p style="margin-left:11%;">&quot;S{min,max}?&quot;</p>

<p style="margin-left:17%;">Matches as
&quot;S{min}|S{min+1}|...|S{max&minus;1}|S{max}&quot;.</p>

<p style="margin-left:11%;">&quot;S?&quot;, &quot;S*&quot;,
&quot;S+&quot;</p>

<p style="margin-left:17%;">Same as &quot;S{0,1}&quot;,
&quot;S{0,BIG_NUMBER}&quot;, &quot;S{1,BIG_NUMBER}&quot;
respectively.</p>

<p style="margin-left:11%;">&quot;S??&quot;,
&quot;S*?&quot;, &quot;S+?&quot;</p>

<p style="margin-left:17%;">Same as &quot;S{0,1}?&quot;,
&quot;S{0,BIG_NUMBER}?&quot;, &quot;S{1,BIG_NUMBER}?&quot;
respectively.</p>

<p style="margin-left:11%;">&quot;(?&gt;S)&quot;</p>

<p style="margin-left:17%;">Matches the best match for
&quot;S&quot; and only that.</p>

<p style="margin-left:11%;">&quot;(?=S)&quot;,
&quot;(?&lt;=S)&quot;</p>

<p style="margin-left:17%;">Only the best match for
&quot;S&quot; is considered. (This is important only if
&quot;S&quot; has capturing parentheses, and backreferences
are used somewhere else in the whole regular
expression.)</p>

<p style="margin-left:11%;">&quot;(?!S)&quot;,
&quot;(?&lt;!S)&quot;</p>

<p style="margin-left:17%;">For this grouping operator
there is no need to describe the ordering, since only
whether or not &quot;S&quot; can match is important.</p>

<p style="margin-left:11%;">&quot;(??{ <i>EXPR</i>
})&quot;, &quot;(?<i>PARNO</i>)&quot;</p>

<p style="margin-left:17%;">The ordering is the same as for
the regular expression which is the result of
<i><small>EXPR</small></i> , or the pattern contained by
capture group <i><small>PARNO</small></i> .</p>


<p style="margin-left:11%;">&quot;(?(<i>condition</i>)<i>yes&minus;pattern</i>|<i>no&minus;pattern</i>)&quot;</p>

<p style="margin-left:17%;">Recall that which of
<i>yes-pattern</i> or <i>no-pattern</i> actually matches is
already determined. The ordering of the matches is the same
as for the chosen subexpression.</p>

<p style="margin-left:11%; margin-top: 1em">The above
recipes describe the ordering of matches <i>at a given
position</i>. One more rule is needed to understand how a
match is determined for the whole regular expression: a
match at an earlier position is always better than a match
at a later position.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Creating
Custom <small>RE</small> Engines</b> <br>
As of Perl 5.10.0, one can create custom regular expression
engines. This is not for the faint of heart, as they have to
plug in at the C level. See perlreapi for more details.</p>

<p style="margin-left:11%; margin-top: 1em">As an
alternative, overloaded constants (see overload) provide a
simple way to extend the functionality of the
<small>RE</small> engine, by substituting one pattern for
another.</p>

<p style="margin-left:11%; margin-top: 1em">Suppose that we
want to enable a new <small>RE</small> escape-sequence
&quot;\Y|&quot; which matches at a boundary between
whitespace characters and non-whitespace characters. Note
that &quot;(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)&quot; matches
exactly at these positions, so we want to have each
&quot;\Y|&quot; in the place of the more complicated
version. We can create a module &quot;customre&quot; to do
this:</p>

<p style="margin-left:11%; margin-top: 1em">package
customre; <br>
use overload; <br>
sub import { <br>
shift; <br>
die &quot;No argument to customre::import allowed&quot; if
@_; <br>
overload::constant 'qr' =&gt; \&amp;convert; <br>
} <br>
sub invalid { die &quot;/$_[0]/: invalid escape
'\\$_[1]'&quot;} <br>
# We must also take care of not escaping the legitimate \\Y|
<br>
# sequence, hence the presence of '\\' in the conversion
rules. <br>
my %rules = ( '\\' =&gt; '\\\\', <br>
'Y|' =&gt; qr/(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)/ ); <br>
sub convert { <br>
my $re = shift; <br>
$re =~ s{ <br>
\\ ( \\ | Y . ) <br>
} <br>
{ $rules{$1} or invalid($re,$1) }sgex; <br>
return $re; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now &quot;use
customre&quot; enables the new escape in constant regular
expressions, <i>i.e.</i>, those without any runtime variable
interpolations. As documented in overload, this conversion
will work only over literal parts of regular expressions.
For &quot;\Y|$re\Y|&quot; the variable part of this regular
expression needs to be converted explicitly (but only if the
special meaning of &quot;\Y|&quot; should be enabled inside
$re):</p>

<p style="margin-left:11%; margin-top: 1em">use customre;
<br>
$re = &lt;&gt;; <br>
chomp $re; <br>
$re = customre::convert $re; <br>
/\Y|$re\Y|/;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Embedded
Code Execution Frequency</b> <br>
The exact rules for how often &quot;(??{})&quot; and
&quot;(?{})&quot; are executed in a pattern are unspecified.
In the case of a successful match you can assume that they
<small>DWIM</small> and will be executed in left to right
order the appropriate number of times in the accepting path
of the pattern as would any other meta-pattern. How
non-accepting pathways and match failures affect the number
of times a pattern is executed is specifically unspecified
and may vary depending on what optimizations can be applied
to the pattern and is likely to change from version to
version.</p>

<p style="margin-left:11%; margin-top: 1em">For instance
in</p>


<p style="margin-left:11%; margin-top: 1em">&quot;aaabcdeeeee&quot;=~/a(?{print
&quot;a&quot;})b(?{print &quot;b&quot;})cde/;</p>

<p style="margin-left:11%; margin-top: 1em">the exact
number of times &quot;a&quot; or &quot;b&quot; are printed
out is unspecified for failure, but you may assume they will
be printed at least once during a successful match,
additionally you may assume that if &quot;b&quot; is
printed, it will be preceded by at least one
&quot;a&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">In the case of
branching constructs like the following:</p>

<p style="margin-left:11%; margin-top: 1em">/a(b|(?{ print
&quot;a&quot; }))c(?{ print &quot;c&quot; })/;</p>

<p style="margin-left:11%; margin-top: 1em">you can assume
that the input &quot;ac&quot; will output &quot;ac&quot;,
and that &quot;abc&quot; will output only &quot;c&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">When embedded
code is quantified, successful matches will call the code
once for each matched iteration of the quantifier. For
example:</p>


<p style="margin-left:11%; margin-top: 1em">&quot;good&quot;
=~ /g(?:o(?{print &quot;o&quot;}))*d/;</p>

<p style="margin-left:11%; margin-top: 1em">will output
&quot;o&quot; twice.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PCRE/Python
Support</b> <br>
As of Perl 5.10.0, Perl supports several
Python/PCRE&minus;specific extensions to the regex syntax.
While Perl programmers are encouraged to use the
Perl-specific syntax, the following are also accepted: <br>
&quot;(?P&lt;<i>NAME</i>&gt;<i>pattern</i>)&quot;</p>

<p style="margin-left:17%;">Define a named capture group.
Equivalent to
&quot;(?&lt;<i>NAME</i>&gt;<i>pattern</i>)&quot;.</p>


<p style="margin-left:11%;">&quot;(?P=<i>NAME</i>)&quot;</p>

<p style="margin-left:17%;">Backreference to a named
capture group. Equivalent to
&quot;\g{<i>NAME</i>}&quot;.</p>


<p style="margin-left:11%;">&quot;(?P&gt;<i>NAME</i>)&quot;</p>

<p style="margin-left:17%;">Subroutine call to a named
capture group. Equivalent to
&quot;(?&amp;<i>NAME</i>)&quot;.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are a
number of issues with regard to case-insensitive matching in
Unicode rules. See &quot;i&quot; under &quot;Modifiers&quot;
above.</p>

<p style="margin-left:11%; margin-top: 1em">This document
varies from difficult to understand to completely and
utterly opaque. The wandering prose riddled with jargon is
hard to fathom in several places.</p>

<p style="margin-left:11%; margin-top: 1em">This document
needs a rewrite that separates the tutorial content from the
reference content.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The syntax of
patterns used in Perl pattern matching evolved from those
supplied in the Bell Labs Research Unix 8th Edition (Version
8) regex routines. (The code is actually derived (distantly)
from Henry Spencer&rsquo;s freely redistributable
reimplementation of those V8 routines.)</p>


<p style="margin-left:11%; margin-top: 1em">perlrequick.</p>

<p style="margin-left:11%; margin-top: 1em">perlretut.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Regexp
Quote-Like Operators&quot; in perlop.</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Gory
details of parsing quoted constructs&quot; in perlop.</p>

<p style="margin-left:11%; margin-top: 1em">perlfaq6.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;pos&quot;
in perlfunc.</p>


<p style="margin-left:11%; margin-top: 1em">perllocale.</p>


<p style="margin-left:11%; margin-top: 1em">perlebcdic.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Mastering
Regular Expressions</i> by Jeffrey Friedl, published by
O&rsquo;Reilly and Associates.</p>
<hr>
</body>
</html>
