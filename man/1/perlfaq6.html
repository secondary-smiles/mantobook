<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:53:58 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLFAQ6</title>

</head>
<body>
<h1>perlfaq6</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlfaq6
&minus; Regular Expressions</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">version
5.20210520</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section is
surprisingly small because the rest of the
<small>FAQ</small> is littered with answers involving
regular expressions. For example, decoding a
<small>URL</small> and checking whether something is a
number can be handled with regular expressions, but those
answers are found elsewhere in this document (in perlfaq9:
&quot;How do I decode or create those %&minus;encodings on
the web&quot; and perlfaq4: &quot;How do I determine whether
a scalar is a number/whole/integer/float&quot;, to be
precise).</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
hope to use regular expressions without creating illegible
and unmaintainable code?</b> <br>
Three techniques can make regular expressions maintainable
and understandable. <br>
Comments Outside the Regex</p>

<p style="margin-left:17%;">Describe what you&rsquo;re
doing and how you&rsquo;re doing it, using normal Perl
comments.</p>

<p style="margin-left:17%; margin-top: 1em"># turn the line
into the first word, a colon, and the <br>
# number of characters on the rest of the line <br>
s/^(\w+)(.*)/ lc($1) . &quot;:&quot; . length($2) /meg;</p>

<p style="margin-left:11%;">Comments Inside the Regex</p>

<p style="margin-left:17%;">The &quot;/x&quot; modifier
causes whitespace to be ignored in a regex pattern (except
in a character class and a few other places), and also
allows you to use normal comments there, too. As you can
imagine, whitespace and comments help a lot.</p>

<p style="margin-left:17%; margin-top: 1em">&quot;/x&quot;
lets you turn this:</p>


<p style="margin-left:17%; margin-top: 1em">s{&lt;(?:[^&gt;'&quot;]*|&quot;.*?&quot;|'.*?')+&gt;}{}gs;</p>

<p style="margin-left:17%; margin-top: 1em">into this:</p>

<p style="margin-left:17%; margin-top: 1em">s{ &lt; #
opening angle bracket <br>
(?: # Non&minus;backreffing grouping paren <br>
[^&gt;'&quot;] * # 0 or more things that are neither &gt;
nor ' nor &quot; <br>
| # or else <br>
&quot;.*?&quot; # a section between double quotes (stingy
match) <br>
| # or else <br>
'.*?' # a section between single quotes (stingy match) <br>
) + # all occurring one or more times <br>
&gt; # closing angle bracket <br>
}{}gsx; # replace with nothing, i.e. delete</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
still not quite so clear as prose, but it is very useful for
describing the meaning of each part of the pattern.</p>

<p style="margin-left:11%;">Different Delimiters</p>

<p style="margin-left:17%;">While we normally think of
patterns as being delimited with &quot;/&quot; characters,
they can be delimited by almost any character. perlre
describes this. For example, the &quot;s///&quot; above uses
braces as delimiters. Selecting another delimiter can avoid
quoting the delimiter within the pattern:</p>


<p style="margin-left:17%; margin-top: 1em">s/\/usr\/local/\/usr\/share/g;
# bad delimiter choice <br>
s#/usr/local#/usr/share#g; # better</p>

<p style="margin-left:17%; margin-top: 1em">Using logically
paired delimiters can be even more readable:</p>


<p style="margin-left:17%; margin-top: 1em">s{/usr/local/}{/usr/share}g;
# better still</p>

<p style="margin-left:11%; margin-top: 1em"><b>I&rsquo;m
having trouble matching over more than one line.
What&rsquo;s wrong?</b> <br>
Either you don&rsquo;t have more than one line in the string
you&rsquo;re looking at (probably), or else you aren&rsquo;t
using the correct modifier(s) on your pattern
(possibly).</p>

<p style="margin-left:11%; margin-top: 1em">There are many
ways to get multiline data into a string. If you want it to
happen automatically while reading input, you&rsquo;ll want
to set $/ (probably to &rsquo;&rsquo; for paragraphs or
&quot;undef&quot; for the whole file) to allow you to read
more than one line at a time.</p>

<p style="margin-left:11%; margin-top: 1em">Read perlre to
help you decide which of &quot;/s&quot; and &quot;/m&quot;
(or both) you might want to use: &quot;/s&quot; allows dot
to include newline, and &quot;/m&quot; allows caret and
dollar to match next to a newline, not just at the end of
the string. You do need to make sure that you&rsquo;ve
actually got a multiline string in there.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
this program detects duplicate words, even when they span
line breaks (but not paragraph ones). For this example, we
don&rsquo;t need &quot;/s&quot; because we aren&rsquo;t
using dot in a regular expression that we want to cross line
boundaries. Neither do we need &quot;/m&quot; because we
don&rsquo;t want caret or dollar to match at any point
inside the record next to newlines. But it&rsquo;s
imperative that $/ be set to something other than the
default, or else we won&rsquo;t actually ever have a
multiline record read in.</p>

<p style="margin-left:11%; margin-top: 1em">$/ = ''; # read
in whole paragraph, not just one line <br>
while ( &lt;&gt; ) { <br>
while ( /\b([\w'&minus;]+)(\s+\g1)+\b/gi ) { # word starts
alpha <br>
print &quot;Duplicate $1 at paragraph $.\n&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
some code that finds sentences that begin with &quot;From
&quot; (which would be mangled by many mailers):</p>

<p style="margin-left:11%; margin-top: 1em">$/ = ''; # read
in whole paragraph, not just one line <br>
while ( &lt;&gt; ) { <br>
while ( /^From /gm ) { # /m makes ^ match next to \n <br>
print &quot;leading From in paragraph $.\n&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
code that finds everything between <small>START</small> and
<small>END</small> in a paragraph:</p>

<p style="margin-left:11%; margin-top: 1em">undef $/; #
read in whole file, not just one line or paragraph <br>
while ( &lt;&gt; ) { <br>
while ( /START(.*?)END/sgm ) { # /s makes . cross line
boundaries <br>
print &quot;$1\n&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
pull out lines between two patterns that are themselves on
different lines?</b> <br>
You can use Perl&rsquo;s somewhat exotic &quot;..&quot;
operator (documented in perlop):</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;ne
'print if /START/ .. /END/' file1 file2 ...</p>

<p style="margin-left:11%; margin-top: 1em">If you wanted
text and not lines, you would use</p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;0777 &minus;ne 'print &quot;$1\n&quot; while
/START(.*?)END/gs' file1 file2 ...</p>

<p style="margin-left:11%; margin-top: 1em">But if you want
nested occurrences of &quot;START&quot; through
&quot;END&quot;, you&rsquo;ll run up against the problem
described in the question in this section on matching
balanced text.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
another example of using &quot;..&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">while
(&lt;&gt;) { <br>
my $in_header = 1 .. /^$/; <br>
my $in_body = /^$/ .. eof; <br>
# now choose between them <br>
} continue { <br>
$. = 0 if eof; # fix $. <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
match <small>XML, HTML,</small> or other nasty, ugly things
with a regex?</b> <br>
Do not use regexes. Use a module and forget about the
regular expressions. The XML::LibXML, HTML::TokeParser and
HTML::TreeBuilder modules are good starts, although each
namespace has other parsing modules specialized for certain
tasks and different ways of doing it. Start at
<small>CPAN</small> Search ( &lt;http://metacpan.org/&gt; )
and wonder at all the work people have done for you already!
:)</p>

<p style="margin-left:11%; margin-top: 1em"><b>I put a
regular expression into $/ but it didn&rsquo;t work.
What&rsquo;s wrong?</b> <br>
$/ has to be a string. You can use these examples if you
really need to do this.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
File::Stream, this is easy.</p>

<p style="margin-left:11%; margin-top: 1em">use
File::Stream; <br>
my $stream = File::Stream&minus;&gt;new( <br>
$filehandle, <br>
separator =&gt; qr/\s*,\s*/, <br>
); <br>
print &quot;$_\n&quot; while &lt;$stream&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">If you
don&rsquo;t have File::Stream, you have to do a little more
work.</p>

<p style="margin-left:11%; margin-top: 1em">You can use the
four-argument form of sysread to continually add to a
buffer. After you add to the buffer, you check if you have a
complete line (using your regular expression).</p>

<p style="margin-left:11%; margin-top: 1em">local $_ =
&quot;&quot;; <br>
while( sysread FH, $_, 8192, length ) { <br>
while( s/^((?s).*?)your_pattern// ) { <br>
my $record = $1; <br>
# do stuff here. <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">You can do the
same thing with foreach and a match using the c flag and the
\G anchor, if you do not mind your entire file being in
memory at the end.</p>

<p style="margin-left:11%; margin-top: 1em">local $_ =
&quot;&quot;; <br>
while( sysread FH, $_, 8192, length ) { <br>
foreach my $record ( m/\G((?s).*?)your_pattern/gc ) { <br>
# do stuff here. <br>
} <br>
substr( $_, 0, pos ) = &quot;&quot; if pos; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
substitute case-insensitively on the <small>LHS</small>
while preserving case on the <small>RHS</small> ?</b> <br>
Here&rsquo;s a lovely Perlish solution by Larry Rosler. It
exploits properties of bitwise xor on <small>ASCII</small>
strings.</p>

<p style="margin-left:11%; margin-top: 1em">$_= &quot;this
is a TEsT case&quot;; <br>
$old = 'test'; <br>
$new = 'success'; <br>
s{(\Q$old\E)} <br>
{ uc $new | (uc $1 ^ $1) . <br>
(uc(substr $1, &minus;1) ^ substr $1, &minus;1) x <br>
(length($new) &minus; length $1) <br>
}egi; <br>
print;</p>

<p style="margin-left:11%; margin-top: 1em">And here it is
as a subroutine, modeled after the above:</p>

<p style="margin-left:11%; margin-top: 1em">sub
preserve_case { <br>
my ($old, $new) = @_; <br>
my $mask = uc $old ^ $old; <br>
uc $new | $mask . <br>
substr($mask, &minus;1) x (length($new) &minus;
length($old)) <br>
} <br>
$string = &quot;this is a TEsT case&quot;; <br>
$string =~ s/(test)/preserve_case($1,
&quot;success&quot;)/egi; <br>
print &quot;$string\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">This
prints:</p>

<p style="margin-left:11%; margin-top: 1em">this is a
SUcCESS case</p>

<p style="margin-left:11%; margin-top: 1em">As an
alternative, to keep the case of the replacement word if it
is longer than the original, you can use this code, by Jeff
Pinyan:</p>

<p style="margin-left:11%; margin-top: 1em">sub
preserve_case { <br>
my ($from, $to) = @_; <br>
my ($lf, $lt) = map length, @_; <br>
if ($lt &lt; $lf) { $from = substr $from, 0, $lt } <br>
else { $from .= substr $to, $lf } <br>
return uc $to | ($from ^ uc $from); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This changes
the sentence to &quot;this is a SUcCess case.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Just to show
that C programmers can write C in any programming language,
if you prefer a more C&minus;like solution, the following
script makes the substitution have the same case, letter by
letter, as the original. (It also happens to run about 240%
slower than the Perlish solution runs.) If the substitution
has more characters than the string being substituted, the
case of the last character is used for the rest of the
substitution.</p>

<p style="margin-left:11%; margin-top: 1em"># Original by
Nathan Torkington, massaged by Jeffrey Friedl <br>
# <br>
sub preserve_case <br>
{ <br>
my ($old, $new) = @_; <br>
my $state = 0; # 0 = no change; 1 = lc; 2 = uc <br>
my ($i, $oldlen, $newlen, $c) = (0, length($old),
length($new)); <br>
my $len = $oldlen &lt; $newlen ? $oldlen : $newlen; <br>
for ($i = 0; $i &lt; $len; $i++) { <br>
if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) { <br>
$state = 0; <br>
} elsif (lc $c eq $c) { <br>
substr($new, $i, 1) = lc(substr($new, $i, 1)); <br>
$state = 1; <br>
} else { <br>
substr($new, $i, 1) = uc(substr($new, $i, 1)); <br>
$state = 2; <br>
} <br>
} <br>
# finish up with any remaining new (for when new is longer
than old) <br>
if ($newlen &gt; $oldlen) { <br>
if ($state == 1) { <br>
substr($new, $oldlen) = lc(substr($new, $oldlen)); <br>
} elsif ($state == 2) { <br>
substr($new, $oldlen) = uc(substr($new, $oldlen)); <br>
} <br>
} <br>
return $new; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
make &quot;\w&quot; match national character sets?</b> <br>
Put &quot;use locale;&quot; in your script. The \w character
class is taken from the current locale.</p>

<p style="margin-left:11%; margin-top: 1em">See perllocale
for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
match a locale-smart version of
&quot;/[a&minus;zA&minus;Z]/&quot;?</b> <br>
You can use the <small>POSIX</small> character class syntax
&quot;/[[:alpha:]]/&quot; documented in perlre.</p>

<p style="margin-left:11%; margin-top: 1em">No matter which
locale you are in, the alphabetic characters are the
characters in \w without the digits and the underscore. As a
regex, that looks like &quot;/[^\W\d_]/&quot;. Its
complement, the non-alphabetics, is then everything in \W
along with the digits and the underscore, or
&quot;/[\W\d_]/&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
quote a variable to use in a regex?</b> <br>
The Perl parser will expand $variable and @variable
references in regular expressions unless the delimiter is a
single quote. Remember, too, that the right-hand side of a
&quot;s///&quot; substitution is considered a double-quoted
string (see perlop for more details). Remember also that any
regex special characters will be acted on unless you precede
the substitution with \Q. Here&rsquo;s an example:</p>

<p style="margin-left:11%; margin-top: 1em">$string =
&quot;Placido P. Octopus&quot;; <br>
$regex = &quot;P.&quot;; <br>
$string =~ s/$regex/Polyp/; <br>
# $string is now &quot;Polypacido P. Octopus&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Because
&quot;.&quot; is special in regular expressions, and can
match any single character, the regex &quot;P.&quot; here
has matched the &lt;Pl&gt; in the original string.</p>

<p style="margin-left:11%; margin-top: 1em">To escape the
special meaning of &quot;.&quot;, we use &quot;\Q&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">$string =
&quot;Placido P. Octopus&quot;; <br>
$regex = &quot;P.&quot;; <br>
$string =~ s/\Q$regex/Polyp/; <br>
# $string is now &quot;Placido Polyp Octopus&quot;</p>

<p style="margin-left:11%; margin-top: 1em">The use of
&quot;\Q&quot; causes the &quot;.&quot; in the regex to be
treated as a regular character, so that &quot;P.&quot;
matches a &quot;P&quot; followed by a dot.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What is
&quot;/o&quot; really for?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;/o&quot; option for regular expressions (documented in
perlop and perlreref) tells Perl to compile the regular
expression only once. This is only useful when the pattern
contains a variable. Perls 5.6 and later handle this
automatically if the pattern does not change.</p>

<p style="margin-left:11%; margin-top: 1em">Since the match
operator &quot;m//&quot;, the substitution operator
&quot;s///&quot;, and the regular expression quoting
operator &quot;qr//&quot; are double-quotish constructs, you
can interpolate variables into the pattern. See the answer
to &quot;How can I quote a variable to use in a regex?&quot;
for more details.</p>

<p style="margin-left:11%; margin-top: 1em">This example
takes a regular expression from the argument list and prints
the lines of input that match it:</p>

<p style="margin-left:11%; margin-top: 1em">my $pattern =
shift @ARGV; <br>
while( &lt;&gt; ) { <br>
print if m/$pattern/; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Versions of
Perl prior to 5.6 would recompile the regular expression for
each iteration, even if $pattern had not changed. The
&quot;/o&quot; would prevent this by telling Perl to compile
the pattern the first time, then reuse that for subsequent
iterations:</p>

<p style="margin-left:11%; margin-top: 1em">my $pattern =
shift @ARGV; <br>
while( &lt;&gt; ) { <br>
print if m/$pattern/o; # useful for Perl &lt; 5.6 <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">In versions 5.6
and later, Perl won&rsquo;t recompile the regular expression
if the variable hasn&rsquo;t changed, so you probably
don&rsquo;t need the &quot;/o&quot; option. It doesn&rsquo;t
hurt, but it doesn&rsquo;t help either. If you want any
version of Perl to compile the regular expression only once
even if the variable changes (thus, only using its initial
value), you still need the &quot;/o&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You can watch
Perl&rsquo;s regular expression engine at work to verify for
yourself if Perl is recompiling a regular expression. The
&quot;use re 'debug'&quot; pragma (comes with Perl 5.005 and
later) shows the details. With Perls before 5.6, you should
see &quot;re&quot; reporting that its compiling the regular
expression on each iteration. With Perl 5.6 or later, you
should only see &quot;re&quot; report that for the first
iteration.</p>

<p style="margin-left:11%; margin-top: 1em">use re 'debug';
<br>
my $regex = 'Perl'; <br>
foreach ( qw(Perl Java Ruby Python) ) { <br>
print STDERR &quot;&minus;&quot; x 73, &quot;\n&quot;; <br>
print STDERR &quot;Trying $_...\n&quot;; <br>
print STDERR &quot;\t$_ is good!\n&quot; if m/$regex/; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I use
a regular expression to strip C&minus;style comments from a
file?</b> <br>
While this actually can be done, it&rsquo;s much harder than
you&rsquo;d think. For example, this one-liner</p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;0777 &minus;pe 's{/\*.*?\*/}{}gs' foo.c</p>

<p style="margin-left:11%; margin-top: 1em">will work in
many but not all cases. You see, it&rsquo;s too
simple-minded for certain kinds of C programs, in
particular, those with what appear to be comments in quoted
strings. For that, you&rsquo;d need something like this,
created by Jeffrey Friedl and later modified by Fred
Curtis.</p>

<p style="margin-left:11%; margin-top: 1em">$/ = undef;
<br>
$_ = &lt;&gt;; <br>

s#/\*[^*]*\*+([^/*][^*]*\*+)*/|(&quot;(\\.|[^&quot;\\])*&quot;|'(\\.|[^'\\])*'|.[^/&quot;'\\]*)#defined
$2 ? $2 : &quot;&quot;#gse; <br>
print;</p>

<p style="margin-left:11%; margin-top: 1em">This could, of
course, be more legibly written with the &quot;/x&quot;
modifier, adding whitespace and comments. Here it is
expanded, courtesy of Fred Curtis.</p>

<p style="margin-left:11%; margin-top: 1em">s{ <br>
/\* ## Start of /* ... */ comment <br>
[^*]*\*+ ## Non&minus;* followed by 1&minus;or&minus;more
*'s <br>
( <br>
[^/*][^*]*\*+ <br>
)* ## 0&minus;or&minus;more things which don't start with /
<br>
## but do end with '*' <br>
/ ## End of /* ... */ comment <br>
| ## OR various things which aren't comments: <br>
( <br>
&quot; ## Start of &quot; ... &quot; string <br>
( <br>
\\. ## Escaped char <br>
| ## OR <br>
[^&quot;\\] ## Non &quot;\ <br>
)* <br>
&quot; ## End of &quot; ... &quot; string <br>
| ## OR <br>
' ## Start of ' ... ' string <br>
( <br>
\\. ## Escaped char <br>
| ## OR <br>
[^'\\] ## Non '\ <br>
)* <br>
' ## End of ' ... ' string <br>
| ## OR <br>
. ## Anything other char <br>
[^/&quot;'\\]* ## Chars which doesn't start a comment,
string or escape <br>
) <br>
}{defined $2 ? $2 : &quot;&quot;}gxse;</p>

<p style="margin-left:11%; margin-top: 1em">A slight
modification also removes C <small>++</small> comments,
possibly spanning multiple lines using a continuation
character:</p>


<p style="margin-left:11%; margin-top: 1em">s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//([^\\]|[^\n][\n]?)*?\n|(&quot;(\\.|[^&quot;\\])*&quot;|'(\\.|[^'\\])*'|.[^/&quot;'\\]*)#defined
$3 ? $3 : &quot;&quot;#gse;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Can I use
Perl regular expressions to match balanced text?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">Your first try
should probably be the Text::Balanced module, which is in
the Perl standard library since Perl 5.8. It has a variety
of functions to deal with tricky text. The Regexp::Common
module can also help by providing canned patterns you can
use.</p>

<p style="margin-left:11%; margin-top: 1em">As of Perl
5.10, you can match balanced text with regular expressions
using recursive patterns. Before Perl 5.10, you had to
resort to various tricks such as using Perl code in
&quot;(??{})&quot; sequences.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s an
example using a recursive regular expression. The goal is to
capture all of the text within angle brackets, including the
text in nested angle brackets. This sample text has two
&quot;major&quot; groups: a group with one level of nesting
and a group with two levels of nesting. There are five total
groups in angle brackets:</p>

<p style="margin-left:11%; margin-top: 1em">I have some
&lt;brackets in &lt;nested brackets&gt; &gt; and <br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt; <br>
and that's it.</p>

<p style="margin-left:11%; margin-top: 1em">The regular
expression to match the balanced text uses two new (to Perl
5.10) regular expression features. These are covered in
perlre and this example is a modified version of one in that
documentation.</p>

<p style="margin-left:11%; margin-top: 1em">First, adding
the new possessive &quot;+&quot; to any quantifier finds the
longest match and does not backtrack. That&rsquo;s important
since you want to handle any angle brackets through the
recursion, not backtracking. The group
&quot;[^&lt;&gt;]++&quot; finds one or more non-angle
brackets without backtracking.</p>

<p style="margin-left:11%; margin-top: 1em">Second, the new
&quot;(?PARNO)&quot; refers to the sub-pattern in the
particular capture group given by &quot;PARNO&quot;. In the
following regex, the first capture group finds (and
remembers) the balanced text, and you need that same pattern
within the first buffer to get past the nested text.
That&rsquo;s the recursive part. The &quot;(?1)&quot; uses
the pattern in the outer capture group as an independent
part of the regex.</p>

<p style="margin-left:11%; margin-top: 1em">Putting it all
together, you have:</p>


<p style="margin-left:11%; margin-top: 1em">#!/usr/local/bin/perl5.10.0
<br>
my $string =&lt;&lt;&quot;HERE&quot;; <br>
I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
<br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt; <br>
and that's it. <br>
HERE <br>
my @groups = $string =~ m/ <br>
( # start of capture group 1 <br>
&lt; # match an opening angle bracket <br>
(?: <br>
[^&lt;&gt;]++ # one or more non angle brackets, non
backtracking <br>
| <br>
(?1) # found &lt; or &gt;, so recurse to capture group 1
<br>
)* <br>
&gt; # match a closing angle bracket <br>
) # end of capture group 1 <br>
/xg; <br>
$&quot; = &quot;\n\t&quot;; <br>
print &quot;Found:\n\t@groups\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">The output
shows that Perl found the two major groups:</p>

<p style="margin-left:11%; margin-top: 1em">Found: <br>
&lt;brackets in &lt;nested brackets&gt; &gt; <br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt;</p>

<p style="margin-left:11%; margin-top: 1em">With a little
extra work, you can get all of the groups in angle brackets
even if they are in other angle brackets too. Each time you
get a balanced match, remove its outer delimiter
(that&rsquo;s the one you just matched so don&rsquo;t match
it again) and add it to a queue of strings to process. Keep
doing that until you get no matches:</p>


<p style="margin-left:11%; margin-top: 1em">#!/usr/local/bin/perl5.10.0
<br>
my @queue =&lt;&lt;&quot;HERE&quot;; <br>
I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
<br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt; <br>
and that's it. <br>
HERE <br>
my $regex = qr/ <br>
( # start of bracket 1 <br>
&lt; # match an opening angle bracket <br>
(?: <br>
[^&lt;&gt;]++ # one or more non angle brackets, non
backtracking <br>
| <br>
(?1) # recurse to bracket 1 <br>
)* <br>
&gt; # match a closing angle bracket <br>
) # end of bracket 1 <br>
/x; <br>
$&quot; = &quot;\n\t&quot;; <br>
while( @queue ) { <br>
my $string = shift @queue; <br>
my @groups = $string =~ m/$regex/g; <br>
print &quot;Found:\n\t@groups\n\n&quot; if @groups; <br>
unshift @queue, map { s/^&lt;//; s/&gt;$//; $_ } @groups;
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The output
shows all of the groups. The outermost matches show up first
and the nested matches show up later:</p>

<p style="margin-left:11%; margin-top: 1em">Found: <br>
&lt;brackets in &lt;nested brackets&gt; &gt; <br>
&lt;another group &lt;nested once &lt;nested twice&gt; &gt;
&gt; <br>
Found: <br>
&lt;nested brackets&gt; <br>
Found: <br>
&lt;nested once &lt;nested twice&gt; &gt; <br>
Found: <br>
&lt;nested twice&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>What does it
mean that regexes are greedy? How can I get around it?</b>
<br>
Most people mean that greedy regexes match as much as they
can. Technically speaking, it&rsquo;s actually the
quantifiers (&quot;?&quot;, &quot;*&quot;, &quot;+&quot;,
&quot;{}&quot;) that are greedy rather than the whole
pattern; Perl prefers local greed and immediate
gratification to overall greed. To get non-greedy versions
of the same quantifiers, use (&quot;??&quot;,
&quot;*?&quot;, &quot;+?&quot;, &quot;{}?&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">An example:</p>

<p style="margin-left:11%; margin-top: 1em">my $s1 = my $s2
= &quot;I am very very cold&quot;; <br>
$s1 =~ s/ve.*y //; # I am cold <br>
$s2 =~ s/ve.*?y //; # I am very cold</p>

<p style="margin-left:11%; margin-top: 1em">Notice how the
second substitution stopped matching as soon as it
encountered &quot;y &quot;. The &quot;*?&quot; quantifier
effectively tells the regular expression engine to find a
match as quickly as possible and pass control on to whatever
is next in line, as you would if you were playing hot
potato.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
process each word on each line?</b> <br>
Use the split function:</p>

<p style="margin-left:11%; margin-top: 1em">while
(&lt;&gt;) { <br>
foreach my $word ( split ) { <br>
# do something with $word here <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
isn&rsquo;t really a word in the English sense; it&rsquo;s
just chunks of consecutive non-whitespace characters.</p>

<p style="margin-left:11%; margin-top: 1em">To work with
only alphanumeric sequences (including underscores), you
might consider</p>

<p style="margin-left:11%; margin-top: 1em">while
(&lt;&gt;) { <br>
foreach $word (m/(\w+)/g) { <br>
# do something with $word here <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
print out a word-frequency or line-frequency summary?</b>
<br>
To do this, you have to parse out each word in the input
stream. We&rsquo;ll pretend that by word you mean chunk of
alphabetics, hyphens, or apostrophes, rather than the
non-whitespace chunk idea of a word given in the previous
question:</p>

<p style="margin-left:11%; margin-top: 1em">my (%seen);
<br>
while (&lt;&gt;) { <br>
while ( /(\b[^\W_\d][\w'&minus;]+\b)/g ) { # misses
&quot;`sheep'&quot; <br>
$seen{$1}++; <br>
} <br>
} <br>
while ( my ($word, $count) = each %seen ) { <br>
print &quot;$count $word\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If you wanted
to do the same thing for lines, you wouldn&rsquo;t need a
regular expression:</p>

<p style="margin-left:11%; margin-top: 1em">my (%seen);
<br>
while (&lt;&gt;) { <br>
$seen{$_}++; <br>
} <br>
while ( my ($line, $count) = each %seen ) { <br>
print &quot;$count $line&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If you want
these output in a sorted order, see perlfaq4: &quot;How do I
sort a hash (optionally by value instead of key)?&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I do
approximate matching?</b> <br>
See the module String::Approx available from
<small>CPAN.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
efficiently match many regular expressions at once?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">You want to
avoid compiling a regular expression every time you want to
match it. In this example, perl must recompile the regular
expression for every iteration of the &quot;foreach&quot;
loop since $pattern can change:</p>

<p style="margin-left:11%; margin-top: 1em">my @patterns =
qw( fo+ ba[rz] ); <br>
LINE: while( my $line = &lt;&gt; ) { <br>
foreach my $pattern ( @patterns ) { <br>
if( $line =~ m/\b$pattern\b/i ) { <br>
print $line; <br>
next LINE; <br>
} <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;qr//&quot; operator compiles a regular expression, but
doesn&rsquo;t apply it. When you use the pre-compiled
version of the regex, perl does less work. In this example,
I inserted a &quot;map&quot; to turn each pattern into its
pre-compiled form. The rest of the script is the same, but
faster:</p>

<p style="margin-left:11%; margin-top: 1em">my @patterns =
map { qr/\b$_\b/i } qw( fo+ ba[rz] ); <br>
LINE: while( my $line = &lt;&gt; ) { <br>
foreach my $pattern ( @patterns ) { <br>
if( $line =~ m/$pattern/ ) { <br>
print $line; <br>
next LINE; <br>
} <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">In some cases,
you may be able to make several patterns into a single
regular expression. Beware of situations that require
backtracking though. In this example, the regex is only
compiled once because $regex doesn&rsquo;t change between
iterations:</p>

<p style="margin-left:11%; margin-top: 1em">my $regex =
join '|', qw( fo+ ba[rz] ); <br>
while( my $line = &lt;&gt; ) { <br>
print if $line =~ m/\b(?:$regex)\b/i; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The function
&quot;list2re&quot; in Data::Munge on <small>CPAN</small>
can also be used to form a single regex that matches a list
of literal strings (not regexes).</p>

<p style="margin-left:11%; margin-top: 1em">For more
details on regular expression efficiency, see <i>Mastering
Regular Expressions</i> by Jeffrey Friedl. He explains how
the regular expressions engine works and why some patterns
are surprisingly inefficient. Once you understand how perl
applies regular expressions, you can tune them for
individual situations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why
don&rsquo;t word-boundary searches with &quot;\b&quot; work
for me?</b> <br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">Ensure that you
know what \b really does: it&rsquo;s the boundary between a
word character, \w, and something that isn&rsquo;t a word
character. That thing that isn&rsquo;t a word character
might be \W, but it can also be the start or end of the
string.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s not
(not!) the boundary between whitespace and non-whitespace,
and it&rsquo;s not the stuff between words we use to create
sentences.</p>

<p style="margin-left:11%; margin-top: 1em">In regex speak,
a word boundary (\b) is a &quot;zero width assertion&quot;,
meaning that it doesn&rsquo;t represent a character in the
string, but a condition at a certain position.</p>

<p style="margin-left:11%; margin-top: 1em">For the regular
expression, /\bPerl\b/, there has to be a word boundary
before the &quot;P&quot; and after the &quot;l&quot;. As
long as something other than a word character precedes the
&quot;P&quot; and succeeds the &quot;l&quot;, the pattern
will match. These strings match /\bPerl\b/.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Perl&quot;
# no word char before &quot;P&quot; or after &quot;l&quot;
<br>
&quot;Perl &quot; # same as previous (space is not a word
char) <br>
&quot;'Perl'&quot; # the &quot;'&quot; char is not a word
char <br>
&quot;Perl's&quot; # no word char before &quot;P&quot;,
non&minus;word char after &quot;l&quot;</p>

<p style="margin-left:11%; margin-top: 1em">These strings
do not match /\bPerl\b/.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Perl_&quot;
# &quot;_&quot; is a word char! <br>
&quot;Perler&quot; # no word char before &quot;P&quot;, but
one after &quot;l&quot;</p>

<p style="margin-left:11%; margin-top: 1em">You don&rsquo;t
have to use \b to match words though. You can look for
non-word characters surrounded by word characters. These
strings match the pattern /\b&rsquo;\b/.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;don't&quot;
# the &quot;'&quot; char is surrounded by &quot;n&quot; and
&quot;t&quot; <br>
&quot;qep'a'&quot; # the &quot;'&quot; char is surrounded by
&quot;p&quot; and &quot;a&quot;</p>

<p style="margin-left:11%; margin-top: 1em">These strings
do not match /\b&rsquo;\b/.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;foo'&quot;
# there is no word char after non&minus;word
&quot;'&quot;</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use the complement of \b, \B, to specify that there should
not be a word boundary.</p>

<p style="margin-left:11%; margin-top: 1em">In the pattern
/\Bam\B/, there must be a word character before the
&quot;a&quot; and after the &quot;m&quot;. These patterns
match /\Bam\B/:</p>


<p style="margin-left:11%; margin-top: 1em">&quot;llama&quot;
# &quot;am&quot; surrounded by word chars <br>
&quot;Samuel&quot; # same</p>

<p style="margin-left:11%; margin-top: 1em">These strings
do not match /\Bam\B/</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Sam&quot;
# no word boundary before &quot;a&quot;, but one after
&quot;m&quot; <br>
&quot;I am Sam&quot; # &quot;am&quot; surrounded by
non&minus;word chars</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why does
using $&amp;, $&lsquo;, or $&rsquo; slow my program
down?</b> <br>
(contributed by Anno Siegel)</p>

<p style="margin-left:11%; margin-top: 1em">Once Perl sees
that you need one of these variables anywhere in the
program, it provides them on each and every pattern match.
That means that on every pattern match the entire string
will be copied, part of it to $&lsquo;, part to $&amp;, and
part to $&rsquo;. Thus the penalty is most severe with long
strings and patterns that match often. Avoid $&amp;,
$&rsquo;, and $&lsquo; if you can, but if you can&rsquo;t,
once you&rsquo;ve used them at all, use them at will because
you&rsquo;ve already paid the price. Remember that some
algorithms really appreciate them. As of the 5.005 release,
the $&amp; variable is no longer &quot;expensive&quot; the
way the other two are.</p>

<p style="margin-left:11%; margin-top: 1em">Since Perl
5.6.1 the special variables @&minus; and @+ can functionally
replace $&lsquo;, $&amp; and $&rsquo;. These arrays contain
pointers to the beginning and end of each match (see perlvar
for the full story), so they give you essentially the same
information, but without the risk of excessive string
copying.</p>

<p style="margin-left:11%; margin-top: 1em">Perl 5.10 added
three specials, &quot;${^MATCH}&quot;,
&quot;${^PREMATCH}&quot;, and &quot;${^POSTMATCH}&quot; to
do the same job but without the global performance penalty.
Perl 5.10 only sets these variables if you compile or
execute the regular expression with the &quot;/p&quot;
modifier.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What good is
&quot;\G&quot; in a regular expression?</b> <br>
You use the &quot;\G&quot; anchor to start the next match on
the same string where the last match left off. The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so &quot;\G&quot; is
similar to the beginning of string anchor, &quot;^&quot;.
The &quot;\G&quot; anchor is typically used with the
&quot;g&quot; modifier. It uses the value of
&quot;pos()&quot; as the position to start the next match.
As the match operator makes successive matches, it updates
&quot;pos()&quot; with the position of the next character
past the last match (or the first character of the next
match, depending on how you like to look at it). Each string
has its own &quot;pos()&quot; value.</p>

<p style="margin-left:11%; margin-top: 1em">Suppose you
want to match all of consecutive pairs of digits in a string
like &quot;1122a44&quot; and stop matching when you
encounter non-digits. You want to match 11 and 22 but the
letter &quot;a&quot; shows up between 22 and 44 and you want
to stop at &quot;a&quot;. Simply matching pairs of digits
skips over the &quot;a&quot; and still matches 44.</p>

<p style="margin-left:11%; margin-top: 1em">$_ =
&quot;1122a44&quot;; <br>
my @pairs = m/(\d\d)/g; # qw( 11 22 44 )</p>

<p style="margin-left:11%; margin-top: 1em">If you use the
&quot;\G&quot; anchor, you force the match after 22 to start
with the &quot;a&quot;. The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.</p>

<p style="margin-left:11%; margin-top: 1em">$_ =
&quot;1122a44&quot;; <br>
my @pairs = m/\G(\d\d)/g; # qw( 11 22 )</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use the &quot;\G&quot; anchor in scalar context. You still
need the &quot;g&quot; modifier.</p>

<p style="margin-left:11%; margin-top: 1em">$_ =
&quot;1122a44&quot;; <br>
while( m/\G(\d\d)/g ) { <br>
print &quot;Found $1\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">After the match
fails at the letter &quot;a&quot;, perl resets
&quot;pos()&quot; and the next match on the same string
starts at the beginning.</p>

<p style="margin-left:11%; margin-top: 1em">$_ =
&quot;1122a44&quot;; <br>
while( m/\G(\d\d)/g ) { <br>
print &quot;Found $1\n&quot;; <br>
} <br>
print &quot;Found $1 after while&quot; if m/(\d\d)/g; #
finds &quot;11&quot;</p>

<p style="margin-left:11%; margin-top: 1em">You can disable
&quot;pos()&quot; resets on fail with the &quot;c&quot;
modifier, documented in perlop and perlreref. Subsequent
matches start where the last successful match ended (the
value of &quot;pos()&quot;) even if a match on the same
string has failed in the meantime. In this case, the match
after the &quot;while()&quot; loop starts at the
&quot;a&quot; (where the last match stopped), and since it
does not use any anchor it can skip over the &quot;a&quot;
to find 44.</p>

<p style="margin-left:11%; margin-top: 1em">$_ =
&quot;1122a44&quot;; <br>
while( m/\G(\d\d)/gc ) { <br>
print &quot;Found $1\n&quot;; <br>
} <br>
print &quot;Found $1 after while&quot; if m/(\d\d)/g; #
finds &quot;44&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Typically you
use the &quot;\G&quot; anchor with the &quot;c&quot;
modifier when you want to try a different match if one
fails, such as in a tokenizer. Jeffrey Friedl offers this
example which works in 5.004 or later.</p>

<p style="margin-left:11%; margin-top: 1em">while
(&lt;&gt;) { <br>
chomp; <br>
PARSER: { <br>
m/ \G( \d+\b )/gcx &amp;&amp; do { print &quot;number:
$1\n&quot;; redo; }; <br>
m/ \G( \w+ )/gcx &amp;&amp; do { print &quot;word:
$1\n&quot;; redo; }; <br>
m/ \G( \s+ )/gcx &amp;&amp; do { print &quot;space:
$1\n&quot;; redo; }; <br>
m/ \G( [^\w\d]+ )/gcx &amp;&amp; do { print &quot;other:
$1\n&quot;; redo; }; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">For each line,
the &quot;PARSER&quot; loop first tries to match a series of
digits followed by a word boundary. This match has to start
at the place the last match left off (or the beginning of
the string on the first match). Since &quot;m/ \G( \d+\b
)/gcx&quot; uses the &quot;c&quot; modifier, if the string
does not match that regular expression, perl does not reset
<b>pos()</b> and the next match starts at the same position
to try a different pattern.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Are Perl
regexes DFAs or NFAs? Are they <small>POSIX</small>
compliant?</b> <br>
While it&rsquo;s true that Perl&rsquo;s regular expressions
resemble the DFAs (deterministic finite automata) of the
<b>egrep</b>(1) program, they are in fact implemented as
NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing. And they aren&rsquo;t
POSIX-style either, because those guarantee worst-case
behavior for all cases. (It seems that some people prefer
guarantees of consistency, even when what&rsquo;s guaranteed
is slowness.) See the book &quot;Mastering Regular
Expressions&quot; (from O&rsquo;Reilly) by Jeffrey Friedl
for all the details you could ever hope to know on these
matters (a full citation appears in perlfaq2).</p>


<p style="margin-left:11%; margin-top: 1em"><b>What&rsquo;s
wrong with using grep in a void context?</b> <br>
The problem is that grep builds a return list, regardless of
the context. This means you&rsquo;re making Perl go to the
trouble of building a list that you then just throw away. If
the list is large, you waste both time and space. If your
intent is to iterate over the list, then use a for loop for
this purpose.</p>

<p style="margin-left:11%; margin-top: 1em">In perls older
than 5.8.1, map suffers from this problem as well. But since
5.8.1, this has been fixed, and map is context aware &minus;
in void context, no lists are constructed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
match strings with multibyte characters?</b> <br>
Starting from Perl 5.6 Perl has had some level of multibyte
character support. Perl 5.8 or later is recommended.
Supported multibyte character repertoires include Unicode,
and legacy encodings through the Encode module. See
perluniintro, perlunicode, and Encode.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
stuck with older Perls, you can do Unicode with the
Unicode::String module, and character conversions using the
Unicode::Map8 and Unicode::Map modules. If you are using
Japanese encodings, you might try using the jperl
5.005_03.</p>

<p style="margin-left:11%; margin-top: 1em">Finally, the
following set of approaches was offered by Jeffrey Friedl,
whose article in issue #5 of The Perl Journal talks about
this very matter.</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
suppose you have some weird Martian encoding where pairs of
<small>ASCII</small> uppercase letters encode single Martian
letters (i.e. the two bytes &quot; <small>CV&quot;</small>
make a single Martian letter, as do the two bytes &quot;
<small>SG&quot;, &quot;VS&quot;, &quot;XX&quot;,</small>
etc.). Other bytes represent single characters, just like
<small>ASCII.</small></p>

<p style="margin-left:11%; margin-top: 1em">So, the string
of Martian &quot;I am <small>CVSGXX</small> !&quot; uses 12
bytes to encode the nine characters &rsquo;I&rsquo;, &rsquo;
&rsquo;, &rsquo;a&rsquo;, &rsquo;m&rsquo;, &rsquo; &rsquo;,
&rsquo; <small>CV</small> &rsquo;, &rsquo; <small>SG</small>
&rsquo;, &rsquo; <small>XX</small> &rsquo;,
&rsquo;!&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">Now, say you
want to search for the single character &quot;/GX/&quot;.
Perl doesn&rsquo;t know about Martian, so it&rsquo;ll find
the two bytes &quot; <small>GX&quot;</small> in the &quot;I
am <small>CVSGXX</small> !&quot; string, even though that
character isn&rsquo;t there: it just looks like it is
because &quot; <small>SG&quot;</small> is next to &quot;
<small>XX&quot;,</small> but there&rsquo;s no real &quot;
<small>GX&quot;.</small> This is a big problem.</p>

<p style="margin-left:11%; margin-top: 1em">Here are a few
ways, all painful, to deal with it:</p>

<p style="margin-left:11%; margin-top: 1em"># Make sure
adjacent &quot;martian&quot; bytes are no longer adjacent.
<br>
$martian =~ s/([A&minus;Z][A&minus;Z])/ $1 /g; <br>
print &quot;found GX!\n&quot; if $martian =~ /GX/;</p>

<p style="margin-left:11%; margin-top: 1em">Or like
this:</p>

<p style="margin-left:11%; margin-top: 1em">my @chars =
$martian =~ m/([A&minus;Z][A&minus;Z]|[^A&minus;Z])/g; <br>
# above is conceptually similar to: my @chars = $text =~
m/(.)/g; <br>
# <br>
foreach my $char (@chars) { <br>
print &quot;found GX!\n&quot;, last if $char eq 'GX'; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Or like
this:</p>

<p style="margin-left:11%; margin-top: 1em">while ($martian
=~ m/\G([A&minus;Z][A&minus;Z]|.)/gs) { # \G probably
unneeded <br>
if ($1 eq 'GX') { <br>
print &quot;found GX!\n&quot;; <br>
last; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
another, slightly less painful, way to do it from Benjamin
Goldberg, who uses a zero-width negative look-behind
assertion.</p>

<p style="margin-left:11%; margin-top: 1em">print
&quot;found GX!\n&quot; if $martian =~ m/ <br>
(?&lt;![A&minus;Z]) <br>
(?:[A&minus;Z][A&minus;Z])*? <br>
GX <br>
/x;</p>

<p style="margin-left:11%; margin-top: 1em">This succeeds
if the &quot;martian&quot; character <small>GX</small> is in
the string, and fails otherwise. If you don&rsquo;t like
using (?&lt;!), a zero-width negative look-behind assertion,
you can replace (?&lt;![A&minus;Z]) with
(?:^|[^A&minus;Z]).</p>

<p style="margin-left:11%; margin-top: 1em">It does have
the drawback of putting the wrong thing in $&minus;[0] and
$+[0], but this usually can be worked around.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How do I
match a regular expression that&rsquo;s in a variable?</b>
<br>
(contributed by brian d foy)</p>

<p style="margin-left:11%; margin-top: 1em">We don&rsquo;t
have to hard-code patterns into the match operator (or
anything else that works with regular expressions). We can
put the pattern in a variable for later use.</p>

<p style="margin-left:11%; margin-top: 1em">The match
operator is a double quote context, so you can interpolate
your variable just like a double quoted string. In this
case, you read the regular expression as user input and
store it in $regex. Once you have the pattern in $regex, you
use that variable in the match operator.</p>

<p style="margin-left:11%; margin-top: 1em">chomp( my
$regex = &lt;STDIN&gt; ); <br>
if( $string =~ m/$regex/ ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">Any regular
expression special characters in $regex are still special,
and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired
parenthesis.</p>

<p style="margin-left:11%; margin-top: 1em">my $regex =
&quot;Unmatched ( paren&quot;; <br>
&quot;Two parens to bind them all&quot; =~ m/$regex/;</p>

<p style="margin-left:11%; margin-top: 1em">When Perl
compiles the regular expression, it treats the parenthesis
as the start of a memory match. When it doesn&rsquo;t find
the closing parenthesis, it complains:</p>

<p style="margin-left:11%; margin-top: 1em">Unmatched ( in
regex; marked by &lt;&minus;&minus; HERE in m/Unmatched (
&lt;&minus;&minus; HERE paren/ at script line 3.</p>

<p style="margin-left:11%; margin-top: 1em">You can get
around this in several ways depending on our situation.
First, if you don&rsquo;t want any of the characters in the
string to be special, you can escape them with
&quot;quotemeta&quot; before you use the string.</p>

<p style="margin-left:11%; margin-top: 1em">chomp( my
$regex = &lt;STDIN&gt; ); <br>
$regex = quotemeta( $regex ); <br>
if( $string =~ m/$regex/ ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">You can also do
this directly in the match operator using the &quot;\Q&quot;
and &quot;\E&quot; sequences. The &quot;\Q&quot; tells Perl
where to start escaping special characters, and the
&quot;\E&quot; tells it where to stop (see perlop for more
details).</p>

<p style="margin-left:11%; margin-top: 1em">chomp( my
$regex = &lt;STDIN&gt; ); <br>
if( $string =~ m/\Q$regex\E/ ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">Alternately,
you can use &quot;qr//&quot;, the regular expression quote
operator (see perlop for more details). It quotes and
perhaps compiles the pattern, and you can apply regular
expression flags to the pattern.</p>

<p style="margin-left:11%; margin-top: 1em">chomp( my
$input = &lt;STDIN&gt; ); <br>
my $regex = qr/$input/is; <br>
$string =~ m/$regex/ # same as m/$input/is;</p>

<p style="margin-left:11%; margin-top: 1em">You might also
want to trap any errors by wrapping an &quot;eval&quot;
block around the whole thing.</p>

<p style="margin-left:11%; margin-top: 1em">chomp( my
$input = &lt;STDIN&gt; ); <br>
eval { <br>
if( $string =~ m/\Q$input\E/ ) { ... } <br>
}; <br>
warn $@ if $@;</p>

<p style="margin-left:11%; margin-top: 1em">Or...</p>

<p style="margin-left:11%; margin-top: 1em">my $regex =
eval { qr/$input/is }; <br>
if( defined $regex ) { <br>
$string =~ m/$regex/; <br>
} <br>
else { <br>
warn $@; <br>
}</p>

<h2>AUTHOR AND COPYRIGHT
<a name="AUTHOR AND COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1997&minus;2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This
documentation is free; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>

<p style="margin-left:11%; margin-top: 1em">Irrespective of
its distribution, all code examples in this file are hereby
placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun or
for profit as you see fit. A simple comment in the code
giving credit would be courteous but is not required.</p>
<hr>
</body>
</html>
