<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:00 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLTIE</title>

</head>
<body>
<h1>perltie</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perltie &minus;
how to hide an object class in a simple variable</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">tie VARIABLE,
CLASSNAME, LIST <br>
$object = tied VARIABLE <br>
untie VARIABLE</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Prior to
release 5.0 of Perl, a programmer could use <b>dbmopen()</b>
to connect an on-disk database in the standard Unix
<b>dbm</b>(3x) format magically to a %HASH in their program.
However, their Perl was either built with one particular dbm
library or another, but not both, and you couldn&rsquo;t
extend this mechanism to other packages or types of
variables.</p>

<p style="margin-left:11%; margin-top: 1em">Now you
can.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>tie()</b> function binds a variable to a class (package)
that will provide the implementation for access methods for
that variable. Once this magic has been performed, accessing
a tied variable automatically triggers method calls in the
proper class. The complexity of the class is hidden behind
magic methods calls. The method names are in <small>ALL
CAPS,</small> which is a convention that Perl uses to
indicate that they&rsquo;re called implicitly rather than
explicitly--just like the <b><small>BEGIN</small> ()</b> and
<b><small>END</small> ()</b> functions.</p>

<p style="margin-left:11%; margin-top: 1em">In the
<b>tie()</b> call, &quot;VARIABLE&quot; is the name of the
variable to be enchanted. &quot;CLASSNAME&quot; is the name
of a class implementing objects of the correct type. Any
additional arguments in the &quot;LIST&quot; are passed to
the appropriate constructor method for that class--meaning
<b><small>TIESCALAR</small> ()</b>,
<b><small>TIEARRAY</small> ()</b>, <b><small>TIEHASH</small>
()</b>, or <b><small>TIEHANDLE</small> ()</b>. (Typically
these are arguments such as might be passed to the
<b>dbminit()</b> function of C.) The object returned by the
&quot;new&quot; method is also returned by the <b>tie()</b>
function, which would be useful if you wanted to access
other methods in &quot;CLASSNAME&quot;. (You don&rsquo;t
actually have to return a reference to a right
&quot;type&quot; (e.g., <small>HASH</small> or
&quot;CLASSNAME&quot;) so long as it&rsquo;s a properly
blessed object.) You can also retrieve a reference to the
underlying object using the <b>tied()</b> function.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike
<b>dbmopen()</b>, the <b>tie()</b> function will not
&quot;use&quot; or &quot;require&quot; a module for you--you
need to do that explicitly yourself.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tying
Scalars</b> <br>
A class implementing a tied scalar should define the
following methods: <small>TIESCALAR, FETCH, STORE,</small>
and possibly <small>UNTIE</small> and/or
<small>DESTROY.</small></p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
look at each in turn, using as an example a tie class for
scalars that allows the user to do something like:</p>

<p style="margin-left:11%; margin-top: 1em">tie $his_speed,
'Nice', getppid(); <br>
tie $my_speed, 'Nice', $$;</p>

<p style="margin-left:11%; margin-top: 1em">And now
whenever either of those variables is accessed, its current
system priority is retrieved and returned. If those
variables are set, then the process&rsquo;s priority is
changed!</p>

<p style="margin-left:11%; margin-top: 1em">We&rsquo;ll use
Jarkko Hietaniemi &lt;<i>jhi@iki.fi</i>&gt;&rsquo;s
BSD::Resource class (not included) to access the
<small>PRIO_PROCESS, PRIO_MIN,</small> and
<small>PRIO_MAX</small> constants from your system, as well
as the <b>getpriority()</b> and <b>setpriority()</b> system
calls. Here&rsquo;s the preamble of the class.</p>

<p style="margin-left:11%; margin-top: 1em">package Nice;
<br>
use Carp; <br>
use BSD::Resource; <br>
use strict; <br>
$Nice::DEBUG = 0 unless defined $Nice::DEBUG; <small><br>
TIESCALAR</small> classname, <small>LIST</small></p>

<p style="margin-left:17%;">This is the constructor for the
class. That means it is expected to return a blessed
reference to a new scalar (probably anonymous) that
it&rsquo;s creating. For example:</p>

<p style="margin-left:17%; margin-top: 1em">sub TIESCALAR {
<br>
my $class = shift; <br>
my $pid = shift || $$; # 0 means me <br>
if ($pid !~ /^\d+$/) { <br>
carp &quot;Nice::Tie::Scalar got non&minus;numeric pid
$pid&quot; if $^W; <br>
return undef; <br>
} <br>
unless (kill 0, $pid) { # EPERM or ERSCH, no doubt <br>
carp &quot;Nice::Tie::Scalar got bad pid $pid: $!&quot; if
$^W; <br>
return undef; <br>
} <br>
return bless \$pid, $class; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">This tie class
has chosen to return an error rather than raising an
exception if its constructor should fail. While this is how
<b>dbmopen()</b> works, other classes may well not wish to
be so forgiving. It checks the global variable $^W to see
whether to emit a bit of noise anyway.</p>

<p style="margin-left:11%;"><small>FETCH</small> this</p>

<p style="margin-left:17%;">This method will be triggered
every time the tied variable is accessed (read). It takes no
arguments beyond its self reference, which is the object
representing the scalar we&rsquo;re dealing with. Because in
this case we&rsquo;re using just a <small>SCALAR</small> ref
for the tied scalar object, a simple $$self allows the
method to get at the real value stored there. In our example
below, that real value is the process <small>ID</small> to
which we&rsquo;ve tied our variable.</p>

<p style="margin-left:17%; margin-top: 1em">sub FETCH {
<br>
my $self = shift; <br>
confess &quot;wrong type&quot; unless ref $self; <br>
croak &quot;usage error&quot; if @_; <br>
my $nicety; <br>
local($!) = 0; <br>
$nicety = getpriority(PRIO_PROCESS, $$self); <br>
if ($!) { croak &quot;getpriority failed: $!&quot; } <br>
return $nicety; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">This time
we&rsquo;ve decided to blow up (raise an exception) if the
renice fails--there&rsquo;s no place for us to return an
error otherwise, and it&rsquo;s probably the right thing to
do.</p>

<p style="margin-left:11%;"><small>STORE</small> this,
value</p>

<p style="margin-left:17%;">This method will be triggered
every time the tied variable is set (assigned). Beyond its
self reference, it also expects one (and only one) argument:
the new value the user is trying to assign. Don&rsquo;t
worry about returning a value from <small>STORE</small> ;
the semantic of assignment returning the assigned value is
implemented with <small>FETCH.</small></p>

<p style="margin-left:17%; margin-top: 1em">sub STORE {
<br>
my $self = shift; <br>
confess &quot;wrong type&quot; unless ref $self; <br>
my $new_nicety = shift; <br>
croak &quot;usage error&quot; if @_; <br>
if ($new_nicety &lt; PRIO_MIN) { <br>
carp sprintf <br>
&quot;WARNING: priority %d less than minimum system priority
%d&quot;, <br>
$new_nicety, PRIO_MIN if $^W; <br>
$new_nicety = PRIO_MIN; <br>
} <br>
if ($new_nicety &gt; PRIO_MAX) { <br>
carp sprintf <br>
&quot;WARNING: priority %d greater than maximum system
priority %d&quot;, <br>
$new_nicety, PRIO_MAX if $^W; <br>
$new_nicety = PRIO_MAX; <br>
} <br>
unless (defined setpriority(PRIO_PROCESS, <br>
$$self, <br>
$new_nicety)) <br>
{ <br>
confess &quot;setpriority failed: $!&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%;"><small>UNTIE</small> this</p>

<p style="margin-left:17%;">This method will be triggered
when the &quot;untie&quot; occurs. This can be useful if the
class needs to know when no further calls will be made.
(Except <small>DESTROY</small> of course.) See &quot;The
&quot;untie&quot; Gotcha&quot; below for more details.</p>

<p style="margin-left:11%;"><small>DESTROY</small> this</p>

<p style="margin-left:17%;">This method will be triggered
when the tied variable needs to be destructed. As with other
object classes, such a method is seldom necessary, because
Perl deallocates its moribund object&rsquo;s memory for you
automatically--this isn&rsquo;t C <small>++</small> , you
know. We&rsquo;ll use a <small>DESTROY</small> method here
for debugging purposes only.</p>

<p style="margin-left:17%; margin-top: 1em">sub DESTROY {
<br>
my $self = shift; <br>
confess &quot;wrong type&quot; unless ref $self; <br>
carp &quot;[ Nice::DESTROY pid $$self ]&quot; if
$Nice::DEBUG; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
about all there is to it. Actually, it&rsquo;s more than all
there is to it, because we&rsquo;ve done a few nice things
here for the sake of completeness, robustness, and general
aesthetics. Simpler <small>TIESCALAR</small> classes are
certainly possible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tying
Arrays</b> <br>
A class implementing a tied ordinary array should define the
following methods: <small>TIEARRAY, FETCH, STORE, FETCHSIZE,
STORESIZE, CLEAR</small> and perhaps <small>UNTIE</small>
and/or <small>DESTROY.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small>FETCHSIZE</small>
and <small>STORESIZE</small> are used to provide $#array and
equivalent &quot;scalar(@array)&quot; access.</p>

<p style="margin-left:11%; margin-top: 1em">The methods
<small>POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE,</small>
and <small>EXISTS</small> are required if the perl operator
with the corresponding (but lowercase) name is to operate on
the tied array. The <b>Tie::Array</b> class can be used as a
base class to implement the first five of these in terms of
the basic methods above. The default implementations of
<small>DELETE</small> and <small>EXISTS</small> in
<b>Tie::Array</b> simply &quot;croak&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">In addition
<small>EXTEND</small> will be called when perl would have
pre-extended allocation in a real array.</p>

<p style="margin-left:11%; margin-top: 1em">For this
discussion, we&rsquo;ll implement an array whose elements
are a fixed size at creation. If you try to create an
element larger than the fixed size, you&rsquo;ll take an
exception. For example:</p>

<p style="margin-left:11%; margin-top: 1em">use
FixedElem_Array; <br>
tie @array, 'FixedElem_Array', 3; <br>
$array[0] = 'cat'; # ok. <br>
$array[1] = 'dogs'; # exception, length('dogs') &gt; 3.</p>

<p style="margin-left:11%; margin-top: 1em">The preamble
code for the class is as follows:</p>

<p style="margin-left:11%; margin-top: 1em">package
FixedElem_Array; <br>
use Carp; <br>
use strict; <small><br>
TIEARRAY</small> classname, <small>LIST</small></p>

<p style="margin-left:17%;">This is the constructor for the
class. That means it is expected to return a blessed
reference through which the new array (probably an anonymous
<small>ARRAY</small> ref) will be accessed.</p>

<p style="margin-left:17%; margin-top: 1em">In our example,
just to show you that you don&rsquo;t <i>really</i> have to
return an <small>ARRAY</small> reference, we&rsquo;ll choose
a <small>HASH</small> reference to represent our object. A
<small>HASH</small> works out well as a generic record type:
the &quot;{ELEMSIZE}&quot; field will store the maximum
element size allowed, and the &quot;{ARRAY}&quot; field will
hold the true <small>ARRAY</small> ref. If someone outside
the class tries to dereference the object returned
(doubtless thinking it an <small>ARRAY</small> ref),
they&rsquo;ll blow up. This just goes to show you that you
should respect an object&rsquo;s privacy.</p>

<p style="margin-left:17%; margin-top: 1em">sub TIEARRAY {
<br>
my $class = shift; <br>
my $elemsize = shift; <br>
if ( @_ || $elemsize =~ /\D/ ) { <br>
croak &quot;usage: tie ARRAY, '&quot; . __PACKAGE__ .
&quot;', elem_size&quot;; <br>
} <br>
return bless { <br>
ELEMSIZE =&gt; $elemsize, <br>
ARRAY =&gt; [], <br>
}, $class; <br>
}</p>

<p style="margin-left:11%;"><small>FETCH</small> this,
index</p>

<p style="margin-left:17%;">This method will be triggered
every time an individual element the tied array is accessed
(read). It takes one argument beyond its self reference: the
index whose value we&rsquo;re trying to fetch.</p>

<p style="margin-left:17%; margin-top: 1em">sub FETCH {
<br>
my $self = shift; <br>
my $index = shift; <br>
return $self&minus;&gt;{ARRAY}&minus;&gt;[$index]; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">If a negative
array index is used to read from an array, the index will be
translated to a positive one internally by calling
<small>FETCHSIZE</small> before being passed to
<small>FETCH.</small> You may disable this feature by
assigning a true value to the variable $NEGATIVE_INDICES in
the tied array class.</p>

<p style="margin-left:17%; margin-top: 1em">As you may have
noticed, the name of the <small>FETCH</small> method (et
al.) is the same for all accesses, even though the
constructors differ in names ( <small>TIESCALAR</small> vs
<small>TIEARRAY</small> ). While in theory you could have
the same class servicing several tied types, in practice
this becomes cumbersome, and it&rsquo;s easiest to keep them
at simply one tie type per class.</p>

<p style="margin-left:11%;"><small>STORE</small> this,
index, value</p>

<p style="margin-left:17%;">This method will be triggered
every time an element in the tied array is set (written). It
takes two arguments beyond its self reference: the index at
which we&rsquo;re trying to store something and the value
we&rsquo;re trying to put there.</p>

<p style="margin-left:17%; margin-top: 1em">In our example,
&quot;undef&quot; is really
&quot;$self&minus;&gt;{ELEMSIZE}&quot; number of spaces so
we have a little more work to do here:</p>

<p style="margin-left:17%; margin-top: 1em">sub STORE {
<br>
my $self = shift; <br>
my( $index, $value ) = @_; <br>
if ( length $value &gt; $self&minus;&gt;{ELEMSIZE} ) { <br>
croak &quot;length of $value is greater than
$self&minus;&gt;{ELEMSIZE}&quot;; <br>
} <br>
# fill in the blanks <br>
$self&minus;&gt;STORESIZE( $index ) if $index &gt;
$self&minus;&gt;FETCHSIZE(); <br>
# right justify to keep element size for smaller elements
<br>
$self&minus;&gt;{ARRAY}&minus;&gt;[$index] = sprintf
&quot;%$self&minus;&gt;{ELEMSIZE}s&quot;, $value; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">Negative
indexes are treated the same as with
<small>FETCH.</small></p>

<p style="margin-left:11%;"><small>FETCHSIZE</small>
this</p>

<p style="margin-left:17%;">Returns the total number of
items in the tied array associated with object <i>this</i>.
(Equivalent to &quot;scalar(@array)&quot;). For example:</p>

<p style="margin-left:17%; margin-top: 1em">sub FETCHSIZE {
<br>
my $self = shift; <br>
return scalar $self&minus;&gt;{ARRAY}&minus;&gt;@*; <br>
}</p>

<p style="margin-left:11%;"><small>STORESIZE</small> this,
count</p>

<p style="margin-left:17%;">Sets the total number of items
in the tied array associated with object <i>this</i> to be
<i>count</i>. If this makes the array larger then
class&rsquo;s mapping of &quot;undef&quot; should be
returned for new positions. If the array becomes smaller
then entries beyond count should be deleted.</p>

<p style="margin-left:17%; margin-top: 1em">In our example,
&rsquo;undef&rsquo; is really an element containing
&quot;$self&minus;&gt;{ELEMSIZE}&quot; number of spaces.
Observe:</p>

<p style="margin-left:17%; margin-top: 1em">sub STORESIZE {
<br>
my $self = shift; <br>
my $count = shift; <br>
if ( $count &gt; $self&minus;&gt;FETCHSIZE() ) { <br>
foreach ( $count &minus; $self&minus;&gt;FETCHSIZE() ..
$count ) { <br>
$self&minus;&gt;STORE( $_, '' ); <br>
} <br>
} elsif ( $count &lt; $self&minus;&gt;FETCHSIZE() ) { <br>
foreach ( 0 .. $self&minus;&gt;FETCHSIZE() &minus; $count
&minus; 2 ) { <br>
$self&minus;&gt;POP(); <br>
} <br>
} <br>
}</p>

<p style="margin-left:11%;"><small>EXTEND</small> this,
count</p>

<p style="margin-left:17%;">Informative call that array is
likely to grow to have <i>count</i> entries. Can be used to
optimize allocation. This method need do nothing.</p>

<p style="margin-left:17%; margin-top: 1em">In our example
there is no reason to implement this method, so we leave it
as a no-op. This method is only relevant to tied array
implementations where there is the possibility of having the
allocated size of the array be larger than is visible to a
perl programmer inspecting the size of the array. Many tied
array implementations will have no reason to implement
it.</p>

<p style="margin-left:17%; margin-top: 1em">sub EXTEND {
<br>
my $self = shift; <br>
my $count = shift; <br>
# nothing to see here, move along. <br>
}</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>NOTE:</small></b>
It is generally an error to make this equivalent to
<small>STORESIZE.</small> Perl may from time to time call
<small>EXTEND</small> without wanting to actually change the
array size directly. Any tied array should function
correctly if this method is a no-op, even if perhaps they
might not be as efficient as they would if this method was
implemented.</p>

<p style="margin-left:11%;"><small>EXISTS</small> this,
key</p>

<p style="margin-left:17%;">Verify that the element at
index <i>key</i> exists in the tied array <i>this</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In our example,
we will determine that if an element consists of
&quot;$self&minus;&gt;{ELEMSIZE}&quot; spaces only, it does
not exist:</p>

<p style="margin-left:17%; margin-top: 1em">sub EXISTS {
<br>
my $self = shift; <br>
my $index = shift; <br>
return 0 if ! defined
$self&minus;&gt;{ARRAY}&minus;&gt;[$index] || <br>
$self&minus;&gt;{ARRAY}&minus;&gt;[$index] eq ' ' x
$self&minus;&gt;{ELEMSIZE}; <br>
return 1; <br>
}</p>

<p style="margin-left:11%;"><small>DELETE</small> this,
key</p>

<p style="margin-left:17%;">Delete the element at index
<i>key</i> from the tied array <i>this</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In our example,
a deleted item is &quot;$self&minus;&gt;{ELEMSIZE}&quot;
spaces:</p>

<p style="margin-left:17%; margin-top: 1em">sub DELETE {
<br>
my $self = shift; <br>
my $index = shift; <br>
return $self&minus;&gt;STORE( $index, '' ); <br>
}</p>

<p style="margin-left:11%;"><small>CLEAR</small> this</p>

<p style="margin-left:17%;">Clear (remove, delete, ...) all
values from the tied array associated with object
<i>this</i>. For example:</p>

<p style="margin-left:17%; margin-top: 1em">sub CLEAR {
<br>
my $self = shift; <br>
return $self&minus;&gt;{ARRAY} = []; <br>
}</p>

<p style="margin-left:11%;"><small>PUSH</small> this,
<small>LIST</small></p>

<p style="margin-left:17%;">Append elements of
<i><small>LIST</small></i> to the array. For example:</p>

<p style="margin-left:17%; margin-top: 1em">sub PUSH { <br>
my $self = shift; <br>
my @list = @_; <br>
my $last = $self&minus;&gt;FETCHSIZE(); <br>
$self&minus;&gt;STORE( $last + $_, $list[$_] ) foreach 0 ..
$#list; <br>
return $self&minus;&gt;FETCHSIZE(); <br>
}</p>

<p style="margin-left:11%;"><small>POP</small> this</p>

<p style="margin-left:17%;">Remove last element of the
array and return it. For example:</p>

<p style="margin-left:17%; margin-top: 1em">sub POP { <br>
my $self = shift; <br>
return pop $self&minus;&gt;{ARRAY}&minus;&gt;@*; <br>
}</p>

<p style="margin-left:11%;"><small>SHIFT</small> this</p>

<p style="margin-left:17%;">Remove the first element of the
array (shifting other elements down) and return it. For
example:</p>

<p style="margin-left:17%; margin-top: 1em">sub SHIFT {
<br>
my $self = shift; <br>
return shift $self&minus;&gt;{ARRAY}&minus;&gt;@*; <br>
}</p>

<p style="margin-left:11%;"><small>UNSHIFT</small> this,
<small>LIST</small></p>

<p style="margin-left:17%;">Insert <small>LIST</small>
elements at the beginning of the array, moving existing
elements up to make room. For example:</p>

<p style="margin-left:17%; margin-top: 1em">sub UNSHIFT {
<br>
my $self = shift; <br>
my @list = @_; <br>
my $size = scalar( @list ); <br>
# make room for our list <br>
$self&minus;&gt;{ARRAY}[ $size ..
$self&minus;&gt;{ARRAY}&minus;&gt;$#* + $size ]&minus;&gt;@*
<br>
= $self&minus;&gt;{ARRAY}&minus;&gt;@* <br>
$self&minus;&gt;STORE( $_, $list[$_] ) foreach 0 .. $#list;
<br>
}</p>

<p style="margin-left:11%;"><small>SPLICE</small> this,
offset, length, <small>LIST</small></p>

<p style="margin-left:17%;">Perform the equivalent of
&quot;splice&quot; on the array.</p>

<p style="margin-left:17%; margin-top: 1em"><i>offset</i>
is optional and defaults to zero, negative values count back
from the end of the array.</p>

<p style="margin-left:17%; margin-top: 1em"><i>length</i>
is optional and defaults to rest of the array.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>LIST</small></i>
may be empty.</p>

<p style="margin-left:17%; margin-top: 1em">Returns a list
of the original <i>length</i> elements at <i>offset</i>.</p>

<p style="margin-left:17%; margin-top: 1em">In our example,
we&rsquo;ll use a little shortcut if there is a
<i><small>LIST</small></i> :</p>

<p style="margin-left:17%; margin-top: 1em">sub SPLICE {
<br>
my $self = shift; <br>
my $offset = shift || 0; <br>
my $length = shift || $self&minus;&gt;FETCHSIZE() &minus;
$offset; <br>
my @list = (); <br>
if ( @_ ) { <br>
tie @list, __PACKAGE__, $self&minus;&gt;{ELEMSIZE}; <br>
@list = @_; <br>
} <br>
return splice $self&minus;&gt;{ARRAY}&minus;&gt;@*, $offset,
$length, @list; <br>
}</p>

<p style="margin-left:11%;"><small>UNTIE</small> this</p>

<p style="margin-left:17%;">Will be called when
&quot;untie&quot; happens. (See &quot;The &quot;untie&quot;
Gotcha&quot; below.)</p>

<p style="margin-left:11%;"><small>DESTROY</small> this</p>

<p style="margin-left:17%;">This method will be triggered
when the tied variable needs to be destructed. As with the
scalar tie class, this is almost never needed in a language
that does its own garbage collection, so this time
we&rsquo;ll just leave it out.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tying
Hashes</b> <br>
Hashes were the first Perl data type to be tied (see
<b>dbmopen()</b>). A class implementing a tied hash should
define the following methods: <small>TIEHASH</small> is the
constructor. <small>FETCH</small> and <small>STORE</small>
access the key and value pairs. <small>EXISTS</small>
reports whether a key is present in the hash, and
<small>DELETE</small> deletes one. <small>CLEAR</small>
empties the hash by deleting all the key and value pairs.
<small>FIRSTKEY</small> and <small>NEXTKEY</small> implement
the <b>keys()</b> and <b>each()</b> functions to iterate
over all the keys. <small>SCALAR</small> is triggered when
the tied hash is evaluated in scalar context, and in 5.28
onwards, by &quot;keys&quot; in boolean context.
<small>UNTIE</small> is called when &quot;untie&quot;
happens, and <small>DESTROY</small> is called when the tied
variable is garbage collected.</p>

<p style="margin-left:11%; margin-top: 1em">If this seems
like a lot, then feel free to inherit from merely the
standard Tie::StdHash module for most of your methods,
redefining only the interesting ones. See Tie::Hash for
details.</p>

<p style="margin-left:11%; margin-top: 1em">Remember that
Perl distinguishes between a key not existing in the hash,
and the key existing in the hash but having a corresponding
value of &quot;undef&quot;. The two possibilities can be
tested with the &quot;exists()&quot; and
&quot;defined()&quot; functions.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s an
example of a somewhat interesting tied hash class: it gives
you a hash representing a particular user&rsquo;s dot files.
You index into the hash with the name of the file (minus the
dot) and you get back that dot file&rsquo;s contents. For
example:</p>

<p style="margin-left:11%; margin-top: 1em">use DotFiles;
<br>
tie %dot, 'DotFiles'; <br>
if ( $dot{profile} =~ /MANPATH/ || <br>
$dot{login} =~ /MANPATH/ || <br>
$dot{cshrc} =~ /MANPATH/ ) <br>
{ <br>
print &quot;you seem to set your MANPATH\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Or here&rsquo;s
another sample of using our tied class:</p>

<p style="margin-left:11%; margin-top: 1em">tie %him,
'DotFiles', 'daemon'; <br>
foreach $f ( keys %him ) { <br>
printf &quot;daemon dot file %s is size %d\n&quot;, <br>
$f, length $him{$f}; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">In our tied
hash DotFiles example, we use a regular hash for the object
containing several important fields, of which only the
&quot;{LIST}&quot; field will be what the user thinks of as
the real hash.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><small>USER</small></p></td>
<td width="1%"></td>
<td width="59%">


<p>whose dot files this object represents</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><small>HOME</small></p></td>
<td width="1%"></td>
<td width="59%">


<p>where those dot files live</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:11%;"><small>CLOBBER</small></p>

<p style="margin-left:18%;">whether we should try to change
or remove those dot files</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><small>LIST</small></p></td>
<td width="1%"></td>
<td width="73%">


<p>the hash of dot file names and content mappings</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
the start of <i>Dotfiles.pm</i>:</p>

<p style="margin-left:11%; margin-top: 1em">package
DotFiles; <br>
use Carp; <br>
sub whowasi { (caller(1))[3] . '()' } <br>
my $DEBUG = 0; <br>
sub debug { $DEBUG = @_ ? shift : 1 }</p>

<p style="margin-left:11%; margin-top: 1em">For our
example, we want to be able to emit debugging info to help
in tracing during development. We keep also one convenience
function around internally to help print out warnings;
<b>whowasi()</b> returns the function name that calls
it.</p>

<p style="margin-left:11%; margin-top: 1em">Here are the
methods for the DotFiles tied hash. <small><br>
TIEHASH</small> classname, <small>LIST</small></p>

<p style="margin-left:17%;">This is the constructor for the
class. That means it is expected to return a blessed
reference through which the new object (probably but not
necessarily an anonymous hash) will be accessed.</p>

<p style="margin-left:17%; margin-top: 1em">Here&rsquo;s
the constructor:</p>

<p style="margin-left:17%; margin-top: 1em">sub TIEHASH {
<br>
my $class = shift; <br>
my $user = shift || $&gt;; <br>
my $dotdir = shift || ''; <br>
croak &quot;usage: @{[&amp;whowasi]} [USER [DOTDIR]]&quot;
if @_; <br>
$user = getpwuid($user) if $user =~ /^\d+$/; <br>
my $dir = (getpwnam($user))[7] <br>
|| croak &quot;@{[&amp;whowasi]}: no user $user&quot;; <br>
$dir .= &quot;/$dotdir&quot; if $dotdir; <br>
my $node = { <br>
USER =&gt; $user, <br>
HOME =&gt; $dir, <br>
LIST =&gt; {}, <br>
CLOBBER =&gt; 0, <br>
}; <br>
opendir(DIR, $dir) <br>
|| croak &quot;@{[&amp;whowasi]}: can't opendir $dir:
$!&quot;; <br>
foreach $dot ( grep /^\./ &amp;&amp; &minus;f
&quot;$dir/$_&quot;, readdir(DIR)) { <br>
$dot =~ s/^\.//; <br>
$node&minus;&gt;{LIST}{$dot} = undef; <br>
} <br>
closedir DIR; <br>
return bless $node, $class; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
probably worth mentioning that if you&rsquo;re going to
filetest the return values out of a readdir, you&rsquo;d
better prepend the directory in question. Otherwise, because
we didn&rsquo;t <b>chdir()</b> there, it would have been
testing the wrong file.</p>

<p style="margin-left:11%;"><small>FETCH</small> this,
key</p>

<p style="margin-left:17%;">This method will be triggered
every time an element in the tied hash is accessed (read).
It takes one argument beyond its self reference: the key
whose value we&rsquo;re trying to fetch.</p>

<p style="margin-left:17%; margin-top: 1em">Here&rsquo;s
the fetch for our DotFiles example.</p>

<p style="margin-left:17%; margin-top: 1em">sub FETCH {
<br>
carp &amp;whowasi if $DEBUG; <br>
my $self = shift; <br>
my $dot = shift; <br>
my $dir = $self&minus;&gt;{HOME}; <br>
my $file = &quot;$dir/.$dot&quot;; <br>
unless (exists $self&minus;&gt;{LIST}&minus;&gt;{$dot} ||
&minus;f $file) { <br>
carp &quot;@{[&amp;whowasi]}: no $dot file&quot; if $DEBUG;
<br>
return undef; <br>
} <br>
if (defined $self&minus;&gt;{LIST}&minus;&gt;{$dot}) { <br>
return $self&minus;&gt;{LIST}&minus;&gt;{$dot}; <br>
} else { <br>
return $self&minus;&gt;{LIST}&minus;&gt;{$dot} = `cat
$dir/.$dot`; <br>
} <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">It was easy to
write by having it call the Unix <b>cat</b>(1) command, but
it would probably be more portable to open the file manually
(and somewhat more efficient). Of course, because dot files
are a Unixy concept, we&rsquo;re not that concerned.</p>

<p style="margin-left:11%;"><small>STORE</small> this, key,
value</p>

<p style="margin-left:17%;">This method will be triggered
every time an element in the tied hash is set (written). It
takes two arguments beyond its self reference: the index at
which we&rsquo;re trying to store something, and the value
we&rsquo;re trying to put there.</p>

<p style="margin-left:17%; margin-top: 1em">Here in our
DotFiles example, we&rsquo;ll be careful not to let them try
to overwrite the file unless they&rsquo;ve called the
<b>clobber()</b> method on the original object reference
returned by <b>tie()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">sub STORE {
<br>
carp &amp;whowasi if $DEBUG; <br>
my $self = shift; <br>
my $dot = shift; <br>
my $value = shift; <br>
my $file = $self&minus;&gt;{HOME} . &quot;/.$dot&quot;; <br>
my $user = $self&minus;&gt;{USER}; <br>
croak &quot;@{[&amp;whowasi]}: $file not clobberable&quot;
<br>
unless $self&minus;&gt;{CLOBBER}; <br>
open(my $f, '&gt;', $file) || croak &quot;can't open $file:
$!&quot;; <br>
print $f $value; <br>
close($f); <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">If they wanted
to clobber something, they might say:</p>

<p style="margin-left:17%; margin-top: 1em">$ob = tie
%daemon_dots, 'daemon'; <br>
$ob&minus;&gt;clobber(1); <br>
$daemon_dots{signature} = &quot;A true daemon\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Another way to
lay hands on a reference to the underlying object is to use
the <b>tied()</b> function, so they might alternately have
set clobber using:</p>

<p style="margin-left:17%; margin-top: 1em">tie
%daemon_dots, 'daemon'; <br>
tied(%daemon_dots)&minus;&gt;clobber(1);</p>

<p style="margin-left:17%; margin-top: 1em">The clobber
method is simply:</p>

<p style="margin-left:17%; margin-top: 1em">sub clobber {
<br>
my $self = shift; <br>
$self&minus;&gt;{CLOBBER} = @_ ? shift : 1; <br>
}</p>

<p style="margin-left:11%;"><small>DELETE</small> this,
key</p>

<p style="margin-left:17%;">This method is triggered when
we remove an element from the hash, typically by using the
<b>delete()</b> function. Again, we&rsquo;ll be careful to
check whether they really want to clobber files.</p>

<p style="margin-left:17%; margin-top: 1em">sub DELETE {
<br>
carp &amp;whowasi if $DEBUG; <br>
my $self = shift; <br>
my $dot = shift; <br>
my $file = $self&minus;&gt;{HOME} . &quot;/.$dot&quot;; <br>
croak &quot;@{[&amp;whowasi]}: won't remove file $file&quot;
<br>
unless $self&minus;&gt;{CLOBBER}; <br>
delete $self&minus;&gt;{LIST}&minus;&gt;{$dot}; <br>
my $success = unlink($file); <br>
carp &quot;@{[&amp;whowasi]}: can't unlink $file: $!&quot;
unless $success; <br>
$success; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">The value
returned by <small>DELETE</small> becomes the return value
of the call to <b>delete()</b>. If you want to emulate the
normal behavior of <b>delete()</b>, you should return
whatever <small>FETCH</small> would have returned for this
key. In this example, we have chosen instead to return a
value which tells the caller whether the file was
successfully deleted.</p>

<p style="margin-left:11%;"><small>CLEAR</small> this</p>

<p style="margin-left:17%;">This method is triggered when
the whole hash is to be cleared, usually by assigning the
empty list to it.</p>

<p style="margin-left:17%; margin-top: 1em">In our example,
that would remove all the user&rsquo;s dot files! It&rsquo;s
such a dangerous thing that they&rsquo;ll have to set
<small>CLOBBER</small> to something higher than 1 to make it
happen.</p>

<p style="margin-left:17%; margin-top: 1em">sub CLEAR {
<br>
carp &amp;whowasi if $DEBUG; <br>
my $self = shift; <br>
croak &quot;@{[&amp;whowasi]}: won't remove all dot files
for $self&minus;&gt;{USER}&quot; <br>
unless $self&minus;&gt;{CLOBBER} &gt; 1; <br>
my $dot; <br>
foreach $dot ( keys $self&minus;&gt;{LIST}&minus;&gt;%* ) {
<br>
$self&minus;&gt;DELETE($dot); <br>
} <br>
}</p>

<p style="margin-left:11%;"><small>EXISTS</small> this,
key</p>

<p style="margin-left:17%;">This method is triggered when
the user uses the <b>exists()</b> function on a particular
hash. In our example, we&rsquo;ll look at the
&quot;{LIST}&quot; hash element for this:</p>

<p style="margin-left:17%; margin-top: 1em">sub EXISTS {
<br>
carp &amp;whowasi if $DEBUG; <br>
my $self = shift; <br>
my $dot = shift; <br>
return exists $self&minus;&gt;{LIST}&minus;&gt;{$dot}; <br>
}</p>

<p style="margin-left:11%;"><small>FIRSTKEY</small>
this</p>

<p style="margin-left:17%;">This method will be triggered
when the user is going to iterate through the hash, such as
via a <b>keys()</b>, <b>values()</b>, or <b>each()</b>
call.</p>

<p style="margin-left:17%; margin-top: 1em">sub FIRSTKEY {
<br>
carp &amp;whowasi if $DEBUG; <br>
my $self = shift; <br>
my $a = keys $self&minus;&gt;{LIST}&minus;&gt;%*; # reset
each() iterator <br>
each $self&minus;&gt;{LIST}&minus;&gt;%* <br>
}</p>


<p style="margin-left:17%; margin-top: 1em"><small>FIRSTKEY</small>
is always called in scalar context and it should just return
the first key. <b>values()</b>, and <b>each()</b> in list
context, will call <small>FETCH</small> for the returned
keys.</p>

<p style="margin-left:11%;"><small>NEXTKEY</small> this,
lastkey</p>

<p style="margin-left:17%;">This method gets triggered
during a <b>keys()</b>, <b>values()</b>, or <b>each()</b>
iteration. It has a second argument which is the last key
that had been accessed. This is useful if you&rsquo;re
caring about ordering or calling the iterator from more than
one sequence, or not really storing things in a hash
anywhere.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NEXTKEY</small>
is always called in scalar context and it should just return
the next key. <b>values()</b>, and <b>each()</b> in list
context, will call <small>FETCH</small> for the returned
keys.</p>

<p style="margin-left:17%; margin-top: 1em">For our
example, we&rsquo;re using a real hash so we&rsquo;ll do
just the simple thing, but we&rsquo;ll have to go through
the <small>LIST</small> field indirectly.</p>

<p style="margin-left:17%; margin-top: 1em">sub NEXTKEY {
<br>
carp &amp;whowasi if $DEBUG; <br>
my $self = shift; <br>
return each $self&minus;&gt;{LIST}&minus;&gt;%* <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">If the object
underlying your tied hash isn&rsquo;t a real hash and you
don&rsquo;t have &quot;each&quot; available, then you should
return &quot;undef&quot; or the empty list once you&rsquo;ve
reached the end of your list of keys. See &quot;each's own
documentation&quot; for more details.</p>

<p style="margin-left:11%;"><small>SCALAR</small> this</p>

<p style="margin-left:17%;">This is called when the hash is
evaluated in scalar context, and in 5.28 onwards, by
&quot;keys&quot; in boolean context. In order to mimic the
behaviour of untied hashes, this method must return a value
which when used as boolean, indicates whether the tied hash
is considered empty. If this method does not exist, perl
will make some educated guesses and return true when the
hash is inside an iteration. If this isn&rsquo;t the case,
<small>FIRSTKEY</small> is called, and the result will be a
false value if <small>FIRSTKEY</small> returns the empty
list, true otherwise.</p>

<p style="margin-left:17%; margin-top: 1em">However, you
should <b>not</b> blindly rely on perl always doing the
right thing. Particularly, perl will mistakenly return true
when you clear the hash by repeatedly calling
<small>DELETE</small> until it is empty. You are therefore
advised to supply your own <small>SCALAR</small> method when
you want to be absolutely sure that your hash behaves nicely
in scalar context.</p>

<p style="margin-left:17%; margin-top: 1em">In our example
we can just call &quot;scalar&quot; on the underlying hash
referenced by &quot;$self&minus;&gt;{LIST}&quot;:</p>

<p style="margin-left:17%; margin-top: 1em">sub SCALAR {
<br>
carp &amp;whowasi if $DEBUG; <br>
my $self = shift; <br>
return scalar $self&minus;&gt;{LIST}&minus;&gt;%* <br>
}</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
In perl 5.25 the behavior of scalar %hash on an untied hash
changed to return the count of keys. Prior to this it
returned a string containing information about the bucket
setup of the hash. See &quot;bucket_ratio&quot; in
Hash::Util for a backwards compatibility path.</p>

<p style="margin-left:11%;"><small>UNTIE</small> this</p>

<p style="margin-left:17%;">This is called when
&quot;untie&quot; occurs. See &quot;The &quot;untie&quot;
Gotcha&quot; below.</p>

<p style="margin-left:11%;"><small>DESTROY</small> this</p>

<p style="margin-left:17%;">This method is triggered when a
tied hash is about to go out of scope. You don&rsquo;t
really need it unless you&rsquo;re trying to add debugging
or have auxiliary state to clean up. Here&rsquo;s a very
simple function:</p>

<p style="margin-left:17%; margin-top: 1em">sub DESTROY {
<br>
carp &amp;whowasi if $DEBUG; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Note that
functions such as <b>keys()</b> and <b>values()</b> may
return huge lists when used on large objects, like
<small>DBM</small> files. You may prefer to use the
<b>each()</b> function to iterate over such. Example:</p>

<p style="margin-left:11%; margin-top: 1em"># print out
history file offsets <br>
use NDBM_File; <br>
tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0); <br>
while (($key,$val) = each %HIST) { <br>
print $key, ' = ', unpack('L',$val), &quot;\n&quot;; <br>
} <br>
untie(%HIST);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tying
FileHandles</b> <br>
This is partially implemented now.</p>

<p style="margin-left:11%; margin-top: 1em">A class
implementing a tied filehandle should define the following
methods: <small>TIEHANDLE,</small> at least one of
<small>PRINT, PRINTF, WRITE, READLINE, GETC, READ,</small>
and possibly <small>CLOSE, UNTIE</small> and
<small>DESTROY.</small> The class can also provide:
<small>BINMODE, OPEN, EOF, FILENO, SEEK, TELL</small>
&minus; if the corresponding perl operators are used on the
handle.</p>

<p style="margin-left:11%; margin-top: 1em">When
<small>STDERR</small> is tied, its <small>PRINT</small>
method will be called to issue warnings and error messages.
This feature is temporarily disabled during the call, which
means you can use &quot;warn()&quot; inside
<small>PRINT</small> without starting a recursive loop. And
just like &quot;__WARN__&quot; and &quot;__DIE__&quot;
handlers, <small>STDERR</small> &rsquo;s
<small>PRINT</small> method may be called to report parser
errors, so the caveats mentioned under &quot;%SIG&quot; in
perlvar apply.</p>

<p style="margin-left:11%; margin-top: 1em">All of this is
especially useful when perl is embedded in some other
program, where output to <small>STDOUT</small> and
<small>STDERR</small> may have to be redirected in some
special way. See nvi and the Apache module for examples.</p>

<p style="margin-left:11%; margin-top: 1em">When tying a
handle, the first argument to &quot;tie&quot; should begin
with an asterisk. So, if you are tying
<small>STDOUT,</small> use *STDOUT. If you have assigned it
to a scalar variable, say $handle, use *$handle. &quot;tie
$handle&quot; ties the scalar variable $handle, not the
handle inside it.</p>

<p style="margin-left:11%; margin-top: 1em">In our example
we&rsquo;re going to create a shouting handle.</p>

<p style="margin-left:11%; margin-top: 1em">package Shout;
<small><br>
TIEHANDLE</small> classname, <small>LIST</small></p>

<p style="margin-left:17%;">This is the constructor for the
class. That means it is expected to return a blessed
reference of some sort. The reference can be used to hold
some internal information.</p>

<p style="margin-left:17%; margin-top: 1em">sub TIEHANDLE {
print &quot;&lt;shout&gt;\n&quot;; my $i; bless \$i, shift
}</p>

<p style="margin-left:11%;"><small>WRITE</small> this,
<small>LIST</small></p>

<p style="margin-left:17%;">This method will be called when
the handle is written to via the &quot;syswrite&quot;
function.</p>

<p style="margin-left:17%; margin-top: 1em">sub WRITE {
<br>
$r = shift; <br>
my($buf,$len,$offset) = @_; <br>
print &quot;WRITE called, \$buf=$buf, \$len=$len,
\$offset=$offset&quot;; <br>
}</p>

<p style="margin-left:11%;"><small>PRINT</small> this,
<small>LIST</small></p>

<p style="margin-left:17%;">This method will be triggered
every time the tied handle is printed to with the
&quot;print()&quot; or &quot;say()&quot; functions. Beyond
its self reference it also expects the list that was passed
to the print function.</p>

<p style="margin-left:17%; margin-top: 1em">sub PRINT { $r
= shift; $$r++; print join($,,map(uc($_),@_)),$\ }</p>


<p style="margin-left:17%; margin-top: 1em">&quot;say()&quot;
acts just like &quot;print()&quot; except $\ will be
localized to &quot;\n&quot; so you need do nothing special
to handle &quot;say()&quot; in &quot;PRINT()&quot;.</p>

<p style="margin-left:11%;"><small>PRINTF</small> this,
<small>LIST</small></p>

<p style="margin-left:17%;">This method will be triggered
every time the tied handle is printed to with the
&quot;printf()&quot; function. Beyond its self reference it
also expects the format and list that was passed to the
printf function.</p>

<p style="margin-left:17%; margin-top: 1em">sub PRINTF {
<br>
shift; <br>
my $fmt = shift; <br>
print sprintf($fmt, @_); <br>
}</p>

<p style="margin-left:11%;"><small>READ</small> this,
<small>LIST</small></p>

<p style="margin-left:17%;">This method will be called when
the handle is read from via the &quot;read&quot; or
&quot;sysread&quot; functions.</p>

<p style="margin-left:17%; margin-top: 1em">sub READ { <br>
my $self = shift; <br>
my $bufref = \$_[0]; <br>
my(undef,$len,$offset) = @_; <br>
print &quot;READ called, \$buf=$bufref, \$len=$len,
\$offset=$offset&quot;; <br>
# add to $$bufref, set $len to number of characters read
<br>
$len; <br>
}</p>

<p style="margin-left:11%;"><small>READLINE</small>
this</p>

<p style="margin-left:17%;">This method is called when the
handle is read via &quot;&lt;HANDLE&gt;&quot; or
&quot;readline HANDLE&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">As per
&quot;readline&quot;, in scalar context it should return the
next line, or &quot;undef&quot; for no more data. In list
context it should return all remaining lines, or an empty
list for no more data. The strings returned should include
the input record separator $/ (see perlvar), unless it is
&quot;undef&quot; (which means &quot;slurp&quot; mode).</p>

<p style="margin-left:17%; margin-top: 1em">sub READLINE {
<br>
my $r = shift; <br>
if (wantarray) { <br>
return (&quot;all remaining\n&quot;, <br>
&quot;lines up\n&quot;, <br>
&quot;to eof\n&quot;); <br>
} else { <br>
return &quot;READLINE called &quot; . ++$$r . &quot;
times\n&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%;"><small>GETC</small> this</p>

<p style="margin-left:17%;">This method will be called when
the &quot;getc&quot; function is called.</p>

<p style="margin-left:17%; margin-top: 1em">sub GETC {
print &quot;Don't GETC, Get Perl&quot;; return
&quot;a&quot;; }</p>

<p style="margin-left:11%;"><small>EOF</small> this</p>

<p style="margin-left:17%;">This method will be called when
the &quot;eof&quot; function is called.</p>

<p style="margin-left:17%; margin-top: 1em">Starting with
Perl 5.12, an additional integer parameter will be passed.
It will be zero if &quot;eof&quot; is called without
parameter; 1 if &quot;eof&quot; is given a filehandle as a
parameter, e.g. &quot;eof(FH)&quot;; and 2 in the very
special case that the tied filehandle is &quot;ARGV&quot;
and &quot;eof&quot; is called with an empty parameter list,
e.g. &quot;eof()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">sub EOF { not
length $stringbuf }</p>

<p style="margin-left:11%;"><small>CLOSE</small> this</p>

<p style="margin-left:17%;">This method will be called when
the handle is closed via the &quot;close&quot; function.</p>

<p style="margin-left:17%; margin-top: 1em">sub CLOSE {
print &quot;CLOSE called.\n&quot; }</p>

<p style="margin-left:11%;"><small>UNTIE</small> this</p>

<p style="margin-left:17%;">As with the other types of
ties, this method will be called when &quot;untie&quot;
happens. It may be appropriate to &quot;auto
<small>CLOSE&quot;</small> when this occurs. See &quot;The
&quot;untie&quot; Gotcha&quot; below.</p>

<p style="margin-left:11%;"><small>DESTROY</small> this</p>

<p style="margin-left:17%;">As with the other types of
ties, this method will be called when the tied handle is
about to be destroyed. This is useful for debugging and
possibly cleaning up.</p>

<p style="margin-left:17%; margin-top: 1em">sub DESTROY {
print &quot;&lt;/shout&gt;\n&quot; }</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
how to use our little example:</p>


<p style="margin-left:11%; margin-top: 1em">tie(*FOO,'Shout');
<br>
print FOO &quot;hello\n&quot;; <br>
$a = 4; $b = 6; <br>
print FOO $a, &quot; plus &quot;, $b, &quot; equals &quot;,
$a + $b, &quot;\n&quot;; <br>
print &lt;FOO&gt;;</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>UNTIE</small>
this</b> <br>
You can define for all tie types an <small>UNTIE</small>
method that will be called at <b>untie()</b>. See &quot;The
&quot;untie&quot; Gotcha&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
&quot;untie&quot; Gotcha</b> <br>
If you intend making use of the object returned from either
<b>tie()</b> or <b>tied()</b>, and if the tie&rsquo;s target
class defines a destructor, there is a subtle gotcha you
<i>must</i> guard against.</p>

<p style="margin-left:11%; margin-top: 1em">As setup,
consider this (admittedly rather contrived) example of a
tie; all it does is use a file to keep a log of the values
assigned to a scalar.</p>

<p style="margin-left:11%; margin-top: 1em">package
Remember; <br>
use v5.36; <br>
use IO::File; <br>
sub TIESCALAR { <br>
my $class = shift; <br>
my $filename = shift; <br>
my $handle = IO::File&minus;&gt;new( &quot;&gt;
$filename&quot; ) <br>
or die &quot;Cannot open $filename: $!\n&quot;; <br>
print $handle &quot;The Start\n&quot;; <br>
bless {FH =&gt; $handle, Value =&gt; 0}, $class; <br>
} <br>
sub FETCH { <br>
my $self = shift; <br>
return $self&minus;&gt;{Value}; <br>
} <br>
sub STORE { <br>
my $self = shift; <br>
my $value = shift; <br>
my $handle = $self&minus;&gt;{FH}; <br>
print $handle &quot;$value\n&quot;; <br>
$self&minus;&gt;{Value} = $value; <br>
} <br>
sub DESTROY { <br>
my $self = shift; <br>
my $handle = $self&minus;&gt;{FH}; <br>
print $handle &quot;The End\n&quot;; <br>
close $handle; <br>
} <br>
1;</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example that makes use of this tie:</p>

<p style="margin-left:11%; margin-top: 1em">use strict;
<br>
use Remember; <br>
my $fred; <br>
tie $fred, 'Remember', 'myfile.txt'; <br>
$fred = 1; <br>
$fred = 4; <br>
$fred = 5; <br>
untie $fred; <br>
system &quot;cat myfile.txt&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">This is the
output when it is executed:</p>

<p style="margin-left:11%; margin-top: 1em">The Start <br>
1 <br>
4 <br>
5 <br>
The End</p>

<p style="margin-left:11%; margin-top: 1em">So far so good.
Those of you who have been paying attention will have
spotted that the tied object hasn&rsquo;t been used so far.
So lets add an extra method to the Remember class to allow
comments to be included in the file; say, something like
this:</p>

<p style="margin-left:11%; margin-top: 1em">sub comment {
<br>
my $self = shift; <br>
my $text = shift; <br>
my $handle = $self&minus;&gt;{FH}; <br>
print $handle $text, &quot;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">And here is the
previous example modified to use the &quot;comment&quot;
method (which requires the tied object):</p>

<p style="margin-left:11%; margin-top: 1em">use strict;
<br>
use Remember; <br>
my ($fred, $x); <br>
$x = tie $fred, 'Remember', 'myfile.txt'; <br>
$fred = 1; <br>
$fred = 4; <br>
comment $x &quot;changing...&quot;; <br>
$fred = 5; <br>
untie $fred; <br>
system &quot;cat myfile.txt&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">When this code
is executed there is no output. Here&rsquo;s why:</p>

<p style="margin-left:11%; margin-top: 1em">When a variable
is tied, it is associated with the object which is the
return value of the <small>TIESCALAR, TIEARRAY,</small> or
<small>TIEHASH</small> function. This object normally has
only one reference, namely, the implicit reference from the
tied variable. When <b>untie()</b> is called, that reference
is destroyed. Then, as in the first example above, the
object&rsquo;s destructor ( <small>DESTROY</small> ) is
called, which is normal for objects that have no more valid
references; and thus the file is closed.</p>

<p style="margin-left:11%; margin-top: 1em">In the second
example, however, we have stored another reference to the
tied object in $x. That means that when <b>untie()</b> gets
called there will still be a valid reference to the object
in existence, so the destructor is not called at that time,
and thus the file is not closed. The reason there is no
output is because the file buffers have not been flushed to
disk.</p>

<p style="margin-left:11%; margin-top: 1em">Now that you
know what the problem is, what can you do to avoid it? Prior
to the introduction of the optional <small>UNTIE</small>
method the only way was the good old &quot;&minus;w&quot;
flag. Which will spot any instances where you call
<b>untie()</b> and there are still valid references to the
tied object. If the second script above this near the top
&quot;use warnings 'untie'&quot; or was run with the
&quot;&minus;w&quot; flag, Perl prints this warning
message:</p>

<p style="margin-left:11%; margin-top: 1em">untie attempted
while 1 inner references still exist</p>

<p style="margin-left:11%; margin-top: 1em">To get the
script to work properly and silence the warning make sure
there are no valid references to the tied object
<i>before</i> <b>untie()</b> is called:</p>

<p style="margin-left:11%; margin-top: 1em">undef $x; <br>
untie $fred;</p>

<p style="margin-left:11%; margin-top: 1em">Now that
<small>UNTIE</small> exists the class designer can decide
which parts of the class functionality are really associated
with &quot;untie&quot; and which with the object being
destroyed. What makes sense for a given class depends on
whether the inner references are being kept so that
non-tie-related methods can be called on the object. But in
most cases it probably makes sense to move the functionality
that would have been in <small>DESTROY</small> to the
<small>UNTIE</small> method.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<small>UNTIE</small> method exists then the warning above
does not occur. Instead the <small>UNTIE</small> method is
passed the count of &quot;extra&quot; references and can
issue its own warning if appropriate. e.g. to replicate the
no <small>UNTIE</small> case this method can be used:</p>

<p style="margin-left:11%; margin-top: 1em">sub UNTIE <br>
{ <br>
my ($obj,$count) = @_; <br>
carp &quot;untie attempted while $count inner references
still exist&quot; <br>
if $count; <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See DB_File or
Config for some interesting <b>tie()</b> implementations. A
good starting point for many <b>tie()</b> implementations is
with one of the modules Tie::Scalar, Tie::Array, Tie::Hash,
or Tie::Handle.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The normal
return provided by &quot;scalar(%hash)&quot; is not
available. What this means is that using %tied_hash in
boolean context doesn&rsquo;t work right (currently this
always tests false, regardless of whether the hash is empty
or hash elements). [ This paragraph needs review in light of
changes in 5.25 ]</p>

<p style="margin-left:11%; margin-top: 1em">Localizing tied
arrays or hashes does not work. After exiting the scope the
arrays or the hashes are not restored.</p>

<p style="margin-left:11%; margin-top: 1em">Counting the
number of entries in a hash via
&quot;scalar(keys(%hash))&quot; or
&quot;scalar(values(%hash)&quot;) is inefficient since it
needs to iterate through all the entries with
<small>FIRSTKEY/NEXTKEY.</small></p>

<p style="margin-left:11%; margin-top: 1em">Tied hash/array
slices cause multiple <small>FETCH/STORE</small> pairs,
there are no tie methods for slice operations.</p>

<p style="margin-left:11%; margin-top: 1em">You cannot
easily tie a multilevel data structure (such as a hash of
hashes) to a dbm file. The first problem is that all but
<small>GDBM</small> and Berkeley <small>DB</small> have size
limitations, but beyond that, you also have problems with
how references are to be represented on disk. One module
that does attempt to address this need is DBM::Deep. Check
your nearest <small>CPAN</small> site as described in
perlmodlib for source code. Note that despite its name,
DBM::Deep does not use dbm. Another earlier attempt at
solving the problem is <small>MLDBM,</small> which is also
available on the <small>CPAN,</small> but which has some
fairly serious limitations.</p>

<p style="margin-left:11%; margin-top: 1em">Tied
filehandles are still incomplete. <b>sysopen()</b>,
<b>truncate()</b>, <b>flock()</b>, <b>fcntl()</b>,
<b>stat()</b> and &minus;X can&rsquo;t currently be
trapped.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Tom
Christiansen</p>


<p style="margin-left:11%; margin-top: 1em"><small>TIEHANDLE</small>
by Sven Verdoolaege &lt;<i>skimo@dns.ufsia.ac.be</i>&gt; and
Doug MacEachern &lt;<i>dougm@osf.org</i>&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><small>UNTIE</small>
by Nick Ing-Simmons
&lt;<i>nick@ing&minus;simmons.net</i>&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><small>SCALAR</small>
by Tassilo von Parseval
&lt;<i>tassilo.von.parseval@rwth&minus;aachen.de</i>&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Tying Arrays by
Casey West &lt;<i>casey@geeknest.com</i>&gt;</p>
<hr>
</body>
</html>
