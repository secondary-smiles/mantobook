<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:00 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PERLOP</title>

</head>
<body>
<h1>perlop</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlop &minus;
Perl operators and precedence</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In Perl, the
operator determines what operation is performed, independent
of the type of the operands. For example
&quot;$x&nbsp;+&nbsp;$y&quot; is always a numeric addition,
and if $x or $y do not contain numbers, an attempt is made
to convert them to numbers first.</p>

<p style="margin-left:11%; margin-top: 1em">This is in
contrast to many other dynamic languages, where the
operation is determined by the type of the first argument.
It also means that Perl has two versions of some operators,
one for numeric and one for string comparison. For example
&quot;$x&nbsp;==&nbsp;$y&quot; compares two numbers for
equality, and &quot;$x&nbsp;eq&nbsp;$y&quot; compares two
strings.</p>

<p style="margin-left:11%; margin-top: 1em">There are a few
exceptions though: &quot;x&quot; can be either string
repetition or list repetition, depending on the type of the
left operand, and &quot;&amp;&quot;, &quot;|&quot;,
&quot;^&quot; and &quot;~&quot; can be either string or
numeric bit operations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operator
Precedence and Associativity</b> <br>
Operator precedence and associativity work in Perl more or
less like they do in mathematics.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Operator
precedence</i> means some operators group more tightly than
others. For example, in &quot;2 + 4 * 5&quot;, the
multiplication has higher precedence, so &quot;4 * 5&quot;
is grouped together as the right-hand operand of the
addition, rather than &quot;2 + 4&quot; being grouped
together as the left-hand operand of the multiplication. It
is as if the expression were written &quot;2 + (4 *
5)&quot;, not &quot;(2 + 4) * 5&quot;. So the expression
yields &quot;2 + 20 == 22&quot;, rather than &quot;6 * 5 ==
30&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Operator
associativity</i> defines what happens if a sequence of the
same operators is used one after another: usually that they
will be grouped at the left or the right. For example, in
&quot;9 &minus; 3 &minus; 2&quot;, subtraction is left
associative, so &quot;9 &minus; 3&quot; is grouped together
as the left-hand operand of the second subtraction, rather
than &quot;3 &minus; 2&quot; being grouped together as the
right-hand operand of the first subtraction. It is as if the
expression were written &quot;(9 &minus; 3) &minus; 2&quot;,
not &quot;9 &minus; (3 &minus; 2)&quot;. So the expression
yields &quot;6 &minus; 2 == 4&quot;, rather than &quot;9
&minus; 1 == 8&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">For simple
operators that evaluate all their operands and then combine
the values in some way, precedence and associativity (and
parentheses) imply some ordering requirements on those
combining operations. For example, in &quot;2 + 4 * 5&quot;,
the grouping implied by precedence means that the
multiplication of 4 and 5 must be performed before the
addition of 2 and 20, simply because the result of that
multiplication is required as one of the operands of the
addition. But the order of operations is not fully
determined by this: in &quot;2 * 2 + 4 * 5&quot; both
multiplications must be performed before the addition, but
the grouping does not say anything about the order in which
the two multiplications are performed. In fact Perl has a
general rule that the operands of an operator are evaluated
in left-to-right order. A few operators such as
&quot;&amp;&amp;=&quot; have special evaluation rules that
can result in an operand not being evaluated at all; in
general, the top-level operator in an expression has control
of operand evaluation.</p>

<p style="margin-left:11%; margin-top: 1em">Some comparison
operators, as their associativity, <i>chain</i> with some
operators of the same precedence (but never with operators
of different precedence). This chaining means that each
comparison is performed on the two arguments surrounding it,
with each interior argument taking part in two comparisons,
and the comparison results are implicitly ANDed. Thus
&quot;$x&nbsp;&lt;&nbsp;$y&nbsp;&lt;=&nbsp;$z&quot; behaves
exactly like
&quot;$x&nbsp;&lt;&nbsp;$y&nbsp;&amp;&amp;&nbsp;$y&nbsp;&lt;=&nbsp;$z&quot;,
assuming that &quot;$y&quot; is as simple a scalar as it
looks. The ANDing short-circuits just like
&quot;&amp;&amp;&quot; does, stopping the sequence of
comparisons as soon as one yields false.</p>

<p style="margin-left:11%; margin-top: 1em">In a chained
comparison, each argument expression is evaluated at most
once, even if it takes part in two comparisons, but the
result of the evaluation is fetched for each comparison. (It
is not evaluated at all if the short-circuiting means that
it&rsquo;s not required for any comparisons.) This matters
if the computation of an interior argument is expensive or
non-deterministic. For example,</p>

<p style="margin-left:11%; margin-top: 1em">if($x &lt;
expensive_sub() &lt;= $z) { ...</p>

<p style="margin-left:11%; margin-top: 1em">is not entirely
like</p>

<p style="margin-left:11%; margin-top: 1em">if($x &lt;
expensive_sub() &amp;&amp; expensive_sub() &lt;= $z) {
...</p>

<p style="margin-left:11%; margin-top: 1em">but instead
closer to</p>

<p style="margin-left:11%; margin-top: 1em">my $tmp =
expensive_sub(); <br>
if($x &lt; $tmp &amp;&amp; $tmp &lt;= $z) { ...</p>

<p style="margin-left:11%; margin-top: 1em">in that the
subroutine is only called once. However, it&rsquo;s not
exactly like this latter code either, because the chained
comparison doesn&rsquo;t actually involve any temporary
variable (named or otherwise): there is no assignment. This
doesn&rsquo;t make much difference where the expression is a
call to an ordinary subroutine, but matters more with an
lvalue subroutine, or if the argument expression yields some
unusual kind of scalar by other means. For example, if the
argument expression yields a tied scalar, then the
expression is evaluated to produce that scalar at most once,
but the value of that scalar may be fetched up to twice,
once for each comparison in which it is actually used.</p>

<p style="margin-left:11%; margin-top: 1em">In this
example, the expression is evaluated only once, and the tied
scalar (the result of the expression) is fetched for each
comparison that uses it.</p>

<p style="margin-left:11%; margin-top: 1em">if ($x &lt;
$tied_scalar &lt; $z) { ...</p>

<p style="margin-left:11%; margin-top: 1em">In the next
example, the expression is evaluated only once, and the tied
scalar is fetched once as part of the operation within the
expression. The result of that operation is fetched for each
comparison, which normally doesn&rsquo;t matter unless that
expression result is also magical due to operator
overloading.</p>

<p style="margin-left:11%; margin-top: 1em">if ($x &lt;
$tied_scalar + 42 &lt; $z) { ...</p>

<p style="margin-left:11%; margin-top: 1em">Some operators
are instead non-associative, meaning that it is a syntax
error to use a sequence of those operators of the same
precedence. For example,
&quot;$x&nbsp;..&nbsp;$y&nbsp;..&nbsp;$z&quot; is an
error.</p>

<p style="margin-left:11%; margin-top: 1em">Perl operators
have the following associativity and precedence, listed from
highest precedence to lowest. Operators borrowed from C keep
the same precedence relationship with each other, even where
C&rsquo;s precedence is slightly screwy. (This makes
learning Perl easier for C folks.) With very few exceptions,
these all operate on scalar values only, not array
values.</p>

<p style="margin-left:11%; margin-top: 1em">left terms and
list operators (leftward) <br>
left &minus;&gt; <br>
nonassoc ++ &minus;&minus; <br>
right ** <br>
right ! ~ ~. \ and unary + and &minus; <br>
left =~ !~ <br>
left * / % x <br>
left + &minus; . <br>
left &lt;&lt; &gt;&gt; <br>
nonassoc named unary operators <br>
nonassoc isa <br>
chained &lt; &gt; &lt;= &gt;= lt gt le ge <br>
chain/na == != eq ne &lt;=&gt; cmp ~~ <br>
left &amp; &amp;. <br>
left | |. ^ ^. <br>
left &amp;&amp; <br>
left || // <br>
nonassoc .. ... <br>
right ?: <br>
right = += &minus;= *= etc. goto last next redo dump <br>
left , =&gt; <br>
nonassoc list operators (rightward) <br>
right not <br>
left and <br>
left or xor</p>

<p style="margin-left:11%; margin-top: 1em">In the
following sections, these operators are covered in detail,
in the same order in which they appear in the table
above.</p>

<p style="margin-left:11%; margin-top: 1em">Many operators
can be overloaded for objects. See overload.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Terms and
List Operators (Leftward)</b> <br>
A <small>TERM</small> has the highest precedence in Perl.
They include variables, quote and quote-like operators, any
expression in parentheses, and any function whose arguments
are parenthesized. Actually, there aren&rsquo;t really
functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses
around the arguments. These are all documented in
perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em">If any list
operator (&quot;print()&quot;, etc.) or any unary operator
(&quot;chdir()&quot;, etc.) is followed by a left
parenthesis as the next token, the operator and arguments
within parentheses are taken to be of highest precedence,
just like a normal function call.</p>

<p style="margin-left:11%; margin-top: 1em">In the absence
of parentheses, the precedence of list operators such as
&quot;print&quot;, &quot;sort&quot;, or &quot;chmod&quot; is
either very high or very low depending on whether you are
looking at the left side or the right side of the operator.
For example, in</p>

<p style="margin-left:11%; margin-top: 1em">@ary = (1, 3,
sort 4, 2); <br>
print @ary; # prints 1324</p>

<p style="margin-left:11%; margin-top: 1em">the commas on
the right of the &quot;sort&quot; are evaluated before the
&quot;sort&quot;, but the commas on the left are evaluated
after. In other words, list operators tend to gobble up all
arguments that follow, and then act like a simple
<small>TERM</small> with regard to the preceding expression.
Be careful with parentheses:</p>

<p style="margin-left:11%; margin-top: 1em"># These
evaluate exit before doing the print: <br>
print($foo, exit); # Obviously not what you want. <br>
print $foo, exit; # Nor is this. <br>
# These do the print before evaluating exit: <br>
(print $foo), exit; # This is what you want. <br>
print($foo), exit; # Or this. <br>
print ($foo), exit; # Or even this.</p>

<p style="margin-left:11%; margin-top: 1em">Also note
that</p>

<p style="margin-left:11%; margin-top: 1em">print ($foo
&amp; 255) + 1, &quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">probably
doesn&rsquo;t do what you expect at first glance. The
parentheses enclose the argument list for &quot;print&quot;
which is evaluated (printing the result of
&quot;$foo&nbsp;&amp;&nbsp;255&quot;). Then one is added to
the return value of &quot;print&quot; (usually 1). The
result is something like this:</p>

<p style="margin-left:11%; margin-top: 1em">1 + 1,
&quot;\n&quot;; # Obviously not what you meant.</p>

<p style="margin-left:11%; margin-top: 1em">To do what you
meant properly, you must write:</p>

<p style="margin-left:11%; margin-top: 1em">print(($foo
&amp; 255) + 1, &quot;\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;Named
Unary Operators&quot; for more discussion of this.</p>

<p style="margin-left:11%; margin-top: 1em">Also parsed as
terms are the &quot;do&nbsp;{}&quot; and
&quot;eval&nbsp;{}&quot; constructs, as well as subroutine
and method calls, and the anonymous constructors
&quot;[]&quot; and &quot;{}&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Quote and Quote-like Operators&quot; toward the end of
this section, as well as &quot;I/O Operators&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Arrow
Operator</b> <br>
&quot;&quot;&minus;&gt;&quot;&quot; is an infix dereference
operator, just as it is in C and C <small>++</small> . If
the right side is either a &quot;[...]&quot;,
&quot;{...}&quot;, or a &quot;(...)&quot; subscript, then
the left side must be either a hard or symbolic reference to
an array, a hash, or a subroutine respectively. (Or
technically speaking, a location capable of holding a hard
reference, if it&rsquo;s an array or hash reference being
used for assignment.) See perlreftut and perlref.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, the
right side is a method name or a simple scalar variable
containing either the method name or a subroutine reference,
and (if it is a method name) the left side must be either an
object (a blessed reference) or a class name (that is, a
package name). See perlobj.</p>

<p style="margin-left:11%; margin-top: 1em">The
dereferencing cases (as opposed to method-calling cases) are
somewhat extended by the &quot;postderef&quot; feature. For
the details of that feature, consult &quot;Postfix
Dereference Syntax&quot; in perlref.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Auto-increment
and Auto-decrement</b> <br>
&quot;++&quot; and &quot;&minus;&minus;&quot; work as in C.
That is, if placed before a variable, they increment or
decrement the variable by one before returning the value,
and if placed after, increment or decrement after returning
the value.</p>

<p style="margin-left:11%; margin-top: 1em">$i = 0; $j = 0;
<br>
print $i++; # prints 0 <br>
print ++$j; # prints 1</p>

<p style="margin-left:11%; margin-top: 1em">Note that just
as in C, Perl doesn&rsquo;t define <b>when</b> the variable
is incremented or decremented. You just know it will be done
sometime before or after the value is returned. This also
means that modifying a variable twice in the same statement
will lead to undefined behavior. Avoid statements like:</p>

<p style="margin-left:11%; margin-top: 1em">$i = $i ++;
<br>
print ++ $i + $i ++;</p>

<p style="margin-left:11%; margin-top: 1em">Perl will not
guarantee what the result of the above statements is.</p>

<p style="margin-left:11%; margin-top: 1em">The
auto-increment operator has a little extra builtin magic to
it. If you increment a variable that is numeric, or that has
ever been used in a numeric context, you get a normal
increment. If, however, the variable has been used in only
string contexts since it was set, and has a value that is
not the empty string and matches the pattern
&quot;/^[a&minus;zA&minus;Z]*[0&minus;9]*\z/&quot;, the
increment is done as a string, preserving each character
within its range, with carry:</p>

<p style="margin-left:11%; margin-top: 1em">print ++($foo =
&quot;99&quot;); # prints &quot;100&quot; <br>
print ++($foo = &quot;a0&quot;); # prints &quot;a1&quot;
<br>
print ++($foo = &quot;Az&quot;); # prints &quot;Ba&quot;
<br>
print ++($foo = &quot;zz&quot;); # prints
&quot;aaa&quot;</p>


<p style="margin-left:11%; margin-top: 1em">&quot;undef&quot;
is always treated as numeric, and in particular is changed
to 0 before incrementing (so that a post-increment of an
undef value will return 0 rather than
&quot;undef&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">The
auto-decrement operator is not magical.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exponentiation</b>
<br>
Binary &quot;**&quot; is the exponentiation operator. It
binds even more tightly than unary minus, so
&quot;&minus;2**4&quot; is &quot;&minus;(2**4)&quot;, not
&quot;(&minus;2)**4&quot;. (This is implemented using
C&rsquo;s pow(3) function, which actually works on doubles
internally.)</p>

<p style="margin-left:11%; margin-top: 1em">Note that
certain exponentiation expressions are ill-defined: these
include &quot;0**0&quot;, &quot;1**Inf&quot;, and
&quot;Inf**0&quot;. Do not expect any particular results
from these special cases, the results are
platform-dependent.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Symbolic
Unary Operators</b> <br>
Unary &quot;!&quot; performs logical negation, that is,
&quot;not&quot;. See also &quot;not&quot; for a lower
precedence version of this.</p>

<p style="margin-left:11%; margin-top: 1em">Unary
&quot;&minus;&quot; performs arithmetic negation if the
operand is numeric, including any string that looks like a
number. If the operand is an identifier, a string consisting
of a minus sign concatenated with the identifier is
returned. Otherwise, if the string starts with a plus or
minus, a string starting with the opposite sign is returned.
One effect of these rules is that
&quot;&minus;bareword&quot; is equivalent to the string
&quot;&minus;bareword&quot;. If, however, the string begins
with a non-alphabetic character (excluding &quot;+&quot; or
&quot;&minus;&quot;), Perl will attempt to convert the
string to a numeric, and the arithmetic negation is
performed. If the string cannot be cleanly converted to a
numeric, Perl will give the warning <b>Argument &quot;the
string&quot; isn&rsquo;t numeric in negation (&minus;) at
...</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Unary
&quot;~&quot; performs bitwise negation, that is, 1&rsquo;s
complement. For example,
&quot;0666&nbsp;&amp;&nbsp;~027&quot; is 0640. (See also
&quot;Integer Arithmetic&quot; and &quot;Bitwise String
Operators&quot;.) Note that the width of the result is
platform-dependent: &quot;~0&quot; is 32 bits wide on a
32&minus;bit platform, but 64 bits wide on a 64&minus;bit
platform, so if you are expecting a certain bit width,
remember to use the &quot;&amp;&quot; operator to mask off
the excess bits.</p>

<p style="margin-left:11%; margin-top: 1em">Starting in
Perl 5.28, it is a fatal error to try to complement a string
containing a character with an ordinal value above 255.</p>

<p style="margin-left:11%; margin-top: 1em">If the
&quot;bitwise&quot; feature is enabled via
&quot;use&nbsp;feature&nbsp;'bitwise'&quot; or &quot;use
v5.28&quot;, then unary &quot;~&quot; always treats its
argument as a number, and an alternate form of the operator,
&quot;~.&quot;, always treats its argument as a string. So
&quot;~0&quot; and &quot;~&quot;0&quot;&quot; will both give
2**32&minus;1 on 32&minus;bit platforms, whereas
&quot;~.0&quot; and &quot;~.&quot;0&quot;&quot; will both
yield &quot;\xff&quot;. Until Perl 5.28, this feature
produced a warning in the &quot;experimental::bitwise&quot;
category.</p>

<p style="margin-left:11%; margin-top: 1em">Unary
&quot;+&quot; has no effect whatsoever, even on strings. It
is useful syntactically for separating a function name from
a parenthesized expression that would otherwise be
interpreted as the complete list of function arguments. (See
examples above under &quot;Terms and List Operators
(Leftward)&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">Unary
&quot;\&quot; creates references. If its operand is a single
sigilled thing, it creates a reference to that object. If
its operand is a parenthesised list, then it creates
references to the things mentioned in the list. Otherwise it
puts its operand in list context, and creates a list of
references to the scalars in the list provided by the
operand. See perlreftut and perlref. Do not confuse this
behavior with the behavior of backslash within a string,
although both forms do convey the notion of protecting the
next thing from interpolation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Binding
Operators</b> <br>
Binary &quot;=~&quot; binds a scalar expression to a pattern
match. Certain operations search or modify the string $_ by
default. This operator makes that kind of operation work on
some other string. The right argument is a search pattern,
substitution, or transliteration. The left argument is what
is supposed to be searched, substituted, or transliterated
instead of the default $_. When used in scalar context, the
return value generally indicates the success of the
operation. The exceptions are substitution
(&quot;s///&quot;) and transliteration (&quot;y///&quot;)
with the &quot;/r&quot; (non-destructive) option, which
cause the <b>r</b>eturn value to be the result of the
substitution. Behavior in list context depends on the
particular operator. See &quot;Regexp Quote-Like
Operators&quot; for details and perlretut for examples using
these operators.</p>

<p style="margin-left:11%; margin-top: 1em">If the right
argument is an expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a
search pattern at run time. Note that this means that its
contents will be interpolated twice, so</p>

<p style="margin-left:11%; margin-top: 1em">'\\' =~
q'\\';</p>

<p style="margin-left:11%; margin-top: 1em">is not ok, as
the regex engine will end up trying to compile the pattern
&quot;\&quot;, which it will consider a syntax error.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;!~&quot; is just like &quot;=~&quot; except the return
value is negated in the logical sense.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;!~&quot; with a non-destructive substitution
(&quot;s///r&quot;) or transliteration (&quot;y///r&quot;)
is a syntax error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Multiplicative
Operators</b> <br>
Binary &quot;*&quot; multiplies two numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;/&quot; divides two numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;%&quot; is the modulo operator, which computes the
division remainder of its first argument with respect to its
second argument. Given integer operands $m and $n: If $n is
positive, then &quot;$m&nbsp;%&nbsp;$n&quot; is $m minus the
largest multiple of $n less than or equal to $m. If $n is
negative, then &quot;$m&nbsp;%&nbsp;$n&quot; is $m minus the
smallest multiple of $n that is not less than $m (that is,
the result will be less than or equal to zero). If the
operands $m and $n are floating point values and the
absolute value of $n (that is &quot;abs($n)&quot;) is less
than &quot;(UV_MAX&nbsp;+&nbsp;1)&quot;, only the integer
portion of $m and $n will be used in the operation (Note:
here &quot;UV_MAX&quot; means the maximum of the unsigned
integer type). If the absolute value of the right operand
(&quot;abs($n)&quot;) is greater than or equal to
&quot;(UV_MAX&nbsp;+&nbsp;1)&quot;, &quot;%&quot; computes
the floating-point remainder $r in the equation
&quot;($r&nbsp;=&nbsp;$m&nbsp;&minus;&nbsp;$i*$n)&quot;
where $i is a certain integer that makes $r have the same
sign as the right operand $n (<b>not</b> as the left operand
$m like C function &quot;fmod()&quot;) and the absolute
value less than that of $n. Note that when
&quot;use&nbsp;integer&quot; is in scope, &quot;%&quot;
gives you direct access to the modulo operator as
implemented by your C compiler. This operator is not as well
defined for negative operands, but it will execute
faster.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;x&quot; is the repetition operator. In scalar context,
or if the left operand is neither enclosed in parentheses
nor a &quot;qw//&quot; list, it performs a string
repetition. In that case it supplies scalar context to the
left operand, and returns a string consisting of the left
operand string repeated the number of times specified by the
right operand. If the &quot;x&quot; is in list context, and
the left operand is either enclosed in parentheses or a
&quot;qw//&quot; list, it performs a list repetition. In
that case it supplies list context to the left operand, and
returns a list consisting of the left operand list repeated
the number of times specified by the right operand. If the
right operand is zero or negative (raising a warning on
negative), it returns an empty string or an empty list,
depending on the context.</p>

<p style="margin-left:11%; margin-top: 1em">print '&minus;'
x 80; # print row of dashes <br>
print &quot;\t&quot; x ($tab/8), ' ' x ($tab%8); # tab over
<br>
@ones = (1) x 80; # a list of 80 1's <br>
@ones = (5) x @ones; # set all elements to 5</p>

<p style="margin-left:11%; margin-top: 1em"><b>Additive
Operators</b> <br>
Binary &quot;+&quot; returns the sum of two numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;&minus;&quot; returns the difference of two
numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;.&quot; concatenates two strings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Shift
Operators</b> <br>
Binary &quot;&lt;&lt;&quot; returns the value of its left
argument shifted left by the number of bits specified by the
right argument. Arguments should be integers. (See also
&quot;Integer Arithmetic&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;&gt;&gt;&quot; returns the value of its left argument
shifted right by the number of bits specified by the right
argument. Arguments should be integers. (See also
&quot;Integer Arithmetic&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">If
&quot;use&nbsp;integer&quot; (see &quot;Integer
Arithmetic&quot;) is in force then signed C integers are
used (<i>arithmetic shift</i>), otherwise unsigned C
integers are used (<i>logical shift</i>), even for negative
shiftees. In arithmetic right shift the sign bit is
replicated on the left, in logical shift zero bits come in
from the left.</p>

<p style="margin-left:11%; margin-top: 1em">Either way, the
implementation isn&rsquo;t going to generate results larger
than the size of the integer type Perl was built with (32
bits or 64 bits).</p>

<p style="margin-left:11%; margin-top: 1em">Shifting by
negative number of bits means the reverse shift: left shift
becomes right shift, right shift becomes left shift. This is
unlike in C, where negative shift is undefined.</p>

<p style="margin-left:11%; margin-top: 1em">Shifting by
more bits than the size of the integers means most of the
time zero (all bits fall off), except that under
&quot;use&nbsp;integer&quot; right overshifting a negative
shiftee results in &minus;1. This is unlike in C, where
shifting by too many bits is undefined. A common C behavior
is &quot;shift by modulo wordbits&quot;, so that for
example</p>

<p style="margin-left:11%; margin-top: 1em">1 &gt;&gt; 64
== 1 &gt;&gt; (64 % 64) == 1 &gt;&gt; 0 == 1 # Common C
behavior.</p>

<p style="margin-left:11%; margin-top: 1em">but that is
completely accidental.</p>

<p style="margin-left:11%; margin-top: 1em">If you get
tired of being subject to your platform&rsquo;s native
integers, the &quot;use&nbsp;bigint&quot; pragma neatly
sidesteps the issue altogether:</p>

<p style="margin-left:11%; margin-top: 1em">print 20
&lt;&lt; 20; # 20971520 <br>
print 20 &lt;&lt; 40; # 5120 on 32&minus;bit machines, <br>
# 21990232555520 on 64&minus;bit machines <br>
use bigint; <br>
print 20 &lt;&lt; 100; #
25353012004564588029934064107520</p>

<p style="margin-left:11%; margin-top: 1em"><b>Named Unary
Operators</b> <br>
The various named unary operators are treated as functions
with one argument, with optional parentheses.</p>

<p style="margin-left:11%; margin-top: 1em">If any list
operator (&quot;print()&quot;, etc.) or any unary operator
(&quot;chdir()&quot;, etc.) is followed by a left
parenthesis as the next token, the operator and arguments
within parentheses are taken to be of highest precedence,
just like a normal function call. For example, because named
unary operators are higher precedence than
&quot;||&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">chdir $foo ||
die; # (chdir $foo) || die <br>
chdir($foo) || die; # (chdir $foo) || die <br>
chdir ($foo) || die; # (chdir $foo) || die <br>
chdir +($foo) || die; # (chdir $foo) || die</p>

<p style="margin-left:11%; margin-top: 1em">but, because
&quot;*&quot; is higher precedence than named operators:</p>

<p style="margin-left:11%; margin-top: 1em">chdir $foo *
20; # chdir ($foo * 20) <br>
chdir($foo) * 20; # (chdir $foo) * 20 <br>
chdir ($foo) * 20; # (chdir $foo) * 20 <br>
chdir +($foo) * 20; # chdir ($foo * 20) <br>
rand 10 * 20; # rand (10 * 20) <br>
rand(10) * 20; # (rand 10) * 20 <br>
rand (10) * 20; # (rand 10) * 20 <br>
rand +(10) * 20; # rand (10 * 20)</p>

<p style="margin-left:11%; margin-top: 1em">Regarding
precedence, the filetest operators, like
&quot;&minus;f&quot;, &quot;&minus;M&quot;, etc. are treated
like named unary operators, but they don&rsquo;t follow this
functional parenthesis rule. That means, for example, that
&quot;&minus;f($file).&quot;.bak&quot;&quot; is equivalent
to &quot;&minus;f&nbsp;&quot;$file.bak&quot;&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">See also
&quot;Terms and List Operators (Leftward)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Relational
Operators</b> <br>
Perl operators that return true or false generally return
values that can be safely used as numbers. For example, the
relational operators in this section and the equality
operators in the next one return 1 for true and a special
version of the defined empty string, &quot;&quot;, which
counts as a zero but is exempt from warnings about improper
numeric conversions, just as
&quot;0&nbsp;but&nbsp;true&quot; is.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;&lt;&quot; returns true if the left argument is
numerically less than the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;&gt;&quot; returns true if the left argument is
numerically greater than the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;&lt;=&quot; returns true if the left argument is
numerically less than or equal to the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;&gt;=&quot; returns true if the left argument is
numerically greater than or equal to the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;lt&quot; returns true if the left argument is
stringwise less than the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;gt&quot; returns true if the left argument is
stringwise greater than the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;le&quot; returns true if the left argument is
stringwise less than or equal to the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;ge&quot; returns true if the left argument is
stringwise greater than or equal to the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">A sequence of
relational operators, such as
&quot;$x&nbsp;&lt;&nbsp;$y&nbsp;&lt;=&nbsp;$z&quot;,
performs chained comparisons, in the manner described above
in the section &quot;Operator Precedence and
Associativity&quot;. Beware that they do not chain with
equality operators, which have lower precedence.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Equality
Operators</b> <br>
Binary &quot;==&quot; returns true if the left argument is
numerically equal to the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;!=&quot; returns true if the left argument is
numerically not equal to the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;eq&quot; returns true if the left argument is
stringwise equal to the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;ne&quot; returns true if the left argument is
stringwise not equal to the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">A sequence of
the above equality operators, such as
&quot;$x&nbsp;==&nbsp;$y&nbsp;==&nbsp;$z&quot;, performs
chained comparisons, in the manner described above in the
section &quot;Operator Precedence and Associativity&quot;.
Beware that they do not chain with relational operators,
which have higher precedence.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;&lt;=&gt;&quot; returns &minus;1, 0, or 1 depending on
whether the left argument is numerically less than, equal
to, or greater than the right argument. If your platform
supports &quot;NaN&quot;&rsquo;s (not-a-numbers) as numeric
values, using them with &quot;&lt;=&gt;&quot; returns undef.
&quot;NaN&quot; is not &quot;&lt;&quot;, &quot;==&quot;,
&quot;&gt;&quot;, &quot;&lt;=&quot; or &quot;&gt;=&quot;
anything (even &quot;NaN&quot;), so those 5 return false.
&quot;NaN&nbsp;!=&nbsp;NaN&quot; returns true, as does
&quot;NaN&nbsp;!=&quot;&nbsp;<i>anything&nbsp;else</i>. If
your platform doesn&rsquo;t support &quot;NaN&quot;&rsquo;s
then &quot;NaN&quot; is just a string with numeric value
0.</p>

<p style="margin-left:11%; margin-top: 1em">$ perl
&minus;le '$x = &quot;NaN&quot;; print &quot;No NaN support
here&quot; if $x == $x' <br>
$ perl &minus;le '$x = &quot;NaN&quot;; print &quot;NaN
support here&quot; if $x != $x'</p>

<p style="margin-left:11%; margin-top: 1em">(Note that the
bigint, bigrat, and bignum pragmas all support
&quot;NaN&quot;.)</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;cmp&quot; returns &minus;1, 0, or 1 depending on
whether the left argument is stringwise less than, equal to,
or greater than the right argument.</p>

<p style="margin-left:11%; margin-top: 1em">Here we can see
the difference between &lt;=&gt; and cmp,</p>

<p style="margin-left:11%; margin-top: 1em">print 10
&lt;=&gt; 2 #prints 1 <br>
print 10 cmp 2 #prints &minus;1</p>

<p style="margin-left:11%; margin-top: 1em">(likewise
between gt and &gt;, lt and &lt;, etc.)</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;~~&quot; does a smartmatch between its arguments.
Smart matching is described in the next section.</p>

<p style="margin-left:11%; margin-top: 1em">The two-sided
ordering operators &quot;&lt;=&gt;&quot; and
&quot;cmp&quot;, and the smartmatch operator &quot;~~&quot;,
are non-associative with respect to each other and with
respect to the equality operators of the same
precedence.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;lt&quot;,
&quot;le&quot;, &quot;ge&quot;, &quot;gt&quot; and
&quot;cmp&quot; use the collation (sort) order specified by
the current &quot;LC_COLLATE&quot; locale if a
&quot;use&nbsp;locale&quot; form that includes collation is
in effect. See perllocale. Do not mix these with Unicode,
only use them with legacy 8&minus;bit locale encodings. The
standard &quot;Unicode::Collate&quot; and
&quot;Unicode::Collate::Locale&quot; modules offer much more
powerful solutions to collation issues.</p>

<p style="margin-left:11%; margin-top: 1em">For
case-insensitive comparisons, look at the &quot;fc&quot; in
perlfunc case-folding function, available in Perl v5.16 or
later:</p>

<p style="margin-left:11%; margin-top: 1em">if ( fc($x) eq
fc($y) ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em"><b>Class
Instance Operator</b> <br>
Binary &quot;isa&quot; evaluates to true when the left
argument is an object instance of the class (or a subclass
derived from that class) given by the right argument. If the
left argument is not defined, not a blessed object instance,
nor does not derive from the class given by the right
argument, the operator evaluates as false. The right
argument may give the class either as a bareword or a scalar
expression that yields a string class name:</p>

<p style="margin-left:11%; margin-top: 1em">if( $obj isa
Some::Class ) { ... } <br>
if( $obj isa &quot;Different::Class&quot; ) { ... } <br>
if( $obj isa $name_of_class ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">This feature is
available from Perl 5.31.6 onwards when enabled by &quot;use
feature 'isa'&quot;. This feature is enabled automatically
by a &quot;use v5.36&quot; (or higher) declaration in the
current scope.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Smartmatch
Operator</b> <br>
First available in Perl 5.10.1 (the 5.10.0 version behaved
differently), binary &quot;~~&quot; does a
&quot;smartmatch&quot; between its arguments. This is mostly
used implicitly in the &quot;when&quot; construct described
in perlsyn, although not all &quot;when&quot; clauses call
the smartmatch operator. Unique among all of Perl&rsquo;s
operators, the smartmatch operator can recurse. The
smartmatch operator is experimental and its behavior is
subject to change.</p>

<p style="margin-left:11%; margin-top: 1em">It is also
unique in that all other Perl operators impose a context
(usually string or numeric context) on their operands,
autoconverting those operands to those imposed contexts. In
contrast, smartmatch <i>infers</i> contexts from the actual
types of its operands and uses that type information to
select a suitable comparison mechanism.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;~~&quot; operator compares its operands
&quot;polymorphically&quot;, determining how to compare them
according to their actual types (numeric, string, array,
hash, etc.). Like the equality operators with which it
shares the same precedence, &quot;~~&quot; returns 1 for
true and &quot;&quot; for false. It is often best read aloud
as &quot;in&quot;, &quot;inside of&quot;, or &quot;is
contained in&quot;, because the left operand is often looked
for <i>inside</i> the right operand. That makes the order of
the operands to the smartmatch operand often opposite that
of the regular match operator. In other words, the
&quot;smaller&quot; thing is usually placed in the left
operand and the larger one in the right.</p>

<p style="margin-left:11%; margin-top: 1em">The behavior of
a smartmatch depends on what type of things its arguments
are, as determined by the following table. The first row of
the table whose types apply determines the smartmatch
behavior. Because what actually happens is mostly determined
by the type of the second operand, the table is sorted on
the right operand instead of on the left.</p>

<p style="margin-left:11%; margin-top: 1em">Left Right
Description and pseudocode <br>

===============================================================
<br>
Any undef check whether Any is undefined <br>
like: !defined Any <br>
Any Object invoke ~~ overloading on Object, or die <br>
Right operand is an ARRAY: <br>
Left Right Description and pseudocode <br>

===============================================================
<br>
ARRAY1 ARRAY2 recurse on paired elements of ARRAY1 and
ARRAY2[2] <br>
like: (ARRAY1[0] ~~ ARRAY2[0]) <br>
&amp;&amp; (ARRAY1[1] ~~ ARRAY2[1]) &amp;&amp; ... <br>
HASH ARRAY any ARRAY elements exist as HASH keys <br>
like: grep { exists HASH&minus;&gt;{$_} } ARRAY <br>
Regexp ARRAY any ARRAY elements pattern match Regexp <br>
like: grep { /Regexp/ } ARRAY <br>
undef ARRAY undef in ARRAY <br>
like: grep { !defined } ARRAY <br>
Any ARRAY smartmatch each ARRAY element[3] <br>
like: grep { Any ~~ $_ } ARRAY <br>
Right operand is a HASH: <br>
Left Right Description and pseudocode <br>

===============================================================
<br>
HASH1 HASH2 all same keys in both HASHes <br>
like: keys HASH1 == <br>
grep { exists HASH2&minus;&gt;{$_} } keys HASH1 <br>
ARRAY HASH any ARRAY elements exist as HASH keys <br>
like: grep { exists HASH&minus;&gt;{$_} } ARRAY <br>
Regexp HASH any HASH keys pattern match Regexp <br>
like: grep { /Regexp/ } keys HASH <br>
undef HASH always false (undef cannot be a key) <br>
like: 0 == 1 <br>
Any HASH HASH key existence <br>
like: exists HASH&minus;&gt;{Any} <br>
Right operand is CODE: <br>
Left Right Description and pseudocode <br>

===============================================================
<br>
ARRAY CODE sub returns true on all ARRAY elements[1] <br>
like: !grep { !CODE&minus;&gt;($_) } ARRAY <br>
HASH CODE sub returns true on all HASH keys[1] <br>
like: !grep { !CODE&minus;&gt;($_) } keys HASH <br>
Any CODE sub passed Any returns true <br>
like: CODE&minus;&gt;(Any) <br>
Right operand is a Regexp: <br>
Left Right Description and pseudocode <br>

===============================================================
<br>
ARRAY Regexp any ARRAY elements match Regexp <br>
like: grep { /Regexp/ } ARRAY <br>
HASH Regexp any HASH keys match Regexp <br>
like: grep { /Regexp/ } keys HASH <br>
Any Regexp pattern match <br>
like: Any =~ /Regexp/ <br>
Other: <br>
Left Right Description and pseudocode <br>

===============================================================
<br>
Object Any invoke ~~ overloading on Object, <br>
or fall back to... <br>
Any Num numeric equality <br>
like: Any == Num <br>
Num nummy[4] numeric equality <br>
like: Num == nummy <br>
undef Any check whether undefined <br>
like: !defined(Any) <br>
Any Any string equality <br>
like: Any eq Any</p>

<p style="margin-left:11%; margin-top: 1em">Notes: <br>
1. Empty hashes or arrays match. <br>
2. That is, each element smartmatches the element of the
same index in <br>
the other array.[3] <br>
3. If a circular reference is found, fall back to
referential equality. <br>
4. Either an actual number, or a string that looks like
one.</p>

<p style="margin-left:11%; margin-top: 1em">The smartmatch
implicitly dereferences any non-blessed hash or array
reference, so the &quot;<i>HASH</i>&quot; and
&quot;<i>ARRAY</i>&quot; entries apply in those cases. For
blessed references, the &quot;<i>Object</i>&quot; entries
apply. Smartmatches involving hashes only consider hash
keys, never hash values.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;like&quot; code entry is not always an exact
rendition. For example, the smartmatch operator
short-circuits whenever possible, but &quot;grep&quot; does
not. Also, &quot;grep&quot; in scalar context returns the
number of matches, but &quot;~~&quot; returns only true or
false.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike most
operators, the smartmatch operator knows to treat
&quot;undef&quot; specially:</p>

<p style="margin-left:11%; margin-top: 1em">use v5.10.1;
<br>
@array = (1, 2, 3, undef, 4, 5); <br>
say &quot;some elements undefined&quot; if undef ~~
@array;</p>

<p style="margin-left:11%; margin-top: 1em">Each operand is
considered in a modified scalar context, the modification
being that array and hash variables are passed by reference
to the operator, which implicitly dereferences them. Both
elements of each pair are the same:</p>

<p style="margin-left:11%; margin-top: 1em">use v5.10.1;
<br>
my %hash = (red =&gt; 1, blue =&gt; 2, green =&gt; 3, <br>
orange =&gt; 4, yellow =&gt; 5, purple =&gt; 6, <br>
black =&gt; 7, grey =&gt; 8, white =&gt; 9); <br>
my @array = qw(red blue green); <br>
say &quot;some array elements in hash keys&quot; if @array
~~ %hash; <br>
say &quot;some array elements in hash keys&quot; if \@array
~~ \%hash; <br>
say &quot;red in array&quot; if &quot;red&quot; ~~ @array;
<br>
say &quot;red in array&quot; if &quot;red&quot; ~~ \@array;
<br>
say &quot;some keys end in e&quot; if /e$/ ~~ %hash; <br>
say &quot;some keys end in e&quot; if /e$/ ~~ \%hash;</p>

<p style="margin-left:11%; margin-top: 1em">Two arrays
smartmatch if each element in the first array smartmatches
(that is, is &quot;in&quot;) the corresponding element in
the second array, recursively.</p>

<p style="margin-left:11%; margin-top: 1em">use v5.10.1;
<br>
my @little = qw(red blue green); <br>
my @bigger = (&quot;red&quot;, &quot;blue&quot;, [
&quot;orange&quot;, &quot;green&quot; ] ); <br>
if (@little ~~ @bigger) { # true! <br>
say &quot;little is contained in bigger&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Because the
smartmatch operator recurses on nested arrays, this will
still report that &quot;red&quot; is in the array.</p>

<p style="margin-left:11%; margin-top: 1em">use v5.10.1;
<br>
my @array = qw(red blue green); <br>
my $nested_array = [[[[[[[ @array ]]]]]]]; <br>
say &quot;red in array&quot; if &quot;red&quot; ~~
$nested_array;</p>

<p style="margin-left:11%; margin-top: 1em">If two arrays
smartmatch each other, then they are deep copies of each
others&rsquo; values, as this example reports:</p>

<p style="margin-left:11%; margin-top: 1em">use v5.12.0;
<br>
my @a = (0, 1, 2, [3, [4, 5], 6], 7); <br>
my @b = (0, 1, 2, [3, [4, 5], 6], 7); <br>
if (@a ~~ @b &amp;&amp; @b ~~ @a) { <br>
say &quot;a and b are deep copies of each other&quot;; <br>
} <br>
elsif (@a ~~ @b) { <br>
say &quot;a smartmatches in b&quot;; <br>
} <br>
elsif (@b ~~ @a) { <br>
say &quot;b smartmatches in a&quot;; <br>
} <br>
else { <br>
say &quot;a and b don't smartmatch each other at all&quot;;
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If you were to
set &quot;$b[3]&nbsp;=&nbsp;4&quot;, then instead of
reporting that &quot;a and b are deep copies of each
other&quot;, it now reports that &quot;b smartmatches in
a&quot;. That&rsquo;s because the corresponding position in
@a contains an array that (eventually) has a 4 in it.</p>

<p style="margin-left:11%; margin-top: 1em">Smartmatching
one hash against another reports whether both contain the
same keys, no more and no less. This could be used to see
whether two records have the same field names, without
caring what values those fields might have. For example:</p>

<p style="margin-left:11%; margin-top: 1em">use v5.10.1;
<br>
sub make_dogtag { <br>
state $REQUIRED_FIELDS = { name=&gt;1, rank=&gt;1,
serial_num=&gt;1 }; <br>
my ($class, $init_fields) = @_; <br>
die &quot;Must supply (only) name, rank, and serial
number&quot; <br>
unless $init_fields ~~ $REQUIRED_FIELDS; <br>
... <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">However, this
only does what you mean if $init_fields is indeed a hash
reference. The condition &quot;$init_fields ~~
$REQUIRED_FIELDS&quot; also allows the strings
&quot;name&quot;, &quot;rank&quot;, &quot;serial_num&quot;
as well as any array reference that contains
&quot;name&quot; or &quot;rank&quot; or
&quot;serial_num&quot; anywhere to pass through.</p>

<p style="margin-left:11%; margin-top: 1em">The smartmatch
operator is most often used as the implicit operator of a
&quot;when&quot; clause. See the section on &quot;Switch
Statements&quot; in perlsyn.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Smartmatching
of Objects</i></p>

<p style="margin-left:11%; margin-top: 1em">To avoid
relying on an object&rsquo;s underlying representation, if
the smartmatch&rsquo;s right operand is an object that
doesn&rsquo;t overload &quot;~~&quot;, it raises the
exception &quot;&quot;Smartmatching a non&minus;overloaded
object breaks encapsulation&quot;&quot;. That&rsquo;s
because one has no business digging around to see whether
something is &quot;in&quot; an object. These are all illegal
on objects without a &quot;~~&quot; overload:</p>

<p style="margin-left:11%; margin-top: 1em">%hash ~~
$object <br>
42 ~~ $object <br>
&quot;fred&quot; ~~ $object</p>

<p style="margin-left:11%; margin-top: 1em">However, you
can change the way an object is smartmatched by overloading
the &quot;~~&quot; operator. This is allowed to extend the
usual smartmatch semantics. For objects that do have an
&quot;~~&quot; overload, see overload.</p>

<p style="margin-left:11%; margin-top: 1em">Using an object
as the left operand is allowed, although not very useful.
Smartmatching rules take precedence over overloading, so
even if the object in the left operand has smartmatch
overloading, this will be ignored. A left operand that is a
non-overloaded object falls back on a string or numeric
comparison of whatever the &quot;ref&quot; operator returns.
That means that</p>

<p style="margin-left:11%; margin-top: 1em">$object ~~
X</p>

<p style="margin-left:11%; margin-top: 1em">does <i>not</i>
invoke the overload method with &quot;<i>X</i>&quot; as an
argument. Instead the above table is consulted as normal,
and based on the type of &quot;<i>X</i>&quot;, overloading
may or may not be invoked. For simple strings or numbers,
&quot;in&quot; becomes equivalent to this:</p>

<p style="margin-left:11%; margin-top: 1em">$object ~~
$number ref($object) == $number <br>
$object ~~ $string ref($object) eq $string</p>

<p style="margin-left:11%; margin-top: 1em">For example,
this reports that the handle smells IOish (but please
don&rsquo;t really do this!):</p>

<p style="margin-left:11%; margin-top: 1em">use IO::Handle;
<br>
my $fh = IO::Handle&minus;&gt;new(); <br>
if ($fh ~~ /\bIO\b/) { <br>
say &quot;handle smells IOish&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
because it treats $fh as a string like
&quot;IO::Handle=GLOB(0x8039e0)&quot;, then pattern matches
against that.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Bitwise
And</b> <br>
Binary &quot;&amp;&quot; returns its operands ANDed together
bit by bit. Although no warning is currently raised, the
result is not well defined when this operation is performed
on operands that aren&rsquo;t either numbers (see
&quot;Integer Arithmetic&quot;) nor bitstrings (see
&quot;Bitwise String Operators&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;&amp;&quot; has lower priority than relational
operators, so for example the parentheses are essential in a
test like</p>

<p style="margin-left:11%; margin-top: 1em">print
&quot;Even\n&quot; if ($x &amp; 1) == 0;</p>

<p style="margin-left:11%; margin-top: 1em">If the
&quot;bitwise&quot; feature is enabled via
&quot;use&nbsp;feature&nbsp;'bitwise'&quot; or &quot;use
v5.28&quot;, then this operator always treats its operands
as numbers. Before Perl 5.28 this feature produced a warning
in the &quot;experimental::bitwise&quot; category.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Bitwise Or
and Exclusive Or</b> <br>
Binary &quot;|&quot; returns its operands ORed together bit
by bit.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;^&quot; returns its operands XORed together bit by
bit.</p>

<p style="margin-left:11%; margin-top: 1em">Although no
warning is currently raised, the results are not well
defined when these operations are performed on operands that
aren&rsquo;t either numbers (see &quot;Integer
Arithmetic&quot;) nor bitstrings (see &quot;Bitwise String
Operators&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;|&quot; and &quot;^&quot; have lower priority than
relational operators, so for example the parentheses are
essential in a test like</p>

<p style="margin-left:11%; margin-top: 1em">print
&quot;false\n&quot; if (8 | 2) != 10;</p>

<p style="margin-left:11%; margin-top: 1em">If the
&quot;bitwise&quot; feature is enabled via
&quot;use&nbsp;feature&nbsp;'bitwise'&quot; or &quot;use
v5.28&quot;, then this operator always treats its operands
as numbers. Before Perl 5.28. this feature produced a
warning in the &quot;experimental::bitwise&quot;
category.</p>


<p style="margin-left:11%; margin-top: 1em"><b>C&minus;style
Logical And</b> <br>
Binary &quot;&amp;&amp;&quot; performs a short-circuit
logical <small>AND</small> operation. That is, if the left
operand is false, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand
if it is evaluated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>C&minus;style
Logical Or</b> <br>
Binary &quot;||&quot; performs a short-circuit logical
<small>OR</small> operation. That is, if the left operand is
true, the right operand is not even evaluated. Scalar or
list context propagates down to the right operand if it is
evaluated.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Logical
Defined-Or</b> <br>
Although it has no direct equivalent in C, Perl&rsquo;s
&quot;//&quot; operator is related to its C&minus;style
&quot;or&quot;. In fact, it&rsquo;s exactly the same as
&quot;||&quot;, except that it tests the left hand
side&rsquo;s definedness instead of its truth. Thus,
&quot;EXPR1&nbsp;//&nbsp;EXPR2&quot; returns the value of
&quot;EXPR1&quot; if it&rsquo;s defined, otherwise, the
value of &quot;EXPR2&quot; is returned. (&quot;EXPR1&quot;
is evaluated in scalar context, &quot;EXPR2&quot; in the
context of &quot;//&quot; itself). Usually, this is the same
result as
&quot;defined(EXPR1)&nbsp;?&nbsp;EXPR1&nbsp;:&nbsp;EXPR2&quot;
(except that the ternary-operator form can be used as a
lvalue, while &quot;EXPR1&nbsp;//&nbsp;EXPR2&quot; cannot).
This is very useful for providing default values for
variables. If you actually want to test if at least one of
$x and $y is defined, use
&quot;defined($x&nbsp;//&nbsp;$y)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;||&quot;, &quot;//&quot; and &quot;&amp;&amp;&quot;
operators return the last value evaluated (unlike C&rsquo;s
&quot;||&quot; and &quot;&amp;&amp;&quot;, which return 0 or
1). Thus, a reasonably portable way to find out the home
directory might be:</p>

<p style="margin-left:11%; margin-top: 1em">$home =
$ENV{HOME} <br>
// $ENV{LOGDIR} <br>
// (getpwuid($&lt;))[7] <br>
// die &quot;You're homeless!\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">In particular,
this means that you shouldn&rsquo;t use this for selecting
between two aggregates for assignment:</p>

<p style="margin-left:11%; margin-top: 1em">@a = @b || @c;
# This doesn't do the right thing <br>
@a = scalar(@b) || @c; # because it really means this. <br>
@a = @b ? @b : @c; # This works fine, though.</p>

<p style="margin-left:11%; margin-top: 1em">As alternatives
to &quot;&amp;&amp;&quot; and &quot;||&quot; when used for
control flow, Perl provides the &quot;and&quot; and
&quot;or&quot; operators (see below). The short-circuit
behavior is identical. The precedence of &quot;and&quot; and
&quot;or&quot; is much lower, however, so that you can
safely use them after a list operator without the need for
parentheses:</p>

<p style="margin-left:11%; margin-top: 1em">unlink
&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot; <br>
or gripe(), next LINE;</p>

<p style="margin-left:11%; margin-top: 1em">With the
C&minus;style operators that would have been written like
this:</p>


<p style="margin-left:11%; margin-top: 1em">unlink(&quot;alpha&quot;,
&quot;beta&quot;, &quot;gamma&quot;) <br>
|| (gripe(), next LINE);</p>

<p style="margin-left:11%; margin-top: 1em">It would be
even more readable to write that this way:</p>


<p style="margin-left:11%; margin-top: 1em">unless(unlink(&quot;alpha&quot;,
&quot;beta&quot;, &quot;gamma&quot;)) { <br>
gripe(); <br>
next LINE; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Using
&quot;or&quot; for assignment is unlikely to do what you
want; see below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Range
Operators</b> <br>
Binary &quot;..&quot; is the range operator, which is really
two different operators depending on the context. In list
context, it returns a list of values counting (up by ones)
from the left value to the right value. If the left value is
greater than the right value then it returns the empty list.
The range operator is useful for writing
&quot;foreach&nbsp;(1..10)&quot; loops and for doing slice
operations on arrays. In the current implementation, no
temporary array is created when the range operator is used
as the expression in &quot;foreach&quot; loops, but older
versions of Perl might burn a lot of memory when you write
something like this:</p>

<p style="margin-left:11%; margin-top: 1em">for (1 ..
1_000_000) { <br>
# code <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The range
operator also works on strings, using the magical
auto-increment, see below.</p>

<p style="margin-left:11%; margin-top: 1em">In scalar
context, &quot;..&quot; returns a boolean value. The
operator is bistable, like a flip-flop, and emulates the
line-range (comma) operator of <b>sed</b>, <b>awk</b>, and
various editors. Each &quot;..&quot; operator maintains its
own boolean state, even across calls to a subroutine that
contains it. It is false as long as its left operand is
false. Once the left operand is true, the range operator
stays true until the right operand is true,
<i><small>AFTER</small></i> which the range operator becomes
false again. It doesn&rsquo;t become false till the next
time the range operator is evaluated. It can test the right
operand and become false on the same evaluation it became
true (as in <b>awk</b>), but it still returns true once. If
you don&rsquo;t want it to test the right operand until the
next evaluation, as in <b>sed</b>, just use three dots
(&quot;...&quot;) instead of two. In all other regards,
&quot;...&quot; behaves just like &quot;..&quot; does.</p>

<p style="margin-left:11%; margin-top: 1em">The right
operand is not evaluated while the operator is in the
&quot;false&quot; state, and the left operand is not
evaluated while the operator is in the &quot;true&quot;
state. The precedence is a little lower than || and
&amp;&amp;. The value returned is either the empty string
for false, or a sequence number (beginning with 1) for true.
The sequence number is reset for each range encountered. The
final sequence number in a range has the string
&quot;E0&quot; appended to it, which doesn&rsquo;t affect
its numeric value, but gives you something to search for if
you want to exclude the endpoint. You can exclude the
beginning point by waiting for the sequence number to be
greater than 1.</p>

<p style="margin-left:11%; margin-top: 1em">If either
operand of scalar &quot;..&quot; is a constant expression,
that operand is considered true if it is equal
(&quot;==&quot;) to the current input line number (the $.
variable).</p>

<p style="margin-left:11%; margin-top: 1em">To be pedantic,
the comparison is actually
&quot;int(EXPR)&nbsp;==&nbsp;int(EXPR)&quot;, but that is
only an issue if you use a floating point expression; when
implicitly using $. as described in the previous paragraph,
the comparison is &quot;int(EXPR)&nbsp;==&nbsp;int($.)&quot;
which is only an issue when $. is set to a floating point
value and you are not reading from a file. Furthermore,
&quot;span&quot;&nbsp;..&nbsp;&quot;spat&quot; or
&quot;2.18&nbsp;..&nbsp;3.14&quot; will not do what you want
in scalar context because each of the operands are evaluated
using their integer representation.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">As a scalar
operator:</p>

<p style="margin-left:11%; margin-top: 1em">if (101 .. 200)
{ print; } # print 2nd hundred lines, short for <br>
# if ($. == 101 .. $. == 200) { print; } <br>
next LINE if (1 .. /^$/); # skip header lines, short for
<br>
# next LINE if ($. == 1 .. /^$/); <br>
# (typically in a loop labeled LINE) <br>
s/^/&gt; / if (/^$/ .. eof()); # quote body <br>
# parse mail messages <br>
while (&lt;&gt;) { <br>
$in_header = 1 .. /^$/; <br>
$in_body = /^$/ .. eof; <br>
if ($in_header) { <br>
# do something <br>
} else { # in body <br>
# do something else <br>
} <br>
} continue { <br>
close ARGV if eof; # reset $. each file <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
simple example to illustrate the difference between the two
range operators:</p>

<p style="margin-left:11%; margin-top: 1em">@lines =
(&quot; &minus; Foo&quot;, <br>
&quot;01 &minus; Bar&quot;, <br>
&quot;1 &minus; Baz&quot;, <br>
&quot; &minus; Quux&quot;); <br>
foreach (@lines) { <br>
if (/0/ .. /1/) { <br>
print &quot;$_\n&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This program
will print only the line containing &quot;Bar&quot;. If the
range operator is changed to &quot;...&quot;, it will also
print the &quot;Baz&quot; line.</p>

<p style="margin-left:11%; margin-top: 1em">And now some
examples as a list operator:</p>

<p style="margin-left:11%; margin-top: 1em">for (101 ..
200) { print } # print $_ 100 times <br>
@foo = @foo[0 .. $#foo]; # an expensive no&minus;op <br>
@foo = @foo[$#foo&minus;4 .. $#foo]; # slice last 5
items</p>

<p style="margin-left:11%; margin-top: 1em">Because each
operand is evaluated in integer form,
&quot;2.18&nbsp;..&nbsp;3.14&quot; will return two elements
in list context.</p>

<p style="margin-left:11%; margin-top: 1em">@list = (2.18
.. 3.14); # same as @list = (2 .. 3);</p>

<p style="margin-left:11%; margin-top: 1em">The range
operator in list context can make use of the magical
auto-increment algorithm if both operands are strings,
subject to the following rules:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>With one exception (below), if both strings look like
numbers to Perl, the magic increment will not be applied,
and the strings will be treated as numbers (more
specifically, integers) instead.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For example,
&quot;&minus;2&quot;..&quot;2&quot; is the same as
&quot;&minus;2..2&quot;, and
&quot;2.18&quot;..&quot;3.14&quot; produces &quot;2,
3&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The exception to the above rule
is when the left-hand string begins with 0 and is longer
than one character, in this case the magic increment
<i>will</i> be applied, even though strings like
&quot;01&quot; would normally look like a number to
Perl.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For example,
&quot;01&quot;..&quot;04&quot; produces &quot;01&quot;,
&quot;02&quot;, &quot;03&quot;, &quot;04&quot;, and
&quot;00&quot;..&quot;&minus;1&quot; produces &quot;00&quot;
through &quot;99&quot; &minus; this may seem surprising, but
see the following rules for why it works this way. To get
dates with leading zeros, you can say:</p>

<p style="margin-left:17%; margin-top: 1em">@z2 =
(&quot;01&quot; .. &quot;31&quot;); <br>
print $z2[$mday];</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
force strings to be interpreted as numbers, you could
say</p>

<p style="margin-left:17%; margin-top: 1em">@numbers = (
0+$first .. 0+$last );</p>

<p style="margin-left:17%; margin-top: 1em"><b>Note:</b> In
Perl versions 5.30 and below, <i>any</i> string on the
left-hand side beginning with &quot;0&quot;, including the
string &quot;0&quot; itself, would cause the magic string
increment behavior. This means that on these Perl versions,
&quot;0&quot;..&quot;&minus;1&quot; would produce
&quot;0&quot; through &quot;99&quot;, which was inconsistent
with &quot;0..&minus;1&quot;, which produces the empty list.
This also means that &quot;0&quot;..&quot;9&quot; now
produces a list of integers instead of a list of
strings.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If the initial value specified
isn&rsquo;t part of a magical increment sequence (that is, a
non-empty string matching
&quot;/^[a&minus;zA&minus;Z]*[0&minus;9]*\z/&quot;), only
the initial value will be returned.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For example,
&quot;ax&quot;..&quot;az&quot; produces &quot;ax&quot;,
&quot;ay&quot;, &quot;az&quot;, but
&quot;*x&quot;..&quot;az&quot; produces only
&quot;*x&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">For other initial values that
are strings that do follow the rules of the magical
increment, the corresponding sequence will be returned.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For example,
you can say</p>

<p style="margin-left:17%; margin-top: 1em">@alphabet =
(&quot;A&quot; .. &quot;Z&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">to get all
normal letters of the English alphabet, or</p>

<p style="margin-left:17%; margin-top: 1em">$hexdigit = (0
.. 9, &quot;a&quot; .. &quot;f&quot;)[$num &amp; 15];</p>

<p style="margin-left:17%; margin-top: 1em">to get a
hexadecimal digit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If the final value specified is
not in the sequence that the magical increment would
produce, the sequence goes until the next value would be
longer than the final value specified. If the length of the
final string is shorter than the first, the empty list is
returned.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For example,
&quot;a&quot;..&quot;&minus;&minus;&quot; is the same as
&quot;a&quot;..&quot;zz&quot;, &quot;0&quot;..&quot;xx&quot;
produces &quot;0&quot; through &quot;99&quot;, and
&quot;aaa&quot;..&quot;&minus;&minus;&quot; returns the
empty list.</p>

<p style="margin-left:11%; margin-top: 1em">As of Perl
5.26, the list-context range operator on strings works as
expected in the scope of
&quot;use&nbsp;feature&nbsp;'unicode_strings&quot;. In
previous versions, and outside the scope of that feature, it
exhibits &quot;The &quot;Unicode Bug&quot;&quot; in
perlunicode: its behavior depends on the internal encoding
of the range endpoint.</p>

<p style="margin-left:11%; margin-top: 1em">Because the
magical increment only works on non-empty strings matching
&quot;/^[a&minus;zA&minus;Z]*[0&minus;9]*\z/&quot;, the
following will only return an alpha:</p>

<p style="margin-left:11%; margin-top: 1em">use charnames
&quot;greek&quot;; <br>
my @greek_small = (&quot;\N{alpha}&quot; ..
&quot;\N{omega}&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">To get the 25
traditional lowercase Greek letters, including both sigmas,
you could use this instead:</p>

<p style="margin-left:11%; margin-top: 1em">use charnames
&quot;greek&quot;; <br>
my @greek_small = map { chr } ( ord(&quot;\N{alpha}&quot;)
<br>
.. <br>
ord(&quot;\N{omega}&quot;) <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">However,
because there are <i>many</i> other lowercase Greek
characters than just those, to match lowercase Greek
characters in a regular expression, you could use the
pattern &quot;/(?:(?=\p{Greek})\p{Lower})+/&quot; (or the
experimental feature
&quot;/(?[&nbsp;\p{Greek}&nbsp;&amp;&nbsp;\p{Lower}&nbsp;])+/&quot;).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Conditional
Operator</b> <br>
Ternary &quot;?:&quot; is the conditional operator, just as
in C. It works much like an if-then-else. If the argument
before the &quot;?&quot; is true, the argument before the
&quot;:&quot; is returned, otherwise the argument after the
&quot;:&quot; is returned. For example:</p>

<p style="margin-left:11%; margin-top: 1em">printf &quot;I
have %d dog%s.\n&quot;, $n, <br>
($n == 1) ? &quot;&quot; : &quot;s&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">Scalar or list
context propagates downward into the 2nd or 3rd argument,
whichever is selected.</p>

<p style="margin-left:11%; margin-top: 1em">$x = $ok ? $y :
$z; # get a scalar <br>
@x = $ok ? @y : @z; # get an array <br>
$x = $ok ? @y : @z; # oops, that's just a count!</p>

<p style="margin-left:11%; margin-top: 1em">The operator
may be assigned to if both the 2nd and 3rd arguments are
legal lvalues (meaning that you can assign to them):</p>

<p style="margin-left:11%; margin-top: 1em">($x_or_y ? $x :
$y) = $z;</p>

<p style="margin-left:11%; margin-top: 1em">Because this
operator produces an assignable result, using assignments
without parentheses will get you in trouble. For example,
this:</p>

<p style="margin-left:11%; margin-top: 1em">$x % 2 ? $x +=
10 : $x += 2</p>

<p style="margin-left:11%; margin-top: 1em">Really means
this:</p>

<p style="margin-left:11%; margin-top: 1em">(($x % 2) ? ($x
+= 10) : $x) += 2</p>

<p style="margin-left:11%; margin-top: 1em">Rather than
this:</p>

<p style="margin-left:11%; margin-top: 1em">($x % 2) ? ($x
+= 10) : ($x += 2)</p>

<p style="margin-left:11%; margin-top: 1em">That should
probably be written more simply as:</p>

<p style="margin-left:11%; margin-top: 1em">$x += ($x % 2)
? 10 : 2;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Assignment
Operators</b> <br>
&quot;=&quot; is the ordinary assignment operator.</p>

<p style="margin-left:11%; margin-top: 1em">Assignment
operators work as in C. That is,</p>

<p style="margin-left:11%; margin-top: 1em">$x += 2;</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>

<p style="margin-left:11%; margin-top: 1em">$x = $x +
2;</p>

<p style="margin-left:11%; margin-top: 1em">although
without duplicating any side effects that dereferencing the
lvalue might trigger, such as from &quot;tie()&quot;. Other
assignment operators work similarly. The following are
recognized:</p>

<p style="margin-left:11%; margin-top: 1em">**= += *=
&amp;= &amp;.= &lt;&lt;= &amp;&amp;= <br>
&minus;= /= |= |.= &gt;&gt;= ||= <br>
.= %= ^= ^.= //= <br>
x=</p>

<p style="margin-left:11%; margin-top: 1em">Although these
are grouped by family, they all have the precedence of
assignment. These combined assignment operators can only
operate on scalars, whereas the ordinary assignment operator
can assign to arrays, hashes, lists and even references.
(See &quot;Context&quot; and &quot;List value
constructors&quot; in perldata, and &quot;Assigning to
References&quot; in perlref.)</p>

<p style="margin-left:11%; margin-top: 1em">Unlike in C,
the scalar assignment operator produces a valid lvalue.
Modifying an assignment is equivalent to doing the
assignment and then modifying the variable that was assigned
to. This is useful for modifying a copy of something, like
this:</p>

<p style="margin-left:11%; margin-top: 1em">($tmp =
$global) =~ tr/13579/24680/;</p>

<p style="margin-left:11%; margin-top: 1em">Although as of
5.14, that can be also be accomplished this way:</p>

<p style="margin-left:11%; margin-top: 1em">use v5.14; <br>
$tmp = ($global =~ tr/13579/24680/r);</p>

<p style="margin-left:11%; margin-top: 1em">Likewise,</p>

<p style="margin-left:11%; margin-top: 1em">($x += 2) *=
3;</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>

<p style="margin-left:11%; margin-top: 1em">$x += 2; <br>
$x *= 3;</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, a
list assignment in list context produces the list of lvalues
assigned to, and a list assignment in scalar context returns
the number of elements produced by the expression on the
right hand side of the assignment.</p>

<p style="margin-left:11%; margin-top: 1em">The three
dotted bitwise assignment operators (&quot;&amp;.=&quot;
&quot;|.=&quot; &quot;^.=&quot;) are new in Perl 5.22. See
&quot;Bitwise String Operators&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Comma
Operator</b> <br>
Binary &quot;,&quot; is the comma operator. In scalar
context it evaluates its left argument, throws that value
away, then evaluates its right argument and returns that
value. This is just like C&rsquo;s comma operator.</p>

<p style="margin-left:11%; margin-top: 1em">In list
context, it&rsquo;s just the list argument separator, and
inserts both its arguments into the list. These arguments
are also evaluated from left to right.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;=&gt;&quot; operator (sometimes pronounced &quot;fat
comma&quot;) is a synonym for the comma except that it
causes a word on its left to be interpreted as a string if
it begins with a letter or underscore and is composed only
of letters, digits and underscores. This includes operands
that might otherwise be interpreted as operators, constants,
single number v&minus;strings or function calls. If in doubt
about this behavior, the left operand can be quoted
explicitly.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, the
&quot;=&gt;&quot; operator behaves exactly as the comma
operator or list argument separator, according to
context.</p>

<p style="margin-left:11%; margin-top: 1em">For
example:</p>

<p style="margin-left:11%; margin-top: 1em">use constant
FOO =&gt; &quot;something&quot;; <br>
my %h = ( FOO =&gt; 23 );</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to:</p>

<p style="margin-left:11%; margin-top: 1em">my %h =
(&quot;FOO&quot;, 23);</p>

<p style="margin-left:11%; margin-top: 1em">It is
<i><small>NOT</small></i> :</p>

<p style="margin-left:11%; margin-top: 1em">my %h =
(&quot;something&quot;, 23);</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;=&gt;&quot; operator is helpful in documenting the
correspondence between keys and values in hashes, and other
paired elements in lists.</p>

<p style="margin-left:11%; margin-top: 1em">%hash = ( $key
=&gt; $value ); <br>
login( $username =&gt; $password );</p>

<p style="margin-left:11%; margin-top: 1em">The special
quoting behavior ignores precedence, and hence may apply to
<i>part</i> of the left operand:</p>

<p style="margin-left:11%; margin-top: 1em">print
time.shift =&gt; &quot;bbb&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">That example
prints something like &quot;1314363215shiftbbb&quot;,
because the &quot;=&gt;&quot; implicitly quotes the
&quot;shift&quot; immediately on its left, ignoring the fact
that &quot;time.shift&quot; is the entire left operand.</p>

<p style="margin-left:11%; margin-top: 1em"><b>List
Operators (Rightward)</b> <br>
On the right side of a list operator, the comma has very low
precedence, such that it controls all comma-separated
expressions found there. The only operators with lower
precedence are the logical operators &quot;and&quot;,
&quot;or&quot;, and &quot;not&quot;, which may be used to
evaluate calls to list operators without the need for
parentheses:</p>

<p style="margin-left:11%; margin-top: 1em">open HANDLE,
&quot;&lt; :encoding(UTF&minus;8)&quot;,
&quot;filename&quot; <br>
or die &quot;Can't open: $!\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">However, some
people find that code harder to read than writing it with
parentheses:</p>

<p style="margin-left:11%; margin-top: 1em">open(HANDLE,
&quot;&lt; :encoding(UTF&minus;8)&quot;,
&quot;filename&quot;) <br>
or die &quot;Can't open: $!\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">in which case
you might as well just use the more customary &quot;||&quot;
operator:</p>

<p style="margin-left:11%; margin-top: 1em">open(HANDLE,
&quot;&lt; :encoding(UTF&minus;8)&quot;,
&quot;filename&quot;) <br>
|| die &quot;Can't open: $!\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">See also
discussion of list operators in &quot;Terms and List
Operators (Leftward)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Logical
Not</b> <br>
Unary &quot;not&quot; returns the logical negation of the
expression to its right. It&rsquo;s the equivalent of
&quot;!&quot; except for the very low precedence.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Logical
And</b> <br>
Binary &quot;and&quot; returns the logical conjunction of
the two surrounding expressions. It&rsquo;s equivalent to
&quot;&amp;&amp;&quot; except for the very low precedence.
This means that it short-circuits: the right expression is
evaluated only if the left expression is true.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Logical or
and Exclusive Or</b> <br>
Binary &quot;or&quot; returns the logical disjunction of the
two surrounding expressions. It&rsquo;s equivalent to
&quot;||&quot; except for the very low precedence. This
makes it useful for control flow:</p>

<p style="margin-left:11%; margin-top: 1em">print FH $data
or die &quot;Can't write to FH: $!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">This means that
it short-circuits: the right expression is evaluated only if
the left expression is false. Due to its precedence, you
must be careful to avoid using it as replacement for the
&quot;||&quot; operator. It usually works out better for
flow control than in assignments:</p>

<p style="margin-left:11%; margin-top: 1em">$x = $y or $z;
# bug: this is wrong <br>
($x = $y) or $z; # really means this <br>
$x = $y || $z; # better written this way</p>

<p style="margin-left:11%; margin-top: 1em">However, when
it&rsquo;s a list-context assignment and you&rsquo;re trying
to use &quot;||&quot; for control flow, you probably need
&quot;or&quot; so that the assignment takes higher
precedence.</p>

<p style="margin-left:11%; margin-top: 1em">@info =
stat($file) || die; # oops, scalar sense of stat! <br>
@info = stat($file) or die; # better, now @info gets its
due</p>

<p style="margin-left:11%; margin-top: 1em">Then again, you
could always use parentheses.</p>

<p style="margin-left:11%; margin-top: 1em">Binary
&quot;xor&quot; returns the exclusive-OR of the two
surrounding expressions. It cannot short-circuit (of
course).</p>

<p style="margin-left:11%; margin-top: 1em">There is no low
precedence operator for defined-OR.</p>

<p style="margin-left:11%; margin-top: 1em"><b>C Operators
Missing From Perl</b> <br>
Here is what C has that Perl doesn&rsquo;t:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em">unary &amp;</p></td>
<td width="1%"></td>
<td width="77%">


<p style="margin-top: 1em">Address-of operator. (But see
the &quot;\&quot; operator for taking a reference.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>unary *</p></td>
<td width="1%"></td>
<td width="77%">


<p>Dereference-address operator. (Perl&rsquo;s prefix
dereferencing operators are typed: &quot;$&quot;,
&quot;@&quot;, &quot;%&quot;, and &quot;&amp;&quot;.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>( <small>TYPE</small> )</p></td>
<td width="1%"></td>
<td width="77%">


<p>Type-casting operator.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Quote and
Quote-like Operators</b> <br>
While we usually think of quotes as literal values, in Perl
they function as operators, providing various kinds of
interpolating and pattern matching capabilities. Perl
provides customary quote characters for these behaviors, but
also provides a way for you to choose your quote character
for any of them. In the following table, a &quot;{}&quot;
represents any pair of delimiters you choose.</p>

<p style="margin-left:11%; margin-top: 1em">Customary
Generic Meaning Interpolates <br>
'' q{} Literal no <br>
&quot;&quot; qq{} Literal yes <br>
`` qx{} Command yes* <br>
qw{} Word list no <br>
// m{} Pattern match yes* <br>
qr{} Pattern yes* <br>
s{}{} Substitution yes* <br>
tr{}{} Transliteration no (but see below) <br>
y{}{} Transliteration no (but see below) <br>
&lt;&lt;EOF here&minus;doc yes* <br>
* unless the delimiter is ''.</p>

<p style="margin-left:11%; margin-top: 1em">Non-bracketing
delimiters use the same character fore and aft, but the four
sorts of <small>ASCII</small> brackets (round, angle,
square, curly) all nest, which means that</p>


<p style="margin-left:11%; margin-top: 1em">q{foo{bar}baz}</p>

<p style="margin-left:11%; margin-top: 1em">is the same
as</p>


<p style="margin-left:11%; margin-top: 1em">'foo{bar}baz'</p>

<p style="margin-left:11%; margin-top: 1em">Note, however,
that this does not always work for quoting Perl code:</p>

<p style="margin-left:11%; margin-top: 1em">$s = q{ if($x
eq &quot;}&quot;) ... }; # WRONG</p>

<p style="margin-left:11%; margin-top: 1em">is a syntax
error. The &quot;Text::Balanced&quot; module (standard as of
v5.8, and from <small>CPAN</small> before then) is able to
do this properly.</p>

<p style="margin-left:11%; margin-top: 1em">There can (and
in some cases, must) be whitespace between the operator and
the quoting characters, except when &quot;#&quot; is being
used as the quoting character. &quot;q#foo#&quot; is parsed
as the string &quot;foo&quot;, while
&quot;q&nbsp;#foo#&quot; is the operator &quot;q&quot;
followed by a comment. Its argument will be taken from the
next line. This allows you to write:</p>

<p style="margin-left:11%; margin-top: 1em">s {foo} #
Replace foo <br>
{bar} # with bar.</p>

<p style="margin-left:11%; margin-top: 1em">The cases where
whitespace must be used are when the quoting character is a
word character (meaning it matches &quot;/\w/&quot;):</p>

<p style="margin-left:11%; margin-top: 1em">q XfooX #
Works: means the string 'foo' <br>
qXfooX # WRONG!</p>

<p style="margin-left:11%; margin-top: 1em">The following
escape sequences are available in constructs that
interpolate, and in transliterations whose delimiters
aren&rsquo;t single quotes (&quot;'&quot;). In all the ones
with braces, any number of blanks and/or tabs adjoining and
within the braces are allowed (and ignored).</p>

<p style="margin-left:11%; margin-top: 1em">Sequence Note
Description <br>
\t tab (HT, TAB) <br>
\n newline (NL) <br>
\r return (CR) <br>
\f form feed (FF) <br>
\b backspace (BS) <br>
\a alarm (bell) (BEL) <br>
\e escape (ESC) <br>
\x{263A} [1,8] hex char (example shown: SMILEY) <br>
\x{ 263A } Same, but shows optional blanks inside and <br>
adjoining the braces <br>
\x1b [2,8] restricted range hex char (example: ESC) <br>
\N{name} [3] named Unicode character or character sequence
<br>
\N{U+263D} [4,8] Unicode character (example: FIRST QUARTER
MOON) <br>
\c[ [5] control char (example: chr(27)) <br>
\o{23072} [6,8] octal char (example: SMILEY) <br>
\033 [7,8] restricted range octal char (example: ESC)</p>

<p style="margin-left:11%; margin-top: 1em">Note that any
escape sequence using braces inside interpolated constructs
may have optional blanks (tab or space characters) adjoining
with and inside of the braces, as illustrated above by the
second &quot;\x{&nbsp;}&quot; example.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[1]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The result is the character
specified by the hexadecimal number between the braces. See
&quot;[8]&quot; below for details on which character.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Blanks (tab or
space characters) may separate the number from either or
both of the braces.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise, only
hexadecimal digits are valid between the braces. If an
invalid character is encountered, a warning will be issued
and the invalid character and all subsequent characters
(valid or invalid) within the braces will be discarded.</p>

<p style="margin-left:17%; margin-top: 1em">If there are no
valid digits between the braces, the generated character is
the <small>NULL</small> character (&quot;\x{00}&quot;).
However, an explicit empty brace (&quot;\x{}&quot;) will not
cause a warning (currently).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[2]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The result is the character
specified by the hexadecimal number in the range 0x00 to
0xFF. See &quot;[8]&quot; below for details on which
character.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Only
hexadecimal digits are valid following &quot;\x&quot;. When
&quot;\x&quot; is followed by fewer than two valid digits,
any valid digits will be zero-padded. This means that
&quot;\x7&quot; will be interpreted as &quot;\x07&quot;, and
a lone &quot;\x&quot; will be interpreted as
&quot;\x00&quot;. Except at the end of a string, having
fewer than two valid digits will result in a warning. Note
that although the warning says the illegal character is
ignored, it is only ignored as part of the escape and will
still be used as the subsequent character in the string. For
example:</p>

<p style="margin-left:17%; margin-top: 1em">Original Result
Warns? <br>
&quot;\x7&quot; &quot;\x07&quot; no <br>
&quot;\x&quot; &quot;\x00&quot; no <br>
&quot;\x7q&quot; &quot;\x07q&quot; yes <br>
&quot;\xq&quot; &quot;\x00q&quot; yes</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[3]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The result is the Unicode
character or character sequence given by <i>name</i>. See
charnames.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[4]</p></td>
<td width="2%"></td>
<td width="83%">


<p>&quot;\N{U+<i>hexadecimal&nbsp;number</i>}&quot; means
the Unicode character whose Unicode code point is
<i>hexadecimal number</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>[5]</p></td>
<td width="2%"></td>
<td width="83%">


<p>The character following &quot;\c&quot; is mapped to some
other character as shown in the table:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Sequence Value
<br>
\c@ chr(0) <br>
\cA chr(1) <br>
\ca chr(1) <br>
\cB chr(2) <br>
\cb chr(2) <br>
... <br>
\cZ chr(26) <br>
\cz chr(26) <br>
\c[ chr(27) <br>
# See below for chr(28) <br>
\c] chr(29) <br>
\c^ chr(30) <br>
\c_ chr(31) <br>
\c? chr(127) # (on ASCII platforms; see below for link to
<br>
# EBCDIC discussion)</p>

<p style="margin-left:17%; margin-top: 1em">In other words,
it&rsquo;s the character whose code point has had 64
xor&rsquo;d with its uppercase. &quot;\c?&quot; is
<small>DELETE</small> on <small>ASCII</small> platforms
because &quot;ord(&quot;?&quot;)&nbsp;^&nbsp;64&quot; is
127, and &quot;\c@&quot; is <small>NULL</small> because the
ord of &quot;@&quot; is 64, so xor&rsquo;ing 64 itself
produces 0.</p>

<p style="margin-left:17%; margin-top: 1em">Also,
&quot;\c\<i>X</i>&quot; yields
&quot;&nbsp;chr(28)&nbsp;.&nbsp;&quot;<i>X</i>&quot;&quot;
for any <i>X</i>, but cannot come at the end of a string,
because the backslash would be parsed as escaping the end
quote.</p>

<p style="margin-left:17%; margin-top: 1em">On
<small>ASCII</small> platforms, the resulting characters
from the list above are the complete set of
<small>ASCII</small> controls. This isn&rsquo;t the case on
<small>EBCDIC</small> platforms; see &quot; <small>OPERATOR
DIFFERENCES&quot;</small> in perlebcdic for a full
discussion of the differences between these for
<small>ASCII</small> versus <small>EBCDIC</small>
platforms.</p>

<p style="margin-left:17%; margin-top: 1em">Use of any
other character following the &quot;c&quot; besides those
listed above is discouraged, and as of Perl v5.20, the only
characters actually allowed are the printable
<small>ASCII</small> ones, minus the left brace
&quot;{&quot;. What happens for any of the allowed other
characters is that the value is derived by xor&rsquo;ing
with the seventh bit, which is 64, and a warning raised if
enabled. Using the non-allowed characters generates a fatal
error.</p>

<p style="margin-left:17%; margin-top: 1em">To get platform
independent controls, you can use &quot;\N{...}&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[6]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The result is the character
specified by the octal number between the braces. See
&quot;[8]&quot; below for details on which character.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Blanks (tab or
space characters) may separate the number from either or
both of the braces.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise, if a
character that isn&rsquo;t an octal digit is encountered, a
warning is raised, and the value is based on the octal
digits before it, discarding it and all following characters
up to the closing brace. It is a fatal error if there are no
octal digits at all.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[7]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">The result is the character
specified by the three-digit octal number in the range 000
to 777 (but best to not use above 077, see next paragraph).
See &quot;[8]&quot; below for details on which
character.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Some contexts
allow 2 or even 1 digit, but any usage without exactly three
digits, the first being a zero, may give unintended results.
(For example, in a regular expression it may be confused
with a backreference; see &quot;Octal escapes&quot; in
perlrebackslash.) Starting in Perl 5.14, you may use
&quot;\o{}&quot; instead, which avoids all these problems.
Otherwise, it is best to use this construct only for
ordinals &quot;\077&quot; and below, remembering to pad to
the left with zeros to make three digits. For larger
ordinals, either use &quot;\o{}&quot;, or convert to
something else, such as to hex and use &quot;\N{U+}&quot;
(which is portable between platforms with different
character sets) or &quot;\x{}&quot; instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em">[8]</p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">Several constructs above specify
a character by a number. That number gives the
character&rsquo;s position in the character set encoding
(indexed from 0). This is called synonymously its ordinal,
code position, or code point. Perl works on platforms that
have a native encoding currently of either ASCII/Latin1 or
<small>EBCDIC,</small> each of which allow specification of
256 characters. In general, if the number is 255 (0xFF,
0377) or below, Perl interprets this in the platform&rsquo;s
native encoding. If the number is 256 (0x100, 0400) or
above, Perl interprets it as a Unicode code point and the
result is the corresponding Unicode character. For example
&quot;\x{50}&quot; and &quot;\o{120}&quot; both are the
number 80 in decimal, which is less than 256, so the number
is interpreted in the native character set encoding. In
<small>ASCII</small> the character in the 80th position
(indexed from 0) is the letter &quot;P&quot;, and in
<small>EBCDIC</small> it is the ampersand symbol
&quot;&amp;&quot;. &quot;\x{100}&quot; and
&quot;\o{400}&quot; are both 256 in decimal, so the number
is interpreted as a Unicode code point no matter what the
native encoding is. The name of the character in the 256th
position (indexed by 0) in Unicode is &quot;LATIN CAPITAL
LETTER A WITH MACRON&quot;.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">An exception to
the above rule is that
&quot;\N{U+<i>hex&nbsp;number</i>}&quot; is always
interpreted as a Unicode code point, so that
&quot;\N{U+0050}&quot; is &quot;P&quot; even on
<small>EBCDIC</small> platforms.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
: Unlike C and other languages, Perl has no &quot;\v&quot;
escape sequence for the vertical tab ( <small>VT,</small>
which is 11 in both <small>ASCII</small> and
<small>EBCDIC</small> ), but you may use &quot;\N{VT}&quot;,
&quot;\ck&quot;, &quot;\N{U+0b}&quot;, or &quot;\x0b&quot;.
(&quot;\v&quot; does have meaning in regular expression
patterns in Perl, see perlre.)</p>

<p style="margin-left:11%; margin-top: 1em">The following
escape sequences are available in constructs that
interpolate, but not in transliterations.</p>

<p style="margin-left:11%; margin-top: 1em">\l lowercase
next character only <br>
\u titlecase (not uppercase!) next character only <br>
\L lowercase all characters till \E or end of string <br>
\U uppercase all characters till \E or end of string <br>
\F foldcase all characters till \E or end of string <br>
\Q quote (disable) pattern metacharacters till \E or <br>
end of string <br>
\E end either case modification or quoted section <br>
(whichever was last seen)</p>

<p style="margin-left:11%; margin-top: 1em">See
&quot;quotemeta&quot; in perlfunc for the exact definition
of characters that are quoted by &quot;\Q&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;\L&quot;,
&quot;\U&quot;, &quot;\F&quot;, and &quot;\Q&quot; can
stack, in which case you need one &quot;\E&quot; for each.
For example:</p>

<p style="margin-left:11%; margin-top: 1em">say &quot;This
\Qquoting \ubusiness \Uhere isn't quite\E done yet,\E is
it?&quot;; <br>
This quoting\ Business\ HERE\ ISN\'T\ QUITE\ done\ yet\, is
it?</p>

<p style="margin-left:11%; margin-top: 1em">If a
&quot;use&nbsp;locale&quot; form that includes
&quot;LC_CTYPE&quot; is in effect (see perllocale), the case
map used by &quot;\l&quot;, &quot;\L&quot;, &quot;\u&quot;,
and &quot;\U&quot; is taken from the current locale. If
Unicode (for example, &quot;\N{}&quot; or code points of
0x100 or beyond) is being used, the case map used by
&quot;\l&quot;, &quot;\L&quot;, &quot;\u&quot;, and
&quot;\U&quot; is as defined by Unicode. That means that
case-mapping a single character can sometimes produce a
sequence of several characters. Under
&quot;use&nbsp;locale&quot;, &quot;\F&quot; produces the
same results as &quot;\L&quot; for all locales but a
<small>UTF&minus;8</small> one, where it instead uses the
Unicode definition.</p>

<p style="margin-left:11%; margin-top: 1em">All systems use
the virtual &quot;\n&quot; to represent a line terminator,
called a &quot;newline&quot;. There is no such thing as an
unvarying, physical newline character. It is only an
illusion that the operating system, device drivers, C
libraries, and Perl all conspire to preserve. Not all
systems read &quot;\r&quot; as <small>ASCII CR</small> and
&quot;\n&quot; as <small>ASCII LF.</small> For example, on
the ancient Macs (pre-MacOS X) of yesteryear, these used to
be reversed, and on systems without a line terminator,
printing &quot;\n&quot; might emit no actual data. In
general, use &quot;\n&quot; when you mean a
&quot;newline&quot; for your system, but use the literal
<small>ASCII</small> when you need an exact character. For
example, most networking protocols expect and prefer a
<small>CR+LF</small> (&quot;\015\012&quot; or
&quot;\cM\cJ&quot;) for line terminators, and although they
often accept just &quot;\012&quot;, they seldom tolerate
just &quot;\015&quot;. If you get in the habit of using
&quot;\n&quot; for networking, you may be burned some
day.</p>

<p style="margin-left:11%; margin-top: 1em">For constructs
that do interpolate, variables beginning with
&quot;&quot;$&quot;&quot; or &quot;&quot;@&quot;&quot; are
interpolated. Subscripted variables such as $a[3] or
&quot;$href&minus;&gt;{key}[0]&quot; are also interpolated,
as are array and hash slices. But method calls such as
&quot;$obj&minus;&gt;meth&quot; are not.</p>

<p style="margin-left:11%; margin-top: 1em">Interpolating
an array or slice interpolates the elements in order,
separated by the value of $&quot;, so is equivalent to
interpolating &quot;join&nbsp;$&quot;,&nbsp;@array&quot;.
&quot;Punctuation&quot; arrays such as &quot;@*&quot; are
usually interpolated only if the name is enclosed in braces
&quot;@{*}&quot;, but the arrays @_, &quot;@+&quot;, and
&quot;@&minus;&quot; are interpolated even without
braces.</p>

<p style="margin-left:11%; margin-top: 1em">For
double-quoted strings, the quoting from &quot;\Q&quot; is
applied after interpolation and escapes are processed.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;abc\Qfoo\tbar$s\Exyz&quot;</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to</p>


<p style="margin-left:11%; margin-top: 1em">&quot;abc&quot;
. quotemeta(&quot;foo\tbar$s&quot;) . &quot;xyz&quot;</p>

<p style="margin-left:11%; margin-top: 1em">For the pattern
of regex operators (&quot;qr//&quot;, &quot;m//&quot; and
&quot;s///&quot;), the quoting from &quot;\Q&quot; is
applied after interpolation is processed, but before escapes
are processed. This allows the pattern to match literally
(except for &quot;$&quot; and &quot;@&quot;). For example,
the following matches:</p>

<p style="margin-left:11%; margin-top: 1em">'\s\t' =~
/\Q\s\t/</p>

<p style="margin-left:11%; margin-top: 1em">Because
&quot;$&quot; or &quot;@&quot; trigger interpolation,
you&rsquo;ll need to use something like
&quot;/\Quser\E\@\Qhost/&quot; to match them literally.</p>

<p style="margin-left:11%; margin-top: 1em">Patterns are
subject to an additional level of interpretation as a
regular expression. This is done as a second pass, after
variables are interpolated, so that regular expressions may
be incorporated into the pattern from the variables. If this
is not what you want, use &quot;\Q&quot; to interpolate a
variable literally.</p>

<p style="margin-left:11%; margin-top: 1em">Apart from the
behavior described above, Perl does not expand multiple
levels of interpolation. In particular, contrary to the
expectations of shell programmers, back-quotes do
<i><small>NOT</small></i> interpolate within double quotes,
nor do single quotes impede evaluation of variables when
used within double quotes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Regexp
Quote-Like Operators</b> <br>
Here are the quote-like operators that apply to pattern
matching and related activities. <br>
&quot;qr/<i>STRING</i>/msixpodualn&quot;</p>

<p style="margin-left:23%;">This operator quotes (and
possibly compiles) its <i><small>STRING</small></i> as a
regular expression. <i><small>STRING</small></i> is
interpolated the same way as <i><small>PATTERN</small></i>
in &quot;m/<i>PATTERN</i>/&quot;. If &quot;'&quot; is used
as the delimiter, no variable interpolation is done. Returns
a Perl value which may be used instead of the corresponding
&quot;/<i>STRING</i>/msixpodualn&quot; expression. The
returned value is a normalized version of the original
pattern. It magically differs from a string containing the
same characters: &quot;ref(qr/x/)&quot; returns
&quot;Regexp&quot;; however, dereferencing it is not well
defined (you currently get the normalized version of the
original pattern, but this may change).</p>

<p style="margin-left:23%; margin-top: 1em">For
example,</p>

<p style="margin-left:23%; margin-top: 1em">$rex =
qr/my.STRING/is; <br>
print $rex; # prints (?si&minus;xm:my.STRING) <br>
s/$rex/foo/;</p>

<p style="margin-left:23%; margin-top: 1em">is equivalent
to</p>


<p style="margin-left:23%; margin-top: 1em">s/my.STRING/foo/is;</p>

<p style="margin-left:23%; margin-top: 1em">The result may
be used as a subpattern in a match:</p>

<p style="margin-left:23%; margin-top: 1em">$re =
qr/$pattern/; <br>
$string =~ /foo${re}bar/; # can be interpolated in other
<br>
# patterns <br>
$string =~ $re; # or used standalone <br>
$string =~ /$re/; # or this way</p>

<p style="margin-left:23%; margin-top: 1em">Since Perl may
compile the pattern at the moment of execution of the
&quot;qr()&quot; operator, using &quot;qr()&quot; may have
speed advantages in some situations, notably if the result
of &quot;qr()&quot; is used standalone:</p>

<p style="margin-left:23%; margin-top: 1em">sub match {
<br>
my $patterns = shift; <br>
my @compiled = map qr/$_/i, @$patterns; <br>
grep { <br>
my $success = 0; <br>
foreach my $pat (@compiled) { <br>
$success = 1, last if /$pat/; <br>
} <br>
$success; <br>
} @_; <br>
}</p>

<p style="margin-left:23%; margin-top: 1em">Precompilation
of the pattern into an internal representation at the moment
of &quot;qr()&quot; avoids the need to recompile the pattern
every time a match &quot;/$pat/&quot; is attempted. (Perl
has many other internal optimizations, but none would be
triggered in the above example if we did not use
&quot;qr()&quot; operator.)</p>

<p style="margin-left:23%; margin-top: 1em">Options
(specified by the following modifiers) are:</p>

<p style="margin-left:23%; margin-top: 1em">m Treat string
as multiple lines. <br>
s Treat string as single line. (Make . match a newline) <br>
i Do case&minus;insensitive pattern matching. <br>
x Use extended regular expressions; specifying two <br>
x's means \t and the SPACE character are ignored within <br>
square&minus;bracketed character classes <br>
p When matching preserve a copy of the matched string so
<br>
that ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be <br>
defined (ignored starting in v5.20) as these are always <br>
defined starting in that release <br>
o Compile pattern only once. <br>
a ASCII&minus;restrict: Use ASCII for \d, \s, \w and
[[:posix:]] <br>
character classes; specifying two a's adds the further <br>
restriction that no ASCII character will match a <br>
non&minus;ASCII one under /i. <br>
l Use the current run&minus;time locale's rules. <br>
u Use Unicode rules. <br>
d Use Unicode or native charset, as in 5.12 and earlier.
<br>
n Non&minus;capture mode. Don't let () fill in $1, $2,
etc...</p>

<p style="margin-left:23%; margin-top: 1em">If a
precompiled pattern is embedded in a larger pattern then the
effect of &quot;msixpluadn&quot; will be propagated
appropriately. The effect that the &quot;/o&quot; modifier
has is not propagated, being restricted to those patterns
explicitly using it.</p>

<p style="margin-left:23%; margin-top: 1em">The
&quot;/a&quot;, &quot;/d&quot;, &quot;/l&quot;, and
&quot;/u&quot; modifiers (added in Perl 5.14) control the
character set rules, but &quot;/a&quot; is the only one you
are likely to want to specify explicitly; the other three
are selected automatically by various pragmas.</p>

<p style="margin-left:23%; margin-top: 1em">See perlre for
additional information on valid syntax for
<i><small>STRING</small></i> , and for a detailed look at
the semantics of regular expressions. In particular, all
modifiers except the largely obsolete &quot;/o&quot; are
further explained in &quot;Modifiers&quot; in perlre.
&quot;/o&quot; is described in the next section.</p>


<p style="margin-left:11%;">&quot;m/<i>PATTERN</i>/msixpodualngc&quot;
<br>
&quot;/<i>PATTERN</i>/msixpodualngc&quot;</p>

<p style="margin-left:23%;">Searches a string for a pattern
match, and in scalar context returns true if it succeeds,
false if it fails. If no string is specified via the
&quot;=~&quot; or &quot;!~&quot; operator, the $_ string is
searched. (The string specified with &quot;=~&quot; need not
be an lvalue--it may be the result of an expression
evaluation, but remember the &quot;=~&quot; binds rather
tightly.) See also perlre.</p>

<p style="margin-left:23%; margin-top: 1em">Options are as
described in &quot;qr//&quot; above; in addition, the
following match process modifiers are available:</p>

<p style="margin-left:23%; margin-top: 1em">g Match
globally, i.e., find all occurrences. <br>
c Do not reset search position on a failed match when /g is
<br>
in effect.</p>

<p style="margin-left:23%; margin-top: 1em">If
&quot;/&quot; is the delimiter then the initial
&quot;m&quot; is optional. With the &quot;m&quot; you can
use any pair of non-whitespace ( <small>ASCII</small> )
characters as delimiters. This is particularly useful for
matching path names that contain &quot;/&quot;, to avoid
<small>LTS</small> (leaning toothpick syndrome). If
&quot;?&quot; is the delimiter, then a match-only-once rule
applies, described in &quot;m?<i>PATTERN</i>?&quot; below.
If &quot;'&quot; (single quote) is the delimiter, no
variable interpolation is performed on the
<i><small>PATTERN</small></i> . When using a delimiter
character valid in an identifier, whitespace is required
after the &quot;m&quot;.</p>


<p style="margin-left:23%; margin-top: 1em"><i><small>PATTERN</small></i>
may contain variables, which will be interpolated every time
the pattern search is evaluated, except for when the
delimiter is a single quote. (Note that $(, $), and $| are
not interpolated because they look like end-of-string
tests.) Perl will not recompile the pattern unless an
interpolated variable that it contains changes. You can
force Perl to skip the test and never recompile by adding a
&quot;/o&quot; (which stands for &quot;once&quot;) after the
trailing delimiter. Once upon a time, Perl would recompile
regular expressions unnecessarily, and this modifier was
useful to tell it not to do so, in the interests of speed.
But now, the only reasons to use &quot;/o&quot; are one
of:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="71%">


<p>The variables are thousands of characters long and you
know that they don&rsquo;t change, and you need to wring out
the last little bit of speed by having Perl skip testing for
that. (There is a maintenance penalty for doing this, as
mentioning &quot;/o&quot; constitutes a promise that you
won&rsquo;t change the variables in the pattern. If you do
change them, Perl won&rsquo;t even notice.)</p></td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="71%">


<p>you want the pattern to use the initial values of the
variables regardless of whether they change or not. (But
there are saner ways of accomplishing this than using
&quot;/o&quot;.)</p> </td></tr>
<tr valign="top" align="left">
<td width="23%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="71%">


<p>If the pattern contains embedded code, such as</p></td></tr>
</table>

<p style="margin-left:29%; margin-top: 1em">use re 'eval';
<br>
$code = 'foo(?{ $x })'; <br>
/$code/</p>

<p style="margin-left:29%; margin-top: 1em">then perl will
recompile each time, even though the pattern string
hasn&rsquo;t changed, to ensure that the current value of $x
is seen each time. Use &quot;/o&quot; if you want to avoid
this.</p>

<p style="margin-left:23%; margin-top: 1em">The bottom line
is that using &quot;/o&quot; is almost never a good
idea.</p>

<p style="margin-left:11%;">The empty pattern
&quot;//&quot;</p>

<p style="margin-left:23%;">If the
<i><small>PATTERN</small></i> evaluates to the empty string,
the last <i>successfully</i> matched regular expression is
used instead. In this case, only the &quot;g&quot; and
&quot;c&quot; flags on the empty pattern are honored; the
other flags are taken from the original pattern. If no match
has previously succeeded, this will (silently) act instead
as a genuine empty pattern (which will always match).</p>

<p style="margin-left:23%; margin-top: 1em">Note that
it&rsquo;s possible to confuse Perl into thinking
&quot;//&quot; (the empty regex) is really &quot;//&quot;
(the defined-or operator). Perl is usually pretty good about
this, but some pathological cases might trigger this, such
as &quot;$x///&quot; (is that
&quot;($x)&nbsp;/&nbsp;(//)&quot; or
&quot;$x&nbsp;//&nbsp;/&quot;?) and
&quot;print&nbsp;$fh&nbsp;//&quot;
(&quot;print&nbsp;$fh(//&quot; or
&quot;print($fh&nbsp;//&quot;?). In all of these examples,
Perl will assume you meant defined-or. If you meant the
empty regex, just use parentheses or spaces to disambiguate,
or even prefix the empty regex with an &quot;m&quot; (so
&quot;//&quot; becomes &quot;m//&quot;).</p>

<p style="margin-left:11%;">Matching in list context</p>

<p style="margin-left:23%;">If the &quot;/g&quot; option is
not used, &quot;m//&quot; in list context returns a list
consisting of the subexpressions matched by the parentheses
in the pattern, that is, ($1, $2, $3...) (Note that here $1
etc. are also set). When there are no parentheses in the
pattern, the return value is the list &quot;(1)&quot; for
success. With or without parentheses, an empty list is
returned upon failure.</p>

<p style="margin-left:23%; margin-top: 1em">Examples:</p>

<p style="margin-left:23%; margin-top: 1em">open(TTY,
&quot;+&lt;/dev/tty&quot;) <br>
|| die &quot;can't access /dev/tty: $!&quot;; <br>
&lt;TTY&gt; =~ /^y/i &amp;&amp; foo(); # do foo if desired
<br>
if (/Version: *([0&minus;9.]*)/) { $version = $1; } <br>
next if m#^/usr/spool/uucp#; <br>
# poor man's grep <br>
$arg = shift; <br>
while (&lt;&gt;) { <br>
print if /$arg/o; # compile only once (no longer needed!)
<br>
} <br>
if (($F1, $F2, $Etc) = ($foo =~
/^(\S+)\s+(\S+)\s*(.*)/))</p>

<p style="margin-left:23%; margin-top: 1em">This last
example splits $foo into the first two words and the
remainder of the line, and assigns those three fields to
$F1, $F2, and $Etc. The conditional is true if any variables
were assigned; that is, if the pattern matched.</p>

<p style="margin-left:23%; margin-top: 1em">The
&quot;/g&quot; modifier specifies global pattern
matching--that is, matching as many times as possible within
the string. How it behaves depends on the context. In list
context, it returns a list of the substrings matched by any
capturing parentheses in the regular expression. If there
are no parentheses, it returns a list of all the matched
strings, as if there were parentheses around the whole
pattern.</p>

<p style="margin-left:23%; margin-top: 1em">In scalar
context, each execution of &quot;m//g&quot; finds the next
match, returning true if it matches, and false if there is
no further match. The position after the last match can be
read or set using the &quot;pos()&quot; function; see
&quot;pos&quot; in perlfunc. A failed match normally resets
the search position to the beginning of the string, but you
can avoid that by adding the &quot;/c&quot; modifier (for
example, &quot;m//gc&quot;). Modifying the target string
also resets the search position.</p>

<p style="margin-left:11%;">&quot;\G
<i>assertion</i>&quot;</p>

<p style="margin-left:23%;">You can intermix
&quot;m//g&quot; matches with &quot;m/\G.../g&quot;, where
&quot;\G&quot; is a zero-width assertion that matches the
exact position where the previous &quot;m//g&quot;, if any,
left off. Without the &quot;/g&quot; modifier, the
&quot;\G&quot; assertion still anchors at &quot;pos()&quot;
as it was at the start of the operation (see &quot;pos&quot;
in perlfunc), but the match is of course only attempted
once. Using &quot;\G&quot; without &quot;/g&quot; on a
target string that has not previously had a &quot;/g&quot;
match applied to it is the same as using the &quot;\A&quot;
assertion to match the beginning of the string. Note also
that, currently, &quot;\G&quot; is only properly supported
when anchored at the very beginning of the pattern.</p>

<p style="margin-left:23%; margin-top: 1em">Examples:</p>

<p style="margin-left:23%; margin-top: 1em"># list context
<br>
($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g); <br>
# scalar context <br>
local $/ = &quot;&quot;; <br>
while ($paragraph = &lt;&gt;) { <br>
while ($paragraph =~
/\p{Ll}['&quot;)]*[.!?]+['&quot;)]*\s/g) { <br>
$sentences++; <br>
} <br>
} <br>
say $sentences;</p>

<p style="margin-left:23%; margin-top: 1em">Here&rsquo;s
another way to check for sentences in a paragraph:</p>

<p style="margin-left:23%; margin-top: 1em">my $sentence_rx
= qr{ <br>
(?: (?&lt;= ^ ) | (?&lt;= \s ) ) # after
start&minus;of&minus;string or <br>
# whitespace <br>
\p{Lu} # capital letter <br>
.*? # a bunch of anything <br>
(?&lt;= \S ) # that ends in non&minus; <br>
# whitespace <br>
(?&lt;! \b [DMS]r ) # but isn't a common abbr. <br>
(?&lt;! \b Mrs ) <br>
(?&lt;! \b Sra ) <br>
(?&lt;! \b St ) <br>
[.?!] # followed by a sentence <br>
# ender <br>
(?= $ | \s ) # in front of end&minus;of&minus;string <br>
# or whitespace <br>
}sx; <br>
local $/ = &quot;&quot;; <br>
while (my $paragraph = &lt;&gt;) { <br>
say &quot;NEW PARAGRAPH&quot;; <br>
my $count = 0; <br>
while ($paragraph =~ /($sentence_rx)/g) { <br>
printf &quot;\tgot sentence %d: &lt;%s&gt;\n&quot;,
++$count, $1; <br>
} <br>
}</p>

<p style="margin-left:23%; margin-top: 1em">Here&rsquo;s
how to use &quot;m//gc&quot; with &quot;\G&quot;:</p>

<p style="margin-left:23%; margin-top: 1em">$_ =
&quot;ppooqppqq&quot;; <br>
while ($i++ &lt; 2) { <br>
print &quot;1: '&quot;; <br>
print $1 while /(o)/gc; print &quot;', pos=&quot;, pos,
&quot;\n&quot;; <br>
print &quot;2: '&quot;; <br>
print $1 if /\G(q)/gc; print &quot;', pos=&quot;, pos,
&quot;\n&quot;; <br>
print &quot;3: '&quot;; <br>
print $1 while /(p)/gc; print &quot;', pos=&quot;, pos,
&quot;\n&quot;; <br>
} <br>
print &quot;Final: '$1', pos=&quot;,pos,&quot;\n&quot; if
/\G(.)/;</p>

<p style="margin-left:23%; margin-top: 1em">The last
example should print:</p>

<p style="margin-left:23%; margin-top: 1em">1: 'oo', pos=4
<br>
2: 'q', pos=5 <br>
3: 'pp', pos=7 <br>
1: '', pos=7 <br>
2: 'q', pos=8 <br>
3: '', pos=8 <br>
Final: 'q', pos=8</p>

<p style="margin-left:23%; margin-top: 1em">Notice that the
final match matched &quot;q&quot; instead of &quot;p&quot;,
which a match without the &quot;\G&quot; anchor would have
done. Also note that the final match did not update
&quot;pos&quot;. &quot;pos&quot; is only updated on a
&quot;/g&quot; match. If the final match did indeed match
&quot;p&quot;, it&rsquo;s a good bet that you&rsquo;re
running an ancient (pre&minus;5.6.0) version of Perl.</p>

<p style="margin-left:23%; margin-top: 1em">A useful idiom
for &quot;lex&quot;&minus;like scanners is
&quot;/\G.../gc&quot;. You can combine several regexps like
this to process a string part-by-part, doing different
actions depending on which regexp matched. Each regexp tries
to match where the previous one leaves off.</p>

<p style="margin-left:23%; margin-top: 1em">$_ =
&lt;&lt;'EOL'; <br>
$url = URI::URL&minus;&gt;new(
&quot;http://example.com/&quot; ); <br>
die if $url eq &quot;xXx&quot;; <br>
EOL <br>
LOOP: { <br>
print(&quot; digits&quot;), redo LOOP if
/\G\d+\b[,.;]?\s*/gc; <br>
print(&quot; lowercase&quot;), redo LOOP <br>
if /\G\p{Ll}+\b[,.;]?\s*/gc; <br>
print(&quot; UPPERCASE&quot;), redo LOOP <br>
if /\G\p{Lu}+\b[,.;]?\s*/gc; <br>
print(&quot; Capitalized&quot;), redo LOOP <br>
if /\G\p{Lu}\p{Ll}+\b[,.;]?\s*/gc; <br>
print(&quot; MiXeD&quot;), redo LOOP if
/\G\pL+\b[,.;]?\s*/gc; <br>
print(&quot; alphanumeric&quot;), redo LOOP <br>
if /\G[\p{Alpha}\pN]+\b[,.;]?\s*/gc; <br>
print(&quot; line&minus;noise&quot;), redo LOOP if
/\G\W+/gc; <br>
print &quot;. That's all!\n&quot;; <br>
}</p>

<p style="margin-left:23%; margin-top: 1em">Here is the
output (split into several lines):</p>


<p style="margin-left:23%; margin-top: 1em">line&minus;noise
lowercase line&minus;noise UPPERCASE line&minus;noise
UPPERCASE <br>
line&minus;noise lowercase line&minus;noise lowercase
line&minus;noise lowercase <br>
lowercase line&minus;noise lowercase lowercase
line&minus;noise lowercase <br>
lowercase line&minus;noise MiXeD line&minus;noise. That's
all!</p>


<p style="margin-left:11%;">&quot;m?<i>PATTERN</i>?msixpodualngc&quot;</p>

<p style="margin-left:23%;">This is just like the
&quot;m/<i>PATTERN</i>/&quot; search, except that it matches
only once between calls to the &quot;reset()&quot; operator.
This is a useful optimization when you want to see only the
first occurrence of something in each file of a set of
files, for instance. Only &quot;m??&quot; patterns local to
the current package are reset.</p>

<p style="margin-left:23%; margin-top: 1em">while
(&lt;&gt;) { <br>
if (m?^$?) { <br>
# blank line between header and body <br>
} <br>
} continue { <br>
reset if eof; # clear m?? status for next file <br>
}</p>

<p style="margin-left:23%; margin-top: 1em">Another example
switched the first &quot;latin1&quot; encoding it finds to
&quot;utf8&quot; in a pod file:</p>

<p style="margin-left:23%; margin-top: 1em">s//utf8/ if m?
^ =encoding \h+ \K latin1 ?x;</p>

<p style="margin-left:23%; margin-top: 1em">The match-once
behavior is controlled by the match delimiter being
&quot;?&quot;; with any other delimiter this is the normal
&quot;m//&quot; operator.</p>

<p style="margin-left:23%; margin-top: 1em">In the past,
the leading &quot;m&quot; in &quot;m?<i>PATTERN</i>?&quot;
was optional, but omitting it would produce a deprecation
warning. As of v5.22.0, omitting it produces a syntax error.
If you encounter this construct in older code, you can just
add &quot;m&quot;.</p>


<p style="margin-left:11%;">&quot;s/<i>PATTERN</i>/<i>REPLACEMENT</i>/msixpodualngcer&quot;</p>

<p style="margin-left:23%;">Searches a string for a
pattern, and if found, replaces that pattern with the
replacement text and returns the number of substitutions
made. Otherwise it returns false (a value that is both an
empty string (&quot;&quot;) and numeric zero (0) as
described in &quot;Relational Operators&quot;).</p>

<p style="margin-left:23%; margin-top: 1em">If the
&quot;/r&quot; (non-destructive) option is used then it runs
the substitution on a copy of the string and instead of
returning the number of substitutions, it returns the copy
whether or not a substitution occurred. The original string
is never changed when &quot;/r&quot; is used. The copy will
always be a plain string, even if the input is an object or
a tied variable.</p>

<p style="margin-left:23%; margin-top: 1em">If no string is
specified via the &quot;=~&quot; or &quot;!~&quot; operator,
the $_ variable is searched and modified. Unless the
&quot;/r&quot; option is used, the string specified must be
a scalar variable, an array element, a hash element, or an
assignment to one of those; that is, some sort of scalar
lvalue.</p>

<p style="margin-left:23%; margin-top: 1em">If the
delimiter chosen is a single quote, no variable
interpolation is done on either the
<i><small>PATTERN</small></i> or the
<i><small>REPLACEMENT</small></i> . Otherwise, if the
<i><small>PATTERN</small></i> contains a &quot;$&quot; that
looks like a variable rather than an end-of-string test, the
variable will be interpolated into the pattern at run-time.
If you want the pattern compiled only once the first time
the variable is interpolated, use the &quot;/o&quot; option.
If the pattern evaluates to the empty string, the last
successfully executed regular expression is used instead.
See perlre for further explanation on these.</p>

<p style="margin-left:23%; margin-top: 1em">Options are as
with &quot;m//&quot; with the addition of the following
replacement specific options:</p>

<p style="margin-left:23%; margin-top: 1em">e Evaluate the
right side as an expression. <br>
ee Evaluate the right side as a string then eval the <br>
result. <br>
r Return substitution and leave the original string <br>
untouched.</p>

<p style="margin-left:23%; margin-top: 1em">Any
non-whitespace delimiter may replace the slashes. Add space
after the &quot;s&quot; when using a character allowed in
identifiers. If single quotes are used, no interpretation is
done on the replacement string (the &quot;/e&quot; modifier
overrides this, however). Note that Perl treats backticks as
normal delimiters; the replacement text is not evaluated as
a command. If the <i><small>PATTERN</small></i> is delimited
by bracketing quotes, the <i><small>REPLACEMENT</small></i>
has its own pair of quotes, which may or may not be
bracketing quotes, for example, &quot;s(foo)(bar)&quot; or
&quot;s&lt;foo&gt;/bar/&quot;. A &quot;/e&quot; will cause
the replacement portion to be treated as a full-fledged Perl
expression and evaluated right then and there. It is,
however, syntax checked at compile-time. A second
&quot;e&quot; modifier will cause the replacement portion to
be &quot;eval&quot;ed before being run as a Perl
expression.</p>

<p style="margin-left:23%; margin-top: 1em">Examples:</p>


<p style="margin-left:23%; margin-top: 1em">s/\bgreen\b/mauve/g;
# don't change wintergreen <br>
$path =~ s|/usr/bin|/usr/local/bin|; <br>
s/Login: $foo/Login: $bar/; # run&minus;time pattern <br>
($foo = $bar) =~ s/this/that/; # copy first, then <br>
# change <br>
($foo = &quot;$bar&quot;) =~ s/this/that/; # convert to
string, <br>
# copy, then change <br>
$foo = $bar =~ s/this/that/r; # Same as above using /r <br>
$foo = $bar =~ s/this/that/r <br>
=~ s/that/the other/r; # Chained substitutes <br>
# using /r <br>
@foo = map { s/this/that/r } @bar # /r is very useful in
<br>
# maps <br>
$count = ($paragraph =~ s/Mister\b/Mr./g); # get
change&minus;cnt <br>
$_ = 'abc123xyz'; <br>
s/\d+/$&amp;*2/e; # yields 'abc246xyz' <br>
s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e; # yields 'abc
246xyz' <br>
s/\w/$&amp; x 2/eg; # yields 'aabbcc 224466xxyyzz' <br>
s/%(.)/$percent{$1}/g; # change percent escapes; no /e <br>
s/%(.)/$percent{$1} || $&amp;/ge; # expr now, so /e <br>
s/^=(\w+)/pod($1)/ge; # use function call <br>
$_ = 'abc123xyz'; <br>
$x = s/abc/def/r; # $x is 'def123xyz' and <br>
# $_ remains 'abc123xyz'. <br>
# expand variables in $_, but dynamics only, using <br>
# symbolic dereferencing <br>
s/\$(\w+)/${$1}/g; <br>
# Add one to the value of any numbers in the string <br>
s/(\d+)/1 + $1/eg; <br>
# Titlecase words in the last 30 characters only (presuming
<br>
# that the substring doesn't start in the middle of a word)
<br>
substr($str, &minus;30) =~
s/\b(\p{Alpha})(\p{Alpha}*)\b/\u$1\L$2/g; <br>
# This will expand any embedded scalar variable <br>
# (including lexicals) in $_ : First $1 is interpolated <br>
# to the variable name, and then evaluated <br>
s/(\$\w+)/$1/eeg; <br>
# Delete (most) C comments. <br>
$program =~ s { <br>
/\* # Match the opening delimiter. <br>
.*? # Match a minimal number of characters. <br>
\*/ # Match the closing delimiter. <br>
} []gsx; <br>
s/^\s*(.*?)\s*$/$1/; # trim whitespace in $_, <br>
# expensively <br>
for ($variable) { # trim whitespace in $variable, <br>
# cheap <br>
s/^\s+//; <br>
s/\s+$//; <br>
} <br>
s/([^ ]*) *([^ ]*)/$2 $1/; # reverse 1st two fields <br>
$foo !~ s/A/a/g; # Lowercase all A's in $foo; return <br>
# 0 if any were found and changed; <br>
# otherwise return 1</p>

<p style="margin-left:23%; margin-top: 1em">Note the use of
&quot;$&quot; instead of &quot;\&quot; in the last example.
Unlike <b>sed</b>, we use the \&lt;<i>digit</i>&gt; form
only in the left hand side. Anywhere else it&rsquo;s
$&lt;<i>digit</i>&gt;.</p>

<p style="margin-left:23%; margin-top: 1em">Occasionally,
you can&rsquo;t use just a &quot;/g&quot; to get all the
changes to occur that you might want. Here are two common
cases:</p>

<p style="margin-left:23%; margin-top: 1em"># put commas in
the right places in an integer <br>
1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g; <br>
# expand tabs to 8&minus;column spacing <br>
1 while s/\t+/' ' x (length($&amp;)*8 &minus;
length($`)%8)/e;</p>

<p style="margin-left:23%; margin-top: 1em">While
&quot;s///&quot; accepts the &quot;/c&quot; flag, it has no
effect beyond producing a warning if warnings are
enabled.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Quote-Like
Operators</b> <br>
&quot;q/<i>STRING</i>/&quot; <br>
'<i>STRING</i>'</p>

<p style="margin-left:17%;">A single-quoted, literal
string. A backslash represents a backslash unless followed
by the delimiter or another backslash, in which case the
delimiter or backslash is interpolated.</p>

<p style="margin-left:17%; margin-top: 1em">$foo = q!I
said, &quot;You said, 'She said it.'&quot;!; <br>
$bar = q('This is it.'); <br>
$baz = '\n'; # a two&minus;character string</p>

<p style="margin-left:11%;">&quot;qq/<i>STRING</i>/&quot;
<br>
&quot;<i>STRING</i>&quot;</p>

<p style="margin-left:17%;">A double-quoted, interpolated
string.</p>

<p style="margin-left:17%; margin-top: 1em">$_ .= qq <br>
(*** The previous line contains the naughty word
&quot;$1&quot;.\n) <br>
if /\b(tcl|java|python)\b/i; # :&minus;) <br>
$baz = &quot;\n&quot;; # a one&minus;character string</p>

<p style="margin-left:11%;">&quot;qx/<i>STRING</i>/&quot;
<br>
&quot;`<i>STRING</i>`&quot;</p>

<p style="margin-left:17%;">A string which is (possibly)
interpolated and then executed as a system command, via
<i>/bin/sh</i> or its equivalent if required. Shell
wildcards, pipes, and redirections will be honored.
Similarly to &quot;system&quot;, if the string contains no
shell metacharacters then it will executed directly. The
collected standard output of the command is returned;
standard error is unaffected. In scalar context, it comes
back as a single (potentially multi-line) string, or
&quot;undef&quot; if the shell (or command) could not be
started. In list context, returns a list of lines (however
you&rsquo;ve defined lines with $/ or
$INPUT_RECORD_SEPARATOR), or an empty list if the shell (or
command) could not be started.</p>

<p style="margin-left:17%; margin-top: 1em">Because
backticks do not affect standard error, use shell file
descriptor syntax (assuming the shell supports this) if you
care to address this. To capture a command&rsquo;s
<small>STDERR</small> and <small>STDOUT</small>
together:</p>

<p style="margin-left:17%; margin-top: 1em">$output = `cmd
2&gt;&amp;1`;</p>

<p style="margin-left:17%; margin-top: 1em">To capture a
command&rsquo;s <small>STDOUT</small> but discard its
<small>STDERR:</small></p>

<p style="margin-left:17%; margin-top: 1em">$output = `cmd
2&gt;/dev/null`;</p>

<p style="margin-left:17%; margin-top: 1em">To capture a
command&rsquo;s <small>STDERR</small> but discard its
<small>STDOUT</small> (ordering is important here):</p>

<p style="margin-left:17%; margin-top: 1em">$output = `cmd
2&gt;&amp;1 1&gt;/dev/null`;</p>

<p style="margin-left:17%; margin-top: 1em">To exchange a
command&rsquo;s <small>STDOUT</small> and
<small>STDERR</small> in order to capture the
<small>STDERR</small> but leave its <small>STDOUT</small> to
come out the old <small>STDERR:</small></p>

<p style="margin-left:17%; margin-top: 1em">$output = `cmd
3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;&minus;`;</p>

<p style="margin-left:17%; margin-top: 1em">To read both a
command&rsquo;s <small>STDOUT</small> and its
<small>STDERR</small> separately, it&rsquo;s easiest to
redirect them separately to files, and then read from those
files when the program is done:</p>


<p style="margin-left:17%; margin-top: 1em">system(&quot;program
args 1&gt;program.stdout 2&gt;program.stderr&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">The
<small>STDIN</small> filehandle used by the command is
inherited from Perl&rsquo;s <small>STDIN.</small> For
example:</p>

<p style="margin-left:17%; margin-top: 1em">open(SPLAT,
&quot;stuff&quot;) || die &quot;can't open stuff: $!&quot;;
<br>
open(STDIN, &quot;&lt;&amp;SPLAT&quot;) || die &quot;can't
dupe SPLAT: $!&quot;; <br>
print STDOUT `sort`;</p>

<p style="margin-left:17%; margin-top: 1em">will print the
sorted contents of the file named
<i>&quot;stuff&quot;</i>.</p>

<p style="margin-left:17%; margin-top: 1em">Using
single-quote as a delimiter protects the command from
Perl&rsquo;s double-quote interpolation, passing it on to
the shell instead:</p>

<p style="margin-left:17%; margin-top: 1em">$perl_info =
qx(ps $$); # that's Perl's $$ <br>
$shell_info = qx'ps $$'; # that's the new shell's $$</p>

<p style="margin-left:17%; margin-top: 1em">How that string
gets evaluated is entirely subject to the command
interpreter on your system. On most platforms, you will have
to protect shell metacharacters if you want them treated
literally. This is in practice difficult to do, as
it&rsquo;s unclear how to escape which characters. See
perlsec for a clean and safe example of a manual
&quot;fork()&quot; and &quot;exec()&quot; to emulate
backticks safely.</p>

<p style="margin-left:17%; margin-top: 1em">On some
platforms (notably DOS-like ones), the shell may not be
capable of dealing with multiline commands, so putting
newlines in the string may not get you what you want. You
may be able to evaluate multiple commands in a single line
by separating them with the command separator character, if
your shell supports that (for example, &quot;;&quot; on many
Unix shells and &quot;&amp;&quot; on the Windows
<small>NT</small> &quot;cmd&quot; shell).</p>

<p style="margin-left:17%; margin-top: 1em">Perl will
attempt to flush all files opened for output before starting
the child process, but this may not be supported on some
platforms (see perlport). To be safe, you may need to set $|
($AUTOFLUSH in &quot;English&quot;) or call the
&quot;autoflush()&quot; method of &quot;IO::Handle&quot; on
any open handles.</p>

<p style="margin-left:17%; margin-top: 1em">Beware that
some command shells may place restrictions on the length of
the command line. You must ensure your strings don&rsquo;t
exceed this limit after any necessary interpolations. See
the platform-specific release notes for more details about
your particular environment.</p>

<p style="margin-left:17%; margin-top: 1em">Using this
operator can lead to programs that are difficult to port,
because the shell commands called vary between systems, and
may in fact not be present at all. As one example, the
&quot;type&quot; command under the <small>POSIX</small>
shell is very different from the &quot;type&quot; command
under <small>DOS.</small> That doesn&rsquo;t mean you should
go out of your way to avoid backticks when they&rsquo;re the
right way to get something done. Perl was made to be a glue
language, and one of the things it glues together is
commands. Just understand what you&rsquo;re getting yourself
into.</p>

<p style="margin-left:17%; margin-top: 1em">Like
&quot;system&quot;, backticks put the child process exit
code in $?. If you&rsquo;d like to manually inspect failure,
you can check all possible failure modes by inspecting $?
like this:</p>

<p style="margin-left:17%; margin-top: 1em">if ($? ==
&minus;1) { <br>
print &quot;failed to execute: $!\n&quot;; <br>
} <br>
elsif ($? &amp; 127) { <br>
printf &quot;child died with signal %d, %s coredump\n&quot;,
<br>
($? &amp; 127), ($? &amp; 128) ? 'with' : 'without'; <br>
} <br>
else { <br>
printf &quot;child exited with value %d\n&quot;, $? &gt;&gt;
8; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">Use the open
pragma to control the I/O layers used when reading the
output of the command, for example:</p>

<p style="margin-left:17%; margin-top: 1em">use open IN
=&gt; &quot;:encoding(UTF&minus;8)&quot;; <br>
my $x = `cmd&minus;producing&minus;utf&minus;8`;</p>


<p style="margin-left:17%; margin-top: 1em">&quot;qx//&quot;
can also be called like a function with &quot;readpipe&quot;
in perlfunc.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;I/O
Operators&quot; for more discussion.</p>


<p style="margin-left:11%;">&quot;qw/<i>STRING</i>/&quot;</p>

<p style="margin-left:17%;">Evaluates to a list of the
words extracted out of <i><small>STRING</small></i> , using
embedded whitespace as the word delimiters. It can be
understood as being roughly equivalent to:</p>

<p style="margin-left:17%; margin-top: 1em">split(&quot;
&quot;, q/STRING/);</p>

<p style="margin-left:17%; margin-top: 1em">the differences
being that it only splits on <small>ASCII</small>
whitespace, generates a real list at compile time, and in
scalar context it returns the last element in the list. So
this expression:</p>

<p style="margin-left:17%; margin-top: 1em">qw(foo bar
baz)</p>

<p style="margin-left:17%; margin-top: 1em">is semantically
equivalent to the list:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;foo&quot;,
&quot;bar&quot;, &quot;baz&quot;</p>

<p style="margin-left:17%; margin-top: 1em">Some frequently
seen examples:</p>

<p style="margin-left:17%; margin-top: 1em">use POSIX qw(
setlocale localeconv ) <br>
@EXPORT = qw( foo bar baz );</p>

<p style="margin-left:17%; margin-top: 1em">A common
mistake is to try to separate the words with commas or to
put comments into a multi-line &quot;qw&quot;&minus;string.
For this reason, the &quot;use&nbsp;warnings&quot; pragma
and the <b>&minus;w</b> switch (that is, the $^W variable)
produces warnings if the <i><small>STRING</small></i>
contains the &quot;,&quot; or the &quot;#&quot;
character.</p>


<p style="margin-left:11%;">&quot;tr/<i>SEARCHLIST</i>/<i>REPLACEMENTLIST</i>/cdsr&quot;
<br>

&quot;y/<i>SEARCHLIST</i>/<i>REPLACEMENTLIST</i>/cdsr&quot;</p>

<p style="margin-left:17%;">Transliterates all occurrences
of the characters found (or not found if the &quot;/c&quot;
modifier is specified) in the search list with the
positionally corresponding character in the replacement
list, possibly deleting some, depending on the modifiers
specified. It returns the number of characters replaced or
deleted. If no string is specified via the &quot;=~&quot; or
&quot;!~&quot; operator, the $_ string is
transliterated.</p>

<p style="margin-left:17%; margin-top: 1em">For <b>sed</b>
devotees, &quot;y&quot; is provided as a synonym for
&quot;tr&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;/r&quot; (non-destructive) option is present, a new
copy of the string is made and its characters
transliterated, and this copy is returned no matter whether
it was modified or not: the original string is always left
unchanged. The new copy is always a plain string, even if
the input string is an object or a tied variable.</p>

<p style="margin-left:17%; margin-top: 1em">Unless the
&quot;/r&quot; option is used, the string specified with
&quot;=~&quot; must be a scalar variable, an array element,
a hash element, or an assignment to one of those; in other
words, an lvalue.</p>

<p style="margin-left:17%; margin-top: 1em">The characters
delimitting <i><small>SEARCHLIST</small></i> and
<i><small>REPLACEMENTLIST</small></i> can be any printable
character, not just forward slashes. If they are single
quotes
(&quot;tr'<i>SEARCHLIST</i>'<i>REPLACEMENTLIST</i>'&quot;),
the only interpolation is removal of &quot;\&quot; from
pairs of &quot;\\&quot;; so hyphens are interpreted
literally rather than specifying a character range.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise, a
character range may be specified with a hyphen, so
&quot;tr/A&minus;J/0&minus;9/&quot; does the same
replacement as &quot;tr/ACEGIBDFHJ/0246813579/&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If the
<i><small>SEARCHLIST</small></i> is delimited by bracketing
quotes, the <i><small>REPLACEMENTLIST</small></i> must have
its own pair of quotes, which may or may not be bracketing
quotes; for example, &quot;tr(aeiouy)(yuoiea)&quot; or
&quot;tr[+\&minus;*/]&quot;ABCD&quot;&quot;. This final
example shows a way to visually clarify what is going on for
people who are more familiar with regular expression
patterns than with &quot;tr&quot;, and who may think forward
slash delimiters imply that &quot;tr&quot; is more like a
regular expression pattern than it actually is. (Another
option might be to use &quot;tr[...][...]&quot;.)</p>

<p style="margin-left:17%; margin-top: 1em">&quot;tr&quot;
isn&rsquo;t fully like bracketed character classes, just
(significantly) more like them than it is to full patterns.
For example, characters appearing more than once in either
list behave differently here than in patterns, and
&quot;tr&quot; lists do not allow backslashed character
classes such as &quot;\d&quot; or &quot;\pL&quot;, nor
variable interpolation, so &quot;$&quot; and &quot;@&quot;
are always treated as literals.</p>

<p style="margin-left:17%; margin-top: 1em">The allowed
elements are literals plus &quot;\'&quot; (meaning a single
quote). If the delimiters aren&rsquo;t single quotes, also
allowed are any of the escape sequences accepted in
double-quoted strings. Escape sequence details are in the
table near the beginning of this section.</p>

<p style="margin-left:17%; margin-top: 1em">A hyphen at the
beginning or end, or preceded by a backslash is also always
considered a literal. Precede a delimiter character with a
backslash to allow it.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;tr&quot; operator is not equivalent to the tr(1)
utility. &quot;tr[a&minus;z][A&minus;Z]&quot; will uppercase
the 26 letters &quot;a&quot; through &quot;z&quot;, but for
case changing not confined to <small>ASCII,</small> use
&quot;lc&quot;, &quot;uc&quot;, &quot;lcfirst&quot;,
&quot;ucfirst&quot; (all documented in perlfunc), or the
substitution operator
&quot;s/<i>PATTERN</i>/<i>REPLACEMENT</i>/&quot; (with
&quot;\U&quot;, &quot;\u&quot;, &quot;\L&quot;, and
&quot;\l&quot; string-interpolation escapes in the
<i><small>REPLACEMENT</small></i> portion).</p>

<p style="margin-left:17%; margin-top: 1em">Most ranges are
unportable between character sets, but certain ones signal
Perl to do special handling to make them portable. There are
two classes of portable ranges. The first are any subsets of
the ranges &quot;A&minus;Z&quot;, &quot;a&minus;z&quot;, and
&quot;0&minus;9&quot;, when expressed as literal
characters.</p>


<p style="margin-left:17%; margin-top: 1em">tr/h&minus;k/H&minus;K/</p>

<p style="margin-left:17%; margin-top: 1em">capitalizes the
letters &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, and
&quot;k&quot; and nothing else, no matter what the
platform&rsquo;s character set is. In contrast, all of</p>


<p style="margin-left:17%; margin-top: 1em">tr/\x68&minus;\x6B/\x48&minus;\x4B/
<br>
tr/h&minus;\x6B/H&minus;\x4B/ <br>
tr/\x68&minus;k/\x48&minus;K/</p>

<p style="margin-left:17%; margin-top: 1em">do the same
capitalizations as the previous example when run on
<small>ASCII</small> platforms, but something completely
different on <small>EBCDIC</small> ones.</p>

<p style="margin-left:17%; margin-top: 1em">The second
class of portable ranges is invoked when one or both of the
range&rsquo;s end points are expressed as
&quot;\N{...}&quot;</p>

<p style="margin-left:17%; margin-top: 1em">$string =~
tr/\N{U+20}&minus;\N{U+7E}//d;</p>

<p style="margin-left:17%; margin-top: 1em">removes from
$string all the platform&rsquo;s characters which are
equivalent to any of Unicode U+0020, U+0021, ... U+007D,
U+007E. This is a portable range, and has the same effect on
every platform it is run on. In this example, these are the
<small>ASCII</small> printable characters. So after this is
run, $string has only controls and characters which have no
<small>ASCII</small> equivalents.</p>

<p style="margin-left:17%; margin-top: 1em">But, even for
portable ranges, it is not generally obvious what is
included without having to look things up in the manual. A
sound principle is to use only ranges that both begin from,
and end at, either <small>ASCII</small> alphabetics of equal
case (&quot;b&minus;e&quot;, &quot;B&minus;E&quot;), or
digits (&quot;1&minus;4&quot;). Anything else is unclear
(and unportable unless &quot;\N{...}&quot; is used). If in
doubt, spell out the character sets in full.</p>

<p style="margin-left:17%; margin-top: 1em">Options:</p>

<p style="margin-left:17%; margin-top: 1em">c Complement
the SEARCHLIST. <br>
d Delete found but unreplaced characters. <br>
r Return the modified string and leave the original string
<br>
untouched. <br>
s Squash duplicate replaced characters.</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;/d&quot; modifier is specified, any characters
specified by <i><small>SEARCHLIST</small></i> not found in
<i><small>REPLACEMENTLIST</small></i> are deleted. (Note
that this is slightly more flexible than the behavior of
some <b>tr</b> programs, which delete anything they find in
the <i><small>SEARCHLIST</small></i> , period.)</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;/s&quot; modifier is specified, sequences of
characters, all in a row, that were transliterated to the
same character are squashed down to a single instance of
that character.</p>

<p style="margin-left:17%; margin-top: 1em">my $a =
&quot;aaabbbca&quot;; <br>
$a =~ tr/ab/dd/s; # $a now is &quot;dcd&quot;</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;/d&quot; modifier is used, the
<i><small>REPLACEMENTLIST</small></i> is always interpreted
exactly as specified. Otherwise, if the
<i><small>REPLACEMENTLIST</small></i> is shorter than the
<i><small>SEARCHLIST</small></i> , the final character, if
any, is replicated until it is long enough. There
won&rsquo;t be a final character if and only if the
<i><small>REPLACEMENTLIST</small></i> is empty, in which
case <i><small>REPLACEMENTLIST</small></i> is copied from
<i><small>SEARCHLIST</small></i> . An empty
<i><small>REPLACEMENTLIST</small></i> is useful for counting
characters in a class, or for squashing character sequences
in a class.</p>

<p style="margin-left:17%; margin-top: 1em">tr/abcd//
tr/abcd/abcd/ <br>
tr/abcd/AB/ tr/abcd/ABBB/ <br>
tr/abcd//d s/[abcd]//g <br>
tr/abcd/AB/d (tr/ab/AB/ + s/[cd]//g) &minus; but run
together</p>

<p style="margin-left:17%; margin-top: 1em">If the
&quot;/c&quot; modifier is specified, the characters to be
transliterated are the ones <small>NOT</small> in
<i><small>SEARCHLIST</small></i> , that is, it is
complemented. If &quot;/d&quot; and/or &quot;/s&quot; are
also specified, they apply to the complemented
<i><small>SEARCHLIST</small></i> . Recall, that if
<i><small>REPLACEMENTLIST</small></i> is empty (except under
&quot;/d&quot;) a copy of <i><small>SEARCHLIST</small></i>
is used instead. That copy is made after complementing under
&quot;/c&quot;. <i><small>SEARCHLIST</small></i> is sorted
by code point order after complementing, and any
<i><small>REPLACEMENTLIST</small></i> is applied to that
sorted result. This means that under &quot;/c&quot;, the
order of the characters specified in
<i><small>SEARCHLIST</small></i> is irrelevant. This can
lead to different results on <small>EBCDIC</small> systems
if <i><small>REPLACEMENTLIST</small></i> contains more than
one character, hence it is generally non-portable to use
&quot;/c&quot; with such a
<i><small>REPLACEMENTLIST</small></i> .</p>

<p style="margin-left:17%; margin-top: 1em">Another way of
describing the operation is this: If &quot;/c&quot; is
specified, the <i><small>SEARCHLIST</small></i> is sorted by
code point order, then complemented. If
<i><small>REPLACEMENTLIST</small></i> is empty and
&quot;/d&quot; is not specified,
<i><small>REPLACEMENTLIST</small></i> is replaced by a copy
of <i><small>SEARCHLIST</small></i> (as modified under
&quot;/c&quot;), and these potentially modified lists are
used as the basis for what follows. Any character in the
target string that isn&rsquo;t in
<i><small>SEARCHLIST</small></i> is passed through
unchanged. Every other character in the target string is
replaced by the character in
<i><small>REPLACEMENTLIST</small></i> that positionally
corresponds to its mate in <i><small>SEARCHLIST</small></i>
, except that under &quot;/s&quot;, the 2nd and following
characters are squeezed out in a sequence of characters in a
row that all translate to the same character. If
<i><small>SEARCHLIST</small></i> is longer than
<i><small>REPLACEMENTLIST</small></i> , characters in the
target string that match a character in
<i><small>SEARCHLIST</small></i> that doesn&rsquo;t have a
correspondence in <i><small>REPLACEMENTLIST</small></i> are
either deleted from the target string if &quot;/d&quot; is
specified; or replaced by the final character in
<i><small>REPLACEMENTLIST</small></i> if &quot;/d&quot;
isn&rsquo;t specified.</p>

<p style="margin-left:17%; margin-top: 1em">Some
examples:</p>

<p style="margin-left:17%; margin-top: 1em">$ARGV[1] =~
tr/A&minus;Z/a&minus;z/; # canonicalize to lower case ASCII
<br>
$cnt = tr/*/*/; # count the stars in $_ <br>
$cnt = tr/*//; # same thing <br>
$cnt = $sky =~ tr/*/*/; # count the stars in $sky <br>
$cnt = $sky =~ tr/*//; # same thing <br>
$cnt = $sky =~ tr/*//c; # count all the non&minus;stars in
$sky <br>
$cnt = $sky =~ tr/*/*/c; # same, but transliterate each
non&minus;star <br>
# into a star, leaving the already&minus;stars <br>
# alone. Afterwards, everything in $sky <br>
# is a star. <br>
$cnt = tr/0&minus;9//; # count the ASCII digits in $_ <br>
tr/a&minus;zA&minus;Z//s; # bookkeeper &minus;&gt; bokeper
<br>
tr/o/o/s; # bookkeeper &minus;&gt; bokkeeper <br>
tr/oe/oe/s; # bookkeeper &minus;&gt; bokkeper <br>
tr/oe//s; # bookkeeper &minus;&gt; bokkeper <br>
tr/oe/o/s; # bookkeeper &minus;&gt; bokkopor <br>
($HOST = $host) =~ tr/a&minus;z/A&minus;Z/; <br>
$HOST = $host =~ tr/a&minus;z/A&minus;Z/r; # same thing <br>
$HOST = $host =~ tr/a&minus;z/A&minus;Z/r # chained with
s///r <br>
=~ s/:/ &minus;p/r; <br>
tr/a&minus;zA&minus;Z/ /cs; # change non&minus;alphas to
single space <br>
@stripped = map tr/a&minus;zA&minus;Z/ /csr, @original; <br>
# /r with map <br>
tr [\200&minus;\377] <br>
[\000&minus;\177]; # wickedly delete 8th bit <br>
$foo !~ tr/A/a/ # transliterate all the A's in $foo to 'a',
<br>
# return 0 if any were found and changed. <br>
# Otherwise return 1</p>

<p style="margin-left:17%; margin-top: 1em">If multiple
transliterations are given for a character, only the first
one is used:</p>


<p style="margin-left:17%; margin-top: 1em">tr/AAA/XYZ/</p>

<p style="margin-left:17%; margin-top: 1em">will
transliterate any A to X.</p>

<p style="margin-left:17%; margin-top: 1em">Because the
transliteration table is built at compile time, neither the
<i><small>SEARCHLIST</small></i> nor the
<i><small>REPLACEMENTLIST</small></i> are subjected to
double quote interpolation. That means that if you want to
use variables, you must use an &quot;eval()&quot;:</p>

<p style="margin-left:17%; margin-top: 1em">eval
&quot;tr/$oldlist/$newlist/&quot;; <br>
die $@ if $@; <br>
eval &quot;tr/$oldlist/$newlist/, 1&quot; or die $@;</p>


<p style="margin-left:11%;">&quot;&lt;&lt;<i>EOF</i>&quot;</p>

<p style="margin-left:17%;">A line-oriented form of quoting
is based on the shell &quot;here-document&quot; syntax.
Following a &quot;&lt;&lt;&quot; you specify a string to
terminate the quoted material, and all lines following the
current line down to the terminating string are the value of
the item.</p>

<p style="margin-left:17%; margin-top: 1em">Prefixing the
terminating string with a &quot;~&quot; specifies that you
want to use &quot;Indented Here-docs&quot; (see below).</p>

<p style="margin-left:17%; margin-top: 1em">The terminating
string may be either an identifier (a word), or some quoted
text. An unquoted identifier works like double quotes. There
may not be a space between the &quot;&lt;&lt;&quot; and the
identifier, unless the identifier is explicitly quoted. The
terminating string must appear by itself (unquoted and with
no surrounding whitespace) on the terminating line.</p>

<p style="margin-left:17%; margin-top: 1em">If the
terminating string is quoted, the type of quotes used
determine the treatment of the text. <br>
Double Quotes</p>

<p style="margin-left:23%;">Double quotes indicate that the
text will be interpolated using exactly the same rules as
normal double quoted strings.</p>

<p style="margin-left:23%; margin-top: 1em">print
&lt;&lt;EOF; <br>
The price is $Price. <br>
EOF <br>
print &lt;&lt; &quot;EOF&quot;; # same as above <br>
The price is $Price. <br>
EOF</p>

<p style="margin-left:17%;">Single Quotes</p>

<p style="margin-left:23%;">Single quotes indicate the text
is to be treated literally with no interpolation of its
content. This is similar to single quoted strings except
that backslashes have no special meaning, with
&quot;\\&quot; being treated as two backslashes and not one
as they would in every other quoting construct.</p>

<p style="margin-left:23%; margin-top: 1em">Just as in the
shell, a backslashed bareword following the
&quot;&lt;&lt;&quot; means the same thing as a single-quoted
string does:</p>

<p style="margin-left:23%; margin-top: 1em">$cost =
&lt;&lt;'VISTA'; # hasta la ... <br>
That'll be $10 please, ma'am. <br>
VISTA <br>
$cost = &lt;&lt;\VISTA; # Same thing! <br>
That'll be $10 please, ma'am. <br>
VISTA</p>

<p style="margin-left:23%; margin-top: 1em">This is the
only form of quoting in perl where there is no need to worry
about escaping content, something that code generators can
and do make good use of.</p>

<p style="margin-left:17%;">Backticks</p>

<p style="margin-left:23%;">The content of the here doc is
treated just as it would be if the string were embedded in
backticks. Thus the content is interpolated as though it
were double quoted and then executed via the shell, with the
results of the execution returned.</p>

<p style="margin-left:23%; margin-top: 1em">print &lt;&lt;
`EOC`; # execute command and get results <br>
echo hi there <br>
EOC</p>

<p style="margin-left:17%;">Indented Here-docs</p>

<p style="margin-left:23%;">The here-doc modifier
&quot;~&quot; allows you to indent your here-docs to make
the code more readable:</p>

<p style="margin-left:23%; margin-top: 1em">if ($some_var)
{ <br>
print &lt;&lt;~EOF; <br>
This is a here&minus;doc <br>
EOF <br>
}</p>

<p style="margin-left:23%; margin-top: 1em">This will
print...</p>

<p style="margin-left:23%; margin-top: 1em">This is a
here&minus;doc</p>

<p style="margin-left:23%; margin-top: 1em">...with no
leading whitespace.</p>

<p style="margin-left:23%; margin-top: 1em">The line
containing the delimiter that marks the end of the here-doc
determines the indentation template for the whole thing.
Compilation croaks if any non-empty line inside the here-doc
does not begin with the precise indentation of the
terminating line. (An empty line consists of the single
character &quot;\n&quot;.) For example, suppose the
terminating line begins with a tab character followed by 4
space characters. Every non-empty line in the here-doc must
begin with a tab followed by 4 spaces. They are stripped
from each line, and any leading white space remaining on a
line serves as the indentation for that line. Currently,
only the <small>TAB</small> and <small>SPACE</small>
characters are treated as whitespace for this purpose. Tabs
and spaces may be mixed, but are matched exactly; tabs
remain tabs and are not expanded.</p>

<p style="margin-left:23%; margin-top: 1em">Additional
beginning whitespace (beyond what preceded the delimiter)
will be preserved:</p>

<p style="margin-left:23%; margin-top: 1em">print
&lt;&lt;~EOF; <br>
This text is not indented <br>
This text is indented with two spaces <br>
This text is indented with two tabs <br>
EOF</p>

<p style="margin-left:23%; margin-top: 1em">Finally, the
modifier may be used with all of the forms mentioned
above:</p>

<p style="margin-left:23%; margin-top: 1em">&lt;&lt;~\EOF;
<br>
&lt;&lt;~'EOF' <br>
&lt;&lt;~&quot;EOF&quot; <br>
&lt;&lt;~`EOF`</p>

<p style="margin-left:23%; margin-top: 1em">And whitespace
may be used between the &quot;~&quot; and quoted
delimiters:</p>

<p style="margin-left:23%; margin-top: 1em">&lt;&lt;~
'EOF'; # ... &quot;EOF&quot;, `EOF`</p>

<p style="margin-left:17%; margin-top: 1em">It is possible
to stack multiple here-docs in a row:</p>

<p style="margin-left:17%; margin-top: 1em">print
&lt;&lt;&quot;foo&quot;, &lt;&lt;&quot;bar&quot;; # you can
stack them <br>
I said foo. <br>
foo <br>
I said bar. <br>
bar <br>
myfunc(&lt;&lt; &quot;THIS&quot;, 23, &lt;&lt;'THAT'); <br>
Here's a line <br>
or two. <br>
THIS <br>
and here's another. <br>
THAT</p>

<p style="margin-left:17%; margin-top: 1em">Just
don&rsquo;t forget that you have to put a semicolon on the
end to finish the statement, as Perl doesn&rsquo;t know
you&rsquo;re not going to try to do this:</p>

<p style="margin-left:17%; margin-top: 1em">print
&lt;&lt;ABC <br>
179231 <br>
ABC <br>
+ 20;</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
remove the line terminator from your here-docs, use
&quot;chomp()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">chomp($string =
&lt;&lt;'END'); <br>
This is a string. <br>
END</p>

<p style="margin-left:17%; margin-top: 1em">If you want
your here-docs to be indented with the rest of the code, use
the &quot;&lt;&lt;~FOO&quot; construct described under
&quot;Indented Here-docs&quot;:</p>

<p style="margin-left:17%; margin-top: 1em">$quote =
&lt;&lt;~'FINIS'; <br>
The Road goes ever on and on, <br>
down from the door where it began. <br>
FINIS</p>

<p style="margin-left:17%; margin-top: 1em">If you use a
here-doc within a delimited construct, such as in
&quot;s///eg&quot;, the quoted material must still come on
the line following the &quot;&lt;&lt;FOO&quot; marker, which
means it may be inside the delimited construct:</p>


<p style="margin-left:17%; margin-top: 1em">s/this/&lt;&lt;E
. 'that' <br>
the other <br>
E <br>
. 'more '/eg;</p>

<p style="margin-left:17%; margin-top: 1em">It works this
way as of Perl 5.18. Historically, it was inconsistent, and
you would have to write</p>


<p style="margin-left:17%; margin-top: 1em">s/this/&lt;&lt;E
. 'that' <br>
. 'more '/eg; <br>
the other <br>
E</p>

<p style="margin-left:17%; margin-top: 1em">outside of
string evals.</p>

<p style="margin-left:17%; margin-top: 1em">Additionally,
quoting rules for the end-of-string identifier are unrelated
to Perl&rsquo;s quoting rules. &quot;q()&quot;,
&quot;qq()&quot;, and the like are not supported in place of
'' and &quot;&quot;, and the only interpolation is for
backslashing the quoting character:</p>

<p style="margin-left:17%; margin-top: 1em">print &lt;&lt;
&quot;abc\&quot;def&quot;; <br>
testing... <br>
abc&quot;def</p>

<p style="margin-left:17%; margin-top: 1em">Finally, quoted
strings cannot span multiple lines. The general rule is that
the identifier must be a string literal. Stick with that,
and you should be safe.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Gory details
of parsing quoted constructs</b> <br>
When presented with something that might have several
different interpretations, Perl uses the
<b><small>DWIM</small></b> (that&rsquo;s &quot;Do What I
Mean&quot;) principle to pick the most probable
interpretation. This strategy is so successful that Perl
programmers often do not suspect the ambivalence of what
they write. But from time to time, Perl&rsquo;s notions
differ substantially from what the author honestly
meant.</p>

<p style="margin-left:11%; margin-top: 1em">This section
hopes to clarify how Perl handles quoted constructs.
Although the most common reason to learn this is to unravel
labyrinthine regular expressions, because the initial steps
of parsing are the same for all quoting operators, they are
all discussed together.</p>

<p style="margin-left:11%; margin-top: 1em">The most
important Perl parsing rule is the first one discussed
below: when processing a quoted construct, Perl first finds
the end of that construct, then interprets its contents. If
you understand this rule, you may skip the rest of this
section on the first reading. The other rules are likely to
contradict the user&rsquo;s expectations much less
frequently than this first one.</p>

<p style="margin-left:11%; margin-top: 1em">Some passes
discussed below are performed concurrently, but because
their results are the same, we consider them individually.
For different quoting constructs, Perl performs different
numbers of passes, from one to four, but these passes are
always performed in the same order. <br>
Finding the end</p>

<p style="margin-left:17%;">The first pass is finding the
end of the quoted construct. This results in saving to a
safe location a copy of the text (between the starting and
ending delimiters), normalized as necessary to avoid needing
to know what the original delimiters were.</p>

<p style="margin-left:17%; margin-top: 1em">If the
construct is a here-doc, the ending delimiter is a line that
has a terminating string as the content. Therefore
&quot;&lt;&lt;EOF&quot; is terminated by &quot;EOF&quot;
immediately followed by &quot;\n&quot; and starting from the
first column of the terminating line. When searching for the
terminating line of a here-doc, nothing is skipped. In other
words, lines after the here-doc syntax are compared with the
terminating string line by line.</p>

<p style="margin-left:17%; margin-top: 1em">For the
constructs except here-docs, single characters are used as
starting and ending delimiters. If the starting delimiter is
an opening punctuation (that is &quot;(&quot;,
&quot;[&quot;, &quot;{&quot;, or &quot;&lt;&quot;), the
ending delimiter is the corresponding closing punctuation
(that is &quot;)&quot;, &quot;]&quot;, &quot;}&quot;, or
&quot;&gt;&quot;). If the starting delimiter is an unpaired
character like &quot;/&quot; or a closing punctuation, the
ending delimiter is the same as the starting delimiter.
Therefore a &quot;/&quot; terminates a &quot;qq//&quot;
construct, while a &quot;]&quot; terminates both
&quot;qq[]&quot; and &quot;qq]]&quot; constructs.</p>

<p style="margin-left:17%; margin-top: 1em">When searching
for single-character delimiters, escaped delimiters and
&quot;\\&quot; are skipped. For example, while searching for
terminating &quot;/&quot;, combinations of &quot;\\&quot;
and &quot;\/&quot; are skipped. If the delimiters are
bracketing, nested pairs are also skipped. For example,
while searching for a closing &quot;]&quot; paired with the
opening &quot;[&quot;, combinations of &quot;\\&quot;,
&quot;\]&quot;, and &quot;\[&quot; are all skipped, and
nested &quot;[&quot; and &quot;]&quot; are skipped as well.
However, when backslashes are used as the delimiters (like
&quot;qq\\&quot; and &quot;tr\\\&quot;), nothing is skipped.
During the search for the end, backslashes that escape
delimiters or other backslashes are removed (exactly
speaking, they are not copied to the safe location).</p>

<p style="margin-left:17%; margin-top: 1em">For constructs
with three-part delimiters (&quot;s///&quot;,
&quot;y///&quot;, and &quot;tr///&quot;), the search is
repeated once more. If the first delimiter is not an opening
punctuation, the three delimiters must be the same, such as
&quot;s!!!&quot; and &quot;tr)))&quot;, in which case the
second delimiter terminates the left part and starts the
right part at once. If the left part is delimited by
bracketing punctuation (that is &quot;()&quot;,
&quot;[]&quot;, &quot;{}&quot;, or &quot;&lt;&gt;&quot;),
the right part needs another pair of delimiters such as
&quot;s(){}&quot; and &quot;tr[]//&quot;. In these cases,
whitespace and comments are allowed between the two parts,
although the comment must follow at least one whitespace
character; otherwise a character expected as the start of
the comment may be regarded as the starting delimiter of the
right part.</p>

<p style="margin-left:17%; margin-top: 1em">During this
search no attention is paid to the semantics of the
construct. Thus:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;$hash{&quot;$foo/$bar&quot;}&quot;</p>

<p style="margin-left:17%; margin-top: 1em">or:</p>

<p style="margin-left:17%; margin-top: 1em">m/ <br>
bar # NOT a comment, this slash / terminated m//! <br>
/x</p>

<p style="margin-left:17%; margin-top: 1em">do not form
legal quoted expressions. The quoted part ends on the first
&quot;&quot;&quot; and &quot;/&quot;, and the rest happens
to be a syntax error. Because the slash that terminated
&quot;m//&quot; was followed by a &quot;SPACE&quot;, the
example above is not &quot;m//x&quot;, but rather
&quot;m//&quot; with no &quot;/x&quot; modifier. So the
embedded &quot;#&quot; is interpreted as a literal
&quot;#&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Also no
attention is paid to &quot;\c\&quot; (multichar control char
syntax) during this search. Thus the second &quot;\&quot; in
&quot;qq/\c\/&quot; is interpreted as a part of
&quot;\/&quot;, and the following &quot;/&quot; is not
recognized as a delimiter. Instead, use &quot;\034&quot; or
&quot;\x1c&quot; at the end of quoted constructs.</p>

<p style="margin-left:11%;">Interpolation</p>

<p style="margin-left:17%;">The next step is interpolation
in the text obtained, which is now delimiter-independent.
There are multiple cases. <br>
&quot;&lt;&lt;'EOF'&quot;</p>

<p style="margin-left:23%;">No interpolation is performed.
Note that the combination &quot;\\&quot; is left intact,
since escaped delimiters are not available for
here-docs.</p>

<p style="margin-left:17%;">&quot;m''&quot;, the pattern of
&quot;s'''&quot;</p>

<p style="margin-left:23%;">No interpolation is performed
at this stage. Any backslashed sequences including
&quot;\\&quot; are treated at the stage of &quot;Parsing
regular expressions&quot;.</p>

<p style="margin-left:17%;">'', &quot;q//&quot;,
&quot;tr'''&quot;, &quot;y'''&quot;, the replacement of
&quot;s'''&quot;</p>

<p style="margin-left:23%;">The only interpolation is
removal of &quot;\&quot; from pairs of &quot;\\&quot;.
Therefore &quot;&minus;&quot; in &quot;tr'''&quot; and
&quot;y'''&quot; is treated literally as a hyphen and no
character range is available. &quot;\1&quot; in the
replacement of &quot;s'''&quot; does not work as $1.</p>

<p style="margin-left:17%;">&quot;tr///&quot;,
&quot;y///&quot;</p>

<p style="margin-left:23%;">No variable interpolation
occurs. String modifying combinations for case and quoting
such as &quot;\Q&quot;, &quot;\U&quot;, and &quot;\E&quot;
are not recognized. The other escape sequences such as
&quot;\200&quot; and &quot;\t&quot; and backslashed
characters such as &quot;\\&quot; and &quot;\&minus;&quot;
are converted to appropriate literals. The character
&quot;&minus;&quot; is treated specially and therefore
&quot;\&minus;&quot; is treated as a literal
&quot;&minus;&quot;.</p>

<p style="margin-left:17%;">&quot;&quot;, &quot;``&quot;,
&quot;qq//&quot;, &quot;qx//&quot;,
&quot;&lt;file*glob&gt;&quot;,
&quot;&lt;&lt;&quot;EOF&quot;&quot;</p>

<p style="margin-left:23%;">&quot;\Q&quot;, &quot;\U&quot;,
&quot;\u&quot;, &quot;\L&quot;, &quot;\l&quot;,
&quot;\F&quot; (possibly paired with &quot;\E&quot;) are
converted to corresponding Perl constructs. Thus,
&quot;$foo\Qbaz$bar&quot; is converted to
&quot;$foo&nbsp;.&nbsp;(quotemeta(&quot;baz&quot;&nbsp;.&nbsp;$bar))&quot;
internally. The other escape sequences such as
&quot;\200&quot; and &quot;\t&quot; and backslashed
characters such as &quot;\\&quot; and &quot;\&minus;&quot;
are replaced with appropriate expansions.</p>

<p style="margin-left:23%; margin-top: 1em">Let it be
stressed that <i>whatever falls between &quot;\Q&quot; and
&quot;\E&quot;</i> is interpolated in the usual way.
Something like &quot;\Q\\E&quot; has no &quot;\E&quot;
inside. Instead, it has &quot;\Q&quot;, &quot;\\&quot;, and
&quot;E&quot;, so the result is the same as for
&quot;\\\\E&quot;. As a general rule, backslashes between
&quot;\Q&quot; and &quot;\E&quot; may lead to
counterintuitive results. So, &quot;\Q\t\E&quot; is
converted to &quot;quotemeta(&quot;\t&quot;)&quot;, which is
the same as &quot;\\\t&quot; (since <small>TAB</small> is
not alphanumeric). Note also that:</p>

<p style="margin-left:23%; margin-top: 1em">$str = '\t';
<br>
return &quot;\Q$str&quot;;</p>

<p style="margin-left:23%; margin-top: 1em">may be closer
to the conjectural <i>intention</i> of the writer of
&quot;\Q\t\E&quot;.</p>

<p style="margin-left:23%; margin-top: 1em">Interpolated
scalars and arrays are converted internally to the
&quot;join&quot; and &quot;.&quot; catenation operations.
Thus, &quot;$foo&nbsp;XXX&nbsp;'@arr'&quot; becomes:</p>

<p style="margin-left:23%; margin-top: 1em">$foo . &quot;
XXX '&quot; . (join $&quot;, @arr) . &quot;'&quot;;</p>

<p style="margin-left:23%; margin-top: 1em">All operations
above are performed simultaneously, left to right.</p>

<p style="margin-left:23%; margin-top: 1em">Because the
result of &quot;\Q&nbsp;<i>STRING&nbsp;</i>\E&quot; has all
metacharacters quoted, there is no way to insert a literal
&quot;$&quot; or &quot;@&quot; inside a &quot;\Q\E&quot;
pair. If protected by &quot;\&quot;, &quot;$&quot; will be
quoted to become &quot;\\\$&quot;; if not, it is interpreted
as the start of an interpolated scalar.</p>

<p style="margin-left:23%; margin-top: 1em">Note also that
the interpolation code needs to make a decision on where the
interpolated scalar ends. For instance, whether
&quot;a&nbsp;$x&nbsp;&minus;&gt;&nbsp;{c}&quot; really
means:</p>

<p style="margin-left:23%; margin-top: 1em">&quot;a &quot;
. $x . &quot; &minus;&gt; {c}&quot;;</p>

<p style="margin-left:23%; margin-top: 1em">or:</p>

<p style="margin-left:23%; margin-top: 1em">&quot;a &quot;
. $x &minus;&gt; {c};</p>

<p style="margin-left:23%; margin-top: 1em">Most of the
time, the longest possible text that does not include spaces
between components and which contains matching braces or
brackets. because the outcome may be determined by voting
based on heuristic estimators, the result is not strictly
predictable. Fortunately, it&rsquo;s usually correct for
ambiguous cases.</p>

<p style="margin-left:17%;">The replacement of
&quot;s///&quot;</p>

<p style="margin-left:23%;">Processing of &quot;\Q&quot;,
&quot;\U&quot;, &quot;\u&quot;, &quot;\L&quot;,
&quot;\l&quot;, &quot;\F&quot; and interpolation happens as
with &quot;qq//&quot; constructs.</p>

<p style="margin-left:23%; margin-top: 1em">It is at this
step that &quot;\1&quot; is begrudgingly converted to $1 in
the replacement text of &quot;s///&quot;, in order to
correct the incorrigible <i>sed</i> hackers who
haven&rsquo;t picked up the saner idiom yet. A warning is
emitted if the &quot;use&nbsp;warnings&quot; pragma or the
<b>&minus;w</b> command-line flag (that is, the $^W
variable) was set.</p>

<p style="margin-left:17%;">&quot;RE&quot; in
&quot;m?RE?&quot;, &quot;/RE/&quot;, &quot;m/RE/&quot;,
&quot;s/RE/foo/&quot;,</p>

<p style="margin-left:23%;">Processing of &quot;\Q&quot;,
&quot;\U&quot;, &quot;\u&quot;, &quot;\L&quot;,
&quot;\l&quot;, &quot;\F&quot;, &quot;\E&quot;, and
interpolation happens (almost) as with &quot;qq//&quot;
constructs.</p>

<p style="margin-left:23%; margin-top: 1em">Processing of
&quot;\N{...}&quot; is also done here, and compiled into an
intermediate form for the regex compiler. (This is because,
as mentioned below, the regex compilation may be done at
execution time, and &quot;\N{...}&quot; is a compile-time
construct.)</p>

<p style="margin-left:23%; margin-top: 1em">However any
other combinations of &quot;\&quot; followed by a character
are not substituted but only skipped, in order to parse them
as regular expressions at the following step. As
&quot;\c&quot; is skipped at this step, &quot;@&quot; of
&quot;\c@&quot; in <small>RE</small> is possibly treated as
an array symbol (for example @foo), even though the same
text in &quot;qq//&quot; gives interpolation of
&quot;\c@&quot;.</p>

<p style="margin-left:23%; margin-top: 1em">Code blocks
such as &quot;(?{BLOCK})&quot; are handled by temporarily
passing control back to the perl parser, in a similar way
that an interpolated array subscript expression such as
&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot; would
be.</p>

<p style="margin-left:23%; margin-top: 1em">Moreover,
inside &quot;(?{BLOCK})&quot;,
&quot;(?#&nbsp;comment&nbsp;)&quot;, and a
&quot;#&quot;&minus;comment in a
&quot;/x&quot;&minus;regular expression, no processing is
performed whatsoever. This is the first step at which the
presence of the &quot;/x&quot; modifier is relevant.</p>

<p style="margin-left:23%; margin-top: 1em">Interpolation
in patterns has several quirks: $|, $(, $), &quot;@+&quot;
and &quot;@&minus;&quot; are not interpolated, and
constructs $var[SOMETHING] are voted (by several different
estimators) to be either an array element or $var followed
by an <small>RE</small> alternative. This is where the
notation &quot;${arr[$bar]}&quot; comes handy:
&quot;/${arr[0&minus;9]}/&quot; is interpreted as array
element &quot;&minus;9&quot;, not as a regular expression
from the variable $arr followed by a digit, which would be
the interpretation of &quot;/$arr[0&minus;9]/&quot;. Since
voting among different estimators may occur, the result is
not predictable.</p>

<p style="margin-left:23%; margin-top: 1em">The lack of
processing of &quot;\\&quot; creates specific restrictions
on the post-processed text. If the delimiter is
&quot;/&quot;, one cannot get the combination &quot;\/&quot;
into the result of this step. &quot;/&quot; will finish the
regular expression, &quot;\/&quot; will be stripped to
&quot;/&quot; on the previous step, and &quot;\\/&quot; will
be left as is. Because &quot;/&quot; is equivalent to
&quot;\/&quot; inside a regular expression, this does not
matter unless the delimiter happens to be character special
to the <small>RE</small> engine, such as in
&quot;s*foo*bar*&quot;, &quot;m[foo]&quot;, or
&quot;m?foo?&quot;; or an alphanumeric char, as in:</p>

<p style="margin-left:23%; margin-top: 1em">m m ^ a \s* b
mmx;</p>

<p style="margin-left:23%; margin-top: 1em">In the
<small>RE</small> above, which is intentionally obfuscated
for illustration, the delimiter is &quot;m&quot;, the
modifier is &quot;mx&quot;, and after delimiter-removal the
<small>RE</small> is the same as for
&quot;m/&nbsp;^&nbsp;a&nbsp;\s*&nbsp;b&nbsp;/mx&quot;.
There&rsquo;s more than one reason you&rsquo;re encouraged
to restrict your delimiters to non-alphanumeric,
non-whitespace choices.</p>

<p style="margin-left:17%; margin-top: 1em">This step is
the last one for all constructs except regular expressions,
which are processed further.</p>

<p style="margin-left:11%;">Parsing regular expressions</p>

<p style="margin-left:17%;">Previous steps were performed
during the compilation of Perl code, but this one happens at
run time, although it may be optimized to be calculated at
compile time if appropriate. After preprocessing described
above, and possibly after evaluation if concatenation,
joining, casing translation, or metaquoting are involved,
the resulting <i>string</i> is passed to the
<small>RE</small> engine for compilation.</p>

<p style="margin-left:17%; margin-top: 1em">Whatever
happens in the <small>RE</small> engine might be better
discussed in perlre, but for the sake of continuity, we
shall do so here.</p>

<p style="margin-left:17%; margin-top: 1em">This is another
step where the presence of the &quot;/x&quot; modifier is
relevant. The <small>RE</small> engine scans the string from
left to right and converts it into a finite automaton.</p>

<p style="margin-left:17%; margin-top: 1em">Backslashed
characters are either replaced with corresponding literal
strings (as with &quot;\{&quot;), or else they generate
special nodes in the finite automaton (as with
&quot;\b&quot;). Characters special to the <small>RE</small>
engine (such as &quot;|&quot;) generate corresponding nodes
or groups of nodes. &quot;(?#...)&quot; comments are
ignored. All the rest is either converted to literal strings
to match, or else is ignored (as is whitespace and
&quot;#&quot;&minus;style comments if &quot;/x&quot; is
present).</p>

<p style="margin-left:17%; margin-top: 1em">Parsing of the
bracketed character class construct, &quot;[...]&quot;, is
rather different than the rule used for the rest of the
pattern. The terminator of this construct is found using the
same rules as for finding the terminator of a
&quot;{}&quot;&minus;delimited construct, the only exception
being that &quot;]&quot; immediately following &quot;[&quot;
is treated as though preceded by a backslash.</p>

<p style="margin-left:17%; margin-top: 1em">The terminator
of runtime &quot;(?{...})&quot; is found by temporarily
switching control to the perl parser, which should stop at
the point where the logically balancing terminating
&quot;}&quot; is found.</p>

<p style="margin-left:17%; margin-top: 1em">It is possible
to inspect both the string given to <small>RE</small> engine
and the resulting finite automaton. See the arguments
&quot;debug&quot;/&quot;debugcolor&quot; in the
&quot;use&nbsp;re&quot; pragma, as well as Perl&rsquo;s
<b>&minus;Dr</b> command-line switch documented in
&quot;Command Switches&quot; in perlrun.</p>

<p style="margin-left:11%;">Optimization of regular
expressions</p>

<p style="margin-left:17%;">This step is listed for
completeness only. Since it does not change semantics,
details of this step are not documented and are subject to
change without notice. This step is performed over the
finite automaton that was generated during the previous
pass.</p>

<p style="margin-left:17%; margin-top: 1em">It is at this
stage that &quot;split()&quot; silently optimizes
&quot;/^/&quot; to mean &quot;/^/m&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I/O
Operators</b> <br>
There are several I/O operators you should know about.</p>

<p style="margin-left:11%; margin-top: 1em">A string
enclosed by backticks (grave accents) first undergoes
double-quote interpolation. It is then interpreted as an
external command, and the output of that command is the
value of the backtick string, like in a shell. In scalar
context, a single string consisting of all output is
returned. In list context, a list of values is returned, one
per line of output. (You can set $/ to use a different line
terminator.) The command is executed each time the
pseudo-literal is evaluated. The status value of the command
is returned in $? (see perlvar for the interpretation of
$?). Unlike in <b>csh</b>, no translation is done on the
return data--newlines remain newlines. Unlike in any of the
shells, single quotes do not hide variable names in the
command from interpretation. To pass a literal dollar-sign
through to the shell you need to hide it with a backslash.
The generalized form of backticks is &quot;qx//&quot;, or
you can call the &quot;readpipe&quot; in perlfunc function.
(Because backticks always undergo shell expansion as well,
see perlsec for security concerns.)</p>

<p style="margin-left:11%; margin-top: 1em">In scalar
context, evaluating a filehandle in angle brackets yields
the next line from that file (the newline, if any,
included), or &quot;undef&quot; at end-of-file or on error.
When $/ is set to &quot;undef&quot; (sometimes known as
file-slurp mode) and the file is empty, it returns '' the
first time, followed by &quot;undef&quot; subsequently.</p>

<p style="margin-left:11%; margin-top: 1em">Ordinarily you
must assign the returned value to a variable, but there is
one situation where an automatic assignment happens. If and
only if the input symbol is the only thing inside the
conditional of a &quot;while&quot; statement (even if
disguised as a &quot;for(;;)&quot; loop), the value is
automatically assigned to the global variable $_, destroying
whatever was there previously. (This may seem like an odd
thing to you, but you&rsquo;ll use the construct in almost
every Perl script you write.) The $_ variable is not
implicitly localized. You&rsquo;ll have to put a
&quot;local&nbsp;$_;&quot; before the loop if you want that
to happen. Furthermore, if the input symbol or an explicit
assignment of the input symbol to a scalar is used as a
&quot;while&quot;/&quot;for&quot; condition, then the
condition actually tests for definedness of the
expression&rsquo;s value, not for its regular truth
value.</p>

<p style="margin-left:11%; margin-top: 1em">Thus the
following lines are equivalent:</p>

<p style="margin-left:11%; margin-top: 1em">while
(defined($_ = &lt;STDIN&gt;)) { print; } <br>
while ($_ = &lt;STDIN&gt;) { print; } <br>
while (&lt;STDIN&gt;) { print; } <br>
for (;&lt;STDIN&gt;;) { print; } <br>
print while defined($_ = &lt;STDIN&gt;); <br>
print while ($_ = &lt;STDIN&gt;); <br>
print while &lt;STDIN&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">This also
behaves similarly, but assigns to a lexical variable instead
of to $_:</p>

<p style="margin-left:11%; margin-top: 1em">while (my $line
= &lt;STDIN&gt;) { print $line }</p>

<p style="margin-left:11%; margin-top: 1em">In these loop
constructs, the assigned value (whether assignment is
automatic or explicit) is then tested to see whether it is
defined. The defined test avoids problems where the line has
a string value that would be treated as false by Perl; for
example a &quot;&quot; or a &quot;0&quot; with no trailing
newline. If you really mean for such values to terminate the
loop, they should be tested for explicitly:</p>

<p style="margin-left:11%; margin-top: 1em">while (($_ =
&lt;STDIN&gt;) ne '0') { ... } <br>
while (&lt;STDIN&gt;) { last unless $_; ... }</p>

<p style="margin-left:11%; margin-top: 1em">In other
boolean contexts, &quot;&lt;<i>FILEHANDLE</i>&gt;&quot;
without an explicit &quot;defined&quot; test or comparison
elicits a warning if the &quot;use&nbsp;warnings&quot;
pragma or the <b>&minus;w</b> command-line switch (the $^W
variable) is in effect.</p>

<p style="margin-left:11%; margin-top: 1em">The filehandles
<small>STDIN, STDOUT,</small> and <small>STDERR</small> are
predefined. (The filehandles &quot;stdin&quot;,
&quot;stdout&quot;, and &quot;stderr&quot; will also work
except in packages, where they would be interpreted as local
identifiers rather than global.) Additional filehandles may
be created with the &quot;open()&quot; function, amongst
others. See perlopentut and &quot;open&quot; in perlfunc for
details on this.</p>

<p style="margin-left:11%; margin-top: 1em">If a
&quot;&lt;<i>FILEHANDLE</i>&gt;&quot; is used in a context
that is looking for a list, a list comprising all input
lines is returned, one line per list element. It&rsquo;s
easy to grow to a rather large data space this way, so use
with care.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;&lt;<i>FILEHANDLE</i>&gt;&quot;
may also be spelled
&quot;readline(*<i>FILEHANDLE</i>)&quot;. See
&quot;readline&quot; in perlfunc.</p>

<p style="margin-left:11%; margin-top: 1em">The null
filehandle &quot;&lt;&gt;&quot; (sometimes called the
diamond operator) is special: it can be used to emulate the
behavior of <b>sed</b> and <b>awk</b>, and any other Unix
filter program that takes a list of filenames, doing the
same to each line of input from all of them. Input from
&quot;&lt;&gt;&quot; comes either from standard input, or
from each file listed on the command line. Here&rsquo;s how
it works: the first time &quot;&lt;&gt;&quot; is evaluated,
the @ARGV array is checked, and if it is empty, $ARGV[0] is
set to &quot;&minus;&quot;, which when opened gives you
standard input. The @ARGV array is then processed as a list
of filenames. The loop</p>

<p style="margin-left:11%; margin-top: 1em">while
(&lt;&gt;) { <br>
... # code for each line <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to the following Perl-like pseudo code:</p>

<p style="margin-left:11%; margin-top: 1em">unshift(@ARGV,
'&minus;') unless @ARGV; <br>
while ($ARGV = shift) { <br>
open(ARGV, $ARGV); <br>
while (&lt;ARGV&gt;) { <br>
... # code for each line <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">except that it
isn&rsquo;t so cumbersome to say, and will actually work. It
really does shift the @ARGV array and put the current
filename into the $ARGV variable. It also uses filehandle
<i><small>ARGV</small></i> internally. &quot;&lt;&gt;&quot;
is just a synonym for &quot;&lt;ARGV&gt;&quot;, which is
magical. (The pseudo code above doesn&rsquo;t work because
it treats &quot;&lt;ARGV&gt;&quot; as non-magical.)</p>

<p style="margin-left:11%; margin-top: 1em">Since the null
filehandle uses the two argument form of &quot;open&quot; in
perlfunc it interprets special characters, so if you have a
script like this:</p>

<p style="margin-left:11%; margin-top: 1em">while
(&lt;&gt;) { <br>
print; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">and call it
with
&quot;perl&nbsp;dangerous.pl&nbsp;'rm&nbsp;&minus;rfv&nbsp;*|'&quot;,
it actually opens a pipe, executes the &quot;rm&quot;
command and reads &quot;rm&quot;&rsquo;s output from that
pipe. If you want all items in @ARGV to be interpreted as
file names, you can use the module
&quot;ARGV::readonly&quot; from <small>CPAN,</small> or use
the double diamond bracket:</p>

<p style="margin-left:11%; margin-top: 1em">while
(&lt;&lt;&gt;&gt;) { <br>
print; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Using double
angle brackets inside of a while causes the open to use the
three argument form (with the second argument being
&quot;&lt;&quot;), so all arguments in &quot;ARGV&quot; are
treated as literal filenames (including
&quot;&minus;&quot;). (Note that for convenience, if you use
&quot;&lt;&lt;&gt;&gt;&quot; and if @ARGV is empty, it will
still read from the standard input.)</p>

<p style="margin-left:11%; margin-top: 1em">You can modify
@ARGV before the first &quot;&lt;&gt;&quot; as long as the
array ends up containing the list of filenames you really
want. Line numbers ($.) continue as though the input were
one big happy file. See the example in &quot;eof&quot; in
perlfunc for how to reset line numbers on each file.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
set @ARGV to your own list of files, go right ahead. This
sets @ARGV to all plain text files if no @ARGV was
given:</p>

<p style="margin-left:11%; margin-top: 1em">@ARGV = grep {
&minus;f &amp;&amp; &minus;T } glob('*') unless @ARGV;</p>

<p style="margin-left:11%; margin-top: 1em">You can even
set them to pipe commands. For example, this automatically
filters compressed arguments through <b>gzip</b>:</p>

<p style="margin-left:11%; margin-top: 1em">@ARGV = map {
/\.(gz|Z)$/ ? &quot;gzip &minus;dc &lt; $_ |&quot; : $_ }
@ARGV;</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
pass switches into your script, you can use one of the
&quot;Getopts&quot; modules or put a loop on the front like
this:</p>

<p style="margin-left:11%; margin-top: 1em">while ($_ =
$ARGV[0], /^&minus;/) { <br>
shift; <br>
last if /^&minus;&minus;$/; <br>
if (/^&minus;D(.*)/) { $debug = $1 } <br>
if (/^&minus;v/) { $verbose++ } <br>
# ... # other switches <br>
} <br>
while (&lt;&gt;) { <br>
# ... # code for each line <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;&lt;&gt;&quot; symbol will return &quot;undef&quot;
for end-of-file only once. If you call it again after this,
it will assume you are processing another @ARGV list, and if
you haven&rsquo;t set @ARGV, will read input from
<small>STDIN.</small></p>

<p style="margin-left:11%; margin-top: 1em">If what the
angle brackets contain is a simple scalar variable (for
example, $foo), then that variable contains the name of the
filehandle to input from, or its typeglob, or a reference to
the same. For example:</p>

<p style="margin-left:11%; margin-top: 1em">$fh = \*STDIN;
<br>
$line = &lt;$fh&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">If what&rsquo;s
within the angle brackets is neither a filehandle nor a
simple scalar variable containing a filehandle name,
typeglob, or typeglob reference, it is interpreted as a
filename pattern to be globbed, and either a list of
filenames or the next filename in the list is returned,
depending on context. This distinction is determined on
syntactic grounds alone. That means &quot;&lt;$x&gt;&quot;
is always a &quot;readline()&quot; from an indirect handle,
but &quot;&lt;$hash{key}&gt;&quot; is always a
&quot;glob()&quot;. That&rsquo;s because $x is a simple
scalar variable, but $hash{key} is not--it&rsquo;s a hash
element. Even &quot;&lt;$x &gt;&quot; (note the extra space)
is treated as &quot;glob(&quot;$x &quot;)&quot;, not
&quot;readline($x)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">One level of
double-quote interpretation is done first, but you
can&rsquo;t say &quot;&lt;$foo&gt;&quot; because
that&rsquo;s an indirect filehandle as explained in the
previous paragraph. (In older versions of Perl, programmers
would insert curly brackets to force interpretation as a
filename glob: &quot;&lt;${foo}&gt;&quot;. These days,
it&rsquo;s considered cleaner to call the internal function
directly as &quot;glob($foo)&quot;, which is probably the
right way to have done it in the first place.) For
example:</p>

<p style="margin-left:11%; margin-top: 1em">while
(&lt;*.c&gt;) { <br>
chmod 0644, $_; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">is roughly
equivalent to:</p>

<p style="margin-left:11%; margin-top: 1em">open(FOO,
&quot;echo *.c | tr &minus;s ' \t\r\f'
'\\012\\012\\012\\012'|&quot;); <br>
while (&lt;FOO&gt;) { <br>
chomp; <br>
chmod 0644, $_; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">except that the
globbing is actually done internally using the standard
&quot;File::Glob&quot; extension. Of course, the shortest
way to do the above is:</p>

<p style="margin-left:11%; margin-top: 1em">chmod 0644,
&lt;*.c&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">A (file)glob
evaluates its (embedded) argument only when it is starting a
new list. All values must be read before it will start over.
In list context, this isn&rsquo;t important because you
automatically get them all anyway. However, in scalar
context the operator returns the next value each time
it&rsquo;s called, or &quot;undef&quot; when the list has
run out. As with filehandle reads, an automatic
&quot;defined&quot; is generated when the glob occurs in the
test part of a &quot;while&quot;, because legal glob returns
(for example, a file called <i>0</i>) would otherwise
terminate the loop. Again, &quot;undef&quot; is returned
only once. So if you&rsquo;re expecting a single value from
a glob, it is much better to say</p>

<p style="margin-left:11%; margin-top: 1em">($file) =
&lt;blurch*&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">than</p>

<p style="margin-left:11%; margin-top: 1em">$file =
&lt;blurch*&gt;;</p>

<p style="margin-left:11%; margin-top: 1em">because the
latter will alternate between returning a filename and
returning false.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
trying to do variable interpolation, it&rsquo;s definitely
better to use the &quot;glob()&quot; function, because the
older notation can cause people to become confused with the
indirect filehandle notation.</p>

<p style="margin-left:11%; margin-top: 1em">@files =
glob(&quot;$dir/*.[ch]&quot;); <br>
@files = glob($files[$i]);</p>

<p style="margin-left:11%; margin-top: 1em">If an
angle-bracket-based globbing expression is used as the
condition of a &quot;while&quot; or &quot;for&quot; loop,
then it will be implicitly assigned to $_. If either a
globbing expression or an explicit assignment of a globbing
expression to a scalar is used as a
&quot;while&quot;/&quot;for&quot; condition, then the
condition actually tests for definedness of the
expression&rsquo;s value, not for its regular truth
value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Constant
Folding</b> <br>
Like C, Perl does a certain amount of expression evaluation
at compile time whenever it determines that all arguments to
an operator are static and have no side effects. In
particular, string concatenation happens at compile time
between literals that don&rsquo;t do variable substitution.
Backslash interpolation also happens at compile time. You
can say</p>

<p style="margin-left:11%; margin-top: 1em">'Now is the
time for all' <br>
. &quot;\n&quot; <br>
. 'good men to come to.'</p>

<p style="margin-left:11%; margin-top: 1em">and this all
reduces to one string internally. Likewise, if you say</p>

<p style="margin-left:11%; margin-top: 1em">foreach $file
(@filenames) { <br>
if (&minus;s $file &gt; 5 + 100 * 2**16) { } <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">the compiler
precomputes the number which that expression represents so
that the interpreter won&rsquo;t have to.</p>

<p style="margin-left:11%; margin-top: 1em"><b>No-ops</b>
<br>
Perl doesn&rsquo;t officially have a no-op operator, but the
bare constants 0 and 1 are special-cased not to produce a
warning in void context, so you can for example safely
do</p>

<p style="margin-left:11%; margin-top: 1em">1 while
foo();</p>

<p style="margin-left:11%; margin-top: 1em"><b>Bitwise
String Operators</b> <br>
Bitstrings of any size may be manipulated by the bitwise
operators (&quot;~ | &amp; ^&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">If the operands
to a binary bitwise op are strings of different sizes,
<b>|</b> and <b>^</b> ops act as though the shorter operand
had additional zero bits on the right, while the
<b>&amp;</b> op acts as though the longer operand were
truncated to the length of the shorter. The granularity for
such extension or truncation is one or more bytes.</p>

<p style="margin-left:11%; margin-top: 1em">#
ASCII&minus;based examples <br>
print &quot;j p \n&quot; ^ &quot; a h&quot;; # prints
&quot;JAPH\n&quot; <br>
print &quot;JA&quot; | &quot; ph\n&quot;; # prints
&quot;japh\n&quot; <br>
print &quot;japh\nJunk&quot; &amp; '_____'; # prints
&quot;JAPH\n&quot;; <br>
print 'p N$' ^ &quot; E&lt;H\n&quot;; # prints
&quot;Perl\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If you are
intending to manipulate bitstrings, be certain that
you&rsquo;re supplying bitstrings: If an operand is a
number, that will imply a <b>numeric</b> bitwise operation.
You may explicitly show which type of operation you intend
by using &quot;&quot; or &quot;0+&quot;, as in the examples
below.</p>

<p style="margin-left:11%; margin-top: 1em">$foo = 150 |
105; # yields 255 (0x96 | 0x69 is 0xFF) <br>
$foo = '150' | 105; # yields 255 <br>
$foo = 150 | '105'; # yields 255 <br>
$foo = '150' | '105'; # yields string '155' (under ASCII)
<br>
$baz = 0+$foo &amp; 0+$bar; # both ops explicitly numeric
<br>
$biz = &quot;$foo&quot; ^ &quot;$bar&quot;; # both ops
explicitly stringy</p>

<p style="margin-left:11%; margin-top: 1em">This somewhat
unpredictable behavior can be avoided with the
&quot;bitwise&quot; feature, new in Perl 5.22. You can
enable it via &quot;use&nbsp;feature&nbsp;'bitwise'&quot; or
&quot;use v5.28&quot;. Before Perl 5.28, it used to emit a
warning in the &quot;experimental::bitwise&quot; category.
Under this feature, the four standard bitwise operators
(&quot;~ | &amp; ^&quot;) are always numeric. Adding a dot
after each operator (&quot;~. |. &amp;. ^.&quot;) forces it
to treat its operands as strings:</p>

<p style="margin-left:11%; margin-top: 1em">use feature
&quot;bitwise&quot;; <br>
$foo = 150 | 105; # yields 255 (0x96 | 0x69 is 0xFF) <br>
$foo = '150' | 105; # yields 255 <br>
$foo = 150 | '105'; # yields 255 <br>
$foo = '150' | '105'; # yields 255 <br>
$foo = 150 |. 105; # yields string '155' <br>
$foo = '150' |. 105; # yields string '155' <br>
$foo = 150 |.'105'; # yields string '155' <br>
$foo = '150' |.'105'; # yields string '155' <br>
$baz = $foo &amp; $bar; # both operands numeric <br>
$biz = $foo ^. $bar; # both operands stringy</p>

<p style="margin-left:11%; margin-top: 1em">The assignment
variants of these operators (&quot;&amp;= |= ^= &amp;.= |.=
^.=&quot;) behave likewise under the feature.</p>

<p style="margin-left:11%; margin-top: 1em">It is a fatal
error if an operand contains a character whose ordinal value
is above 0xFF, and hence not expressible except in
<small>UTF&minus;8.</small> The operation is performed on a
non&minus;UTF&minus;8 copy for other operands encoded in
<small>UTF&minus;8.</small> See &quot;Byte and Character
Semantics&quot; in perlunicode.</p>

<p style="margin-left:11%; margin-top: 1em">See
&quot;vec&quot; in perlfunc for information on how to
manipulate individual bits in a bit vector.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Integer
Arithmetic</b> <br>
By default, Perl assumes that it must do most of its
arithmetic in floating point. But by saying</p>

<p style="margin-left:11%; margin-top: 1em">use
integer;</p>

<p style="margin-left:11%; margin-top: 1em">you may tell
the compiler to use integer operations (see integer for a
detailed explanation) from here to the end of the enclosing
<small>BLOCK.</small> An inner <small>BLOCK</small> may
countermand this by saying</p>

<p style="margin-left:11%; margin-top: 1em">no integer;</p>

<p style="margin-left:11%; margin-top: 1em">which lasts
until the end of that <small>BLOCK.</small> Note that this
doesn&rsquo;t mean everything is an integer, merely that
Perl will use integer operations for arithmetic, comparison,
and bitwise operators. For example, even under
&quot;use&nbsp;integer&quot;, if you take the sqrt(2),
you&rsquo;ll still get 1.4142135623731 or so.</p>

<p style="margin-left:11%; margin-top: 1em">Used on
numbers, the bitwise operators (&quot;&amp;&quot;
&quot;|&quot; &quot;^&quot; &quot;~&quot;
&quot;&lt;&lt;&quot; &quot;&gt;&gt;&quot;) always produce
integral results. (But see also &quot;Bitwise String
Operators&quot;.) However, &quot;use&nbsp;integer&quot;
still has meaning for them. By default, their results are
interpreted as unsigned integers, but if
&quot;use&nbsp;integer&quot; is in effect, their results are
interpreted as signed integers. For example, &quot;~0&quot;
usually evaluates to a large integral value. However,
&quot;use&nbsp;integer;&nbsp;~0&quot; is
&quot;&minus;1&quot; on two&rsquo;s-complement machines.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Floating-point
Arithmetic</b> <br>
While &quot;use&nbsp;integer&quot; provides integer-only
arithmetic, there is no analogous mechanism to provide
automatic rounding or truncation to a certain number of
decimal places. For rounding to a certain number of digits,
&quot;sprintf()&quot; or &quot;printf()&quot; is usually the
easiest route. See perlfaq4.</p>

<p style="margin-left:11%; margin-top: 1em">Floating-point
numbers are only approximations to what a mathematician
would call real numbers. There are infinitely more reals
than floats, so some corners must be cut. For example:</p>

<p style="margin-left:11%; margin-top: 1em">printf
&quot;%.20g\n&quot;, 123456789123456789; <br>
# produces 123456789123456784</p>

<p style="margin-left:11%; margin-top: 1em">Testing for
exact floating-point equality or inequality is not a good
idea. Here&rsquo;s a (relatively expensive) work-around to
compare whether two floating-point numbers are equal to a
particular number of decimal places. See Knuth, volume
<small>II,</small> for a more robust treatment of this
topic.</p>

<p style="margin-left:11%; margin-top: 1em">sub fp_equal {
<br>
my ($X, $Y, $POINTS) = @_; <br>
my ($tX, $tY); <br>
$tX = sprintf(&quot;%.${POINTS}g&quot;, $X); <br>
$tY = sprintf(&quot;%.${POINTS}g&quot;, $Y); <br>
return $tX eq $tY; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>POSIX</small> module (part of the standard perl
distribution) implements &quot;ceil()&quot;,
&quot;floor()&quot;, and other mathematical and
trigonometric functions. The &quot;Math::Complex&quot;
module (part of the standard perl distribution) defines
mathematical functions that work on both the reals and the
imaginary numbers. &quot;Math::Complex&quot; is not as
efficient as <small>POSIX,</small> but <small>POSIX</small>
can&rsquo;t work with complex numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Rounding in
financial applications can have serious implications, and
the rounding method used should be specified precisely. In
these cases, it probably pays not to trust whichever system
rounding is being used by Perl, but to instead implement the
rounding function you need yourself.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Bigger
Numbers</b> <br>
The standard &quot;Math::BigInt&quot;,
&quot;Math::BigRat&quot;, and &quot;Math::BigFloat&quot;
modules, along with the &quot;bignum&quot;,
&quot;bigint&quot;, and &quot;bigrat&quot; pragmas, provide
variable-precision arithmetic and overloaded operators,
although they&rsquo;re currently pretty slow. At the cost of
some space and considerable speed, they avoid the normal
pitfalls associated with limited-precision
representations.</p>

<p style="margin-left:11%; margin-top: 1em">use 5.010; <br>
use bigint; # easy interface to Math::BigInt <br>
$x = 123456789123456789; <br>
say $x * $x; <br>
+15241578780673678515622620750190521</p>

<p style="margin-left:11%; margin-top: 1em">Or with
rationals:</p>

<p style="margin-left:11%; margin-top: 1em">use 5.010; <br>
use bigrat; <br>
$x = 3/22; <br>
$y = 4/6; <br>
say &quot;x/y is &quot;, $x/$y; <br>
say &quot;x*y is &quot;, $x*$y; <br>
x/y is 9/44 <br>
x*y is 1/11</p>

<p style="margin-left:11%; margin-top: 1em">Several modules
let you calculate with unlimited or fixed precision (bound
only by memory and <small>CPU</small> time). There are also
some non-standard modules that provide faster
implementations via external C libraries.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
short, but incomplete summary:</p>

<p style="margin-left:11%; margin-top: 1em">Math::String
treat string sequences like numbers <br>
Math::FixedPrecision calculate with a fixed precision <br>
Math::Currency for currency calculations <br>
Bit::Vector manipulate bit vectors fast (uses C) <br>
Math::BigIntFast Bit::Vector wrapper for big numbers <br>
Math::Pari provides access to the Pari C library <br>
Math::Cephes uses the external Cephes C library (no <br>
big numbers) <br>
Math::Cephes::Fraction fractions via the Cephes library <br>
Math::GMP another one using an external C library <br>
Math::GMPz an alternative interface to libgmp's big ints
<br>
Math::GMPq an interface to libgmp's fraction numbers <br>
Math::GMPf an interface to libgmp's floating point
numbers</p>

<p style="margin-left:11%; margin-top: 1em">Choose
wisely.</p>
<hr>
</body>
</html>
