<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:53 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GITPROTOCOL&minus;V2</title>

</head>
<body>
<h1>gitprotocol-v2</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">gitprotocol-v2
&minus; Git Wire Protocol, Version 2</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&lt;over&minus;the&minus;wire&minus;protocol&gt;</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
presents a specification for a version 2 of Git&rsquo;s wire
protocol. Protocol v2 will improve upon v1 in the following
ways:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Instead
of multiple service names, multiple commands will be
supported by a single service</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Easily
extendable as capabilities are moved into their own section
of the protocol, no longer being hidden behind a NUL byte
and limited by the size of a pkt&minus;line</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Separate
out other information hidden behind NUL bytes (e.g. agent
string as a capability and symrefs can be requested using
<i>ls&minus;refs</i>)</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
Reference advertisement will be omitted unless explicitly
requested</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
ls&minus;refs command to explicitly request some refs</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Designed
with http and stateless&minus;rpc in mind. With clear flush
semantics the http remote helper can simply act as a
proxy</p>

<p style="margin-left:11%; margin-top: 1em">In protocol v2
communication is command oriented. When first contacting a
server a list of capabilities will advertised. Some of these
capabilities will be commands which a client can request be
executed. Once a command has completed, a client can reuse
the connection and request that other commands be
executed.</p>

<h2>PACKET&minus;LINE FRAMING
<a name="PACKET&minus;LINE FRAMING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All
communication is done using packet&minus;line framing, just
as in v1. See <b>gitprotocol-pack</b>(5) and
<b>gitprotocol-common</b>(5) for more information.</p>

<p style="margin-left:11%; margin-top: 1em">In protocol v2
these special packets will have the following semantics:</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>0000</i> Flush Packet (flush&minus;pkt) &minus; indicates
the end of a message</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>0001</i> Delimiter Packet (delim&minus;pkt) &minus;
separates sections of a message</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<i>0002</i> Response End Packet
(response&minus;end&minus;pkt) &minus; indicates the end of
a response for stateless connections</p>

<h2>INITIAL CLIENT REQUEST
<a name="INITIAL CLIENT REQUEST"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In general a
client can request to speak protocol v2 by sending
<b>version=2</b> through the respective side&minus;channel
for the transport being used which inevitably sets
<b>GIT_PROTOCOL</b>. More information can be found in
<b>gitprotocol-pack</b>(5) and <b>gitprotocol-http</b>(5),
as well as the <b>GIT_PROTOCOL</b> definition in
<b>git.txt</b>. In all cases the response from the server is
the capability advertisement.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Git
Transport</b> <br>
When using the git:// transport, you can request to use
protocol v2 by sending &quot;version=2&quot; as an extra
parameter:</p>


<p style="margin-left:17%; margin-top: 1em">003egit&minus;upload&minus;pack
/project.git\0host=myserver.com\0\0version=2\0</p>

<p style="margin-left:11%; margin-top: 1em"><b>SSH and File
Transport</b> <br>
When using either the ssh:// or file:// transport, the
GIT_PROTOCOL environment variable must be set explicitly to
include &quot;version=2&quot;. The server may need to be
configured to allow this environment variable to pass.</p>

<p style="margin-left:11%; margin-top: 1em"><b>HTTP
Transport</b> <br>
When using the http:// or https:// transport a client makes
a &quot;smart&quot; info/refs request as described in
<b>gitprotocol-http</b>(5) and requests that v2 be used by
supplying &quot;version=2&quot; in the
<b>Git&minus;Protocol</b> header.</p>

<p style="margin-left:17%; margin-top: 1em">C: GET
$GIT_URL/info/refs?service=git&minus;upload&minus;pack
HTTP/1.0 <br>
C: Git&minus;Protocol: version=2</p>

<p style="margin-left:11%; margin-top: 1em">A v2 server
would reply:</p>

<p style="margin-left:17%; margin-top: 1em">S: 200 OK <br>
S: &lt;Some headers&gt; <br>
S: ... <br>
S: <br>
S: 000eversion 2\n <br>
S: &lt;capability&minus;advertisement&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Subsequent
requests are then made directly to the service
<b>$GIT_URL/git&minus;upload&minus;pack</b>. (This works the
same for git&minus;receive&minus;pack).</p>

<p style="margin-left:11%; margin-top: 1em">Uses the
<b>&minus;&minus;http&minus;backend&minus;info&minus;refs</b>
option to <b>git-upload-pack</b>(1).</p>

<p style="margin-left:11%; margin-top: 1em">The server may
need to be configured to pass this header&rsquo;s contents
via the <b>GIT_PROTOCOL</b> variable. See the discussion in
<b>git&minus;http&minus;backend.txt</b>.</p>

<h2>CAPABILITY ADVERTISEMENT
<a name="CAPABILITY ADVERTISEMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A server which
decides to communicate (based on a request from a client)
using protocol version 2, notifies the client by sending a
version string in its initial response followed by an
advertisement of its capabilities. Each capability is a key
with an optional value. Clients must ignore all unknown
keys. Semantics of unknown values are left to the definition
of each key. Some capabilities will describe commands which
can be requested to be executed by the client.</p>


<p style="margin-left:17%; margin-top: 1em">capability&minus;advertisement
= protocol&minus;version <br>
capability&minus;list <br>
flush&minus;pkt</p>


<p style="margin-left:17%; margin-top: 1em">protocol&minus;version
= PKT&minus;LINE(&quot;version 2&quot; LF) <br>
capability&minus;list = *capability <br>
capability = PKT&minus;LINE(key[=value] LF)</p>

<p style="margin-left:17%; margin-top: 1em">key = 1*(ALPHA
| DIGIT | &quot;&minus;_&quot;) <br>
value = 1*(ALPHA | DIGIT | &quot;
&minus;_.,?\/{}[]()&lt;&gt;!@#$%^&amp;*+=:;&quot;)</p>

<h2>COMMAND REQUEST
<a name="COMMAND REQUEST"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">After receiving
the capability advertisement, a client can then issue a
request to select the command it wants with any particular
capabilities or arguments. There is then an optional section
where the client can provide any command specific parameters
or queries. Only a single command can be requested at a
time.</p>

<p style="margin-left:17%; margin-top: 1em">request =
empty&minus;request | command&minus;request <br>
empty&minus;request = flush&minus;pkt <br>
command&minus;request = command <br>
capability&minus;list <br>
delim&minus;pkt <br>
command&minus;args <br>
flush&minus;pkt <br>
command = PKT&minus;LINE(&quot;command=&quot; key LF) <br>
command&minus;args = *command&minus;specific&minus;arg</p>


<p style="margin-left:17%; margin-top: 1em">command&minus;specific&minus;args
are packet line framed arguments defined by <br>
each individual command.</p>

<p style="margin-left:11%; margin-top: 1em">The server will
then check to ensure that the client&rsquo;s request is
comprised of a valid command as well as valid capabilities
which were advertised. If the request is valid the server
will then execute the command. A server MUST wait till it
has received the client&rsquo;s entire request before
issuing a response. The format of the response is determined
by the command being executed, but in all cases a
flush&minus;pkt indicates the end of the response.</p>

<p style="margin-left:11%; margin-top: 1em">When a command
has finished, and the client has received the entire
response from the server, a client can either request that
another command be executed or can terminate the connection.
A client may optionally send an empty request consisting of
just a flush&minus;pkt to indicate that no more requests
will be made.</p>

<h2>CAPABILITIES
<a name="CAPABILITIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are two
different types of capabilities: normal capabilities, which
can be used to convey information or alter the behavior of a
request, and commands, which are the core actions that a
client wants to perform (fetch, push, etc).</p>

<p style="margin-left:11%; margin-top: 1em">Protocol
version 2 is stateless by default. This means that all
commands must only last a single round and be stateless from
the perspective of the server side, unless the client has
requested a capability indicating that state should be
maintained by the server. Clients MUST NOT require state
management on the server side in order to function
correctly. This permits simple round&minus;robin
load&minus;balancing on the server side, without needing to
worry about state management.</p>

<p style="margin-left:11%; margin-top: 1em"><b>agent</b>
<br>
The server can advertise the <b>agent</b> capability with a
value <b>X</b> (in the form <b>agent=X</b>) to notify the
client that the server is running version <b>X</b>. The
client may optionally send its own agent string by including
the <b>agent</b> capability with a value <b>Y</b> (in the
form <b>agent=Y</b>) in its request to the server (but it
MUST NOT do so if the server did not advertise the agent
capability). The <b>X</b> and <b>Y</b> strings may contain
any printable ASCII characters except space (i.e., the byte
range 32 &lt; x &lt; 127), and are typically of the form
&quot;package/version&quot; (e.g., &quot;git/1.8.3.1&quot;).
The agent strings are purely informative for statistics and
debugging purposes, and MUST NOT be used to programmatically
assume the presence or absence of particular features.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ls&minus;refs
<br>
ls&minus;refs</b> is the command used to request a reference
advertisement in v2. Unlike the current reference
advertisement, ls&minus;refs takes in arguments which can be
used to limit the refs sent from the server.</p>

<p style="margin-left:11%; margin-top: 1em">Additional
features not supported in the base command will be
advertised as the value of the command in the capability
advertisement in the form of a space separated list of
features: &quot;&lt;command&gt;=&lt;feature 1&gt;
&lt;feature 2&gt;&quot;</p>

<p style="margin-left:11%; margin-top: 1em">ls&minus;refs
takes in the following arguments:</p>

<p style="margin-left:17%; margin-top: 1em">symrefs <br>
In addition to the object pointed by it, show the underlying
ref <br>
pointed by it when showing a symbolic ref. <br>
peel <br>
Show peeled tags. <br>
ref&minus;prefix &lt;prefix&gt; <br>
When specified, only references having a prefix matching one
of <br>
the provided prefixes are displayed. Multiple instances may
be <br>
given, in which case references matching any prefix will be
<br>
shown. Note that this is purely for optimization; a server
MAY <br>
show refs not matching the prefix if it chooses, and clients
<br>
should filter the result themselves.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>unborn</i> feature is advertised the following argument
can be included in the client&rsquo;s request.</p>

<p style="margin-left:17%; margin-top: 1em">unborn <br>
The server will send information about HEAD even if it is a
symref <br>
pointing to an unborn branch in the form &quot;unborn HEAD
<br>
symref&minus;target:&lt;target&gt;&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The output of
ls&minus;refs is as follows:</p>

<p style="margin-left:17%; margin-top: 1em">output = *ref
<br>
flush&minus;pkt <br>
obj&minus;id&minus;or&minus;unborn = (obj&minus;id |
&quot;unborn&quot;) <br>
ref = PKT&minus;LINE(obj&minus;id&minus;or&minus;unborn SP
refname *(SP ref&minus;attribute) LF) <br>
ref&minus;attribute = (symref | peeled) <br>
symref = &quot;symref&minus;target:&quot;
symref&minus;target <br>
peeled = &quot;peeled:&quot; obj&minus;id</p>

<p style="margin-left:11%; margin-top: 1em"><b>fetch <br>
fetch</b> is the command used to fetch a packfile in v2. It
can be looked at as a modified version of the v1 fetch where
the ref&minus;advertisement is stripped out (since the
<b>ls&minus;refs</b> command fills that role) and the
message format is tweaked to eliminate redundancies and
permit easy addition of future extensions.</p>

<p style="margin-left:11%; margin-top: 1em">Additional
features not supported in the base command will be
advertised as the value of the command in the capability
advertisement in the form of a space separated list of
features: &quot;&lt;command&gt;=&lt;feature 1&gt;
&lt;feature 2&gt;&quot;</p>

<p style="margin-left:11%; margin-top: 1em">A <b>fetch</b>
request can take the following arguments:</p>

<p style="margin-left:17%; margin-top: 1em">want
&lt;oid&gt; <br>
Indicates to the server an object which the client wants to
<br>
retrieve. Wants can be anything and are not limited to <br>
advertised objects.</p>

<p style="margin-left:17%; margin-top: 1em">have
&lt;oid&gt; <br>
Indicates to the server an object which the client has
locally. <br>
This allows the server to make a packfile which only
contains <br>
the objects that the client needs. Multiple 'have' lines can
be <br>
supplied.</p>

<p style="margin-left:17%; margin-top: 1em">done <br>
Indicates to the server that negotiation should terminate
(or <br>
not even begin if performing a clone) and that the server
should <br>
use the information supplied in the request to construct the
<br>
packfile.</p>


<p style="margin-left:17%; margin-top: 1em">thin&minus;pack
<br>
Request that a thin pack be sent, which is a pack with
deltas <br>
which reference base objects not contained within the pack
(but <br>
are known to exist at the receiving end). This can reduce
the <br>
network traffic significantly, but it requires the receiving
end <br>
to know how to &quot;thicken&quot; these packs by adding the
missing bases <br>
to the pack.</p>


<p style="margin-left:17%; margin-top: 1em">no&minus;progress
<br>
Request that progress information that would normally be
sent on <br>
side&minus;band channel 2, during the packfile transfer,
should not be <br>
sent. However, the side&minus;band channel 3 is still used
for error <br>
responses.</p>


<p style="margin-left:17%; margin-top: 1em">include&minus;tag
<br>
Request that annotated tags should be sent if the objects
they <br>
point to are being sent.</p>


<p style="margin-left:17%; margin-top: 1em">ofs&minus;delta
<br>
Indicate that the client understands PACKv2 with delta
referring <br>
to its base by position in pack rather than by an oid. That
is, <br>
they can read OBJ_OFS_DELTA (aka type 6) in a packfile.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>shallow</i> feature is advertised the following arguments
can be included in the clients request as well as the
potential addition of the <i>shallow&minus;info</i> section
in the server&rsquo;s response as explained below.</p>

<p style="margin-left:17%; margin-top: 1em">shallow
&lt;oid&gt; <br>
A client must notify the server of all commits for which it
only <br>
has shallow copies (meaning that it doesn't have the parents
of <br>
a commit) by supplying a 'shallow &lt;oid&gt;' line for each
such <br>
object so that the server is aware of the limitations of the
<br>
client's history. This is so that the server is aware that
the <br>
client may not have all objects reachable from such
commits.</p>

<p style="margin-left:17%; margin-top: 1em">deepen
&lt;depth&gt; <br>
Requests that the fetch/clone should be shallow having a
commit <br>
depth of &lt;depth&gt; relative to the remote side.</p>


<p style="margin-left:17%; margin-top: 1em">deepen&minus;relative
<br>
Requests that the semantics of the &quot;deepen&quot;
command be changed <br>
to indicate that the depth requested is relative to the
client's <br>
current shallow boundary, instead of relative to the
requested <br>
commits.</p>


<p style="margin-left:17%; margin-top: 1em">deepen&minus;since
&lt;timestamp&gt; <br>
Requests that the shallow clone/fetch should be cut at a
<br>
specific time, instead of depth. Internally it's equivalent
to <br>
doing &quot;git rev&minus;list
&minus;&minus;max&minus;age=&lt;timestamp&gt;&quot;. Cannot
be used with <br>
&quot;deepen&quot;.</p>


<p style="margin-left:17%; margin-top: 1em">deepen&minus;not
&lt;rev&gt; <br>
Requests that the shallow clone/fetch should be cut at a
<br>
specific revision specified by '&lt;rev&gt;', instead of a
depth. <br>
Internally it's equivalent of doing &quot;git rev&minus;list
&minus;&minus;not &lt;rev&gt;&quot;. <br>
Cannot be used with &quot;deepen&quot;, but can be used with
<br>
&quot;deepen&minus;since&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>filter</i> feature is advertised, the following argument
can be included in the client&rsquo;s request:</p>

<p style="margin-left:17%; margin-top: 1em">filter
&lt;filter&minus;spec&gt; <br>
Request that various objects from the packfile be omitted
<br>
using one of several filtering techniques. These are
intended <br>
for use with partial clone and partial fetch operations. See
<br>
&lsquo;rev&minus;list&lsquo; for possible
&quot;filter&minus;spec&quot; values. When communicating
<br>
with other processes, senders SHOULD translate scaled
integers <br>
(e.g. &quot;1k&quot;) into a fully&minus;expanded form (e.g.
&quot;1024&quot;) to aid <br>
interoperability with older receivers that may not
understand <br>
newly&minus;invented scaling suffixes. However, receivers
SHOULD <br>
accept the following suffixes: 'k', 'm', and 'g' for 1024,
<br>
1048576, and 1073741824, respectively.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>ref&minus;in&minus;want</i> feature is advertised, the
following argument can be included in the client&rsquo;s
request as well as the potential addition of the
<i>wanted&minus;refs</i> section in the server&rsquo;s
response as explained below.</p>

<p style="margin-left:17%; margin-top: 1em">want&minus;ref
&lt;ref&gt; <br>
Indicates to the server that the client wants to retrieve a
<br>
particular ref, where &lt;ref&gt; is the full name of a ref
on the <br>
server.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>sideband&minus;all</i> feature is advertised, the
following argument can be included in the client&rsquo;s
request:</p>


<p style="margin-left:17%; margin-top: 1em">sideband&minus;all
<br>
Instruct the server to send the whole response multiplexed,
not just <br>
the packfile section. All non&minus;flush and
non&minus;delim PKT&minus;LINE in the <br>
response (not only in the packfile section) will then start
with a byte <br>
indicating its sideband (1, 2, or 3), and the server may
send &quot;0005\2&quot; <br>
(a PKT&minus;LINE of sideband 2 with no payload) as a
keepalive packet.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>packfile&minus;uris</i> feature is advertised, the
following argument can be included in the client&rsquo;s
request as well as the potential addition of the
<i>packfile&minus;uris</i> section in the server&rsquo;s
response as explained below.</p>


<p style="margin-left:17%; margin-top: 1em">packfile&minus;uris
&lt;comma&minus;separated list of protocols&gt; <br>
Indicates to the server that the client is willing to
receive <br>
URIs of any of the given protocols in place of objects in
the <br>
sent packfile. Before performing the connectivity check, the
<br>
client should download from all given URIs. Currently, the
<br>
protocols supported are &quot;http&quot; and
&quot;https&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>wait&minus;for&minus;done</i> feature is advertised, the
following argument can be included in the client&rsquo;s
request.</p>


<p style="margin-left:17%; margin-top: 1em">wait&minus;for&minus;done
<br>
Indicates to the server that it should never send
&quot;ready&quot;, but <br>
should wait for the client to say &quot;done&quot; before
sending the <br>
packfile.</p>

<p style="margin-left:11%; margin-top: 1em">The response of
<b>fetch</b> is broken into a number of sections separated
by delimiter packets (0001), with each section beginning
with its section header. Most sections are sent only when
the packfile is sent.</p>

<p style="margin-left:17%; margin-top: 1em">output =
acknowledgements flush&minus;pkt | <br>
[acknowledgments delim&minus;pkt] [shallow&minus;info
delim&minus;pkt] <br>
[wanted&minus;refs delim&minus;pkt] [packfile&minus;uris
delim&minus;pkt] <br>
packfile flush&minus;pkt</p>


<p style="margin-left:17%; margin-top: 1em">acknowledgments
= PKT&minus;LINE(&quot;acknowledgments&quot; LF) <br>
(nak | *ack) <br>
(ready) <br>
ready = PKT&minus;LINE(&quot;ready&quot; LF) <br>
nak = PKT&minus;LINE(&quot;NAK&quot; LF) <br>
ack = PKT&minus;LINE(&quot;ACK&quot; SP obj&minus;id LF)</p>


<p style="margin-left:17%; margin-top: 1em">shallow&minus;info
= PKT&minus;LINE(&quot;shallow&minus;info&quot; LF) <br>
*PKT&minus;LINE((shallow | unshallow) LF) <br>
shallow = &quot;shallow&quot; SP obj&minus;id <br>
unshallow = &quot;unshallow&quot; SP obj&minus;id</p>


<p style="margin-left:17%; margin-top: 1em">wanted&minus;refs
= PKT&minus;LINE(&quot;wanted&minus;refs&quot; LF) <br>
*PKT&minus;LINE(wanted&minus;ref LF) <br>
wanted&minus;ref = obj&minus;id SP refname</p>


<p style="margin-left:17%; margin-top: 1em">packfile&minus;uris
= PKT&minus;LINE(&quot;packfile&minus;uris&quot; LF)
*packfile&minus;uri <br>
packfile&minus;uri = PKT&minus;LINE(40*(HEXDIGIT) SP
*%x20&minus;ff LF)</p>

<p style="margin-left:17%; margin-top: 1em">packfile =
PKT&minus;LINE(&quot;packfile&quot; LF) <br>
*PKT&minus;LINE(%x01&minus;03 *%x00&minus;ff)</p>


<p style="margin-left:17%; margin-top: 1em">acknowledgments
section <br>
* If the client determines that it is finished with
negotiations by <br>
sending a &quot;done&quot; line (thus requiring the server
to send a packfile), <br>
the acknowledgments sections MUST be omitted from the
server's <br>
response.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Always
begins with the section header
&quot;acknowledgments&quot;</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
server will respond with &quot;NAK&quot; if none of the
object ids sent as have lines were common.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
server will respond with &quot;ACK obj&minus;id&quot; for
all of the object ids sent as have lines which are
common.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; A
response cannot have both &quot;ACK&quot; lines as well as a
&quot;NAK&quot; line.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
server will respond with a &quot;ready&quot; line indicating
that the server has found an acceptable common base and is
ready to make and send a packfile (which will be found in
the packfile section of the same response)</p>

<p style="margin-left:17%; margin-top: 1em">&bull; If the
server has found a suitable cut point and has decided to
send a &quot;ready&quot; line, then the server can decide to
(as an optimization) omit any &quot;ACK&quot; lines it would
have sent during its response. This is because the server
will have already determined the objects it plans to send to
the client and no further negotiation is needed.</p>


<p style="margin-left:23%; margin-top: 1em">shallow&minus;info
section <br>
* If the client has requested a shallow fetch/clone, a
shallow <br>
client requests a fetch or the server is shallow then the
<br>
server's response may include a shallow&minus;info section.
The <br>
shallow&minus;info section will be included if (due to one
of the <br>
above conditions) the server needs to inform the client of
any <br>
shallow boundaries or adjustments to the clients already
<br>
existing shallow boundaries.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Always
begins with the section header
&quot;shallow&minus;info&quot;</p>

<p style="margin-left:17%; margin-top: 1em">&bull; If a
positive depth is requested, the server will compute the set
of commits which are no deeper than the desired depth.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
server sends a &quot;shallow obj&minus;id&quot; line for
each commit whose parents will not be sent in the following
packfile.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
server sends an &quot;unshallow obj&minus;id&quot; line for
each commit which the client has indicated is shallow, but
is no longer shallow as a result of the fetch (due to its
parents being sent in the following packfile).</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
server MUST NOT send any &quot;unshallow&quot; lines for
anything which the client has not indicated was shallow as a
part of its request.</p>


<p style="margin-left:23%; margin-top: 1em">wanted&minus;refs
section <br>
* This section is only included if the client has requested
a <br>
ref using a 'want&minus;ref' line and if a packfile section
is also <br>
included in the response.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Always
begins with the section header
&quot;wanted&minus;refs&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
server will send a ref listing (&quot;&lt;oid&gt;
&lt;refname&gt;&quot;) for each reference requested using
<i>want&minus;ref</i> lines.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
server MUST NOT send any refs which were not requested using
<i>want&minus;ref</i> lines.</p>


<p style="margin-left:23%; margin-top: 1em">packfile&minus;uris
section <br>
* This section is only included if the client sent <br>
'packfile&minus;uris' and the server has at least one such
URI to <br>
send.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Always
begins with the section header
&quot;packfile&minus;uris&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; For each
URI the server sends, it sends a hash of the pack&rsquo;s
contents (as output by git index&minus;pack) followed by the
URI.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
hashes are 40 hex characters long. When Git upgrades to a
new hash algorithm, this might need to be updated. (It
should match whatever index&minus;pack outputs after
&quot;pack\t&quot; or &quot;keep\t&quot;.</p>

<p style="margin-left:23%; margin-top: 1em">packfile
section <br>
* This section is only included if the client has sent
'want' <br>
lines in its request and either requested that no more <br>
negotiation be done by sending 'done' or if the server has
<br>
decided it has found a sufficient cut point to produce a
<br>
packfile.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Always
begins with the section header &quot;packfile&quot;</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
transmission of the packfile begins immediately after the
section header</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The data
transfer of the packfile is always multiplexed, using the
same semantics of the <i>side&minus;band&minus;64k</i>
capability from protocol version 1. This means that each
packet, during the packfile data stream, is made up of a
leading 4&minus;byte pkt&minus;line length (typical of the
pkt&minus;line format), followed by a 1&minus;byte stream
code, followed by the actual data.</p>

<p style="margin-left:23%; margin-top: 1em">The stream code
can be one of: <br>
1 &minus; pack data <br>
2 &minus; progress messages <br>
3 &minus; fatal error message just before stream aborts</p>


<p style="margin-left:11%; margin-top: 1em"><b>server&minus;option</b>
<br>
If advertised, indicates that any number of server specific
options can be included in a request. This is done by
sending each option as a
&quot;server&minus;option=&lt;option&gt;&quot; capability
line in the capability&minus;list section of a request.</p>

<p style="margin-left:11%; margin-top: 1em">The provided
options must not contain a NUL or LF character.</p>


<p style="margin-left:11%; margin-top: 1em"><b>object&minus;format</b>
<br>
The server can advertise the <b>object&minus;format</b>
capability with a value <b>X</b> (in the form
<b>object&minus;format=X</b>) to notify the client that the
server is able to deal with objects using hash algorithm X.
If not specified, the server is assumed to only handle
SHA&minus;1. If the client would like to use a hash
algorithm other than SHA&minus;1, it should specify its
object&minus;format string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>session&minus;id=&lt;session
id&gt;</b> <br>
The server may advertise a session ID that can be used to
identify this process across multiple requests. The client
may advertise its own session ID back to the server as
well.</p>

<p style="margin-left:11%; margin-top: 1em">Session IDs
should be unique to a given process. They must fit within a
packet&minus;line, and must not contain non&minus;printable
or whitespace characters. The current implementation uses
trace2 session IDs (see
<b><font color="#0000FF">api&minus;trace2</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">for details), but this may change and
users of the session ID should not rely on this
fact.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>object&minus;info
<br>
object&minus;info</b> is the command to retrieve information
about one or more objects. Its main purpose is to allow a
client to make decisions based on this information without
having to fully fetch objects. Object size is the only
information that is currently supported.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">An
<b>object&minus;info</b> request takes the following
arguments:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">size
<br>
Requests size information to be returned for each listed
object id.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">oid
&lt;oid&gt; <br>
Indicates to the server an object which the client wants to
obtain <br>
information for.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
response of <b>object&minus;info</b> is a list of the
requested object ids and associated requested information,
each separated by a single space.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">output
= info flush&minus;pkt</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">info
= PKT&minus;LINE(attrs) LF) <br>
*PKT&minus;LINE(obj&minus;info LF)</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">attrs
= attr | attrs SP attrs</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">attr
= &quot;size&quot;</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">obj&minus;info
= obj&minus;id SP obj&minus;size</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>bundle&minus;uri</b>
<br>
If the <i>bundle&minus;uri</i> capability is advertised, the
server supports the &lsquo;bundle&minus;uri&rsquo;
command.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
capability is currently advertised with no value (i.e. not
&quot;bundle&minus;uri=somevalue&quot;), a value may be
added in the future for supporting command&minus;wide
extensions. Clients MUST ignore any unknown capability
values and proceed with the 'bundle&minus;uri&lsquo; dialog
they support.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>bundle&minus;uri</i> command is intended to be issued
before <b>fetch</b> to get URIs to bundle files (see
<b>git-bundle</b>(1)) to &quot;seed&quot; and inform the
subsequent <b>fetch</b> command.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
client CAN issue <b>bundle&minus;uri</b> before or after any
other valid command. To be useful to clients it&rsquo;s
expected that it&rsquo;ll be issued after an
<b>ls&minus;refs</b> and before <b>fetch</b>, but CAN be
issued at any time in the dialog.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b><big>DISCUSSION
of bundle-uri</big></b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
intent of the feature is optimize for server resource
consumption in the common case by changing the common case
of fetching a very large PACK during <b>git-clone</b>(1)
into a smaller incremental fetch.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">It
also allows servers to achieve better caching in combination
with an <b>uploadpack.packObjectsHook</b> (see
<b>git-config</b>(1)).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">By
having new clones or fetches be a more predictable and
common negotiation against the tips of recently produces
*.bundle file(s). Servers might even pre&minus;generate the
results of such negotiations for the
<b>uploadpack.packObjectsHook</b> as new pushes come
in.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">One
way that servers could take advantage of these bundles is
that the server would anticipate that fresh clones will
download a known bundle, followed by catching up to the
current state of the repository using ref tips found in that
bundle (or bundles).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b><big>PROTOCOL
for bundle-uri</big></b></font></p>

<p style="margin-left:17%;"><font color="#000000">A
<b>bundle&minus;uri</b> request takes no arguments, and as
noted above does not currently advertise a capability value.
Both may be added in the future.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
the client issues a <b>command=bundle&minus;uri</b> request,
the response is a list of key&minus;value pairs provided as
packet lines with value <b>&lt;key&gt;=&lt;value&gt;</b>.
Each <b>&lt;key&gt;</b> should be interpreted as a config
key from the <b>bundle.*</b> namespace to construct a list
of bundles. These keys are grouped by a
<b>bundle.&lt;id&gt;.</b> subsection, where each key
corresponding to a given <b>&lt;id&gt;</b> contributes
attributes to the bundle defined by that <b>&lt;id&gt;</b>.
See <b>git-config</b>(1) for the specific details of these
keys and how the Git client will interpret their
values.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Clients
MUST parse the line according to the above format, lines
that do not conform to the format SHOULD be discarded. The
user MAY be warned in such a case.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b><big>bundle-uri
CLIENT AND SERVER EXPECTATIONS</big></b></font></p>

<p style="margin-left:17%;"><font color="#000000">URI
CONTENTS</font></p>

<p style="margin-left:23%;"><font color="#000000">The
content at the advertised URIs MUST be one of two
types.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">The
advertised URI may contain a bundle file that <b>git bundle
verify</b> would accept. I.e. they MUST contain one or more
reference tips for use by the client, MUST indicate
prerequisites (in any) with standard &quot;&minus;&quot;
prefixes, and MUST indicate their
&quot;object&minus;format&quot;, if applicable.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">The
advertised URI may alternatively contain a plaintext file
that <b>git config &minus;&minus;list</b> would accept (with
the <b>&minus;&minus;file</b> option). The key&minus;value
pairs in this list are in the <b>bundle.*</b> namespace (see
<b>git-config</b>(1)).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">bundle&minus;uri
CLIENT ERROR RECOVERY</font></p>

<p style="margin-left:23%;"><font color="#000000">A client
MUST above all gracefully degrade on errors, whether that
error is because of bad missing/data in the bundle URI(s),
because that client is too dumb to e.g. understand and fully
parse out bundle headers and their prerequisite
relationships, or something else.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">Server
operators should feel confident in turning on
&quot;bundle&minus;uri&quot; and not worry if e.g. their CDN
goes down that clones or fetches will run into hard
failures. Even if the server bundle(s) are incomplete, or
bad in some way the client should still end up with a
functioning repository, just as if it had chosen not to use
this protocol extension.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">All
subsequent discussion on client and server interaction MUST
keep this in mind.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">bundle&minus;uri
SERVER TO CLIENT</font></p>

<p style="margin-left:23%;"><font color="#000000">The
ordering of the returned bundle uris is not significant.
Clients MUST parse their headers to discover their contained
OIDS and prerequisites. A client MUST consider the content
of the bundle(s) themselves and their header as the ultimate
source of truth.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">A
server MAY even return bundle(s) that don&rsquo;t have any
direct relationship to the repository being cloned (either
through accident, or intentional &quot;clever&quot;
configuration), and expect a client to sort out what data
they&rsquo;d like from the bundle(s), if any.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">bundle&minus;uri
CLIENT TO SERVER</font></p>

<p style="margin-left:23%;"><font color="#000000">The
client SHOULD provide reference tips found in the bundle
header(s) as <i>have</i> lines in any subsequent
<b>fetch</b> request. A client MAY also ignore the bundle(s)
entirely if doing so is deemed worse for some reason, e.g.
if the bundles can&rsquo;t be downloaded, it doesn&rsquo;t
like the tips it finds etc.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">WHEN
ADVERTISED BUNDLE(S) REQUIRE NO FURTHER
NEGOTIATION</font></p>

<p style="margin-left:23%;"><font color="#000000">If after
issuing <b>bundle&minus;uri</b> and <b>ls&minus;refs</b>,
and getting the header(s) of the bundle(s) the client finds
that the ref tips it wants can be retrieved entirely from
advertised bundle(s), the client MAY disconnect from the Git
server. The results of such a <i>clone</i> or <i>fetch</i>
should be indistinguishable from the state attained without
using bundle&minus;uri.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">EARLY
CLIENT DISCONNECTIONS AND ERROR RECOVERY</font></p>

<p style="margin-left:23%;"><font color="#000000">A client
MAY perform an early disconnect while still downloading the
bundle(s) (having streamed and parsed their headers). In
such a case the client MUST gracefully recover from any
errors related to finishing the download and validation of
the bundle(s).</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">I.e.
a client might need to re&minus;connect and issue a
<i>fetch</i> command, and possibly fall back to not making
use of <i>bundle&minus;uri</i> at all.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">This
&quot;MAY&quot; behavior is specified as such (and not a
&quot;SHOULD&quot;) on the assumption that a server
advertising bundle uris is more likely than not to be
serving up a relatively large repository, and to be pointing
to URIs that have a good chance of being in working order. A
client MAY e.g. look at the payload size of the bundles as a
heuristic to see if an early disconnect is worth it, should
falling back on a full &quot;fetch&quot; dialog be
necessary.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">WHEN
ADVERTISED BUNDLE(S) REQUIRE FURTHER NEGOTIATION</font></p>

<p style="margin-left:23%;"><font color="#000000">A client
SHOULD commence a negotiation of a PACK from the server via
the &quot;fetch&quot; command using the OID tips found in
advertised bundles, even if&rsquo;s still in the process of
downloading those bundle(s).</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">This
allows for aggressive early disconnects from any interactive
server dialog. The client blindly trusts that the advertised
OID tips are relevant, and issues them as <i>have</i> lines,
it then requests any tips it would like (usually from the
&quot;ls&minus;refs&quot; advertisement) via <i>want</i>
lines. The server will then compute a (hopefully small) PACK
with the expected difference between the tips from the
bundle(s) and the data requested.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">The
only connection the client then needs to keep active is to
the concurrently downloading static bundle(s), when those
and the incremental PACK are retrieved they should be
inflated and validated. Any errors at this point should be
gracefully recovered from, see above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b><big>bundle-uri
PROTOCOL FEATURES</big></b></font></p>

<p style="margin-left:17%;"><font color="#000000">The
client constructs a bundle list from the
<b>&lt;key&gt;=&lt;value&gt;</b> pairs provided by the
server. These pairs are part of the <b>bundle.*</b>
namespace as documented in <b>git-config</b>(1). In this
section, we discuss some of these keys and describe the
actions the client will do in response to this
information.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">In
particular, the <b>bundle.version</b> key specifies an
integer value. The only accepted value at the moment is
<b>1</b>, but if the client sees an unexpected value here
then the client MUST ignore the bundle list.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">As
long as <b>bundle.version</b> is understood, all other
unknown keys MAY be ignored by the client. The server will
guarantee compatibility with older clients, though newer
clients may be better able to use the extra keys to minimize
downloads.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Any
backwards&minus;incompatible addition of pre&minus;URI
key&minus;value will be guarded by a new
<b>bundle.version</b> value or values in
<i>bundle&minus;uri</i> capability advertisement itself,
and/or by new future <b>bundle&minus;uri</b> request
arguments.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Some
example key&minus;value pairs that are not currently
implemented but could be implemented in the future
include:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
Add a &quot;hash=&lt;val&gt;&quot; or
&quot;size=&lt;bytes&gt;&quot; advertise the expected hash
or size of the bundle file.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
Advertise that one or more bundle files are the same (to
e.g. have clients round&minus;robin or otherwise choose one
of N possible files).</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
A &quot;oid=&lt;OID&gt;&quot; shortcut and
&quot;prerequisite=&lt;OID&gt;&quot; shortcut. For
expressing the common case of a bundle with one tip and no
prerequisites, or one tip and one prerequisite.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">This
would allow for optimizing the common case of servers
who&rsquo;d like to provide one &quot;big bundle&quot;
containing only their &quot;main&quot; branch, and/or
incremental updates thereof.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">A
client receiving such a a response MAY assume that they can
skip retrieving the header from a bundle at the indicated
URI, and thus save themselves and the server(s) the
request(s) needed to inspect the headers of that bundle or
bundles.</font></p>

<h2>GIT
<a name="GIT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Part
of the <b>git</b>(1) suite</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="15%">



<p style="margin-top: 1em"><font color="#000000">api-trace2</font></p> </td>
<td width="68%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">file:///usr/share/doc/git-doc/technical/api-trace2.html</font></p>
<hr>
</body>
</html>
