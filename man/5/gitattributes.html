<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:53 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GITATTRIBUTES</title>

</head>
<body>
<h1>gitattributes</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">gitattributes
&minus; Defining attributes per path</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">$GIT_DIR/info/attributes,
.gitattributes</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A
<b>gitattributes</b> file is a simple text file that gives
<b>attributes</b> to pathnames.</p>

<p style="margin-left:11%; margin-top: 1em">Each line in
<b>gitattributes</b> file is of form:</p>

<p style="margin-left:17%; margin-top: 1em">pattern attr1
attr2 ...</p>

<p style="margin-left:11%; margin-top: 1em">That is, a
pattern followed by an attributes list, separated by
whitespaces. Leading and trailing whitespaces are ignored.
Lines that begin with <i>#</i> are ignored. Patterns that
begin with a double quote are quoted in C style. When the
pattern matches the path in question, the attributes listed
on the line are given to the path.</p>

<p style="margin-left:11%; margin-top: 1em">Each attribute
can be in one of these states for a given path:</p>

<p style="margin-left:11%; margin-top: 1em">Set</p>

<p style="margin-left:17%;">The path has the attribute with
special value &quot;true&quot;; this is specified by listing
only the name of the attribute in the attribute list.</p>

<p style="margin-left:11%; margin-top: 1em">Unset</p>

<p style="margin-left:17%;">The path has the attribute with
special value &quot;false&quot;; this is specified by
listing the name of the attribute prefixed with a dash
<b>&minus;</b> in the attribute list.</p>

<p style="margin-left:11%; margin-top: 1em">Set to a
value</p>

<p style="margin-left:17%;">The path has the attribute with
specified string value; this is specified by listing the
name of the attribute followed by an equal sign <b>=</b> and
its value in the attribute list.</p>


<p style="margin-left:11%; margin-top: 1em">Unspecified</p>

<p style="margin-left:17%;">No pattern matches the path,
and nothing says if the path has or does not have the
attribute, the attribute for the path is said to be
Unspecified.</p>

<p style="margin-left:11%; margin-top: 1em">When more than
one pattern matches the path, a later line overrides an
earlier line. This overriding is done per attribute.</p>

<p style="margin-left:11%; margin-top: 1em">The rules by
which the pattern matches paths are the same as in
<b>.gitignore</b> files (see <b>gitignore</b>(5)), with a
few exceptions:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; negative
patterns are forbidden</p>

<p style="margin-left:17%; margin-top: 1em">&bull; patterns
that match a directory do not recursively match paths inside
that directory (so using the trailing&minus;slash
<b>path/</b> syntax is pointless in an attributes file; use
<b>path/**</b> instead)</p>

<p style="margin-left:11%; margin-top: 1em">When deciding
what attributes are assigned to a path, Git consults
<b>$GIT_DIR/info/attributes</b> file (which has the highest
precedence), <b>.gitattributes</b> file in the same
directory as the path in question, and its parent
directories up to the toplevel of the work tree (the further
the directory that contains <b>.gitattributes</b> is from
the path in question, the lower its precedence). Finally
global and system&minus;wide files are considered (they have
the lowest precedence).</p>

<p style="margin-left:11%; margin-top: 1em">When the
<b>.gitattributes</b> file is missing from the work tree,
the path in the index is used as a fall&minus;back. During
checkout process, <b>.gitattributes</b> in the index is used
and then the file in the working tree is used as a
fall&minus;back.</p>

<p style="margin-left:11%; margin-top: 1em">If you wish to
affect only a single repository (i.e., to assign attributes
to files that are particular to one user&rsquo;s workflow
for that repository), then attributes should be placed in
the <b>$GIT_DIR/info/attributes</b> file. Attributes which
should be version&minus;controlled and distributed to other
repositories (i.e., attributes of interest to all users)
should go into <b>.gitattributes</b> files. Attributes that
should affect all repositories for a single user should be
placed in a file specified by the <b>core.attributesFile</b>
configuration option (see <b>git-config</b>(1)). Its default
value is $XDG_CONFIG_HOME/git/attributes. If
$XDG_CONFIG_HOME is either not set or empty,
$HOME/.config/git/attributes is used instead. Attributes for
all users on a system should be placed in the
<b>$(prefix)/etc/gitattributes</b> file.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes you
would need to override a setting of an attribute for a path
to <b>Unspecified</b> state. This can be done by listing the
name of the attribute prefixed with an exclamation point
<b>!</b>.</p>

<h2>EFFECTS
<a name="EFFECTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Certain
operations by Git can be influenced by assigning particular
attributes to a path. Currently, the following operations
are attributes&minus;aware.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Checking&minus;out
and checking&minus;in</b> <br>
These attributes affect how the contents stored in the
repository are copied to the working tree files when
commands such as <i>git switch</i>, <i>git checkout</i> and
<i>git merge</i> run. They also affect how Git stores the
contents you prepare in the working tree in the repository
upon <i>git add</i> and <i>git commit</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>text</big></b></p>

<p style="margin-left:17%;">This attribute enables and
controls end&minus;of&minus;line normalization. When a text
file is normalized, its line endings are converted to LF in
the repository. To control what line ending style is used in
the working directory, use the <b>eol</b> attribute for a
single file and the <b>core.eol</b> configuration variable
for all text files. Note that setting <b>core.autocrlf</b>
to <b>true</b> or <b>input</b> overrides <b>core.eol</b>
(see the definitions of those options in
<b>git-config</b>(1)).</p>

<p style="margin-left:17%; margin-top: 1em">Set</p>

<p style="margin-left:23%;">Setting the <b>text</b>
attribute on a path enables end&minus;of&minus;line
normalization and marks the path as a text file.
End&minus;of&minus;line conversion takes place without
guessing the content type.</p>

<p style="margin-left:17%; margin-top: 1em">Unset</p>

<p style="margin-left:23%;">Unsetting the <b>text</b>
attribute on a path tells Git not to attempt any
end&minus;of&minus;line conversion upon checkin or
checkout.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;auto&quot;</p>

<p style="margin-left:23%;">When <b>text</b> is set to
&quot;auto&quot;, the path is marked for automatic
end&minus;of&minus;line conversion. If Git decides that the
content is text, its line endings are converted to LF on
checkin. When the file has been committed with CRLF, no
conversion is done.</p>


<p style="margin-left:17%; margin-top: 1em">Unspecified</p>

<p style="margin-left:23%;">If the <b>text</b> attribute is
unspecified, Git uses the <b>core.autocrlf</b> configuration
variable to determine if the file should be converted.</p>

<p style="margin-left:17%; margin-top: 1em">Any other value
causes Git to act as if <b>text</b> has been left
unspecified.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>eol</big></b></p>

<p style="margin-left:17%;">This attribute sets a specific
line&minus;ending style to be used in the working directory.
This attribute has effect only if the <b>text</b> attribute
is set or unspecified, or if it is set to <b>auto</b>, the
file is detected as text, and it is stored with LF endings
in the index. Note that setting this attribute on paths
which are in the index with CRLF line endings may make the
paths to be considered dirty unless <b>text=auto</b> is set.
Adding the path to the index again will normalize the line
endings in the index.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;crlf&quot;</p>

<p style="margin-left:23%;">This setting forces Git to
normalize line endings for this file on checkin and convert
them to CRLF when the file is checked out.</p>

<p style="margin-left:17%; margin-top: 1em">Set to string
value &quot;lf&quot;</p>

<p style="margin-left:23%;">This setting forces Git to
normalize line endings to LF on checkin and prevents
conversion to CRLF when the file is checked out.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>Backwards
compatibility with crlf attribute</big></b></p>

<p style="margin-left:17%;">For backwards compatibility,
the <b>crlf</b> attribute is interpreted as follows:</p>

<p style="margin-left:23%; margin-top: 1em">crlf text <br>
&minus;crlf &minus;text <br>
crlf=input eol=lf</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>End-of-line
conversion</big></b></p>

<p style="margin-left:17%;">While Git normally leaves file
contents alone, it can be configured to normalize line
endings to LF in the repository and, optionally, to convert
them to CRLF when files are checked out.</p>

<p style="margin-left:17%; margin-top: 1em">If you simply
want to have CRLF line endings in your working directory
regardless of the repository you are working with, you can
set the config variable &quot;core.autocrlf&quot; without
using any attributes.</p>

<p style="margin-left:23%; margin-top: 1em">[core] <br>
autocrlf = true</p>

<p style="margin-left:17%; margin-top: 1em">This does not
force normalization of text files, but does ensure that text
files that you introduce to the repository have their line
endings normalized to LF when they are added, and that files
that are already normalized in the repository stay
normalized.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
ensure that text files that any contributor introduces to
the repository have their line endings normalized, you can
set the <b>text</b> attribute to &quot;auto&quot; for
<i>all</i> files.</p>

<p style="margin-left:23%; margin-top: 1em">* text=auto</p>

<p style="margin-left:17%; margin-top: 1em">The attributes
allow a fine&minus;grained control, how the line endings are
converted. Here is an example that will make Git normalize
.txt, .vcproj and .sh files, ensure that .vcproj files have
CRLF and .sh files have LF in the working directory, and
prevent .jpg files from being normalized regardless of their
content.</p>

<p style="margin-left:23%; margin-top: 1em">* text=auto
<br>
*.txt text <br>
*.vcproj text eol=crlf <br>
*.sh text eol=lf <br>
*.jpg &minus;text</p>


<p style="margin-left:23%; margin-top: 1em"><b><big>Note</big></b>
<br>
When <b>text=auto</b> conversion is enabled in a
cross&minus;platform project using push and pull to a
central repository the text files containing CRLFs should be
normalized.</p>

<p style="margin-left:17%; margin-top: 1em">From a clean
working directory:</p>

<p style="margin-left:23%; margin-top: 1em">$ echo &quot;*
text=auto&quot; &gt;.gitattributes <br>
$ git add &minus;&minus;renormalize . <br>
$ git status # Show files that will be normalized <br>
$ git commit &minus;m &quot;Introduce
end&minus;of&minus;line normalization&quot;</p>

<p style="margin-left:17%; margin-top: 1em">If any files
that should not be normalized show up in <i>git status</i>,
unset their <b>text</b> attribute before running <i>git add
&minus;u</i>.</p>

<p style="margin-left:23%; margin-top: 1em">manual.pdf
&minus;text</p>

<p style="margin-left:17%; margin-top: 1em">Conversely,
text files that Git does not detect can have normalization
enabled manually.</p>

<p style="margin-left:23%; margin-top: 1em">weirdchars.txt
text</p>

<p style="margin-left:17%; margin-top: 1em">If
<b>core.safecrlf</b> is set to &quot;true&quot; or
&quot;warn&quot;, Git verifies if the conversion is
reversible for the current setting of <b>core.autocrlf</b>.
For &quot;true&quot;, Git rejects irreversible conversions;
for &quot;warn&quot;, Git only prints a warning but accepts
an irreversible conversion. The safety triggers to prevent
such a conversion done to the files in the work tree, but
there are a few exceptions. Even though...</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
add</i> itself does not touch the files in the work tree,
the next checkout would, so the safety triggers;</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
apply</i> to update a text file with a patch does touch the
files in the work tree, but the operation is about text
files and CRLF conversion is about fixing the line ending
inconsistencies, so the safety does not trigger;</p>

<p style="margin-left:23%; margin-top: 1em">&bull; <i>git
diff</i> itself does not touch the files in the work tree,
it is often run to inspect the changes you intend to next
<i>git add</i>. To catch potential problems early, safety
triggers.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>working-tree-encoding</big></b></p>

<p style="margin-left:17%;"><big>Git recognizes files
encoded in ASCII or one of its supersets (e.g. UTF&minus;8,
ISO&minus;8859&minus;1, ...) as text files. Files encoded in
certain other encodings (e.g. UTF&minus;16) are interpreted
as binary and consequently built&minus;in Git text
processing tools (e.g. <i>git diff</i>) as well as most Git
web front ends do not visualize the contents of these files
by default.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In these
cases you can tell Git the encoding of a file in the working
directory with the <b>working&minus;tree&minus;encoding</b>
attribute. If a file with this attribute is added to Git,
then Git re&minus;encodes the content from the specified
encoding to UTF&minus;8. Finally, Git stores the UTF&minus;8
encoded content in its internal data structure (called
&quot;the index&quot;). On checkout the content is
re&minus;encoded back to the specified encoding.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Please
note that using the <b>working&minus;tree&minus;encoding</b>
attribute may have a number of pitfalls:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
Alternative Git implementations (e.g. JGit or libgit2) and
older Git versions (as of March 2018) do not support the
<b>working&minus;tree&minus;encoding</b> attribute. If you
decide to use the <b>working&minus;tree&minus;encoding</b>
attribute in your repository, then it is strongly
recommended to ensure that all clients working with the
repository support it.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>For
example, Microsoft Visual Studio resources files
(<b>*.rc</b>) or PowerShell script files (<b>*.ps1</b>) are
sometimes encoded in UTF&minus;16. If you declare
<b>*.ps1</b> as files as UTF&minus;16 and you add
<b>foo.ps1</b> with a
<b>working&minus;tree&minus;encoding</b> enabled Git client,
then <b>foo.ps1</b> will be stored as UTF&minus;8
internally. A client without
<b>working&minus;tree&minus;encoding</b> support will
checkout <b>foo.ps1</b> as UTF&minus;8 encoded file. This
will typically cause trouble for the users of this
file.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>If a Git
client that does not support the
<b>working&minus;tree&minus;encoding</b> attribute adds a
new file <b>bar.ps1</b>, then <b>bar.ps1</b> will be stored
&quot;as&minus;is&quot; internally (in this example probably
as UTF&minus;16). A client with
<b>working&minus;tree&minus;encoding</b> support will
interpret the internal contents as UTF&minus;8 and try to
convert it to UTF&minus;16 on checkout. That operation will
fail and cause an error.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
Reencoding content to non&minus;UTF encodings can cause
errors as the conversion might not be UTF&minus;8 round trip
safe. If you suspect your encoding to not be round trip
safe, then add it to <b>core.checkRoundtripEncoding</b> to
make Git check the round trip encoding (see
<b>git-config</b>(1)). SHIFT&minus;JIS (Japanese character
set) is known to have round trip issues with UTF&minus;8 and
is checked by default.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>&bull;
Reencoding content requires resources that might slow down
certain Git operations (e.g <i>git checkout</i> or <i>git
add</i>).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Use the
<b>working&minus;tree&minus;encoding</b> attribute only if
you cannot store a file in UTF&minus;8 encoding and if you
want Git to be able to process the content as
text.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>As an
example, use the following attributes if your <i>*.ps1</i>
files are UTF&minus;16 encoded with byte order mark (BOM)
and you want Git to perform automatic line ending conversion
based on your platform.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.ps1 text
working&minus;tree&minus;encoding=UTF&minus;16</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Use the
following attributes if your <i>*.ps1</i> files are
UTF&minus;16 little endian encoded without BOM and you want
Git to use Windows line endings in the working directory
(use <b>UTF&minus;16LE&minus;BOM</b> instead of
<b>UTF&minus;16LE</b> if you want UTF&minus;16 little endian
with BOM). Please note, it is highly recommended to
explicitly define the line endings with <b>eol</b> if the
<b>working&minus;tree&minus;encoding</b> attribute is used
to avoid ambiguity.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.ps1 text
working&minus;tree&minus;encoding=UTF&minus;16LE
eol=CRLF</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>You can
get a list of all available encodings on your platform with
the following command:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>iconv
&minus;&minus;list</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If you do
not know the encoding of a file, then you can use the
<b>file</b> command to guess the encoding:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>file
foo.ps1</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>ident</big></b></big></p>

<p style="margin-left:17%;"><big>When the attribute
<b>ident</b> is set for a path, Git replaces <b>$Id$</b> in
the blob object with <b>$Id:</b>, followed by the
40&minus;character hexadecimal blob object name, followed by
a dollar sign <b>$</b> upon checkout. Any byte sequence that
begins with <b>$Id:</b> and ends with <b>$</b> in the
worktree file is replaced with <b>$Id$</b> upon
check&minus;in.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>filter</big></b></big></p>

<p style="margin-left:17%;"><big>A <b>filter</b> attribute
can be set to a string value that names a filter driver
specified in the configuration.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>A filter
driver consists of a <b>clean</b> command and a
<b>smudge</b> command, either of which can be left
unspecified. Upon checkout, when the <b>smudge</b> command
is specified, the command is fed the blob object from its
standard input, and its standard output is used to update
the worktree file. Similarly, the <b>clean</b> command is
used to convert the contents of worktree file upon checkin.
By default these commands process only a single blob and
terminate. If a long running <b>process</b> filter is used
in place of <b>clean</b> and/or <b>smudge</b> filters, then
Git can process all blobs with a single filter command
invocation for the entire life of a single Git command, for
example <b>git add &minus;&minus;all</b>. If a long running
<b>process</b> filter is configured then it always takes
precedence over a configured single blob filter. See section
below for the description of the protocol used to
communicate with a <b>process</b> filter.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>One use of
the content filtering is to massage the content into a shape
that is more convenient for the platform, filesystem, and
the user to use. For this mode of operation, the key phrase
here is &quot;more convenient&quot; and not &quot;turning
something unusable into usable&quot;. In other words, the
intent is that if someone unsets the filter driver
definition, or does not have the appropriate filter program,
the project should still be usable.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Another
use of the content filtering is to store the content that
cannot be directly used in the repository (e.g. a UUID that
refers to the true content stored outside Git, or an
encrypted content) and turn it into a usable form upon
checkout (e.g. download the external content, or decrypt the
encrypted content).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>These two
filters behave differently, and by default, a filter is
taken as the former, massaging the contents into more
convenient shape. A missing filter driver definition in the
config, or a filter driver that exits with a non&minus;zero
status, is not an error but makes the filter a no&minus;op
passthru.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>You can
declare that a filter turns a content that by itself is
unusable into a usable content by setting the
filter.&lt;driver&gt;.required configuration variable to
<b>true</b>.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Note:
Whenever the clean filter is changed, the repo should be
renormalized: $ git add &minus;&minus;renormalize
.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For
example, in .gitattributes, you would assign the
<b>filter</b> attribute for paths.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.c
filter=indent</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Then you
would define a &quot;filter.indent.clean&quot; and
&quot;filter.indent.smudge&quot; configuration in your
.git/config to specify a pair of commands to modify the
contents of C programs when the source files are checked in
(&quot;clean&quot; is run) and checked out (no change is
made because the command is &quot;cat&quot;).</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;indent&quot;] <br>
clean = indent <br>
smudge = cat</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For best
results, <b>clean</b> should not alter its output further if
it is run twice (&quot;clean&rarr;clean&quot; should be
equivalent to &quot;clean&quot;), and multiple <b>smudge</b>
commands should not alter <b>clean</b>'s output
(&quot;smudge&rarr;smudge&rarr;clean&quot; should be
equivalent to &quot;clean&quot;). See the section on merging
below.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The
&quot;indent&quot; filter is well&minus;behaved in this
regard: it will not modify input that is already correctly
indented. In this case, the lack of a smudge filter means
that the clean filter <i>must</i> accept its own output
without modifying it.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If a
filter <i>must</i> succeed in order to make the stored
contents usable, you can declare that the filter is
<b>required</b>, in the configuration:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;crypt&quot;] <br>
clean = openssl enc ... <br>
smudge = openssl enc &minus;d ... <br>
required</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Sequence
&quot;%f&quot; on the filter command line is replaced with
the name of the file the filter is working on. A filter
might use this in keyword substitution. For
example:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[filter
&quot;p4&quot;] <br>
clean = git&minus;p4&minus;filter &minus;&minus;clean %f
<br>
smudge = git&minus;p4&minus;filter &minus;&minus;smudge
%f</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Note that
&quot;%f&quot; is the name of the path that is being worked
on. Depending on the version that is being filtered, the
corresponding file on disk may not exist, or may have
different contents. So, smudge and clean commands should not
try to access the file on disk, but only act as filters on
the content provided to them on standard input.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Long
Running Filter Process</big></b></big></p>

<p style="margin-left:17%;"><big>If the filter command (a
string value) is defined via
<b>filter.&lt;driver&gt;.process</b> then Git can process
all blobs with a single filter invocation for the entire
life of a single Git command. This is achieved by using the
long&minus;running process protocol (described in
technical/long&minus;running&minus;process&minus;protocol.txt).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>When Git
encounters the first file that needs to be cleaned or
smudged, it starts the filter and performs the handshake. In
the handshake, the welcome message sent by Git is
&quot;git&minus;filter&minus;client&quot;, only version 2 is
supported, and the supported capabilities are
&quot;clean&quot;, &quot;smudge&quot;, and
&quot;delay&quot;.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Afterwards
Git sends a list of &quot;key=value&quot; pairs terminated
with a flush packet. The list will contain at least the
filter command (based on the supported capabilities) and the
pathname of the file to filter relative to the repository
root. Right after the flush packet Git sends the content
split in zero or more pkt&minus;line packets and a flush
packet to terminate content. Please note, that the filter
must not send any response before it received the content
and the final flush packet. Also note that the
&quot;value&quot; of a &quot;key=value&quot; pair can
contain the &quot;=&quot; character whereas the key would
never contain that character.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&gt; command=smudge <br>
packet: git&gt; pathname=path/testfile.dat <br>
packet: git&gt; 0000 <br>
packet: git&gt; CONTENT <br>
packet: git&gt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The filter
is expected to respond with a list of &quot;key=value&quot;
pairs terminated with a flush packet. If the filter does not
experience problems then the list must contain a
&quot;success&quot; status. Right after these packets the
filter is expected to send the content in zero or more
pkt&minus;line packets and a flush packet at the end.
Finally, a second list of &quot;key=value&quot; pairs
terminated with a flush packet is expected. The filter can
change the status in the second list or keep the status as
is with an empty list. Please note that the empty list must
be terminated with a flush packet regardless.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=success <br>
packet: git&lt; 0000 <br>
packet: git&lt; SMUDGED_CONTENT <br>
packet: git&lt; 0000 <br>
packet: git&lt; 0000 # empty list, keep
&quot;status=success&quot; unchanged!</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If the
result content is empty then the filter is expected to
respond with a &quot;success&quot; status and a flush packet
to signal the empty content.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=success <br>
packet: git&lt; 0000 <br>
packet: git&lt; 0000 # empty content! <br>
packet: git&lt; 0000 # empty list, keep
&quot;status=success&quot; unchanged!</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In case
the filter cannot or does not want to process the content,
it is expected to respond with an &quot;error&quot;
status.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=error <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If the
filter experiences an error during processing, then it can
send the status &quot;error&quot; after the content was
(partially or completely) sent.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=success <br>
packet: git&lt; 0000 <br>
packet: git&lt; HALF_WRITTEN_ERRONEOUS_CONTENT <br>
packet: git&lt; 0000 <br>
packet: git&lt; status=error <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In case
the filter cannot or does not want to process the content as
well as any future content for the lifetime of the Git
process, then it is expected to respond with an
&quot;abort&quot; status at any point in the
protocol.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&lt; status=abort <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Git
neither stops nor restarts the filter process in case the
&quot;error&quot;/&quot;abort&quot; status is set. However,
Git sets its exit code according to the
<b>filter.&lt;driver&gt;.required</b> flag, mimicking the
behavior of the <b>filter.&lt;driver&gt;.clean</b> /
<b>filter.&lt;driver&gt;.smudge</b> mechanism.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If the
filter dies during the communication or does not adhere to
the protocol then Git will stop the filter process and
restart it with the next file that needs to be processed.
Depending on the <b>filter.&lt;driver&gt;.required</b> flag
Git will interpret that as error.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Delay</big></b></big></p>

<p style="margin-left:17%;"><big>If the filter supports the
&quot;delay&quot; capability, then Git can send the flag
&quot;can&minus;delay&quot; after the filter command and
pathname. This flag denotes that the filter can delay
filtering the current blob (e.g. to compensate network
latencies) by responding with no content but with the status
&quot;delayed&quot; and a flush packet.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&gt; command=smudge <br>
packet: git&gt; pathname=path/testfile.dat <br>
packet: git&gt; can&minus;delay=1 <br>
packet: git&gt; 0000 <br>
packet: git&gt; CONTENT <br>
packet: git&gt; 0000 <br>
packet: git&lt; status=delayed <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If the
filter supports the &quot;delay&quot; capability then it
must support the &quot;list_available_blobs&quot; command.
If Git sends this command, then the filter is expected to
return a list of pathnames representing blobs that have been
delayed earlier and are now available. The list must be
terminated with a flush packet followed by a
&quot;success&quot; status that is also terminated with a
flush packet. If no blobs for the delayed paths are
available, yet, then the filter is expected to block the
response until at least one blob becomes available. The
filter can tell Git that it has no more delayed blobs by
sending an empty list. As soon as the filter responds with
an empty list, Git stops asking. All blobs that Git has not
received at this point are considered missing and will
result in an error.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&gt; command=list_available_blobs <br>
packet: git&gt; 0000 <br>
packet: git&lt; pathname=path/testfile.dat <br>
packet: git&lt; pathname=path/otherfile.dat <br>
packet: git&lt; 0000 <br>
packet: git&lt; status=success <br>
packet: git&lt; 0000</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>After Git
received the pathnames, it will request the corresponding
blobs again. These requests contain a pathname and an empty
content section. The filter is expected to respond with the
smudged content in the usual way as explained
above.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>packet:
git&gt; command=smudge <br>
packet: git&gt; pathname=path/testfile.dat <br>
packet: git&gt; 0000 <br>
packet: git&gt; 0000 # empty content! <br>
packet: git&lt; status=success <br>
packet: git&lt; 0000 <br>
packet: git&lt; SMUDGED_CONTENT <br>
packet: git&lt; 0000 <br>
packet: git&lt; 0000 # empty list, keep
&quot;status=success&quot; unchanged!</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Example</big></b></big></p>

<p style="margin-left:17%;"><big>A long running filter demo
implementation can be found in
<b>contrib/long&minus;running&minus;filter/example.pl</b>
located in the Git core repository. If you develop your own
long running filter process then the <b>GIT_TRACE_PACKET</b>
environment variables can be very helpful for debugging (see
<b>git</b>(1)).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Please
note that you cannot use an existing
<b>filter.&lt;driver&gt;.clean</b> or
<b>filter.&lt;driver&gt;.smudge</b> command with
<b>filter.&lt;driver&gt;.process</b> because the former two
use a different inter process communication protocol than
the latter one.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Interaction
between checkin/checkout attributes</big></b></big></p>

<p style="margin-left:17%;"><big>In the check&minus;in
codepath, the worktree file is first converted with
<b>filter</b> driver (if specified and corresponding driver
defined), then the result is processed with <b>ident</b> (if
specified), and then finally with <b>text</b> (again, if
specified and applicable).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In the
check&minus;out codepath, the blob content is first
converted with <b>text</b>, and then <b>ident</b> and fed to
<b>filter</b>.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Merging
branches with differing checkin/checkout
attributes</big></b></big></p>

<p style="margin-left:17%;"><big>If you have added
attributes to a file that cause the canonical repository
format for that file to change, such as adding a
clean/smudge filter or text/eol/ident attributes, merging
anything where the attribute is not in place would normally
cause merge conflicts.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>To prevent
these unnecessary merge conflicts, Git can be told to run a
virtual check&minus;out and check&minus;in of all three
stages of a file when resolving a three&minus;way merge by
setting the <b>merge.renormalize</b> configuration variable.
This prevents changes caused by check&minus;in conversion
from causing spurious merge conflicts when a converted file
is merged with an unconverted file.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>As long as
a &quot;smudge&rarr;clean&quot; results in the same output
as a &quot;clean&quot; even on files that are already
smudged, this strategy will automatically resolve all
filter&minus;related conflicts. Filters that do not act in
this way may cause additional merge conflicts that must be
resolved manually.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b>Generating
diff text <big><br>
diff</big></b></big></p>

<p style="margin-left:17%;"><big>The attribute <b>diff</b>
affects how Git generates diffs for particular files. It can
tell Git whether to generate a textual patch for the path or
to treat the path as a binary file. It can also affect what
line is shown on the hunk header <b>@@ &minus;k,l +n,m
@@</b> line, tell Git to use an external command to generate
the diff, or ask Git to convert binary files to a text
format before generating the diff.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Set</big></p>

<p style="margin-left:23%;"><big>A path to which the
<b>diff</b> attribute is set is treated as text, even when
they contain byte values that normally never appear in text
files, such as NUL.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Unset</big></p>

<p style="margin-left:23%;"><big>A path to which the
<b>diff</b> attribute is unset will generate <b>Binary files
differ</b> (or a binary patch, if binary patches are
enabled).</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Unspecified</big></p>

<p style="margin-left:23%;"><big>A path to which the
<b>diff</b> attribute is unspecified first gets its contents
inspected, and if it looks like text and is smaller than
core.bigFileThreshold, it is treated as text. Otherwise it
would generate <b>Binary files differ</b>.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>String</big></p>

<p style="margin-left:23%;"><big>Diff is shown using the
specified diff driver. Each driver may specify one or more
options, as described in the following section. The options
for the diff driver &quot;foo&quot; are defined by the
configuration variables in the &quot;diff.foo&quot; section
of the Git config file.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Defining
an external diff driver</big></b></big></p>

<p style="margin-left:17%;"><big>The definition of a diff
driver is done in <b>gitconfig</b>, not <b>gitattributes</b>
file, so strictly speaking this manual page is a wrong place
to talk about it. However...</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>To define
an external diff driver <b>jcdiff</b>, add a section to your
<b>$GIT_DIR/config</b> file (or <b>$HOME/.gitconfig</b>
file) like this:</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;jcdiff&quot;] <br>
command = j&minus;c&minus;diff</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>When Git
needs to show you a diff for the path with <b>diff</b>
attribute set to <b>jcdiff</b>, it calls the command you
specified with the above configuration, i.e.
<b>j&minus;c&minus;diff</b>, with 7 parameters, just like
<b>GIT_EXTERNAL_DIFF</b> program is called. See
<b>git</b>(1) for details.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Setting
the internal diff algorithm</big></b></big></p>

<p style="margin-left:17%;"><big>The diff algorithm can be
set through the <b>diff.algorithm</b> config key, but
sometimes it may be helpful to set the diff algorithm per
path. For example, one may want to use the <b>minimal</b>
diff algorithm for .json files, and the <b>histogram</b> for
.c files, and so on without having to pass in the algorithm
through the command line each time.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>First, in
<b>.gitattributes</b>, assign the <b>diff</b> attribute for
paths.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>*.json
diff=&lt;name&gt;</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Then,
define a &quot;diff.&lt;name&gt;.algorithm&quot;
configuration to specify the diff algorithm, choosing from
<b>myers</b>, <b>patience</b>, <b>minimal</b>, or
<b>histogram</b>.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>[diff
&quot;&lt;name&gt;&quot;] <br>
algorithm = histogram</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>This diff
algorithm applies to user facing diff output like
git&minus;diff(1), git&minus;show(1) and is used for the
<b>&minus;&minus;stat</b> output as well. The merge
machinery will not use the diff algorithm set through this
method.</big></p>


<p style="margin-left:23%; margin-top: 1em"><big><b><big>Note</big></b>
<br>
If <b>diff.&lt;name&gt;.command</b> is defined for path with
the <b>diff=&lt;name&gt;</b> attribute, it is executed as an
external diff driver (see above), and adding
<b>diff.&lt;name&gt;.algorithm</b> has no effect, as the
algorithm is not passed to the external diff
driver.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>Defining
a custom hunk-header</big></b></big></p>

<p style="margin-left:17%;"><big><big>Each group of changes
(called a &quot;hunk&quot;) in the textual diff output is
prefixed with a line of the form:</big></big></p>

<p style="margin-left:23%; margin-top: 1em"><big><big>@@
&minus;k,l +n,m @@ TEXT</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>This
is called a <i>hunk header</i>. The &quot;TEXT&quot; portion
is by default a line that begins with an alphabet, an
underscore or a dollar sign; this matches what GNU <i>diff
&minus;p</i> output uses. This default selection however is
not suited for some contents, and you can use a customized
pattern to make a selection.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>First,
in .gitattributes, you would assign the <b>diff</b>
attribute for paths.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>*.tex
diff=tex</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Then,
you would define a &quot;diff.tex.xfuncname&quot;
configuration to specify a regular expression that matches a
line that you would want to appear as the hunk header
&quot;TEXT&quot;. Add a section to your
<b>$GIT_DIR/config</b> file (or <b>$HOME/.gitconfig</b>
file) like this:</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>[diff
&quot;tex&quot;] <br>
xfuncname =
&quot;^(\\\\(sub)*section\\{.*)$&quot;</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Note.
A single level of backslashes are eaten by the configuration
file parser, so you would need to double the backslashes;
the pattern above picks a line that begins with a backslash,
and zero or more occurrences of <b>sub</b> followed by
<b>section</b> followed by open brace, to the end of
line.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>There
are a few built&minus;in patterns to make this easier, and
<b>tex</b> is one of them, so you do not have to write the
above in your configuration file (you still need to enable
this with the attribute mechanism, via
<b>.gitattributes</b>). The following built in patterns are
available:</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>ada</b> suitable for source code in the Ada
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>bash</b> suitable for source code in the
Bourne&minus;Again SHell language. Covers a superset of
POSIX shell function definitions.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>bibtex</b> suitable for files with BibTeX coded
references.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>cpp</b> suitable for source code in the C and C++
languages.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>csharp</b> suitable for source code in the C#
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>css</b> suitable for cascading style
sheets.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>dts</b> suitable for devicetree (DTS)
files.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>elixir</b> suitable for source code in the Elixir
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>fortran</b> suitable for source code in the Fortran
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>fountain</b> suitable for Fountain
documents.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>golang</b> suitable for source code in the Go
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>html</b> suitable for HTML/XHTML
documents.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>java</b> suitable for source code in the Java
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>kotlin</b> suitable for source code in the Kotlin
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>markdown</b> suitable for Markdown
documents.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>matlab</b> suitable for source code in the MATLAB and
Octave languages.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>objc</b> suitable for source code in the
Objective&minus;C language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>pascal</b> suitable for source code in the Pascal/Delphi
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>perl</b> suitable for source code in the Perl
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>php</b> suitable for source code in the PHP
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>python</b> suitable for source code in the Python
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>ruby</b> suitable for source code in the Ruby
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>rust</b> suitable for source code in the Rust
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>scheme</b> suitable for source code in the Scheme
language.</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>&bull;
<b>tex</b> suitable for source code for LaTeX
documents.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Customizing
word diff</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>You can customize the
rules that <b>git diff &minus;&minus;word&minus;diff</b>
uses to split words in a line, by specifying an appropriate
regular expression in the &quot;diff.*.wordRegex&quot;
configuration variable. For example, in TeX a backslash
followed by a sequence of letters forms a command, but
several such commands can be run together without
intervening whitespace. To separate them, use a regular
expression in your <b>$GIT_DIR/config</b> file (or
<b>$HOME/.gitconfig</b> file) like this:</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>[diff
&quot;tex&quot;] <br>
wordRegex =
&quot;\\\\[a&minus;zA&minus;Z]+|[{}]|\\\\.|[^\\{}[:space:]]+&quot;</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>A
built&minus;in pattern is provided for all languages listed
in the previous section.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Performing
text diffs of binary files</big></b></big></big></p>

<p style="margin-left:17%;"><big><big>Sometimes it is
desirable to see the diff of a text&minus;converted version
of some binary files. For example, a word processor document
can be converted to an ASCII text representation, and the
diff of the text shown. Even though this conversion loses
some information, the resulting diff is useful for human
viewing (but cannot be applied directly).</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>The
<b>textconv</b> config option is used to define a program
for performing such a conversion. The program should take a
single argument, the name of a file to convert, and produce
the resulting text on stdout.</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>For
example, to show the diff of the exif information of a file
instead of the binary information (assuming you have the
exif tool installed), add the following section to your
<b>$GIT_DIR/config</b> file (or <b>$HOME/.gitconfig</b>
file):</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>[diff
&quot;jpg&quot;] <br>
textconv = exif</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><b><big>Note</big></b>
<br>
The text conversion is generally a one&minus;way conversion;
in this example, we lose the actual image contents and focus
just on the text data. This means that diffs generated by
textconv are <i>not</i> suitable for applying. For this
reason, only <b>git diff</b> and the <b>git log</b> family
of commands (i.e., log, whatchanged, show) will perform text
conversion. <b>git format&minus;patch</b> will never
generate this output. If you want to send somebody a
text&minus;converted diff of a binary file (e.g., because it
quickly conveys the changes you have made), you should
generate it separately and send it as a comment <i>in
addition to</i> the usual binary diff that you might
send.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>Because
text conversion can be slow, especially when doing a large
number of them with <b>git log &minus;p</b>, Git provides a
mechanism to cache the output and use it in future diffs. To
enable caching, set the &quot;cachetextconv&quot; variable
in your diff driver&rsquo;s config. For
example:</big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big>[diff
&quot;jpg&quot;] <br>
textconv = exif <br>
cachetextconv = true</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>This
will cache the result of running &quot;exif&quot; on each
blob indefinitely. If you change the textconv config
variable for a diff driver, Git will automatically
invalidate the cache entries and re&minus;run the textconv
filter. If you want to invalidate the cache manually (e.g.,
because your version of &quot;exif&quot; was updated and now
produces better output), you can remove the cache manually
with <b>git update&minus;ref &minus;d
refs/notes/textconv/jpg</b> (where &quot;jpg&quot; is the
name of the diff driver, as in the example
above).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Choosing
textconv versus external diff</big></b></big></big></p>

<p style="margin-left:17%;"><big><big><big>If you want to
show differences between binary or specially&minus;formatted
blobs in your repository, you can choose to use either an
external diff command, or to use textconv to convert them to
a diff&minus;able text format. Which method you choose
depends on your exact situation.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>The
advantage of using an external diff command is flexibility.
You are not bound to find line&minus;oriented changes, nor
is it necessary for the output to resemble unified diff. You
are free to locate and report changes in the most
appropriate way for your data format.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>A
textconv, by comparison, is much more limiting. You provide
a transformation of the data into a line&minus;oriented text
format, and Git uses its regular diff tools to generate the
output. There are several advantages to choosing this
method:</big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big>1.
Ease of use. It is often much simpler to write a binary to
text transformation than it is to perform your own diff. In
many cases, existing programs can be used as textconv
filters (e.g., exif, odt2txt).</big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big>2.
Git diff features. By performing only the transformation
step yourself, you can still utilize many of Git&rsquo;s
diff features, including colorization, word&minus;diff, and
combined diffs for merges.</big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big>3.
Caching. Textconv caching can speed up repeated diffs, such
as those you might trigger by running <b>git log
&minus;p</b>.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b><big>Marking
files as binary</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>Git usually
guesses correctly whether a blob contains text or binary
data by examining the beginning of the contents. However,
sometimes you may want to override its decision, either
because a blob contains binary data later in the file, or
because the content, while technically composed of text
characters, is opaque to a human reader. For example, many
postscript files contain only ASCII characters, but produce
noisy and meaningless diffs.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>The
simplest way to mark a file as binary is to unset the diff
attribute in the <b>.gitattributes</b>
file:</big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big>*.ps
&minus;diff</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>This
will cause Git to generate <b>Binary files differ</b> (or a
binary patch, if binary patches are enabled) instead of a
regular diff.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>However,
one may also want to specify other diff driver attributes.
For example, you might want to use <b>textconv</b> to
convert postscript files to an ASCII representation for
human viewing, but otherwise treat them as binary files. You
cannot specify both <b>&minus;diff</b> and <b>diff=ps</b>
attributes. The solution is to use the <b>diff.*.binary</b>
config option:</big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big>[diff
&quot;ps&quot;] <br>
textconv = ps2ascii <br>
binary = true</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b>Performing
a three&minus;way merge <big><br>
merge</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>The attribute
<b>merge</b> affects how three versions of a file are merged
when a file&minus;level merge is necessary during <b>git
merge</b>, and other commands such as <b>git revert</b> and
<b>git cherry&minus;pick</b>.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>Set</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Built&minus;in
3&minus;way merge driver is used to merge the contents in a
way similar to <i>merge</i> command of <b>RCS</b> suite.
This is suitable for ordinary text
files.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>Unset</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Take the version
from the current branch as the tentative merge result, and
declare that the merge has conflicts. This is suitable for
binary files that do not have a well&minus;defined merge
semantics.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>Unspecified</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>By default, this
uses the same built&minus;in 3&minus;way merge driver as is
the case when the <b>merge</b> attribute is set. However,
the <b>merge.default</b> configuration variable can name
different merge driver to be used with paths for which the
<b>merge</b> attribute is unspecified.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>String</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>3&minus;way
merge is performed using the specified custom merge driver.
The built&minus;in 3&minus;way merge driver can be
explicitly specified by asking for &quot;text&quot; driver;
the built&minus;in &quot;take the current branch&quot;
driver can be requested with
&quot;binary&quot;.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b><big>Built-in
merge drivers</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>There are a few
built&minus;in low&minus;level merge drivers defined that
can be asked for via the <b>merge</b>
attribute.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>text</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Usual
3&minus;way file level merge for text files. Conflicted
regions are marked with conflict markers
<b>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</b>, <b>=======</b> and
<b>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</b>. The version from your
branch appears before the <b>=======</b> marker, and the
version from the merged branch appears after the
<b>=======</b> marker.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>binary</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Keep the version
from your branch in the work tree, but leave the path in the
conflicted state for the user to sort
out.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>union</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Run 3&minus;way
file level merge for text files, but take lines from both
versions, instead of leaving conflict markers. This tends to
leave the added lines in the resulting file in random order
and the user should verify the result. Do not use this if
you do not understand the
implications.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b><big>Defining
a custom merge driver</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>The definition
of a merge driver is done in the <b>.git/config</b> file,
not in the <b>gitattributes</b> file, so strictly speaking
this manual page is a wrong place to talk about it.
However...</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>To
define a custom merge driver <b>filfre</b>, add a section to
your <b>$GIT_DIR/config</b> file (or <b>$HOME/.gitconfig</b>
file) like this:</big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big>[merge
&quot;filfre&quot;] <br>
name = feel&minus;free merge driver <br>
driver = filfre %O %A %B %L %P <br>
recursive = binary</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>The
<b>merge.*.name</b> variable gives the driver a
human&minus;readable name.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>The
&lsquo;merge.*.driver&lsquo; variable&rsquo;s value is used
to construct a command to run to merge ancestor&rsquo;s
version (<b>%O</b>), current version (<b>%A</b>) and the
other branches&rsquo; version (<b>%B</b>). These three
tokens are replaced with the names of temporary files that
hold the contents of these versions when the command line is
built. Additionally, %L will be replaced with the conflict
marker size (see below).</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>The
merge driver is expected to leave the result of the merge in
the file named with <b>%A</b> by overwriting it, and exit
with zero status if it managed to merge them cleanly, or
non&minus;zero if there were
conflicts.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>The
<b>merge.*.recursive</b> variable specifies what other merge
driver to use when the merge driver is called for an
internal merge between common ancestors, when there are more
than one. When left unspecified, the driver itself is used
for both internal merge and the final
merge.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>The
merge driver can learn the pathname in which the merged
result will be stored via placeholder
<b>%P</b>.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b><big>conflict-marker-size</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>This attribute
controls the length of conflict markers left in the work
tree file during a conflicted merge. Only setting to the
value to a positive integer has any meaningful
effect.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>For
example, this line in <b>.gitattributes</b> can be used to
tell the merge machinery to leave much longer (instead of
the usual 7&minus;character&minus;long) conflict markers
when merging the file
<b>Documentation/git&minus;merge.txt</b> results in a
conflict.</big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big>Documentation/git&minus;merge.txt
conflict&minus;marker&minus;size=32</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b>Checking
whitespace errors <big><br>
whitespace</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>The
<b>core.whitespace</b> configuration variable allows you to
define what <i>diff</i> and <i>apply</i> should consider
whitespace errors for all paths in the project (See
<b>git-config</b>(1)). This attribute gives you finer
control per path.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>Set</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Notice all types
of potential whitespace errors known to Git. The tab width
is taken from the value of the <b>core.whitespace</b>
configuration variable.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>Unset</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Do not notice
anything as error.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>Unspecified</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Use the value of
the <b>core.whitespace</b> configuration variable to decide
what to notice as error.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>String</big></big></big></p>

<p style="margin-left:23%;"><big><big><big>Specify a comma
separated list of common whitespace problems to notice in
the same format as the <b>core.whitespace</b> configuration
variable.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b>Creating
an archive <big><br>
export-ignore</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>Files and
directories with the attribute <b>export&minus;ignore</b>
won&rsquo;t be added to archive files.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b><big>export-subst</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>If the attribute
<b>export&minus;subst</b> is set for a file then Git will
expand several placeholders when adding this file to an
archive. The expansion depends on the availability of a
commit ID, i.e., if <b>git-archive</b>(1) has been given a
tree instead of a commit or a tag then no replacement will
be done. The placeholders are the same as those for the
option <b>&minus;&minus;pretty=format:</b> of
<b>git-log</b>(1), except that they need to be wrapped like
this: <b>$Format:PLACEHOLDERS$</b> in the file. E.g. the
string <b>$Format:%H$</b> will be replaced by the commit
hash. However, only one <b>%(describe)</b> placeholder is
expanded per archive to avoid denial&minus;of&minus;service
attacks.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b>Packing
objects <big><br>
delta</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>Delta
compression will not be attempted for blobs for paths with
the attribute <b>delta</b> set to
false.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b>Viewing
files in GUI tools <big><br>
encoding</big></b></big></big></big></p>

<p style="margin-left:17%;"><big><big><big>The value of
this attribute specifies the character encoding that should
be used by GUI tools (e.g. <b>gitk</b>(1) and
<b>git-gui</b>(1)) to display the contents of the relevant
file. Note that due to performance considerations
<b>gitk</b>(1) does not use this attribute unless you
manually enable per&minus;file encodings in its
options.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>If
this attribute is not set or has an invalid value, the value
of the <b>gui.encoding</b> configuration variable is used
instead (See <b>git-config</b>(1)).</big></big></big></p>

<h2>USING MACRO ATTRIBUTES
<a name="USING MACRO ATTRIBUTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big>You
do not want any end&minus;of&minus;line conversions applied
to, nor textual diffs produced for, any binary file you
track. You would need to specify e.g.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>*.jpg
&minus;text &minus;diff</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>but
that may become cumbersome, when you have many attributes.
Using macro attributes, you can define an attribute that,
when set, also sets or unsets a number of other attributes
at the same time. The system knows a built&minus;in macro
attribute, <b>binary</b>:</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>*.jpg
binary</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>Setting
the &quot;binary&quot; attribute also unsets the
&quot;text&quot; and &quot;diff&quot; attributes as above.
Note that macro attributes can only be &quot;Set&quot;,
though setting one might have the effect of setting or
unsetting other attributes or even returning other
attributes to the &quot;Unspecified&quot;
state.</big></big></big></p>

<h2>DEFINING MACRO ATTRIBUTES
<a name="DEFINING MACRO ATTRIBUTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big>Custom
macro attributes can be defined only in top&minus;level
gitattributes files (<b>$GIT_DIR/info/attributes</b>, the
<b>.gitattributes</b> file at the top level of the working
tree, or the global or system&minus;wide gitattributes
files), not in <b>.gitattributes</b> files in working tree
subdirectories. The built&minus;in macro attribute
&quot;binary&quot; is equivalent to:</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>[attr]binary
&minus;diff &minus;merge &minus;text</big></big></big></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big>Git
does not follow symbolic links when accessing a
<b>.gitattributes</b> file in the working tree. This keeps
behavior consistent when the file is accessed from the index
or a tree versus from the filesystem.</big></big></big></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big>If
you have these three <b>gitattributes</b>
file:</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>(in
$GIT_DIR/info/attributes)</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>a*
foo !bar &minus;baz</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>(in
.gitattributes) <br>
abc foo bar baz</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>(in
t/.gitattributes) <br>
ab* merge=filfre <br>
abc &minus;foo &minus;bar <br>
*.c frotz</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>the
attributes given to path <b>t/abc</b> are computed as
follows:</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>1.
By examining <b>t/.gitattributes</b> (which is in the same
directory as the path in question), Git finds that the first
line matches. <b>merge</b> attribute is set. It also finds
that the second line matches, and attributes <b>foo</b> and
<b>bar</b> are unset.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>2.
Then it examines <b>.gitattributes</b> (which is in the
parent directory), and finds that the first line matches,
but <b>t/.gitattributes</b> file already decided how
<b>merge</b>, <b>foo</b> and <b>bar</b> attributes should be
given to this path, so it leaves <b>foo</b> and <b>bar</b>
unset. Attribute <b>baz</b> is set.</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>3.
Finally it examines <b>$GIT_DIR/info/attributes</b>. This
file is used to override the in&minus;tree settings. The
first line is a match, and <b>foo</b> is set, <b>bar</b> is
reverted to unspecified state, and <b>baz</b> is
unset.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>As
the result, the attributes assignment to <b>t/abc</b>
becomes:</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>foo
set to true <br>
bar unspecified <br>
baz set to false <br>
merge set to string value &quot;filfre&quot; <br>
frotz unspecified</big></big></big></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><b>git-check-attr</b>(1).</big></big></big></p>

<h2>GIT
<a name="GIT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big>Part
of the <b>git</b>(1) suite</big></big></big></p>
<hr>
</body>
</html>
