<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:55 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SYSTEMD.SERVICE</title>

</head>
<body>
<h1>systemd.service</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">systemd.service
&minus; Service unit configuration</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>service</i>.service</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A unit
configuration file whose name ends in &quot;.service&quot;
encodes information about a process controlled and
supervised by systemd.</p>

<p style="margin-left:11%; margin-top: 1em">This man page
lists the configuration options specific to this unit type.
See <b>systemd.unit</b>(5) for the common options of all
unit configuration files. The common configuration items are
configured in the generic [Unit] and [Install] sections. The
service specific configuration options are configured in the
[Service] section.</p>

<p style="margin-left:11%; margin-top: 1em">Additional
options are listed in <b>systemd.exec</b>(5), which define
the execution environment the commands are executed in, and
in <b>systemd.kill</b>(5), which define the way the
processes of the service are terminated, and in
<b>systemd.resource-control</b>(5), which configure resource
control settings for the processes of the service.</p>

<p style="margin-left:11%; margin-top: 1em">If SysV init
compat is enabled, systemd automatically creates service
units that wrap SysV init scripts (the service name is the
same as the name of the script, with a &quot;.service&quot;
suffix added); see <b>systemd-sysv-generator</b>(8).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>systemd-run</b>(1) command allows creating .service and
.scope units dynamically and transiently from the command
line.</p>

<h2>SERVICE TEMPLATES
<a name="SERVICE TEMPLATES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">It is possible
for <b>systemd</b> services to take a single argument via
the &quot;<i>service</i>@<i>argument</i>.service&quot;
syntax. Such services are called &quot;instantiated&quot;
services, while the unit definition without the
<i>argument</i> parameter is called a &quot;template&quot;.
An example could be a dhcpcd@.service service template which
takes a network interface as a parameter to form an
instantiated service. Within the service file, this
parameter or &quot;instance name&quot; can be accessed with
%&minus;specifiers. See <b>systemd.unit</b>(5) for
details.</p>

<h2>AUTOMATIC DEPENDENCIES
<a name="AUTOMATIC DEPENDENCIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Implicit
Dependencies</b> <br>
The following dependencies are implicitly added:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Services
with <i>Type=dbus</i> set automatically acquire dependencies
of type <i>Requires=</i> and <i>After=</i> on
dbus.socket.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Socket
activated services are automatically ordered after their
activating .socket units via an automatic <i>After=</i>
dependency. Services also pull in all .socket units listed
in <i>Sockets=</i> via automatic <i>Wants=</i> and
<i>After=</i> dependencies.</p>

<p style="margin-left:11%; margin-top: 1em">Additional
implicit dependencies may be added as result of execution
and resource control parameters as documented in
<b>systemd.exec</b>(5) and
<b>systemd.resource-control</b>(5).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Default
Dependencies</b> <br>
The following dependencies are added unless
<i>DefaultDependencies=no</i> is set:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Service
units will have dependencies of type <i>Requires=</i> and
<i>After=</i> on sysinit.target, a dependency of type
<i>After=</i> on basic.target as well as dependencies of
type <i>Conflicts=</i> and <i>Before=</i> on
shutdown.target. These ensure that normal service units pull
in basic system initialization, and are terminated cleanly
prior to system shutdown. Only services involved with early
boot or late system shutdown should disable this option.</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
Instanced service units (i.e. service units with an
&quot;@&quot; in their name) are assigned by default a
per&minus;template slice unit (see <b>systemd.slice</b>(5)),
named after the template unit, containing all instances of
the specific template. This slice is normally stopped at
shutdown, together with all template instances. If that is
not desired, set <i>DefaultDependencies=no</i> in the
template unit, and either define your own per&minus;template
slice unit file that also sets
<i>DefaultDependencies=no</i>, or set
<i>Slice=system.slice</i> (or another suitable slice) in the
template unit. Also see
<b>systemd.resource-control</b>(5).</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Service unit
files may include [Unit] and [Install] sections, which are
described in <b>systemd.unit</b>(5).</p>

<p style="margin-left:11%; margin-top: 1em">Service unit
files must include a [Service] section, which carries
information about the service and the process it supervises.
A number of options that may be used in this section are
shared with other unit types. These options are documented
in <b>systemd.exec</b>(5), <b>systemd.kill</b>(5) and
<b>systemd.resource-control</b>(5). The options specific to
the [Service] section of service units are the
following:</p>


<p style="margin-left:11%; margin-top: 1em"><i>Type=</i></p>

<p style="margin-left:17%;">Configures the process
start&minus;up type for this service unit. One of
<b>simple</b>, <b>exec</b>, <b>forking</b>, <b>oneshot</b>,
<b>dbus</b>, <b>notify</b>, <b>notify&minus;reload</b> or
<b>idle</b>:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; If set
to <b>simple</b> (the default if <i>ExecStart=</i> is
specified but neither <i>Type=</i> nor <i>BusName=</i> are),
the service manager will consider the unit started
immediately after the main service process has been forked
off. It is expected that the process configured with
<i>ExecStart=</i> is the main process of the service. In
this mode, if the process offers functionality to other
processes on the system, its communication channels should
be installed before the service is started up (e.g. sockets
set up by systemd, via socket activation), as the service
manager will immediately proceed starting follow&minus;up
units, right after creating the main service process, and
before executing the service's binary. Note that this means
<b>systemctl start</b> command lines for <b>simple</b>
services will report success even if the service's binary
cannot be invoked successfully (for example because the
selected <i>User=</i> doesn't exist, or the service binary
is missing).</p>

<p style="margin-left:23%; margin-top: 1em">&bull; The
<b>exec</b> type is similar to <b>simple</b>, but the
service manager will consider the unit started immediately
after the main service binary has been executed. The service
manager will delay starting of follow&minus;up units until
that point. (Or in other words: <b>simple</b> proceeds with
further jobs right after <b>fork()</b> returns, while
<b>exec</b> will not proceed before both <b>fork()</b> and
<b>execve()</b> in the service process succeeded.) Note that
this means <b>systemctl start</b> command lines for
<b>exec</b> services will report failure when the service's
binary cannot be invoked successfully (for example because
the selected <i>User=</i> doesn't exist, or the service
binary is missing).</p>

<p style="margin-left:23%; margin-top: 1em">&bull; If set
to <b>forking</b>, it is expected that the process
configured with <i>ExecStart=</i> will call <b>fork()</b> as
part of its start&minus;up. The parent process is expected
to exit when start&minus;up is complete and all
communication channels are set up. The child continues to
run as the main service process, and the service manager
will consider the unit started when the parent process
exits. This is the behavior of traditional UNIX services. If
this setting is used, it is recommended to also use the
<i>PIDFile=</i> option, so that systemd can reliably
identify the main process of the service. systemd will
proceed with starting follow&minus;up units as soon as the
parent process exits.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Behavior
of <b>oneshot</b> is similar to <b>simple</b>; however, the
service manager will consider the unit up after the main
process exits. It will then start follow&minus;up units.
<i>RemainAfterExit=</i> is particularly useful for this type
of service. <i>Type=</i><b>oneshot</b> is the implied
default if neither <i>Type=</i> nor <i>ExecStart=</i> are
specified. Note that if this option is used without
<i>RemainAfterExit=</i> the service will never enter
&quot;active&quot; unit state, but directly transition from
&quot;activating&quot; to &quot;deactivating&quot; or
&quot;dead&quot; since no process is configured that shall
run continuously. In particular this means that after a
service of this type ran (and which has
<i>RemainAfterExit=</i> not set) it will not show up as
started afterwards, but as dead.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Behavior
of <b>dbus</b> is similar to <b>simple</b>; however, it is
expected that the service acquires a name on the D&minus;Bus
bus, as configured by <i>BusName=</i>. systemd will proceed
with starting follow&minus;up units after the D&minus;Bus
bus name has been acquired. Service units with this option
configured implicitly gain dependencies on the dbus.socket
unit. This type is the default if <i>BusName=</i> is
specified. A service unit of this type is considered to be
in the activating state until the specified bus name is
acquired. It is considered activated while the bus name is
taken. Once the bus name is released the service is
considered being no longer functional which has the effect
that the service manager attempts to terminate any remaining
processes belonging to the service. Services that drop their
bus name as part of their shutdown logic thus should be
prepared to receive a <b>SIGTERM</b> (or whichever signal is
configured in <i>KillSignal=</i>) as result.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Behavior
of <b>notify</b> is similar to <b>exec</b>; however, it is
expected that the service sends a &quot;READY=1&quot;
notification message via <b>sd_notify</b>(3) or an
equivalent call when it has finished starting up. systemd
will proceed with starting follow&minus;up units after this
notification message has been sent. If this option is used,
<i>NotifyAccess=</i> (see below) should be set to open
access to the notification socket provided by systemd. If
<i>NotifyAccess=</i> is missing or set to <b>none</b>, it
will be forcibly set to <b>main</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Behavior
of <b>notify&minus;reload</b> is identical to <b>notify</b>.
However, it extends the logic in one way: the <b>SIGHUP</b>
UNIX process signal is sent to the service's main process
when the service is asked to reload. (The signal to send can
be tweaked via <i>ReloadSignal=</i>, see below.). When
initiating the reload process the service is then expected
to reply with a notification message via <b>sd_notify</b>(3)
that contains the &quot;RELOADING=1&quot; field in
combination with &quot;MONOTONIC_USEC=&quot; set to the
current monotonic time (i.e. <b>CLOCK_MONOTONIC</b> in
<b>clock_gettime</b>(2)) in &micro;s, formatted as decimal
string. Once reloading is complete another notification
message must be sent, containing &quot;READY=1&quot;. Using
this service type and implementing this reload protocol is
an efficient alternative to providing an <i>ExecReload=</i>
command for reloading of the service's configuration.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Behavior
of <b>idle</b> is very similar to <b>simple</b>; however,
actual execution of the service program is delayed until all
active jobs are dispatched. This may be used to avoid
interleaving of output of shell services with the status
output on the console. Note that this type is useful only to
improve console output, it is not useful as a general unit
ordering tool, and the effect of this service type is
subject to a 5s timeout, after which the service program is
invoked anyway.</p>

<p style="margin-left:17%; margin-top: 1em">It is generally
recommended to use <i>Type=</i><b>simple</b> for
long&minus;running services whenever possible, as it is the
simplest and fastest option. However, as this service type
won't propagate service start&minus;up failures and doesn't
allow ordering of other units against completion of
initialization of the service (which for example is useful
if clients need to connect to the service through some form
of IPC, and the IPC channel is only established by the
service itself &mdash; in contrast to doing this ahead of
time through socket or bus activation or similar), it might
not be sufficient for many cases. If so, <b>notify</b>,
<b>notify&minus;reload</b> or <b>dbus</b> (the latter only
in case the service provides a D&minus;Bus interface) are
the preferred options as they allow service program code to
precisely schedule when to consider the service started up
successfully and when to proceed with follow&minus;up units.
The <b>notify</b>/<b>notify&minus;reload</b> service types
require explicit support in the service codebase (as
<b>sd_notify()</b> or an equivalent API needs to be invoked
by the service at the appropriate time) &mdash; if it's not
supported, then <b>forking</b> is an alternative: it
supports the traditional UNIX service start&minus;up
protocol. Finally, <b>exec</b> might be an option for cases
where it is enough to ensure the service binary is invoked,
and where the service binary itself executes no or little
initialization on its own (and its initialization is
unlikely to fail). Note that using any type other than
<b>simple</b> possibly delays the boot process, as the
service manager needs to wait for service initialization to
complete. It is hence recommended not to needlessly use any
types other than <b>simple</b>. (Also note it is generally
not recommended to use <b>idle</b> or <b>oneshot</b> for
long&minus;running services.)</p>


<p style="margin-left:11%; margin-top: 1em"><i>ExitType=</i></p>

<p style="margin-left:17%;">Specifies when the manager
should consider the service to be finished. One of
<b>main</b> or <b>cgroup</b>:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; If set
to <b>main</b> (the default), the service manager will
consider the unit stopped when the main process, which is
determined according to the <i>Type=</i>, exits.
Consequently, it cannot be used with
<i>Type=</i><b>oneshot</b>.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; If set
to <b>cgroup</b>, the service will be considered running as
long as at least one process in the cgroup has not
exited.</p>

<p style="margin-left:17%; margin-top: 1em">It is generally
recommended to use <i>ExitType=</i><b>main</b> when a
service has a known forking model and a main process can
reliably be determined. <i>ExitType=</i> <b>cgroup</b> is
meant for applications whose forking model is not known
ahead of time and which might not have a specific main
process. It is well suited for transient or automatically
generated services, such as graphical applications inside of
a desktop environment.</p>


<p style="margin-left:11%; margin-top: 1em"><i>RemainAfterExit=</i></p>

<p style="margin-left:17%;">Takes a boolean value that
specifies whether the service shall be considered active
even when all its processes exited. Defaults to
<b>no</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>GuessMainPID=</i></p>

<p style="margin-left:17%;">Takes a boolean value that
specifies whether systemd should try to guess the main PID
of a service if it cannot be determined reliably. This
option is ignored unless <b>Type=forking</b> is set and
<b>PIDFile=</b> is unset because for the other types or with
an explicitly configured PID file, the main PID is always
known. The guessing algorithm might come to incorrect
conclusions if a daemon consists of more than one process.
If the main PID cannot be determined, failure detection and
automatic restarting of a service will not work reliably.
Defaults to <b>yes</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>PIDFile=</i></p>

<p style="margin-left:17%;">Takes a path referring to the
PID file of the service. Usage of this option is recommended
for services where <i>Type=</i> is set to <b>forking</b>.
The path specified typically points to a file below /run/.
If a relative path is specified it is hence prefixed with
/run/. The service manager will read the PID of the main
process of the service from this file after start&minus;up
of the service. The service manager will not write to the
file configured here, although it will remove the file after
the service has shut down if it still exists. The PID file
does not need to be owned by a privileged user, but if it is
owned by an unprivileged user additional safety restrictions
are enforced: the file may not be a symlink to a file owned
by a different user (neither directly nor indirectly), and
the PID file must refer to a process already belonging to
the service.</p>

<p style="margin-left:17%; margin-top: 1em">Note that PID
files should be avoided in modern projects. Use
<b>Type=notify</b>, <b>Type=notify&minus;reload</b> or
<b>Type=simple</b> where possible, which does not require
use of PID files to determine the main process of a service
and avoids needless forking.</p>


<p style="margin-left:11%; margin-top: 1em"><i>BusName=</i></p>

<p style="margin-left:17%;">Takes a D&minus;Bus destination
name that this service shall use. This option is mandatory
for services where <i>Type=</i> is set to <b>dbus</b>. It is
recommended to always set this property if known to make it
easy to map the service name to the D&minus;Bus destination.
In particular, <b>systemctl
service&minus;log&minus;level/service&minus;log&minus;target</b>
verbs make use of this.</p>


<p style="margin-left:11%; margin-top: 1em"><i>ExecStart=</i></p>

<p style="margin-left:17%;">Commands with their arguments
that are executed when this service is started. The value is
split into zero or more command lines according to the rules
described below (see section &quot;Command Lines&quot;
below).</p>

<p style="margin-left:17%; margin-top: 1em">Unless
<i>Type=</i> is <b>oneshot</b>, exactly one command must be
given. When <i>Type=oneshot</i> is used, zero or more
commands may be specified. Commands may be specified by
providing multiple command lines in the same directive, or
alternatively, this directive may be specified more than
once with the same effect. If the empty string is assigned
to this option, the list of commands to start is reset,
prior assignments of this option will have no effect. If no
<i>ExecStart=</i> is specified, then the service must have
<i>RemainAfterExit=yes</i> and at least one <i>ExecStop=</i>
line set. (Services lacking both <i>ExecStart=</i> and
<i>ExecStop=</i> are not valid.)</p>

<p style="margin-left:17%; margin-top: 1em">For each of the
specified commands, the first argument must be either an
absolute path to an executable or a simple file name without
any slashes. Optionally, this filename may be prefixed with
a number of special characters:</p>


<p style="margin-left:17%; margin-top: 1em"><b>Table&nbsp;1.&nbsp;Special
executable prefixes</b> <br>
&quot;@&quot;, &quot;&minus;&quot;, &quot;:&quot;, and one
of &quot;+&quot;/&quot;!&quot;/&quot;!!&quot; may be used
together and they can appear in any order. However, only one
of &quot;+&quot;, &quot;!&quot;, &quot;!!&quot; may be used
at a time. Note that these prefixes are also supported for
the other command line settings, i.e. <i>ExecStartPre=</i>,
<i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>
and <i>ExecStopPost=</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If more than
one command is specified, the commands are invoked
sequentially in the order they appear in the unit file. If
one of the commands fails (and is not prefixed with
&quot;&minus;&quot;), other lines are not executed, and the
unit is considered failed.</p>

<p style="margin-left:17%; margin-top: 1em">Unless
<i>Type=forking</i> is set, the process started via this
command line will be considered the main process of the
daemon.</p>


<p style="margin-left:11%; margin-top: 1em"><i>ExecStartPre=</i>,
<i>ExecStartPost=</i></p>

<p style="margin-left:17%;">Additional commands that are
executed before or after the command in <i>ExecStart=</i>,
respectively. Syntax is the same as for <i>ExecStart=</i>,
except that multiple command lines are allowed and the
commands are executed one after the other, serially.</p>

<p style="margin-left:17%; margin-top: 1em">If any of those
commands (not prefixed with &quot;&minus;&quot;) fail, the
rest are not executed and the unit is considered failed.</p>


<p style="margin-left:17%; margin-top: 1em"><i>ExecStart=</i>
commands are only run after all <i>ExecStartPre=</i>
commands that were not prefixed with a &quot;&minus;&quot;
exit successfully.</p>


<p style="margin-left:17%; margin-top: 1em"><i>ExecStartPost=</i>
commands are only run after the commands specified in
<i>ExecStart=</i> have been invoked successfully, as
determined by <i>Type=</i> (i.e. the process has been
started for <i>Type=simple</i> or <i>Type=idle</i>, the last
<i>ExecStart=</i> process exited successfully for
<i>Type=oneshot</i>, the initial process exited successfully
for <i>Type=forking</i>, &quot;READY=1&quot; is sent for
<i>Type=notify</i>/<i>Type=notify&minus;reload</i>, or the
<i>BusName=</i> has been taken for <i>Type=dbus</i>).</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<i>ExecStartPre=</i> may not be used to start
long&minus;running processes. All processes forked off by
processes invoked via <i>ExecStartPre=</i> will be killed
before the next service process is run.</p>

<p style="margin-left:17%; margin-top: 1em">Note that if
any of the commands specified in <i>ExecStartPre=</i>,
<i>ExecStart=</i>, or <i>ExecStartPost=</i> fail (and are
not prefixed with &quot;&minus;&quot;, see above) or time
out before the service is fully up, execution continues with
commands specified in <i>ExecStopPost=</i>, the commands in
<i>ExecStop=</i> are skipped.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
execution of <i>ExecStartPost=</i> is taken into account for
the purpose of <i>Before=</i>/<i>After=</i> ordering
constraints.</p>


<p style="margin-left:11%; margin-top: 1em"><i>ExecCondition=</i></p>

<p style="margin-left:17%;">Optional commands that are
executed before the commands in <i>ExecStartPre=</i>. Syntax
is the same as for <i>ExecStart=</i>, except that multiple
command lines are allowed and the commands are executed one
after the other, serially.</p>

<p style="margin-left:17%; margin-top: 1em">The behavior is
like an <i>ExecStartPre=</i> and condition check hybrid:
when an <i>ExecCondition=</i> command exits with exit code 1
through 254 (inclusive), the remaining commands are skipped
and the unit is <i>not</i> marked as failed. However, if an
<i>ExecCondition=</i> command exits with 255 or abnormally
(e.g. timeout, killed by a signal, etc.), the unit will be
considered failed (and remaining commands will be skipped).
Exit code of 0 or those matching <i>SuccessExitStatus=</i>
will continue execution to the next commands.</p>

<p style="margin-left:17%; margin-top: 1em">The same
recommendations about not running long&minus;running
processes in <i>ExecStartPre=</i> also applies to
<i>ExecCondition=</i>. <i>ExecCondition=</i> will also run
the commands in <i>ExecStopPost=</i>, as part of stopping
the service, in the case of any non&minus;zero or abnormal
exits, like the ones described above.</p>


<p style="margin-left:11%; margin-top: 1em"><i>ExecReload=</i></p>

<p style="margin-left:17%;">Commands to execute to trigger
a configuration reload in the service. This argument takes
multiple command lines, following the same scheme as
described for <i>ExecStart=</i> above. Use of this setting
is optional. Specifier and environment variable substitution
is supported here following the same scheme as for
<i>ExecStart=</i>.</p>

<p style="margin-left:17%; margin-top: 1em">One additional,
special environment variable is set: if known,
<i>$MAINPID</i> is set to the main process of the daemon,
and may be used for command lines like the following:</p>


<p style="margin-left:23%; margin-top: 1em">ExecReload=kill
&minus;HUP $MAINPID</p>

<p style="margin-left:17%; margin-top: 1em">Note however
that reloading a daemon by enqueuing a signal (as with the
example line above) is usually not a good choice, because
this is an asynchronous operation and hence not suitable
when ordering reloads of multiple services against each
other. It is thus strongly recommended to either use
<i>Type=</i><b>notify&minus;reload</b> in place of
<i>ExecReload=</i>, or to set <i>ExecReload=</i> to a
command that not only triggers a configuration reload of the
daemon, but also synchronously waits for it to complete. For
example, <b>dbus-broker</b>(1) uses the following:</p>


<p style="margin-left:23%; margin-top: 1em">ExecReload=busctl
call org.freedesktop.DBus \ <br>
/org/freedesktop/DBus org.freedesktop.DBus \ <br>
ReloadConfig</p>


<p style="margin-left:11%; margin-top: 1em"><i>ExecStop=</i></p>

<p style="margin-left:17%;">Commands to execute to stop the
service started via <i>ExecStart=</i>. This argument takes
multiple command lines, following the same scheme as
described for <i>ExecStart=</i> above. Use of this setting
is optional. After the commands configured in this option
are run, it is implied that the service is stopped, and any
processes remaining for it are terminated according to the
<i>KillMode=</i> setting (see <b>systemd.kill</b>(5)). If
this option is not specified, the process is terminated by
sending the signal specified in <i>KillSignal=</i> or
<i>RestartKillSignal=</i> when service stop is requested.
Specifier and environment variable substitution is supported
(including <i>$MAINPID</i>, see above).</p>

<p style="margin-left:17%; margin-top: 1em">Note that it is
usually not sufficient to specify a command for this setting
that only asks the service to terminate (for example, by
sending some form of termination signal to it), but does not
wait for it to do so. Since the remaining processes of the
services are killed according to <i>KillMode=</i> and
<i>KillSignal=</i> or <i>RestartKillSignal=</i> as described
above immediately after the command exited, this may not
result in a clean stop. The specified command should hence
be a synchronous operation, not an asynchronous one.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
commands specified in <i>ExecStop=</i> are only executed
when the service started successfully first. They are not
invoked if the service was never started at all, or in case
its start&minus;up failed, for example because any of the
commands specified in <i>ExecStart=</i>,
<i>ExecStartPre=</i> or <i>ExecStartPost=</i> failed (and
weren't prefixed with &quot;&minus;&quot;, see above) or
timed out. Use <i>ExecStopPost=</i> to invoke commands when
a service failed to start up correctly and is shut down
again. Also note that the stop operation is always performed
if the service started successfully, even if the processes
in the service terminated on their own or were killed. The
stop commands must be prepared to deal with that case.
<i>$MAINPID</i> will be unset if systemd knows that the main
process exited by the time the stop commands are called.</p>

<p style="margin-left:17%; margin-top: 1em">Service restart
requests are implemented as stop operations followed by
start operations. This means that <i>ExecStop=</i> and
<i>ExecStopPost=</i> are executed during a service restart
operation.</p>

<p style="margin-left:17%; margin-top: 1em">It is
recommended to use this setting for commands that
communicate with the service requesting clean termination.
For post&minus;mortem clean&minus;up steps use
<i>ExecStopPost=</i> instead.</p>


<p style="margin-left:11%; margin-top: 1em"><i>ExecStopPost=</i></p>

<p style="margin-left:17%;">Additional commands that are
executed after the service is stopped. This includes cases
where the commands configured in <i>ExecStop=</i> were used,
where the service does not have any <i>ExecStop=</i>
defined, or where the service exited unexpectedly. This
argument takes multiple command lines, following the same
scheme as described for <i>ExecStart=</i>. Use of these
settings is optional. Specifier and environment variable
substitution is supported. Note that &ndash; unlike
<i>ExecStop=</i> &ndash; commands specified with this
setting are invoked when a service failed to start up
correctly and is shut down again.</p>

<p style="margin-left:17%; margin-top: 1em">It is
recommended to use this setting for clean&minus;up
operations that shall be executed even when the service
failed to start up correctly. Commands configured with this
setting need to be able to operate even if the service
failed starting up half&minus;way and left incompletely
initialized data around. As the service's processes have
been terminated already when the commands specified with
this setting are executed they should not attempt to
communicate with them.</p>

<p style="margin-left:17%; margin-top: 1em">Note that all
commands that are configured with this setting are invoked
with the result code of the service, as well as the main
process' exit code and status, set in the
<i>$SERVICE_RESULT</i>, <i>$EXIT_CODE</i> and
<i>$EXIT_STATUS</i> environment variables, see
<b>systemd.exec</b>(5) for details.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
execution of <i>ExecStopPost=</i> is taken into account for
the purpose of <i>Before=</i>/<i>After=</i> ordering
constraints.</p>


<p style="margin-left:11%; margin-top: 1em"><i>RestartSec=</i></p>

<p style="margin-left:17%;">Configures the time to sleep
before restarting a service (as configured with
<i>Restart=</i>). Takes a unit&minus;less value in seconds,
or a time span value such as &quot;5min 20s&quot;. Defaults
to 100ms.</p>


<p style="margin-left:11%; margin-top: 1em"><i>TimeoutStartSec=</i></p>

<p style="margin-left:17%;">Configures the time to wait for
start&minus;up. If a daemon service does not signal
start&minus;up completion within the configured time, the
service will be considered failed and will be shut down
again. The precise action depends on the
<i>TimeoutStartFailureMode=</i> option. Takes a
unit&minus;less value in seconds, or a time span value such
as &quot;5min 20s&quot;. Pass &quot;infinity&quot; to
disable the timeout logic. Defaults to
<i>DefaultTimeoutStartSec=</i> set in the manager, except
when <i>Type=oneshot</i> is used, in which case the timeout
is disabled by default (see
<b>systemd-system.conf</b>(5)).</p>

<p style="margin-left:17%; margin-top: 1em">If a service of
<i>Type=notify</i>/<i>Type=notify&minus;reload</i> sends
&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the
start time to be extended beyond <i>TimeoutStartSec=</i>.
The first receipt of this message must occur before
<i>TimeoutStartSec=</i> is exceeded, and once the start time
has extended beyond <i>TimeoutStartSec=</i>, the service
manager will allow the service to continue to start,
provided the service repeats
&quot;EXTEND_TIMEOUT_USEC=...&quot; within the interval
specified until the service startup status is finished by
&quot;READY=1&quot;. (see <b>sd_notify</b>(3)).</p>


<p style="margin-left:11%; margin-top: 1em"><i>TimeoutStopSec=</i></p>

<p style="margin-left:17%;">This option serves two
purposes. First, it configures the time to wait for each
<i>ExecStop=</i> command. If any of them times out,
subsequent <i>ExecStop=</i> commands are skipped and the
service will be terminated by <b>SIGTERM</b>. If no
<i>ExecStop=</i> commands are specified, the service gets
the <b>SIGTERM</b> immediately. This default behavior can be
changed by the <i>TimeoutStopFailureMode=</i> option.
Second, it configures the time to wait for the service
itself to stop. If it doesn't terminate in the specified
time, it will be forcibly terminated by <b>SIGKILL</b> (see
<i>KillMode=</i> in <b>systemd.kill</b>(5)). Takes a
unit&minus;less value in seconds, or a time span value such
as &quot;5min 20s&quot;. Pass &quot;infinity&quot; to
disable the timeout logic. Defaults to
<i>DefaultTimeoutStopSec=</i> from the manager configuration
file (see <b>systemd-system.conf</b>(5)).</p>

<p style="margin-left:17%; margin-top: 1em">If a service of
<i>Type=notify</i>/<i>Type=notify&minus;reload</i> sends
&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the stop
time to be extended beyond <i>TimeoutStopSec=</i>. The first
receipt of this message must occur before
<i>TimeoutStopSec=</i> is exceeded, and once the stop time
has extended beyond <i>TimeoutStopSec=</i>, the service
manager will allow the service to continue to stop, provided
the service repeats &quot;EXTEND_TIMEOUT_USEC=...&quot;
within the interval specified, or terminates itself (see
<b>sd_notify</b>(3)).</p>


<p style="margin-left:11%; margin-top: 1em"><i>TimeoutAbortSec=</i></p>

<p style="margin-left:17%;">This option configures the time
to wait for the service to terminate when it was aborted due
to a watchdog timeout (see <i>WatchdogSec=</i>). If the
service has a short <i>TimeoutStopSec=</i> this option can
be used to give the system more time to write a core dump of
the service. Upon expiration the service will be forcibly
terminated by <b>SIGKILL</b> (see <i>KillMode=</i> in
<b>systemd.kill</b>(5)). The core file will be truncated in
this case. Use <i>TimeoutAbortSec=</i> to set a sensible
timeout for the core dumping per service that is large
enough to write all expected data while also being short
enough to handle the service failure in due time.</p>

<p style="margin-left:17%; margin-top: 1em">Takes a
unit&minus;less value in seconds, or a time span value such
as &quot;5min 20s&quot;. Pass an empty value to skip the
dedicated watchdog abort timeout handling and fall back
<i>TimeoutStopSec=</i>. Pass &quot;infinity&quot; to disable
the timeout logic. Defaults to
<i>DefaultTimeoutAbortSec=</i> from the manager
configuration file (see <b>systemd-system.conf</b>(5)).</p>

<p style="margin-left:17%; margin-top: 1em">If a service of
<i>Type=notify</i>/<i>Type=notify&minus;reload</i> handles
<b>SIGABRT</b> itself (instead of relying on the kernel to
write a core dump) it can send
&quot;EXTEND_TIMEOUT_USEC=...&quot; to extended the abort
time beyond <i>TimeoutAbortSec=</i>. The first receipt of
this message must occur before <i>TimeoutAbortSec=</i> is
exceeded, and once the abort time has extended beyond
<i>TimeoutAbortSec=</i>, the service manager will allow the
service to continue to abort, provided the service repeats
&quot;EXTEND_TIMEOUT_USEC=...&quot; within the interval
specified, or terminates itself (see
<b>sd_notify</b>(3)).</p>


<p style="margin-left:11%; margin-top: 1em"><i>TimeoutSec=</i></p>

<p style="margin-left:17%;">A shorthand for configuring
both <i>TimeoutStartSec=</i> and <i>TimeoutStopSec=</i> to
the specified value.</p>


<p style="margin-left:11%; margin-top: 1em"><i>TimeoutStartFailureMode=</i>,
<i>TimeoutStopFailureMode=</i></p>

<p style="margin-left:17%;">These options configure the
action that is taken in case a daemon service does not
signal start&minus;up within its configured
<i>TimeoutStartSec=</i>, respectively if it does not stop
within <i>TimeoutStopSec=</i>. Takes one of
<b>terminate</b>, <b>abort</b> and <b>kill</b>. Both options
default to <b>terminate</b>.</p>

<p style="margin-left:17%; margin-top: 1em">If
<b>terminate</b> is set the service will be gracefully
terminated by sending the signal specified in
<i>KillSignal=</i> (defaults to <b>SIGTERM</b>, see
<b>systemd.kill</b>(5)). If the service does not terminate
the <i>FinalKillSignal=</i> is sent after
<i>TimeoutStopSec=</i>. If <b>abort</b> is set,
<i>WatchdogSignal=</i> is sent instead and
<i>TimeoutAbortSec=</i> applies before sending
<i>FinalKillSignal=</i>. This setting may be used to analyze
services that fail to start&minus;up or shut&minus;down
intermittently. By using <b>kill</b> the service is
immediately terminated by sending <i>FinalKillSignal=</i>
without any further timeout. This setting can be used to
expedite the shutdown of failing services.</p>


<p style="margin-left:11%; margin-top: 1em"><i>RuntimeMaxSec=</i></p>

<p style="margin-left:17%;">Configures a maximum time for
the service to run. If this is used and the service has been
active for longer than the specified time it is terminated
and put into a failure state. Note that this setting does
not have any effect on <i>Type=oneshot</i> services, as they
terminate immediately after activation completed. Pass
&quot;infinity&quot; (the default) to configure no runtime
limit.</p>

<p style="margin-left:17%; margin-top: 1em">If a service of
<i>Type=notify</i>/<i>Type=notify&minus;reload</i> sends
&quot;EXTEND_TIMEOUT_USEC=...&quot;, this may cause the
runtime to be extended beyond <i>RuntimeMaxSec=</i>. The
first receipt of this message must occur before
<i>RuntimeMaxSec=</i> is exceeded, and once the runtime has
extended beyond <i>RuntimeMaxSec=</i>, the service manager
will allow the service to continue to run, provided the
service repeats &quot;EXTEND_TIMEOUT_USEC=...&quot; within
the interval specified until the service shutdown is
achieved by &quot;STOPPING=1&quot; (or termination). (see
<b>sd_notify</b>(3)).</p>


<p style="margin-left:11%; margin-top: 1em"><i>RuntimeRandomizedExtraSec=</i></p>

<p style="margin-left:17%;">This option modifies
<i>RuntimeMaxSec=</i> by increasing the maximum runtime by
an evenly distributed duration between 0 and the specified
value (in seconds). If <i>RuntimeMaxSec=</i> is unspecified,
then this feature will be disabled.</p>


<p style="margin-left:11%; margin-top: 1em"><i>WatchdogSec=</i></p>

<p style="margin-left:17%;">Configures the watchdog timeout
for a service. The watchdog is activated when the
start&minus;up is completed. The service must call
<b>sd_notify</b>(3) regularly with &quot;WATCHDOG=1&quot;
(i.e. the &quot;keep&minus;alive ping&quot;). If the time
between two such calls is larger than the configured time,
then the service is placed in a failed state and it will be
terminated with <b>SIGABRT</b> (or the signal specified by
<i>WatchdogSignal=</i>). By setting <i>Restart=</i> to
<b>on&minus;failure</b>, <b>on&minus;watchdog</b>,
<b>on&minus;abnormal</b> or <b>always</b>, the service will
be automatically restarted. The time configured here will be
passed to the executed service process in the
<i>WATCHDOG_USEC=</i> environment variable. This allows
daemons to automatically enable the keep&minus;alive pinging
logic if watchdog support is enabled for the service. If
this option is used, <i>NotifyAccess=</i> (see below) should
be set to open access to the notification socket provided by
systemd. If <i>NotifyAccess=</i> is not set, it will be
implicitly set to <b>main</b>. Defaults to 0, which disables
this feature. The service can check whether the service
manager expects watchdog keep&minus;alive notifications. See
<b>sd_watchdog_enabled</b>(3) for details.
<b>sd_event_set_watchdog</b>(3) may be used to enable
automatic watchdog notification support.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Restart=</i></p>

<p style="margin-left:17%;">Configures whether the service
shall be restarted when the service process exits, is
killed, or a timeout is reached. The service process may be
the main service process, but it may also be one of the
processes specified with <i>ExecStartPre=</i>,
<i>ExecStartPost=</i>, <i>ExecStop=</i>,
<i>ExecStopPost=</i>, or <i>ExecReload=</i>. When the death
of the process is a result of systemd operation (e.g.
service stop or restart), the service will not be restarted.
Timeouts include missing the watchdog &quot;keep&minus;alive
ping&quot; deadline and a service start, reload, and stop
operation timeouts.</p>

<p style="margin-left:17%; margin-top: 1em">Takes one of
<b>no</b>, <b>on&minus;success</b>, <b>on&minus;failure</b>,
<b>on&minus;abnormal</b>, <b>on&minus;watchdog</b>,
<b>on&minus;abort</b>, or <b>always</b>. If set to <b>no</b>
(the default), the service will not be restarted. If set to
<b>on&minus;success</b>, it will be restarted only when the
service process exits cleanly. In this context, a clean exit
means any of the following:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; exit
code of 0;</p>

<p style="margin-left:23%; margin-top: 1em">&bull; for
types other than <i>Type=oneshot</i>, one of the signals
<b>SIGHUP</b>, <b>SIGINT</b>, <b>SIGTERM</b>, or
<b>SIGPIPE</b>;</p>

<p style="margin-left:23%; margin-top: 1em">&bull; exit
statuses and signals specified in
<i>SuccessExitStatus=</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If set to
<b>on&minus;failure</b>, the service will be restarted when
the process exits with a non&minus;zero exit code, is
terminated by a signal (including on core dump, but
excluding the aforementioned four signals), when an
operation (such as service reload) times out, and when the
configured watchdog timeout is triggered. If set to
<b>on&minus;abnormal</b>, the service will be restarted when
the process is terminated by a signal (including on core
dump, excluding the aforementioned four signals), when an
operation times out, or when the watchdog timeout is
triggered. If set to <b>on&minus;abort</b>, the service will
be restarted only if the service process exits due to an
uncaught signal not specified as a clean exit status. If set
to <b>on&minus;watchdog</b>, the service will be restarted
only if the watchdog timeout for the service expires. If set
to <b>always</b>, the service will be restarted regardless
of whether it exited cleanly or not, got terminated
abnormally by a signal, or hit a timeout.</p>


<p style="margin-left:17%; margin-top: 1em"><b>Table&nbsp;2.&nbsp;Exit
causes and the effect of the</b> <i>Restart=</i> settings
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;</p>


<p align="center"><img src="grohtml-35853962.png" alt="Image grohtml-35853962.png"></p>

<p style="margin-left:17%;">As exceptions to the setting
above, the service will not be restarted if the exit code or
signal is specified in <i>RestartPreventExitStatus=</i> (see
below) or the service is stopped with <b>systemctl stop</b>
or an equivalent operation. Also, the services will always
be restarted if the exit code or signal is specified in
<i>RestartForceExitStatus=</i> (see below).</p>

<p style="margin-left:17%; margin-top: 1em">Note that
service restart is subject to unit start rate limiting
configured with <i>StartLimitIntervalSec=</i> and
<i>StartLimitBurst=</i>, see <b>systemd.unit</b>(5) for
details. A restarted service enters the failed state only
after the start limits are reached.</p>

<p style="margin-left:17%; margin-top: 1em">Setting this to
<b>on&minus;failure</b> is the recommended choice for
long&minus;running services, in order to increase
reliability by attempting automatic recovery from errors.
For services that shall be able to terminate on their own
choice (and avoid immediate restarting),
<b>on&minus;abnormal</b> is an alternative choice.</p>


<p style="margin-left:11%; margin-top: 1em"><i>SuccessExitStatus=</i></p>

<p style="margin-left:17%;">Takes a list of exit status
definitions that, when returned by the main service process,
will be considered successful termination, in addition to
the normal successful exit status 0 and, except for
<i>Type=oneshot</i>, the signals <b>SIGHUP</b>,
<b>SIGINT</b>, <b>SIGTERM</b>, and <b>SIGPIPE</b>. Exit
status definitions can be numeric termination statuses,
termination status names, or termination signal names,
separated by spaces. See the Process Exit Codes section in
<b>systemd.exec</b>(5) for a list of termination status
names (for this setting only the part without the
&quot;EXIT_&quot; or &quot;EX_&quot; prefix should be used).
See <b>signal</b>(7) for a list of signal names.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
setting does not change the mapping between numeric exit
statuses and their names, i.e. regardless how this setting
is used 0 will still be mapped to &quot;SUCCESS&quot; (and
thus typically shown as &quot;0/SUCCESS&quot; in tool
outputs) and 1 to &quot;FAILURE&quot; (and thus typically
shown as &quot;1/FAILURE&quot;), and so on. It only controls
what happens as effect of these exit statuses, and how it
propagates to the state of the service as a whole.</p>

<p style="margin-left:17%; margin-top: 1em">This option may
appear more than once, in which case the list of successful
exit statuses is merged. If the empty string is assigned to
this option, the list is reset, all prior assignments of
this option will have no effect.</p>


<p style="margin-left:17%; margin-top: 1em"><b>Example&nbsp;1.&nbsp;A
service with the</b> <i>SuccessExitStatus=</i> setting</p>


<p style="margin-left:23%; margin-top: 1em">SuccessExitStatus=TEMPFAIL
250 SIGKILL</p>

<p style="margin-left:17%; margin-top: 1em">Exit status 75
(<b>TEMPFAIL</b>), 250, and the termination signal
<b>SIGKILL</b> are considered clean service
terminations.</p>

<p style="margin-left:17%; margin-top: 1em">Note:
<b>systemd&minus;analyze exit&minus;status</b> may be used
to list exit statuses and translate between numerical status
values and names.</p>


<p style="margin-left:11%; margin-top: 1em"><i>RestartPreventExitStatus=</i></p>

<p style="margin-left:17%;">Takes a list of exit status
definitions that, when returned by the main service process,
will prevent automatic service restarts, regardless of the
restart setting configured with <i>Restart=</i>. Exit status
definitions can either be numeric exit codes or termination
signal names, and are separated by spaces. Defaults to the
empty list, so that, by default, no exit status is excluded
from the configured restart logic. For example:</p>


<p style="margin-left:23%; margin-top: 1em">RestartPreventExitStatus=1
6 SIGABRT</p>

<p style="margin-left:17%; margin-top: 1em">ensures that
exit codes 1 and 6 and the termination signal <b>SIGABRT</b>
will not result in automatic service restarting. This option
may appear more than once, in which case the list of
restart&minus;preventing statuses is merged. If the empty
string is assigned to this option, the list is reset and all
prior assignments of this option will have no effect.</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
setting has no effect on processes configured via
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecStop=</i>, <i>ExecStopPost=</i> or
<i>ExecReload=</i>, but only on the main service process,
i.e. either the one invoked by <i>ExecStart=</i> or
(depending on <i>Type=</i>, <i>PIDFile=</i>, ...) the
otherwise configured main process.</p>


<p style="margin-left:11%; margin-top: 1em"><i>RestartForceExitStatus=</i></p>

<p style="margin-left:17%;">Takes a list of exit status
definitions that, when returned by the main service process,
will force automatic service restarts, regardless of the
restart setting configured with <i>Restart=</i>. The
argument format is similar to
<i>RestartPreventExitStatus=</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>RootDirectoryStartOnly=</i></p>

<p style="margin-left:17%;">Takes a boolean argument. If
true, the root directory, as configured with the
<i>RootDirectory=</i> option (see <b>systemd.exec</b>(5) for
more information), is only applied to the process started
with <i>ExecStart=</i>, and not to the various other
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecReload=</i>, <i>ExecStop=</i>, and
<i>ExecStopPost=</i> commands. If false, the setting is
applied to all configured commands the same way. Defaults to
false.</p>


<p style="margin-left:11%; margin-top: 1em"><i>NonBlocking=</i></p>

<p style="margin-left:17%;">Set the <b>O_NONBLOCK</b> flag
for all file descriptors passed via socket&minus;based
activation. If true, all file descriptors &gt;= 3 (i.e. all
except stdin, stdout, stderr), excluding those passed in via
the file descriptor storage logic (see
<i>FileDescriptorStoreMax=</i> for details), will have the
<b>O_NONBLOCK</b> flag set and hence are in
non&minus;blocking mode. This option is only useful in
conjunction with a socket unit, as described in
<b>systemd.socket</b>(5) and has no effect on file
descriptors which were previously saved in the
file&minus;descriptor store for example. Defaults to
false.</p>


<p style="margin-left:11%; margin-top: 1em"><i>NotifyAccess=</i></p>

<p style="margin-left:17%;">Controls access to the service
status notification socket, as accessible via the
<b>sd_notify</b>(3) call. Takes one of <b>none</b> (the
default), <b>main</b>, <b>exec</b> or <b>all</b>. If
<b>none</b>, no daemon status updates are accepted from the
service processes, all status update messages are ignored.
If <b>main</b>, only service updates sent from the main
process of the service are accepted. If <b>exec</b>, only
service updates sent from any of the main or control
processes originating from one of the <i>Exec*=</i> commands
are accepted. If <b>all</b>, all services updates from all
members of the service's control group are accepted. This
option should be set to open access to the notification
socket when using
<i>Type=notify</i>/<i>Type=notify&minus;reload</i> or
<i>WatchdogSec=</i> (see above). If those options are used
but <i>NotifyAccess=</i> is not configured, it will be
implicitly set to <b>main</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<b>sd_notify()</b> notifications may be attributed to units
correctly only if either the sending process is still around
at the time PID 1 processes the message, or if the sending
process is explicitly runtime&minus;tracked by the service
manager. The latter is the case if the service manager
originally forked off the process, i.e. on all processes
that match <b>main</b> or <b>exec</b>. Conversely, if an
auxiliary process of the unit sends an <b>sd_notify()</b>
message and immediately exits, the service manager might not
be able to properly attribute the message to the unit, and
thus will ignore it, even if <i>NotifyAccess=</i><b>all</b>
is set for it.</p>

<p style="margin-left:17%; margin-top: 1em">Hence, to
eliminate all race conditions involving lookup of the
client's unit and attribution of notifications to units
correctly, <b>sd_notify_barrier()</b> may be used. This call
acts as a synchronization point and ensures all
notifications sent before this call have been picked up by
the service manager when it returns successfully. Use of
<b>sd_notify_barrier()</b> is needed for clients which are
not invoked by the service manager, otherwise this
synchronization mechanism is unnecessary for attribution of
notifications to the unit.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Sockets=</i></p>

<p style="margin-left:17%;">Specifies the name of the
socket units this service shall inherit socket file
descriptors from when the service is started. Normally, it
should not be necessary to use this setting, as all socket
file descriptors whose unit shares the same name as the
service (subject to the different unit name suffix of
course) are passed to the spawned process.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
same socket file descriptors may be passed to multiple
processes simultaneously. Also note that a different service
may be activated on incoming socket traffic than the one
which is ultimately configured to inherit the socket file
descriptors. Or, in other words: the <i>Service=</i> setting
of .socket units does not have to match the inverse of the
<i>Sockets=</i> setting of the .service it refers to.</p>

<p style="margin-left:17%; margin-top: 1em">This option may
appear more than once, in which case the list of socket
units is merged. Note that once set, clearing the list of
sockets again (for example, by assigning the empty string to
this option) is not supported.</p>


<p style="margin-left:11%; margin-top: 1em"><i>FileDescriptorStoreMax=</i></p>

<p style="margin-left:17%;">Configure how many file
descriptors may be stored in the service manager for the
service using <b>sd_pid_notify_with_fds</b>(3)'s
&quot;FDSTORE=1&quot; messages. This is useful for
implementing services that can restart after an explicit
request or a crash without losing state. Any open sockets
and other file descriptors which should not be closed during
the restart may be stored this way. Application state can
either be serialized to a file in /run/, or better, stored
in a <b>memfd_create</b>(2) memory file descriptor. Defaults
to 0, i.e. no file descriptors may be stored in the service
manager. All file descriptors passed to the service manager
from a specific service are passed back to the service's
main process on the next service restart (see
<b>sd_listen_fds</b>(3) for details about the precise
protocol used and the order in which the file descriptors
are passed). Any file descriptors passed to the service
manager are automatically closed when <b>POLLHUP</b> or
<b>POLLERR</b> is seen on them, or when the service is fully
stopped and no job is queued or being executed for it. If
this option is used, <i>NotifyAccess=</i> (see above) should
be set to open access to the notification socket provided by
systemd. If <i>NotifyAccess=</i> is not set, it will be
implicitly set to <b>main</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>USBFunctionDescriptors=</i></p>

<p style="margin-left:17%;">Configure the location of a
file containing <b><font color="#0000FF">USB
FunctionFS</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">descriptors, for implementation of USB
gadget functions. This is used only in conjunction with a
socket unit with <i>ListenUSBFunction=</i> configured. The
contents of this file are written to the ep0 file after it
is opened.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>USBFunctionStrings=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the location of a file containing USB FunctionFS strings.
Behavior is similar to <i>USBFunctionDescriptors=</i>
above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>OOMPolicy=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the out&minus;of&minus;memory (OOM) killing policy for the
kernel and the userspace OOM killer
<b>systemd-oomd.service</b>(8). On Linux, when memory
becomes scarce to the point that the kernel has trouble
allocating memory for itself, it might decide to kill a
running process in order to free up memory and reduce memory
pressure. Note that systemd&minus;oomd.service is a more
flexible solution that aims to prevent
out&minus;of&minus;memory situations for the userspace too,
not just the kernel, by attempting to terminate services
earlier, before the kernel would have to act.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
setting takes one of <b>continue</b>, <b>stop</b> or
<b>kill</b>. If set to <b>continue</b> and a process in the
unit is killed by the OOM killer, this is logged but the
unit continues running. If set to <b>stop</b> the event is
logged but the unit is terminated cleanly by the service
manager. If set to <b>kill</b> and one of the unit's
processes is killed by the OOM killer the kernel is
instructed to kill all remaining processes of the unit too,
by setting the memory.oom.group attribute to <b>1</b>; also
see</font> <b><font color="#0000FF">kernel
documentation</font></b>
<small><font color="#000000">[2]</font></small>
<font color="#000000">.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Defaults
to the setting <i>DefaultOOMPolicy=</i> in
<b>systemd-system.conf</b>(5) is set to, except for units
where <i>Delegate=</i> is turned on, where it defaults to
<b>continue</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Use
the <i>OOMScoreAdjust=</i> setting to configure whether
processes of the unit shall be considered preferred or less
preferred candidates for process termination by the Linux
OOM killer logic. See <b>systemd.exec</b>(5) for
details.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
setting also applies to <b>systemd&minus;oomd</b>. Similarly
to the kernel OOM kills, this setting determines the state
of the unit after <b>systemd&minus;oomd</b> kills a cgroup
associated with it.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>OpenFile=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes an
argument of the form
&quot;path[<i>:fd&minus;name:options</i>]&quot;,
where:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
&quot;path&quot; is a path to a file or an <b>AF_UNIX</b>
socket in the file system;</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
&quot;fd&minus;name&quot; is a name that will be associated
with the file descriptor; the name may contain any ASCII
character, but must exclude control characters and
&quot;:&quot;, and must be at most 255 characters in length;
it is optional and, if not provided, defaults to the file
name;</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
&quot;options&quot; is a comma&minus;separated list of
access options; possible values are
&quot;read&minus;only&quot;, &quot;append&quot;,
&quot;truncate&quot;, &quot;graceful&quot;; if not
specified, files will be opened in <b>rw</b> mode; if
&quot;graceful&quot; is specified, errors during file/socket
opening are ignored. Specifying the same option several
times is treated as an error.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
file or socket is opened by the service manager and the file
descriptor is passed to the service. If the path is a
socket, we call <b>connect()</b> on it. See
<b>sd_listen_fds</b>(3) for more details on how to retrieve
these file descriptors.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
setting is useful to allow services to access files/sockets
that they can't access themselves (due to running in a
separate mount namespace, not having privileges,
...).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
setting can be specified multiple times, in which case all
the specified paths are opened and the file descriptors
passed to the service. If the empty string is assigned, the
entire list of open files defined prior to this is
reset.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ReloadSignal=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
the UNIX process signal to send to the service's main
process when asked to reload the service's configuration.
Defaults to <b>SIGHUP</b>. This option has no effect unless
<i>Type=</i><b>notify&minus;reload</b> is used, see
above.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Check
<b>systemd.unit</b>(5), <b>systemd.exec</b>(5), and
<b>systemd.kill</b>(5) for more settings.</font></p>

<h2>COMMAND LINES
<a name="COMMAND LINES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
section describes command line parsing and variable and
specifier substitutions for <i>ExecStart=</i>,
<i>ExecStartPre=</i>, <i>ExecStartPost=</i>,
<i>ExecReload=</i>, <i>ExecStop=</i>, and
<i>ExecStopPost=</i> options.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Multiple
command lines may be concatenated in a single directive by
separating them with semicolons (these semicolons must be
passed as separate words). Lone semicolons may be escaped as
&quot;\;&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Each
command line is unquoted using the rules described in
&quot;Quoting&quot; section in <b>systemd.syntax</b>(7). The
first item becomes the command to execute, and the
subsequent items the arguments.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
syntax is inspired by shell syntax, but only the
meta&minus;characters and expansions described in the
following paragraphs are understood, and the expansion of
variables is different. Specifically, redirection using
&quot;&lt;&quot;, &quot;&lt;&lt;&quot;, &quot;&gt;&quot;,
and &quot;&gt;&gt;&quot;, pipes using &quot;|&quot;, running
programs in the background using &quot;&amp;&quot;, and
<i>other elements of shell syntax are not
supported</i>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
command to execute may contain spaces, but control
characters are not allowed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
command line accepts &quot;%&quot; specifiers as described
in <b>systemd.unit</b>(5).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Basic
environment variable substitution is supported. Use
&quot;${FOO}&quot; as part of a word, or as a word of its
own, on the command line, in which case it will be erased
and replaced by the exact value of the environment variable
(if any) including all whitespace it contains, always
resulting in exactly a single argument. Use &quot;$FOO&quot;
as a separate word on the command line, in which case it
will be replaced by the value of the environment variable
split at whitespace, resulting in zero or more arguments.
For this type of expansion, quotes are respected when
splitting into words, and afterwards removed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">If
the command is not a full (absolute) path, it will be
resolved to a full path using a fixed search path determined
at compilation time. Searched directories include
/usr/local/bin/, /usr/bin/, /bin/ on systems using split
/usr/bin/ and /bin/ directories, and their sbin/
counterparts on systems using split bin/ and sbin/. It is
thus safe to use just the executable name in case of
executables located in any of the &quot;standard&quot;
directories, and an absolute path must be used in other
cases. Using an absolute path is recommended to avoid
ambiguity. Hint: this search path may be queried using
<b>systemd&minus;path
search&minus;binaries&minus;default</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Environment=&quot;ONE=one&quot;
'TWO=two two' <br>
ExecStart=echo $ONE $TWO ${TWO}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>/bin/echo</b> with four arguments:
&quot;one&quot;, &quot;two&quot;, &quot;two&quot;, and
&quot;two two&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Environment=ONE='one'
&quot;TWO='two&nbsp;two'&nbsp;too&quot; THREE= <br>
ExecStart=/bin/echo ${ONE} ${TWO} ${THREE} <br>
ExecStart=/bin/echo $ONE $TWO $THREE</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
results in /bin/echo being called twice, the first time with
arguments &quot;'one'&quot;,
&quot;'two&nbsp;two'&nbsp;too&quot;, &quot;&quot;, and the
second time with arguments &quot;one&quot;,
&quot;two&nbsp;two&quot;, &quot;too&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">To
pass a literal dollar sign, use &quot;$$&quot;. Variables
whose value is not known at expansion time are treated as
empty strings. Note that the first argument (i.e. the
program to execute) may not be a variable.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Variables
to be used in this fashion may be defined through
<i>Environment=</i> and <i>EnvironmentFile=</i>. In
addition, variables listed in the section &quot;Environment
variables in spawned processes&quot; in
<b>systemd.exec</b>(5), which are considered &quot;static
configuration&quot;, may be used (this includes e.g.
<i>$USER</i>, but not <i>$TERM</i>).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that shell command lines are not directly supported. If
shell command lines are to be used, they need to be passed
explicitly to a shell implementation of some kind.
Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=sh
&minus;c 'dmesg | tac'</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=echo
one ; echo &quot;two two&quot;</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>echo</b> two times, each time with one
argument: &quot;one&quot; and &quot;two two&quot;,
respectively. Because two commands are specified,
<i>Type=oneshot</i> must be used.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">ExecStart=echo
/ &gt;/dev/null &amp; \; \ <br>
ls</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
will execute <b>echo</b> with five arguments: &quot;/&quot;,
&quot;&gt;/dev/null&quot;, &quot;&amp;&quot;, &quot;;&quot;,
and &quot;ls&quot;.</font></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;2.&nbsp;Simple
service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following unit file creates a service that will execute
/usr/sbin/foo&minus;daemon. Since no <i>Type=</i> is
specified, the default <i>Type=</i><b>simple</b> will be
assumed. systemd will assume the unit to be started
immediately after the program has begun
executing.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Foo</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
ExecStart=/usr/sbin/foo&minus;daemon</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that systemd assumes here that the process started by
systemd will continue running until the service terminates.
If the program daemonizes itself (i.e. forks), please use
<i>Type=</i><b>forking</b> instead.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Since
no <i>ExecStop=</i> was specified, systemd will send SIGTERM
to all processes started from this service, and after a
timeout also SIGKILL. This behavior can be modified, see
<b>systemd.kill</b>(5) for details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that this unit type does not include any type of
notification when a service has completed initialization.
For this, you should use other unit types, such as
<i>Type=</i><b>notify</b>/<i>Type=</i><b>notify&minus;reload</b>
if the service understands systemd's notification protocol,
<i>Type=</i><b>forking</b> if the service can background
itself or <i>Type=</i><b>dbus</b> if the unit acquires a
DBus name once initialization is complete. See
below.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;3.&nbsp;Oneshot
service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Sometimes,
units should just execute an action without keeping active
processes, such as a filesystem check or a cleanup action on
boot. For this, <i>Type=</i><b>oneshot</b> exists. Units of
this type will wait until the process specified terminates
and then fall back to being inactive. The following unit
will perform a cleanup action:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Cleanup old Foo data</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=oneshot <br>
ExecStart=/usr/sbin/foo&minus;cleanup</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that systemd will consider the unit to be in the state
&quot;starting&quot; until the program has terminated, so
ordered dependencies will wait for the program to finish
before starting themselves. The unit will revert to the
&quot;inactive&quot; state after the execution is done,
never reaching the &quot;active&quot; state. That means
another request to start the unit will perform the action
again.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Type=</i><b>oneshot</b>
are the only service units that may have more than one
<i>ExecStart=</i> specified. For units with multiple
commands (<i>Type=oneshot</i>), all commands will be run
again.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
<i>Type=oneshot</i>, <i>Restart=</i><b>always</b> and
<i>Restart=</i><b>on&minus;success</b> are <i>not</i>
allowed.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;4.&nbsp;Stoppable
oneshot service</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Similarly
to the oneshot services, there are sometimes units that need
to execute a program to set up something and then execute
another to shut it down, but no process remains active while
they are considered &quot;started&quot;. Network
configuration can sometimes fall into this category. Another
use case is if a oneshot service shall not be executed each
time when they are pulled in as a dependency, but only the
first time.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
this, systemd knows the setting
<i>RemainAfterExit=</i><b>yes</b>, which causes systemd to
consider the unit to be active if the start action exited
successfully. This directive can be used with all types, but
is most useful with <i>Type=</i><b>oneshot</b> and
<i>Type=</i><b>simple</b>. With <i>Type=</i><b>oneshot</b>,
systemd waits until the start action has completed before it
considers the unit to be active, so dependencies start only
after the start action has succeeded. With
<i>Type=</i><b>simple</b>, dependencies will start
immediately after the start action has been dispatched. The
following unit provides an example for a simple static
firewall.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple firewall</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=oneshot <br>
RemainAfterExit=yes <br>
ExecStart=/usr/local/sbin/simple&minus;firewall&minus;start
<br>

ExecStop=/usr/local/sbin/simple&minus;firewall&minus;stop</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Since
the unit is considered to be running after the start action
has exited, invoking <b>systemctl start</b> on that unit
again will cause no action to be taken.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;5.&nbsp;Traditional
forking services</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Many
traditional daemons/services background (i.e. fork,
daemonize) themselves when starting. Set
<i>Type=</i><b>forking</b> in the service's unit file to
support this mode of operation. systemd will consider the
service to be in the process of initialization while the
original program is still running. Once it exits
successfully and at least a process remains (and
<i>RemainAfterExit=</i><b>no</b>), the service is considered
started.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Often,
a traditional daemon only consists of one process.
Therefore, if only one process is left after the original
process terminates, systemd will consider that process the
main process of the service. In that case, the
<i>$MAINPID</i> variable will be available in
<i>ExecReload=</i>, <i>ExecStop=</i>, etc.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">In
case more than one process remains, systemd will be unable
to determine the main process, so it will not assume there
is one. In that case, <i>$MAINPID</i> will not expand to
anything. However, if the process decides to write a
traditional PID file, systemd will be able to read the main
PID from there. Please set <i>PIDFile=</i> accordingly. Note
that the daemon should write that file before finishing with
its initialization. Otherwise, systemd might try to read the
file before it exists.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following example shows a simple daemon that forks and just
starts one process in the background:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Some simple daemon</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=forking <br>
ExecStart=/usr/sbin/my&minus;simple&minus;daemon
&minus;d</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;6.&nbsp;DBus
services</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
services that acquire a name on the DBus system bus, use
<i>Type=</i><b>dbus</b> and set <i>BusName=</i> accordingly.
The service should not fork (daemonize). systemd will
consider the service to be initialized once the name has
been acquired on the system bus. The following example shows
a typical DBus service:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple DBus service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=dbus <br>
BusName=org.example.simple&minus;dbus&minus;service <br>

ExecStart=/usr/sbin/simple&minus;dbus&minus;service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
<i>bus&minus;activatable</i> services, do not include a
[Install] section in the systemd service file, but use the
<i>SystemdService=</i> option in the corresponding DBus
service file, for example
(/usr/share/dbus&minus;1/system&minus;services/org.example.simple&minus;dbus&minus;service.service):</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[D&minus;BUS
Service] <br>
Name=org.example.simple&minus;dbus&minus;service <br>
Exec=/usr/sbin/simple&minus;dbus&minus;service <br>
User=root <br>

SystemdService=simple&minus;dbus&minus;service.service</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;7.&nbsp;Services
that notify systemd about their
initialization</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Type=</i><b>simple</b>
services are really easy to write, but have the major
disadvantage of systemd not being able to tell when
initialization of the given service is complete. For this
reason, systemd supports a simple notification protocol that
allows daemons to make systemd aware that they are done
initializing. Use <i>Type=</i><b>notify</b> or
<i>Type=</i><b>notify&minus;reload</b> for this. A typical
service file for such a daemon would look like
this:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Simple notifying service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=notify <br>

ExecStart=/usr/sbin/simple&minus;notifying&minus;service</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that the daemon has to support systemd's notification
protocol, else systemd will think the service has not
started yet and kill it after a timeout. For an example of
how to update daemons to support this protocol
transparently, take a look at <b>sd_notify</b>(3). systemd
will consider the unit to be in the 'starting' state until a
readiness notification has arrived.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Please
see <b>systemd.kill</b>(5) for details on how you can
influence the way systemd terminates the service.</font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>systemd</b>(1),
<b>systemctl</b>(1), <b>systemd-system.conf</b>(5),
<b>systemd.unit</b>(5), <b>systemd.exec</b>(5),
<b>systemd.resource-control</b>(5), <b>systemd.kill</b>(5),
<b>systemd.directives</b>(7),
<b>systemd-run</b>(1)</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="21%">


<p style="margin-top: 1em"><font color="#000000">USB
FunctionFS</font></p> </td>
<td width="62%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://docs.kernel.org/usb/functionfs.html</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">2.</font></p> </td>
<td width="2%"></td>
<td width="31%">


<p style="margin-top: 1em"><font color="#000000">kernel
documentation</font></p> </td>
<td width="52%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://docs.kernel.org/admin-guide/cgroup-v2.html</font></p>
<hr>
</body>
</html>
