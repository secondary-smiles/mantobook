<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:55 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SYSTEMD.UNIT</title>

</head>
<body>
<h1>systemd.unit</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">systemd.unit
&minus; Unit configuration</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>service</i>.service,
<i>socket</i>.socket, <i>device</i>.device,
<i>mount</i>.mount, <i>automount</i>.automount,
<i>swap</i>.swap, <i>target</i>.target, <i>path</i>.path,
<i>timer</i>.timer, <i>slice</i>.slice,
<i>scope</i>.scope</p>

<p style="margin-left:11%; margin-top: 1em"><b>System Unit
Search Path</b> <br>
/etc/systemd/system.control/* <br>
/run/systemd/system.control/* <br>
/run/systemd/transient/* <br>
/run/systemd/generator.early/* <br>
/etc/systemd/system/* <br>
/etc/systemd/system.attached/* <br>
/run/systemd/system/* <br>
/run/systemd/system.attached/* <br>
/run/systemd/generator/* <br>
... <br>
/usr/lib/systemd/system/* <br>
/run/systemd/generator.late/*</p>

<p style="margin-left:11%; margin-top: 1em"><b>User Unit
Search Path</b> <br>
~/.config/systemd/user.control/* <br>
$XDG_RUNTIME_DIR/systemd/user.control/* <br>
$XDG_RUNTIME_DIR/systemd/transient/* <br>
$XDG_RUNTIME_DIR/systemd/generator.early/* <br>
~/.config/systemd/user/* <br>
$XDG_CONFIG_DIRS/systemd/user/* <br>
/etc/systemd/user/* <br>
$XDG_RUNTIME_DIR/systemd/user/* <br>
/run/systemd/user/* <br>
$XDG_RUNTIME_DIR/systemd/generator/* <br>
$XDG_DATA_HOME/systemd/user/* <br>
$XDG_DATA_DIRS/systemd/user/* <br>
... <br>
/usr/lib/systemd/user/* <br>
$XDG_RUNTIME_DIR/systemd/generator.late/*</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A unit file is
a plain text ini&minus;style file that encodes information
about a service, a socket, a device, a mount point, an
automount point, a swap file or partition, a start&minus;up
target, a watched file system path, a timer controlled and
supervised by <b>systemd</b>(1), a resource management slice
or a group of externally created processes. See
<b>systemd.syntax</b>(7) for a general description of the
syntax.</p>

<p style="margin-left:11%; margin-top: 1em">This man page
lists the common configuration options of all the unit
types. These options need to be configured in the [Unit] or
[Install] sections of the unit files.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the generic [Unit] and [Install] sections described here,
each unit may have a type&minus;specific section, e.g.
[Service] for a service unit. See the respective man pages
for more information: <b>systemd.service</b>(5),
<b>systemd.socket</b>(5), <b>systemd.device</b>(5),
<b>systemd.mount</b>(5), <b>systemd.automount</b>(5),
<b>systemd.swap</b>(5), <b>systemd.target</b>(5),
<b>systemd.path</b>(5), <b>systemd.timer</b>(5),
<b>systemd.slice</b>(5), <b>systemd.scope</b>(5).</p>

<p style="margin-left:11%; margin-top: 1em">Unit files are
loaded from a set of paths determined during compilation,
described in the next section.</p>

<p style="margin-left:11%; margin-top: 1em">Valid unit
names consist of a &quot;unit name prefix&quot;, and a
suffix specifying the unit type which begins with a dot. The
&quot;unit name prefix&quot; must consist of one or more
valid characters (ASCII letters, digits, &quot;:&quot;,
&quot;&minus;&quot;, &quot;_&quot;, &quot;.&quot;, and
&quot;\&quot;). The total length of the unit name including
the suffix must not exceed 255 characters. The unit type
suffix must be one of &quot;.service&quot;,
&quot;.socket&quot;, &quot;.device&quot;,
&quot;.mount&quot;, &quot;.automount&quot;,
&quot;.swap&quot;, &quot;.target&quot;, &quot;.path&quot;,
&quot;.timer&quot;, &quot;.slice&quot;, or
&quot;.scope&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Unit names can
be parameterized by a single argument called the
&quot;instance name&quot;. The unit is then constructed
based on a &quot;template file&quot; which serves as the
definition of multiple services or other units. A template
unit must have a single &quot;@&quot; at the end of the unit
name prefix (right before the type suffix). The name of the
full unit is formed by inserting the instance name between
&quot;@&quot; and the unit type suffix. In the unit file
itself, the instance parameter may be referred to using
&quot;%i&quot; and other specifiers, see below.</p>

<p style="margin-left:11%; margin-top: 1em">Unit files may
contain additional options on top of those listed here. If
systemd encounters an unknown option, it will write a
warning log message but continue loading the unit. If an
option or section name is prefixed with <b>X&minus;</b>, it
is ignored completely by systemd. Options within an ignored
section do not need the prefix. Applications may use this to
include additional information in the unit files. To access
those options, applications need to parse the unit files on
their own.</p>

<p style="margin-left:11%; margin-top: 1em">Units can be
aliased (have an alternative name), by creating a symlink
from the new name to the existing name in one of the unit
search paths. For example, systemd&minus;networkd.service
has the alias dbus&minus;org.freedesktop.network1.service,
created during installation as a symlink, so when
<b>systemd</b> is asked through D&minus;Bus to load
dbus&minus;org.freedesktop.network1.service, it'll load
systemd&minus;networkd.service. As another example,
default.target &mdash; the default system target started at
boot &mdash; is commonly aliased to either
multi&minus;user.target or graphical.target to select what
is started by default. Alias names may be used in commands
like <b>disable</b>, <b>start</b>, <b>stop</b>,
<b>status</b>, and similar, and in all unit dependency
directives, including <i>Wants=</i>, <i>Requires=</i>,
<i>Before=</i>, <i>After=</i>. Aliases cannot be used with
the <b>preset</b> command.</p>

<p style="margin-left:11%; margin-top: 1em">Aliases obey
the following restrictions: a unit of a certain type
(&quot;.service&quot;, &quot;.socket&quot;, ...) can only be
aliased by a name with the same type suffix. A plain unit
(not a template or an instance), may only be aliased by a
plain name. A template instance may only be aliased by
another template instance, and the instance part must be
identical. A template may be aliased by another template (in
which case the alias applies to all instances of the
template). As a special case, a template instance (e.g.
&quot;alias@inst.service&quot;) may be a symlink to
different template (e.g. &quot;template@inst.service&quot;).
In that case, just this specific instance is aliased, while
other instances of the template (e.g.
&quot;alias@foo.service&quot;,
&quot;alias@bar.service&quot;) are not aliased. Those rules
preserve the requirement that the instance (if any) is
always uniquely defined for a given unit and all its
aliases. The target of alias symlink must point to a valid
unit file location, i.e. the symlink target name must match
the symlink source name as described, and the destination
path must be in one of the unit search paths, see UNIT FILE
LOAD PATH section below for more details. Note that the
target file may not exist, i.e. the symlink may be
dangling.</p>

<p style="margin-left:11%; margin-top: 1em">Unit files may
specify aliases through the <i>Alias=</i> directive in the
[Install] section. When the unit is enabled, symlinks will
be created for those names, and removed when the unit is
disabled. For example, reboot.target specifies
<i>Alias=ctrl&minus;alt&minus;del.target</i>, so when
enabled, the symlink
/etc/systemd/system/ctrl&minus;alt&minus;del.service
pointing to the reboot.target file will be created, and when
Ctrl+Alt+Del is invoked, <b>systemd</b> will look for the
ctrl&minus;alt&minus;del.service and execute reboot.service.
<b>systemd</b> does not look at the [Install] section at all
during normal operation, so any directives in that section
only have an effect through the symlinks created during
enablement.</p>

<p style="margin-left:11%; margin-top: 1em">Along with a
unit file foo.service, the directory foo.service.wants/ may
exist. All unit files symlinked from such a directory are
implicitly added as dependencies of type <i>Wants=</i> to
the unit. Similar functionality exists for <i>Requires=</i>
type dependencies as well, the directory suffix is
.requires/ in this case. This functionality is useful to
hook units into the start&minus;up of other units, without
having to modify their unit files. For details about the
semantics of <i>Wants=</i> and <i>Requires=</i>, see below.
The preferred way to create symlinks in the .wants/ or
.requires/ directories is by specifying the dependency in
[Install] section of the target unit, and creating the
symlink in the file system with the <b>enable</b> or
<b>preset</b> commands of <b>systemctl</b>(1). The target
can be a normal unit (either plain or a specific instance of
a template unit). In case when the source unit is a
template, the target can also be a template, in which case
the instance will be &quot;propagated&quot; to the target
unit to form a valid unit instance. The target of symlinks
in .wants/ or .requires/ must thus point to a valid unit
file location, i.e. the symlink target name must satisfy the
described requirements, and the destination path must be in
one of the unit search paths, see UNIT FILE LOAD PATH
section below for more details. Note that the target file
may not exist, i.e. the symlink may be dangling.</p>

<p style="margin-left:11%; margin-top: 1em">Along with a
unit file foo.service, a &quot;drop&minus;in&quot; directory
foo.service.d/ may exist. All files with the suffix
&quot;.conf&quot; from this directory will be merged in the
alphanumeric order and parsed after the main unit file
itself has been parsed. This is useful to alter or add
configuration settings for a unit, without having to modify
unit files. Each drop&minus;in file must contain appropriate
section headers. For instantiated units, this logic will
first look for the instance &quot;.d/&quot; subdirectory
(e.g. &quot;foo@bar.service.d/&quot;) and read its
&quot;.conf&quot; files, followed by the template
&quot;.d/&quot; subdirectory (e.g.
&quot;foo@.service.d/&quot;) and the &quot;.conf&quot; files
there. Moreover for unit names containing dashes
(&quot;&minus;&quot;), the set of directories generated by
repeatedly truncating the unit name after all dashes is
searched too. Specifically, for a unit name
foo&minus;bar&minus;baz.service not only the regular
drop&minus;in directory foo&minus;bar&minus;baz.service.d/
is searched but also both foo&minus;bar&minus;.service.d/
and foo&minus;.service.d/. This is useful for defining
common drop&minus;ins for a set of related units, whose
names begin with a common prefix. This scheme is
particularly useful for mount, automount and slice units,
whose systematic naming structure is built around dashes as
component separators. Note that equally named drop&minus;in
files further down the prefix hierarchy override those
further up, i.e.
foo&minus;bar&minus;.service.d/10&minus;override.conf
overrides foo&minus;.service.d/10&minus;override.conf.</p>

<p style="margin-left:11%; margin-top: 1em">In cases of
unit aliases (described above), dropins for the aliased name
and all aliases are loaded. In the example of default.target
aliasing graphical.target, default.target.d/,
default.target.wants/, default.target.requires/,
graphical.target.d/, graphical.target.wants/,
graphical.target.requires/ would all be read. For templates,
dropins for the template, any template aliases, the template
instance, and all alias instances are read. When just a
specific template instance is aliased, then the dropins for
the target template, the target template instance, and the
alias template instance are read.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
/etc/systemd/system, the drop&minus;in &quot;.d/&quot;
directories for system services can be placed in
/usr/lib/systemd/system or /run/systemd/system directories.
Drop&minus;in files in /etc/ take precedence over those in
/run/ which in turn take precedence over those in /usr/lib/.
Drop&minus;in files under any of these directories take
precedence over unit files wherever located. Multiple
drop&minus;in files with different names are applied in
lexicographic order, regardless of which of the directories
they reside in.</p>

<p style="margin-left:11%; margin-top: 1em">Units also
support a top&minus;level drop&minus;in with <i>type</i>.d/,
where <i>type</i> may be e.g. &quot;service&quot; or
&quot;socket&quot;, that allows altering or adding to the
settings of all corresponding unit files on the system. The
formatting and precedence of applying drop&minus;in
configurations follow what is defined above. Files in
<i>type</i>.d/ have lower precedence compared to files in
name&minus;specific override directories. The usual rules
apply: multiple drop&minus;in files with different names are
applied in lexicographic order, regardless of which of the
directories they reside in, so a file in <i>type</i>.d/
applies to a unit only if there are no drop&minus;ins or
masks with that name in directories with higher precedence.
See Examples.</p>

<p style="margin-left:11%; margin-top: 1em">Note that while
systemd offers a flexible dependency system between units it
is recommended to use this functionality only sparingly and
instead rely on techniques such as bus&minus;based or
socket&minus;based activation which make dependencies
implicit, resulting in a both simpler and more flexible
system.</p>

<p style="margin-left:11%; margin-top: 1em">As mentioned
above, a unit may be instantiated from a template file. This
allows creation of multiple units from a single
configuration file. If systemd looks for a unit
configuration file, it will first search for the literal
unit name in the file system. If that yields no success and
the unit name contains an &quot;@&quot; character, systemd
will look for a unit template that shares the same name but
with the instance string (i.e. the part between the
&quot;@&quot; character and the suffix) removed. Example: if
a service getty@tty3.service is requested and no file by
that name is found, systemd will look for getty@.service and
instantiate a service from that configuration file if it is
found.</p>

<p style="margin-left:11%; margin-top: 1em">To refer to the
instance string from within the configuration file you may
use the special &quot;%i&quot; specifier in many of the
configuration options. See below for details.</p>

<p style="margin-left:11%; margin-top: 1em">If a unit file
is empty (i.e. has the file size 0) or is symlinked to
/dev/null, its configuration will not be loaded and it
appears with a load state of &quot;masked&quot;, and cannot
be activated. Use this as an effective way to fully disable
a unit, making it impossible to start it even manually.</p>

<p style="margin-left:11%; margin-top: 1em">The unit file
format is covered by the <b><font color="#0000FF">Interface
Portability and Stability Promise</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">.</font></p>

<h2>STRING ESCAPING FOR INCLUSION IN UNIT NAMES
<a name="STRING ESCAPING FOR INCLUSION IN UNIT NAMES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Sometimes
it is useful to convert arbitrary strings into unit names.
To facilitate this, a method of string escaping is used, in
order to map strings containing arbitrary byte values
(except <b>NUL</b>) into valid unit names and their
restricted character set. A common special case are unit
names that reflect paths to objects in the file system
hierarchy. Example: a device unit dev&minus;sda.device
refers to a device with the device node /dev/sda in the file
system.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
escaping algorithm operates as follows: given a string, any
&quot;/&quot; character is replaced by &quot;&minus;&quot;,
and all other characters which are not ASCII alphanumerics,
&quot;:&quot;, &quot;_&quot; or &quot;.&quot; are replaced
by C&minus;style &quot;\x2d&quot; escapes. In addition,
&quot;.&quot; is replaced with such a C&minus;style escape
when it would appear as the first character in the escaped
string.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">When
the input qualifies as absolute file system path, this
algorithm is extended slightly: the path to the root
directory &quot;/&quot; is encoded as single dash
&quot;&minus;&quot;. In addition, any leading, trailing or
duplicate &quot;/&quot; characters are removed from the
string before transformation. Example: /foo//bar/baz/
becomes &quot;foo&minus;bar&minus;baz&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
escaping is fully reversible, as long as it is known whether
the escaped string was a path (the unescaping results are
different for paths and non&minus;path strings). The
<b>systemd-escape</b>(1) command may be used to apply and
reverse escaping on arbitrary strings. Use
<b>systemd&minus;escape &minus;&minus;path</b> to escape
path strings, and <b>systemd&minus;escape</b> without
<b>&minus;&minus;path</b> otherwise.</font></p>

<h2>AUTOMATIC DEPENDENCIES
<a name="AUTOMATIC DEPENDENCIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Implicit
Dependencies</b> <br>
A number of unit dependencies are implicitly established,
depending on unit type and unit configuration. These
implicit dependencies can make unit configuration file
cleaner. For the implicit dependencies in each unit type,
please refer to section &quot;Implicit Dependencies&quot; in
respective man pages.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
example, service units with <i>Type=dbus</i> automatically
acquire dependencies of type <i>Requires=</i> and
<i>After=</i> on dbus.socket. See <b>systemd.service</b>(5)
for details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Default
Dependencies</b> <br>
Default dependencies are similar to implicit dependencies,
but can be turned on and off by setting
<i>DefaultDependencies=</i> to <i>yes</i> (the default) and
<i>no</i>, while implicit dependencies are always in effect.
See section &quot;Default Dependencies&quot; in respective
man pages for the effect of enabling
<i>DefaultDependencies=</i> in each unit types.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">For
example, target units will complement all configured
dependencies of type <i>Wants=</i> or <i>Requires=</i> with
dependencies of type <i>After=</i>. See
<b>systemd.target</b>(5) for details. Note that this
behavior can be opted out by setting
<i>DefaultDependencies=no</i> in the specified units, or it
can be selectively overridden via an explicit <i>Before=</i>
dependency.</font></p>

<h2>UNIT FILE LOAD PATH
<a name="UNIT FILE LOAD PATH"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Unit
files are loaded from a set of paths determined during
compilation, described in the two tables below. Unit files
found in directories listed earlier override files with the
same name in directories lower in the list.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">When
the variable <i>$SYSTEMD_UNIT_PATH</i> is set, the contents
of this variable overrides the unit load path. If
<i>$SYSTEMD_UNIT_PATH</i> ends with an empty component
(&quot;:&quot;), the usual unit load path will be appended
to the contents of the variable.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Table&nbsp;1.&nbsp;
Load path when running in system mode
(&minus;&minus;system).</b></font></p>


<p align="center"><font color="#000000"><b><img src="grohtml-35855161.png" alt="Image grohtml-35855161.png"></b></font></p>


<p style="margin-left:11%;"><font color="#000000"><b>Table&nbsp;2.&nbsp;
Load path when running in user mode
(&minus;&minus;user).</b></font></p>


<p align="center"><font color="#000000"><b><img src="grohtml-35855162.png" alt="Image grohtml-35855162.png"></b></font></p>

<p style="margin-left:11%;"><font color="#000000">The set
of load paths for the user manager instance may be augmented
or changed using various environment variables. And
environment variables may in turn be set using environment
generators, see <b>systemd.environment-generator</b>(7). In
particular, <i>$XDG_DATA_HOME</i> and <i>$XDG_DATA_DIRS</i>
may be easily set using
<b>systemd-environment-d-generator</b>(8). Thus, directories
listed here are just the defaults. To see the actual list
that would be used based on compilation options and current
environment use</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">systemd&minus;analyze
&minus;&minus;user unit&minus;paths</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Moreover,
additional units might be loaded into systemd from
directories not on the unit load path by creating a symlink
pointing to a unit file in the directories. You can use
<b>systemctl link</b> for this; see <b>systemctl</b>(1). The
file system where the linked unit files are located must be
accessible when systemd is started (e.g. anything underneath
/home/ or /var/ is not allowed, unless those directories are
located on the root file system).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">It
is important to distinguish &quot;linked unit files&quot;
from &quot;unit file aliases&quot;: any symlink where the
symlink <i>target</i> is within the unit load path becomes
an alias: the source name and the target file name must
satisfy specific constraints listed above in the discussion
of aliases, but the symlink target doesn't have to exist,
and in fact the symlink target path is not used, except to
check whether the target is within the unit load path. In
contrast, a symlink which goes outside of the unit load path
signifies a linked unit file. The symlink is followed when
loading the file, but the destination name is otherwise
unused (and may even not be a valid unit file name). For
example, symlinks /etc/systemd/system/alias1.service &acirc;
service1.service, /etc/systemd/system/alias2.service &acirc;
/usr/lib/systemd/service1.service,
/etc/systemd/system/alias3.service &acirc;
/etc/systemd/system/service1.service are all valid aliases
and service1.service will have four names, even if the unit
file is located at /run/systemd/system/service1.service. In
contrast, a symlink /etc/systemd/system/link1.service
&acirc; ../link1_service_file means that link1.service is a
&quot;linked unit&quot; and the contents of
/etc/systemd/link1_service_file provide its
configuration.</font></p>

<h2>UNIT GARBAGE COLLECTION
<a name="UNIT GARBAGE COLLECTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
system and service manager loads a unit's configuration
automatically when a unit is referenced for the first time.
It will automatically unload the unit configuration and
state again when the unit is not needed anymore
(&quot;garbage collection&quot;). A unit may be referenced
through a number of different mechanisms:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">1.
Another loaded unit references it with a dependency such as
<i>After=</i>, <i>Wants=</i>, ...</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">2.
The unit is currently starting, running, reloading or
stopping.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">3.
The unit is currently in the <b>failed</b> state. (But see
below.)</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">4.
A job for the unit is pending.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">5.
The unit is pinned by an active IPC client
program.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">6.
The unit is a special &quot;perpetual&quot; unit that is
always active and loaded. Examples for perpetual units are
the root mount unit &minus;.mount or the scope unit
init.scope that the service manager itself lives
in.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">7.
The unit has running processes associated with
it.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
garbage collection logic may be altered with the
<i>CollectMode=</i> option, which allows configuration
whether automatic unloading of units that are in
<b>failed</b> state is permissible, see below.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that when a unit's configuration and state is unloaded, all
execution results, such as exit codes, exit signals,
resource consumption and other statistics are lost, except
for what is stored in the log subsystem.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Use
<b>systemctl daemon&minus;reload</b> or an equivalent
command to reload unit configuration while the unit is
already loaded. In this case all configuration settings are
flushed out and replaced with the new configuration (which
however might not be in effect immediately), however all
runtime state is saved/restored.</font></p>

<h2>[UNIT] SECTION OPTIONS
<a name="[UNIT] SECTION OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
unit file may include a [Unit] section, which carries
generic information about the unit that is not dependent on
the type of unit:</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Description=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A short
human readable title of the unit. This may be used by
<b>systemd</b> (and other UIs) as a user&minus;visible label
for the unit, so this string should identify the unit rather
than describe it, despite the name. This string also
shouldn't just repeat the unit name. &quot;Apache2 Web
Server&quot; is a good example. Bad examples are
&quot;high&minus;performance light&minus;weight HTTP
server&quot; (too generic) or &quot;Apache2&quot;
(meaningless for people who do not know Apache, duplicates
the unit name). <b>systemd</b> may use this string as a noun
in status messages (&quot;Starting
<i>description</i>...&quot;, &quot;Started
<i>description</i>.&quot;, &quot;Reached target
<i>description</i>.&quot;, &quot;Failed to start
<i>description</i>.&quot;), so it should be capitalized, and
should not be a full sentence, or a phrase with a continuous
verb. Bad examples include &quot;exiting the container&quot;
or &quot;updating the database once per
day.&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Documentation=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
space&minus;separated list of URIs referencing documentation
for this unit or its configuration. Accepted are only URIs
of the types &quot;http://&quot;, &quot;https://&quot;,
&quot;file:&quot;, &quot;info:&quot;, &quot;man:&quot;. For
more information about the syntax of these URIs, see
<b>uri</b>(7). The URIs should be listed in order of
relevance, starting with the most relevant. It is a good
idea to first reference documentation that explains what the
unit's purpose is, followed by how it is configured,
followed by any other related documentation. This option may
be specified more than once, in which case the specified
list of URIs is merged. If the empty string is assigned to
this option, the list is reset and all prior assignments
will have no effect.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Wants=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
(weak) requirement dependencies on other units. This option
may be specified more than once or multiple
space&minus;separated units may be specified in one option
in which case dependencies for all listed names will be
created. Dependencies of this type may also be configured
outside of the unit configuration file by adding a symlink
to a .wants/ directory accompanying the unit file. For
details, see above.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Units
listed in this option will be started if the configuring
unit is. However, if the listed units fail to start or
cannot be added to the transaction, this has no impact on
the validity of the transaction as a whole, and this unit
will still be started. This is the recommended way to hook
the start&minus;up of one unit to the start&minus;up of
another unit.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that requirement dependencies do not influence the order in
which services are started or stopped. This has to be
configured independently with the <i>After=</i> or
<i>Before=</i> options. If unit foo.service pulls in unit
bar.service as configured with <i>Wants=</i> and no ordering
is configured with <i>After=</i> or <i>Before=</i>, then
both units will be started simultaneously and without any
delay between them if foo.service is activated.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Requires=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Similar
to <i>Wants=</i>, but declares a stronger requirement
dependency. Dependencies of this type may also be configured
by adding a symlink to a .requires/ directory accompanying
the unit file.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
this unit gets activated, the units listed will be activated
as well. If one of the other units fails to activate, and an
ordering dependency <i>After=</i> on the failing unit is
set, this unit will not be started. Besides, with or without
specifying <i>After=</i>, this unit will be stopped (or
restarted) if one of the other units is explicitly stopped
(or restarted).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Often,
it is a better choice to use <i>Wants=</i> instead of
<i>Requires=</i> in order to achieve a system that is more
robust when dealing with failing services.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that this dependency type does not imply that the other unit
always has to be in active state when this unit is running.
Specifically: failing condition checks (such as
<i>ConditionPathExists=</i>,
<i>ConditionPathIsSymbolicLink=</i>, ... &mdash; see below)
do not cause the start job of a unit with a <i>Requires=</i>
dependency on it to fail. Also, some unit types may
deactivate on their own (for example, a service process may
decide to exit cleanly, or a device may be unplugged by the
user), which is not propagated to units having a
<i>Requires=</i> dependency. Use the <i>BindsTo=</i>
dependency type together with <i>After=</i> to ensure that a
unit may never be in active state without a specific other
unit also in active state (see below).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Requisite=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Similar
to <i>Requires=</i>. However, if the units listed here are
not started already, they will not be started and the
starting of this unit will fail immediately.
<i>Requisite=</i> does not imply an ordering dependency,
even if both units are started in the same transaction.
Hence this setting should usually be combined with
<i>After=</i>, to ensure this unit is not started before the
other unit.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
<i>Requisite=b.service</i> is used on a.service, this
dependency will show as <i>RequisiteOf=a.service</i> in
property listing of b.service. <i>RequisiteOf=</i>
dependency cannot be specified directly.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>BindsTo=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
requirement dependencies, very similar in style to
<i>Requires=</i>. However, this dependency type is stronger:
in addition to the effect of <i>Requires=</i> it declares
that if the unit bound to is stopped, this unit will be
stopped too. This means a unit bound to another unit that
suddenly enters inactive state will be stopped too. Units
can suddenly, unexpectedly enter inactive state for
different reasons: the main process of a service unit might
terminate on its own choice, the backing device of a device
unit might be unplugged or the mount point of a mount unit
might be unmounted without involvement of the system and
service manager.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
used in conjunction with <i>After=</i> on the same unit the
behaviour of <i>BindsTo=</i> is even stronger. In this case,
the unit bound to strictly has to be in active state for
this unit to also be in active state. This not only means a
unit bound to another unit that suddenly enters inactive
state, but also one that is bound to another unit that gets
skipped due to an unmet condition check (such as
<i>ConditionPathExists=</i>,
<i>ConditionPathIsSymbolicLink=</i>, ... &mdash; see below)
will be stopped, should it be running. Hence, in many cases
it is best to combine <i>BindsTo=</i> with
<i>After=</i>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
<i>BindsTo=b.service</i> is used on a.service, this
dependency will show as <i>BoundBy=a.service</i> in property
listing of b.service. <i>BoundBy=</i> dependency cannot be
specified directly.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>PartOf=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
dependencies similar to <i>Requires=</i>, but limited to
stopping and restarting of units. When systemd stops or
restarts the units listed here, the action is propagated to
this unit. Note that this is a one&minus;way
dependency&nbsp;&mdash; changes to this unit do not affect
the listed units.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
<i>PartOf=b.service</i> is used on a.service, this
dependency will show as <i>ConsistsOf=a.service</i> in
property listing of b.service. <i>ConsistsOf=</i> dependency
cannot be specified directly.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Upholds=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configures
dependencies similar to <i>Wants=</i>, but as long as this
unit is up, all units listed in <i>Upholds=</i> are started
whenever found to be inactive or failed, and no job is
queued for them. While a <i>Wants=</i> dependency on another
unit has a one&minus;time effect when this units started, a
<i>Upholds=</i> dependency on it has a continuous effect,
constantly restarting the unit if necessary. This is an
alternative to the <i>Restart=</i> setting of service units,
to ensure they are kept running whatever happens.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
<i>Upholds=b.service</i> is used on a.service, this
dependency will show as <i>UpheldBy=a.service</i> in the
property listing of b.service. The <i>UpheldBy=</i>
dependency cannot be specified directly.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Conflicts=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
space&minus;separated list of unit names. Configures
negative requirement dependencies. If a unit has a
<i>Conflicts=</i> setting on another unit, starting the
former will stop the latter and vice versa.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that this setting does not imply an ordering dependency,
similarly to the <i>Wants=</i> and <i>Requires=</i>
dependencies described above. This means that to ensure that
the conflicting unit is stopped before the other unit is
started, an <i>After=</i> or <i>Before=</i> dependency must
be declared. It doesn't matter which of the two ordering
dependencies is used, because stop jobs are always ordered
before start jobs, see the discussion in
<i>Before=</i>/<i>After=</i> below.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
unit A that conflicts with unit B is scheduled to be started
at the same time as B, the transaction will either fail (in
case both are required parts of the transaction) or be
modified to be fixed (in case one or both jobs are not a
required part of the transaction). In the latter case, the
job that is not required will be removed, or in case both
are not required, the unit that conflicts will be started
and the unit that is conflicted is stopped.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Before=</i>,
<i>After=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">These two
settings expect a space&minus;separated list of unit names.
They may be specified more than once, in which case
dependencies for all listed names are created.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Those
two settings configure ordering dependencies between units.
If unit foo.service contains the setting
<b>Before=bar.service</b> and both units are being started,
bar.service's start&minus;up is delayed until foo.service
has finished starting up. <i>After=</i> is the inverse of
<i>Before=</i>, i.e. while <i>Before=</i> ensures that the
configured unit is started before the listed unit begins
starting up, <i>After=</i> ensures the opposite, that the
listed unit is fully started up before the configured unit
is started.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
two units with an ordering dependency between them are shut
down, the inverse of the start&minus;up order is applied.
I.e. if a unit is configured with <i>After=</i> on another
unit, the former is stopped before the latter if both are
shut down. Given two units with any ordering dependency
between them, if one unit is shut down and the other is
started up, the shutdown is ordered before the
start&minus;up. It doesn't matter if the ordering dependency
is <i>After=</i> or <i>Before=</i>, in this case. It also
doesn't matter which of the two is shut down, as long as one
is shut down and the other is started up; the shutdown is
ordered before the start&minus;up in all cases. If two units
have no ordering dependencies between them, they are shut
down or started up simultaneously, and no ordering takes
place. It depends on the unit type when precisely a unit has
finished starting up. Most importantly, for service units
start&minus;up is considered completed for the purpose of
<i>Before=</i>/<i>After=</i> when all its configured
start&minus;up commands have been invoked and they either
failed or reported start&minus;up success. Note that this
does includes <i>ExecStartPost=</i> (or <i>ExecStopPost=</i>
for the shutdown case).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that those settings are independent of and orthogonal to the
requirement dependencies as configured by <i>Requires=</i>,
<i>Wants=</i>, <i>Requisite=</i>, or <i>BindsTo=</i>. It is
a common pattern to include a unit name in both the
<i>After=</i> and <i>Wants=</i> options, in which case the
unit listed will be started before the unit that is
configured with these options.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that <i>Before=</i> dependencies on device units have no
effect and are not supported. Devices generally become
available as a result of an external hotplug event, and
systemd creates the corresponding device unit without
delay.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>OnFailure=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
space&minus;separated list of one or more units that are
activated when this unit enters the &quot;failed&quot;
state. A service unit using <i>Restart=</i> enters the
failed state only after the start limits are
reached.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>OnSuccess=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
space&minus;separated list of one or more units that are
activated when this unit enters the &quot;inactive&quot;
state.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>PropagatesReloadTo=</i>,
<i>ReloadPropagatedFrom=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
space&minus;separated list of one or more units to which
reload requests from this unit shall be propagated to, or
units from which reload requests shall be propagated to this
unit, respectively. Issuing a reload request on a unit will
automatically also enqueue reload requests on all units that
are linked to it using these two settings.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>PropagatesStopTo=</i>,
<i>StopPropagatedFrom=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
space&minus;separated list of one or more units to which
stop requests from this unit shall be propagated to, or
units from which stop requests shall be propagated to this
unit, respectively. Issuing a stop request on a unit will
automatically also enqueue stop requests on all units that
are linked to it using these two settings.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>JoinsNamespaceOf=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">For units
that start processes (such as service units), lists one or
more other units whose network and/or temporary file
namespace to join. This only applies to unit types which
support the <i>PrivateNetwork=</i>,
<i>NetworkNamespacePath=</i>, <i>PrivateIPC=</i>,
<i>IPCNamespacePath=</i>, and <i>PrivateTmp=</i> directives
(see <b>systemd.exec</b>(5) for details). If a unit that has
this setting set is started, its processes will see the same
/tmp/, /var/tmp/, IPC namespace and network namespace as one
listed unit that is started. If multiple listed units are
already started, it is not defined which namespace is
joined. Note that this setting only has an effect if
<i>PrivateNetwork=</i>/<i>NetworkNamespacePath=</i>,
<i>PrivateIPC=</i>/<i>IPCNamespacePath=</i> and/or
<i>PrivateTmp=</i> is enabled for both the unit that joins
the namespace and the unit whose namespace is
joined.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RequiresMountsFor=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
space&minus;separated list of absolute paths. Automatically
adds dependencies of type <i>Requires=</i> and <i>After=</i>
for all mount units required to access the specified
path.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Mount
points marked with <b>noauto</b> are not mounted
automatically through local&minus;fs.target, but are still
honored for the purposes of this option, i.e. they will be
pulled in by this unit.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>OnFailureJobMode=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
value of &quot;fail&quot;, &quot;replace&quot;,
&quot;replace&minus;irreversibly&quot;, &quot;isolate&quot;,
&quot;flush&quot;, &quot;ignore&minus;dependencies&quot; or
&quot;ignore&minus;requirements&quot;. Defaults to
&quot;replace&quot;. Specifies how the units listed in
<i>OnFailure=</i> will be enqueued. See
<b>systemctl</b>(1)'s <b>&minus;&minus;job&minus;mode=</b>
option for details on the possible values. If this is set to
&quot;isolate&quot;, only a single unit may be listed in
<i>OnFailure=</i>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>IgnoreOnIsolate=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. If <b>true</b>, this unit will not be
stopped when isolating another unit. Defaults to
<b>false</b> for service, target, socket, timer, and path
units, and <b>true</b> for slice, scope, device, swap,
mount, and automount units.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>StopWhenUnneeded=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. If <b>true</b>, this unit will be stopped
when it is no longer used. Note that, in order to minimize
the work to be executed, systemd will not stop units by
default unless they are conflicting with other units, or the
user explicitly requested their shut down. If this option is
set, a unit will be automatically cleaned up if no other
active unit requires it. Defaults to
<b>false</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RefuseManualStart=</i>,
<i>RefuseManualStop=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. If <b>true</b>, this unit can only be
activated or deactivated indirectly. In this case, explicit
start&minus;up or termination requested by the user is
denied, however if it is started or stopped as a dependency
of another unit, start&minus;up or termination will succeed.
This is mostly a safety feature to ensure that the user does
not accidentally activate units that are not intended to be
activated explicitly, and not accidentally deactivate units
that are not intended to be deactivated. These options
default to <b>false</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>AllowIsolate=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. If <b>true</b>, this unit may be used with
the <b>systemctl isolate</b> command. Otherwise, this will
be refused. It probably is a good idea to leave this
disabled except for target units that shall be used similar
to runlevels in SysV init systems, just as a precaution to
avoid unusable system states. This option defaults to
<b>false</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>DefaultDependencies=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. If <b>yes</b>, (the default), a few
default dependencies will implicitly be created for the
unit. The actual dependencies created depend on the unit
type. For example, for service units, these dependencies
ensure that the service is started only after basic system
initialization is completed and is properly terminated on
system shutdown. See the respective man pages for details.
Generally, only services involved with early boot or late
shutdown should set this option to <b>no</b>. It is highly
recommended to leave this option enabled for the majority of
common units. If set to <b>no</b>, this option does not
disable all implicit dependencies, just non&minus;essential
ones.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>CollectMode=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Tweaks
the &quot;garbage collection&quot; algorithm for this unit.
Takes one of <b>inactive</b> or
<b>inactive&minus;or&minus;failed</b>. If set to
<b>inactive</b> the unit will be unloaded if it is in the
<b>inactive</b> state and is not referenced by clients, jobs
or other units &mdash; however it is not unloaded if it is
in the <b>failed</b> state. In <b>failed</b> mode, failed
units are not unloaded until the user invoked <b>systemctl
reset&minus;failed</b> on them to reset the <b>failed</b>
state, or an equivalent command. This behaviour is altered
if this option is set to
<b>inactive&minus;or&minus;failed</b>: in this case the unit
is unloaded even if the unit is in a <b>failed</b> state,
and thus an explicitly resetting of the <b>failed</b> state
is not necessary. Note that if this mode is used unit
results (such as exit codes, exit signals, consumed
resources, ...) are flushed out immediately after the unit
completed, except for what is stored in the logging
subsystem. Defaults to <b>inactive</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>FailureAction=</i>,
<i>SuccessAction=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the action to take when the unit stops and enters a failed
state or inactive state. Takes one of <b>none</b>,
<b>reboot</b>, <b>reboot&minus;force</b>,
<b>reboot&minus;immediate</b>, <b>poweroff</b>,
<b>poweroff&minus;force</b>,
<b>poweroff&minus;immediate</b>, <b>exit</b>, and
<b>exit&minus;force</b>. In system mode, all options are
allowed. In user mode, only <b>none</b>, <b>exit</b>, and
<b>exit&minus;force</b> are allowed. Both options default to
<b>none</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
<b>none</b> is set, no action will be triggered.
<b>reboot</b> causes a reboot following the normal shutdown
procedure (i.e. equivalent to <b>systemctl reboot</b>).
<b>reboot&minus;force</b> causes a forced reboot which will
terminate all processes forcibly but should cause no dirty
file systems on reboot (i.e. equivalent to <b>systemctl
reboot &minus;f</b>) and <b>reboot&minus;immediate</b>
causes immediate execution of the <b>reboot</b>(2) system
call, which might result in data loss (i.e. equivalent to
<b>systemctl reboot &minus;ff</b>). Similarly,
<b>poweroff</b>, <b>poweroff&minus;force</b>,
<b>poweroff&minus;immediate</b> have the effect of powering
down the system with similar semantics. <b>exit</b> causes
the manager to exit following the normal shutdown procedure,
and <b>exit&minus;force</b> causes it terminate without
shutting down services. When <b>exit</b> or
<b>exit&minus;force</b> is used by default the exit status
of the main process of the unit (if this applies) is
returned from the service manager. However, this may be
overridden with
<i>FailureActionExitStatus=</i>/<i>SuccessActionExitStatus=</i>,
see below.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>FailureActionExitStatus=</i>,
<i>SuccessActionExitStatus=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Controls
the exit status to propagate back to an invoking container
manager (in case of a system service) or service manager (in
case of a user manager) when the
<i>FailureAction=</i>/<i>SuccessAction=</i> are set to
<b>exit</b> or <b>exit&minus;force</b> and the action is
triggered. By default the exit status of the main process of
the triggering unit (if this applies) is propagated. Takes a
value in the range 0...255 or the empty string to request
default behaviour.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>JobTimeoutSec=</i>,
<i>JobRunningTimeoutSec=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>JobTimeoutSec=</i>
specifies a timeout for the whole job that starts running
when the job is queued. <i>JobRunningTimeoutSec=</i>
specifies a timeout that starts running when the queued job
is actually started. If either limit is reached, the job
will be cancelled, the unit however will not change state or
even enter the &quot;failed&quot; mode.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Both
settings take a time span with the default unit of seconds,
but other units may be specified, see
<b>systemd.time</b>(5). The default is &quot;infinity&quot;
(job timeouts disabled), except for device units where
<i>JobRunningTimeoutSec=</i> defaults to
<i>DefaultTimeoutStartSec=</i>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note:
these timeouts are independent from any unit&minus;specific
timeouts (for example, the timeout set with
<i>TimeoutStartSec=</i> in service units). The job timeout
has no effect on the unit itself. Or in other words:
unit&minus;specific timeouts are useful to abort unit state
changes, and revert them. The job timeout set with this
option however is useful to abort only the job waiting for
the unit state to change.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>JobTimeoutAction=</i>,
<i>JobTimeoutRebootArgument=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>JobTimeoutAction=</i>
optionally configures an additional action to take when the
timeout is hit, see description of <i>JobTimeoutSec=</i> and
<i>JobRunningTimeoutSec=</i> above. It takes the same values
as <i>StartLimitAction=</i>. Defaults to
<b>none</b>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><i>JobTimeoutRebootArgument=</i>
configures an optional reboot string to pass to the
<b>reboot</b>(2) system call.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>StartLimitIntervalSec=interval</i>,
<i>StartLimitBurst=burst</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
unit start rate limiting. Units which are started more than
<i>burst</i> times within an <i>interval</i> time span are
not permitted to start any more. Use
<i>StartLimitIntervalSec=</i> to configure the checking
interval and <i>StartLimitBurst=</i> to configure how many
starts per interval are allowed.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><i>interval</i>
is a time span with the default unit of seconds, but other
units may be specified, see <b>systemd.time</b>(5). Defaults
to <i>DefaultStartLimitIntervalSec=</i> in manager
configuration file, and may be set to 0 to disable any kind
of rate limiting. <i>burst</i> is a number and defaults to
<i>DefaultStartLimitBurst=</i> in manager configuration
file.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">These
configuration options are particularly useful in conjunction
with the service setting <i>Restart=</i> (see
<b>systemd.service</b>(5)); however, they apply to all kinds
of starts (including manual), not just those triggered by
the <i>Restart=</i> logic.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that units which are configured for <i>Restart=</i>, and
which reach the start limit are not attempted to be
restarted anymore; however, they may still be restarted
manually or from a timer or socket at a later point, after
the <i>interval</i> has passed. From that point on, the
restart logic is activated again. <b>systemctl
reset&minus;failed</b> will cause the restart rate counter
for a service to be flushed, which is useful if the
administrator wants to manually start a unit and the start
limit interferes with that. Rate&minus;limiting is enforced
after any unit condition checks are executed, and hence unit
activations with failing conditions do not count towards the
rate limit.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">When
a unit is unloaded due to the garbage collection logic (see
above) its rate limit counters are flushed out too. This
means that configuring start rate limiting for a unit that
is not referenced continuously has no effect.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
setting does not apply to slice, target, device, and scope
units, since they are unit types whose activation may either
never fail, or may succeed only a single time.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>StartLimitAction=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
an additional action to take if the rate limit configured
with <i>StartLimitIntervalSec=</i> and
<i>StartLimitBurst=</i> is hit. Takes the same values as the
<i>FailureAction=</i>/<i>SuccessAction=</i> settings. If
<b>none</b> is set, hitting the rate limit will trigger no
action except that the start will not be permitted. Defaults
to <b>none</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>RebootArgument=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Configure
the optional argument for the <b>reboot</b>(2) system call
if <i>StartLimitAction=</i> or <i>FailureAction=</i> is a
reboot action. This works just like the optional argument to
<b>systemctl reboot</b> command.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>SourcePath=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A path to
a configuration file this unit has been generated from. This
is primarily useful for implementation of generator tools
that convert configuration from an external configuration
file format into native unit files. This functionality
should not be used in normal units.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Conditions
and Asserts</b> <br>
Unit files may also include a number of <i>Condition...=</i>
and <i>Assert...=</i> settings. Before the unit is started,
systemd will verify that the specified conditions and
asserts are true. If not, the starting of the unit will be
(mostly silently) skipped (in case of conditions), or
aborted with an error message (in case of asserts). Failing
conditions or asserts will not result in the unit being
moved into the &quot;failed&quot; state. The conditions and
asserts are checked at the time the queued start job is to
be executed. The ordering dependencies are still respected,
so other units are still pulled in and ordered as if this
unit was successfully activated, and the conditions and
asserts are executed the precise moment the unit would
normally start and thus can validate system state after the
units ordered before completed initialization. Use condition
expressions for skipping units that do not apply to the
local system, for example because the kernel or runtime
environment doesn't require their functionality.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">If
multiple conditions are specified, the unit will be executed
if all of them apply (i.e. a logical AND is applied).
Condition checks can use a pipe symbol (&quot;|&quot;) after
the equals sign (&quot;Condition...=|...&quot;), which
causes the condition to become a <i>triggering</i>
condition. If at least one triggering condition is defined
for a unit, then the unit will be started if at least one of
the triggering conditions of the unit applies and all of the
regular (i.e. non&minus;triggering) conditions apply. If you
prefix an argument with the pipe symbol and an exclamation
mark, the pipe symbol must be passed first, the exclamation
second. If any of these options is assigned the empty
string, the list of conditions is reset completely, all
previous condition settings (of any kind) will have no
effect.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<i>AssertArchitecture=</i>, <i>AssertVirtualization=</i>,
... options are similar to conditions but cause the start
job to fail (instead of being skipped). The failed check is
logged. Units with unmet conditions are considered to be in
a clean state and will be garbage collected if they are not
referenced. This means that when queried, the condition
failure may or may not show up in the state of the
unit.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that neither assertion nor condition expressions result in
unit state changes. Also note that both are checked at the
time the job is to be executed, i.e. long after depending
jobs and it itself were queued. Thus, neither condition nor
assertion expressions are suitable for conditionalizing unit
dependencies.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
<b>condition</b> verb of <b>systemd-analyze</b>(1) can be
used to test condition and assert expressions.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Except
for <i>ConditionPathIsSymbolicLink=</i>, all path checks
follow symlinks.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionArchitecture=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Check
whether the system is running on a specific architecture.
Takes one of &quot;x86&quot;, &quot;x86&minus;64&quot;,
&quot;ppc&quot;, &quot;ppc&minus;le&quot;,
&quot;ppc64&quot;, &quot;ppc64&minus;le&quot;,
&quot;ia64&quot;, &quot;parisc&quot;, &quot;parisc64&quot;,
&quot;s390&quot;, &quot;s390x&quot;, &quot;sparc&quot;,
&quot;sparc64&quot;, &quot;mips&quot;,
&quot;mips&minus;le&quot;, &quot;mips64&quot;,
&quot;mips64&minus;le&quot;, &quot;alpha&quot;,
&quot;arm&quot;, &quot;arm&minus;be&quot;,
&quot;arm64&quot;, &quot;arm64&minus;be&quot;,
&quot;sh&quot;, &quot;sh64&quot;, &quot;m68k&quot;,
&quot;tilegx&quot;, &quot;cris&quot;, &quot;arc&quot;,
&quot;arc&minus;be&quot;, or &quot;native&quot;.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">The
architecture is determined from the information returned by
<b>uname</b>(2) and is thus subject to
<b>personality</b>(2). Note that a <i>Personality=</i>
setting in the same unit file has no effect on this
condition. A special architecture name &quot;native&quot; is
mapped to the architecture the system manager itself is
compiled for. The test may be negated by prepending an
exclamation mark.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionFirmware=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Check
whether the system's firmware is of a certain type. The
following values are possible:</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
&quot;uefi&quot; matches systems with EFI.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
&quot;device&minus;tree&quot; matches systems with a device
tree.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
&quot;device&minus;tree&minus;compatible(<i>value</i>)&quot;
matches systems with a device tree that are compatible with
&quot;value&quot;.</font></p>


<p style="margin-left:23%; margin-top: 1em"><font color="#000000">&bull;
&quot;smbios&minus;field(<i>field operator value</i>)&quot;
matches systems with a SMBIOS field containing a certain
value. <i>field</i> is the name of the SMBIOS field exposed
as &quot;sysfs&quot; attribute file below
/sys/class/dmi/id/. <i>operator</i> is one of
&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;,
&quot;&gt;&quot;, &quot;==&quot;, &quot;&lt;&gt;&quot; for
version comparisons, &quot;=&quot; and &quot;!=&quot; for
literal string comparisons, or &quot;$=&quot;,
&quot;!$=&quot; for shell&minus;style glob comparisons.
<i>value</i> is the expected value of the SMBIOS field value
(possibly containing shell style globs in case
&quot;$=&quot;/&quot;!$=&quot; is used).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionVirtualization=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Check
whether the system is executed in a virtualized environment
and optionally test whether it is a specific implementation.
Takes either boolean value to check if being executed in any
virtualized environment, or one of &quot;vm&quot; and
&quot;container&quot; to test against a generic type of
virtualization solution, or one of &quot;qemu&quot;,
&quot;kvm&quot;, &quot;amazon&quot;, &quot;zvm&quot;,
&quot;vmware&quot;, &quot;microsoft&quot;,
&quot;oracle&quot;, &quot;powervm&quot;, &quot;xen&quot;,
&quot;bochs&quot;, &quot;uml&quot;, &quot;bhyve&quot;,
&quot;qnx&quot;, &quot;apple&quot;, &quot;sre&quot;,
&quot;openvz&quot;, &quot;lxc&quot;,
&quot;lxc&minus;libvirt&quot;,
&quot;systemd&minus;nspawn&quot;, &quot;docker&quot;,
&quot;podman&quot;, &quot;rkt&quot;, &quot;wsl&quot;,
&quot;proot&quot;, &quot;pouch&quot;, &quot;acrn&quot; to
test against a specific implementation, or
&quot;private&minus;users&quot; to check whether we are
running in a user namespace. See
<b>systemd-detect-virt</b>(1) for a full list of known
virtualization technologies and their identifiers. If
multiple virtualization technologies are nested, only the
innermost is considered. The test may be negated by
prepending an exclamation mark.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionHost=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionHost=</i>
may be used to match against the hostname or machine ID of
the host. This either takes a hostname string (optionally
with shell style globs) which is tested against the locally
set hostname as returned by <b>gethostname</b>(2), or a
machine ID formatted as string (see <b>machine-id</b>(5)).
The test may be negated by prepending an exclamation
mark.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionKernelCommandLine=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionKernelCommandLine=</i>
may be used to check whether a specific kernel command line
option is set (or if prefixed with the exclamation mark
&mdash; unset). The argument must either be a single word,
or an assignment (i.e. two words, separated by
&quot;=&quot;). In the former case the kernel command line
is searched for the word appearing as is, or as left hand
side of an assignment. In the latter case, the exact
assignment is looked for with right and left hand side
matching. This operates on the kernel command line
communicated to userspace via /proc/cmdline, except when the
service manager is invoked as payload of a container
manager, in which case the command line of PID 1 is used
instead (i.e. /proc/1/cmdline).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionKernelVersion=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionKernelVersion=</i>
may be used to check whether the kernel version (as reported
by <b>uname &minus;r</b>) matches a certain expression, or
if prefixed with the exclamation mark, does not match. The
argument must be a list of (potentially quoted) expressions.
Each expression starts with one of &quot;=&quot; or
&quot;!=&quot; for string comparisons, &quot;&lt;&quot;,
&quot;&lt;=&quot;, &quot;==&quot;, &quot;&lt;&gt;&quot;,
&quot;&gt;=&quot;, &quot;&gt;&quot; for version comparisons,
or &quot;$=&quot;, &quot;!$=&quot; for a shell&minus;style
glob match. If no operator is specified, &quot;$=&quot; is
implied.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that using the kernel version string is an unreliable way to
determine which features are supported by a kernel, because
of the widespread practice of backporting drivers, features,
and fixes from newer upstream kernels into older versions
provided by distributions. Hence, this check is inherently
unportable and should not be used for units which may be
used on different distributions.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionCredential=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionCredential=</i>
may be used to check whether a credential by the specified
name was passed into the service manager. See</font>
<b><font color="#0000FF">System and Service
Credentials</font></b>
<small><font color="#000000">[2]</font></small>
<font color="#000000">for details about credentials. If used
in services for the system service manager this may be used
to conditionalize services based on system credentials
passed in. If used in services for the per&minus;user
service manager this may be used to conditionalize services
based on credentials passed into the unit@.service service
instance belonging to the user. The argument must be a valid
credential name.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionEnvironment=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionEnvironment=</i>
may be used to check whether a specific environment variable
is set (or if prefixed with the exclamation mark &mdash;
unset) in the service manager's environment block. The
argument may be a single word, to check if the variable with
this name is defined in the environment block, or an
assignment (&quot;<i>name</i>=<i>value</i>&quot;), to check
if the variable with this exact value is defined. Note that
the environment block of the service manager itself is
checked, i.e. not any variables defined with
<i>Environment=</i> or <i>EnvironmentFile=</i>, as described
above. This is particularly useful when the service manager
runs inside a containerized environment or as per&minus;user
service manager, in order to check for variables passed in
by the enclosing container manager or PAM.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionSecurity=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionSecurity=</i>
may be used to check whether the given security technology
is enabled on the system. Currently, the recognized values
are &quot;selinux&quot;, &quot;apparmor&quot;,
&quot;tomoyo&quot;, &quot;ima&quot;, &quot;smack&quot;,
&quot;audit&quot;, &quot;uefi&minus;secureboot&quot; and
&quot;tpm2&quot;. The test may be negated by prepending an
exclamation mark.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionCapability=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Check
whether the given capability exists in the capability
bounding set of the service manager (i.e. this does not
check whether capability is actually available in the
permitted or effective sets, see <b>capabilities</b>(7) for
details). Pass a capability name such as
&quot;CAP_MKNOD&quot;, possibly prefixed with an exclamation
mark to negate the check.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionACPower=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Check
whether the system has AC power, or is exclusively battery
powered at the time of activation of the unit. This takes a
boolean argument. If set to &quot;true&quot;, the condition
will hold only if at least one AC connector of the system is
connected to a power source, or if no AC connectors are
known. Conversely, if set to &quot;false&quot;, the
condition will hold only if there is at least one AC
connector known and all AC connectors are disconnected from
a power source.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionNeedsUpdate=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes one
of /var/ or /etc/ as argument, possibly prefixed with a
&quot;!&quot; (to invert the condition). This condition may
be used to conditionalize units on whether the specified
directory requires an update because /usr/'s modification
time is newer than the stamp file .updated in the specified
directory. This is useful to implement offline updates of
the vendor operating system resources in /usr/ that require
updating of /etc/ or /var/ on the next following boot. Units
making use of this condition should order themselves before
<b>systemd-update-done.service</b>(8), to make sure they run
before the stamp file's modification time gets reset
indicating a completed update.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
the <i>systemd.condition&minus;needs&minus;update=</i>
option is specified on the kernel command line (taking a
boolean), it will override the result of this condition
check, taking precedence over any file modification time
checks. If the kernel command line option is used,
systemd&minus;update&minus;done.service will not have
immediate effect on any following
<i>ConditionNeedsUpdate=</i> checks, until the system is
rebooted where the kernel command line option is not
specified anymore.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Note
that to make this scheme effective, the timestamp of /usr/
should be explicitly updated after its contents are
modified. The kernel will automatically update modification
timestamp on a directory only when immediate children of a
directory are modified; an modification of nested files will
not automatically result in mtime of /usr/ being
updated.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Also
note that if the update method includes a call to execute
appropriate post&minus;update steps itself, it should not
touch the timestamp of /usr/. In a typical distribution
packaging scheme, packages will do any required update steps
as part of the installation or upgrade, to make package
contents immediately usable. <i>ConditionNeedsUpdate=</i>
should be used with other update mechanisms where such an
immediate update does not happen.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionFirstBoot=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
boolean argument. This condition may be used to
conditionalize units on whether the system is booting up for
the first time. This roughly means that /etc/ was
unpopulated when the system started booting (for details,
see &quot;First Boot Semantics&quot; in
<b>machine-id</b>(5)). First boot is considered finished
(this condition will evaluate as false) after the manager
has finished the startup phase.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
condition may be used to populate /etc/ on the first boot
after factory reset, or when a new system instance boots up
for the first time.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">For
robustness, units with <i>ConditionFirstBoot=yes</i> should
order themselves before
first&minus;boot&minus;complete.target and pull in this
passive target with <i>Wants=</i>. This ensures that in a
case of an aborted first boot, these units will be
re&minus;run during the next system startup.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">If
the <i>systemd.condition&minus;first&minus;boot=</i> option
is specified on the kernel command line (taking a boolean),
it will override the result of this condition check, taking
precedence over /etc/machine&minus;id existence
checks.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionPathExists=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Check for
the existence of a file. If the specified absolute path name
does not exist, the condition will fail. If the absolute
path name passed to <i>ConditionPathExists=</i> is prefixed
with an exclamation mark (&quot;!&quot;), the test is
negated, and the unit is only started if the path does not
exist.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionPathExistsGlob=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionPathExistsGlob=</i>
is similar to <i>ConditionPathExists=</i>, but checks for
the existence of at least one file or directory matching the
specified globbing pattern.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionPathIsDirectory=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionPathIsDirectory=</i>
is similar to <i>ConditionPathExists=</i> but verifies that
a certain path exists and is a directory.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionPathIsSymbolicLink=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionPathIsSymbolicLink=</i>
is similar to <i>ConditionPathExists=</i> but verifies that
a certain path exists and is a symbolic link.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionPathIsMountPoint=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionPathIsMountPoint=</i>
is similar to <i>ConditionPathExists=</i> but verifies that
a certain path exists and is a mount point.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionPathIsReadWrite=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionPathIsReadWrite=</i>
is similar to <i>ConditionPathExists=</i> but verifies that
the underlying file system is readable and writable (i.e.
not mounted read&minus;only).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionPathIsEncrypted=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionPathIsEncrypted=</i>
is similar to <i>ConditionPathExists=</i> but verifies that
the underlying file system's backing block device is
encrypted using dm&minus;crypt/LUKS. Note that this check
does not cover ext4 per&minus;directory encryption, and only
detects block level encryption. Moreover, if the specified
path resides on a file system on top of a loopback block
device, only encryption above the loopback device is
detected. It is not detected whether the file system backing
the loopback block device is encrypted.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionDirectoryNotEmpty=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionDirectoryNotEmpty=</i>
is similar to <i>ConditionPathExists=</i> but verifies that
a certain path exists and is a non&minus;empty
directory.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionFileNotEmpty=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionFileNotEmpty=</i>
is similar to <i>ConditionPathExists=</i> but verifies that
a certain path exists and refers to a regular file with a
non&minus;zero size.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionFileIsExecutable=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionFileIsExecutable=</i>
is similar to <i>ConditionPathExists=</i> but verifies that
a certain path exists, is a regular file, and marked
executable.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionUser=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionUser=</i>
takes a numeric &quot;UID&quot;, a UNIX user name, or the
special value &quot;@system&quot;. This condition may be
used to check whether the service manager is running as the
given user. The special value &quot;@system&quot; can be
used to check if the user id is within the system user
range. This option is not useful for system services, as the
system manager exclusively runs as the root user, and thus
the test result is constant.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionGroup=</i></font></p>


<p style="margin-left:17%;"><font color="#000000"><i>ConditionGroup=</i>
is similar to <i>ConditionUser=</i> but verifies that the
service manager's real or effective group, or any of its
auxiliary groups, match the specified group or GID. This
setting does not support the special value
&quot;@system&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionControlGroupController=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Check
whether given cgroup controllers (e.g. &quot;cpu&quot;) are
available for use on the system or whether the legacy v1
cgroup or the modern v2 cgroup hierarchy is used.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Multiple
controllers may be passed with a space separating them; in
this case the condition will only pass if all listed
controllers are available for use. Controllers unknown to
systemd are ignored. Valid controllers are &quot;cpu&quot;,
&quot;io&quot;, &quot;memory&quot;, and &quot;pids&quot;.
Even if available in the kernel, a particular controller may
not be available if it was disabled on the kernel command
line with <i>cgroup_disable=controller</i>.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Alternatively,
two special strings &quot;v1&quot; and &quot;v2&quot; may be
specified (without any controller names). &quot;v2&quot;
will pass if the unified v2 cgroup hierarchy is used, and
&quot;v1&quot; will pass if the legacy v1 hierarchy or the
hybrid hierarchy are used. Note that legacy or hybrid
hierarchies have been deprecated. See <b>systemd</b>(1) for
more information.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionMemory=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Verify
that the specified amount of system memory is available to
the current system. Takes a memory size in bytes as
argument, optionally prefixed with a comparison operator
&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;=&quot; (or
&quot;==&quot;), &quot;!=&quot; (or &quot;&lt;&gt;&quot;),
&quot;&gt;=&quot;, &quot;&gt;&quot;. On bare&minus;metal
systems compares the amount of physical memory in the system
with the specified size, adhering to the specified
comparison operator. In containers compares the amount of
memory assigned to the container instead.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionCPUs=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Verify
that the specified number of CPUs is available to the
current system. Takes a number of CPUs as argument,
optionally prefixed with a comparison operator
&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;=&quot; (or
&quot;==&quot;), &quot;!=&quot; (or &quot;&lt;&gt;&quot;),
&quot;&gt;=&quot;, &quot;&gt;&quot;. Compares the number of
CPUs in the CPU affinity mask configured of the service
manager itself with the specified number, adhering to the
specified comparison operator. On physical systems the
number of CPUs in the affinity mask of the service manager
usually matches the number of physical CPUs, but in special
and virtual environments might differ. In particular, in
containers the affinity mask usually matches the number of
CPUs assigned to the container and not the physically
available ones.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionCPUFeature=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Verify
that a given CPU feature is available via the
&quot;CPUID&quot; instruction. This condition only does
something on i386 and x86&minus;64 processors. On other
processors it is assumed that the CPU does not support the
given feature. It checks the leaves &quot;1&quot;,
&quot;7&quot;, &quot;0x80000001&quot;, and
&quot;0x80000007&quot;. Valid values are: &quot;fpu&quot;,
&quot;vme&quot;, &quot;de&quot;, &quot;pse&quot;,
&quot;tsc&quot;, &quot;msr&quot;, &quot;pae&quot;,
&quot;mce&quot;, &quot;cx8&quot;, &quot;apic&quot;,
&quot;sep&quot;, &quot;mtrr&quot;, &quot;pge&quot;,
&quot;mca&quot;, &quot;cmov&quot;, &quot;pat&quot;,
&quot;pse36&quot;, &quot;clflush&quot;, &quot;mmx&quot;,
&quot;fxsr&quot;, &quot;sse&quot;, &quot;sse2&quot;,
&quot;ht&quot;, &quot;pni&quot;, &quot;pclmul&quot;,
&quot;monitor&quot;, &quot;ssse3&quot;, &quot;fma3&quot;,
&quot;cx16&quot;, &quot;sse4_1&quot;, &quot;sse4_2&quot;,
&quot;movbe&quot;, &quot;popcnt&quot;, &quot;aes&quot;,
&quot;xsave&quot;, &quot;osxsave&quot;, &quot;avx&quot;,
&quot;f16c&quot;, &quot;rdrand&quot;, &quot;bmi1&quot;,
&quot;avx2&quot;, &quot;bmi2&quot;, &quot;rdseed&quot;,
&quot;adx&quot;, &quot;sha_ni&quot;, &quot;syscall&quot;,
&quot;rdtscp&quot;, &quot;lm&quot;, &quot;lahf_lm&quot;,
&quot;abm&quot;, &quot;constant_tsc&quot;.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionOSRelease=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Verify
that a specific &quot;key=value&quot; pair is set in the
host's <b>os-release</b>(5).</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Other
than exact string matching (with &quot;=&quot; and
&quot;!=&quot;), relative comparisons are supported for
versioned parameters (e.g. &quot;VERSION_ID&quot;; with
&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;==&quot;,
&quot;&lt;&gt;&quot;, &quot;&gt;=&quot;, &quot;&gt;&quot;),
and shell&minus;style wildcard comparisons (&quot;*&quot;,
&quot;?&quot;, &quot;[]&quot;) are supported with the
&quot;$=&quot; (match) and &quot;!$=&quot;
(non&minus;match).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>ConditionMemoryPressure=</i>,
<i>ConditionCPUPressure=</i>,
<i>ConditionIOPressure=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Verify
that the overall system (memory, CPU or IO) pressure is
below or equal to a threshold. This setting takes a
threshold value as argument. It can be specified as a simple
percentage value, suffixed with &quot;%&quot;, in which case
the pressure will be measured as an average over the last
five minutes before the attempt to start the unit is
performed. Alternatively, the average timespan can also be
specified using &quot;/&quot; as a separator, for example:
&quot;10%/1min&quot;. The supported timespans match what the
kernel provides, and are limited to &quot;10sec&quot;,
&quot;1min&quot; and &quot;5min&quot;. The &quot;full&quot;
PSI will be checked first, and if not found &quot;some&quot;
will be checked. For more details, see the documentation
on</font> <b><font color="#0000FF">PSI (Pressure Stall
Information)</font></b>
<small><font color="#000000">[3]</font></small>
<font color="#000000">.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">Optionally,
the threshold value can be prefixed with the slice unit
under which the pressure will be checked, followed by a
&quot;:&quot;. If the slice unit is not specified, the
overall system pressure will be measured, instead of a
particular cgroup's.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>AssertArchitecture=</i>,
<i>AssertVirtualization=</i>, <i>AssertHost=</i>,
<i>AssertKernelCommandLine=</i>,
<i>AssertKernelVersion=</i>, <i>AssertCredential=</i>,
<i>AssertEnvironment=</i>, <i>AssertSecurity=</i>,
<i>AssertCapability=</i>, <i>AssertACPower=</i>,
<i>AssertNeedsUpdate=</i>, <i>AssertFirstBoot=</i>,
<i>AssertPathExists=</i>, <i>AssertPathExistsGlob=</i>,
<i>AssertPathIsDirectory=</i>,
<i>AssertPathIsSymbolicLink=</i>,
<i>AssertPathIsMountPoint=</i>,
<i>AssertPathIsReadWrite=</i>,
<i>AssertPathIsEncrypted=</i>,
<i>AssertDirectoryNotEmpty=</i>, <i>AssertFileNotEmpty=</i>,
<i>AssertFileIsExecutable=</i>, <i>AssertUser=</i>,
<i>AssertGroup=</i>, <i>AssertControlGroupController=</i>,
<i>AssertMemory=</i>, <i>AssertCPUs=</i>,
<i>AssertCPUFeature=</i>, <i>AssertOSRelease=</i>,
<i>AssertMemoryPressure=</i>, <i>AssertCPUPressure=</i>,
<i>AssertIOPressure=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Similar
to the <i>ConditionArchitecture=</i>,
<i>ConditionVirtualization=</i>, ..., condition settings
described above, these settings add assertion checks to the
start&minus;up of the unit. However, unlike the conditions
settings, any assertion setting that is not met results in
failure of the start job (which means this is logged
loudly). Note that hitting a configured assertion does not
cause the unit to enter the &quot;failed&quot; state (or in
fact result in any state change of the unit), it affects
only the job queued for it. Use assertion expressions for
units that cannot operate when specific requirements are not
met, and when this is something the administrator or user
should look into.</font></p>

<h2>MAPPING OF UNIT PROPERTIES TO THEIR INVERSES
<a name="MAPPING OF UNIT PROPERTIES TO THEIR INVERSES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Unit
settings that create a relationship with a second unit
usually show up in properties of both units, for example in
<b>systemctl show</b> output. In some cases the name of the
property is the same as the name of the configuration
setting, but not always. This table lists the properties
that are shown on two units which are connected through some
dependency, and shows which property on &quot;source&quot;
unit corresponds to which property on the &quot;target&quot;
unit.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Table&nbsp;3.&nbsp;
Forward and reverse unit properties <br>
&nbsp;</b></font></p>


<p align="center"><font color="#000000"><b><img src="grohtml-35855163.png" alt="Image grohtml-35855163.png"></b></font></p>

<p style="margin-left:11%;"><font color="#000000">Note:
<i>WantedBy=</i> and <i>RequiredBy=</i> are used in the
[Install] section to create symlinks in .wants/ and
.requires/ directories. They cannot be used directly as a
unit configuration setting.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note:
<i>ConsistsOf=</i>, <i>BoundBy=</i>, <i>RequisiteOf=</i>,
<i>ConflictedBy=</i> are created implicitly along with their
reverses and cannot be specified directly.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note:
<i>Triggers=</i> is created implicitly between a socket,
path unit, or an automount unit, and the unit they activate.
By default a unit with the same name is triggered, but this
can be overridden using <i>Sockets=</i>, <i>Service=</i>,
and <i>Unit=</i> settings. See <b>systemd.service</b>(5),
<b>systemd.socket</b>(5), <b>systemd.path</b>(5), and
<b>systemd.automount</b>(5) for details. <i>TriggeredBy=</i>
is created implicitly on the triggered unit.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note:
<i>Following=</i> is used to group device aliases and points
to the &quot;primary&quot; device unit that systemd is using
to track device state, usually corresponding to a sysfs
path. It does not show up in the &quot;target&quot;
unit.</font></p>

<h2>[INSTALL] SECTION OPTIONS
<a name="[INSTALL] SECTION OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Unit
files may include an [Install] section, which carries
installation information for the unit. This section is not
interpreted by <b>systemd</b>(1) during runtime; it is used
by the <b>enable</b> and <b>disable</b> commands of the
<b>systemctl</b>(1) tool during installation of a
unit.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Alias=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">A
space&minus;separated list of additional names this unit
shall be installed under. The names listed here must have
the same suffix (i.e. type) as the unit filename. This
option may be specified more than once, in which case all
listed names are used. At installation time, <b>systemctl
enable</b> will create symlinks from these names to the unit
filename. Note that not all unit types support such alias
names, and this setting is not supported for them.
Specifically, mount, slice, swap, and automount units do not
support aliasing.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>WantedBy=</i>,
<i>RequiredBy=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">This
option may be used more than once, or a
space&minus;separated list of unit names may be given. A
symbolic link is created in the .wants/ or .requires/
directory of each of the listed units when this unit is
installed by <b>systemctl enable</b>. This has the effect of
a dependency of type <i>Wants=</i> or <i>Requires=</i> being
added from the listed unit to the current unit. The primary
result is that the current unit will be started when the
listed unit is started, see the description of <i>Wants=</i>
and <i>Requires=</i> in the [Unit] section for
details.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">In
case of template units listing non template units, the
listing unit must have <i>DefaultInstance=</i> set, or
<b>systemctl enable</b> must be called with an instance
name. The instance (default or specified) will be added to
the .wants/ or .requires/ list of the listed unit. For
example, <b>WantedBy=getty.target</b> in a service
getty@.service will result in <b>systemctl enable
getty@tty2.service</b> creating a
getty.target.wants/getty@tty2.service link to
getty@.service. This also applies to listing specific
instances of templated units: this specific instance will
gain the dependency. A template unit may also list a
template unit, in which case a generic dependency will be
added where each instance of the listing unit will have a
dependency on an instance of the listed template with the
same instance value. For example,
<b>WantedBy=container@.target</b> in a service
monitor@.service will result in <b>systemctl enable
monitor@.service</b> creating a
container@.target.wants/monitor@.service link to
monitor@.service, which applies to all instances of
container@.target.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>Also=</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Additional
units to install/deinstall when this unit is
installed/deinstalled. If the user requests
installation/deinstallation of a unit with this option
configured, <b>systemctl enable</b> and <b>systemctl
disable</b> will automatically install/uninstall units
listed in this option as well.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
option may be used more than once, or a
space&minus;separated list of unit names may be
given.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><i>DefaultInstance=</i></font></p>

<p style="margin-left:17%;"><font color="#000000">In
template unit files, this specifies for which instance the
unit shall be enabled if the template is enabled without any
explicitly set instance. This option has no effect in
non&minus;template unit files. The specified string must be
usable as instance identifier.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following specifiers are interpreted in the Install section:
%a, %b, %B, %g, %G, %H, %i, %j, %l, %m, %n, %N, %o, %p, %u,
%U, %v, %w, %W, %%. For their meaning see the next
section.</font></p>

<h2>SPECIFIERS
<a name="SPECIFIERS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Many
settings resolve specifiers which may be used to write
generic unit files referring to runtime or unit parameters
that are replaced when the unit files are loaded. Specifiers
must be known and resolvable for the setting to be valid.
The following specifiers are understood:</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Table&nbsp;4.&nbsp;Specifiers
available in unit files <br>
&nbsp;</b></font></p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;1.&nbsp;Allowing
units to be enabled</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
following snippet (highlighted) allows a unit (e.g.
foo.service) to be enabled via <b>systemctl
enable</b>:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Foo</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
ExecStart=/usr/sbin/foo&minus;daemon</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><i>[Install]
<br>
WantedBy=multi&minus;user.target</i></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">After
running <b>systemctl enable</b>, a symlink
/etc/systemd/system/multi&minus;user.target.wants/foo.service
linking to the actual unit will be created. It tells systemd
to pull in the unit when starting multi&minus;user.target.
The inverse <b>systemctl disable</b> will remove that
symlink again.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;2.&nbsp;Overriding
vendor settings</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">There
are two methods of overriding vendor settings in unit files:
copying the unit file from /usr/lib/systemd/system to
/etc/systemd/system and modifying the chosen settings.
Alternatively, one can create a directory named
<i>unit</i>.d/ within /etc/systemd/system and place a
drop&minus;in file <i>name</i>.conf there that only changes
the specific settings one is interested in. Note that
multiple such drop&minus;in files are read if present,
processed in lexicographic order of their
filename.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
advantage of the first method is that one easily overrides
the complete unit, the vendor unit is not parsed at all
anymore. It has the disadvantage that improvements to the
unit file by the vendor are not automatically incorporated
on updates.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
advantage of the second method is that one only overrides
the settings one specifically wants, where updates to the
unit by the vendor automatically apply. This has the
disadvantage that some future updates by the vendor might be
incompatible with the local changes.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
also applies for user instances of systemd, but with
different locations for the unit files. See the section on
unit load paths for further details.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Suppose
there is a vendor&minus;supplied unit
/usr/lib/systemd/system/httpd.service with the following
contents:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Some HTTP server <br>
After=remote&minus;fs.target sqldb.service <br>
Requires=sqldb.service <br>
AssertPathExists=/srv/webserver</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=notify <br>

ExecStart=/usr/sbin/some&minus;fancy&minus;httpd&minus;server
<br>
Nice=5</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Now
one wants to change some settings as an administrator:
firstly, in the local setup, /srv/webserver might not exist,
because the HTTP server is configured to use /srv/www
instead. Secondly, the local configuration makes the HTTP
server also depend on a memory cache service,
memcached.service, that should be pulled in
(<i>Requires=</i>) and also be ordered appropriately
(<i>After=</i>). Thirdly, in order to harden the service a
bit more, the administrator would like to set the
<i>PrivateTmp=</i> setting (see <b>systemd.exec</b>(5) for
details). And lastly, the administrator would like to reset
the niceness of the service to its default value of
0.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
first possibility is to copy the unit file to
/etc/systemd/system/httpd.service and change the chosen
settings:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=Some HTTP server <br>
After=remote&minus;fs.target sqldb.service
<i>memcached.service</i> <br>
Requires=sqldb.service <i>memcached.service</i> <br>
AssertPathExists=<i>/srv/www</i></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=notify <br>

ExecStart=/usr/sbin/some&minus;fancy&minus;httpd&minus;server
<i><br>
Nice=0 <br>
PrivateTmp=yes</i></font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Install]
<br>
WantedBy=multi&minus;user.target</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Alternatively,
the administrator could create a drop&minus;in file
/etc/systemd/system/httpd.service.d/local.conf with the
following contents:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
After=memcached.service <br>
Requires=memcached.service <br>
# Reset all assertions and then re&minus;add the condition
we want <br>
AssertPathExists= <br>
AssertPathExists=/srv/www</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Nice=0 <br>
PrivateTmp=yes</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Note
that for drop&minus;in files, if one wants to remove entries
from a setting that is parsed as a list (and is not a
dependency), such as <i>AssertPathExists=</i> (or e.g.
<i>ExecStart=</i> in service units), one needs to first
clear the list before re&minus;adding all entries except the
one that is to be removed. Dependencies (<i>After=</i>,
etc.) cannot be reset to an empty list, so dependencies can
only be added in drop&minus;ins. If you want to remove
dependencies, you have to override the entire
unit.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;3.&nbsp;Top
level drop&minus;ins with template units</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Top
level per&minus;type drop&minus;ins can be used to change
some aspect of all units of a particular type. For example,
by creating the /etc/systemd/system/service.d/ directory
with a drop&minus;in file, the contents of the drop&minus;in
file can be applied to all service units. We can take this
further by having the top&minus;level drop&minus;in
instantiate a secondary helper unit. Consider for example
the following set of units and drop&minus;in files where we
install an <i>OnFailure=</i> dependency for all service
units.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">/etc/systemd/system/failure&minus;handler@.service:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
Description=My failure handler for %i</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Service]
<br>
Type=oneshot <br>
# Perform some special action for when %i exits
unexpectedly. <br>
ExecStart=/usr/sbin/myfailurehandler %i</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">We
can then add an instance of failure&minus;handler@.service
as an <i>OnFailure=</i> dependency for all service
units.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">/etc/systemd/system/service.d/10&minus;all.conf:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">[Unit]
<br>
OnFailure=failure&minus;handler@%N.service</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Now,
after running <b>systemctl daemon&minus;reload</b> all
services will have acquired an <i>OnFailure=</i> dependency
on failure&minus;handler@%N.service. The template instance
units will also have gained the dependency which results in
the creation of a recursive dependency chain. systemd will
try to detect these recursive dependency chains where a
template unit directly and recursively depends on itself and
will remove such dependencies automatically if it finds
them. If systemd doesn't detect the recursive dependency
chain, we can break the chain ourselves by disabling the
drop&minus;in for the template instance units via a symlink
to /dev/null:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000"><b>mkdir
/etc/systemd/system/failure&minus;handler@.service.d/ <br>
ln &minus;s /dev/null
/etc/systemd/system/failure&minus;handler@.service.d/10&minus;all.conf
<br>
systemctl daemon&minus;reload</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
ensures that if a failure&minus;handler@.service instance
fails it will not trigger an instance named
failure&minus;handler@failure&minus;handler.service.</font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>systemd</b>(1),
<b>systemctl</b>(1), <b>systemd-system.conf</b>(5),
<b>systemd.special</b>(7), <b>systemd.service</b>(5),
<b>systemd.socket</b>(5), <b>systemd.device</b>(5),
<b>systemd.mount</b>(5), <b>systemd.automount</b>(5),
<b>systemd.swap</b>(5), <b>systemd.target</b>(5),
<b>systemd.path</b>(5), <b>systemd.timer</b>(5),
<b>systemd.scope</b>(5), <b>systemd.slice</b>(5),
<b>systemd.time</b>(7), <b>systemd-analyze</b>(1),
<b>capabilities</b>(7), <b>systemd.directives</b>(7),
<b>uname</b>(1)</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em"><font color="#000000">Interface
Portability and Stability Promise</font></p></td>
<td width="17%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://systemd.io/PORTABILITY_AND_STABILITY/</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">2.</font></p> </td>
<td width="2%"></td>
<td width="46%">


<p style="margin-top: 1em"><font color="#000000">System and
Service Credentials</font></p></td>
<td width="37%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://systemd.io/CREDENTIALS</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">3.</font></p> </td>
<td width="2%"></td>
<td width="49%">


<p style="margin-top: 1em"><font color="#000000">PSI
(Pressure Stall Information)</font></p></td>
<td width="34%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://docs.kernel.org/accounting/psi.html</font></p>
<hr>
</body>
</html>
