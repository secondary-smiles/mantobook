<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:59 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>fanotify</title>

</head>
<body>
<h1>fanotify</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">fanotify
&minus; monitoring filesystem events</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The fanotify
API provides notification and interception of filesystem
events. Use cases include virus scanning and hierarchical
storage management. In the original fanotify API, only a
limited set of events was supported. In particular, there
was no support for create, delete, and move events. The
support for those events was added in Linux 5.1. (See
<b>inotify</b>(7) for details of an API that did notify
those events pre Linux 5.1.)</p>

<p style="margin-left:11%; margin-top: 1em">Additional
capabilities compared to the <b>inotify</b>(7) API include
the ability to monitor all of the objects in a mounted
filesystem, the ability to make access permission decisions,
and the possibility to read or modify files before access by
other applications.</p>

<p style="margin-left:11%; margin-top: 1em">The following
system calls are used with this API:
<b>fanotify_init</b>(2), <b>fanotify_mark</b>(2),
<b>read</b>(2), <b>write</b>(2), and <b>close</b>(2).</p>


<p style="margin-left:11%; margin-top: 1em"><b>fanotify_init(),
fanotify_mark(), and notification groups</b> <br>
The <b>fanotify_init</b>(2) system call creates and
initializes an fanotify notification group and returns a
file descriptor referring to it.</p>

<p style="margin-left:11%; margin-top: 1em">An fanotify
notification group is a kernel-internal object that holds a
list of files, directories, filesystems, and mounts for
which events shall be created.</p>

<p style="margin-left:11%; margin-top: 1em">For each entry
in an fanotify notification group, two bit masks exist: the
<i>mark</i> mask and the <i>ignore</i> mask. The mark mask
defines file activities for which an event shall be created.
The ignore mask defines activities for which no event shall
be generated. Having these two types of masks permits a
filesystem, mount, or directory to be marked for receiving
events, while at the same time ignoring events for specific
objects under a mount or directory.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>fanotify_mark</b>(2) system call adds a file, directory,
filesystem, or mount to a notification group and specifies
which events shall be reported (or ignored), or removes or
modifies such an entry.</p>

<p style="margin-left:11%; margin-top: 1em">A possible
usage of the ignore mask is for a file cache. Events of
interest for a file cache are modification of a file and
closing of the same. Hence, the cached directory or mount is
to be marked to receive these events. After receiving the
first event informing that a file has been modified, the
corresponding cache entry will be invalidated. No further
modification events for this file are of interest until the
file is closed. Hence, the modify event can be added to the
ignore mask. Upon receiving the close event, the modify
event can be removed from the ignore mask and the file cache
entry can be updated.</p>

<p style="margin-left:11%; margin-top: 1em">The entries in
the fanotify notification groups refer to files and
directories via their inode number and to mounts via their
mount ID. If files or directories are renamed or moved
within the same mount, the respective entries survive. If
files or directories are deleted or moved to another mount
or if filesystems or mounts are unmounted, the corresponding
entries are deleted.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The event
queue</b> <br>
As events occur on the filesystem objects monitored by a
notification group, the fanotify system generates events
that are collected in a queue. These events can then be read
(using <b>read</b>(2) or similar) from the fanotify file
descriptor returned by <b>fanotify_init</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Two types of
events are generated: <i>notification</i> events and
<i>permission</i> events. Notification events are merely
informative and require no action to be taken by the
receiving application with one exception: if a valid file
descriptor is provided within a generic event, the file
descriptor must be closed. Permission events are requests to
the receiving application to decide whether permission for a
file access shall be granted. For these events, the
recipient must write a response which decides whether access
is granted or not.</p>

<p style="margin-left:11%; margin-top: 1em">An event is
removed from the event queue of the fanotify group when it
has been read. Permission events that have been read are
kept in an internal list of the fanotify group until either
a permission decision has been taken by writing to the
fanotify file descriptor or the fanotify file descriptor is
closed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Reading
fanotify events</b> <br>
Calling <b>read</b>(2) for the file descriptor returned by
<b>fanotify_init</b>(2) blocks (if the flag
<b>FAN_NONBLOCK</b> is not specified in the call to
<b>fanotify_init</b>(2)) until either a file event occurs or
the call is interrupted by a signal (see
<b>signal</b>(7)).</p>

<p style="margin-left:11%; margin-top: 1em">After a
successful <b>read</b>(2), the read buffer contains one or
more of the following structures:</p>

<p style="margin-left:17%; margin-top: 1em">struct
fanotify_event_metadata { <br>
__u32 event_len; <br>
__u8 vers; <br>
__u8 reserved; <br>
__u16 metadata_len; <br>
__aligned_u64 mask; <br>
__s32 fd; <br>
__s32 pid; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">Information
records are supplemental pieces of information that may be
provided alongside the generic
<i>fanotify_event_metadata</i> structure. The <i>flags</i>
passed to <b>fanotify_init</b>(2) have influence over the
type of information records that may be returned for an
event. For example, if a notification group is initialized
with <b>FAN_REPORT_FID</b> or <b>FAN_REPORT_DIR_FID</b>,
then event listeners should also expect to receive a
<i>fanotify_event_info_fid</i> structure alongside the
<i>fanotify_event_metadata</i> structure, whereby file
handles are used to identify filesystem objects rather than
file descriptors. Information records may also be stacked,
meaning that using the various <b>FAN_REPORT_*</b> flags in
conjunction with one another is supported. In such cases,
multiple information records can be returned for an event
alongside the generic <i>fanotify_event_metadata</i>
structure. For example, if a notification group is
initialized with <b>FAN_REPORT_TARGET_FID</b> and
<b>FAN_REPORT_PIDFD</b>, then an event listener should
expect to receive up to two <i>fanotify_event_info_fid</i>
information records and one <i>fanotify_event_info_pidfd</i>
information record alongside the generic
<i>fanotify_event_metadata</i> structure. Importantly,
fanotify provides no guarantee around the ordering of
information records when a notification group is initialized
with a stacked based configuration. Each information record
has a nested structure of type
<i>fanotify_event_info_header</i>. It is imperative for
event listeners to inspect the <i>info_type</i> field of
this structure in order to determine the type of information
record that had been received for a given event.</p>

<p style="margin-left:11%; margin-top: 1em">In cases where
an fanotify group identifies filesystem objects by file
handles, event listeners should also expect to receive one
or more of the below information record objects alongside
the generic <i>fanotify_event_metadata</i> structure within
the read buffer:</p>

<p style="margin-left:17%; margin-top: 1em">struct
fanotify_event_info_fid { <br>
struct fanotify_event_info_header hdr; <br>
__kernel_fsid_t fsid; <br>
unsigned char file_handle[0]; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">In cases where
an fanotify group is initialized with
<b>FAN_REPORT_PIDFD</b>, event listeners should expect to
receive the below information record object alongside the
generic <i>fanotify_event_metadata</i> structure within the
read buffer:</p>

<p style="margin-left:17%; margin-top: 1em">struct
fanotify_event_info_pidfd { <br>
struct fanotify_event_info_header hdr; <br>
__s32 pidfd; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">In case of a
<b>FAN_FS_ERROR</b> event, an additional information record
describing the error that occurred is returned alongside the
generic <i>fanotify_event_metadata</i> structure within the
read buffer. This structure is defined as follows:</p>

<p style="margin-left:17%; margin-top: 1em">struct
fanotify_event_info_error { <br>
struct fanotify_event_info_header hdr; <br>
__s32 error; <br>
__u32 error_count; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">All information
records contain a nested structure of type
<i>fanotify_event_info_header</i>. This structure holds
meta-information about the information record that may have
been returned alongside the generic
<i>fanotify_event_metadata</i> structure. This structure is
defined as follows:</p>

<p style="margin-left:17%; margin-top: 1em">struct
fanotify_event_info_header {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>__u8 info_type;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>__u8 pad;</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>__u16 len;</p></td></tr>
</table>

<p style="margin-left:17%;">};</p>

<p style="margin-left:11%; margin-top: 1em">For performance
reasons, it is recommended to use a large buffer size (for
example, 4096 bytes), so that multiple events can be
retrieved by a single <b>read</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">The return
value of <b>read</b>(2) is the number of bytes placed in the
buffer, or &minus;1 in case of an error (but see BUGS).</p>

<p style="margin-left:11%; margin-top: 1em">The fields of
the <i>fanotify_event_metadata</i> structure are as follows:
<i><br>
event_len</i></p>

<p style="margin-left:22%;">This is the length of the data
for the current event and the offset to the next event in
the buffer. Unless the group identifies filesystem objects
by file handles, the value of <i>event_len</i> is always
<b>FAN_EVENT_METADATA_LEN</b>. For a group that identifies
filesystem objects by file handles, <i>event_len</i> also
includes the variable length file identifier records.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>vers</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This field holds a version number for the structure. It
must be compared to <b>FANOTIFY_METADATA_VERSION</b> to
verify that the structures returned at run time match the
structures defined at compile time. In case of a mismatch,
the application should abandon trying to use the fanotify
file descriptor.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>reserved</i></p>

<p style="margin-left:22%;">This field is not used.</p>

<p style="margin-left:11%;"><i>metadata_len</i></p>

<p style="margin-left:22%;">This is the length of the
structure. The field was introduced to facilitate the
implementation of optional headers per event type. No such
optional headers exist in the current implementation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>mask</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This is a bit mask describing the event (see below).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>fd</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This is an open file descriptor for the object being
accessed, or <b>FAN_NOFD</b> if a queue overflow occurred.
With an fanotify group that identifies filesystem objects by
file handles, applications should expect this value to be
set to <b>FAN_NOFD</b> for each event that is received. The
file descriptor can be used to access the contents of the
monitored file or directory. The reading application is
responsible for closing this file descriptor.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">When calling
<b>fanotify_init</b>(2), the caller may specify (via the
<i>event_f_flags</i> argument) various file status flags
that are to be set on the open file description that
corresponds to this file descriptor. In addition, the
(kernel-internal) <b>FMODE_NONOTIFY</b> file status flag is
set on the open file description. This flag suppresses
fanotify event generation. Hence, when the receiver of the
fanotify event accesses the notified file or directory using
this file descriptor, no additional events will be
created.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><i>pid</i></p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">If flag <b>FAN_REPORT_TID</b>
was set in <b>fanotify_init</b>(2), this is the TID of the
thread that caused the event. Otherwise, this the PID of the
process that caused the event.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A program
listening to fanotify events can compare this PID to the PID
returned by <b>getpid</b>(2), to determine whether the event
is caused by the listener itself, or is due to a file access
by another process.</p>

<p style="margin-left:11%; margin-top: 1em">The bit mask in
<i>mask</i> indicates which events have occurred for a
single filesystem object. Multiple bits may be set in this
mask, if more than one event occurred for the monitored
filesystem object. In particular, consecutive events for the
same filesystem object and originating from the same process
may be merged into a single event, with the exception that
two permission events are never merged into one queue
entry.</p>

<p style="margin-left:11%; margin-top: 1em">The bits that
may appear in <i>mask</i> are as follows: <b><br>
FAN_ACCESS</b></p>

<p style="margin-left:22%;">A file or a directory (but see
BUGS) was accessed (read).</p>

<p style="margin-left:11%;"><b>FAN_OPEN</b></p>

<p style="margin-left:22%;">A file or a directory was
opened.</p>

<p style="margin-left:11%;"><b>FAN_OPEN_EXEC</b></p>

<p style="margin-left:22%;">A file was opened with the
intent to be executed. See NOTES in <b>fanotify_mark</b>(2)
for additional details.</p>

<p style="margin-left:11%;"><b>FAN_ATTRIB</b></p>

<p style="margin-left:22%;">A file or directory metadata
was changed.</p>

<p style="margin-left:11%;"><b>FAN_CREATE</b></p>

<p style="margin-left:22%;">A child file or directory was
created in a watched parent.</p>

<p style="margin-left:11%;"><b>FAN_DELETE</b></p>

<p style="margin-left:22%;">A child file or directory was
deleted in a watched parent.</p>

<p style="margin-left:11%;"><b>FAN_DELETE_SELF</b></p>

<p style="margin-left:22%;">A watched file or directory was
deleted.</p>

<p style="margin-left:11%;"><b>FAN_FS_ERROR</b></p>

<p style="margin-left:22%;">A filesystem error was
detected.</p>

<p style="margin-left:11%;"><b>FAN_RENAME</b></p>

<p style="margin-left:22%;">A file or directory has been
moved to or from a watched parent directory.</p>

<p style="margin-left:11%;"><b>FAN_MOVED_FROM</b></p>

<p style="margin-left:22%;">A file or directory has been
moved from a watched parent directory.</p>

<p style="margin-left:11%;"><b>FAN_MOVED_TO</b></p>

<p style="margin-left:22%;">A file or directory has been
moved to a watched parent directory.</p>

<p style="margin-left:11%;"><b>FAN_MOVE_SELF</b></p>

<p style="margin-left:22%;">A watched file or directory was
moved.</p>

<p style="margin-left:11%;"><b>FAN_MODIFY</b></p>

<p style="margin-left:22%;">A file was modified.</p>

<p style="margin-left:11%;"><b>FAN_CLOSE_WRITE</b></p>

<p style="margin-left:22%;">A file that was opened for
writing (<b>O_WRONLY</b> or <b>O_RDWR</b>) was closed.</p>

<p style="margin-left:11%;"><b>FAN_CLOSE_NOWRITE</b></p>

<p style="margin-left:22%;">A file or directory that was
opened read-only (<b>O_RDONLY</b>) was closed.</p>

<p style="margin-left:11%;"><b>FAN_Q_OVERFLOW</b></p>

<p style="margin-left:22%;">The event queue exceeded the
limit on number of events. This limit can be overridden by
specifying the <b>FAN_UNLIMITED_QUEUE</b> flag when calling
<b>fanotify_init</b>(2).</p>

<p style="margin-left:11%;"><b>FAN_ACCESS_PERM</b></p>

<p style="margin-left:22%;">An application wants to read a
file or directory, for example using <b>read</b>(2) or
<b>readdir</b>(2). The reader must write a response (as
described below) that determines whether the permission to
access the filesystem object shall be granted.</p>

<p style="margin-left:11%;"><b>FAN_OPEN_PERM</b></p>

<p style="margin-left:22%;">An application wants to open a
file or directory. The reader must write a response that
determines whether the permission to open the filesystem
object shall be granted.</p>

<p style="margin-left:11%;"><b>FAN_OPEN_EXEC_PERM</b></p>

<p style="margin-left:22%;">An application wants to open a
file for execution. The reader must write a response that
determines whether the permission to open the filesystem
object for execution shall be granted. See NOTES in
<b>fanotify_mark</b>(2) for additional details.</p>

<p style="margin-left:11%; margin-top: 1em">To check for
any close event, the following bit mask may be used: <b><br>
FAN_CLOSE</b></p>

<p style="margin-left:22%;">A file was closed. This is a
synonym for:</p>


<p style="margin-left:28%; margin-top: 1em">FAN_CLOSE_WRITE
| FAN_CLOSE_NOWRITE</p>

<p style="margin-left:11%; margin-top: 1em">To check for
any move event, the following bit mask may be used: <b><br>
FAN_MOVE</b></p>

<p style="margin-left:22%;">A file or directory was moved.
This is a synonym for:</p>

<p style="margin-left:28%; margin-top: 1em">FAN_MOVED_FROM
| FAN_MOVED_TO</p>

<p style="margin-left:11%; margin-top: 1em">The following
bits may appear in <i>mask</i> only in conjunction with
other event type bits: <b><br>
FAN_ONDIR</b></p>

<p style="margin-left:22%;">The events described in the
<i>mask</i> have occurred on a directory object. Reporting
events on directories requires setting this flag in the mark
mask. See <b>fanotify_mark</b>(2) for additional details.
The <b>FAN_ONDIR</b> flag is reported in an event mask only
if the fanotify group identifies filesystem objects by file
handles.</p>

<p style="margin-left:11%; margin-top: 1em">Information
records that are supplied alongside the generic
<i>fanotify_event_metadata</i> structure will always contain
a nested structure of type
<i>fanotify_event_info_header</i>. The fields of the
<i>fanotify_event_info_header</i> are as follows: <i><br>
info_type</i></p>

<p style="margin-left:22%;">A unique integer value
representing the type of information record object received
for an event. The value of this field can be set to one of
the following: <b>FAN_EVENT_INFO_TYPE_FID</b>,
<b>FAN_EVENT_INFO_TYPE_DFID</b>,
<b>FAN_EVENT_INFO_TYPE_DFID_NAME</b>, or
<b>FAN_EVENT_INFO_TYPE_PIDFD</b>. The value set for this
field is dependent on the flags that have been supplied to
<b>fanotify_init</b>(2). Refer to the field details of each
information record object type below to understand the
different cases in which the <i>info_type</i> values can be
set.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><i>pad</i></p></td>
<td width="7%"></td>
<td width="78%">


<p>This field is currently not used by any information
record object type and therefore is set to zero.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><i>len</i></p></td>
<td width="7%"></td>
<td width="78%">


<p>The value of <i>len</i> is set to the size of the
information record object, including the
<i>fanotify_event_info_header</i>. The total size of all
additional information records is not expected to be larger
than (<i>event_len</i> &minus; <i>metadata_len</i>).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The fields of
the <i>fanotify_event_info_fid</i> structure are as
follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><i>hdr</i></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">This is a structure of type
<i>fanotify_event_info_header</i>. For example, when an
fanotify file descriptor is created using
<b>FAN_REPORT_FID</b>, a single information record is
expected to be attached to the event with <i>info_type</i>
field value of <b>FAN_EVENT_INFO_TYPE_FID</b>. When an
fanotify file descriptor is created using the combination of
<b>FAN_REPORT_FID</b> and <b>FAN_REPORT_DIR_FID</b>, there
may be two information records attached to the event: one
with <i>info_type</i> field value of
<b>FAN_EVENT_INFO_TYPE_DFID</b>, identifying a parent
directory object, and one with <i>info_type</i> field value
of <b>FAN_EVENT_INFO_TYPE_FID</b>, identifying a child
object. Note that for the directory entry modification
events <b>FAN_CREATE</b>, <b>FAN_DELETE</b>,
<b>FAN_MOVE</b>, and <b>FAN_RENAME</b>, an information
record identifying the created/deleted/moved child object is
reported only if an fanotify group was initialized with the
flag <b>FAN_REPORT_TARGET_FID</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>fsid</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This is a unique identifier of the filesystem containing
the object associated with the event. It is a structure of
type <i>__kernel_fsid_t</i> and contains the same value as
<i>f_fsid</i> when calling <b>statfs</b>(2).</p></td></tr>
</table>

<p style="margin-left:11%;"><i>file_handle</i></p>

<p style="margin-left:22%;">This is a variable length
structure of type struct file_handle. It is an opaque handle
that corresponds to a specified object on a filesystem as
returned by <b>name_to_handle_at</b>(2). It can be used to
uniquely identify a file on a filesystem and can be passed
as an argument to <b>open_by_handle_at</b>(2). If the value
of <i>info_type</i> field is
<b>FAN_EVENT_INFO_TYPE_DFID_NAME</b>, the file handle is
followed by a null terminated string that identifies the
created/deleted/moved directory entry name. For other events
such as <b>FAN_OPEN</b>, <b>FAN_ATTRIB</b>,
<b>FAN_DELETE_SELF</b>, and <b>FAN_MOVE_SELF</b>, if the
value of <i>info_type</i> field is
<b>FAN_EVENT_INFO_TYPE_FID</b>, the <i>file_handle</i>
identifies the object correlated to the event. If the value
of <i>info_type</i> field is
<b>FAN_EVENT_INFO_TYPE_DFID</b>, the <i>file_handle</i>
identifies the directory object correlated to the event or
the parent directory of a non-directory object correlated to
the event. If the value of <i>info_type</i> field is
<b>FAN_EVENT_INFO_TYPE_DFID_NAME</b>, the <i>file_handle</i>
identifies the same directory object that would be reported
with <b>FAN_EVENT_INFO_TYPE_DFID</b> and the file handle is
followed by a null terminated string that identifies the
name of a directory entry in that directory, or
&rsquo;.&rsquo; to identify the directory object itself.</p>

<p style="margin-left:11%; margin-top: 1em">The fields of
the <i>fanotify_event_info_pidfd</i> structure are as
follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>hdr</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This is a structure of type
<i>fanotify_event_info_header</i>. When an fanotify group is
initialized using <b>FAN_REPORT_PIDFD</b>, the
<i>info_type</i> field value of the
<i>fanotify_event_info_header</i> is set to
<b>FAN_EVENT_INFO_TYPE_PIDFD</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>pidfd</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This is a process file descriptor that refers to the
process responsible for generating the event. The returned
process file descriptor is no different from one which could
be obtained manually if <b>pidfd_open</b>(2) were to be
called on <i>fanotify_event_metadata.pid</i>. In the
instance that an error is encountered during pidfd creation,
one of two possible error types represented by a negative
integer value may be returned in this <i>pidfd</i> field. In
cases where the process responsible for generating the event
has terminated prior to the event listener being able to
read events from the notification queue, <b>FAN_NOPIDFD</b>
is returned. The pidfd creation for an event is only
performed at the time the events are read from the
notification queue. All other possible pidfd creation
failures are represented by <b>FAN_EPIDFD</b>. Once the
event listener has dealt with an event and the pidfd is no
longer required, the pidfd should be closed via
<b>close</b>(2).</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The fields of
the <i>fanotify_event_info_error</i> structure are as
follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p style="margin-top: 1em"><i>hdr</i></p></td>
<td width="4%"></td>
<td width="78%">


<p style="margin-top: 1em">This is a structure of type
<i>fanotify_event_info_header</i>. The <i>info_type</i>
field is set to <b>FAN_EVENT_INFO_TYPE_ERROR</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>error</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>Identifies the type of error that occurred.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>error_count</i></p>

<p style="margin-left:22%;">This is a counter of the number
of errors suppressed since the last error was read.</p>

<p style="margin-left:11%; margin-top: 1em">The following
macros are provided to iterate over a buffer containing
fanotify event metadata returned by a <b>read</b>(2) from an
fanotify file descriptor: <b><br>
FAN_EVENT_OK(meta, len)</b></p>

<p style="margin-left:22%;">This macro checks the remaining
length <i>len</i> of the buffer <i>meta</i> against the
length of the metadata structure and the <i>event_len</i>
field of the first metadata structure in the buffer.</p>

<p style="margin-left:11%;"><b>FAN_EVENT_NEXT(meta,
len)</b></p>

<p style="margin-left:22%;">This macro uses the length
indicated in the <i>event_len</i> field of the metadata
structure pointed to by <i>meta</i> to calculate the address
of the next metadata structure that follows <i>meta</i>.
<i>len</i> is the number of bytes of metadata that currently
remain in the buffer. The macro returns a pointer to the
next metadata structure that follows <i>meta</i>, and
reduces <i>len</i> by the number of bytes in the metadata
structure that has been skipped over (i.e., it subtracts
<i>meta&minus;&gt;event_len</i> from <i>len</i>).</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
there is: <b><br>
FAN_EVENT_METADATA_LEN</b></p>

<p style="margin-left:22%;">This macro returns the size (in
bytes) of the structure <i>fanotify_event_metadata</i>. This
is the minimum size (and currently the only size) of any
event metadata.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Monitoring
an fanotify file descriptor for events</b> <br>
When an fanotify event occurs, the fanotify file descriptor
indicates as readable when passed to <b>epoll</b>(7),
<b>poll</b>(2), or <b>select</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Dealing with
permission events</b> <br>
For permission events, the application must <b>write</b>(2)
a structure of the following form to the fanotify file
descriptor:</p>

<p style="margin-left:17%; margin-top: 1em">struct
fanotify_response { <br>
__s32 fd; <br>
__u32 response; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">The fields of
this structure are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><i>fd</i></p></td>
<td width="8%"></td>
<td width="78%">


<p>This is the file descriptor from the structure
<i>fanotify_event_metadata</i>.</p> </td></tr>
</table>

<p style="margin-left:11%;"><i>response</i></p>

<p style="margin-left:22%;">This field indicates whether or
not the permission is to be granted. Its value must be
either <b>FAN_ALLOW</b> to allow the file operation or
<b>FAN_DENY</b> to deny the file operation.</p>

<p style="margin-left:11%; margin-top: 1em">If access is
denied, the requesting application call will receive an
<b>EPERM</b> error. Additionally, if the notification group
has been created with the <b>FAN_ENABLE_AUDIT</b> flag, then
the <b>FAN_AUDIT</b> flag can be set in the <i>response</i>
field. In that case, the audit subsystem will log
information about the access decision to the audit logs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Monitoring
filesystems for errors</b> <br>
A single <b>FAN_FS_ERROR</b> event is stored per filesystem
at once. Extra error messages are suppressed and accounted
for in the <i>error_count</i> field of the existing
<b>FAN_FS_ERROR</b> event record, but details about the
errors are lost.</p>

<p style="margin-left:11%; margin-top: 1em">Errors reported
by <b>FAN_FS_ERROR</b> are generic <i>errno</i> values, but
not all kinds of error types are reported by all
filesystems.</p>

<p style="margin-left:11%; margin-top: 1em">Errors not
directly related to a file (i.e. super block corruption) are
reported with an invalid <i>file_handle</i>. For these
errors, the <i>file_handle</i> will have the field
<i>handle_type</i> set to <b>FILEID_INVALID</b>, and the
handle buffer size set to <b>0</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Closing the
fanotify file descriptor</b> <br>
When all file descriptors referring to the fanotify
notification group are closed, the fanotify group is
released and its resources are freed for reuse by the
kernel. Upon <b>close</b>(2), outstanding permission events
will be set to allowed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>/proc
interfaces</b> <br>
The file <i>/proc/</i>pid<i>/fdinfo/</i>fd contains
information about fanotify marks for file descriptor
<i>fd</i> of process <i>pid</i>. See <b>proc</b>(5) for
details.</p>

<p style="margin-left:11%; margin-top: 1em">Since Linux
5.13, the following interfaces can be used to control the
amount of kernel resources consumed by fanotify: <i><br>
/proc/sys/fs/fanotify/max_queued_events</i></p>

<p style="margin-left:22%;">The value in this file is used
when an application calls <b>fanotify_init</b>(2) to set an
upper limit on the number of events that can be queued to
the corresponding fanotify group. Events in excess of this
limit are dropped, but an <b>FAN_Q_OVERFLOW</b> event is
always generated. Prior to Linux kernel 5.13, the hardcoded
limit was 16384 events.</p>


<p style="margin-left:11%;"><i>/proc/sys/fs/fanotify/max_user_group</i></p>

<p style="margin-left:22%;">This specifies an upper limit
on the number of fanotify groups that can be created per
real user ID. Prior to Linux kernel 5.13, the hardcoded
limit was 128 groups per user.</p>


<p style="margin-left:11%;"><i>/proc/sys/fs/fanotify/max_user_marks</i></p>

<p style="margin-left:22%;">This specifies an upper limit
on the number of fanotify marks that can be created per real
user ID. Prior to Linux kernel 5.13, the hardcoded limit was
8192 marks per group (not per user).</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In addition to
the usual errors for <b>read</b>(2), the following errors
can occur when reading from the fanotify file
descriptor:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The buffer is too small to hold the event.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EMFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The per-process limit on the number of open files has
been reached. See the description of <b>RLIMIT_NOFILE</b> in
<b>getrlimit</b>(2).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENFILE</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The system-wide limit on the total number of open files
has been reached. See <i>/proc/sys/fs/file&minus;max</i> in
<b>proc</b>(5).</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>ETXTBSY</b></p>

<p style="margin-left:22%;">This error is returned by
<b>read</b>(2) if <b>O_RDWR</b> or <b>O_WRONLY</b> was
specified in the <i>event_f_flags</i> argument when calling
<b>fanotify_init</b>(2) and an event occurred for a
monitored file that is currently being executed.</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the usual errors for <b>write</b>(2), the following errors
can occur when writing to the fanotify file descriptor:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Fanotify access permissions are not enabled in the
kernel configuration or the value of <i>response</i> in the
response structure is not valid.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>The file descriptor <i>fd</i> in the response structure
is not valid. This may occur when a response for the
permission event has already been written.</p></td></tr>
</table>

<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Linux.</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The fanotify
API was introduced in Linux 2.6.36 and enabled in Linux
2.6.37. fdinfo support was added in Linux 3.8.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The fanotify
API is available only if the kernel was built with the
<b>CONFIG_FANOTIFY</b> configuration option enabled. In
addition, fanotify permission handling is available only if
the <b>CONFIG_FANOTIFY_ACCESS_PERMISSIONS</b> configuration
option is enabled.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Limitations
and caveats</b> <br>
Fanotify reports only events that a user-space program
triggers through the filesystem API. As a result, it does
not catch remote events that occur on network
filesystems.</p>

<p style="margin-left:11%; margin-top: 1em">The fanotify
API does not report file accesses and modifications that may
occur because of <b>mmap</b>(2), <b>msync</b>(2), and
<b>munmap</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">Events for
directories are created only if the directory itself is
opened, read, and closed. Adding, removing, or changing
children of a marked directory does not create events for
the monitored directory itself.</p>

<p style="margin-left:11%; margin-top: 1em">Fanotify
monitoring of directories is not recursive: to monitor
subdirectories under a directory, additional marks must be
created. The <b>FAN_CREATE</b> event can be used for
detecting when a subdirectory has been created under a
marked directory. An additional mark must then be set on the
newly created subdirectory. This approach is racy, because
it can lose events that occurred inside the newly created
subdirectory, before a mark is added on that subdirectory.
Monitoring mounts offers the capability to monitor a whole
directory tree in a race-free manner. Monitoring filesystems
offers the capability to monitor changes made from any mount
of a filesystem instance in a race-free manner.</p>

<p style="margin-left:11%; margin-top: 1em">The event queue
can overflow. In this case, events are lost.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Before Linux
3.19, <b>fallocate</b>(2) did not generate fanotify events.
Since Linux 3.19, calls to <b>fallocate</b>(2) generate
<b>FAN_MODIFY</b> events.</p>

<p style="margin-left:11%; margin-top: 1em">As of Linux
3.17, the following bugs exist:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em">On Linux, a filesystem object
may be accessible through multiple paths, for example, a
part of a filesystem may be remounted using the
<i>&minus;&minus;bind</i> option of <b>mount</b>(8). A
listener that marked a mount will be notified only of events
that were triggered for a filesystem object using the same
mount. Any other event will pass unnoticed.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>When an event is generated, no check is made to see
whether the user ID of the receiving process has
authorization to read or write the file before passing a
file descriptor for that file. This poses a security risk,
when the <b>CAP_SYS_ADMIN</b> capability is set for programs
executed by unprivileged users.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>If a call to <b>read</b>(2) processes multiple events
from the fanotify queue and an error occurs, the return
value will be the total length of the events successfully
copied to the user-space buffer before the error occurred.
The return value will not be &minus;1, and <i>errno</i> will
not be set. Thus, the reading application has no way to
detect the error.</p></td></tr>
</table>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The two example
programs below demonstrate the usage of the fanotify
API.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
program: fanotify_example.c</b> <br>
The first program is an example of fanotify being used with
its event object information passed in the form of a file
descriptor. The program marks the mount passed as a
command-line argument and waits for events of type
<b>FAN_OPEN_PERM</b> and <b>FAN_CLOSE_WRITE</b>. When a
permission event occurs, a <b>FAN_ALLOW</b> response is
given.</p>

<p style="margin-left:11%; margin-top: 1em">The following
shell session shows an example of running this program. This
session involved editing the file
<i>/home/user/temp/notes</i>. Before the file was opened, a
<b>FAN_OPEN_PERM</b> event occurred. After the file was
closed, a <b>FAN_CLOSE_WRITE</b> event occurred. Execution
of the program ends when the user presses the ENTER key.</p>

<p style="margin-left:17%; margin-top: 1em">#
<b>./fanotify_example /home</b> <br>
Press enter key to terminate. <br>
Listening for events. <br>
FAN_OPEN_PERM: File /home/user/temp/notes <br>
FAN_CLOSE_WRITE: File /home/user/temp/notes</p>

<p style="margin-left:17%; margin-top: 1em">Listening for
events stopped.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source: fanotify_example.c</b> <br>
#define _GNU_SOURCE /* Needed to get O_LARGEFILE definition
*/ <br>
#include &lt;errno.h&gt; <br>
#include &lt;fcntl.h&gt; <br>
#include &lt;limits.h&gt; <br>
#include &lt;poll.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;sys/fanotify.h&gt; <br>
#include &lt;unistd.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">/* Read all
available fanotify events from the file descriptor 'fd'.
*/</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
handle_events(int fd) <br>
{ <br>
const struct fanotify_event_metadata *metadata; <br>
struct fanotify_event_metadata buf[200]; <br>
ssize_t len; <br>
char path[PATH_MAX]; <br>
ssize_t path_len; <br>
char procfd_path[PATH_MAX]; <br>
struct fanotify_response response;</p>

<p style="margin-left:11%; margin-top: 1em">/* Loop while
events can be read from fanotify file descriptor. */</p>

<p style="margin-left:11%; margin-top: 1em">for (;;) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Read some
events. */</p>

<p style="margin-left:11%; margin-top: 1em">len = read(fd,
buf, sizeof(buf)); <br>
if (len == &minus;1 &amp;&amp; errno != EAGAIN) { <br>
perror(&quot;read&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Check if end
of available data reached. */</p>

<p style="margin-left:11%; margin-top: 1em">if (len &lt;=
0) <br>
break;</p>

<p style="margin-left:11%; margin-top: 1em">/* Point to the
first event in the buffer. */</p>

<p style="margin-left:11%; margin-top: 1em">metadata =
buf;</p>

<p style="margin-left:11%; margin-top: 1em">/* Loop over
all events in the buffer. */</p>

<p style="margin-left:11%; margin-top: 1em">while
(FAN_EVENT_OK(metadata, len)) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Check that
run&minus;time and compile&minus;time structures match.
*/</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;vers != FANOTIFY_METADATA_VERSION) {
<br>
fprintf(stderr, <br>
&quot;Mismatch of fanotify metadata version.\n&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/*
metadata&minus;&gt;fd contains either FAN_NOFD, indicating a
<br>
queue overflow, or a file descriptor (a nonnegative <br>
integer). Here, we simply ignore queue overflow. */</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;fd &gt;= 0) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Handle open
permission event. */</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;mask &amp; FAN_OPEN_PERM) { <br>
printf(&quot;FAN_OPEN_PERM: &quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Allow file
to be opened. */</p>

<p style="margin-left:11%; margin-top: 1em">response.fd =
metadata&minus;&gt;fd; <br>
response.response = FAN_ALLOW; <br>
write(fd, &amp;response, sizeof(response)); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Handle
closing of writable file event. */</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;mask &amp; FAN_CLOSE_WRITE) <br>
printf(&quot;FAN_CLOSE_WRITE: &quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Retrieve and
print pathname of the accessed file. */</p>


<p style="margin-left:11%; margin-top: 1em">snprintf(procfd_path,
sizeof(procfd_path), <br>
&quot;/proc/self/fd/%d&quot;, metadata&minus;&gt;fd); <br>
path_len = readlink(procfd_path, path, <br>
sizeof(path) &minus; 1); <br>
if (path_len == &minus;1) { <br>
perror(&quot;readlink&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">path[path_len]
= '\0'; <br>
printf(&quot;File %s\n&quot;, path);</p>

<p style="margin-left:11%; margin-top: 1em">/* Close the
file descriptor of the event. */</p>


<p style="margin-left:11%; margin-top: 1em">close(metadata&minus;&gt;fd);
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Advance to
next event. */</p>

<p style="margin-left:11%; margin-top: 1em">metadata =
FAN_EVENT_NEXT(metadata, len); <br>
} <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
char buf; <br>
int fd, poll_num; <br>
nfds_t nfds; <br>
struct pollfd fds[2];</p>

<p style="margin-left:11%; margin-top: 1em">/* Check mount
point is supplied. */</p>

<p style="margin-left:11%; margin-top: 1em">if (argc != 2)
{ <br>
fprintf(stderr, &quot;Usage: %s MOUNT\n&quot;, argv[0]);
<br>
exit(EXIT_FAILURE); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Press
enter key to terminate.\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Create the
file descriptor for accessing the fanotify API. */</p>

<p style="margin-left:11%; margin-top: 1em">fd =
fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT |
FAN_NONBLOCK, <br>
O_RDONLY | O_LARGEFILE); <br>
if (fd == &minus;1) { <br>
perror(&quot;fanotify_init&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Mark the
mount for: <br>
&minus; permission events before opening files <br>
&minus; notification events after closing a
write&minus;enabled <br>
file descriptor. */</p>

<p style="margin-left:11%; margin-top: 1em">if
(fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT, <br>
FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD, <br>
argv[1]) == &minus;1) { <br>
perror(&quot;fanotify_mark&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Prepare for
polling. */</p>

<p style="margin-left:11%; margin-top: 1em">nfds = 2;</p>

<p style="margin-left:11%; margin-top: 1em">fds[0].fd =
STDIN_FILENO; /* Console input */ <br>
fds[0].events = POLLIN;</p>

<p style="margin-left:11%; margin-top: 1em">fds[1].fd = fd;
/* Fanotify input */ <br>
fds[1].events = POLLIN;</p>

<p style="margin-left:11%; margin-top: 1em">/* This is the
loop to wait for incoming events. */</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Listening
for events.\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">while (1) {
<br>
poll_num = poll(fds, nfds, &minus;1); <br>
if (poll_num == &minus;1) { <br>
if (errno == EINTR) /* Interrupted by a signal */ <br>
continue; /* Restart poll() */</p>


<p style="margin-left:11%; margin-top: 1em">perror(&quot;poll&quot;);
/* Unexpected error */ <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if (poll_num
&gt; 0) { <br>
if (fds[0].revents &amp; POLLIN) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Console
input is available: empty stdin and quit. */</p>

<p style="margin-left:11%; margin-top: 1em">while
(read(STDIN_FILENO, &amp;buf, 1) &gt; 0 &amp;&amp; buf !=
'\n') <br>
continue; <br>
break; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if
(fds[1].revents &amp; POLLIN) {</p>

<p style="margin-left:11%; margin-top: 1em">/* Fanotify
events are available. */</p>


<p style="margin-left:11%; margin-top: 1em">handle_events(fd);
<br>
} <br>
} <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Listening
for events stopped.\n&quot;); <br>
exit(EXIT_SUCCESS); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
program: fanotify_fid.c</b> <br>
The second program is an example of fanotify being used with
a group that identifies objects by file handles. The program
marks the filesystem object that is passed as a command-line
argument and waits until an event of type <b>FAN_CREATE</b>
has occurred. The event mask indicates which type of
filesystem object&mdash;either a file or a
directory&mdash;was created. Once all events have been read
from the buffer and processed accordingly, the program
simply terminates.</p>

<p style="margin-left:11%; margin-top: 1em">The following
shell sessions show two different invocations of this
program, with different actions performed on a watched
object.</p>

<p style="margin-left:11%; margin-top: 1em">The first
session shows a mark being placed on <i>/home/user</i>. This
is followed by the creation of a regular file,
<i>/home/user/testfile.txt</i>. This results in a
<b>FAN_CREATE</b> event being generated and reported against
the file&rsquo;s parent watched directory object and with
the created file name. Program execution ends once all
events captured within the buffer have been processed.</p>

<p style="margin-left:17%; margin-top: 1em">#
<b>./fanotify_fid /home/user</b> <br>
Listening for events. <br>
FAN_CREATE (file created): <br>
Directory /home/user has been modified. <br>
Entry 'testfile.txt' is not a subdirectory. <br>
All events processed successfully. Program exiting.</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>touch
/home/user/testfile.txt</b> # In another terminal</p>

<p style="margin-left:11%; margin-top: 1em">The second
session shows a mark being placed on <i>/home/user</i>. This
is followed by the creation of a directory,
<i>/home/user/testdir</i>. This specific action results in a
<b>FAN_CREATE</b> event being generated and is reported with
the <b>FAN_ONDIR</b> flag set and with the created directory
name.</p>

<p style="margin-left:17%; margin-top: 1em">#
<b>./fanotify_fid /home/user</b> <br>
Listening for events. <br>
FAN_CREATE | FAN_ONDIR (subdirectory created): <br>
Directory /home/user has been modified. <br>
Entry 'testdir' is a subdirectory. <br>
All events processed successfully. Program exiting.</p>

<p style="margin-left:17%; margin-top: 1em">$ <b>mkdir
&minus;p /home/user/testdir</b> # In another terminal</p>

<p style="margin-left:11%; margin-top: 1em"><b>Program
source: fanotify_fid.c</b> <br>
#define _GNU_SOURCE <br>
#include &lt;errno.h&gt; <br>
#include &lt;fcntl.h&gt; <br>
#include &lt;limits.h&gt; <br>
#include &lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;sys/types.h&gt; <br>
#include &lt;sys/stat.h&gt; <br>
#include &lt;sys/fanotify.h&gt; <br>
#include &lt;unistd.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">#define
BUF_SIZE 256</p>

<p style="margin-left:11%; margin-top: 1em">int <br>
main(int argc, char *argv[]) <br>
{ <br>
int fd, ret, event_fd, mount_fd; <br>
ssize_t len, path_len; <br>
char path[PATH_MAX]; <br>
char procfd_path[PATH_MAX]; <br>
char events_buf[BUF_SIZE]; <br>
struct file_handle *file_handle; <br>
struct fanotify_event_metadata *metadata; <br>
struct fanotify_event_info_fid *fid; <br>
const char *file_name; <br>
struct stat sb;</p>

<p style="margin-left:11%; margin-top: 1em">if (argc != 2)
{ <br>
fprintf(stderr, &quot;Invalid number of command line
arguments.\n&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">mount_fd =
open(argv[1], O_DIRECTORY | O_RDONLY); <br>
if (mount_fd == &minus;1) { <br>
perror(argv[1]); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Create an
fanotify file descriptor with FAN_REPORT_DFID_NAME as <br>
a flag so that program can receive fid events with directory
<br>
entry name. */</p>

<p style="margin-left:11%; margin-top: 1em">fd =
fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_DFID_NAME, 0);
<br>
if (fd == &minus;1) { <br>
perror(&quot;fanotify_init&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Place a mark
on the filesystem object supplied in argv[1]. */</p>

<p style="margin-left:11%; margin-top: 1em">ret =
fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR, <br>
FAN_CREATE | FAN_ONDIR, <br>
AT_FDCWD, argv[1]); <br>
if (ret == &minus;1) { <br>
perror(&quot;fanotify_mark&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;Listening
for events.\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">/* Read events
from the event queue into a buffer. */</p>

<p style="margin-left:11%; margin-top: 1em">len = read(fd,
events_buf, sizeof(events_buf)); <br>
if (len == &minus;1 &amp;&amp; errno != EAGAIN) { <br>
perror(&quot;read&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Process all
events within the buffer. */</p>

<p style="margin-left:11%; margin-top: 1em">for (metadata =
(struct fanotify_event_metadata *) events_buf; <br>
FAN_EVENT_OK(metadata, len); <br>
metadata = FAN_EVENT_NEXT(metadata, len)) { <br>
fid = (struct fanotify_event_info_fid *) (metadata + 1);
<br>
file_handle = (struct file_handle *)
fid&minus;&gt;handle;</p>

<p style="margin-left:11%; margin-top: 1em">/* Ensure that
the event info is of the correct type. */</p>

<p style="margin-left:11%; margin-top: 1em">if
(fid&minus;&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_FID ||
<br>
fid&minus;&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_DFID) {
<br>
file_name = NULL; <br>
} else if (fid&minus;&gt;hdr.info_type ==
FAN_EVENT_INFO_TYPE_DFID_NAME) { <br>
file_name = file_handle&minus;&gt;f_handle + <br>
file_handle&minus;&gt;handle_bytes; <br>
} else { <br>
fprintf(stderr, &quot;Received unexpected event info
type.\n&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;mask == FAN_CREATE) <br>
printf(&quot;FAN_CREATE (file created):\n&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">if
(metadata&minus;&gt;mask == (FAN_CREATE | FAN_ONDIR)) <br>
printf(&quot;FAN_CREATE | FAN_ONDIR (subdirectory
created):\n&quot;);</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>/* metadata&minus;&gt;fd is set to FAN_NOFD when the
group identifies</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>objects by file handles. To obtain a file descriptor
for</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>the file object corresponding to an event you can use
the</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>struct file_handle that's provided within the</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>fanotify_event_info_fid in conjunction with the</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>open_by_handle_at(2) system call. A check for ESTALE
is</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>done to accommodate for the situation where the file
handle</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>for the object was deleted prior to this system call.
*/</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">event_fd =
open_by_handle_at(mount_fd, file_handle, O_RDONLY); <br>
if (event_fd == &minus;1) { <br>
if (errno == ESTALE) { <br>
printf(&quot;File handle is no longer valid. &quot; <br>
&quot;File has been deleted\n&quot;); <br>
continue; <br>
} else { <br>
perror(&quot;open_by_handle_at&quot;); <br>
exit(EXIT_FAILURE); <br>
} <br>
}</p>


<p style="margin-left:11%; margin-top: 1em">snprintf(procfd_path,
sizeof(procfd_path), &quot;/proc/self/fd/%d&quot;, <br>
event_fd);</p>

<p style="margin-left:11%; margin-top: 1em">/* Retrieve and
print the path of the modified dentry. */</p>

<p style="margin-left:11%; margin-top: 1em">path_len =
readlink(procfd_path, path, sizeof(path) &minus; 1); <br>
if (path_len == &minus;1) { <br>
perror(&quot;readlink&quot;); <br>
exit(EXIT_FAILURE); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">path[path_len]
= '\0'; <br>
printf(&quot;\tDirectory '%s' has been modified.\n&quot;,
path);</p>

<p style="margin-left:11%; margin-top: 1em">if (file_name)
{ <br>
ret = fstatat(event_fd, file_name, &amp;sb, 0); <br>
if (ret == &minus;1) { <br>
if (errno != ENOENT) { <br>
perror(&quot;fstatat&quot;); <br>
exit(EXIT_FAILURE); <br>
} <br>
printf(&quot;\tEntry '%s' does not exist.\n&quot;,
file_name); <br>
} else if ((sb.st_mode &amp; S_IFMT) == S_IFDIR) { <br>
printf(&quot;\tEntry '%s' is a subdirectory.\n&quot;,
file_name); <br>
} else { <br>
printf(&quot;\tEntry '%s' is not a subdirectory.\n&quot;,
<br>
file_name); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* Close
associated file descriptor for this event. */</p>


<p style="margin-left:11%; margin-top: 1em">close(event_fd);
<br>
}</p>


<p style="margin-left:11%; margin-top: 1em">printf(&quot;All
events processed successfully. Program exiting.\n&quot;);
<br>
exit(EXIT_SUCCESS); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>fanotify_init</b>(2),
<b>fanotify_mark</b>(2), <b>inotify</b>(7)</p>
<hr>
</body>
</html>
