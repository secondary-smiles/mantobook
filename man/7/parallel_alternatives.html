<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:57:02 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PARALLEL_ALTERNATIVES</title>

</head>
<body>
<h1>parallel_alternatives</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">parallel_alternatives
&minus; Alternatives to GNU parallel</p>

<h2>DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES
<a name="DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are a lot
programs that share functionality with <small>GNU</small>
<b>parallel</b>. Some of these are specialized tools, and
while <small>GNU</small> <b>parallel</b> can emulate many of
them, a specialized tool can be better at a given task.
<small>GNU</small> <b>parallel</b> strives to include the
best of the general functionality without sacrificing ease
of use.</p>


<p style="margin-left:11%; margin-top: 1em"><b>parallel</b>
has existed since 2002&minus;01&minus;06 and as
<small>GNU</small> <b>parallel</b> since 2010. A lot of the
alternatives have not had the vitality to survive that long,
but have come and gone during that time.</p>


<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel</b> is actively maintained with a new release
every month since 2010. Most other alternatives are fleeting
interests of the developers with irregular releases and only
maintained for a few years.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>SUMMARY
LEGEND</small></b> <br>
The following features are in some of the comparable
tools:</p>

<p style="margin-left:11%; margin-top: 1em"><i>Inputs</i>
<br>
I1. Arguments can be read from stdin <br>
I2. Arguments can be read from a file <br>
I3. Arguments can be read from multiple files <br>
I4. Arguments can be read from command line <br>
I5. Arguments can be read from a table <br>
I6. Arguments can be read from the same file using #!
(shebang) <br>
I7. Line oriented input as default (Quoting of special chars
not <br>
needed)</p>


<p style="margin-left:11%; margin-top: 1em"><i>Manipulation
of input</i> <br>
M1. Composed command <br>
M2. Multiple arguments can fill up an execution line <br>
M3. Arguments can be put anywhere in the execution line <br>
M4. Multiple arguments can be put anywhere in the execution
line <br>
M5. Arguments can be replaced with context <br>
M6. Input can be treated as the complete command line</p>

<p style="margin-left:11%; margin-top: 1em"><i>Outputs</i>
<br>
O1. Grouping output so output from different jobs do not mix
<br>
O2. Send stderr (standard error) to stderr (standard error)
<br>
O3. Send stdout (standard output) to stdout (standard
output) <br>
O4. Order of output can be same as order of input <br>
O5. Stdout only contains stdout (standard output) from the
command <br>
O6. Stderr only contains stderr (standard error) from the
command <br>
O7. Buffering on disk <br>
O8. No temporary files left if killed <br>
O9. Test if disk runs full during run <br>
O10. Output of a line bigger than 4 <small>GB</small></p>


<p style="margin-left:11%; margin-top: 1em"><i>Execution</i>
<br>
E1. Run jobs in parallel <br>
E2. List running jobs <br>
E3. Finish running jobs, but do not start new jobs <br>
E4. Number of running jobs can depend on number of cpus <br>
E5. Finish running jobs, but do not start new jobs after
first failure <br>
E6. Number of running jobs can be adjusted while running
<br>
E7. Only spawn new jobs if load is less than a limit</p>

<p style="margin-left:11%; margin-top: 1em"><i>Remote
execution</i> <br>
R1. Jobs can be run on remote computers <br>
R2. Basefiles can be transferred <br>
R3. Argument files can be transferred <br>
R4. Result files can be transferred <br>
R5. Cleanup of transferred files <br>
R6. No config files needed <br>
R7. Do not run more than <small>SSHD</small> &rsquo;s
MaxStartups can handle <br>
R8. Configurable <small>SSH</small> command <br>
R9. Retry if connection breaks occasionally</p>


<p style="margin-left:11%; margin-top: 1em"><i>Semaphore</i>
<br>
S1. Possibility to work as a mutex <br>
S2. Possibility to work as a counting semaphore</p>

<p style="margin-left:11%; margin-top: 1em"><i>Legend</i>
<br>
&minus; = no <br>
x = not applicable <small><br>
ID</small> = yes</p>

<p style="margin-left:11%; margin-top: 1em">As every new
version of the programs are not tested the table may be
outdated. Please file a bug report if you find errors (See
<small>REPORTING BUGS</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">parallel: <br>
I1 I2 I3 I4 I5 I6 I7 <br>
M1 M2 M3 M4 M5 M6 <br>
O1 O2 O3 O4 O5 O6 O7 O8 O9 O10 <br>
E1 E2 E3 E4 E5 E6 E7 <br>
R1 R2 R3 R4 R5 R6 R7 R8 R9 <br>
S1 S2</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> xargs <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 I2 &minus; &minus; &minus; &minus; &minus; <br>
&minus; M2 M3 &minus; &minus; &minus; <br>
&minus; O2 O3 &minus; O5 O6 <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; x &minus; &minus;
&minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>xargs</b> offers some of the
same possibilities as <small>GNU</small>
<b>parallel</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>xargs</b>
deals badly with special characters (such as space, \,
&rsquo; and &quot;). To see the problem try this:</p>

<p style="margin-left:11%; margin-top: 1em">touch
important_file <br>
touch 'not important_file' <br>
ls not* | xargs rm <br>
mkdir &minus;p &quot;My brother's 12\&quot; records&quot;
<br>
ls | xargs rmdir <br>
touch 'c:\windows\system32\clfs.sys' <br>
echo 'c:\windows\system32\clfs.sys' | xargs ls &minus;l</p>

<p style="margin-left:11%; margin-top: 1em">You can specify
<b>&minus;0</b>, but many input generators are not optimized
for using <b><small>NUL</small></b> as separator but are
optimized for <b>newline</b> as separator. E.g. <b>awk</b>,
<b>ls</b>, <b>echo</b>, <b>tar &minus;v</b>, <b>head</b>
(requires using <b>&minus;z</b>), <b>tail</b> (requires
using <b>&minus;z</b>), <b>sed</b> (requires using
<b>&minus;z</b>), <b>perl</b> (<b>&minus;0</b> and \0
instead of \n), <b>locate</b> (requires using
<b>&minus;0</b>), <b>find</b> (requires using
<b>&minus;print0</b>), <b>grep</b> (requires using
<b>&minus;z</b> or <b>&minus;Z</b>), <b>sort</b> (requires
using <b>&minus;z</b>).</p>


<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel</b>&rsquo;s newline separation can be emulated
with:</p>

<p style="margin-left:11%; margin-top: 1em">cat | xargs
&minus;d &quot;\n&quot; &minus;n1 command</p>

<p style="margin-left:11%; margin-top: 1em"><b>xargs</b>
can run a given number of jobs in parallel, but has no
support for running number-of-cpu-cores jobs in
parallel.</p>

<p style="margin-left:11%; margin-top: 1em"><b>xargs</b>
has no support for grouping the output, therefore output may
run together, e.g. the first half of a line is from one
process and the last half of the line is from another
process. The example <b>Parallel grep</b> cannot be done
reliably with <b>xargs</b> because of this. To see this in
action try:</p>

<p style="margin-left:11%; margin-top: 1em">parallel perl
&minus;e
&quot;'&quot;'$a=&quot;1&quot;.&quot;{}&quot;x10000000;print
$a,&quot;\n&quot;'&quot;'&quot; \ <br>
'&gt;' {} ::: a b c d e f g h <br>
# Serial = no mixing = the wanted result <br>
# 'tr &minus;s a&minus;z' squeezes repeating letters into a
single letter <br>
echo a b c d e f g h | xargs &minus;P1 &minus;n1 grep 1 | tr
&minus;s a&minus;z <br>
# Compare to 8 jobs in parallel <br>
parallel &minus;kP8 &minus;n1 grep 1 ::: a b c d e f g h |
tr &minus;s a&minus;z <br>
echo a b c d e f g h | xargs &minus;P8 &minus;n1 grep 1 | tr
&minus;s a&minus;z <br>
echo a b c d e f g h | xargs &minus;P8 &minus;n1 grep
&minus;&minus;line&minus;buffered 1 | \ <br>
tr &minus;s a&minus;z</p>

<p style="margin-left:11%; margin-top: 1em">Or try
this:</p>

<p style="margin-left:11%; margin-top: 1em">slow_seq() {
<br>
echo Count to &quot;$@&quot; <br>
seq &quot;$@&quot; | <br>
perl &minus;ne '$|=1; for(split//){ print;
select($a,$a,$a,0.100);}' <br>
} <br>
export &minus;f slow_seq <br>
# Serial = no mixing = the wanted result <br>
seq 8 | xargs &minus;n1 &minus;P1 &minus;I {} bash &minus;c
'slow_seq {}' <br>
# Compare to 8 jobs in parallel <br>
seq 8 | parallel &minus;P8 slow_seq {} <br>
seq 8 | xargs &minus;n1 &minus;P8 &minus;I {} bash &minus;c
'slow_seq {}'</p>

<p style="margin-left:11%; margin-top: 1em"><b>xargs</b>
has no support for keeping the order of the output,
therefore if running jobs in parallel using <b>xargs</b> the
output of the second job cannot be postponed till the first
job is done.</p>

<p style="margin-left:11%; margin-top: 1em"><b>xargs</b>
has no support for running jobs on remote computers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>xargs</b>
has no support for context replace, so you will have to
create the arguments.</p>

<p style="margin-left:11%; margin-top: 1em">If you use a
replace string in <b>xargs</b> (<b>&minus;I</b>) you can not
force <b>xargs</b> to use more than one argument.</p>

<p style="margin-left:11%; margin-top: 1em">Quoting in
<b>xargs</b> works like <b>&minus;q</b> in
<small>GNU</small> <b>parallel</b>. This means composed
commands and redirection require using <b>bash
&minus;c</b>.</p>

<p style="margin-left:11%; margin-top: 1em">ls | parallel
&quot;wc {} &gt;{}.wc&quot; <br>
ls | parallel &quot;echo {}; ls {}|wc&quot;</p>

<p style="margin-left:11%; margin-top: 1em">becomes
(assuming you have 8 cores and that none of the filenames
contain space, &quot; or &rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">ls | xargs
&minus;d &quot;\n&quot; &minus;P8 &minus;I {} bash &minus;c
&quot;wc {} &gt;{}.wc&quot; <br>
ls | xargs &minus;d &quot;\n&quot; &minus;P8 &minus;I {}
bash &minus;c &quot;echo {}; ls {}|wc&quot;</p>

<p style="margin-left:11%; margin-top: 1em">A more extreme
example can be found on:
https://unix.stackexchange.com/q/405552/</p>


<p style="margin-left:11%; margin-top: 1em">https://www.gnu.org/software/findutils/</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> find &minus;exec <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
&minus; &minus; &minus; x &minus; x &minus; <br>
&minus; M2 M3 &minus; &minus; &minus; &minus; <br>
&minus; O2 O3 O4 O5 O6 <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus; <br>
x x</p>

<p style="margin-left:11%; margin-top: 1em"><b>find
&minus;exec</b> offers some of the same possibilities as
<small>GNU</small> <b>parallel</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>find
&minus;exec</b> only works on files. Processing other input
(such as hosts or URLs) will require creating these inputs
as files. <b>find &minus;exec</b> has no support for running
commands in parallel.</p>


<p style="margin-left:11%; margin-top: 1em">https://www.gnu.org/software/findutils/
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> make &minus;j <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; <br>
O1 O2 O3 &minus; x O6 <br>
E1 &minus; &minus; &minus; E5 &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus; <br>
&minus; &minus;</p>

<p style="margin-left:11%; margin-top: 1em"><b>make
&minus;j</b> can run jobs in parallel, but requires a
crafted Makefile to do this. That results in extra quoting
to get filenames containing newlines to work correctly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>make
&minus;j</b> computes a dependency graph before running
jobs. Jobs run by <small>GNU</small> <b>parallel</b> does
not depend on each other.</p>

<p style="margin-left:11%; margin-top: 1em">(Very early
versions of <small>GNU</small> <b>parallel</b> were
coincidentally implemented using <b>make &minus;j</b>).</p>


<p style="margin-left:11%; margin-top: 1em">https://www.gnu.org/software/make/
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> ppss <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 I2 &minus; &minus; &minus; &minus; I7 <br>
M1 &minus; M3 &minus; &minus; M6 <br>
O1 &minus; &minus; x &minus; &minus; <br>
E1 E2 ?E3 E4 &minus; &minus; &minus; <br>
R1 R2 R3 R4 &minus; &minus; ?R7 ? ?</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>ppss</b> is also a tool for
running jobs in parallel.</p>

<p style="margin-left:11%; margin-top: 1em">The output of
<b>ppss</b> is status information and thus not useful for
using as input for another command. The output from the jobs
are put into files.</p>

<p style="margin-left:11%; margin-top: 1em">The argument
replace string ($ITEM) cannot be changed. Arguments must be
quoted &minus; thus arguments containing special characters
(space &rsquo;&quot;&amp;!*) may cause problems. More than
one argument is not supported. Filenames containing newlines
are not processed correctly. When reading input from a file
null cannot be used as a terminator. <b>ppss</b> needs to
read the whole input file before starting any jobs.</p>

<p style="margin-left:11%; margin-top: 1em">Output and
status information is stored in ppss_dir and thus requires
cleanup when completed. If the dir is not removed before
running <b>ppss</b> again it may cause nothing to happen as
<b>ppss</b> thinks the task is already done.
<small>GNU</small> <b>parallel</b> will normally not need
cleaning up if running locally and will only need cleaning
up if stopped abnormally and running remote
(<b>&minus;&minus;cleanup</b> may not complete if stopped
abnormally). The example <b>Parallel grep</b> would require
extra postprocessing if written using <b>ppss</b>.</p>

<p style="margin-left:11%; margin-top: 1em">For remote
systems <small>PPSS</small> requires 3 steps: config,
deploy, and start. <small>GNU</small> <b>parallel</b> only
requires one step.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> ppss <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from <b>ppss</b>&rsquo;s manual page with the
equivalent using <small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">1$ ./ppss.sh
standalone &minus;d /path/to/files &minus;c 'gzip ' <br>
1$ find /path/to/files &minus;type f | parallel gzip <br>
2$ ./ppss.sh standalone &minus;d /path/to/files \ <br>
&minus;c 'cp &quot;$ITEM&quot; /destination/dir ' <br>
2$ find /path/to/files &minus;type f | parallel cp {}
/destination/dir <br>
3$ ./ppss.sh standalone &minus;f
list&minus;of&minus;urls.txt &minus;c 'wget &minus;q ' <br>
3$ parallel &minus;a list&minus;of&minus;urls.txt wget
&minus;q <br>
4$ ./ppss.sh standalone &minus;f
list&minus;of&minus;urls.txt &minus;c 'wget &minus;q
&quot;$ITEM&quot;' <br>
4$ parallel &minus;a list&minus;of&minus;urls.txt wget
&minus;q {} <br>
5$ ./ppss config &minus;C config.cfg &minus;c 'encode.sh '
&minus;d /source/dir \ <br>
&minus;m 192.168.1.100 &minus;u ppss &minus;k
ppss&minus;key.key &minus;S ./encode.sh \ <br>
&minus;n nodes.txt &minus;o /some/output/dir
&minus;&minus;upload &minus;&minus;download; <br>
./ppss deploy &minus;C config.cfg <br>
./ppss start &minus;C config <br>
5$ # parallel does not use configs. If you want <br>
# a different username put it in nodes.txt: user@hostname
<br>
find source/dir &minus;type f | <br>
parallel &minus;&minus;sshloginfile nodes.txt
&minus;&minus;trc {.}.mp3 \ <br>
lame &minus;a {} &minus;o {.}.mp3 &minus;&minus;preset
standard &minus;&minus;quiet <br>
6$ ./ppss stop &minus;C config.cfg <br>
6$ killall &minus;TERM parallel <br>
7$ ./ppss pause &minus;C config.cfg <br>
7$ Press: CTRL&minus;Z or killall &minus;SIGTSTP parallel
<br>
8$ ./ppss continue &minus;C config.cfg <br>
8$ Enter: fg or killall &minus;SIGCONT parallel <br>
9$ ./ppss.sh status &minus;C config.cfg <br>
9$ killall &minus;SIGUSR2 parallel</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/louwrentius/PPSS
(Last checked: 2010&minus;12)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> pexec <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 I2 &minus; I4 I5 &minus; &minus; <br>
M1 &minus; M3 &minus; &minus; M6 <br>
O1 O2 O3 &minus; O5 O6 <br>
E1 &minus; &minus; E4 &minus; E6 &minus; <br>
R1 &minus; &minus; &minus; &minus; R6 &minus; &minus;
&minus; <br>
S1 &minus;</p>

<p style="margin-left:11%; margin-top: 1em"><b>pexec</b> is
also a tool for running jobs in parallel.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> pexec <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from <b>pexec</b>&rsquo;s info page with the
equivalent using <small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">1$ pexec
&minus;o sqrt&minus;%s.dat &minus;p &quot;$(seq 10)&quot;
&minus;e NUM &minus;n 4 &minus;c &minus;&minus; \ <br>
'echo &quot;scale=10000;sqrt($NUM)&quot; | bc' <br>
1$ seq 10 | parallel &minus;j4 'echo
&quot;scale=10000;sqrt({})&quot; | \ <br>
bc &gt; sqrt&minus;{}.dat' <br>
2$ pexec &minus;p &quot;$(ls myfiles*.ext)&quot; &minus;i %s
&minus;o %s.sort &minus;&minus; sort <br>
2$ ls myfiles*.ext | parallel sort {}
&quot;&gt;{}.sort&quot; <br>
3$ pexec &minus;f image.list &minus;n auto &minus;e B
&minus;u star.log &minus;c &minus;&minus; \ <br>
'fistar $B.fits &minus;f 100 &minus;F id,x,y,flux &minus;o
$B.star' <br>
3$ parallel &minus;a image.list \ <br>
'fistar {}.fits &minus;f 100 &minus;F id,x,y,flux &minus;o
{}.star' 2&gt;star.log <br>
4$ pexec &minus;r *.png &minus;e IMG &minus;c &minus;o
&minus; &minus;&minus; \ <br>
'convert $IMG ${IMG%.png}.jpeg ; &quot;echo $IMG:
done&quot;' <br>
4$ ls *.png | parallel 'convert {} {.}.jpeg; echo {}: done'
<br>
5$ pexec &minus;r *.png &minus;i %s &minus;o %s.jpg &minus;c
'pngtopnm | pnmtojpeg' <br>
5$ ls *.png | parallel 'pngtopnm &lt; {} | pnmtojpeg &gt;
{}.jpg' <br>
6$ for p in *.png ; do echo ${p%.png} ; done | \ <br>
pexec &minus;f &minus; &minus;i %s.png &minus;o %s.jpg
&minus;c 'pngtopnm | pnmtojpeg' <br>
6$ ls *.png | parallel 'pngtopnm &lt; {} | pnmtojpeg &gt;
{.}.jpg' <br>
7$ LIST=$(for p in *.png ; do echo ${p%.png} ; done) <br>
pexec &minus;r $LIST &minus;i %s.png &minus;o %s.jpg
&minus;c 'pngtopnm | pnmtojpeg' <br>
7$ ls *.png | parallel 'pngtopnm &lt; {} | pnmtojpeg &gt;
{.}.jpg' <br>
8$ pexec &minus;n 8 &minus;r *.jpg &minus;y unix &minus;e
IMG &minus;c \ <br>
'pexec &minus;j &minus;m blockread &minus;d $IMG | \ <br>
jpegtopnm | pnmscale 0.5 | pnmtojpeg | \ <br>
pexec &minus;j &minus;m blockwrite &minus;s th_$IMG' <br>
8$ # Combining GNU B&lt;parallel&gt; and GNU B&lt;sem&gt;.
<br>
ls *jpg | parallel &minus;j8 'sem &minus;&minus;id blockread
cat {} | jpegtopnm |' \ <br>
'pnmscale 0.5 | pnmtojpeg | sem &minus;&minus;id blockwrite
cat &gt; th_{}' <br>
# If reading and writing is done to the same disk, this may
be <br>
# faster as only one process will be either reading or
writing: <br>
ls *jpg | parallel &minus;j8 'sem &minus;&minus;id diskio
cat {} | jpegtopnm |' \ <br>
'pnmscale 0.5 | pnmtojpeg | sem &minus;&minus;id diskio cat
&gt; th_{}'</p>


<p style="margin-left:11%; margin-top: 1em">https://www.gnu.org/software/pexec/
(Last checked: 2010&minus;12)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> xjobs <small>AND GNU</small> Parallel <br>
xjobs</b> is also a tool for running jobs in parallel. It
only supports running jobs on your local computer.</p>

<p style="margin-left:11%; margin-top: 1em"><b>xjobs</b>
deals badly with special characters just like <b>xargs</b>.
See the section <b><small>DIFFERENCES BETWEEN</small> xargs
<small>AND GNU</small> Parallel</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> xjobs <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from <b>xjobs</b>&rsquo;s man page with the
equivalent using <small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">1$ ls &minus;1
*.zip | xjobs unzip <br>
1$ ls *.zip | parallel unzip <br>
2$ ls &minus;1 *.zip | xjobs &minus;n unzip <br>
2$ ls *.zip | parallel unzip &gt;/dev/null <br>
3$ find . &minus;name '*.bak' | xjobs gzip <br>
3$ find . &minus;name '*.bak' | parallel gzip <br>
4$ ls &minus;1 *.jar | sed 's/\(.*\)/\1 &gt; \1.idx/' |
xjobs jar tf <br>
4$ ls *.jar | parallel jar tf {} '&gt;' {}.idx <br>
5$ xjobs &minus;s script <br>
5$ cat script | parallel <br>
6$ mkfifo /var/run/my_named_pipe; <br>
xjobs &minus;s /var/run/my_named_pipe &amp; <br>
echo unzip 1.zip &gt;&gt; /var/run/my_named_pipe; <br>
echo tar cf /backup/myhome.tar /home/me &gt;&gt;
/var/run/my_named_pipe <br>
6$ mkfifo /var/run/my_named_pipe; <br>
cat /var/run/my_named_pipe | parallel &amp; <br>
echo unzip 1.zip &gt;&gt; /var/run/my_named_pipe; <br>
echo tar cf /backup/myhome.tar /home/me &gt;&gt;
/var/run/my_named_pipe</p>


<p style="margin-left:11%; margin-top: 1em">https://www.maier&minus;komor.de/xjobs.html
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> prll <small>AND GNU</small> Parallel <br>
prll</b> is also a tool for running jobs in parallel. It
does not support running jobs on remote computers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>prll</b>
encourages using <small>BASH</small> aliases and
<small>BASH</small> functions instead of scripts.
<small>GNU</small> <b>parallel</b> supports scripts
directly, functions if they are exported using <b>export
&minus;f</b>, and aliases if using <b>env_parallel</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>prll</b>
generates a lot of status information on stderr (standard
error) which makes it harder to use the stderr (standard
error) output of the job directly as input for another
program.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> prll&rsquo;s <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here is the
example from <b>prll</b>&rsquo;s man page with the
equivalent using <small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">1$ prll
&minus;s 'mogrify &minus;flip $1' *.jpg <br>
1$ parallel mogrify &minus;flip ::: *.jpg</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/exzombie/prll
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> dxargs <small>AND GNU</small> Parallel <br>
dxargs</b> is also a tool for running jobs in parallel.</p>

<p style="margin-left:11%; margin-top: 1em"><b>dxargs</b>
does not deal well with more simultaneous jobs than
<small>SSHD</small> &rsquo;s MaxStartups. <b>dxargs</b> is
only built for remote run jobs, but does not support
transferring of files.</p>


<p style="margin-left:11%; margin-top: 1em">https://web.archive.org/web/20120518070250/http://www.
semicomplete.com/blog/geekery/distributed&minus;xargs.html
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> mdm/middleman <small>AND GNU</small>
Parallel</b> <br>
middleman(mdm) is also a tool for running jobs in
parallel.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> middleman&rsquo;s
<small>WEBSITE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
shellscripts of
https://web.archive.org/web/20110728064735/http://mdm.
berlios.de/usage.html ported to <small>GNU</small>
<b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">1$ seq 19 |
parallel buffon &minus;o &minus; | sort &minus;n &gt; result
<br>
cat files | parallel cmd <br>
find dir &minus;execdir sem cmd {} \;</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/cklin/mdm
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> xapply <small>AND GNU</small> Parallel <br>
xapply</b> can run jobs in parallel on the local
computer.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> xapply&rsquo;s <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from <b>xapply</b>&rsquo;s man page with the
equivalent using <small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">1$ xapply '(cd
%1 &amp;&amp; make all)' */ <br>
1$ parallel 'cd {} &amp;&amp; make all' ::: */ <br>
2$ xapply &minus;f 'diff %1 ../version5/%1' manifest | more
<br>
2$ parallel diff {} ../version5/{} &lt; manifest | more <br>
3$ xapply &minus;p/dev/null &minus;f 'diff %1 %2' manifest1
checklist1 <br>
3$ parallel &minus;&minus;link diff {1} {2} :::: manifest1
checklist1 <br>
4$ xapply 'indent' *.c <br>
4$ parallel indent ::: *.c <br>
5$ find ~ksb/bin &minus;type f ! &minus;perm &minus;111
&minus;print | \ <br>
xapply &minus;f &minus;v 'chmod a+x' &minus; <br>
5$ find ~ksb/bin &minus;type f ! &minus;perm &minus;111
&minus;print | \ <br>
parallel &minus;v chmod a+x <br>
6$ find */ &minus;... | fmt 960 1024 | xapply &minus;f
&minus;i /dev/tty 'vi' &minus; <br>
6$ sh &lt;(find */ &minus;... | parallel &minus;s 1024 echo
vi) <br>
6$ find */ &minus;... | parallel &minus;s 1024 &minus;Xuj1
vi <br>
7$ find ... | xapply &minus;f &minus;5 &minus;i /dev/tty
'vi' &minus; &minus; &minus; &minus; &minus; <br>
7$ sh &lt;(find ... | parallel &minus;n5 echo vi) <br>
7$ find ... | parallel &minus;n5 &minus;uj1 vi <br>
8$ xapply &minus;fn &quot;&quot; /etc/passwd <br>
8$ parallel &minus;k echo &lt; /etc/passwd <br>
9$ tr ':' '\012' &lt; /etc/passwd | \ <br>
xapply &minus;7 &minus;nf 'chown %1 %6' &minus; &minus;
&minus; &minus; &minus; &minus; &minus; <br>
9$ tr ':' '\012' &lt; /etc/passwd | parallel &minus;N7 chown
{1} {6} <br>
10$ xapply '[ &minus;d %1/RCS ] || echo %1' */ <br>
10$ parallel '[ &minus;d {}/RCS ] || echo {}' ::: */ <br>
11$ xapply &minus;f '[ &minus;f %1 ] &amp;&amp; echo %1'
List | ... <br>
11$ parallel '[ &minus;f {} ] &amp;&amp; echo {}' &lt; List
| ...</p>


<p style="margin-left:11%; margin-top: 1em">https://www.databits.net/~ksb/msrc/local/bin/xapply/xapply.html
(Last checked: 2010&minus;12)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN AIX</small> apply <small>AND GNU</small> Parallel
<br>
apply</b> can build command lines based on a template and
arguments &minus; very much like <small>GNU</small>
<b>parallel</b>. <b>apply</b> does not run jobs in parallel.
<b>apply</b> does not use an argument separator (like
<b>:::</b>); instead the template must be the first
argument.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM IBM</small> &rsquo;s <small>KNOWLEDGE
CENTER</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from <small>IBM</small> &rsquo;s Knowledge Center
and the corresponding command using <small>GNU</small>
<b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">To obtain
results similar to those of the <b>ls</b> command,
enter:</p>

<p style="margin-left:11%; margin-top: 1em">1$ apply echo *
<br>
1$ parallel echo ::: *</p>

<p style="margin-left:11%; margin-top: 1em">To compare the
file named a1 to the file named b1, and the file named a2 to
the file named b2, enter:</p>

<p style="margin-left:11%; margin-top: 1em">2$ apply
&minus;2 cmp a1 b1 a2 b2 <br>
2$ parallel &minus;N2 cmp ::: a1 b1 a2 b2</p>

<p style="margin-left:11%; margin-top: 1em">To run the
<b>who</b> command five times, enter:</p>

<p style="margin-left:11%; margin-top: 1em">3$ apply
&minus;0 who 1 2 3 4 5 <br>
3$ parallel &minus;N0 who ::: 1 2 3 4 5</p>

<p style="margin-left:11%; margin-top: 1em">To link all
files in the current directory to the directory /usr/joe,
enter:</p>

<p style="margin-left:11%; margin-top: 1em">4$ apply 'ln %1
/usr/joe' * <br>
4$ parallel ln {} /usr/joe ::: *</p>


<p style="margin-left:11%; margin-top: 1em">https://www&minus;01.ibm.com/support/knowledgecenter/
ssw_aix_71/com.ibm.aix.cmds1/apply.htm (Last checked:
2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> paexec <small>AND GNU</small> Parallel <br>
paexec</b> can run jobs in parallel on both the local and
remote computers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>paexec</b>
requires commands to print a blank line as the last output.
This means you will have to write a wrapper for most
programs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>paexec</b>
has a job dependency facility so a job can depend on another
job to be executed successfully. Sort of a poor-man&rsquo;s
<b>make</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> paexec&rsquo;s <small>EXAMPLE
CATALOG</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from <b>paexec</b>&rsquo;s example catalog with the
equivalent using <small>GNU</small> <b>parallel</b>:</p>


<p style="margin-left:11%; margin-top: 1em">1_div_X_run</p>

<p style="margin-left:11%; margin-top: 1em">1$ ../../paexec
&minus;s &minus;l &minus;c &quot;`pwd`/1_div_X_cmd&quot;
&minus;n +1 &lt;&lt;EOF [...] <br>
1$ parallel echo {} '|' `pwd`/1_div_X_cmd &lt;&lt;EOF
[...]</p>


<p style="margin-left:11%; margin-top: 1em">all_substr_run</p>

<p style="margin-left:11%; margin-top: 1em">2$ ../../paexec
&minus;lp &minus;c &quot;`pwd`/all_substr_cmd&quot; &minus;n
+3 &lt;&lt;EOF [...] <br>
2$ parallel echo {} '|' `pwd`/all_substr_cmd &lt;&lt;EOF
[...]</p>


<p style="margin-left:11%; margin-top: 1em">cc_wrapper_run</p>

<p style="margin-left:11%; margin-top: 1em">3$ ../../paexec
&minus;c &quot;env CC=gcc CFLAGS=&minus;O2
`pwd`/cc_wrapper_cmd&quot; \ <br>
&minus;n 'host1 host2' \ <br>
&minus;t '/usr/bin/ssh &minus;x' &lt;&lt;EOF [...] <br>
3$ parallel echo {} '|' &quot;env CC=gcc CFLAGS=&minus;O2
`pwd`/cc_wrapper_cmd&quot; \ <br>
&minus;S host1,host2 &lt;&lt;EOF [...] <br>
# This is not exactly the same, but avoids the wrapper <br>
parallel gcc &minus;O2 &minus;c &minus;o {.}.o {} \ <br>
&minus;S host1,host2 &lt;&lt;EOF [...]</p>


<p style="margin-left:11%; margin-top: 1em">toupper_run</p>

<p style="margin-left:11%; margin-top: 1em">4$ ../../paexec
&minus;lp &minus;c &quot;`pwd`/toupper_cmd&quot; &minus;n
+10 &lt;&lt;EOF [...] <br>
4$ parallel echo {} '|' ./toupper_cmd &lt;&lt;EOF [...] <br>
# Without the wrapper: <br>
parallel echo {} '| awk {print\ toupper\(\$0\)}' &lt;&lt;EOF
[...]</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/cheusov/paexec
(Last checked: 2010&minus;12)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> map(sitaramc) <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
I1 &minus; &minus; I4 &minus; &minus; (I7) <br>
M1 (M2) M3 (M4) M5 M6 <br>
&minus; O2 O3 &minus; O5 &minus; &minus; N/A N/A O10 <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;">(I7): Only under special
circumstances. See below.</p>

<p style="margin-left:11%; margin-top: 1em">(M2+M4): Only
if there is a single replacement string.</p>

<p style="margin-left:11%; margin-top: 1em"><b>map</b>
rejects input with special characters:</p>

<p style="margin-left:11%; margin-top: 1em">echo &quot;The
Cure&quot; &gt; My\ brother\'s\ 12\&quot;\ records <br>
ls | map 'echo %; wc %'</p>

<p style="margin-left:11%; margin-top: 1em">It works with
<small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ls | parallel
'echo {}; wc {}'</p>

<p style="margin-left:11%; margin-top: 1em">Under some
circumstances it also works with <b>map</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ls | map 'echo
% works %'</p>

<p style="margin-left:11%; margin-top: 1em">But tiny
changes make it reject the input with special
characters:</p>

<p style="margin-left:11%; margin-top: 1em">ls | map 'echo
% does not work &quot;%&quot;'</p>

<p style="margin-left:11%; margin-top: 1em">This means that
many <small>UTF&minus;8</small> characters will be rejected.
This is by design. From the web page: &quot;As such,
programs that <i>quietly handle them, with no warnings at
all,</i> are doing their users a disservice.&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>map</b>
delays each job by 0.01 s. This can be emulated by using
<b>parallel &minus;&minus;delay 0.01</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>map</b>
prints &rsquo;+&rsquo; on stderr when a job starts, and
&rsquo;&minus;&rsquo; when a job finishes. This cannot be
disabled. <b>parallel</b> has <b>&minus;&minus;bar</b> if
you need to see progress.</p>


<p style="margin-left:11%; margin-top: 1em"><b>map</b>&rsquo;s
replacement strings (% %D %B %E) can be simulated in
<small>GNU</small> <b>parallel</b> by putting this in
<b>~/.parallel/config</b>:</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;rpl
'%' <br>
&minus;&minus;rpl '%D $_=Q(::dirname($_));' <br>
&minus;&minus;rpl '%B s:.*/::;s:\.[^/.]+$::;' <br>
&minus;&minus;rpl '%E s:.*\.::'</p>

<p style="margin-left:11%; margin-top: 1em"><b>map</b> does
not have an argument separator on the command line, but uses
the first argument as command. This makes quoting harder
which again may affect readability. Compare:</p>

<p style="margin-left:11%; margin-top: 1em">map &minus;p 2
'perl &minus;ne '&quot;'&quot;'/^\S+\s+\S+$/ and print
$ARGV,&quot;\n&quot;'&quot;'&quot; * <br>
parallel &minus;q perl &minus;ne '/^\S+\s+\S+$/ and print
$ARGV,&quot;\n&quot;' ::: *</p>

<p style="margin-left:11%; margin-top: 1em"><b>map</b> can
do multiple arguments with context replace, but not without
context replace:</p>

<p style="margin-left:11%; margin-top: 1em">parallel
&minus;&minus;xargs echo 'BEGIN{'{}'}END' ::: 1 2 3 <br>
map &quot;echo 'BEGIN{'%'}END'&quot; 1 2 3</p>

<p style="margin-left:11%; margin-top: 1em"><b>map</b> has
no support for grouping. So this gives the wrong
results:</p>

<p style="margin-left:11%; margin-top: 1em">parallel perl
&minus;e '\$a=\&quot;1{}\&quot;x10000000\;print\
\$a,\&quot;\\n\&quot;' '&gt;' {} \ <br>
::: a b c d e f <br>
ls &minus;l a b c d e f <br>
parallel &minus;kP4 &minus;n1 grep 1 ::: a b c d e f &gt;
out.par <br>
map &minus;n1 &minus;p 4 'grep 1' a b c d e f &gt;
out.map&minus;unbuf <br>
map &minus;n1 &minus;p 4 'grep
&minus;&minus;line&minus;buffered 1' a b c d e f &gt;
out.map&minus;linebuf <br>
map &minus;n1 &minus;p 1 'grep
&minus;&minus;line&minus;buffered 1' a b c d e f &gt;
out.map&minus;serial <br>
ls &minus;l out* <br>
md5sum out*</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> map&rsquo;s <small>WEBSITE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from <b>map</b>&rsquo;s web page with the
equivalent using <small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">1$ ls *.gif |
map convert % %B.png # default max&minus;args: 1 <br>
1$ ls *.gif | parallel convert {} {.}.png <br>
2$ map &quot;mkdir %B; tar &minus;C %B &minus;xf %&quot;
*.tgz # default max&minus;args: 1 <br>
2$ parallel 'mkdir {.}; tar &minus;C {.} &minus;xf {}' :::
*.tgz <br>
3$ ls *.gif | map cp % /tmp # default max&minus;args: 100
<br>
3$ ls *.gif | parallel &minus;X cp {} /tmp <br>
4$ ls *.tar | map &minus;n 1 tar &minus;xf % <br>
4$ ls *.tar | parallel tar &minus;xf <br>
5$ map &quot;cp % /tmp&quot; *.tgz <br>
5$ parallel cp {} /tmp ::: *.tgz <br>
6$ map &quot;du &minus;sm /home/%/mail&quot; alice bob carol
<br>
6$ parallel &quot;du &minus;sm /home/{}/mail&quot; ::: alice
bob carol <br>
or if you prefer running a single job with multiple args:
<br>
6$ parallel &minus;Xj1 &quot;du &minus;sm
/home/{}/mail&quot; ::: alice bob carol <br>
7$ cat /etc/passwd | map &minus;d: 'echo user %1 has shell
%7' <br>
7$ cat /etc/passwd | parallel &minus;&minus;colsep : 'echo
user {1} has shell {7}' <br>
8$ export MAP_MAX_PROCS=$(( `nproc` / 2 )) <br>
8$ export PARALLEL=&minus;j50%</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/sitaramc/map
(Last checked: 2020&minus;05)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> ladon <small>AND GNU</small> Parallel <br>
ladon</b> can run multiple jobs on files in parallel.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ladon</b>
only works on files and the only way to specify files is
using a quoted glob string (such as \*.jpg). It is not
possible to list the files manually.</p>

<p style="margin-left:11%; margin-top: 1em">As replacement
strings it uses <small>FULLPATH DIRNAME BASENAME EXT RELDIR
RELPATH</small></p>

<p style="margin-left:11%; margin-top: 1em">These can be
simulated using <small>GNU</small> <b>parallel</b> by
putting this in <b>~/.parallel/config</b>:</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;rpl
'FULLPATH $_=Q($_);chomp($_=qx{readlink &minus;f $_});' <br>
&minus;&minus;rpl 'DIRNAME
$_=Q(::dirname($_));chomp($_=qx{readlink &minus;f $_});'
<br>
&minus;&minus;rpl 'BASENAME s:.*/::;s:\.[^/.]+$::;' <br>
&minus;&minus;rpl 'EXT s:.*\.::' <br>
&minus;&minus;rpl 'RELDIR $_=Q($_);chomp(($_,$c)=qx{readlink
&minus;f $_;pwd}); <br>
s:\Q$c/\E::;$_=::dirname($_);' <br>
&minus;&minus;rpl 'RELPATH
$_=Q($_);chomp(($_,$c)=qx{readlink &minus;f $_;pwd}); <br>
s:\Q$c/\E::;'</p>

<p style="margin-left:11%; margin-top: 1em"><b>ladon</b>
deals badly with filenames containing &quot; and newline,
and it fails for output larger than 200k:</p>

<p style="margin-left:11%; margin-top: 1em">ladon '*'
&minus;&minus; seq 36000 | wc</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> ladon <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em">It is assumed
that the &rsquo;&minus;&minus;rpl&rsquo;s above are put in
<b>~/.parallel/config</b> and that it is run under a shell
that supports &rsquo;**&rsquo; globbing (such as
<b>zsh</b>):</p>

<p style="margin-left:11%; margin-top: 1em">1$ ladon
&quot;**/*.txt&quot; &minus;&minus; echo RELPATH <br>
1$ parallel echo RELPATH ::: **/*.txt <br>
2$ ladon &quot;~/Documents/**/*.pdf&quot; &minus;&minus;
shasum FULLPATH &gt;hashes.txt <br>
2$ parallel shasum FULLPATH ::: ~/Documents/**/*.pdf
&gt;hashes.txt <br>
3$ ladon &minus;m thumbs/RELDIR &quot;**/*.jpg&quot;
&minus;&minus; convert FULLPATH \ <br>
&minus;thumbnail 100x100^ &minus;gravity center
&minus;extent 100x100 \ <br>
thumbs/RELPATH <br>
3$ parallel mkdir &minus;p thumbs/RELDIR\; convert FULLPATH
<br>
&minus;thumbnail 100x100^ &minus;gravity center
&minus;extent 100x100 \ <br>
thumbs/RELPATH ::: **/*.jpg <br>
4$ ladon &quot;~/Music/*.wav&quot; &minus;&minus; lame
&minus;V 2 FULLPATH DIRNAME/BASENAME.mp3 <br>
4$ parallel lame &minus;V 2 FULLPATH DIRNAME/BASENAME.mp3
::: ~/Music/*.wav</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/danielgtaylor/ladon
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> jobflow <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 &minus; &minus; &minus; &minus; &minus; I7 <br>
&minus; &minus; M3 &minus; &minus; (M6) <br>
O1 O2 O3 &minus; O5 O6 (O7) &minus; &minus; O10 <br>
E1 &minus; &minus; &minus; &minus; E6 &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>jobflow</b> can run multiple
jobs in parallel.</p>

<p style="margin-left:11%; margin-top: 1em">Just like
<b>xargs</b> output from <b>jobflow</b> jobs running in
parallel mix together by default. <b>jobflow</b> can buffer
into files with <b>&minus;buffered</b> (placed in /run/shm),
but these are not cleaned up if <b>jobflow</b> dies
unexpectedly (e.g. by Ctrl-C). If the total output is big
(in the order of RAM+swap) it can cause the system to slow
to a crawl and eventually run out of memory.</p>

<p style="margin-left:11%; margin-top: 1em">Just like
<b>xargs</b> redirection and composed commands require
wrapping with <b>bash &minus;c</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Input lines can
at most be 4096 bytes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>jobflow</b>
is faster than <small>GNU</small> <b>parallel</b> but around
6 times slower than <b>parallel-bash</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>jobflow</b>
has no equivalent for <b>&minus;&minus;pipe</b>, or
<b>&minus;&minus;sshlogin</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>jobflow</b>
makes it possible to set resource limits on the running
jobs. This can be emulated by <small>GNU</small>
<b>parallel</b> using <b>bash</b>&rsquo;s <b>ulimit</b>:</p>

<p style="margin-left:11%; margin-top: 1em">jobflow
&minus;limits=mem=100M,cpu=3,fsize=20M,nofiles=300 myjob
<br>
parallel 'ulimit &minus;v 102400 &minus;t 3 &minus;f 204800
&minus;n 300 myjob'</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> jobflow <small>README</small></i></p>

<p style="margin-left:11%; margin-top: 1em">1$ cat
things.list | jobflow &minus;threads=8 &minus;exec ./mytask
{} <br>
1$ cat things.list | parallel &minus;j8 ./mytask {} <br>
2$ seq 100 | jobflow &minus;threads=100 &minus;exec echo {}
<br>
2$ seq 100 | parallel &minus;j100 echo {} <br>
3$ cat urls.txt | jobflow &minus;threads=32 &minus;exec wget
{} <br>
3$ cat urls.txt | parallel &minus;j32 wget {} <br>
4$ find . &minus;name '*.bmp' | \ <br>
jobflow &minus;threads=8 &minus;exec bmp2jpeg {.}.bmp
{.}.jpg <br>
4$ find . &minus;name '*.bmp' | \ <br>
parallel &minus;j8 bmp2jpeg {.}.bmp {.}.jpg <br>
5$ seq 100 | jobflow &minus;skip 10 &minus;count 10 <br>
5$ seq 100 | parallel &minus;&minus;filter '{1} &gt; 10 and
{1} &lt;= 20' echo <br>
5$ seq 100 | parallel echo '{= $_&gt;10 and $_&lt;=20 or
skip() =}'</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/rofl0r/jobflow
(Last checked: 2022&minus;05)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> gargs <small>AND GNU</small> Parallel <br>
gargs</b> can run multiple jobs in parallel.</p>

<p style="margin-left:11%; margin-top: 1em">Older versions
cache output in memory. This causes it to be extremely slow
when the output is larger than the physical
<small>RAM,</small> and can cause the system to run out of
memory.</p>

<p style="margin-left:11%; margin-top: 1em">See more
details on this in <b>man parallel_design</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Newer versions
cache output in files, but leave files in $TMPDIR if it is
killed.</p>

<p style="margin-left:11%; margin-top: 1em">Output to
stderr (standard error) is changed if the command fails.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> gargs <small>WEBSITE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">1$ seq 12
&minus;1 1 | gargs &minus;p 4 &minus;n 3 &quot;sleep {0};
echo {1} {2}&quot; <br>
1$ seq 12 &minus;1 1 | parallel &minus;P 4 &minus;n 3
&quot;sleep {1}; echo {2} {3}&quot; <br>
2$ cat t.txt | gargs &minus;&minus;sep &quot;\s+&quot; \
<br>
&minus;p 2 &quot;echo '{0}:{1}&minus;{2}' full&minus;line:
\'{}\'&quot; <br>
2$ cat t.txt | parallel &minus;&minus;colsep
&quot;\\s+&quot; \ <br>
&minus;P 2 &quot;echo '{1}:{2}&minus;{3}' full&minus;line:
\'{}\'&quot;</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/brentp/gargs
(Last checked: 2016&minus;08)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> orgalorg <small>AND GNU</small> Parallel
<br>
orgalorg</b> can run the same job on multiple machines. This
is related to <b>&minus;&minus;onall</b> and
<b>&minus;&minus;nonall</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>orgalorg</b>
supports entering the <small>SSH</small> password &minus;
provided it is the same for all servers. <small>GNU</small>
<b>parallel</b> advocates using <b>ssh-agent</b> instead,
but it is possible to emulate <b>orgalorg</b>&rsquo;s
behavior by setting <small>SSHPASS</small> and by using
<b>&minus;&minus;ssh &quot;sshpass ssh&quot;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">To make the
emulation easier, make a simple alias:</p>

<p style="margin-left:11%; margin-top: 1em">alias
par_emul=&quot;parallel &minus;j0 &minus;&minus;ssh 'sshpass
ssh' &minus;&minus;nonall &minus;&minus;tag
&minus;&minus;lb&quot;</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
supply a password run:</p>


<p style="margin-left:11%; margin-top: 1em">SSHPASS=`ssh&minus;askpass`</p>

<p style="margin-left:11%; margin-top: 1em">or set the
password directly:</p>


<p style="margin-left:11%; margin-top: 1em">SSHPASS=P4$$w0rd!</p>

<p style="margin-left:11%; margin-top: 1em">If the above is
set up you can then do:</p>

<p style="margin-left:11%; margin-top: 1em">orgalorg
&minus;o frontend1 &minus;o frontend2 &minus;p &minus;C
uptime <br>
par_emul &minus;S frontend1 &minus;S frontend2 uptime <br>
orgalorg &minus;o frontend1 &minus;o frontend2 &minus;p
&minus;C top &minus;bid 1 <br>
par_emul &minus;S frontend1 &minus;S frontend2 top
&minus;bid 1 <br>
orgalorg &minus;o frontend1 &minus;o frontend2 &minus;p
&minus;er /tmp &minus;n \ <br>
'md5sum /tmp/bigfile' &minus;S bigfile <br>
par_emul &minus;S frontend1 &minus;S frontend2
&minus;&minus;basefile bigfile \ <br>
&minus;&minus;workdir /tmp md5sum /tmp/bigfile</p>


<p style="margin-left:11%; margin-top: 1em"><b>orgalorg</b>
has a progress indicator for the transferring of a file.
<small>GNU</small> <b>parallel</b> does not.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/reconquest/orgalorg
(Last checked: 2016&minus;08)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> Rust parallel(mmstick) <small>AND
GNU</small> Parallel</b> <br>
Rust parallel focuses on speed. It is almost as fast as
<b>xargs</b>, but not as fast as <b>parallel-bash</b>. It
implements a few features from <small>GNU</small>
<b>parallel</b>, but lacks many functions. All these
fail:</p>

<p style="margin-left:11%; margin-top: 1em"># Read
arguments from file <br>
parallel &minus;a file echo <br>
# Changing the delimiter <br>
parallel &minus;d _ echo ::: a_b_c_</p>

<p style="margin-left:11%; margin-top: 1em">These do
something different from <small>GNU</small>
<b>parallel</b></p>

<p style="margin-left:11%; margin-top: 1em"># &minus;q to
protect quoted $ and space <br>
parallel &minus;q perl &minus;e '$a=shift; print
&quot;$a&quot;x10000000' ::: a b c <br>
# Generation of combination of inputs <br>
parallel echo {1} {2} ::: red green blue ::: S M L XL XXL
<br>
# {= perl expression =} replacement string <br>
parallel echo '{= s/new/old/ =}' ::: my.new your.new <br>
# &minus;&minus;pipe <br>
seq 100000 | parallel &minus;&minus;pipe wc <br>
# linked arguments <br>
parallel echo ::: S M L :::+ sml med lrg ::: R G B :::+ red
grn blu <br>
# Run different shell dialects <br>
zsh &minus;c 'parallel echo \={} ::: zsh &amp;&amp; true'
<br>
csh &minus;c 'parallel echo \$\{\} ::: shell &amp;&amp;
true' <br>
bash &minus;c 'parallel echo \$\({}\) ::: pwd &amp;&amp;
true' <br>
# Rust parallel does not start before the last argument is
read <br>
(seq 10; sleep 5; echo 2) | time parallel &minus;j2 'sleep
2; echo' <br>
tail &minus;f /var/log/syslog | parallel echo</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
examples from the book <small>GNU</small> Parallel 2018 do
not work, thus Rust parallel is not close to being a
compatible replacement.</p>

<p style="margin-left:11%; margin-top: 1em">Rust parallel
has no remote facilities.</p>

<p style="margin-left:11%; margin-top: 1em">It uses
/tmp/parallel for tmp files and does not clean up if
terminated abruptly. If another user on the system uses Rust
parallel, then /tmp/parallel will have the wrong permissions
and Rust parallel will fail. A malicious user can setup the
right permissions and symlink the output file to one of the
user&rsquo;s files and next time the user uses Rust parallel
it will overwrite this file.</p>

<p style="margin-left:11%; margin-top: 1em">attacker$ mkdir
/tmp/parallel <br>
attacker$ chmod a+rwX /tmp/parallel <br>
# Symlink to the file the attacker wants to zero out <br>
attacker$ ln &minus;s ~victim/.important&minus;file
/tmp/parallel/stderr_1 <br>
victim$ seq 1000 | parallel echo <br>
# This file is now overwritten with stderr from 'echo' <br>
victim$ cat ~victim/.important&minus;file</p>

<p style="margin-left:11%; margin-top: 1em">If
/tmp/parallel runs full during the run, Rust parallel does
not report this, but finishes with success &minus; thereby
risking data loss.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/mmstick/parallel
(Last checked: 2016&minus;08)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> Rush <small>AND GNU</small> Parallel <br>
rush</b> (https://github.com/shenwei356/rush) is written in
Go and based on <b>gargs</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Just like
<small>GNU</small> <b>parallel rush</b> buffers in temporary
files. But opposite <small>GNU</small> <b>parallel rush</b>
does not clean up, if the process dies abnormally.</p>

<p style="margin-left:11%; margin-top: 1em"><b>rush</b> has
some string manipulations that can be emulated by putting
this into ~/.parallel/config (/ is used instead of %, and %
is used instead of ^ as that is closer to bash&rsquo;s
${var%postfix}):</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;rpl
'{:} s:(\.[^/]+)*$::' <br>
&minus;&minus;rpl '{:%([^}]+?)} s:$$1(\.[^/]+)*$::' <br>
&minus;&minus;rpl '{/:%([^}]*?)}
s:.*/(.*)$$1(\.[^/]+)*$:$1:' <br>
&minus;&minus;rpl '{/:} s:(.*/)?([^/.]+)(\.[^/]+)*$:$2:'
<br>
&minus;&minus;rpl '{@(.*?)} /$$1/ and $_=$1;'</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> rush&rsquo;s <small>WEBSITE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from <b>rush</b>&rsquo;s website with the
equivalent command in <small>GNU</small>
<b>parallel</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>1. Simple
run, quoting is not necessary</b></p>

<p style="margin-left:11%; margin-top: 1em">1$ seq 1 3 |
rush echo {} <br>
1$ seq 1 3 | parallel echo {}</p>

<p style="margin-left:11%; margin-top: 1em"><b>2. Read data
from file (&lsquo;&minus;i&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">2$ rush echo {}
&minus;i data1.txt &minus;i data2.txt <br>
2$ cat data1.txt data2.txt | parallel echo {}</p>

<p style="margin-left:11%; margin-top: 1em"><b>3. Keep
output order (&lsquo;&minus;k&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">3$ seq 1 3 |
rush 'echo {}' &minus;k <br>
3$ seq 1 3 | parallel &minus;k echo {}</p>

<p style="margin-left:11%; margin-top: 1em"><b>4. Timeout
(&lsquo;&minus;t&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">4$ time seq 1 |
rush 'sleep 2; echo {}' &minus;t 1 <br>
4$ time seq 1 | parallel &minus;&minus;timeout 1 'sleep 2;
echo {}'</p>

<p style="margin-left:11%; margin-top: 1em"><b>5. Retry
(&lsquo;&minus;r&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">5$ seq 1 | rush
'python unexisted_script.py' &minus;r 1 <br>
5$ seq 1 | parallel &minus;&minus;retries 2 'python
unexisted_script.py'</p>

<p style="margin-left:11%; margin-top: 1em">Use
<b>&minus;u</b> to see it is really run twice:</p>

<p style="margin-left:11%; margin-top: 1em">5$ seq 1 |
parallel &minus;u &minus;&minus;retries 2 'python
unexisted_script.py'</p>

<p style="margin-left:11%; margin-top: 1em"><b>6. Dirname
(&lsquo;{/}&lsquo;) and basename (&lsquo;{%}&lsquo;) and
remove custom suffix (&lsquo;{^suffix}&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">6$ echo
dir/file_1.txt.gz | rush 'echo {/} {%} {^_1.txt.gz}' <br>
6$ echo dir/file_1.txt.gz | <br>
parallel &minus;&minus;plus echo {//} {/} {%_1.txt.gz}</p>

<p style="margin-left:11%; margin-top: 1em"><b>7. Get
basename, and remove last (&lsquo;{.}&lsquo;) or any
(&lsquo;{:}&lsquo;) extension</b></p>

<p style="margin-left:11%; margin-top: 1em">7$ echo
dir.d/file.txt.gz | rush 'echo {.} {:} {%.} {%:}' <br>
7$ echo dir.d/file.txt.gz | parallel 'echo {.} {:} {/.}
{/:}'</p>

<p style="margin-left:11%; margin-top: 1em"><b>8. Job
<small>ID,</small> combine fields index and other
replacement strings</b></p>

<p style="margin-left:11%; margin-top: 1em">8$ echo 12
file.txt dir/s_1.fq.gz | <br>
rush 'echo job {#}: {2} {2.} {3%:^_1}' <br>
8$ echo 12 file.txt dir/s_1.fq.gz | <br>
parallel &minus;&minus;colsep ' ' 'echo job {#}: {2} {2.}
{3/:%_1}'</p>

<p style="margin-left:11%; margin-top: 1em"><b>9. Capture
submatch using regular expression
(&lsquo;{@regexp}&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">9$ echo
read_1.fq.gz | rush 'echo {@(.+)_\d}' <br>
9$ echo read_1.fq.gz | parallel 'echo {@(.+)_\d}'</p>

<p style="margin-left:11%; margin-top: 1em"><b>10. Custom
field delimiter (&lsquo;&minus;d&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">10$ echo a=b=c
| rush 'echo {1} {2} {3}' &minus;d = <br>
10$ echo a=b=c | parallel &minus;d = echo {1} {2} {3}</p>

<p style="margin-left:11%; margin-top: 1em"><b>11. Send
multi-lines to every command
(&lsquo;&minus;n&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">11$ seq 5 |
rush &minus;n 2 &minus;k 'echo &quot;{}&quot;; echo' <br>
11$ seq 5 | <br>
parallel &minus;n 2 &minus;k \ <br>
'echo {=&minus;1 $_=join&quot;\n&quot;,@arg[1..$#arg] =};
echo' <br>
11$ seq 5 | rush &minus;n 2 &minus;k 'echo &quot;{}&quot;;
echo' &minus;J ' ' <br>
11$ seq 5 | parallel &minus;n 2 &minus;k 'echo {}; echo'</p>

<p style="margin-left:11%; margin-top: 1em"><b>12. Custom
record delimiter (&lsquo;&minus;D&lsquo;), note that empty
records are not used.</b></p>

<p style="margin-left:11%; margin-top: 1em">12$ echo a b c
d | rush &minus;D &quot; &quot; &minus;k 'echo {}' <br>
12$ echo a b c d | parallel &minus;d &quot; &quot; &minus;k
'echo {}' <br>
12$ echo abcd | rush &minus;D &quot;&quot; &minus;k 'echo
{}' <br>
Cannot be done by GNU Parallel <br>
12$ cat fasta.fa <br>
&gt;seq1 <br>
tag <br>
&gt;seq2 <br>
cat <br>
gat <br>
&gt;seq3 <br>
attac <br>
a <br>
cat <br>
12$ cat fasta.fa | rush &minus;D &quot;&gt;&quot; \ <br>
'echo FASTA record {#}: name: {1} sequence: {2}' &minus;k
&minus;d &quot;\n&quot; <br>
# rush fails to join the multiline sequences <br>
12$ cat fasta.fa | (read &minus;n1 ignore_first_char; <br>
parallel &minus;d '&gt;' &minus;&minus;colsep '\n' echo
FASTA record {#}: \ <br>
name: {1} sequence: '{=2
$_=join&quot;&quot;,@arg[2..$#arg]=}' <br>
)</p>

<p style="margin-left:11%; margin-top: 1em"><b>13. Assign
value to variable, like &lsquo;awk &minus;v&lsquo;
(&lsquo;&minus;v&lsquo;)</b></p>

<p style="margin-left:11%; margin-top: 1em">13$ seq 1 |
<br>
rush 'echo Hello, {fname} {lname}!' &minus;v fname=Wei
&minus;v lname=Shen <br>
13$ seq 1 | <br>
parallel &minus;N0 \ <br>
'fname=Wei; lname=Shen; echo Hello, ${fname} ${lname}!' <br>
13$ for var in a b; do \ <br>
13$ seq 1 3 | rush &minus;k &minus;v var=$var 'echo var:
{var}, data: {}'; \ <br>
13$ done</p>

<p style="margin-left:11%; margin-top: 1em">In
<small>GNU</small> <b>parallel</b> you would typically
do:</p>

<p style="margin-left:11%; margin-top: 1em">13$ seq 1 3 |
parallel &minus;k echo var: {1}, data: {2} ::: a b ::::
&minus;</p>

<p style="margin-left:11%; margin-top: 1em">If you
<i>really</i> want the var:</p>

<p style="margin-left:11%; margin-top: 1em">13$ seq 1 3 |
<br>
parallel &minus;k var={1} ';echo var: $var, data: {}' ::: a
b :::: &minus;</p>

<p style="margin-left:11%; margin-top: 1em">If you
<i>really</i> want the <b>for</b>&minus;loop:</p>

<p style="margin-left:11%; margin-top: 1em">13$ for var in
a b; do <br>
export var; <br>
seq 1 3 | parallel &minus;k 'echo var: $var, data: {}'; <br>
done</p>

<p style="margin-left:11%; margin-top: 1em">Contrary to
<b>rush</b> this also works if the value is complex
like:</p>

<p style="margin-left:11%; margin-top: 1em">My brother's
12&quot; records</p>

<p style="margin-left:11%; margin-top: 1em"><b>14. Preset
variable (&lsquo;&minus;v&lsquo;), avoid repeatedly writing
verbose replacement strings</b></p>

<p style="margin-left:11%; margin-top: 1em">14$ # naive way
<br>
echo read_1.fq.gz | rush 'echo {:^_1} {:^_1}_2.fq.gz' <br>
14$ echo read_1.fq.gz | parallel 'echo {:%_1}
{:%_1}_2.fq.gz' <br>
14$ # macro + removing suffix <br>
echo read_1.fq.gz | <br>
rush &minus;v p='{:^_1}' 'echo {p} {p}_2.fq.gz' <br>
14$ echo read_1.fq.gz | <br>
parallel 'p={:%_1}; echo $p ${p}_2.fq.gz' <br>
14$ # macro + regular expression <br>
echo read_1.fq.gz | rush &minus;v p='{@(.+?)_\d}' 'echo {p}
{p}_2.fq.gz' <br>
14$ echo read_1.fq.gz | parallel 'p={@(.+?)_\d}; echo $p
${p}_2.fq.gz'</p>

<p style="margin-left:11%; margin-top: 1em">Contrary to
<b>rush</b> <small>GNU</small> <b>parallel</b> works with
complex values:</p>

<p style="margin-left:11%; margin-top: 1em">14$ echo
&quot;My brother's 12\&quot;read_1.fq.gz&quot; | <br>
parallel 'p={@(.+?)_\d}; echo $p ${p}_2.fq.gz'</p>

<p style="margin-left:11%; margin-top: 1em"><b>15.
Interrupt jobs by &lsquo;Ctrl&minus;C&lsquo;, rush will stop
unfinished commands and exit.</b></p>

<p style="margin-left:11%; margin-top: 1em">15$ seq 1 20 |
rush 'sleep 1; echo {}' <br>
^C <br>
15$ seq 1 20 | parallel 'sleep 1; echo {}' <br>
^C</p>

<p style="margin-left:11%; margin-top: 1em"><b>16.
Continue/resume jobs (&lsquo;&minus;c&lsquo;). When some
jobs failed (by execution failure, timeout, or canceling by
user with &lsquo;Ctrl + C&lsquo;), please switch flag
&lsquo;&minus;c/&minus;&minus;continue&lsquo; on and run
again, so that &lsquo;rush&lsquo; can save successful
commands and ignore them in</b>
<b><i><small>NEXT</small></i></b> <b>run.</b></p>

<p style="margin-left:11%; margin-top: 1em">16$ seq 1 3 |
rush 'sleep {}; echo {}' &minus;t 3 &minus;c <br>
cat successful_cmds.rush <br>
seq 1 3 | rush 'sleep {}; echo {}' &minus;t 3 &minus;c <br>
16$ seq 1 3 | parallel &minus;&minus;joblog mylog
&minus;&minus;timeout 2 \ <br>
'sleep {}; echo {}' <br>
cat mylog <br>
seq 1 3 | parallel &minus;&minus;joblog mylog
&minus;&minus;retry&minus;failed \ <br>
'sleep {}; echo {}'</p>

<p style="margin-left:11%; margin-top: 1em">Multi-line
jobs:</p>

<p style="margin-left:11%; margin-top: 1em">16$ seq 1 3 |
rush 'sleep {}; echo {}; \ <br>
echo finish {}' &minus;t 3 &minus;c &minus;C finished.rush
<br>
cat finished.rush <br>
seq 1 3 | rush 'sleep {}; echo {}; \ <br>
echo finish {}' &minus;t 3 &minus;c &minus;C finished.rush
<br>
16$ seq 1 3 | <br>
parallel &minus;&minus;joblog mylog &minus;&minus;timeout 2
'sleep {}; echo {}; \ <br>
echo finish {}' <br>
cat mylog <br>
seq 1 3 | <br>
parallel &minus;&minus;joblog mylog
&minus;&minus;retry&minus;failed 'sleep {}; echo {}; \ <br>
echo finish {}'</p>

<p style="margin-left:11%; margin-top: 1em"><b>17. A
comprehensive example: downloading 1K+ pages given by three
<small>URL</small> list files using &lsquo;phantomjs
save_page.js&lsquo; (some page contents are dynamically
generated by Javascript, so &lsquo;wget&lsquo; does not
work). Here I set max jobs number (&lsquo;&minus;j&lsquo;)
as &lsquo;20&lsquo;, each job has a max running time
(&lsquo;&minus;t&lsquo;) of &lsquo;60&lsquo; seconds and
&lsquo;3&lsquo; retry changes (&lsquo;&minus;r&lsquo;).
Continue flag &lsquo;&minus;c&lsquo; is also switched on, so
we can continue unfinished jobs. Luckily, it&rsquo;s
accomplished in one run :)</b></p>

<p style="margin-left:11%; margin-top: 1em">17$ for f in
$(seq 2014 2016); do \ <br>
/bin/rm &minus;rf $f; mkdir &minus;p $f; \ <br>
cat $f.html.txt | rush &minus;v d=$f &minus;d = \ <br>
'phantomjs save_page.js &quot;{}&quot; &gt; {d}/{3}.html' \
<br>
&minus;j 20 &minus;t 60 &minus;r 3 &minus;c; \ <br>
done</p>


<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel</b> can append to an existing joblog with
&rsquo;+&rsquo;:</p>

<p style="margin-left:11%; margin-top: 1em">17$ rm mylog
<br>
for f in $(seq 2014 2016); do <br>
/bin/rm &minus;rf $f; mkdir &minus;p $f; <br>
cat $f.html.txt | <br>
parallel &minus;j20 &minus;&minus;timeout 60
&minus;&minus;retries 4 &minus;&minus;joblog +mylog \ <br>
&minus;&minus;colsep = \ <br>
phantomjs save_page.js {1}={2}={3} '&gt;' $f/{3}.html <br>
done</p>

<p style="margin-left:11%; margin-top: 1em"><b>18. A
bioinformatics example: mapping with &lsquo;bwa&lsquo;, and
processing result with &lsquo;samtools&lsquo;:</b></p>

<p style="margin-left:11%; margin-top: 1em">18$
ref=ref/xxx.fa <br>
threads=25 <br>
ls &minus;d raw.cluster.clean.mapping/* \ <br>
| rush &minus;v ref=$ref &minus;v j=$threads &minus;v
p='{}/{%}' \ <br>
'bwa mem &minus;t {j} &minus;M &minus;a {ref} {p}_1.fq.gz
{p}_2.fq.gz &gt;{p}.sam;\ <br>
samtools view &minus;bS {p}.sam &gt; {p}.bam; \ <br>
samtools sort &minus;T {p}.tmp &minus;@ {j} {p}.bam &minus;o
{p}.sorted.bam; \ <br>
samtools index {p}.sorted.bam; \ <br>
samtools flagstat {p}.sorted.bam &gt;
{p}.sorted.bam.flagstat; \ <br>
/bin/rm {p}.bam {p}.sam;' \ <br>
&minus;j 2 &minus;&minus;verbose &minus;c &minus;C
mapping.rush</p>


<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel</b> would use a function:</p>

<p style="margin-left:11%; margin-top: 1em">18$
ref=ref/xxx.fa <br>
export ref <br>
thr=25 <br>
export thr <br>
bwa_sam() { <br>
p=&quot;$1&quot; <br>
bam=&quot;$p&quot;.bam <br>
sam=&quot;$p&quot;.sam <br>
sortbam=&quot;$p&quot;.sorted.bam <br>
bwa mem &minus;t $thr &minus;M &minus;a $ref ${p}_1.fq.gz
${p}_2.fq.gz &gt; &quot;$sam&quot; <br>
samtools view &minus;bS &quot;$sam&quot; &gt;
&quot;$bam&quot; <br>
samtools sort &minus;T ${p}.tmp &minus;@ $thr
&quot;$bam&quot; &minus;o &quot;$sortbam&quot; <br>
samtools index &quot;$sortbam&quot; <br>
samtools flagstat &quot;$sortbam&quot; &gt;
&quot;$sortbam&quot;.flagstat <br>
/bin/rm &quot;$bam&quot; &quot;$sam&quot; <br>
} <br>
export &minus;f bwa_sam <br>
ls &minus;d raw.cluster.clean.mapping/* | <br>
parallel &minus;j 2 &minus;&minus;verbose
&minus;&minus;joblog mylog bwa_sam</p>

<p style="margin-left:11%; margin-top: 1em"><i>Other</i>
<b><i>rush</i></b> <i>features</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>rush</b>
has:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="63%">


<p style="margin-top: 1em"><b>awk &minus;v</b> like custom
defined variables (<b>&minus;v</b>)</p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">With
<small>GNU</small> <b>parallel</b> you would simply set a
shell variable:</p>

<p style="margin-left:17%; margin-top: 1em">parallel 'v={};
echo &quot;$v&quot;' ::: foo <br>
echo foo | rush &minus;v v={} 'echo {v}'</p>

<p style="margin-left:17%; margin-top: 1em">Also
<b>rush</b> does not like special chars. So these <b>do not
work</b>:</p>

<p style="margin-left:17%; margin-top: 1em">echo does not
work | rush &minus;v v=\&quot; 'echo {v}' <br>
echo &quot;My brother's 12\&quot; records&quot; | rush
&minus;v v={} 'echo {v}'</p>

<p style="margin-left:17%; margin-top: 1em">Whereas the
corresponding <small>GNU</small> <b>parallel</b> version
works:</p>

<p style="margin-left:17%; margin-top: 1em">parallel
'v=\&quot;; echo &quot;$v&quot;' ::: works <br>
parallel 'v={}; echo &quot;$v&quot;' ::: &quot;My brother's
12\&quot; records&quot;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="41%">


<p style="margin-top: 1em">Exit on first error(s)
(&minus;e)</p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This is called
<b>&minus;&minus;halt now,fail=1</b> (or shorter:
<b>&minus;&minus;halt 2</b>) when used with
<small>GNU</small> <b>parallel</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Settable records sending to
every command (<b>&minus;n</b>, default 1)</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This is also
called <b>&minus;n</b> in <small>GNU</small>
<b>parallel</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="45%">


<p style="margin-top: 1em">Practical replacement
strings</p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:17%;">{:} remove any extension</p>

<p style="margin-left:23%;">With <small>GNU</small>
<b>parallel</b> this can be emulated by:</p>

<p style="margin-left:23%; margin-top: 1em">parallel
&minus;&minus;plus echo '{/\..*/}' ::: foo.ext.bar.gz</p>

<p style="margin-left:17%;">{^suffix}, remove suffix</p>

<p style="margin-left:23%;">With <small>GNU</small>
<b>parallel</b> this can be emulated by:</p>

<p style="margin-left:23%; margin-top: 1em">parallel
&minus;&minus;plus echo '{%.bar.gz}' ::: foo.ext.bar.gz</p>

<p style="margin-left:17%;">{@regexp}, capture submatch
using regular expression</p>

<p style="margin-left:23%;">With <small>GNU</small>
<b>parallel</b> this can be emulated by:</p>

<p style="margin-left:23%; margin-top: 1em">parallel
&minus;&minus;rpl '{@(.*?)} /$$1/ and $_=$1;' \ <br>
echo '{@\d_(.*).gz}' ::: 1_foo.gz</p>

<p style="margin-left:17%;">{%.}, {%:}, basename without
extension</p>

<p style="margin-left:23%;">With <small>GNU</small>
<b>parallel</b> this can be emulated by:</p>

<p style="margin-left:23%; margin-top: 1em">parallel echo
'{= s:.*/::;s/\..*// =}' ::: dir/foo.bar.gz</p>

<p style="margin-left:23%; margin-top: 1em">And if you need
it often, you define a <b>&minus;&minus;rpl</b> in
<b>$HOME/.parallel/config</b>:</p>


<p style="margin-left:23%; margin-top: 1em">&minus;&minus;rpl
'{%.} s:.*/::;s/\..*//' <br>
&minus;&minus;rpl '{%:} s:.*/::;s/\..*//'</p>

<p style="margin-left:23%; margin-top: 1em">Then you can
use them as:</p>

<p style="margin-left:23%; margin-top: 1em">parallel echo
{%.} {%:} ::: dir/foo.bar.gz</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p>Preset variable (macro)</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">E.g.</p>

<p style="margin-left:17%; margin-top: 1em">echo foosuffix
| rush &minus;v p={^suffix} 'echo {p}_new_suffix'</p>

<p style="margin-left:17%; margin-top: 1em">With
<small>GNU</small> <b>parallel</b> this can be emulated
by:</p>

<p style="margin-left:17%; margin-top: 1em">echo foosuffix
| <br>
parallel &minus;&minus;plus 'p={%suffix}; echo
${p}_new_suffix'</p>

<p style="margin-left:17%; margin-top: 1em">Opposite
<b>rush</b> <small>GNU</small> <b>parallel</b> works fine if
the input contains double space, &rsquo; and &quot;:</p>

<p style="margin-left:17%; margin-top: 1em">echo
&quot;1'6\&quot; foosuffix&quot; | <br>
parallel &minus;&minus;plus 'p={%suffix}; echo
&quot;${p}&quot;_new_suffix'</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">Commands of multi-lines</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">While you
<i>can</i> use multi-lined commands in <small>GNU</small>
<b>parallel</b>, to improve readability <small>GNU</small>
<b>parallel</b> discourages the use of multi-line commands.
In most cases it can be written as a function:</p>

<p style="margin-left:17%; margin-top: 1em">seq 1 3 | <br>
parallel &minus;&minus;timeout 2 &minus;&minus;joblog my.log
'sleep {}; echo {}; \ <br>
echo finish {}'</p>

<p style="margin-left:17%; margin-top: 1em">Could be
written as:</p>

<p style="margin-left:17%; margin-top: 1em">doit() { <br>
sleep &quot;$1&quot; <br>
echo &quot;$1&quot; <br>
echo finish &quot;$1&quot; <br>
} <br>
export &minus;f doit <br>
seq 1 3 | parallel &minus;&minus;timeout 2
&minus;&minus;joblog my.log doit</p>

<p style="margin-left:17%; margin-top: 1em">The failed
commands can be resumed with:</p>

<p style="margin-left:17%; margin-top: 1em">seq 1 3 | <br>
parallel &minus;&minus;resume&minus;failed
&minus;&minus;joblog my.log 'sleep {}; echo {};\ <br>
echo finish {}'</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/shenwei356/rush
(Last checked: 2017&minus;05)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> ClusterSSH <small>AND GNU</small>
Parallel</b> <br>
ClusterSSH solves a different problem than
<small>GNU</small> <b>parallel</b>.</p>

<p style="margin-left:11%; margin-top: 1em">ClusterSSH
opens a terminal window for each computer and using a master
window you can run the same command on all the computers.
This is typically used for administrating several computers
that are almost identical.</p>


<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel</b> runs the same (or different) commands with
different arguments in parallel possibly using remote
computers to help computing. If more than one computer is
listed in <b>&minus;S</b> <small>GNU</small> <b>parallel</b>
may only use one of these (e.g. if there are 8 jobs to be
run and one computer has 8 cores).</p>


<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel</b> can be used as a poor-man&rsquo;s version of
ClusterSSH:</p>

<p style="margin-left:11%; margin-top: 1em"><b>parallel
&minus;&minus;nonall &minus;S server&minus;a,server&minus;b
do_stuff foo bar</b></p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/duncs/clusterssh
(Last checked: 2010&minus;12)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> coshell <small>AND GNU</small> Parallel <br>
coshell</b> only accepts full commands on standard input.
Any quoting needs to be done by the user.</p>

<p style="margin-left:11%; margin-top: 1em">Commands are
run in <b>sh</b> so any <b>bash</b>/<b>tcsh</b>/<b>zsh</b>
specific syntax will not work.</p>

<p style="margin-left:11%; margin-top: 1em">Output can be
buffered by using <b>&minus;d</b>. Output is buffered in
memory, so big output can cause swapping and therefore be
terrible slow or even cause out of memory.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/gdm85/coshell
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> spread <small>AND GNU</small> Parallel <br>
spread</b> runs commands on all directories.</p>

<p style="margin-left:11%; margin-top: 1em">It can be
emulated with <small>GNU</small> <b>parallel</b> using this
Bash function:</p>

<p style="margin-left:11%; margin-top: 1em">spread() { <br>
_cmds() { <br>
perl &minus;e '$&quot;=&quot; &amp;&amp; &quot;;print
&quot;@ARGV&quot;' &quot;cd {}&quot; &quot;$@&quot; <br>
} <br>
parallel $(_cmds &quot;$@&quot;)'|| echo exit status $?' :::
*/ <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This works
except for the <b>&minus;&minus;exclude</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">(Last checked:
2017&minus;11)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> pyargs <small>AND GNU</small> Parallel <br>
pyargs</b> deals badly with input containing spaces. It
buffers stdout, but not stderr. It buffers in
<small>RAM.</small> {} does not work as replacement string.
It does not support running functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>pyargs</b>
does not support composed commands if run with
<b>&minus;&minus;lines</b>, and fails on <b>pyargs
traceroute gnu.org fsf.org</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">seq 5 | pyargs
&minus;P50 &minus;L seq <br>
seq 5 | parallel &minus;P50 &minus;&minus;lb seq <br>
seq 5 | pyargs &minus;P50 &minus;&minus;mark &minus;L seq
<br>
seq 5 | parallel &minus;P50 &minus;&minus;lb \ <br>
&minus;&minus;tagstring OUTPUT'[{=
$_=$job&minus;&gt;replaced() =}]' seq <br>
# Similar, but not precisely the same <br>
seq 5 | parallel &minus;P50 &minus;&minus;lb
&minus;&minus;tag seq <br>
seq 5 | pyargs &minus;P50 &minus;&minus;mark command <br>
# Somewhat longer with GNU Parallel due to the special <br>
# &minus;&minus;mark formatting <br>
cmd=&quot;$(echo &quot;command&quot; | parallel
&minus;&minus;shellquote)&quot; <br>
wrap_cmd() { <br>
echo &quot;MARK $cmd
$@================================&quot; &gt;&amp;3 <br>
echo &quot;OUTPUT START[$cmd $@]:&quot; <br>
eval $cmd &quot;$@&quot; <br>
echo &quot;OUTPUT END[$cmd $@]&quot; <br>
} <br>
(seq 5 | env_parallel &minus;P2 wrap_cmd) 3&gt;&amp;1 <br>
# Similar, but not exactly the same <br>
seq 5 | parallel &minus;t &minus;&minus;tag command <br>
(echo '1 2 3';echo 4 5 6) | pyargs &minus;&minus;stream seq
<br>
(echo '1 2 3';echo 4 5 6) | perl &minus;pe 's/\n/ /' | <br>
parallel &minus;r &minus;d' ' seq <br>
# Similar, but not exactly the same <br>
parallel seq ::: 1 2 3 4 5 6</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/robertblackwell/pyargs
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> concurrently <small>AND GNU</small> Parallel
<br>
concurrently</b> runs jobs in parallel.</p>

<p style="margin-left:11%; margin-top: 1em">The output is
prepended with the job number, and may be incomplete:</p>

<p style="margin-left:11%; margin-top: 1em">$ concurrently
'seq 100000' | (sleep 3;wc &minus;l) <br>
7165</p>

<p style="margin-left:11%; margin-top: 1em">When pretty
printing it caches output in memory. Output mixes by using
test <small>MIX</small> below whether or not output is
cached.</p>

<p style="margin-left:11%; margin-top: 1em">There seems to
be no way of making a template command and have
<b>concurrently</b> fill that with different args. The full
commands must be given on the command line.</p>

<p style="margin-left:11%; margin-top: 1em">There is also
no way of controlling how many jobs should be run in
parallel at a time &minus; i.e. &quot;number of
jobslots&quot;. Instead all jobs are simply started in
parallel.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/kimmobrunfeldt/concurrently
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> map(soveran) <small>AND GNU</small> Parallel
<br>
map</b> does not run jobs in parallel by default. The
<small>README</small> suggests using:</p>

<p style="margin-left:11%; margin-top: 1em">... | map t
'sleep $t &amp;&amp; say done &amp;'</p>

<p style="margin-left:11%; margin-top: 1em">But this fails
if more jobs are run in parallel than the number of
available processes. Since there is no support for
parallelization in <b>map</b> itself, the output also
mixes:</p>

<p style="margin-left:11%; margin-top: 1em">seq 10 | map i
'echo start&minus;$i &amp;&amp; sleep 0.$i &amp;&amp; echo
end&minus;$i &amp;'</p>

<p style="margin-left:11%; margin-top: 1em">The major
difference is that <small>GNU</small> <b>parallel</b> is
built for parallelization and <b>map</b> is not. So
<small>GNU</small> <b>parallel</b> has lots of ways of
dealing with the issues that parallelization raises:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p style="margin-top: 1em">Keep the number of processes
manageable</p> </td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p>Make sure output does not mix</p></td>
<td width="23%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p>Make Ctrl-C kill all running processes</p></td>
<td width="23%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> maps <small>WEBSITE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Here are the 5
examples converted to <small>GNU</small> Parallel:</p>

<p style="margin-left:11%; margin-top: 1em">1$ ls *.c | map
f 'foo $f' <br>
1$ ls *.c | parallel foo <br>
2$ ls *.c | map f 'foo $f; bar $f' <br>
2$ ls *.c | parallel 'foo {}; bar {}' <br>
3$ cat urls | map u 'curl &minus;O $u' <br>
3$ cat urls | parallel curl &minus;O <br>
4$ printf &quot;1\n1\n1\n&quot; | map t 'sleep $t &amp;&amp;
say done' <br>
4$ printf &quot;1\n1\n1\n&quot; | parallel 'sleep {}
&amp;&amp; say done' <br>
4$ parallel 'sleep {} &amp;&amp; say done' ::: 1 1 1 <br>
5$ printf &quot;1\n1\n1\n&quot; | map t 'sleep $t &amp;&amp;
say done &amp;' <br>
5$ printf &quot;1\n1\n1\n&quot; | parallel &minus;j0 'sleep
{} &amp;&amp; say done' <br>
5$ parallel &minus;j0 'sleep {} &amp;&amp; say done' ::: 1 1
1</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/soveran/map
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> loop <small>AND GNU</small> Parallel <br>
loop</b> mixes stdout and stderr:</p>

<p style="margin-left:11%; margin-top: 1em">loop 'ls
/no&minus;such&minus;file' &gt;/dev/null</p>


<p style="margin-left:11%; margin-top: 1em"><b>loop</b>&rsquo;s
replacement string <b>$ITEM</b> does not quote strings:</p>

<p style="margin-left:11%; margin-top: 1em">echo 'two
spaces' | loop 'echo $ITEM'</p>

<p style="margin-left:11%; margin-top: 1em"><b>loop</b>
cannot run functions:</p>

<p style="margin-left:11%; margin-top: 1em">myfunc() { echo
joe; } <br>
export &minus;f myfunc <br>
loop 'myfunc this fails'</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> loop&rsquo;s <small>WEBSITE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Some of the
examples from https://github.com/Miserlou/Loop/ can be
emulated with <small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em"># A couple of
functions will make the code easier to read <br>
$ loopy() { <br>
yes | parallel &minus;uN0 &minus;j1 &quot;$@&quot; <br>
} <br>
$ export &minus;f loopy <br>
$ time_out() { <br>
parallel &minus;uN0 &minus;q &minus;&minus;timeout
&quot;$@&quot; ::: 1 <br>
} <br>
$ match() { <br>
perl &minus;0777 &minus;ne 'grep /'&quot;$1&quot;'/,$_ and
print or exit 1' <br>
} <br>
$ export &minus;f match <br>
$ loop 'ls' &minus;&minus;every 10s <br>
$ loopy &minus;&minus;delay 10s ls <br>
$ loop 'touch $COUNT.txt' &minus;&minus;count&minus;by 5
<br>
$ loopy touch '{= $_=seq()*5 =}'.txt <br>
$ loop &minus;&minus;until&minus;contains 200 &minus;&minus;
\ <br>
./get_response_code.sh &minus;&minus;site mysite.biz` <br>
$ loopy &minus;&minus;halt now,success=1 \ <br>
'./get_response_code.sh &minus;&minus;site mysite.biz |
match 200' <br>
$ loop './poke_server' &minus;&minus;for&minus;duration 8h
<br>
$ time_out 8h loopy ./poke_server <br>
$ loop './poke_server' &minus;&minus;until&minus;success
<br>
$ loopy &minus;&minus;halt now,success=1 ./poke_server <br>
$ cat files_to_create.txt | loop 'touch $ITEM' <br>
$ cat files_to_create.txt | parallel touch {} <br>
$ loop 'ls' &minus;&minus;for&minus;duration 10min
&minus;&minus;summary <br>
# &minus;&minus;joblog is somewhat more verbose than
&minus;&minus;summary <br>
$ time_out 10m loopy &minus;&minus;joblog my.log
./poke_server; cat my.log <br>
$ loop 'echo hello' <br>
$ loopy echo hello <br>
$ loop 'echo $COUNT' <br>
# GNU Parallel counts from 1 <br>
$ loopy echo {#} <br>
# Counting from 0 can be forced <br>
$ loopy echo '{= $_=seq()&minus;1 =}' <br>
$ loop 'echo $COUNT' &minus;&minus;count&minus;by 2 <br>
$ loopy echo '{= $_=2*(seq()&minus;1) =}' <br>
$ loop 'echo $COUNT' &minus;&minus;count&minus;by 2
&minus;&minus;offset 10 <br>
$ loopy echo '{= $_=10+2*(seq()&minus;1) =}' <br>
$ loop 'echo $COUNT' &minus;&minus;count&minus;by 1.1 <br>
# GNU Parallel rounds 3.3000000000000003 to 3.3 <br>
$ loopy echo '{= $_=1.1*(seq()&minus;1) =}' <br>
$ loop 'echo $COUNT $ACTUALCOUNT'
&minus;&minus;count&minus;by 2 <br>
$ loopy echo '{= $_=2*(seq()&minus;1) =} {#}' <br>
$ loop 'echo $COUNT' &minus;&minus;num 3
&minus;&minus;summary <br>
# &minus;&minus;joblog is somewhat more verbose than
&minus;&minus;summary <br>
$ seq 3 | parallel &minus;&minus;joblog my.log echo; cat
my.log <br>
$ loop 'ls &minus;foobarbatz' &minus;&minus;num 3
&minus;&minus;summary <br>
# &minus;&minus;joblog is somewhat more verbose than
&minus;&minus;summary <br>
$ seq 3 | parallel &minus;&minus;joblog my.log &minus;N0 ls
&minus;foobarbatz; cat my.log <br>
$ loop 'echo $COUNT' &minus;&minus;count&minus;by 2
&minus;&minus;num 50 &minus;&minus;only&minus;last <br>
# Can be emulated by running 2 jobs <br>
$ seq 49 | parallel echo '{= $_=2*(seq()&minus;1) =}'
&gt;/dev/null <br>
$ echo 50| parallel echo '{= $_=2*(seq()&minus;1) =}' <br>
$ loop 'date' &minus;&minus;every 5s <br>
$ loopy &minus;&minus;delay 5s date <br>
$ loop 'date' &minus;&minus;for&minus;duration 8s
&minus;&minus;every 2s <br>
$ time_out 8s loopy &minus;&minus;delay 2s date <br>
$ loop 'date &minus;u' &minus;&minus;until&minus;time
'2018&minus;05&minus;25 20:50:00' &minus;&minus;every 5s
<br>
$ seconds=$((`date &minus;d 2019&minus;05&minus;25T20:50:00
+%s` &minus; `date +%s`))s <br>
$ time_out $seconds loopy &minus;&minus;delay 5s date
&minus;u <br>
$ loop 'echo $RANDOM' &minus;&minus;until&minus;contains
&quot;666&quot; <br>
$ loopy &minus;&minus;halt now,success=1 'echo $RANDOM |
match 666' <br>
$ loop 'if (( RANDOM % 2 )); then <br>
(echo &quot;TRUE&quot;; true); <br>
else <br>
(echo &quot;FALSE&quot;; false); <br>
fi' &minus;&minus;until&minus;success <br>
$ loopy &minus;&minus;halt now,success=1 'if (( $RANDOM % 2
)); then <br>
(echo &quot;TRUE&quot;; true); <br>
else <br>
(echo &quot;FALSE&quot;; false); <br>
fi' <br>
$ loop 'if (( RANDOM % 2 )); then <br>
(echo &quot;TRUE&quot;; true); <br>
else <br>
(echo &quot;FALSE&quot;; false); <br>
fi' &minus;&minus;until&minus;error <br>
$ loopy &minus;&minus;halt now,fail=1 'if (( $RANDOM % 2 ));
then <br>
(echo &quot;TRUE&quot;; true); <br>
else <br>
(echo &quot;FALSE&quot;; false); <br>
fi' <br>
$ loop 'date' &minus;&minus;until&minus;match
&quot;(\d{4})&quot; <br>
$ loopy &minus;&minus;halt now,success=1 'date | match
[0&minus;9][0&minus;9][0&minus;9][0&minus;9]' <br>
$ loop 'echo $ITEM' &minus;&minus;for red,green,blue <br>
$ parallel echo ::: red green blue <br>
$ cat
/tmp/my&minus;list&minus;of&minus;files&minus;to&minus;create.txt
| loop 'touch $ITEM' <br>
$ cat
/tmp/my&minus;list&minus;of&minus;files&minus;to&minus;create.txt
| parallel touch <br>
$ ls | loop 'cp $ITEM $ITEM.bak'; ls <br>
$ ls | parallel cp {} {}.bak; ls <br>
$ loop 'echo $ITEM | tr a&minus;z A&minus;Z' &minus;i <br>
$ parallel 'echo {} | tr a&minus;z A&minus;Z' <br>
# Or more efficiently: <br>
$ parallel &minus;&minus;pipe tr a&minus;z A&minus;Z <br>
$ loop 'echo $ITEM' &minus;&minus;for &quot;`ls`&quot; <br>
$ parallel echo {} ::: &quot;`ls`&quot; <br>
$ ls | loop './my_program $ITEM'
&minus;&minus;until&minus;success; <br>
$ ls | parallel &minus;&minus;halt now,success=1
./my_program {} <br>
$ ls | loop './my_program $ITEM'
&minus;&minus;until&minus;fail; <br>
$ ls | parallel &minus;&minus;halt now,fail=1 ./my_program
{} <br>
$ ./deploy.sh; <br>
loop 'curl &minus;sw &quot;%{http_code}&quot;
http://coolwebsite.biz' \ <br>
&minus;&minus;every 5s &minus;&minus;until&minus;contains
200; <br>
./announce_to_slack.sh <br>
$ ./deploy.sh; <br>
loopy &minus;&minus;delay 5s &minus;&minus;halt
now,success=1 \ <br>
'curl &minus;sw &quot;%{http_code}&quot;
http://coolwebsite.biz | match 200'; <br>
./announce_to_slack.sh <br>
$ loop &quot;ping &minus;c 1 mysite.com&quot;
&minus;&minus;until&minus;success; ./do_next_thing <br>
$ loopy &minus;&minus;halt now,success=1 ping &minus;c 1
mysite.com; ./do_next_thing <br>
$ ./create_big_file &minus;o my_big_file.bin; <br>
loop 'ls' &minus;&minus;until&minus;contains
'my_big_file.bin'; <br>
./upload_big_file my_big_file.bin <br>
# inotifywait is a better tool to detect file system
changes. <br>
# It can even make sure the file is complete <br>
# so you are not uploading an incomplete file <br>
$ inotifywait &minus;qmre MOVED_TO &minus;e CLOSE_WRITE
&minus;&minus;format %w%f . | <br>
grep my_big_file.bin <br>
$ ls | loop 'cp $ITEM $ITEM.bak' <br>
$ ls | parallel cp {} {}.bak <br>
$ loop './do_thing.sh' &minus;&minus;every 15s
&minus;&minus;until&minus;success &minus;&minus;num 5 <br>
$ parallel &minus;&minus;retries 5 &minus;&minus;delay 15s
::: ./do_thing.sh</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/Miserlou/Loop/
(Last checked: 2018&minus;10)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> lorikeet <small>AND GNU</small> Parallel
<br>
lorikeet</b> can run jobs in parallel. It does this based on
a dependency graph described in a file, so this is similar
to <b>make</b>.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/cetra3/lorikeet
(Last checked: 2018&minus;10)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> spp <small>AND GNU</small> Parallel <br>
spp</b> can run jobs in parallel. <b>spp</b> does not use a
command template to generate the jobs, but requires jobs to
be in a file. Output from the jobs mix.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/john01dav/spp
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> paral <small>AND GNU</small> Parallel <br>
paral</b> prints a lot of status information and stores the
output from the commands run into files. This means it
cannot be used the middle of a pipe like this</p>

<p style="margin-left:11%; margin-top: 1em">paral
&quot;echo this&quot; &quot;echo does not&quot; &quot;echo
work&quot; | wc</p>

<p style="margin-left:11%; margin-top: 1em">Instead it puts
the output into files named like
<b>out_#_</b><b><i>command</i></b><b>.out.log</b>. To get a
very similar behaviour with <small>GNU</small>
<b>parallel</b> use <b>&minus;&minus;results
&rsquo;out_{#}_{=s/[^\sa&minus;z_0&minus;9]//g;s/\s+/_/g=}.log&rsquo;
&minus;&minus;eta</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>paral</b>
only takes arguments on the command line and each argument
should be a full command. Thus it does not use command
templates.</p>

<p style="margin-left:11%; margin-top: 1em">This limits how
many jobs it can run in total, because they all need to fit
on a single command line.</p>

<p style="margin-left:11%; margin-top: 1em"><b>paral</b>
has no support for running jobs remotely.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM README</small> .markdown</i></p>

<p style="margin-left:11%; margin-top: 1em">The examples
from <b><small>README</small> .markdown</b> and the
corresponding command run with <small>GNU</small>
<b>parallel</b> (<b>&minus;&minus;results
&rsquo;out_{#}_{=s/[^\sa&minus;z_0&minus;9]//g;s/\s+/_/g=}.log&rsquo;
&minus;&minus;eta</b> is omitted from the <small>GNU</small>
<b>parallel</b> command):</p>

<p style="margin-left:11%; margin-top: 1em">1$ paral
&quot;command 1&quot; &quot;command 2
&minus;&minus;flag&quot; &quot;command arg1 arg2&quot; <br>
1$ parallel ::: &quot;command 1&quot; &quot;command 2
&minus;&minus;flag&quot; &quot;command arg1 arg2&quot; <br>
2$ paral &quot;sleep 1 &amp;&amp; echo c1&quot; &quot;sleep
2 &amp;&amp; echo c2&quot; \ <br>
&quot;sleep 3 &amp;&amp; echo c3&quot; &quot;sleep 4
&amp;&amp; echo c4&quot; &quot;sleep 5 &amp;&amp; echo
c5&quot; <br>
2$ parallel ::: &quot;sleep 1 &amp;&amp; echo c1&quot;
&quot;sleep 2 &amp;&amp; echo c2&quot; \ <br>
&quot;sleep 3 &amp;&amp; echo c3&quot; &quot;sleep 4
&amp;&amp; echo c4&quot; &quot;sleep 5 &amp;&amp; echo
c5&quot; <br>
# Or shorter: <br>
parallel &quot;sleep {} &amp;&amp; echo c{}&quot; ::: {1..5}
<br>
3$ paral &minus;n=0 &quot;sleep 5 &amp;&amp; echo c5&quot;
&quot;sleep 4 &amp;&amp; echo c4&quot; \ <br>
&quot;sleep 3 &amp;&amp; echo c3&quot; &quot;sleep 2
&amp;&amp; echo c2&quot; &quot;sleep 1 &amp;&amp; echo
c1&quot; <br>
3$ parallel ::: &quot;sleep 5 &amp;&amp; echo c5&quot;
&quot;sleep 4 &amp;&amp; echo c4&quot; \ <br>
&quot;sleep 3 &amp;&amp; echo c3&quot; &quot;sleep 2
&amp;&amp; echo c2&quot; &quot;sleep 1 &amp;&amp; echo
c1&quot; <br>
# Or shorter: <br>
parallel &minus;j0 &quot;sleep {} &amp;&amp; echo c{}&quot;
::: 5 4 3 2 1 <br>
4$ paral &minus;n=1 &quot;sleep 5 &amp;&amp; echo c5&quot;
&quot;sleep 4 &amp;&amp; echo c4&quot; \ <br>
&quot;sleep 3 &amp;&amp; echo c3&quot; &quot;sleep 2
&amp;&amp; echo c2&quot; &quot;sleep 1 &amp;&amp; echo
c1&quot; <br>
4$ parallel &minus;j1 &quot;sleep {} &amp;&amp; echo
c{}&quot; ::: 5 4 3 2 1 <br>
5$ paral &minus;n=2 &quot;sleep 5 &amp;&amp; echo c5&quot;
&quot;sleep 4 &amp;&amp; echo c4&quot; \ <br>
&quot;sleep 3 &amp;&amp; echo c3&quot; &quot;sleep 2
&amp;&amp; echo c2&quot; &quot;sleep 1 &amp;&amp; echo
c1&quot; <br>
5$ parallel &minus;j2 &quot;sleep {} &amp;&amp; echo
c{}&quot; ::: 5 4 3 2 1 <br>
6$ paral &minus;n=5 &quot;sleep 5 &amp;&amp; echo c5&quot;
&quot;sleep 4 &amp;&amp; echo c4&quot; \ <br>
&quot;sleep 3 &amp;&amp; echo c3&quot; &quot;sleep 2
&amp;&amp; echo c2&quot; &quot;sleep 1 &amp;&amp; echo
c1&quot; <br>
6$ parallel &minus;j5 &quot;sleep {} &amp;&amp; echo
c{}&quot; ::: 5 4 3 2 1 <br>
7$ paral &minus;n=1 &quot;echo a &amp;&amp; sleep 0.5
&amp;&amp; echo b &amp;&amp; sleep 0.5 &amp;&amp; \ <br>
echo c &amp;&amp; sleep 0.5 &amp;&amp; echo d &amp;&amp;
sleep 0.5 &amp;&amp; \ <br>
echo e &amp;&amp; sleep 0.5 &amp;&amp; echo f &amp;&amp;
sleep 0.5 &amp;&amp; \ <br>
echo g &amp;&amp; sleep 0.5 &amp;&amp; echo h&quot; <br>
7$ parallel ::: &quot;echo a &amp;&amp; sleep 0.5 &amp;&amp;
echo b &amp;&amp; sleep 0.5 &amp;&amp; \ <br>
echo c &amp;&amp; sleep 0.5 &amp;&amp; echo d &amp;&amp;
sleep 0.5 &amp;&amp; \ <br>
echo e &amp;&amp; sleep 0.5 &amp;&amp; echo f &amp;&amp;
sleep 0.5 &amp;&amp; \ <br>
echo g &amp;&amp; sleep 0.5 &amp;&amp; echo h&quot;</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/amattn/paral
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> concurr <small>AND GNU</small> Parallel <br>
concurr</b> is built to run jobs in parallel using a
client/server model.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM README</small> .md</i></p>

<p style="margin-left:11%; margin-top: 1em">The examples
from <b><small>README</small> .md</b>:</p>

<p style="margin-left:11%; margin-top: 1em">1$ concurr
'echo job {#} on slot {%}: {}' : arg1 arg2 arg3 arg4 <br>
1$ parallel 'echo job {#} on slot {%}: {}' ::: arg1 arg2
arg3 arg4 <br>
2$ concurr 'echo job {#} on slot {%}: {}' :: file1 file2
file3 <br>
2$ parallel 'echo job {#} on slot {%}: {}' :::: file1 file2
file3 <br>
3$ concurr 'echo {}' &lt; input_file <br>
3$ parallel 'echo {}' &lt; input_file <br>
4$ cat file | concurr 'echo {}' <br>
4$ cat file | parallel 'echo {}'</p>

<p style="margin-left:11%; margin-top: 1em"><b>concurr</b>
deals badly empty input files and with output larger than 64
<small>KB.</small></p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/mmstick/concurr
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> lesser-parallel <small>AND GNU</small>
Parallel <br>
lesser-parallel</b> is the inspiration for <b>parallel
&minus;&minus;embed</b>. Both <b>lesser-parallel</b> and
<b>parallel &minus;&minus;embed</b> define bash functions
that can be included as part of a bash script to run jobs in
parallel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>lesser-parallel</b>
implements a few of the replacement strings, but hardly any
options, whereas <b>parallel &minus;&minus;embed</b> gives
you the full <small>GNU</small> <b>parallel</b>
experience.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/kou1okada/lesser&minus;parallel
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> npm-parallel <small>AND GNU</small> Parallel
<br>
npm-parallel</b> can run npm tasks in parallel.</p>

<p style="margin-left:11%; margin-top: 1em">There are no
examples and very little documentation, so it is hard to
compare to <small>GNU</small> <b>parallel</b>.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/spion/npm&minus;parallel
(Last checked: 2019&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> machma <small>AND GNU</small> Parallel <br>
machma</b> runs tasks in parallel. It gives time stamped
output. It buffers in <small>RAM.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small><i>EXAMPLES
FROM README</i></small> <i>.md</i></p>

<p style="margin-left:11%; margin-top: 1em">The examples
from <small>README</small> .md:</p>

<p style="margin-left:11%; margin-top: 1em">1$ # Put
shorthand for timestamp in config for the examples <br>
echo '&minus;&minus;rpl '\ <br>
\''{time} $_=::strftime(&quot;%Y&minus;%m&minus;%d
%H:%M:%S&quot;,localtime())'\' \ <br>
&gt; ~/.parallel/machma <br>
echo '&minus;&minus;line&minus;buffer
&minus;&minus;tagstring &quot;{#} {time} {}&quot;' \ <br>
&gt;&gt; ~/.parallel/machma <br>
2$ find . &minus;iname '*.jpg' | <br>
machma &minus;&minus; mogrify &minus;resize 1200x1200
&minus;filter Lanczos {} <br>
find . &minus;iname '*.jpg' | <br>
parallel &minus;&minus;bar &minus;Jmachma mogrify
&minus;resize 1200x1200 \ <br>
&minus;filter Lanczos {} <br>
3$ cat /tmp/ips | machma &minus;p 2 &minus;&minus; ping
&minus;c 2 &minus;q {} <br>
3$ cat /tmp/ips | parallel &minus;j2 &minus;Jmachma ping
&minus;c 2 &minus;q {} <br>
4$ cat /tmp/ips | <br>
machma &minus;&minus; sh &minus;c 'ping &minus;c 2 &minus;q
$0 &gt; /dev/null &amp;&amp; echo alive' {} <br>
4$ cat /tmp/ips | <br>
parallel &minus;Jmachma 'ping &minus;c 2 &minus;q {} &gt;
/dev/null &amp;&amp; echo alive' <br>
5$ find . &minus;iname '*.jpg' | <br>
machma &minus;&minus;timeout 5s &minus;&minus; mogrify
&minus;resize 1200x1200 \ <br>
&minus;filter Lanczos {} <br>
5$ find . &minus;iname '*.jpg' | <br>
parallel &minus;&minus;timeout 5s &minus;&minus;bar mogrify
&minus;resize 1200x1200 \ <br>
&minus;filter Lanczos {} <br>
6$ find . &minus;iname '*.jpg' &minus;print0 | <br>
machma &minus;&minus;null &minus;&minus; mogrify
&minus;resize 1200x1200 &minus;filter Lanczos {} <br>
6$ find . &minus;iname '*.jpg' &minus;print0 | <br>
parallel &minus;&minus;null &minus;&minus;bar mogrify
&minus;resize 1200x1200 \ <br>
&minus;filter Lanczos {}</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/fd0/machma
(Last checked: 2019&minus;06)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> interlace <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
&minus; I2 I3 I4 &minus; &minus; &minus; <br>
M1 &minus; M3 &minus; &minus; M6 <br>
&minus; O2 O3 &minus; &minus; &minus; &minus; x x <br>
E1 E2 &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>interlace</b> is built for
network analysis to run network tools in parallel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>interface</b>
does not buffer output, so output from different jobs
mixes.</p>

<p style="margin-left:11%; margin-top: 1em">The overhead
for each target is O(n*n), so with 1000 targets it becomes
very slow with an overhead in the order of 500ms/target.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> interlace&rsquo;s
<small>WEBSITE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Using
<b>prips</b> most of the examples from
https://github.com/codingo/Interlace can be run with
<small>GNU</small> <b>parallel</b>:</p>

<p style="margin-left:11%; margin-top: 1em">Blocker</p>

<p style="margin-left:11%; margin-top: 1em">commands.txt:
<br>
mkdir &minus;p _output_/_target_/scans/ <br>
_blocker_ <br>
nmap _target_ &minus;oA
_output_/_target_/scans/_target_&minus;nmap <br>
interlace &minus;tL ./targets.txt &minus;cL commands.txt
&minus;o $output <br>
parallel &minus;a targets.txt \ <br>
mkdir &minus;p $output/{}/scans/\; nmap {} &minus;oA
$output/{}/scans/{}&minus;nmap</p>

<p style="margin-left:11%; margin-top: 1em">Blocks</p>

<p style="margin-left:11%; margin-top: 1em">commands.txt:
<br>
_block:nmap_ <br>
mkdir &minus;p _target_/output/scans/ <br>
nmap _target_ &minus;oN
_target_/output/scans/_target_&minus;nmap <br>
_block:nmap_ <br>
nikto &minus;&minus;host _target_ <br>
interlace &minus;tL ./targets.txt &minus;cL commands.txt
<br>
_nmap() { <br>
mkdir &minus;p $1/output/scans/ <br>
nmap $1 &minus;oN $1/output/scans/$1&minus;nmap <br>
} <br>
export &minus;f _nmap <br>
parallel ::: _nmap &quot;nikto &minus;&minus;host&quot; ::::
targets.txt</p>

<p style="margin-left:11%; margin-top: 1em">Run Nikto Over
Multiple Sites</p>

<p style="margin-left:11%; margin-top: 1em">interlace
&minus;tL ./targets.txt &minus;threads 5 \ <br>
&minus;c &quot;nikto &minus;&minus;host _target_ &gt;
./_target_&minus;nikto.txt&quot; &minus;v <br>
parallel &minus;a targets.txt &minus;P5 nikto
&minus;&minus;host {} \&gt; ./{}_&minus;nikto.txt</p>

<p style="margin-left:11%; margin-top: 1em">Run Nikto Over
Multiple Sites and Ports</p>

<p style="margin-left:11%; margin-top: 1em">interlace
&minus;tL ./targets.txt &minus;threads 5 &minus;c \ <br>
&quot;nikto &minus;&minus;host _target_:_port_ &gt;
./_target_&minus;_port_&minus;nikto.txt&quot; \ <br>
&minus;p 80,443 &minus;v <br>
parallel &minus;P5 nikto &minus;&minus;host {1}:{2} \&gt;
./{1}&minus;{2}&minus;nikto.txt \ <br>
:::: targets.txt ::: 80 443</p>

<p style="margin-left:11%; margin-top: 1em">Run a List of
Commands against Target Hosts</p>

<p style="margin-left:11%; margin-top: 1em">commands.txt:
<br>
nikto &minus;&minus;host _target_:_port_ &gt;
_output_/_target_&minus;nikto.txt <br>
sslscan _target_:_port_ &gt;
_output_/_target_&minus;sslscan.txt <br>
testssl.sh _target_:_port_ &gt;
_output_/_target_&minus;testssl.txt <br>
interlace &minus;t example.com &minus;o
~/Engagements/example/ \ <br>
&minus;cL ./commands.txt &minus;p 80,443 <br>
parallel &minus;&minus;results
~/Engagements/example/{2}:{3}{1} {1} {2}:{3} \ <br>
::: &quot;nikto &minus;&minus;host&quot; sslscan testssl.sh
::: example.com ::: 80 443</p>


<p style="margin-left:11%; margin-top: 1em"><small>CIDR</small>
notation with an application that doesn&rsquo;t support
it</p>

<p style="margin-left:11%; margin-top: 1em">interlace
&minus;t 192.168.12.0/24 &minus;c &quot;vhostscan _target_ \
<br>
&minus;oN _output_/_target_&minus;vhosts.txt&quot; &minus;o
~/scans/ &minus;threads 50 <br>
prips 192.168.12.0/24 | <br>
parallel &minus;P50 vhostscan {} &minus;oN
~/scans/{}&minus;vhosts.txt</p>

<p style="margin-left:11%; margin-top: 1em">Glob notation
with an application that doesn&rsquo;t support it</p>

<p style="margin-left:11%; margin-top: 1em">interlace
&minus;t 192.168.12.* &minus;c &quot;vhostscan _target_ \
<br>
&minus;oN _output_/_target_&minus;vhosts.txt&quot; &minus;o
~/scans/ &minus;threads 50 <br>
# Glob is not supported in prips <br>
prips 192.168.12.0/24 | <br>
parallel &minus;P50 vhostscan {} &minus;oN
~/scans/{}&minus;vhosts.txt</p>

<p style="margin-left:11%; margin-top: 1em">Dash (&minus;)
notation with an application that doesn&rsquo;t support
it</p>

<p style="margin-left:11%; margin-top: 1em">interlace
&minus;t 192.168.12.1&minus;15 &minus;c \ <br>
&quot;vhostscan _target_ &minus;oN
_output_/_target_&minus;vhosts.txt&quot; \ <br>
&minus;o ~/scans/ &minus;threads 50 <br>
# Dash notation is not supported in prips <br>
prips 192.168.12.1 192.168.12.15 | <br>
parallel &minus;P50 vhostscan {} &minus;oN
~/scans/{}&minus;vhosts.txt</p>

<p style="margin-left:11%; margin-top: 1em">Threading
Support for an application that doesn&rsquo;t support it</p>

<p style="margin-left:11%; margin-top: 1em">interlace
&minus;tL ./target&minus;list.txt &minus;c \ <br>
&quot;vhostscan &minus;t _target_ &minus;oN
_output_/_target_&minus;vhosts.txt&quot; \ <br>
&minus;o ~/scans/ &minus;threads 50 <br>
cat ./target&minus;list.txt | <br>
parallel &minus;P50 vhostscan &minus;t {} &minus;oN
~/scans/{}&minus;vhosts.txt</p>


<p style="margin-left:11%; margin-top: 1em">alternatively</p>


<p style="margin-left:11%; margin-top: 1em">./vhosts&minus;commands.txt:
<br>
vhostscan &minus;t $target &minus;oN
_output_/_target_&minus;vhosts.txt <br>
interlace &minus;cL ./vhosts&minus;commands.txt &minus;tL
./target&minus;list.txt \ <br>
&minus;threads 50 &minus;o ~/scans <br>
./vhosts&minus;commands.txt: <br>
vhostscan &minus;t &quot;$1&quot; &minus;oN &quot;$2&quot;
<br>
parallel &minus;P50 ./vhosts&minus;commands.txt {}
~/scans/{}&minus;vhosts.txt \ <br>
:::: ./target&minus;list.txt</p>

<p style="margin-left:11%; margin-top: 1em">Exclusions</p>

<p style="margin-left:11%; margin-top: 1em">interlace
&minus;t 192.168.12.0/24 &minus;e 192.168.12.0/26 &minus;c \
<br>
&quot;vhostscan _target_ &minus;oN
_output_/_target_&minus;vhosts.txt&quot; \ <br>
&minus;o ~/scans/ &minus;threads 50 <br>
prips 192.168.12.0/24 | grep &minus;xv &minus;Ff &lt;(prips
192.168.12.0/26) | <br>
parallel &minus;P50 vhostscan {} &minus;oN
~/scans/{}&minus;vhosts.txt</p>

<p style="margin-left:11%; margin-top: 1em">Run Nikto Using
Multiple Proxies</p>

<p style="margin-left:11%; margin-top: 1em">interlace
&minus;tL ./targets.txt &minus;pL ./proxies.txt
&minus;threads 5 &minus;c \ <br>
&quot;nikto &minus;&minus;host _target_:_port_
&minus;useproxy _proxy_ &gt; \ <br>
./_target_&minus;_port_&minus;nikto.txt&quot; &minus;p
80,443 &minus;v <br>
parallel &minus;j5 \ <br>
&quot;nikto &minus;&minus;host {1}:{2} &minus;useproxy {3}
&gt; ./{1}&minus;{2}&minus;nikto.txt&quot; \ <br>
:::: ./targets.txt ::: 80 443 :::: ./proxies.txt</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/codingo/Interlace
(Last checked: 2019&minus;09)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> otonvm Parallel <small>AND GNU</small>
Parallel</b> <br>
I have been unable to get the code to run at all. It seems
unfinished.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/otonvm/Parallel
(Last checked: 2019&minus;02)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> k&minus;bx par <small>AND GNU</small>
Parallel <br>
par</b> requires Haskell to work. This limits the number of
platforms this can work on.</p>

<p style="margin-left:11%; margin-top: 1em"><b>par</b> does
line buffering in memory. The memory usage is 3x the longest
line (compared to 1x for <b>parallel &minus;&minus;lb</b>).
Commands must be given as arguments. There is no
template.</p>

<p style="margin-left:11%; margin-top: 1em">These are the
examples from https://github.com/k&minus;bx/par with the
corresponding <small>GNU</small> <b>parallel</b>
command.</p>

<p style="margin-left:11%; margin-top: 1em">par &quot;echo
foo; sleep 1; echo foo; sleep 1; echo foo&quot; \ <br>
&quot;echo bar; sleep 1; echo bar; sleep 1; echo bar&quot;
&amp;&amp; echo &quot;success&quot; <br>
parallel &minus;&minus;lb ::: &quot;echo foo; sleep 1; echo
foo; sleep 1; echo foo&quot; \ <br>
&quot;echo bar; sleep 1; echo bar; sleep 1; echo bar&quot;
&amp;&amp; echo &quot;success&quot; <br>
par &quot;echo foo; sleep 1; foofoo&quot; \ <br>
&quot;echo bar; sleep 1; echo bar; sleep 1; echo bar&quot;
&amp;&amp; echo &quot;success&quot; <br>
parallel &minus;&minus;lb &minus;&minus;halt 1 :::
&quot;echo foo; sleep 1; foofoo&quot; \ <br>
&quot;echo bar; sleep 1; echo bar; sleep 1; echo bar&quot;
&amp;&amp; echo &quot;success&quot; <br>
par &quot;PARPREFIX=[fooechoer] echo foo&quot;
&quot;PARPREFIX=[bar] echo bar&quot; <br>
parallel &minus;&minus;lb &minus;&minus;colsep ,
&minus;&minus;tagstring {1} {2} \ <br>
::: &quot;[fooechoer],echo foo&quot; &quot;[bar],echo
bar&quot; <br>
par &minus;&minus;succeed &quot;foo&quot; &quot;bar&quot;
&amp;&amp; echo 'wow' <br>
parallel &quot;foo&quot; &quot;bar&quot;; true &amp;&amp;
echo 'wow'</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/k&minus;bx/par
(Last checked: 2019&minus;02)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> parallelshell <small>AND GNU</small>
Parallel <br>
parallelshell</b> does not allow for composed commands:</p>

<p style="margin-left:11%; margin-top: 1em"># This does not
work <br>
parallelshell 'echo foo;echo bar' 'echo baz;echo quuz'</p>

<p style="margin-left:11%; margin-top: 1em">Instead you
have to wrap that in a shell:</p>

<p style="margin-left:11%; margin-top: 1em">parallelshell
'sh &minus;c &quot;echo foo;echo bar&quot;' 'sh &minus;c
&quot;echo baz;echo quuz&quot;'</p>

<p style="margin-left:11%; margin-top: 1em">It buffers
output in <small>RAM.</small> All commands must be given on
the command line and all commands are started in parallel at
the same time. This will cause the system to freeze if there
are so many jobs that there is not enough memory to run them
all at the same time.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/keithamus/parallelshell
(Last checked: 2019&minus;02)</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/darkguy2008/parallelshell
(Last checked: 2019&minus;03)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> shell-executor <small>AND GNU</small>
Parallel <br>
shell-executor</b> does not allow for composed commands:</p>

<p style="margin-left:11%; margin-top: 1em"># This does not
work <br>
sx 'echo foo;echo bar' 'echo baz;echo quuz'</p>

<p style="margin-left:11%; margin-top: 1em">Instead you
have to wrap that in a shell:</p>

<p style="margin-left:11%; margin-top: 1em">sx 'sh &minus;c
&quot;echo foo;echo bar&quot;' 'sh &minus;c &quot;echo
baz;echo quuz&quot;'</p>

<p style="margin-left:11%; margin-top: 1em">It buffers
output in <small>RAM.</small> All commands must be given on
the command line and all commands are started in parallel at
the same time. This will cause the system to freeze if there
are so many jobs that there is not enough memory to run them
all at the same time.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/royriojas/shell&minus;executor
(Last checked: 2019&minus;02)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> non-GNU par <small>AND GNU</small> Parallel
<br>
par</b> buffers in memory to avoid mixing of jobs. It takes
1s per 1 million output lines.</p>

<p style="margin-left:11%; margin-top: 1em"><b>par</b>
needs to have all commands before starting the first job.
The jobs are read from stdin (standard input) so any quoting
will have to be done by the user.</p>

<p style="margin-left:11%; margin-top: 1em">Stdout
(standard output) is prepended with o:. Stderr (standard
error) is sendt to stdout (standard output) and prepended
with e:.</p>

<p style="margin-left:11%; margin-top: 1em">For short jobs
with little output <b>par</b> is 20% faster than
<small>GNU</small> <b>parallel</b> and 60% slower than
<b>xargs</b>.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/UnixJunkie/PAR</p>


<p style="margin-left:11%; margin-top: 1em">https://savannah.nongnu.org/projects/par
(Last checked: 2019&minus;02)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> fd <small>AND GNU</small> Parallel <br>
fd</b> does not support composed commands, so commands must
be wrapped in <b>sh &minus;c</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It buffers
output in <small>RAM.</small></p>

<p style="margin-left:11%; margin-top: 1em">It only takes
file names from the filesystem as input (similar to
<b>find</b>).</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/sharkdp/fd
(Last checked: 2019&minus;02)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> lateral <small>AND GNU</small> Parallel <br>
lateral</b> is very similar to <b>sem</b>: It takes a single
command and runs it in the background. The design means that
output from parallel running jobs may mix. If it dies
unexpectly it leaves a socket in ~/.lateral/socket.PID.</p>

<p style="margin-left:11%; margin-top: 1em"><b>lateral</b>
deals badly with too long command lines. This makes the
<b>lateral</b> server crash:</p>

<p style="margin-left:11%; margin-top: 1em">lateral run
echo `seq 100000| head &minus;c 1000k`</p>

<p style="margin-left:11%; margin-top: 1em">Any options
will be read by <b>lateral</b> so this does not work
(<b>lateral</b> interprets the <b>&minus;l</b>):</p>

<p style="margin-left:11%; margin-top: 1em">lateral run ls
&minus;l</p>

<p style="margin-left:11%; margin-top: 1em">Composed
commands do not work:</p>

<p style="margin-left:11%; margin-top: 1em">lateral run pwd
';' ls</p>

<p style="margin-left:11%; margin-top: 1em">Functions do
not work:</p>

<p style="margin-left:11%; margin-top: 1em">myfunc() { echo
a; } <br>
export &minus;f myfunc <br>
lateral run myfunc</p>

<p style="margin-left:11%; margin-top: 1em">Running
<b>emacs</b> in the terminal causes the parent shell to
die:</p>

<p style="margin-left:11%; margin-top: 1em">echo
'#!/bin/bash' &gt; mycmd <br>
echo emacs &minus;nw &gt;&gt; mycmd <br>
chmod +x mycmd <br>
lateral start <br>
lateral run ./mycmd</p>

<p style="margin-left:11%; margin-top: 1em">Here are the
examples from https://github.com/akramer/lateral with the
corresponding <small>GNU</small> <b>sem</b> and
<small>GNU</small> <b>parallel</b> commands:</p>

<p style="margin-left:11%; margin-top: 1em">1$ lateral
start <br>
for i in $(cat /tmp/names); do <br>
lateral run &minus;&minus; some_command $i <br>
done <br>
lateral wait <br>
1$ for i in $(cat /tmp/names); do <br>
sem some_command $i <br>
done <br>
sem &minus;&minus;wait <br>
1$ parallel some_command :::: /tmp/names <br>
2$ lateral start <br>
for i in $(seq 1 100); do <br>
lateral run &minus;&minus; my_slow_command &lt; workfile$i
&gt; /tmp/logfile$i <br>
done <br>
lateral wait <br>
2$ for i in $(seq 1 100); do <br>
sem my_slow_command &lt; workfile$i &gt; /tmp/logfile$i <br>
done <br>
sem &minus;&minus;wait <br>
2$ parallel 'my_slow_command &lt; workfile{} &gt;
/tmp/logfile{}' \ <br>
::: {1..100} <br>
3$ lateral start &minus;p 0 # yup, it will just queue tasks
<br>
for i in $(seq 1 100); do <br>
lateral run &minus;&minus;
command_still_outputs_but_wont_spam inputfile$i <br>
done <br>
# command output spam can commence <br>
lateral config &minus;p 10; lateral wait <br>
3$ for i in $(seq 1 100); do <br>
echo &quot;command inputfile$i&quot; &gt;&gt; joblist <br>
done <br>
parallel &minus;j 10 :::: joblist <br>
3$ echo 1 &gt; /tmp/njobs <br>
parallel &minus;j /tmp/njobs command inputfile{} \ <br>
::: {1..100} &amp; <br>
echo 10 &gt;/tmp/njobs <br>
wait</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/akramer/lateral
(Last checked: 2019&minus;03)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> with-this <small>AND GNU</small>
Parallel</b> <br>
The examples from
https://github.com/amritb/with&minus;this.git and the
corresponding <small>GNU</small> <b>parallel</b>
command:</p>

<p style="margin-left:11%; margin-top: 1em">with &minus;v
&quot;$(cat myurls.txt)&quot; &quot;curl &minus;L this&quot;
<br>
parallel curl &minus;L ::: myurls.txt <br>
with &minus;v &quot;$(cat myregions.txt)&quot; \ <br>
&quot;aws &minus;&minus;region=this ec2
describe&minus;instance&minus;status&quot; <br>
parallel aws &minus;&minus;region={} ec2
describe&minus;instance&minus;status \ <br>
:::: myregions.txt <br>
with &minus;v &quot;$(ls)&quot; &quot;kubectl
&minus;&minus;kubeconfig=this get pods&quot; <br>
ls | parallel kubectl &minus;&minus;kubeconfig={} get pods
<br>
with &minus;v &quot;$(ls | grep config)&quot; &quot;kubectl
&minus;&minus;kubeconfig=this get pods&quot; <br>
ls | grep config | parallel kubectl
&minus;&minus;kubeconfig={} get pods <br>
with &minus;v &quot;$(echo {1..10})&quot; &quot;echo
123&quot; <br>
parallel &minus;N0 echo 123 ::: {1..10}</p>

<p style="margin-left:11%; margin-top: 1em">Stderr is
merged with stdout. <b>with-this</b> buffers in
<small>RAM.</small> It uses 3x the output size, so you
cannot have output larger than 1/3rd the amount of
<small>RAM.</small> The input values cannot contain spaces.
Composed commands do not work.</p>


<p style="margin-left:11%; margin-top: 1em"><b>with-this</b>
gives some additional information, so the output has to be
cleaned before piping it to the next command.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/amritb/with&minus;this.git
(Last checked: 2019&minus;03)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> Tollef&rsquo;s parallel (moreutils)
<small>AND GNU</small> Parallel</b> <br>
Summary (see legend above): <br>
&minus; &minus; &minus; I4 &minus; &minus; I7 <br>
&minus; &minus; M3 &minus; &minus; M6 <br>
&minus; O2 O3 &minus; O5 O6 &minus; x x <br>
E1 &minus; &minus; &minus; &minus; &minus; E7 <br>
&minus; x x x x x x x x</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><i><small>EXAMPLES FROM</small>
Tollef&rsquo;s parallel <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em"><b>Tollef</b>
parallel sh &minus;c &quot;echo hi; sleep 2; echo bye&quot;
-- 1 2 3</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>GNU</small></b>
parallel &quot;echo hi; sleep 2; echo bye&quot; ::: 1 2
3</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tollef</b>
parallel &minus;j 3 ufraw &minus;o processed -- *.NEF</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>GNU</small></b>
parallel &minus;j 3 ufraw &minus;o processed ::: *.NEF</p>

<p style="margin-left:11%; margin-top: 1em"><b>Tollef</b>
parallel &minus;j 3 -- ls df &quot;echo hi&quot;</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>GNU</small></b>
parallel &minus;j 3 ::: ls df &quot;echo hi&quot;</p>

<p style="margin-left:11%; margin-top: 1em">(Last checked:
2019&minus;08)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> rargs <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 &minus; &minus; &minus; &minus; &minus; I7 <br>
&minus; &minus; M3 M4 &minus; &minus; <br>
&minus; O2 O3 &minus; O5 O6 &minus; O8 &minus; <br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>rargs</b> has elegant ways
of doing named regexp capture and field ranges.</p>

<p style="margin-left:11%; margin-top: 1em">With
<small>GNU</small> <b>parallel</b> you can use
<b>&minus;&minus;rpl</b> to get a similar functionality as
regexp capture gives, and use <b>join</b> and <b>@arg</b> to
get the field ranges. But the syntax is longer. This:</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;rpl
'{r(\d+)\.\.(\d+)}
$_=join&quot;$opt::colsep&quot;,@arg[$$1..$$2]'</p>

<p style="margin-left:11%; margin-top: 1em">would make it
possible to use:</p>

<p style="margin-left:11%; margin-top: 1em">{1r3..6}</p>

<p style="margin-left:11%; margin-top: 1em">for field
3..6.</p>

<p style="margin-left:11%; margin-top: 1em">For full
support of {n..m:s} including negative numbers use a dynamic
replacement string like this:</p>


<p style="margin-left:11%; margin-top: 1em">PARALLEL=&minus;&minus;rpl\
\''{r((&minus;?\d+)?)\.\.((&minus;?\d+)?)((:([^}]*))?)} <br>
$a = defined $$2 ? $$2 &lt; 0 ? 1+$#arg+$$2 : $$2 : 1; <br>
$b = defined $$4 ? $$4 &lt; 0 ? 1+$#arg+$$4 : $$4 : $#arg+1;
<br>
$s = defined $$6 ? $$7 : &quot; &quot;; <br>
$_ = join $s,@arg[$a..$b]'\' <br>
export PARALLEL</p>

<p style="margin-left:11%; margin-top: 1em">You can then
do:</p>

<p style="margin-left:11%; margin-top: 1em">head
/etc/passwd | parallel &minus;&minus;colsep : echo ..={1r..}
..3={1r..3} \ <br>
4..={1r4..} 2..4={1r2..4} 3..3={1r3..3}
..3:&minus;={1r..3:&minus;} \ <br>
..3:/={1r..3:/} &minus;1={&minus;1} &minus;5={&minus;5}
&minus;6={&minus;6} &minus;3..={1r&minus;3..}</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> rargs <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em">1$ ls *.bak |
rargs &minus;p '(.*)\.bak' mv {0} {1} <br>
1$ ls *.bak | parallel mv {} {.} <br>
2$ cat download&minus;list.csv | <br>
rargs &minus;p '(?P&lt;url&gt;.*),(?P&lt;filename&gt;.*)'
wget {url} &minus;O {filename} <br>
2$ cat download&minus;list.csv | <br>
parallel &minus;&minus;csv wget {1} &minus;O {2} <br>
# or use regexps: <br>
2$ cat download&minus;list.csv | <br>
parallel &minus;&minus;rpl '{url} s/,.*//' &minus;&minus;rpl
'{filename} s/.*?,//' \ <br>
wget {url} &minus;O {filename} <br>
3$ cat /etc/passwd | <br>
rargs &minus;d: echo &minus;e 'id: &quot;{1}&quot;\t name:
&quot;{5}&quot;\t rest: &quot;{6..::}&quot;' <br>
3$ cat /etc/passwd | <br>
parallel &minus;q &minus;&minus;colsep : \ <br>
echo &minus;e 'id: &quot;{1}&quot;\t name: &quot;{5}&quot;\t
rest: &quot;{=6
$_=join&quot;:&quot;,@arg[6..$#arg]=}&quot;'</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/lotabout/rargs
(Last checked: 2020&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> threader <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
M1 &minus; M3 &minus; &minus; M6 <br>
O1 &minus; O3 &minus; O5 &minus; &minus; N/A N/A <br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;">Newline separates arguments,
but newline at the end of file is treated as an empty
argument. So this runs 2 jobs:</p>

<p style="margin-left:11%; margin-top: 1em">echo two_jobs |
threader &minus;run 'echo &quot;$THREADID&quot;'</p>


<p style="margin-left:11%; margin-top: 1em"><b>threader</b>
ignores stderr, so any output to stderr is lost.
<b>threader</b> buffers in <small>RAM,</small> so output
bigger than the machine&rsquo;s virtual memory will cause
the machine to crash.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/voodooEntity/threader
(Last checked: 2020&minus;04)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> runp <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 I2 &minus; &minus; &minus; &minus; &minus; <br>
M1 &minus; (M3) &minus; &minus; M6 <br>
O1 O2 O3 &minus; O5 O6 &minus; N/A N/A &minus; <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;">(M3): You can add a prefix and
a postfix to the input, so it means you can only insert the
argument on the command line once.</p>

<p style="margin-left:11%; margin-top: 1em"><b>runp</b>
runs 10 jobs in parallel by default. <b>runp</b> blocks if
output of a command is &gt; 64 Kbytes. Quoting of input is
needed. It adds output to stderr (this can be prevented with
&minus;q)</p>

<p style="margin-left:11%; margin-top: 1em"><i>Examples as
<small>GNU</small> Parallel</i></p>


<p style="margin-left:11%; margin-top: 1em">base='https://images&minus;api.nasa.gov/search'
<br>
query='jupiter' <br>
desc='planet' <br>
type='image' <br>

url=&quot;$base?q=$query&amp;description=$desc&amp;media_type=$type&quot;
<br>
# Download the images in parallel using runp <br>
curl &minus;s $url | jq &minus;r .collection.items[].href |
\ <br>
runp &minus;p 'curl &minus;s' | jq &minus;r .[] | grep large
| \ <br>
runp &minus;p 'curl &minus;s &minus;L &minus;O' <br>
time curl &minus;s $url | jq &minus;r
.collection.items[].href | \ <br>
runp &minus;g 1 &minus;q &minus;p 'curl &minus;s' | jq
&minus;r .[] | grep large | \ <br>
runp &minus;g 1 &minus;q &minus;p 'curl &minus;s &minus;L
&minus;O' <br>
# Download the images in parallel <br>
curl &minus;s $url | jq &minus;r .collection.items[].href |
\ <br>
parallel curl &minus;s | jq &minus;r .[] | grep large | \
<br>
parallel curl &minus;s &minus;L &minus;O <br>
time curl &minus;s $url | jq &minus;r
.collection.items[].href | \ <br>
parallel &minus;j 1 curl &minus;s | jq &minus;r .[] | grep
large | \ <br>
parallel &minus;j 1 curl &minus;s &minus;L &minus;O</p>

<p style="margin-left:11%; margin-top: 1em">Run some test
commands (read from file)</p>

<p style="margin-left:11%; margin-top: 1em"># Create a file
containing commands to run in parallel. <br>
cat &lt;&lt; EOF &gt; /tmp/test&minus;commands.txt <br>
sleep 5 <br>
sleep 3 <br>
blah # this will fail <br>
ls $PWD # PWD shell variable is used here <br>
EOF <br>
# Run commands from the file. <br>
runp /tmp/test&minus;commands.txt &gt; /dev/null <br>
parallel &minus;a /tmp/test&minus;commands.txt &gt;
/dev/null</p>

<p style="margin-left:11%; margin-top: 1em">Ping several
hosts and see packet loss (read from stdin)</p>

<p style="margin-left:11%; margin-top: 1em"># First copy
this line and press Enter <br>
runp &minus;p 'ping &minus;c 5 &minus;W 2' &minus;s '| grep
loss' <br>
localhost <br>
1.1.1.1 <br>
8.8.8.8 <br>
# Press Enter and Ctrl&minus;D when done entering the hosts
<br>
# First copy this line and press Enter <br>
parallel ping &minus;c 5 &minus;W 2 {} '| grep loss' <br>
localhost <br>
1.1.1.1 <br>
8.8.8.8 <br>
# Press Enter and Ctrl&minus;D when done entering the
hosts</p>

<p style="margin-left:11%; margin-top: 1em">Get
directories&rsquo; sizes (read from stdin)</p>

<p style="margin-left:11%; margin-top: 1em">echo &minus;e
&quot;$HOME\n/etc\n/tmp&quot; | runp &minus;q &minus;p 'sudo
du &minus;sh' <br>
echo &minus;e &quot;$HOME\n/etc\n/tmp&quot; | parallel sudo
du &minus;sh <br>
# or: <br>
parallel sudo du &minus;sh ::: &quot;$HOME&quot; /etc
/tmp</p>

<p style="margin-left:11%; margin-top: 1em">Compress
files</p>

<p style="margin-left:11%; margin-top: 1em">find .
&minus;iname '*.txt' | runp &minus;p 'gzip
&minus;&minus;best' <br>
find . &minus;iname '*.txt' | parallel gzip
&minus;&minus;best</p>

<p style="margin-left:11%; margin-top: 1em">Measure
<small>HTTP</small> request + response time</p>

<p style="margin-left:11%; margin-top: 1em">export
CURL=&quot;curl &minus;w 'time_total: %{time_total}\n'&quot;
<br>
CURL=&quot;$CURL &minus;o /dev/null &minus;s
https://golang.org/&quot; <br>
perl &minus;wE 'for (1..10) { say $ENV{CURL} }' | <br>
runp &minus;q # Make 10 requests <br>
perl &minus;wE 'for (1..10) { say $ENV{CURL} }' | parallel
<br>
# or: <br>
parallel &minus;N0 &quot;$CURL&quot; ::: {1..10}</p>

<p style="margin-left:11%; margin-top: 1em">Find open
<small>TCP</small> ports</p>

<p style="margin-left:11%; margin-top: 1em">cat &lt;&lt;
EOF &gt; /tmp/host&minus;port.txt <br>
localhost 22 <br>
localhost 80 <br>
localhost 81 <br>
127.0.0.1 443 <br>
127.0.0.1 444 <br>
scanme.nmap.org 22 <br>
scanme.nmap.org 23 <br>
scanme.nmap.org 443 <br>
EOF <br>
1$ cat /tmp/host&minus;port.txt | <br>
runp &minus;q &minus;p 'netcat &minus;v &minus;w2 &minus;z'
2&gt;&amp;1 | egrep '(succeeded!|open)$' <br>
# &minus;&minus;colsep is needed to split the line <br>
1$ cat /tmp/host&minus;port.txt | <br>
parallel &minus;&minus;colsep ' ' netcat &minus;v &minus;w2
&minus;z 2&gt;&amp;1 | <br>
egrep '(succeeded!|open)$' <br>
# or use uq for unquoted: <br>
1$ cat /tmp/host&minus;port.txt | <br>
parallel netcat &minus;v &minus;w2 &minus;z {=uq=}
2&gt;&amp;1 | <br>
egrep '(succeeded!|open)$'</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/jreisinger/runp
(Last checked: 2020&minus;04)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> papply <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
&minus; &minus; &minus; I4 &minus; &minus; &minus; <br>
M1 &minus; M3 &minus; &minus; M6 <br>
&minus; &minus; O3 &minus; O5 &minus; &minus; N/A N/A O10
<br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>papply</b> does not print
the output if the command fails:</p>

<p style="margin-left:11%; margin-top: 1em">$ papply 'echo
%F; false' foo <br>
&quot;echo foo; false&quot; did not succeed</p>


<p style="margin-left:11%; margin-top: 1em"><b>papply</b>&rsquo;s
replacement strings (%F %d %f %n %e %z) can be simulated in
<small>GNU</small> <b>parallel</b> by putting this in
<b>~/.parallel/config</b>:</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;rpl
'%F' <br>
&minus;&minus;rpl '%d $_=Q(::dirname($_));' <br>
&minus;&minus;rpl '%f s:.*/::;' <br>
&minus;&minus;rpl '%n s:.*/::;s:\.[^/.]+$::;' <br>
&minus;&minus;rpl '%e s:.*\.:.:' <br>
&minus;&minus;rpl '%z $_=&quot;&quot;'</p>

<p style="margin-left:11%; margin-top: 1em"><b>papply</b>
buffers in <small>RAM,</small> and uses twice the amount of
output. So output of 5 <small>GB</small> takes 10 <small>GB
RAM.</small></p>

<p style="margin-left:11%; margin-top: 1em">The buffering
is very <small>CPU</small> intensive: Buffering a line of 5
<small>GB</small> takes 40 seconds (compared to 10 seconds
with <small>GNU</small> <b>parallel</b>).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Examples as
<small>GNU</small> Parallel</i></p>

<p style="margin-left:11%; margin-top: 1em">1$ papply gzip
*.txt <br>
1$ parallel gzip ::: *.txt <br>
2$ papply &quot;convert %F %n.jpg&quot; *.png <br>
2$ parallel convert {} {.}.jpg ::: *.png</p>


<p style="margin-left:11%; margin-top: 1em">https://pypi.org/project/papply/
(Last checked: 2020&minus;04)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> async <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
&minus; &minus; &minus; I4 &minus; &minus; I7 <br>
&minus; &minus; &minus; &minus; &minus; M6 <br>
&minus; O2 O3 &minus; O5 O6 &minus; N/A N/A O10 <br>
E1 &minus; &minus; E4 &minus; E6 &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus; <br>
S1 S2</p>

<p style="margin-left:11%; margin-top: 1em"><b>async</b> is
very similary to <small>GNU</small> <b>parallel</b>&rsquo;s
<b>&minus;&minus;semaphore</b> mode (aka <b>sem</b>).
<b>async</b> requires the user to start a server
process.</p>

<p style="margin-left:11%; margin-top: 1em">The input is
quoted like <b>&minus;q</b> so you need <b>bash &minus;c
&quot;...;...&quot;</b> to run composed commands.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Examples as
<small>GNU</small> Parallel</i></p>

<p style="margin-left:11%; margin-top: 1em">1$
S=&quot;/tmp/example_socket&quot; <br>
1$ ID=myid <br>
2$ async &minus;s=&quot;$S&quot; server &minus;&minus;start
<br>
2$ # GNU Parallel does not need a server to run <br>
3$ for i in {1..20}; do <br>
# prints command output to stdout <br>
async &minus;s=&quot;$S&quot; cmd &minus;&minus; bash
&minus;c &quot;sleep 1 &amp;&amp; echo test $i&quot; <br>
done <br>
3$ for i in {1..20}; do <br>
# prints command output to stdout <br>
sem &minus;&minus;id &quot;$ID&quot; &minus;j100%
&quot;sleep 1 &amp;&amp; echo test $i&quot; <br>
# GNU Parallel will only print job when it is done <br>
# If you need output from different jobs to mix <br>
# use &minus;u or &minus;&minus;line&minus;buffer <br>
sem &minus;&minus;id &quot;$ID&quot; &minus;j100%
&minus;&minus;line&minus;buffer &quot;sleep 1 &amp;&amp;
echo test $i&quot; <br>
done <br>
4$ # wait until all commands are finished <br>
async &minus;s=&quot;$S&quot; wait <br>
4$ sem &minus;&minus;id &quot;$ID&quot; &minus;&minus;wait
<br>
5$ # configure the server to run four commands in parallel
<br>
async &minus;s=&quot;$S&quot; server &minus;j4 <br>
5$ export PARALLEL=&minus;j4 <br>
6$ mkdir &quot;/tmp/ex_dir&quot; <br>
for i in {21..40}; do <br>
# redirects command output to /tmp/ex_dir/file* <br>
async &minus;s=&quot;$S&quot; cmd &minus;o
&quot;/tmp/ex_dir/file$i&quot; &minus;&minus; \ <br>
bash &minus;c &quot;sleep 1 &amp;&amp; echo test $i&quot;
<br>
done <br>
6$ mkdir &quot;/tmp/ex_dir&quot; <br>
for i in {21..40}; do <br>
# redirects command output to /tmp/ex_dir/file* <br>
sem &minus;&minus;id &quot;$ID&quot; &minus;&minus;result
'/tmp/my&minus;ex/file&minus;{=$_=&quot;&quot;=}'&quot;$i&quot;
\ <br>
&quot;sleep 1 &amp;&amp; echo test $i&quot; <br>
done <br>
7$ sem &minus;&minus;id &quot;$ID&quot; &minus;&minus;wait
<br>
7$ async &minus;s=&quot;$S&quot; wait <br>
8$ # stops server <br>
async &minus;s=&quot;$S&quot; server &minus;&minus;stop <br>
8$ # GNU Parallel does not need to stop a server</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/ctbur/async/
(Last checked: 2023&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> pardi <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 I2 &minus; &minus; &minus; &minus; I7 <br>
M1 &minus; &minus; &minus; &minus; M6 <br>
O1 O2 O3 O4 O5 &minus; O7 &minus; &minus; O10 <br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>pardi</b> is very similar to
<b>parallel &minus;&minus;pipe &minus;&minus;cat</b>: It
reads blocks of data and not arguments. So it cannot insert
an argument in the command line. It puts the block into a
temporary file, and this file name (%IN) can be put in the
command line. You can only use %IN once.</p>

<p style="margin-left:11%; margin-top: 1em">It can also run
full command lines in parallel (like: <b>cat file |
parallel</b>).</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> pardi test.sh</i></p>

<p style="margin-left:11%; margin-top: 1em">1$ time pardi
&minus;v &minus;c 100 &minus;i data/decoys.smi &minus;ie
.smi &minus;oe .smi \ <br>
&minus;o data/decoys_std_pardi.smi \ <br>
&minus;w '(standardiser &minus;i %IN &minus;o %OUT
2&gt;&amp;1) &gt; /dev/null' <br>
1$ cat data/decoys.smi | <br>
time parallel &minus;N 100 &minus;&minus;pipe
&minus;&minus;cat \ <br>
'(standardiser &minus;i {} &minus;o {#} 2&gt;&amp;1) &gt;
/dev/null; cat {#}; rm {#}' \ <br>
&gt; data/decoys_std_pardi.smi <br>
2$ pardi &minus;n 1 &minus;i data/test_in.types &minus;o
data/test_out.types \ <br>
&minus;d 'r:^#atoms:' &minus;w 'cat %IN &gt; %OUT' <br>
2$ cat data/test_in.types | <br>
parallel &minus;n 1 &minus;k &minus;&minus;pipe
&minus;&minus;cat &minus;&minus;regexp
&minus;&minus;recstart '^#atoms' \ <br>
'cat {}' &gt; data/test_out.types <br>
3$ pardi &minus;c 6 &minus;i data/test_in.types &minus;o
data/test_out.types \ <br>
&minus;d 'r:^#atoms:' &minus;w 'cat %IN &gt; %OUT' <br>
3$ cat data/test_in.types | <br>
parallel &minus;n 6 &minus;k &minus;&minus;pipe
&minus;&minus;cat &minus;&minus;regexp
&minus;&minus;recstart '^#atoms' \ <br>
'cat {}' &gt; data/test_out.types <br>
4$ pardi &minus;i data/decoys.mol2 &minus;o
data/still_decoys.mol2 \ <br>
&minus;d 's:@&lt;TRIPOS&gt;MOLECULE' &minus;w 'cp %IN %OUT'
<br>
4$ cat data/decoys.mol2 | <br>
parallel &minus;n 1 &minus;&minus;pipe &minus;&minus;cat
&minus;&minus;recstart '@&lt;TRIPOS&gt;MOLECULE' \ <br>
'cp {} {#}; cat {#}; rm {#}' &gt; data/still_decoys.mol2
<br>
5$ pardi &minus;i data/decoys.mol2 &minus;o
data/decoys2.mol2 \ <br>
&minus;d b:10000 &minus;w 'cp %IN %OUT'
&minus;&minus;preserve <br>
5$ cat data/decoys.mol2 | <br>
parallel &minus;k &minus;&minus;pipe &minus;&minus;block 10k
&minus;&minus;recend '' &minus;&minus;cat \ <br>
'cat {} &gt; {#}; cat {#}; rm {#}' &gt;
data/decoys2.mol2</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/UnixJunkie/pardi
(Last checked: 2021&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> bthread <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
&minus; &minus; &minus; I4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; M6 <br>
O1 &minus; O3 &minus; &minus; &minus; O7 O8 &minus; &minus;
<br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>bthread</b> takes around 1
sec per <small>MB</small> of output. The maximal output line
length is 1073741759.</p>

<p style="margin-left:11%; margin-top: 1em">You cannot
quote space in the command, so you cannot run composed
commands like <b>sh &minus;c &quot;echo a; echo
b&quot;</b>.</p>


<p style="margin-left:11%; margin-top: 1em">https://gitlab.com/netikras/bthread
(Last checked: 2021&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> simple_gpu_scheduler <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
I1 &minus; &minus; &minus; &minus; &minus; I7 <br>
M1 &minus; &minus; &minus; &minus; M6 <br>
&minus; O2 O3 &minus; &minus; O6 &minus; x x O10 <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><i><small>EXAMPLES FROM</small>
simple_gpu_scheduler <small>MANUAL</small></i></p>

<p style="margin-left:11%; margin-top: 1em">1$
simple_gpu_scheduler &minus;&minus;gpus 0 1 2 &lt;
gpu_commands.txt <br>
1$ parallel &minus;j3 &minus;&minus;shuf \ <br>
CUDA_VISIBLE_DEVICES='{=1 $_=slot()&minus;1 =} {=uq;=}' \
<br>
&lt; gpu_commands.txt <br>
2$ simple_hypersearch \ <br>
&quot;python3 train_dnn.py &minus;&minus;lr {lr}
&minus;&minus;batch_size {bs}&quot; \ <br>
&minus;p lr 0.001 0.0005 0.0001 &minus;p bs 32 64 128 | <br>
simple_gpu_scheduler &minus;&minus;gpus 0,1,2 <br>
2$ parallel &minus;&minus;header : &minus;&minus;shuf
&minus;j3 &minus;v \ <br>
CUDA_VISIBLE_DEVICES='{=1 $_=slot()&minus;1 =}' \ <br>
python3 train_dnn.py &minus;&minus;lr {lr}
&minus;&minus;batch_size {bs} \ <br>
::: lr 0.001 0.0005 0.0001 ::: bs 32 64 128 <br>
3$ simple_hypersearch \ <br>
&quot;python3 train_dnn.py &minus;&minus;lr {lr}
&minus;&minus;batch_size {bs}&quot; \ <br>
&minus;&minus;n&minus;samples 5 &minus;p lr 0.001 0.0005
0.0001 &minus;p bs 32 64 128 | <br>
simple_gpu_scheduler &minus;&minus;gpus 0,1,2 <br>
3$ parallel &minus;&minus;header : &minus;&minus;shuf \ <br>
CUDA_VISIBLE_DEVICES='{=1 $_=slot()&minus;1; seq()&gt;5 and
skip() =}' \ <br>
python3 train_dnn.py &minus;&minus;lr {lr}
&minus;&minus;batch_size {bs} \ <br>
::: lr 0.001 0.0005 0.0001 ::: bs 32 64 128 <br>
4$ touch gpu.queue <br>
tail &minus;f &minus;n 0 gpu.queue | simple_gpu_scheduler
&minus;&minus;gpus 0,1,2 &amp; <br>
echo &quot;my_command_with | and stuff &gt; logfile&quot;
&gt;&gt; gpu.queue <br>
4$ touch gpu.queue <br>
tail &minus;f &minus;n 0 gpu.queue | <br>
parallel &minus;j3 CUDA_VISIBLE_DEVICES='{=1
$_=slot()&minus;1 =} {=uq;=}' &amp; <br>
# Needed to fill job slots once <br>
seq 3 | parallel echo true &gt;&gt; gpu.queue <br>
# Add jobs <br>
echo &quot;my_command_with | and stuff &gt; logfile&quot;
&gt;&gt; gpu.queue <br>
# Needed to flush output from completed jobs <br>
seq 3 | parallel echo true &gt;&gt; gpu.queue</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/ExpectationMax/simple_gpu_scheduler
(Last checked: 2021&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> parasweep <small>AND GNU</small> Parallel
<br>
parasweep</b> is a Python module for facilitating parallel
parameter sweeps.</p>

<p style="margin-left:11%; margin-top: 1em">A
<b>parasweep</b> job will normally take a text file as
input. The text file contains arguments for the job. Some of
these arguments will be fixed and some of them will be
changed by <b>parasweep</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It does this by
having a template file such as template.txt:</p>

<p style="margin-left:11%; margin-top: 1em">Xval: {x} <br>
Yval: {y} <br>
FixedValue: 9 <br>
# x with 2 decimals <br>
DecimalX: {x:.2f} <br>
TenX: ${x*10} <br>
RandomVal: {r}</p>

<p style="margin-left:11%; margin-top: 1em">and from this
template it generates the file to be used by the job by
replacing the replacement strings.</p>

<p style="margin-left:11%; margin-top: 1em">Being a Python
module <b>parasweep</b> integrates tighter with Python than
<small>GNU</small> <b>parallel</b>. You get the parameters
directly in a Python data structure. With <small>GNU</small>
<b>parallel</b> you can use the <small>JSON</small> or
<small>CSV</small> output format to get something similar,
but you would have to read the output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>parasweep</b>
has a filtering method to ignore parameter combinations you
do not need.</p>

<p style="margin-left:11%; margin-top: 1em">Instead of
calling the jobs directly, <b>parasweep</b> can use
Python&rsquo;s Distributed Resource Management Application
<small>API</small> to make jobs run with different cluster
software.</p>


<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel &minus;&minus;tmpl</b> supports templates with
replacement strings. Such as:</p>

<p style="margin-left:11%; margin-top: 1em">Xval: {x} <br>
Yval: {y} <br>
FixedValue: 9 <br>
# x with 2 decimals <br>
DecimalX: {=x $_=sprintf(&quot;%.2f&quot;,$_) =} <br>
TenX: {=x $_=$_*10 =} <br>
RandomVal: {=1 $_=rand() =}</p>

<p style="margin-left:11%; margin-top: 1em">that can be
used like:</p>

<p style="margin-left:11%; margin-top: 1em">parallel
&minus;&minus;header : &minus;&minus;tmpl my.tmpl={#}.t
myprog {#}.t \ <br>
::: x 1 2 3 ::: y 1 2 3</p>

<p style="margin-left:11%; margin-top: 1em">Filtering is
supported as:</p>

<p style="margin-left:11%; margin-top: 1em">parallel
&minus;&minus;filter '{1} &gt; {2}' echo ::: 1 2 3 ::: 1 2
3</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/eviatarbach/parasweep
(Last checked: 2021&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> parallel-bash <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
I1 I2 &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; M3 &minus; &minus; M6 <br>
&minus; O2 O3 &minus; O5 O6 &minus; O8 x O10 <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>parallel-bash</b> is written
in pure bash. It is really fast (overhead of ~0.05 ms/job
compared to <small>GNU</small> <b>parallel</b>&rsquo;s
3&minus;10 ms/job). So if your jobs are extremely short
lived, and you can live with the quite limited command, this
may be useful.</p>

<p style="margin-left:11%; margin-top: 1em">It works by
making a queue for each process. Then the jobs are
distributed to the queues in a round robin fashion. Finally
the queues are started in parallel. This works fine, if you
are lucky, but if not, all the long jobs may end up in the
same queue, so you may see:</p>

<p style="margin-left:11%; margin-top: 1em">$ printf
&quot;%b\n&quot; 1 1 1 4 1 1 1 4 1 1 1 4 | <br>
time parallel &minus;P4 sleep {} <br>
(7 seconds) <br>
$ printf &quot;%b\n&quot; 1 1 1 4 1 1 1 4 1 1 1 4 | <br>
time ./parallel&minus;bash.bash &minus;p 4 &minus;c sleep {}
<br>
(12 seconds)</p>

<p style="margin-left:11%; margin-top: 1em">Because it uses
bash lists, the total number of jobs is limited to
167000..265000 depending on your environment. You get a
segmentation fault, when you reach the limit.</p>

<p style="margin-left:11%; margin-top: 1em">Ctrl-C does not
stop spawning new jobs. Ctrl-Z does not suspend running
jobs.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> parallel-bash</i></p>

<p style="margin-left:11%; margin-top: 1em">1$ some_input |
parallel&minus;bash &minus;p 5 &minus;c echo <br>
1$ some_input | parallel &minus;j 5 echo <br>
2$ parallel&minus;bash &minus;p 5 &minus;c echo &lt;
some_file <br>
2$ parallel &minus;j 5 echo &lt; some_file <br>
3$ parallel&minus;bash &minus;p 5 &minus;c echo &lt;&lt;&lt;
'some string' <br>
3$ parallel &minus;j 5 &minus;c echo &lt;&lt;&lt; 'some
string' <br>
4$ something | parallel&minus;bash &minus;p 5 &minus;c echo
{} {} <br>
4$ something | parallel &minus;j 5 echo {} {}</p>


<p style="margin-left:11%; margin-top: 1em">https://reposhub.com/python/command&minus;line&minus;tools/Akianonymus&minus;parallel&minus;bash.html
(Last checked: 2021&minus;06)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> bash-concurrent <small>AND GNU</small>
Parallel <br>
bash-concurrent</b> is more an alternative to <b>make</b>
than to <small>GNU</small> <b>parallel</b>. Its input is
very similar to a Makefile, where jobs depend on other
jobs.</p>

<p style="margin-left:11%; margin-top: 1em">It has a nice
progress indicator where you can see which jobs completed
successfully, which jobs are currently running, which jobs
failed, and which jobs were skipped due to a depending job
failed. The indicator does not deal well with resizing the
window.</p>

<p style="margin-left:11%; margin-top: 1em">Output is
cached in tempfiles on disk, but is only shown if there is
an error, so it is not meant to be part of a
<small>UNIX</small> pipeline. If <b>bash-concurrent</b>
crashes these tempfiles are not removed.</p>

<p style="margin-left:11%; margin-top: 1em">It uses an
O(n*n) algorithm, so if you have 1000 independent jobs it
takes 22 seconds to start it.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/themattrix/bash&minus;concurrent
(Last checked: 2021&minus;02)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> spawntool <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
I1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
M1 &minus; &minus; &minus; &minus; M6 <br>
&minus; O2 O3 &minus; O5 O6 &minus; x x O10 <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>spawn</b> reads a full
command line from stdin which it executes in parallel.</p>


<p style="margin-left:11%; margin-top: 1em">http://code.google.com/p/spawntool/
(Last checked: 2021&minus;07)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> go-pssh <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus; <br>
M1 &minus; &minus; &minus; &minus; &minus; <br>
O1 &minus; &minus; &minus; &minus; &minus; &minus; x x O10
<br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
R1 R2 &minus; &minus; &minus; R6 &minus; &minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>go-pssh</b> does <b>ssh</b>
in parallel to multiple machines. It runs the same command
on multiple machines similar to
<b>&minus;&minus;nonall</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The hostnames
must be given as IP-addresses (not as hostnames).</p>

<p style="margin-left:11%; margin-top: 1em">Output is sent
to stdout (standard output) if command is successful, and to
stderr (standard error) if the command fails.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> go-pssh</i></p>

<p style="margin-left:11%; margin-top: 1em">1$
go&minus;pssh &minus;l &lt;ip&gt;,&lt;ip&gt; &minus;u
&lt;user&gt; &minus;p &lt;port&gt; &minus;P &lt;passwd&gt;
&minus;c &quot;&lt;command&gt;&quot; <br>
1$ parallel &minus;S 'sshpass &minus;p &lt;passwd&gt; ssh
&minus;p &lt;port&gt; &lt;user&gt;@&lt;ip&gt;' \ <br>
&minus;&minus;nonall &quot;&lt;command&gt;&quot; <br>
2$ go&minus;pssh scp &minus;f host.txt &minus;u &lt;user&gt;
&minus;p &lt;port&gt; &minus;P &lt;password&gt; \ <br>
&minus;s /local/file_or_directory &minus;d /remote/directory
<br>
2$ parallel &minus;&minus;nonall &minus;&minus;slf host.txt
\ <br>
&minus;&minus;basefile /local/file_or_directory/./
&minus;&minus;wd /remote/directory <br>
&minus;&minus;ssh 'sshpass &minus;p &lt;password&gt; ssh
&minus;p &lt;port&gt; &minus;l &lt;user&gt;' true <br>
3$ go&minus;pssh scp &minus;l &lt;ip&gt;,&lt;ip&gt; &minus;u
&lt;user&gt; &minus;p &lt;port&gt; &minus;P &lt;password&gt;
\ <br>
&minus;s /local/file_or_directory &minus;d /remote/directory
<br>
3$ parallel &minus;&minus;nonall &minus;S
&lt;ip&gt;,&lt;ip&gt; \ <br>
&minus;&minus;basefile /local/file_or_directory/./
&minus;&minus;wd /remote/directory <br>
&minus;&minus;ssh 'sshpass &minus;p &lt;password&gt; ssh
&minus;p &lt;port&gt; &minus;l &lt;user&gt;' true</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/xuchenCN/go&minus;pssh
(Last checked: 2021&minus;07)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> go-parallel <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
I1 I2 &minus; &minus; &minus; &minus; I7 <br>
&minus; &minus; M3 &minus; &minus; M6 <br>
&minus; O2 O3 &minus; O5 &minus; &minus; x x &minus; O10
<br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>go-parallel</b> uses Go
templates for replacement strings. Quite similar to the
<i>{= perl expr =}</i> replacement string.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> go-parallel</i></p>

<p style="margin-left:11%; margin-top: 1em">1$
go&minus;parallel &minus;a ./files.txt &minus;t 'cp
{{.Input}} {{.Input | dirname | dirname}}' <br>
1$ parallel &minus;a ./files.txt cp {} '{=
$_=::dirname(::dirname($_)) =}' <br>
2$ go&minus;parallel &minus;a ./files.txt &minus;t 'mkdir
&minus;p {{.Input}} {{noExt .Input}}' <br>
2$ parallel &minus;a ./files.txt echo mkdir &minus;p {} {.}
<br>
3$ go&minus;parallel &minus;a ./files.txt &minus;t 'mkdir
&minus;p {{.Input}} {{.Input | basename | noExt}}' <br>
3$ parallel &minus;a ./files.txt echo mkdir &minus;p {}
{/.}</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/mylanconnolly/parallel
(Last checked: 2021&minus;07)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> p <small>AND GNU</small> Parallel</b> <br>
Summary (see legend above): <br>
&minus; &minus; &minus; I4 &minus; &minus; N/A <br>
&minus; &minus; &minus; &minus; &minus; M6 <br>
&minus; O2 O3 &minus; O5 O6 &minus; x x &minus; O10 <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>p</b> is a tiny shell
script. It can color output with some predefined colors, but
is otherwise quite limited.</p>

<p style="margin-left:11%; margin-top: 1em">It maxes out at
around 116000 jobs (probably due to limitations in
Bash).</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> p</i></p>

<p style="margin-left:11%; margin-top: 1em">Some of the
examples from <b>p</b> cannot be implemented 100% by
<small>GNU</small> <b>parallel</b>: The coloring is a bit
different, and <small>GNU</small> <b>parallel</b> cannot
have <b>&minus;&minus;tag</b> for some inputs and not for
others.</p>

<p style="margin-left:11%; margin-top: 1em">The coloring
done by <small>GNU</small> <b>parallel</b> is not exactly
the same as <b>p</b>.</p>

<p style="margin-left:11%; margin-top: 1em">1$ p &minus;bc
blue &quot;ping 127.0.0.1&quot; &minus;uc red &quot;ping
192.168.0.1&quot; \ <br>
&minus;rc yellow &quot;ping 192.168.1.1&quot; &minus;t
example &quot;ping example.com&quot; <br>
1$ parallel &minus;&minus;lb &minus;j0 &minus;&minus;color
&minus;&minus;tag ping \ <br>
::: 127.0.0.1 192.168.0.1 192.168.1.1 example.com <br>
2$ p &quot;tail &minus;f /var/log/httpd/access_log&quot; \
<br>
&minus;bc red &quot;tail &minus;f
/var/log/httpd/error_log&quot; <br>
2$ cd /var/log/httpd; <br>
parallel &minus;&minus;lb &minus;&minus;color
&minus;&minus;tag tail &minus;f ::: access_log error_log
<br>
3$ p tail &minus;f &quot;some file&quot; \&amp; p tail
&minus;f &quot;other file with space.txt&quot; <br>
3$ parallel &minus;&minus;lb tail &minus;f ::: 'some file'
&quot;other file with space.txt&quot; <br>
4$ p &minus;t project1 &quot;hg pull project1&quot; &minus;t
project2 \ <br>
&quot;hg pull project2&quot; &minus;t project3 &quot;hg pull
project3&quot; <br>
4$ parallel &minus;&minus;lb hg pull ::: project{1..3}</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/rudymatela/evenmoreutils/blob/master/man/p.1.adoc
(Last checked: 2022&minus;04)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> senechal <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
M1 &minus; M3 &minus; &minus; M6 <br>
O1 &minus; O3 O4 &minus; &minus; &minus; x x &minus; <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>seneschal</b> only starts
the first job after reading the last job, and output from
the first job is only printed after the last job
finishes.</p>

<p style="margin-left:11%; margin-top: 1em">1 byte of
output requites 3.5 bytes of <small>RAM.</small></p>

<p style="margin-left:11%; margin-top: 1em">This makes it
impossible to have a total output bigger than the virtual
memory.</p>

<p style="margin-left:11%; margin-top: 1em">Even though
output is kept in <small>RAM</small> outputing is quite
slow: 30 MB/s.</p>

<p style="margin-left:11%; margin-top: 1em">Output larger
than 4 <small>GB</small> causes random problems &minus; it
looks like a race condition.</p>

<p style="margin-left:11%; margin-top: 1em">This:</p>

<p style="margin-left:11%; margin-top: 1em">echo 1 |
seneschal &minus;&minus;prefix='yes `seq 1000`|head &minus;c
1G' &gt;/dev/null</p>

<p style="margin-left:11%; margin-top: 1em">takes 4100(!)
<small>CPU</small> seconds to run on a 64C64T server, but
only 140 <small>CPU</small> seconds on a 4C8T laptop. So it
looks like <b>seneschal</b> wastes a lot of
<small>CPU</small> time coordinating the CPUs.</p>

<p style="margin-left:11%; margin-top: 1em">Compare this
to:</p>

<p style="margin-left:11%; margin-top: 1em">echo 1 | time
&minus;v parallel &minus;N0 'yes `seq 1000`|head &minus;c
1G' &gt;/dev/null</p>

<p style="margin-left:11%; margin-top: 1em">which takes
3&minus;8 <small>CPU</small> seconds.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> seneschal <small>README</small> .md</i></p>

<p style="margin-left:11%; margin-top: 1em">1$ echo $REPOS
| seneschal &minus;&minus;prefix=&quot;cd {} &amp;&amp; git
pull&quot; <br>
# If $REPOS is newline separated <br>
1$ echo &quot;$REPOS&quot; | parallel &minus;k &quot;cd {}
&amp;&amp; git pull&quot; <br>
# If $REPOS is space separated <br>
1$ echo &minus;n &quot;$REPOS&quot; | parallel &minus;d' '
&minus;k &quot;cd {} &amp;&amp; git pull&quot; <br>
COMMANDS=&quot;pwd <br>
sleep 5 &amp;&amp; echo boom <br>
echo Howdy <br>
whoami&quot; <br>
2$ echo &quot;$COMMANDS&quot; | seneschal
&minus;&minus;debug <br>
2$ echo &quot;$COMMANDS&quot; | parallel &minus;k &minus;v
<br>
3$ ls &minus;1 | seneschal &minus;&minus;prefix=&quot;pushd
{}; git pull; popd;&quot; <br>
3$ ls &minus;1 | parallel &minus;k &quot;pushd {}; git pull;
popd;&quot; <br>
# Or if current dir also contains files: <br>
3$ parallel &minus;k &quot;pushd {}; git pull; popd;&quot;
::: */</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/TheWizardTower/seneschal
(Last checked: 2022&minus;06)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> async <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
x x x x x x x <br>
&minus; x x x x x <br>
x O2 O3 O4 O5 O6 &minus; x x O10 <br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus; <br>
S1 S2</p>

<p style="margin-left:11%; margin-top: 1em"><b>async</b>
works like <b>sem</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> async</i></p>

<p style="margin-left:11%; margin-top: 1em">1$
S=&quot;/tmp/example_socket&quot; <br>
async &minus;s=&quot;$S&quot; server &minus;&minus;start
<br>
for i in {1..20}; do <br>
# prints command output to stdout <br>
async &minus;s=&quot;$S&quot; cmd &minus;&minus; bash
&minus;c &quot;sleep 1 &amp;&amp; echo test $i&quot; <br>
done <br>
# wait until all commands are finished <br>
async &minus;s=&quot;$S&quot; wait <br>
1$ S=&quot;example_id&quot; <br>
# server not needed <br>
for i in {1..20}; do <br>
# prints command output to stdout <br>
sem &minus;&minus;bg &minus;&minus;id &quot;$S&quot;
&minus;j100% &quot;sleep 1 &amp;&amp; echo test $i&quot;
<br>
done <br>
# wait until all commands are finished <br>
sem &minus;&minus;fg &minus;&minus;id &quot;$S&quot;
&minus;&minus;wait <br>
2$ # configure the server to run four commands in parallel
<br>
async &minus;s=&quot;$S&quot; server &minus;j4 <br>
mkdir &quot;/tmp/ex_dir&quot; <br>
for i in {21..40}; do <br>
# redirects command output to /tmp/ex_dir/file* <br>
async &minus;s=&quot;$S&quot; cmd &minus;o
&quot;/tmp/ex_dir/file$i&quot; &minus;&minus; \ <br>
bash &minus;c &quot;sleep 1 &amp;&amp; echo test $i&quot;
<br>
done <br>
async &minus;s=&quot;$S&quot; wait <br>
# stops server <br>
async &minus;s=&quot;$S&quot; server &minus;&minus;stop <br>
2$ # starting server not needed <br>
mkdir &quot;/tmp/ex_dir&quot; <br>
for i in {21..40}; do <br>
# redirects command output to /tmp/ex_dir/file* <br>
sem &minus;&minus;bg &minus;&minus;id &quot;$S&quot;
&minus;&minus;results &quot;/tmp/ex_dir/file$i{}&quot; \
<br>
&quot;sleep 1 &amp;&amp; echo test $i&quot; <br>
done <br>
sem &minus;&minus;fg &minus;&minus;id &quot;$S&quot;
&minus;&minus;wait <br>
# there is no server to stop</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/ctbur/async
(Last checked: 2023&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> tandem <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
&minus; &minus; &minus; I4 &minus; &minus; N/A <br>
M1 &minus; &minus; &minus; &minus; M6 <br>
&minus; &minus; O3 &minus; &minus; &minus; &minus; N/A
&minus; &minus; <br>
E1 &minus; E3 &minus; E5 &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>tandem</b> runs full
commands in parallel. It is made for starting a
&quot;server&quot;, running a job against the server, and
when the job is done, the server is killed.</p>

<p style="margin-left:11%; margin-top: 1em">More generally:
it kills all jobs when the first job completes &minus;
similar to &rsquo;&minus;&minus;halt now,done=1&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>tandem</b>
silently discards some output. It is unclear exactly when
this happens. It looks like a race condition, because it
varies for each run.</p>

<p style="margin-left:11%; margin-top: 1em">$ tandem
&quot;seq 10000&quot; | wc &minus;l <br>
6731 &lt;&minus; This should always be 10002</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> Demo</i></p>

<p style="margin-left:11%; margin-top: 1em">tandem \ <br>
'php &minus;S localhost:8000' \ <br>
'esbuild src/*.ts &minus;&minus;bundle
&minus;&minus;outdir=dist &minus;&minus;watch' \ <br>
'tailwind &minus;i src/index.css &minus;o dist/index.css
&minus;&minus;watch' <br>
# Emulate tandem's behaviour <br>
PARALLEL='&minus;&minus;color &minus;&minus;lb
&minus;&minus;halt now,done=1 &minus;&minus;tagstring ' <br>
PARALLEL=&quot;$PARALLEL'&quot;'{=s/ .*//;
$_.=&quot;.&quot;.$app{$_}++;=}'&quot;'&quot; <br>
export PARALLEL <br>
parallel ::: \ <br>
'php &minus;S localhost:8000' \ <br>
'esbuild src/*.ts &minus;&minus;bundle
&minus;&minus;outdir=dist &minus;&minus;watch' \ <br>
'tailwind &minus;i src/index.css &minus;o dist/index.css
&minus;&minus;watch'</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> tandem &minus;h</i></p>

<p style="margin-left:11%; margin-top: 1em"># Emulate
tandem's behaviour <br>
PARALLEL='&minus;&minus;color &minus;&minus;lb
&minus;&minus;halt now,done=1 &minus;&minus;tagstring ' <br>
PARALLEL=&quot;$PARALLEL'&quot;'{=s/ .*//;
$_.=&quot;.&quot;.$app{$_}++;=}'&quot;'&quot; <br>
export PARALLEL <br>
1$ tandem 'sleep 5 &amp;&amp; echo &quot;hello&quot;' 'sleep
2 &amp;&amp; echo &quot;world&quot;' <br>
1$ parallel ::: 'sleep 5 &amp;&amp; echo &quot;hello&quot;'
'sleep 2 &amp;&amp; echo &quot;world&quot;' <br>
# '&minus;t 0' fails. But '&minus;&minus;timeout 0 works'
<br>
2$ tandem &minus;&minus;timeout 0 'sleep 5 &amp;&amp; echo
&quot;hello&quot;' \ <br>
'sleep 2 &amp;&amp; echo &quot;world&quot;' <br>
2$ parallel &minus;&minus;timeout 0 ::: 'sleep 5 &amp;&amp;
echo &quot;hello&quot;' \ <br>
'sleep 2 &amp;&amp; echo &quot;world&quot;'</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> tandem&rsquo;s readme.md</i></p>

<p style="margin-left:11%; margin-top: 1em"># Emulate
tandem's behaviour <br>
PARALLEL='&minus;&minus;color &minus;&minus;lb
&minus;&minus;halt now,done=1 &minus;&minus;tagstring ' <br>
PARALLEL=&quot;$PARALLEL'&quot;'{=s/ .*//;
$_.=&quot;.&quot;.$app{$_}++;=}'&quot;'&quot; <br>
export PARALLEL <br>
1$ tandem 'next dev' 'nodemon &minus;&minus;quiet
./server.js' <br>
1$ parallel ::: 'next dev' 'nodemon &minus;&minus;quiet
./server.js' <br>
2$ cat package.json <br>
{ <br>
&quot;scripts&quot;: { <br>
&quot;dev:php&quot;: &quot;...&quot;, <br>
&quot;dev:js&quot;: &quot;...&quot;, <br>
&quot;dev:css&quot;: &quot;...&quot; <br>
} <br>
} <br>
tandem 'npm:dev:php' 'npm:dev:js' 'npm:dev:css' <br>
# GNU Parallel uses bash functions instead <br>
2$ cat package.sh <br>
dev:php() { ... ; } <br>
dev:js() { ... ; } <br>
dev:css() { ... ; } <br>
export &minus;f dev:php dev:js dev:css <br>
. package.sh <br>
parallel ::: dev:php dev:js dev:css <br>
3$ tandem 'npm:dev:*' <br>
3$ compgen &minus;A function | grep ^dev: | parallel</p>

<p style="margin-left:11%; margin-top: 1em">For usage in
Makefiles, include a copy of <small>GNU</small> Parallel
with your source using &lsquo;parallel
&minus;&minus;embed&lsquo;. This has the added benefit of
also working if access to the internet is down or
restricted.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/rosszurowski/tandem
(Last checked: 2023&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> rust&minus;parallel(aaronriekenberg)
<small>AND GNU</small> Parallel</b> <br>
Summary (see legend above): <br>
I1 I2 I3 &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; M6 <br>
O1 O2 O3 &minus; O5 O6 &minus; N/A &minus; O10 <br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>rust-parallel</b> has a goal
of only using Rust. It seems it is impossible to call bash
functions from the command line. You would need to put these
in a script.</p>

<p style="margin-left:11%; margin-top: 1em">Calling a
script that misses the shebang line (#! as first line)
fails.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES
FROM</small> rust-parallel&rsquo;s <small>README</small>
.md</i></p>

<p style="margin-left:11%; margin-top: 1em">$ cat
&gt;./test &lt;&lt;EOL <br>
echo hi <br>
echo there <br>
echo how <br>
echo are <br>
echo you <br>
EOL <br>
1$ cat test | rust&minus;parallel &minus;j5 <br>
1$ cat test | parallel &minus;j5 <br>
2$ cat test | rust&minus;parallel &minus;j1 <br>
2$ cat test | parallel &minus;j1 <br>
3$ head &minus;100 /usr/share/dict/words |
rust&minus;parallel md5 &minus;s <br>
3$ head &minus;100 /usr/share/dict/words | parallel md5
&minus;s <br>
4$ find . &minus;type f &minus;print0 | rust&minus;parallel
&minus;0 gzip &minus;f &minus;k <br>
4$ find . &minus;type f &minus;print0 | parallel &minus;0
gzip &minus;f &minus;k <br>
5$ head &minus;100 /usr/share/dict/words | <br>
awk '{printf &quot;md5 &minus;s %s\n&quot;, $1}' |
rust&minus;parallel <br>
5$ head &minus;100 /usr/share/dict/words | <br>
awk '{printf &quot;md5 &minus;s %s\n&quot;, $1}' | parallel
<br>
6$ head &minus;100 /usr/share/dict/words |
rust&minus;parallel md5 &minus;s | <br>
grep &minus;i abba <br>
6$ head &minus;100 /usr/share/dict/words | parallel md5
&minus;s | <br>
grep &minus;i abba</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/aaronriekenberg/rust&minus;parallel
(Last checked: 2023&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> parallelium <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
&minus; I2 &minus; &minus; &minus; &minus; &minus; <br>
M1 &minus; &minus; &minus; &minus; M6 <br>
O1 &minus; O3 &minus; &minus; &minus; &minus; N/A &minus;
&minus; <br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>parallelium</b> merges
standard output (stdout) and standard error (stderr). The
maximal output of a command is 8192 bytes. Bigger output
makes <b>parallelium</b> go into an infinite loop.</p>

<p style="margin-left:11%; margin-top: 1em">In the input
file for <b>parallelium</b> you can define a tag, so that
you can select to run only these commands. A bit like a
target in a Makefile.</p>

<p style="margin-left:11%; margin-top: 1em">Progress is
printed on standard output (stdout) prepended with
&rsquo;#&rsquo; with similar information as
<small>GNU</small> <b>parallel</b>&rsquo;s
<b>&minus;&minus;bar</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES</small></i></p>

<p style="margin-left:11%; margin-top: 1em">$ cat
testjobs.txt <br>
#tag common sleeps classA <br>
(sleep 4.495;echo &quot;job 000&quot;) <br>
: <br>
(sleep 2.587;echo &quot;job 016&quot;) <br>
#tag common sleeps classB <br>
(sleep 0.218;echo &quot;job 017&quot;) <br>
: <br>
(sleep 2.269;echo &quot;job 040&quot;) <br>
#tag common sleeps classC <br>
(sleep 2.586;echo &quot;job 041&quot;) <br>
: <br>
(sleep 1.626;echo &quot;job 099&quot;) <br>
#tag lasthalf, sleeps, classB <br>
(sleep 1.540;echo &quot;job 100&quot;) <br>
: <br>
(sleep 2.001;echo &quot;job 199&quot;) <br>
1$ parallelium &minus;f testjobs.txt &minus;l logdir
&minus;t classB,classC <br>
1$ cat testjobs.txt | <br>
parallel &minus;&minus;plus &minus;&minus;results
logdir/testjobs.txt_{0#}.output \ <br>
'{= if(/^#tag /) { @tag = split/,|\s+/ } <br>
(grep /^(classB|classC)$/, @tag) or skip =}'</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/beomagi/parallelium
(Last checked: 2023&minus;01)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> forkrun <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): <br>
I1 &minus; &minus; &minus; &minus; &minus; I7 <br>
&minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; O2 O3 &minus; O5 &minus; &minus; &minus; &minus; O10
<br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>forkrun</b> blocks if it
receives fewer jobs than slots:</p>

<p style="margin-left:11%; margin-top: 1em">echo | forkrun
&minus;p 2 echo</p>

<p style="margin-left:11%; margin-top: 1em">or when it gets
some specific commands e.g.:</p>

<p style="margin-left:11%; margin-top: 1em">f() { seq
&quot;$@&quot; | pv &minus;qL 3; } <br>
seq 10 | forkrun f</p>

<p style="margin-left:11%; margin-top: 1em">It is not clear
why.</p>

<p style="margin-left:11%; margin-top: 1em">It is faster
than <small>GNU</small> <b>parallel</b> (overhead: 1.2
ms/job vs 3 ms/job), but way slower than
<b>parallel-bash</b> (0.059 ms/job).</p>

<p style="margin-left:11%; margin-top: 1em">Running jobs
cannot be stopped by pressing CTRL-C.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;k</b>
is supposed to keep the order but fails on the
<small>MIX</small> testing example below. If used with
<b>&minus;k</b> it caches output in <small>RAM.</small></p>

<p style="margin-left:11%; margin-top: 1em">If
<b>forkrun</b> is killed, it leaves temporary files in
<b>/tmp/.forkrun.*</b> that has to be cleaned up
manually.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES</small></i></p>

<p style="margin-left:11%; margin-top: 1em">1$ time find ./
&minus;type f | <br>
forkrun &minus;l512 &minus;&minus; sha256sum 2&gt;/dev/null
| wc &minus;l <br>
1$ time find ./ &minus;type f | <br>
parallel &minus;j28 &minus;m &minus;&minus; sha256sum
2&gt;/dev/null | wc &minus;l <br>
2$ time find ./ &minus;type f | <br>
forkrun &minus;l512 &minus;k &minus;&minus; sha256sum
2&gt;/dev/null | wc &minus;l <br>
2$ time find ./ &minus;type f | <br>
parallel &minus;j28 &minus;k &minus;m &minus;&minus;
sha256sum 2&gt;/dev/null | wc &minus;l</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/jkool702/forkrun
(Last checked: 2023&minus;02)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> parallel-sh <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
I1 I2 &minus; I4 &minus; &minus; &minus; <br>
M1 &minus; &minus; &minus; &minus; M6 <br>
O1 O2 O3 &minus; O5 O6 &minus; &minus; &minus; O10 <br>
E1 &minus; &minus; E4 &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>parallel-sh</b> buffers in
<small>RAM.</small> The buffering data takes O(n^1.5)
time:</p>

<p style="margin-left:11%; margin-top: 1em">2MB=0.107s
4MB=0.175s 8MB=0.342s 16MB=0.766s 32MB=2.2s 64MB=6.7s
128MB=20s 256MB=64s 512MB=248s 1024MB=998s 2048MB=3756s</p>

<p style="margin-left:11%; margin-top: 1em">It limits the
practical usability to jobs outputting &lt; 256 <small>MB.
GNU</small> <b>parallel</b> buffers on disk, yet is faster
for jobs with outputs &gt; 16 <small>MB</small> and is only
limited by the free space in $TMPDIR.</p>


<p style="margin-left:11%; margin-top: 1em"><b>parallel-sh</b>
can kill running jobs if a job fails (Similar to
<b>&minus;&minus;halt now,fail=1</b>).</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>EXAMPLES</small></i></p>

<p style="margin-left:11%; margin-top: 1em">1$
parallel&minus;sh &quot;sleep 2 &amp;&amp; echo first&quot;
&quot;sleep 1 &amp;&amp; echo second&quot; <br>
1$ parallel ::: &quot;sleep 2 &amp;&amp; echo first&quot;
&quot;sleep 1 &amp;&amp; echo second&quot; <br>
2$ cat /tmp/commands <br>
sleep 2 &amp;&amp; echo first <br>
sleep 1 &amp;&amp; echo second <br>
2$ parallel&minus;sh &minus;f /tmp/commands <br>
2$ parallel &minus;a /tmp/commands <br>
3$ echo &minus;e 'sleep 2 &amp;&amp; echo first\nsleep 1
&amp;&amp; echo second' | <br>
parallel&minus;sh <br>
3$ echo &minus;e 'sleep 2 &amp;&amp; echo first\nsleep 1
&amp;&amp; echo second' | <br>
parallel</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/thyrc/parallel&minus;sh
(Last checked: 2023&minus;04)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> bash-parallel <small>AND GNU</small>
Parallel</b> <br>
Summary (see legend above): <br>
&minus; I2 &minus; &minus; &minus; &minus; I7 <br>
M1 &minus; M3 &minus; M5 M6 <br>
&minus; O2 O3 &minus; &minus; O6 &minus; O8 &minus; O10 <br>
E1 &minus; &minus; &minus; &minus; &minus; &minus; <br>
&minus; &minus; &minus; &minus; &minus; &minus; &minus;
&minus; &minus;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&minus; &minus;</p></td>
<td width="85%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>bash-parallel</b> is not as
much a command as it is a shell script that you have to
alter. It requires you to change the shell function
process_job that runs the job, and set $MAX_POOL_SIZE to the
number of jobs to run in parallel.</p>

<p style="margin-left:11%; margin-top: 1em">It is half as
fast as <small>GNU</small> <b>parallel</b> for short
jobs.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/thilinaba/bash&minus;parallel
(Last checked: 2023&minus;05)</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DIFFERENCES
BETWEEN</small> PaSH <small>AND GNU</small> Parallel</b>
<br>
Summary (see legend above): N/A</p>

<p style="margin-left:11%; margin-top: 1em"><b>pash</b> is
quite different from <small>GNU</small> <b>parallel</b>. It
is not a general parallelizer. It takes a shell script and
analyses it and parallelizes parts of it by replacing the
parts with commands that will give the same result.</p>

<p style="margin-left:11%; margin-top: 1em">This will
replace <b>sort</b> with a command that does pretty much the
same as <b>parsort &minus;&minus;parallel=8</b> (except
somewhat slower):</p>

<p style="margin-left:11%; margin-top: 1em">pa.sh
&minus;&minus;width 8 &minus;c 'cat bigfile | sort'</p>

<p style="margin-left:11%; margin-top: 1em">However, even a
simple change will confuse <b>pash</b> and you will get no
parallelization:</p>

<p style="margin-left:11%; margin-top: 1em">pa.sh
&minus;&minus;width 8 &minus;c 'mysort() { sort; }; cat
bigfile | mysort' <br>
pa.sh &minus;&minus;width 8 &minus;c 'cat bigfile | sort |
md5sum'</p>

<p style="margin-left:11%; margin-top: 1em">From the source
it seems <b>pash</b> only looks at: awk cat col comm cut
diff grep head mkfifo mv rm sed seq sort tail tee tr uniq wc
xargs</p>

<p style="margin-left:11%; margin-top: 1em">For pipelines
where these commands are bottlenecks, it might be worth
testing if <b>pash</b> is faster than <small>GNU</small>
<b>parallel</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>pash</b>
does not respect $TMPDIR but always uses /tmp. If
<b>pash</b> dies unexpectantly it does not clean up.</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/binpash/pash
(Last checked: 2023&minus;05)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Todo</b>
<br>
https://www.npmjs.com/package/concurrently</p>


<p style="margin-left:11%; margin-top: 1em">http://code.google.com/p/push/
(cannot compile)</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/krashanoff/parallel</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/Nukesor/pueue</p>


<p style="margin-left:11%; margin-top: 1em">https://arxiv.org/pdf/2012.15443.pdf
KumQuat</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/JeiKeiLim/simple_distribute_job</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/reggi/pkgrun
&minus; not obvious how to use</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/benoror/better&minus;npm&minus;run
&minus; not obvious how to use</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/bahmutov/with&minus;package</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/flesler/parallel</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/Julian/Verge</p>


<p style="margin-left:11%; margin-top: 1em">https://manpages.ubuntu.com/manpages/xenial/man1/tsp.1.html</p>


<p style="margin-left:11%; margin-top: 1em">https://vicerveza.homeunix.net/~viric/soft/ts/</p>


<p style="margin-left:11%; margin-top: 1em">https://github.com/chapmanjacobd/que</p>

<h2>TESTING OTHER TOOLS
<a name="TESTING OTHER TOOLS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are
certain issues that are very common on parallelizing tools.
Here are a few stress tests. Be warned: If the tool is badly
coded it may overload your machine.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MIX:</small>
Output mixes</b> <br>
Output from 2 jobs should not mix. If the output is not
used, this does not matter; but if the output <i>is</i> used
then it is important that you do not get half a line from
one job followed by half a line from another job.</p>

<p style="margin-left:11%; margin-top: 1em">If the tool
does not buffer, output will most likely mix now and
then.</p>

<p style="margin-left:11%; margin-top: 1em">This test
stresses whether output mixes.</p>

<p style="margin-left:11%; margin-top: 1em">#!/bin/bash
<br>
paralleltool=&quot;parallel &minus;j0&quot; <br>
cat &lt;&lt;&minus;EOF &gt; mycommand <br>
#!/bin/bash <br>
# If a, b, c, d, e, and f mix: Very bad <br>
perl &minus;e 'print STDOUT &quot;a&quot;x3000_000,&quot;
&quot;' <br>
perl &minus;e 'print STDERR &quot;b&quot;x3000_000,&quot;
&quot;' <br>
perl &minus;e 'print STDOUT &quot;c&quot;x3000_000,&quot;
&quot;' <br>
perl &minus;e 'print STDERR &quot;d&quot;x3000_000,&quot;
&quot;' <br>
perl &minus;e 'print STDOUT &quot;e&quot;x3000_000,&quot;
&quot;' <br>
perl &minus;e 'print STDERR &quot;f&quot;x3000_000,&quot;
&quot;' <br>
echo <br>
echo &gt;&amp;2 <br>
EOF <br>
chmod +x mycommand <br>
# Run 30 jobs in parallel <br>
seq 30 | <br>
$paralleltool ./mycommand &gt; &gt;(tr &minus;s abcdef)
2&gt; &gt;(tr &minus;s abcdef &gt;&amp;2) <br>
# 'a c e' and 'b d f' should always stay together <br>
# and there should only be a single line per job</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>STDERRMERGE:</small>
Stderr is merged with stdout</b> <br>
Output from stdout and stderr should not be merged, but kept
separated.</p>

<p style="margin-left:11%; margin-top: 1em">This test shows
whether stdout is mixed with stderr.</p>

<p style="margin-left:11%; margin-top: 1em">#!/bin/bash
<br>
paralleltool=&quot;parallel &minus;j0&quot; <br>
cat &lt;&lt;&minus;EOF &gt; mycommand <br>
#!/bin/bash <br>
echo stdout <br>
echo stderr &gt;&amp;2 <br>
echo stdout <br>
echo stderr &gt;&amp;2 <br>
EOF <br>
chmod +x mycommand <br>
# Run one job <br>
echo | <br>
$paralleltool ./mycommand &gt; stdout 2&gt; stderr <br>
cat stdout <br>
cat stderr</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>RAM:</small>
Output limited by <small>RAM</small></b> <br>
Some tools cache output in <small>RAM.</small> This makes
them extremely slow if the output is bigger than physical
memory and crash if the output is bigger than the virtual
memory.</p>

<p style="margin-left:11%; margin-top: 1em">#!/bin/bash
<br>
paralleltool=&quot;parallel &minus;j0&quot; <br>
cat &lt;&lt;'EOF' &gt; mycommand <br>
#!/bin/bash <br>
# Generate 1 GB output <br>
yes &quot;`perl &minus;e 'print
\&quot;c\&quot;x30_000'`&quot; | head &minus;c 1G <br>
EOF <br>
chmod +x mycommand <br>
# Run 20 jobs in parallel <br>
# Adjust 20 to be &gt; physical RAM and &lt; free space on
/tmp <br>
seq 20 | time $paralleltool ./mycommand | wc &minus;c</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DISKFULL:</small>
Incomplete data if /tmp runs full</b> <br>
If caching is done on disk, the disk can run full during the
run. Not all programs discover this. <small>GNU</small>
Parallel discovers it, if it stays full for at least 2
seconds.</p>

<p style="margin-left:11%; margin-top: 1em">#!/bin/bash
<br>
paralleltool=&quot;parallel &minus;j0&quot; <br>
# This should be a dir with less than 100 GB free space <br>
smalldisk=/tmp/shm/parallel <br>
TMPDIR=&quot;$smalldisk&quot; <br>
export TMPDIR <br>
max_output() { <br>
# Force worst case scenario: <br>
# Make GNU Parallel only check once per second <br>
sleep 10 <br>
# Generate 100 GB to fill $TMPDIR <br>
# Adjust if /tmp is bigger than 100 GB <br>
yes | head &minus;c 100G &gt;$TMPDIR/$$ <br>
# Generate 10 MB output that will not be buffered <br>
# due to full disk <br>
perl &minus;e 'print &quot;X&quot;x10_000_000' | head
&minus;c 10M <br>
echo This part is missing from incomplete output <br>
sleep 2 <br>
rm $TMPDIR/$$ <br>
echo Final output <br>
} <br>
export &minus;f max_output <br>
seq 10 | $paralleltool max_output | tr &minus;s X</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CLEANUP:</small>
Leaving tmp files at unexpected death</b> <br>
Some tools do not clean up tmp files if they are killed. If
the tool buffers on disk, they may not clean up, if they are
killed.</p>

<p style="margin-left:11%; margin-top: 1em">#!/bin/bash
<br>
paralleltool=parallel <br>
ls /tmp &gt;/tmp/before <br>
seq 10 | $paralleltool sleep &amp; <br>
pid=$! <br>
# Give the tool time to start up <br>
sleep 1 <br>
# Kill it without giving it a chance to cleanup <br>
kill &minus;9 $! <br>
# Should be empty: No files should be left behind <br>
diff &lt;(ls /tmp) /tmp/before</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>SPCCHAR:</small>
Dealing badly with special file names.</b> <br>
It is not uncommon for users to create files like:</p>

<p style="margin-left:11%; margin-top: 1em">My brother's
12&quot; *** record (costs $$$).jpg</p>

<p style="margin-left:11%; margin-top: 1em">Some tools
break on this.</p>

<p style="margin-left:11%; margin-top: 1em">#!/bin/bash
<br>
paralleltool=parallel <br>
touch &quot;My brother's 12\&quot; *** record (costs
\$\$\$).jpg&quot; <br>
ls My*jpg | $paralleltool ls &minus;l</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>COMPOSED:</small>
Composed commands do not work</b> <br>
Some tools require you to wrap composed commands into
<b>bash &minus;c</b>.</p>

<p style="margin-left:11%; margin-top: 1em">echo bar |
$paralleltool echo foo';' echo {}</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ONEREP:</small>
Only one replacement string allowed</b> <br>
Some tools can only insert the argument once.</p>

<p style="margin-left:11%; margin-top: 1em">echo bar |
$paralleltool echo {} foo {}</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>INPUTSIZE:</small>
Length of input should not be limited</b> <br>
Some tools limit the length of the input lines artificially
with no good reason. <small>GNU</small> <b>parallel</b> does
not:</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;e
'print &quot;foo.&quot;.&quot;x&quot;x100_000_000' |
parallel echo {.}</p>


<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel</b> limits the command to run to 128
<small>KB</small> due to <b>execve</b>(1):</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;e
'print &quot;x&quot;x131_000' | parallel echo {} | wc</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NUMWORDS:</small>
Speed depends on number of words</b> <br>
Some tools become very slow if output lines have many
words.</p>

<p style="margin-left:11%; margin-top: 1em">#!/bin/bash
<br>
paralleltool=parallel <br>
cat &lt;&lt;&minus;EOF &gt; mycommand <br>
#!/bin/bash <br>
# 10 MB of lines with 1000 words <br>
yes &quot;`seq 1000`&quot; | head &minus;c 10M <br>
EOF <br>
chmod +x mycommand <br>
# Run 30 jobs in parallel <br>
seq 30 | time $paralleltool &minus;j0 ./mycommand &gt;
/dev/null</p>

<p style="margin-left:11%; margin-top: 1em"><b>4GB: Output
with a line &gt; 4GB should be <small>OK</small></b> <br>
#!/bin/bash <br>
paralleltool=&quot;parallel &minus;j0&quot; <br>
cat &lt;&lt;&minus;EOF &gt; mycommand <br>
#!/bin/bash <br>
perl &minus;e '\$a=&quot;a&quot;x1000_000; for(1..5000) {
print \$a }' <br>
EOF <br>
chmod +x mycommand <br>
# Run 1 job <br>
seq 1 | $paralleltool ./mycommand | LC_ALL=C wc</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When using
<small>GNU</small> <b>parallel</b> for a publication please
cite:</p>

<p style="margin-left:11%; margin-top: 1em">O. Tange
(2011): <small>GNU</small> Parallel &minus; The Command-Line
Power Tool, ;login: The <small>USENIX</small> Magazine,
February 2011:42&minus;47.</p>

<p style="margin-left:11%; margin-top: 1em">This helps
funding further development; and it won&rsquo;t cost you a
cent. If you pay 10000 <small>EUR</small> you should feel
free to use <small>GNU</small> Parallel without citing.</p>

<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2007&minus;10&minus;18 Ole Tange, http://ole.tange.dk</p>

<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2008&minus;2010 Ole Tange, http://ole.tange.dk</p>

<p style="margin-left:11%; margin-top: 1em">Copyright (C)
2010&minus;2023 Ole Tange, http://ole.tange.dk and Free
Software Foundation, Inc.</p>

<p style="margin-left:11%; margin-top: 1em">Parts of the
manual concerning <b>xargs</b> compatibility is inspired by
the manual of <b>xargs</b> from <small>GNU</small> findutils
4.4.2.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the terms of the <small>GNU</small> General Public
License as published by the Free Software Foundation; either
version 3 of the License, or at your option any later
version.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
distributed in the hope that it will be useful, but
<small>WITHOUT ANY WARRANTY</small> ; without even the
implied warranty of <small>MERCHANTABILITY</small> or
<small>FITNESS FOR A PARTICULAR PURPOSE.</small> See the
<small>GNU</small> General Public License for more
details.</p>

<p style="margin-left:11%; margin-top: 1em">You should have
received a copy of the <small>GNU</small> General Public
License along with this program. If not, see
&lt;https://www.gnu.org/licenses/&gt;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Documentation
license I</b> <br>
Permission is granted to copy, distribute and/or modify this
documentation under the terms of the <small>GNU</small> Free
Documentation License, Version 1.3 or any later version
published by the Free Software Foundation; with no Invariant
Sections, with no Front-Cover Texts, and with no Back-Cover
Texts. A copy of the license is included in the file
<small>LICENSES/GFDL&minus;1</small>
.3&minus;or&minus;later.txt.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Documentation
license <small>II</small></b> <br>
You are free:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em"><b>to Share</b></p></td>
<td width="2%"></td>
<td width="63%">


<p style="margin-top: 1em">to copy, distribute and transmit
the work</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p><b>to Remix</b></p></td>
<td width="2%"></td>
<td width="63%">


<p>to adapt the work</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Under the
following conditions: <b><br>
Attribution</b></p>

<p style="margin-left:25%;">You must attribute the work in
the manner specified by the author or licensor (but not in
any way that suggests that they endorse you or your use of
the work).</p>

<p style="margin-left:11%;"><b>Share Alike</b></p>

<p style="margin-left:25%;">If you alter, transform, or
build upon this work, you may distribute the resulting work
only under the same, similar or a compatible license.</p>

<p style="margin-left:11%; margin-top: 1em">With the
understanding that:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>Waiver</b></p></td>
<td width="5%"></td>
<td width="75%">


<p>Any of the above conditions can be waived if you get
permission from the copyright holder.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>Public Domain</b></p>

<p style="margin-left:25%;">Where the work or any of its
elements is in the public domain under applicable law, that
status is in no way affected by the license.</p>

<p style="margin-left:11%;"><b>Other Rights</b></p>

<p style="margin-left:25%;">In no way are any of the
following rights affected by the license:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="72%">


<p>Your fair dealing or fair use rights, or other
applicable copyright exceptions and limitations;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="72%">


<p>The author&rsquo;s moral rights;</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="72%">


<p>Rights other persons may have either in the work itself
or in how the work is used, such as publicity or privacy
rights.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="15%">


<p><b>Notice</b></p></td>
<td width="2%"></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:25%; margin-top: 1em">For any reuse
or distribution, you must make clear to others the license
terms of this work.</p>

<p style="margin-left:11%; margin-top: 1em">A copy of the
full license is included in the file as
<small>LICENCES/CC&minus;BY&minus;SA&minus;4.0</small>
.txt</p>

<h2>DEPENDENCIES
<a name="DEPENDENCIES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>GNU</small>
<b>parallel</b> uses Perl, and the Perl modules
Getopt::Long, IPC::Open3, Symbol, IO::File,
<small>POSIX,</small> and File::Temp. For remote usage it
also uses rsync with ssh.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>find</b>(1),
<b>xargs</b>(1), <b>make</b>(1), <b>pexec</b>(1),
<b>ppss</b>(1), <b>xjobs</b>(1), <b>prll</b>(1),
<b>dxargs</b>(1), <b>mdm</b>(1)</p>
<hr>
</body>
</html>
