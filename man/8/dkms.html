<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:57:05 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DKMS</title>

</head>
<body>
<h1>dkms</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">dkms &minus;
Dynamic Kernel Module Support</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>dkms</b></p></td>
<td width="1%"></td>
<td width="82%">


<p style="margin-top: 1em">[<b>action</b>] [<b>options</b>]
[<b>module/module-version</b>] [<b>/path/to/source-tree</b>]
[<b>/path/to/tarball.tar</b>]
[<b>/path/to/driver.rpm</b>]</p> </td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>dkms</b> is
a framework which allows kernel modules to be dynamically
built for each kernel on your system in a simplified and
organized fashion.</p>

<h2>ACTIONS
<a name="ACTIONS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>add</b></p></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">[<b>module/module&minus;version
| /path/to/source&minus;tree | /path/to/tarball.tar</b>]</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">
</td>
<td width="2%"></td>
<td width="83%">


<p>Adds a module/module&minus;version combination to the
tree for builds and installs. If
<i>module/module&minus;version</i>, <i>&minus;m
module/module&minus;version</i>, or <i>&minus;m
module&nbsp;&minus;v module&minus;version</i> are passed as
options, this command requires source in
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/</i>
as well as a properly formatted <i>dkms.conf</i> file. If
<i>/path/to/source&minus;tree</i> is passed as an option,
and source-tree contains a <i>dkms.conf</i> file, it will
copy <i>/path/to/source&minus;tree</i> to
<i>/usr/src/module&minus;module&minus;version</i>. If
<i>/path/to/tarball.tar</i> is passed, this command behaves
like the <b>ldtarball</b> command.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>remove</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]
[<b>&minus;&minus;all</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Removes a module/version or module/version/kernel/arch
combination from the tree. If the module is currently
installed, it first uninstalls it and if applicable, will
replace it with its original_module. Use the
<b>&minus;&minus;all</b> option in order to remove all
instances for every kernel at once.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>build</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>] [<b>--force</b>]</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Builds the specified module/version combo for the
specified kernel/arch. If the <i>&minus;k</i> option is not
specified it builds for the currently running kernel and
arch. All builds occur in the directory
<i>/var/lib/dkms/&lt;module&gt;/&lt;module&minus;version&gt;/build/.</i>
If the module/module&minus;version combo has not been added,
dkms will try to add it, and in that case <b>build</b> can
take the same arguments that <b>add</b> can. If the module
is already built, it will not be rebuilt again by default,
and the <b>--force</b> option should be used to override
this.</p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>unbuild</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]
[<b>&minus;&minus;all</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Undoes the build for a module/version or
module/version/kernel/arch combination from the tree. If the
module is currently installed, it first uninstalls it and if
applicable, will replace it with its original_module.
Finally all binary kernel modules are removed. Use the
<b>&minus;&minus;all</b> option in order to remove all
instances for every kernel at once.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>install</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>] [<b>--force</b>]
[<b>/path/to/driver.rpm</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Installs a built module/version combo onto the kernel it
was built for. If the kernel option is not specified it
assumes the currently running kernel. If the module has not
been built, dkms will try to build it. If the module has not
been added, dkms will try to add it. In both cases, the
<b>install</b> command can then take the same arguments as
the <b>build</b> or <b>add</b> commands. If the module is
already installed, it will not be reinstalled again by
default, and the <b>--force</b> option should be used to
override this. If you pass a .rpm file, dkms will try to
install that file with <b>rpm -Uvh</b>, and it will perform
an <b>autoinstall</b> action to be sure that everything is
built for your kernel if the RPM installed successfully.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>uninstall</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]
[<b>&minus;&minus;all</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Uninstalls an installed module/module&minus;version
combo from the kernel/arch passed in the -k option, or the
current kernel if the -k option was not passed. Use the
<b>&minus;&minus;all</b> option in order to uninstall all
instances for every kernel at once. After uninstall
completion, the driver will be left in the built state. To
completely remove a driver, the remove action should be
utilized.</p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>match</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>--templatekernel&nbsp;</b><i>kernel/arch</i>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Match installs modules onto the specified kernel by
looking at the configuration of the specified
<b>templatekernel.</b> Every module that is installed on the
<b>templatekernel</b> within <b>dkms</b> is then installed
on that specified kernel.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>mktarball</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]
[<b>--archive&nbsp;</b><i>/path/to/tarball.tar</i>]
[<b>--source-only</b>] [<b>--binaries-only</b>]</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Creates a tarball archive for the specified
module/version of all files in the DKMS tree for that
module/version combination. This includes the source and any
built modules for kernels in the tree (as specified).
Otherwise, you can specify a singular kernel to archive
only, or multiple kernels to archive (&minus;k kernel1/arch1
&minus;k kernel2/arch2). Optionally, you can use
<b>&minus;&minus;archive</b> to specify the file that you
would like to save this tarball to. You can also specify
<b>&minus;&minus;binaries&minus;only</b> if you want the
resultant tarball not to include the module source.
Likewise, <b>&minus;&minus;source-only</b> can be used to
specify that no prebuilt binaries should be included in the
tarball. In general, <b>mktarball</b> is great for systems
management purposes as you can build your driver on just one
system and then use <b>ldtarball</b> on all of your other
systems to get the same built modules loaded without having
to wait for anything to compile.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>ldtarball</b></p><td width="17%"></td>
<td width="83%">


<p style="margin-top: 1em">[<b>/path/to/tarball.tar</b>]
[<b>--force</b>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>This takes a tarball made from the <b>mktarball</b>
command and loads it into your DKMS tree. This will leave
any newly added modules in the built state and <b>dkms
install</b> should then be called to install any of them. If
files already exist where <b>ldtarball</b> is attempting to
place them, it will warn and not copy over them. The
<b>&minus;&minus;force</b> option should be used to override
this.</p> </td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>status</b></p><td width="17%"></td>
<td width="83%">



<p style="margin-top: 1em">[<b>module/module&minus;version</b>]
[<b>-k&nbsp;</b><i>kernel/arch</i>]</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Returns the current status of modules, versions and
kernels within the tree as well as whether they have been
added, built or installed. Status can be shown for just a
certain module, a certain kernel, a module/version
combination or a module/version/kernel combination.</p></td></tr>
</table>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p style="margin-top: 1em"><b>autoinstall</b></p><td width="17%"></td>
<td width="83%">
</td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>Attempt to install the latest revision of all modules
that have been installed for other kernel revisions.
dkms_autoinstaller is a stub that uses this action to
perform its work.</p></td></tr>
</table>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;m
&lt;module&gt;/&lt;module&minus;version&gt;</b></p>

<p style="margin-left:22%;">The name of the module and
module version you want to operate on. The <b>&minus;m</b>
part of this option is optional, and can be omitted in
virtually all circumstances.</p>

<p style="margin-left:11%;"><b>&minus;v
&lt;module&minus;version&gt;</b></p>

<p style="margin-left:22%;">The version of the module to
execute the specified action upon. This option only has to
be specified if you pass a <b>&minus;m</b> option without a
&lt;module&minus;version&gt; component of its own.</p>

<p style="margin-left:11%;"><b>&minus;k
&lt;kernel&minus;version&gt;/&lt;arch&gt;</b></p>

<p style="margin-left:22%;">The kernel and arch to perform
the action upon. You can specify multiple kernel
version/arch pairs on the command line by repeating the
&minus;k argument with a different kernel version and arch.
However, not all actions support multiple kernel versions
(it will error out in this case). The arch part can be
omitted, and DKMS will assume you want it to be the arch of
the currently running system.</p>

<p style="margin-left:11%;"><b>&minus;a,
&minus;&minus;arch</b></p>

<p style="margin-left:22%;">The system architecture to
perform the action upon. It is optional if you pass it as
part of the <b>&minus;k</b> option. If not specified, it
assumes the arch of the currently running system
(&lsquo;uname &minus;m&lsquo;). You can specify multiple
arch parameters on the same command line by repeating the
&minus;a argument with a different arch name. When multiple
architectures are specified, there must be a 1:1
relationship between &minus;k arguments to &minus;a
arguments. DKMS will then assume the first &minus;a argument
aligns with the first &minus;k kernel and so on for the
second, third, etc.</p>

<p style="margin-left:22%; margin-top: 1em">For example, if
you were to specify: &minus;k kernel1 &minus;k kernel2
&minus;a i386 &minus;k kernel3 &minus;a i686 &minus;a
x86_64, DKMS would process this as: kernel1-i386,
kernel2-i686, kernel3-x86_64.</p>

<p style="margin-left:11%;"><b>&minus;q,
&minus;&minus;quiet</b></p>

<p style="margin-left:22%;">Quiet.</p>

<p style="margin-left:11%;"><b>&minus;V,
&minus;&minus;version</b></p>

<p style="margin-left:22%;">Prints the currently installed
version of dkms and exits.</p>

<p style="margin-left:11%;"><b>&minus;c
&lt;dkms.conf&minus;location&gt;</b></p>

<p style="margin-left:22%;">The location of the
<i>dkms.conf</i> file. This is needed for the add action and
if not specified, it is assumed to be located in
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/.</i>
See below for more information on the format of
<i>dkms.conf.</i></p>

<p style="margin-left:11%;"><b>&minus;&minus;config
&lt;kernel&minus;.config&minus;location&gt;</b></p>

<p style="margin-left:22%;">During a <b>build</b> this
option is used to specify an alternate location for the
kernel .config file which was used to compile that kernel.
Normally, <b>dkms</b> uses the Red Hat standard location and
config filenames located in
<i>/usr/src/linux&minus;&lt;kernel&gt;/configs/.</i> If the
config for the kernel that you are building a module for is
not located here or does not have the expected name in this
location, you will need to tell <b>dkms</b> where the
necessary .config can be found so that your kernel can be
properly prepared for the module build.</p>

<p style="margin-left:11%;"><b>&minus;&minus;archive
&lt;tarball&minus;location&gt;</b></p>

<p style="margin-left:22%;">This option is used during a
<b>ldtarball</b> action to specify the location of the
tarball you wish to load into your DKMS tree. You only have
to specify the <b>--archive</b> part of this option if
&lt;tarball&minus;location&gt; does not already exist as a
file.</p>


<p style="margin-left:11%;"><b>&minus;&minus;templatekernel
&lt;kernel&minus;version&gt;</b></p>

<p style="margin-left:22%;">This option is required for the
action: <b>match.</b> Match will look at the templatekernel
specified and install all of the same module/version
combinations on the other kernel.</p>

<p style="margin-left:11%;"><b>&minus;&minus;force</b></p>

<p style="margin-left:22%;">This option can be used in
conjunction with <b>ldtarball</b> to force copying over of
extant files.</p>


<p style="margin-left:11%;"><b>&minus;&minus;binaries&minus;only</b></p>

<p style="margin-left:22%;">This option can be used in
conjunction with <b>mktarball</b> in order to create a DKMS
tarball which does not contain the source for the module
within it. This can be helpful in reducing the size of the
tarball if you know that the system which this tarball will
be loaded upon already has the source installed. In order to
load a tarball made as binaries-only <b>you must</b> have
the module source in that systems DKMS tree. If you do not,
DKMS <b>will refuse</b> to load a binaries-only tarball.</p>


<p style="margin-left:11%;"><b>&minus;&minus;source&minus;only</b></p>

<p style="margin-left:22%;">This option can be used in
conjunction with <b>mktarball</b> but do not want the
tarball you create to have any prebuilt modules within it,
passing this option will keep its internal DKMS tarball from
containing any prebuilt modules.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>&minus;&minus;all</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>This option can be used to automatically specify all
relevant kernels/arches for a module/module-version. This
can be used for things like remove, unbuild and uninstall.
This saves the trouble of having to actually specify
&minus;k kernel1 &minus;a arch1 &minus;k kernel2 &minus;a
arch2 for every kernel you have built your module for.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>&minus;&minus;no&minus;depmod</b></p>

<p style="margin-left:22%;">This option prevents DKMS from
running the depmod command during <b>install</b> and
<b>uninstall</b> which will avoid (re)calculating module
dependencies and thereby save time.</p>


<p style="margin-left:11%;"><b>&minus;&minus;modprobe&minus;on&minus;install</b></p>

<p style="margin-left:22%;">This option executes modprobe
on the modules upon successful installation.</p>


<p style="margin-left:11%;"><b>&minus;&minus;kernelsourcedir
&lt;kernel&minus;source&minus;directory&minus;location&gt;</b></p>

<p style="margin-left:22%;">Using this option you can
specify the location of your kernel source directory. Most
likely you will not need to set this if your kernel source
is accessible via
<i>/usr/lib/modules/$kernel_version/build.</i></p>

<p style="margin-left:11%;"><b>&minus;&minus;directive
&lt;&quot;cli&minus;directive=cli&minus;value&quot;&gt;</b></p>

<p style="margin-left:22%;">Using this option, you can
specify additional directives from the command line. The
<b>&minus;&minus;directive</b> option can be used multiple
times on the same command-line to specify multiple
additional command line directives.</p>


<p style="margin-left:11%;"><b>&minus;&minus;rpm_safe_upgrade</b></p>

<p style="margin-left:22%;">This flag should be used when
packaging DKMS enabled modules in RPMs. It should be
specified during both the <b>add</b> and <b>remove</b>
actions in the RPM spec to ensure that DKMS and RPM behave
correctly in all scenarios when upgrading between various
versions of a dkms enabled module RPM package.</p>

<p style="margin-left:11%;"><b>&minus;&minus;dkmstree
path/to/place</b></p>

<p style="margin-left:22%;">Provides a destination tree for
building and installing modules to. Useful in cases that you
don&rsquo;t want to contaminate a system when using solely
for building.</p>

<p style="margin-left:11%;"><b>&minus;&minus;sourcetree
path/to/place</b></p>

<p style="margin-left:22%;">Provides a location to build a
DKMS package from. Useful for systems that you may not have
root access, but would still like to be able to build DKMS
packages.</p>

<p style="margin-left:11%;"><b>&minus;&minus;installtree
path/to/place</b></p>

<p style="margin-left:22%;">Provides a location to place
modules when a <i>dkms install</i> command is issued.</p>

<p style="margin-left:11%;"><b>&minus;j number</b></p>

<p style="margin-left:22%;">Run no more than <i>number</i>
jobs in parallel; see the -j option of <i>make(1).</i>
Defaults to the number of CPUs in the system, detected by
<i>nproc(1).</i> Specify 0 to impose no limit on the number
of parallel jobs.</p>

<h2>ORIGINAL MODULES
<a name="ORIGINAL MODULES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">During the
first install of a module for a &lt;kernelversion&gt;,
<b>dkms</b> will search
<i>/usr/lib/modules/&lt;kernelversion&gt;</i> for a
pre-existing module of the same name. If one is found, it
will automatically be saved as an
&quot;original_module&quot; so that if the newer module is
later removed, <b>dkms</b> will put the original module back
in its place. Currently, DKMS searches for these original
modules with first preference going to modules located in
<i>/usr/lib/modules/&lt;kernelversion&gt;/updates/</i>
followed by <b>$DEST_MODULE_LOCATION</b> (as specified in
<i>dkms.conf</i> ). If one cannot be found in either
location, a find will be used to locate one for that kernel.
If none are found, then during a later uninstall, your
kernel will not have that module replaced.</p>

<p style="margin-left:11%; margin-top: 1em">If more than
one is found, then the first one located (by preference
indicated above) will be considered the
&quot;original_module&quot;. As well, all copies of the
same-named module will be removed from your kernel tree and
placed into
<i>/var/lib/dkms/&lt;module&gt;/original_module/$kernelver/collisions</i>
so that they can be *manually* accessible later. DKMS will
never actually do anything with the modules found underneath
the /collisions directory, and they will be stored there
until you manually delete them.</p>

<h2>DKMS.CONF
<a name="DKMS.CONF"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When performing
an <b>add</b>, a proper <i>dkms.conf</i> file must be found.
A properly formatted conf file is essential for
communicating to <b>dkms</b> how and where the module should
be installed. While not all the directives are required,
providing as many as possible helps to limit any ambiguity.
Note that the <i>dkms.conf</i> is really only a
shell&minus;script of variable definitions which are then
sourced in by the <b>dkms</b> executable (of the format,
DIRECTIVE=&quot;directive text goes here&quot;). As well,
the directives are case&minus;sensitive and should be given
in <b>ALL CAPS.</b></p>

<p style="margin-left:11%; margin-top: 1em">It is important
to understand that many of the DKMS directives are arrays
whose index values are tied together. These array
associations can be considered families, and there are
currently three such families of directive arrays. MAKE[#]
and MAKE_MATCH[#] make up one family. PATCH[#] and
PATCH_MATCH[#] make up the second family. The third and
largest family consists of BUILT_MODULE_NAME[#],
BUILT_MODULE_LOCATION[#], DEST_MODULE_NAME[#],
DEST_MODULE_LOCATION[#] and STRIP[#]. When indexing these
arrays when creating your dkms.conf, each family should
start at index value 0. <b><br>
PACKAGE_NAME=</b></p>

<p style="margin-left:22%;">This directive is used to give
the name associated with the entire package of modules. This
is the same name that is used with the <b>&minus;m</b>
option when building, adding, etc. and may not necessarily
be the same as the MODULE_NAME. This directive must be
present in every dkms.conf.</p>

<p style="margin-left:11%;"><b>PACKAGE_VERSION=</b></p>

<p style="margin-left:22%;">This directive is used to give
the version associated with the entire package of modules
being installed within that dkms package. This directive
must be present in every dkms.conf.</p>


<p style="margin-left:11%;"><b>BUILT_MODULE_NAME[#]=</b></p>

<p style="margin-left:22%;">This directive gives the name
of the module just after it is built. If your DKMS module
package contains more than one module to install, this is a
<b>required</b> directive for all of the modules. This
directive should explicitly not contain any trailing
&quot;.o&quot; or &quot;.ko&quot;. Note that for each module
within a dkms package, the numeric value of <b>#</b> must be
the same for each of BUILT_MODULE_NAME,
BUILT_MODULE_LOCATION, DEST_MODULE_NAME and
DEST_MODULE_LOCATION and that the numbering should start at
0 (eg. BUILT_MODULE_NAME[0]=&quot;qla2200&quot;
BUILT_MODULE_NAME[1]=&quot;qla2300&quot;).</p>


<p style="margin-left:11%;"><b>BUILT_MODULE_LOCATION[#]=</b></p>

<p style="margin-left:22%;">This directive tells DKMS where
to find your built module after it has been built. This
pathname should be given relative to the root directory of
your source files (where your dkms.conf file can be found).
If unset, DKMS expects to find your
<b>BUILT_MODULE_NAME[#]</b> in the root directory of your
source files. Note that for each module within a dkms
package, the numeric value of <b>#</b> must be the same for
each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION,
DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the
numbering should start at 0 (eg.
BUILT_MODULE_LOCATION[0]=&quot;some/dir/&quot;
BUILT_MODULE_LOCATION[1]=&quot;other/dir/&quot;).</p>


<p style="margin-left:11%;"><b>DEST_MODULE_NAME[#]=</b></p>

<p style="margin-left:22%;">This directive can be used to
specify the name of the module as it should be installed.
This will rename the module from <b>BUILT_MODULE_NAME[#]</b>
to <b>DEST_MODULE_NAME[#].</b> This directive should
explicitly not contain any trailing &quot;.o&quot; or
&quot;.ko&quot;. If unset, it is assumed to be the same
value as <b>BUILT_MODULE_NAME[#].</b> Note that for each
module within a dkms package, the numeric value of <b>#</b>
must be the same for each of BUILT_MODULE_NAME,
BUILT_MODULE_LOCATION, DEST_MODULE_NAME and
DEST_MODULE_LOCATION and that the numbering should start at
0 (eg. DEST_MODULE_NAME[0]=&quot;qla2200_6x&quot;
DEST_MODULE_NAME[1]=&quot;qla2300_6x&quot;).</p>


<p style="margin-left:11%;"><b>DEST_MODULE_LOCATION[#]=</b></p>

<p style="margin-left:22%;">This directive specifies the
destination where a module should be installed to, once
compiled. It also is used for finding original_modules. This
is a <b>required</b> directive, except as noted below. This
directive must start with the text &quot;/kernel&quot; which
is in reference to
/usr/lib/modules/&lt;kernelversion&gt;/kernel. Note that for
each module within a dkms package, the numeric value of
<b>#</b> must be the same for each of BUILT_MODULE_NAME,
BUILT_MODULE_LOCATION, DEST_MODULE_NAME and
DEST_MODULE_LOCATION and that the numbering should start at
0 (eg.
DEST_MODULE_LOCATION[0]=&quot;/kernel/drivers/something/&quot;
DEST_MODULE_LOCATION[1]=&quot;/kernel/drivers/other/&quot;).</p>


<p style="margin-left:22%; margin-top: 1em">DEST_MODULE_LOCATION
is ignored on Fedora and Red Hat Enterprise Linux, Novell
SuSE Linux Enterprise Server 10 and higher, Novell SuSE
Linux 10.0 and higher, and Ubuntu. Instead, the proper
distribution-specific directory is used.</p>

<p style="margin-left:11%;"><b>STRIP[#]=</b></p>

<p style="margin-left:22%;">By default strip is considered
to be &quot;yes&quot;. If set to &quot;no&quot;, DKMS will
not run strip &minus;g against your built module to remove
debug symbols from it. STRIP[0] is used as the default for
any unset entries in the STRIP array.</p>

<p style="margin-left:11%;"><b>MAKE[#]=</b></p>

<p style="margin-left:22%;">The MAKE directive array tells
DKMS which make command should be used for building your
module. The default make command should be put into
<b>MAKE[0].</b> Other entries in the MAKE array will only be
used if their corresponding entry in <b>MAKE_MATCH[#]</b>
matches, as a regular expression (using grep -E), the kernel
that the module is being built for. Note that if no value is
placed in <b>MAKE_MATCH[#]</b> for any <b>MAKE[#]</b> where
# &gt; 0, then that <b>MAKE</b> directive is ignored.
<b>MAKE_MATCH[0]</b> is optional and if it is populated, it
will be used to determine if MAKE[0] should be used to build
the module for that kernel. If multiple <b>MAKE_MATCH</b>
directives match against the kernel being built for, the
last matching <b>MAKE[#]</b> will be used to build your
module. If no MAKE directive is specified or if no
MAKE_MATCH matches the kernel being built for, DKMS will
attempt to use a generic MAKE command to build your
module.</p>

<p style="margin-left:22%; margin-top: 1em">KERNELRELEASE
will be automatically appended to MAKE[#]. If you want to
suppress this behavior, you can quote the make command:
&rsquo;make&rsquo;.</p>

<p style="margin-left:11%;"><b>MAKE_MATCH[#]=</b></p>

<p style="margin-left:22%;">See the above entry on
<b>MAKE[#]</b> directives. This array should be populated
with regular expressions which, when matched against the
kernel being built for, will tell <b>DKMS</b> to use the
corresponding make command in the <b>MAKE[#]</b> directive
array to build your module.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>CLEAN=</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>CLEAN specifies the make clean command to be used to
clean up both before and after building the module. If
unset, it is assumed to be &quot;make clean&quot;.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>NO_WEAK_MODULES=</b></p>

<p style="margin-left:22%;">The <b>NO_WEAK_MODULES</b>
parameter prevents dkms from creating a symlink into the
weak-updates directory, which is the default on Red Hat
derivatives. The weak modules facility was designed to
eliminate the need to rebuild kernel modules when kernel
upgrades occur and relies on the symbols within the
kABI.</p>

<p style="margin-left:22%; margin-top: 1em">Fedora does not
guaranteed a stable kABI so it should be disabled in the
specific module override by setting it to &quot;yes&quot;.
For example, for an Nvidia DKMS module you would set the
following in /etc/dkms/nvidia.conf:</p>


<p style="margin-left:22%; margin-top: 1em">NO_WEAK_MODULES=&quot;yes&quot;</p>

<p style="margin-left:11%;"><b>OBSOLETE_BY=</b></p>

<p style="margin-left:22%;">This directive allows you to
specify a kernel version that obsoletes the necessity for
this particular DKMS module. This can be specified as a
particular upstream kernel or an ABI bump of a kernel. For
example, &quot;2.6.24&quot; would be an upstream kernel and
&quot;2.6.24&minus;16&quot; would represent an ABI bump for
a kernel. Both are valid in this area.</p>

<p style="margin-left:22%; margin-top: 1em">Please avoid
the use of <b>OBSOLETE_BY</b> wherever possible. It&rsquo;s
use indicates a lack of proper module versioning using
<b>MODULE_VERSION()</b> tags in the module source itself. It
is better to fix the <b>MODULE_VERSION()</b> tags than use
<b>OBSOLETE_BY.</b> This also introduces a implicit
distribution/version dependency on the package, as the value
of <b>OBSOLETE_BY</b> is meaningful only in the context of a
single distribution/version.</p>

<p style="margin-left:22%; margin-top: 1em">If you feel you
must use it, please use as such in dkms.conf:</p>


<p style="margin-left:22%; margin-top: 1em">ubuntu_804=&quot;Ubuntu
<br>
8.04&quot; <br>
if [ &minus;x /usr/bin/lsb_release ]; then <br>
if [ &quot;$(/usr/bin/lsb_release &minus;sir)&quot; ==
&quot;${ubuntu_804}&quot; ]; then <br>
OBSOLETE_BY=&quot;2.6.25&quot; <br>
fi <br>
fi</p>

<p style="margin-left:11%;"><b>PATCH[#]=</b></p>

<p style="margin-left:22%;">Use the PATCH directive array
to specify patches which should be applied to your source
before a build occurs. All patches are expected to be in
&minus;p1 format and are applied with the patch &minus;p1
command. Each directive should specify the filename of the
patch to apply, and all patches must be located in the
patches subdirectory of your source directory (
<i>/usr/src/&lt;module&gt;&minus;&lt;module&minus;version&gt;/patches/</i>
). If any patch fails to apply, the build will be halted and
the rejections can be inspected in
<i>/var/lib/dkms/&lt;module&gt;/&lt;module&minus;version&gt;/build/.</i>
If a PATCH should only be applied conditionally, the
<b>PATCH_MATCH[#]</b> array should be used, and a
corresponding regular expression should be placed in
<b>PATCH_MATCH[#]</b> which will alert dkms to only use that
<b>PATCH[#]</b> if the regular expression matches the kernel
which the module is currently being built for.</p>

<p style="margin-left:11%;"><b>PATCH_MATCH[#]=</b></p>

<p style="margin-left:22%;">See the above description for
<b>PATCH[#]</b> directives. If you only want a patch applied
in certain scenarios, the <b>PATCH_MATCH</b> array should be
utilized by giving a regular expression which matches the
kernels you intend the corresponding <b>PATCH[#]</b> to be
applied to before building that module.</p>

<p style="margin-left:11%;"><b>AUTOINSTALL=</b></p>

<p style="margin-left:22%;">If this directive is set to
<b>yes</b> then the service
<i>/etc/rc.d/init.d/dkms_autoinstaller</i> will
automatically try to install this module on any kernel you
boot into. See the section on <b>dkms_autoinstaller</b> for
more information.</p>

<p style="margin-left:11%;"><b>BUILD_DEPENDS[#]=</b></p>

<p style="margin-left:22%;">This optional directive is an
array that allows you to specify other modules as
dependencies for your module. Each array element should be
the <b>PACKAGE_NAME</b> of another module that is managed by
dkms. Do not specify a version or architecture in the
dependency. Note that this directive is only advisory;
missing or broken dependencies cause non-fatal warnings.</p>


<p style="margin-left:11%;"><b>BUILD_EXCLUSIVE_KERNEL=</b></p>

<p style="margin-left:22%;">This optional directive allows
you to specify a regular expression which defines the subset
of kernels which DKMS is allowed to build your module for.
If the kernel being built for does not match against this
regular expression (or does not the satisfy the constraints
of any other <b>BUILD_EXCLUSIVE_*</b> directive), the dkms
build will error out with exit code 77. Note that dkms
autoinstall will ignore this type of error condition and
simply skip the respective modules. For example, if you set
it as =&quot;^2.4.*&quot;, your module would not be built
for 2.6 or later kernels.</p>


<p style="margin-left:11%;"><b>BUILD_EXCLUSIVE_KERNEL_MIN=</b></p>

<p style="margin-left:22%;">and
<b>BUILD_EXCLUSIVE_KERNEL_MAX=</b> These optional directives
allow one to specify the minimal and maximal kernel versions
supported by the module. If one (or both) of these are
defined, the module will not be built for kernels outside
the specified version limits. For example, if you set
<b>BUILD_EXCLUSIVE_KERNEL_MIN</b> as &quot;=3.5&quot;, your
module would be built for e.g. &quot;3.5-rc2&quot;,
&quot;3.6.18&quot; or other later versions but not for
&quot;3.4.999&quot; or earlier kernels. Similarly, if you
set <b>BUILD_EXCLUSIVE_KERNEL_MAX</b> as =&quot;4.12&quot;,
your module would be built for e.g. &quot;4.11.999&quot;,
&quot;3.9-rc5&quot; or other earlier versions, but not for
&quot;4.12-rc1&quot; or later kernels.</p>


<p style="margin-left:11%;"><b>BUILD_EXCLUSIVE_ARCH=</b></p>

<p style="margin-left:22%;">This optional directive
functions very similarly to <b>BUILD_EXCLUSIVE_KERNEL</b>
except that it matches against the kernel architecture. For
example, if you set it to =&quot;i.86&quot;, your module
would not be built for ia32e, x86_64, amd64, s390, etc.</p>


<p style="margin-left:11%;"><b>BUILD_EXCLUSIVE_CONFIG=</b></p>

<p style="margin-left:22%;">This optional directive allows
you to specify a space separated list of kernel
configuration options (&quot;CONFIG_FOO&quot;) that must be
enabled in the targeted kernels &quot;.config&quot; file
(either to be compiled in or to be built as a module) or
absent (if prefixed with an exclamation mark, e.g.
&quot;!CONFIG_BAR&quot;) in order to build the module. For
example, if you set it as =&quot;CONFIG_PCI
!CONFIG_PREEMPT_RT&quot;, your module would only be built
for kernels that have PCI enabled, but the RT patchset
disabled.</p>

<p style="margin-left:11%;"><b>POST_ADD=</b></p>

<p style="margin-left:22%;">The name of the script to be
run after an <b>add</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>POST_BUILD=</b></p>

<p style="margin-left:22%;">The name of the script to be
run after a <b>build</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>POST_INSTALL=</b></p>

<p style="margin-left:22%;">The name of the script to be
run after an <b>install</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>POST_REMOVE=</b></p>

<p style="margin-left:22%;">The name of the script to be
run after a <b>remove</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>PRE_BUILD=</b></p>

<p style="margin-left:22%;">The name of the script to be
run before a <b>build</b> is performed. The path should be
given relative to the root directory of your source.</p>

<p style="margin-left:11%;"><b>PRE_INSTALL=</b></p>

<p style="margin-left:22%;">The name of the script to be
run before an <b>install</b> is performed. The path should
be given relative to the root directory of your source. If
the script exits with a non&minus;zero value, the install
will be aborted. This is typically used to perform a custom
version comparison.</p>

<h2>DKMS.CONF VARIABLES
<a name="DKMS.CONF VARIABLES"></a>
</h2>


<p style="margin-left:22%; margin-top: 1em">Within your
<i>dkms.conf</i> file, you can use certain variables which
will be replaced at run&minus;time with their values.</p>

<p style="margin-left:11%;"><b>$kernelver</b></p>

<p style="margin-left:22%;">This variable can be used
within a directive definition and during use, the actual
kernel version in question will be substituted in its place.
This is especially useful in MAKE commands when specifying
which INCLUDE statements should be used when compiling your
module (eg. MAKE=&quot;make all
INCLUDEDIR=/usr/lib/modules/${kernelver}/build/include&quot;).</p>

<p style="margin-left:11%;"><b>$kernel_source_dir</b></p>

<p style="margin-left:22%;">This variable holds the value
of the location of your kernel source directory. Usually,
this will be <i>/usr/lib/modules/$kernelver/build</i>,
unless otherwise specified with the
<b>&minus;&minus;kernelsourcedir</b> option.</p>

<h2>DKMS.CONF OVERRIDES
<a name="DKMS.CONF OVERRIDES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You can
override the module-provided <i>dkms.conf</i> files. Every
time after a dkms.conf file is read, dkms will look for and
read the following files in order:</p>


<p style="margin-left:11%; margin-top: 1em"><i>/etc/dkms/&lt;module&gt;.conf
<br>

/etc/dkms/&lt;module&gt;&minus;&lt;module&minus;version&gt;.conf
<br>

/etc/dkms/&lt;module&gt;&minus;&lt;module&minus;version&gt;&minus;&lt;kernel&gt;.conf
<br>

/etc/dkms/&lt;module&gt;&minus;&lt;module&minus;version&gt;&minus;&lt;kernel&gt;&minus;&lt;arch&gt;.conf</i></p>

<p style="margin-left:11%; margin-top: 1em">You can use
these files to override settings in the module-provided
dkms.conf files.</p>

<h2>/etc/dkms/framework.conf
<a name="/etc/dkms/framework.conf"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This
configuration file controls how the overall DKMS framework
handles. It is sourced in every time the dkms command is
run. Mainly it can currently be used to set different
default values for the variables.</p>

<p style="margin-left:11%; margin-top: 1em">The file
contains descriptions for each directive it supports.</p>

<p style="margin-left:11%; margin-top: 1em">Additionally to
/etc/dkms/framework.conf, <b>any file matching the glob</b>
/etc/dkms/framework.conf.d/*.conf will be loaded as well.
<b><br>
$dkms_tree, $source_tree, $install_tree,
$tmp_location</b></p>

<p style="margin-left:22%;">Control which folders DKMS uses
for components and artifacts.</p>

<p style="margin-left:11%;"><b>$verbose</b></p>

<p style="margin-left:22%;">Can be set to anything but a
null value to enable verbose output in DKMS.</p>

<p style="margin-left:11%;"><b>$symlink_modules</b></p>

<p style="margin-left:22%;">Controls whether binary modules
are copied to /usr/lib/modules or if only symlinks are
created there. Note that these variables can also be
manipulated on the command line with &minus;&minus;dkmstree,
&minus;&minus;sourcetree, &minus;&minus;installtree and
&minus;&minus;symlink-modules options.</p>


<p style="margin-left:11%;"><b>$autoinstall_all_kernels</b></p>

<p style="margin-left:22%;">Used by the common postinst for
DKMS modules. It controls if the build should be done for
all installed kernels or only for the current and latest
installed kernel. It has no command line equivalent.</p>

<p style="margin-left:11%;"><b>$sign_file</b></p>

<p style="margin-left:22%;">This is the path of the
<i>sign-file</i> kernel binary that is used to sign the
kernel modules. The variable <b>$kernelver</b> can be used
in path to represent the target kernel version. The path for
the binary depends on the distribution.</p>

<p style="margin-left:11%;"><b>$mok_signing_key,
$mok_certificate</b></p>

<p style="margin-left:22%;">Location of the key and
certificate files used for Secure boot. The variable
<b>$kernelver</b> can be used in path to represent the
target kernel version. <i>mok_signing_key</i> can also be a
&quot;pkcs11:...&quot; string for PKCS#11 engine, as long as
the sign_file program supports it.</p>


<p style="margin-left:11%;"><b>$modprobe_on_install</b></p>

<p style="margin-left:22%;">Automatically load the built
modules upon successful installation.</p>

<h2>dkms_autoinstaller
<a name="dkms_autoinstaller"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This
boot&minus;time service automatically installs any module
which has <b>AUTOINSTALL=&quot;yes&quot;</b> set in its
<b>dkms.conf</b> file. The service works quite simply and if
multiple versions of a module are in your system&rsquo;s
DKMS tree, it will not do anything and instead explain that
manual intervention is required.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Gary Lerhaupt,
Emil Velikov, Simone Caronni, Xu Zhen</p>

<h2>WEBPAGE
<a name="WEBPAGE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>https://github.com/dell/dkms</i></p>
<hr>
</body>
</html>
