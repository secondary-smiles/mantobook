<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:57:10 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>UDEVADM</title>

</head>
<body>
<h1>udevadm</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">udevadm &minus;
udev management tool</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm</b>
[<b>&minus;&minus;debug</b>] [<b>&minus;&minus;version</b>]
[<b>&minus;&minus;help</b>]</p> </td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm info [options]
[devpath]</b></p> </td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm trigger [options]
[devpath]</b></p> </td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm settle
[options]</b></p> </td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm control</b>
<i>option</i></p> </td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm monitor
[options]</b></p> </td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm test [options]</b>
<i>devpath</i></p> </td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm test&minus;builtin
[options]</b> <i>command devpath</i></p></td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm wait [options]</b>
<i>device|syspath</i></p> </td>
<td width="18%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="71%">


<p style="margin-top: 1em"><b>udevadm lock [options]</b>
<i>command</i></p> </td>
<td width="18%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i><b>udevadm</b></i>
expects a command and command specific options. It controls
the runtime behavior of <b>systemd&minus;udevd</b>, requests
kernel events, manages the event queue, and provides simple
debugging mechanisms.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;d</b>,
<b>&minus;&minus;debug</b></p>

<p style="margin-left:17%;">Print debug messages to
standard error. This option is implied in <b>udevadm
test</b> and <b>udevadm test&minus;builtin</b> commands.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udevadm info
[</b><i>options</i>]
[<i>devpath</i>|<i>file</i>|<i>unit</i>...] <br>
Query the udev database for device information.</p>

<p style="margin-left:11%; margin-top: 1em">Positional
arguments should be used to specify one or more devices.
Each one may be a device name (in which case it must start
with /dev/), a sys path (in which case it must start with
/sys/), or a systemd device unit name (in which case it must
end with &quot;.device&quot;, see
<b>systemd.device</b>(5)).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;q</b>,
<b>&minus;&minus;query=</b><i>TYPE</i></p>

<p style="margin-left:17%;">Query the database for the
specified type of device data. Valid <i>TYPE</i>s are:
<b>name</b>, <b>symlink</b>, <b>path</b>, <b>property</b>,
<b>all</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;property=</b><i>NAME</i></p>

<p style="margin-left:17%;">When showing device properties
using the <b>&minus;&minus;query=property</b> option, limit
display to properties specified in the argument. The
argument should be a comma&minus;separated list of property
names. If not specified, all known properties are shown.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;value</b></p>

<p style="margin-left:17%;">When showing device properties
using the <b>&minus;&minus;query=property</b> option, print
only their values, and skip the property name and
&quot;=&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Cannot be used
together with <b>&minus;x/&minus;&minus;export</b> or
<b>&minus;P/&minus;&minus;export&minus;prefix</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;p</b>,
<b>&minus;&minus;path=</b><i>DEVPATH</i></p>

<p style="margin-left:17%;">The /sys/ path of the device to
query, e.g. [/sys/]/class/block/sda. This option is an
alternative to the positional argument with a /sys/ prefix.
<b>udevadm info &minus;&minus;path=/class/block/sda</b> is
equivalent to <b>udevadm info /sys/class/block/sda</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;n</b>,
<b>&minus;&minus;name=</b><i>FILE</i></p>

<p style="margin-left:17%;">The name of the device node or
a symlink to query, e.g. [/dev/]/sda. This option is an
alternative to the positional argument with a /dev/ prefix.
<b>udevadm info &minus;&minus;name=sda</b> is equivalent to
<b>udevadm info /dev/sda</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;r</b>,
<b>&minus;&minus;root</b></p>

<p style="margin-left:17%;">Print absolute paths in
<b>name</b> or <b>symlink</b> query.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;a</b>,
<b>&minus;&minus;attribute&minus;walk</b></p>

<p style="margin-left:17%;">Print all sysfs properties of
the specified device that can be used in udev rules to match
the specified device. It prints all devices along the chain,
up to the root of sysfs that can be used in udev rules.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;tree</b></p>

<p style="margin-left:17%;">Display a sysfs tree. This
recursively iterates through the sysfs hierarchy and
displays it in a tree structure. If a path is specified only
the subtree below and its parent directories are shown. This
will show both device and subsystem items.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;x</b>,
<b>&minus;&minus;export</b></p>

<p style="margin-left:17%;">Print output as key/value
pairs. Values are enclosed in single quotes. This takes
effects only when <b>&minus;&minus;query=property</b> or
<b>&minus;&minus;device&minus;id&minus;of&minus;file=</b><i>FILE</i>
is specified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;P</b>,
<b>&minus;&minus;export&minus;prefix=</b><i>NAME</i></p>

<p style="margin-left:17%;">Add a prefix to the key name of
exported values. This implies
<b>&minus;&minus;export</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;d</b>,
<b>&minus;&minus;device&minus;id&minus;of&minus;file=</b><i>FILE</i></p>

<p style="margin-left:17%;">Print major/minor numbers of
the underlying device, where the file lives on. If this is
specified, all positional arguments are ignored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;e</b>,
<b>&minus;&minus;export&minus;db</b></p>

<p style="margin-left:17%;">Export the content of the udev
database.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;c</b>,
<b>&minus;&minus;cleanup&minus;db</b></p>

<p style="margin-left:17%;">Cleanup the udev database.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;w[SECONDS]</b>,
<b>&minus;&minus;wait&minus;for&minus;initialization[=SECONDS]</b></p>

<p style="margin-left:17%;">Wait for device to be
initialized. If argument <i>SECONDS</i> is not specified,
the default is to wait forever.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;no&minus;pager</b></p>

<p style="margin-left:17%;">Do not pipe output into a
pager.</p>

<p style="margin-left:11%; margin-top: 1em">The generated
output shows the current device database entry in a terse
format. Each line shown is prefixed with one of the
following characters:</p>


<p style="margin-left:11%; margin-top: 1em"><b>Table&nbsp;1.&nbsp;udevadm
info output prefixes</b></p></table>


<p align="center"><b><img src="grohtml-36204081.png" alt="Image grohtml-36204081.png"></b></p>

<p style="margin-left:11%;"><b>udevadm trigger
[</b><i>options</i>]
[<i>devpath</i>|<i>file</i>|<i>unit</i>] <br>
Request device events from the kernel. Primarily used to
replay events at system coldplug time.</p>

<p style="margin-left:11%; margin-top: 1em">Takes device
specifications as positional arguments. See the description
of <b>info</b> above.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;v</b>,
<b>&minus;&minus;verbose</b></p>

<p style="margin-left:17%;">Print the list of devices which
will be triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;n</b>,
<b>&minus;&minus;dry&minus;run</b></p>

<p style="margin-left:17%;">Do not actually trigger the
event.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;q</b>,
<b>&minus;&minus;quiet</b></p>

<p style="margin-left:17%;">Suppress error logging in
triggering events.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;type=</b><i>TYPE</i></p>

<p style="margin-left:17%;">Trigger a specific type of
devices. Valid types are &quot;all&quot;,
&quot;devices&quot;, and &quot;subsystems&quot;. The default
value is &quot;devices&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;c</b>,
<b>&minus;&minus;action=</b><i>ACTION</i></p>

<p style="margin-left:17%;">Type of event to be triggered.
Possible actions are &quot;add&quot;, &quot;remove&quot;,
&quot;change&quot;, &quot;move&quot;, &quot;online&quot;,
&quot;offline&quot;, &quot;bind&quot;, and
&quot;unbind&quot;. Also, the special value &quot;help&quot;
can be used to list the possible actions. The default value
is &quot;change&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;prioritized&minus;subsystem=</b><i>SUBSYSTEM[,SUBSYSTEM</i>...]</p>

<p style="margin-left:17%;">Takes a comma separated list of
subsystems. When triggering events for devices, the devices
from the specified subsystems and their parents are
triggered first. For example, if
<b>&minus;&minus;prioritized&minus;subsystem=block,net</b>,
then firstly all block devices and their parents are
triggered, in the next all network devices and their parents
are triggered, and lastly the other devices are triggered.
This option can be specified multiple times, and in that
case the lists of the subsystems will be merged. That is,
<b>&minus;&minus;prioritized&minus;subsystem=block
&minus;&minus;prioritized&minus;subsystem=net</b> is
equivalent to
<b>&minus;&minus;prioritized&minus;subsystem=block,net</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;s</b>,
<b>&minus;&minus;subsystem&minus;match=</b><i>SUBSYSTEM</i></p>

<p style="margin-left:17%;">Trigger events for devices
which belong to a matching subsystem. This option supports
shell style pattern matching. When this option is specified
more than once, then each matching result is ORed, that is,
all the devices in each subsystem are triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;S</b>,
<b>&minus;&minus;subsystem&minus;nomatch=</b><i>SUBSYSTEM</i></p>

<p style="margin-left:17%;">Do not trigger events for
devices which belong to a matching subsystem. This option
supports shell style pattern matching. When this option is
specified more than once, then each matching result is
ANDed, that is, devices which do not match all specified
subsystems are triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;a</b>,
<b>&minus;&minus;attr&minus;match=</b><i>ATTRIBUTE</i><b>=</b><i>VALUE</i></p>

<p style="margin-left:17%;">Trigger events for devices with
a matching sysfs attribute. If a value is specified along
with the attribute name, the content of the attribute is
matched against the given value using shell style pattern
matching. If no value is specified, the existence of the
sysfs attribute is checked. When this option is specified
multiple times, then each matching result is ANDed, that is,
only devices which have all specified attributes are
triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;A</b>,
<b>&minus;&minus;attr&minus;nomatch=</b><i>ATTRIBUTE</i><b>=</b><i>VALUE</i></p>

<p style="margin-left:17%;">Do not trigger events for
devices with a matching sysfs attribute. If a value is
specified along with the attribute name, the content of the
attribute is matched against the given value using shell
style pattern matching. If no value is specified, the
existence of the sysfs attribute is checked. When this
option is specified multiple times, then each matching
result is ANDed, that is, only devices which have none of
the specified attributes are triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;p</b>,
<b>&minus;&minus;property&minus;match=</b><i>PROPERTY</i><b>=</b><i>VALUE</i></p>

<p style="margin-left:17%;">Trigger events for devices with
a matching property value. This option supports shell style
pattern matching. When this option is specified more than
once, then each matching result is ORed, that is, devices
which have one of the specified properties are
triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;g</b>,
<b>&minus;&minus;tag&minus;match=</b><i>TAG</i></p>

<p style="margin-left:17%;">Trigger events for devices with
a matching tag. When this option is specified multiple
times, then each matching result is ANDed, that is, devices
which have all specified tags are triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;y</b>,
<b>&minus;&minus;sysname&minus;match=</b><i>NAME</i></p>

<p style="margin-left:17%;">Trigger events for devices for
which the last component (i.e. the filename) of the /sys/
path matches the specified <i>PATH</i>. This option supports
shell style pattern matching. When this option is specified
more than once, then each matching result is ORed, that is,
all devices which have any of the specified <i>NAME</i> are
triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;name&minus;match=</b><i>NAME</i></p>

<p style="margin-left:17%;">Trigger events for devices with
a matching device path. When this option is specified more
than once, then each matching result is ORed, that is, all
specified devices are triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;b</b>,
<b>&minus;&minus;parent&minus;match=</b><i>SYSPATH</i></p>

<p style="margin-left:17%;">Trigger events for all children
of a given device. When this option is specified more than
once, then each matching result is ORed, that is, all
children of each specified device are triggered.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;initialized&minus;match</b>,
<b>&minus;&minus;initialized&minus;nomatch</b></p>

<p style="margin-left:17%;">When
<b>&minus;&minus;initialized&minus;match</b> is specified,
trigger events for devices that are already initialized by
<b>systemd&minus;udevd</b>, and skip devices that are not
initialized yet.</p>

<p style="margin-left:17%; margin-top: 1em">When
<b>&minus;&minus;initialized&minus;nomatch</b> is specified,
trigger events for devices that are not initialized by
<b>systemd&minus;udevd</b> yet, and skip devices that are
already initialized.</p>

<p style="margin-left:17%; margin-top: 1em">Typically, it
is essential that applications which intend to use such a
match, make sure a suitable udev rule is installed that sets
at least one property on devices that shall be matched. See
also Initialized Devices section below for more details.</p>

<p style="margin-left:17%; margin-top: 1em">WARNING:
<b>&minus;&minus;initialized&minus;nomatch</b> can
potentially save a significant amount of time compared to
re&minus;triggering all devices in the system and e.g. can
be used to optimize boot time. However, this is not safe to
be used in a boot sequence in general. Especially, when udev
rules for a device depend on its parent devices (e.g.
&quot;ATTRS&quot; or &quot;IMPORT{parent}&quot; keys, see
<b>udev</b>(7) for more details), the final state of the
device becomes easily unstable with this option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;w</b>,
<b>&minus;&minus;settle</b></p>

<p style="margin-left:17%;">Apart from triggering events,
also waits for those events to finish. Note that this is
different from calling <b>udevadm settle</b>. <b>udevadm
settle</b> waits for all events to finish. This option only
waits for events triggered by the same command to
finish.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;uuid</b></p>

<p style="margin-left:17%;">Trigger the synthetic device
events, and associate a randomized UUID with each. These
UUIDs are printed to standard output, one line for each
event. These UUIDs are included in the uevent environment
block (in the &quot;SYNTH_UUID=&quot; property) and may be
used to track delivery of the generated events.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;wait&minus;daemon[=</b><i>SECONDS</i><b>]</b></p>

<p style="margin-left:17%;">Before triggering uevents, wait
for systemd&minus;udevd daemon to be initialized. Optionally
takes timeout value. Default timeout is 5 seconds. This is
equivalent to invoke invoking <b>udevadm control
&minus;&minus;ping</b> before <b>udevadm trigger</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
optional positional arguments can be used to specify device
names or sys paths. They must start with /dev/ or /sys/
respectively.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udevadm
settle [</b><i>options</i>] <br>
Watches the udev event queue, and exits if all current
events are handled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;timeout=</b><i>SECONDS</i></p>

<p style="margin-left:17%;">Maximum number of seconds to
wait for the event queue to become empty. The default value
is 120 seconds. A value of 0 will check if the queue is
empty and always return immediately. A non&minus;zero value
will return an exit code of 0 if queue became empty before
timeout was reached, non&minus;zero otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;E</b>,
<b>&minus;&minus;exit&minus;if&minus;exists=</b><i>FILE</i></p>

<p style="margin-left:17%;">Stop waiting if file
exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>

<p style="margin-left:11%; margin-top: 1em">See
<b>systemd-udev-settle.service</b>(8) for more
information.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udevadm
control</b> <i>option</i> <br>
Modify the internal state of the running udev daemon.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;e</b>,
<b>&minus;&minus;exit</b></p>

<p style="margin-left:17%;">Signal and wait for
systemd&minus;udevd to exit. No option except for
<b>&minus;&minus;timeout</b> can be specified after this
option. Note that systemd&minus;udevd.service contains
<b>Restart=always</b> and so as a result, this option
restarts systemd&minus;udevd. If you want to stop
systemd&minus;udevd.service, please use the following:</p>

<p style="margin-left:23%; margin-top: 1em">systemctl stop
systemd&minus;udevd&minus;control.socket
systemd&minus;udevd&minus;kernel.socket
systemd&minus;udevd.service</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;l</b>,
<b>&minus;&minus;log&minus;level=</b><i>value</i></p>

<p style="margin-left:17%;">Set the internal log level of
systemd&minus;udevd. Valid values are the numerical syslog
priorities or their textual representations: <b>emerg</b>,
<b>alert</b>, <b>crit</b>, <b>err</b>, <b>warning</b>,
<b>notice</b>, <b>info</b>, and <b>debug</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;s</b>,
<b>&minus;&minus;stop&minus;exec&minus;queue</b></p>

<p style="margin-left:17%;">Signal systemd&minus;udevd to
stop executing new events. Incoming events will be
queued.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;S</b>,
<b>&minus;&minus;start&minus;exec&minus;queue</b></p>

<p style="margin-left:17%;">Signal systemd&minus;udevd to
enable the execution of events.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;R</b>,
<b>&minus;&minus;reload</b></p>

<p style="margin-left:17%;">Signal systemd&minus;udevd to
reload the rules files and other databases like the kernel
module index. Reloading rules and databases does not apply
any changes to already existing devices; the new
configuration will only be applied to new events.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;p</b>,
<b>&minus;&minus;property=</b><i>KEY</i><b>=</b><i>value</i></p>

<p style="margin-left:17%;">Set a global property for all
events.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;m</b>,
<b>&minus;&minus;children&minus;max=</b><i>value</i></p>

<p style="margin-left:17%;">Set the maximum number of
events, systemd&minus;udevd will handle at the same
time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;ping</b></p>

<p style="margin-left:17%;">Send a ping message to
systemd&minus;udevd and wait for the reply. This may be
useful to check that systemd&minus;udevd daemon is
running.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;timeout=</b><i>seconds</i></p>

<p style="margin-left:17%;">The maximum number of seconds
to wait for a reply from systemd&minus;udevd.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udevadm
monitor [</b><i>options</i>] <br>
Listens to the kernel uevents and events sent out by a udev
rule and prints the devpath of the event to the console. It
can be used to analyze the event timing, by comparing the
timestamps of the kernel uevent and the udev event.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;k</b>,
<b>&minus;&minus;kernel</b></p>

<p style="margin-left:17%;">Print the kernel uevents.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;u</b>,
<b>&minus;&minus;udev</b></p>

<p style="margin-left:17%;">Print the udev event after the
rule processing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;p</b>,
<b>&minus;&minus;property</b></p>

<p style="margin-left:17%;">Also print the properties of
the event.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;s</b>,
<b>&minus;&minus;subsystem&minus;match=</b><i>string[/string]</i></p>

<p style="margin-left:17%;">Filter kernel uevents and udev
events by subsystem[/devtype]. Only events with a matching
subsystem value will pass. When this option is specified
more than once, then each matching result is ORed, that is,
all devices in the specified subsystems are monitored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;tag&minus;match=</b><i>string</i></p>

<p style="margin-left:17%;">Filter udev events by tag. Only
udev events with a given tag attached will pass. When this
option is specified more than once, then each matching
result is ORed, that is, devices which have one of the
specified tags are monitored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udevadm test
[</b><i>options</i>]
[<i>devpath</i>|<i>file</i>|<i>unit</i>] <br>
Simulate a udev event run for the given device, and print
debug output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;a</b>,
<b>&minus;&minus;action=</b><i>ACTION</i></p>

<p style="margin-left:17%;">Type of event to be simulated.
Possible actions are &quot;add&quot;, &quot;remove&quot;,
&quot;change&quot;, &quot;move&quot;, &quot;online&quot;,
&quot;offline&quot;, &quot;bind&quot;, and
&quot;unbind&quot;. Also, the special value &quot;help&quot;
can be used to list the possible actions. The default value
is &quot;add&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;N</b>,
<b>&minus;&minus;resolve&minus;names=early|late|never</b></p>

<p style="margin-left:17%;">Specify when udevadm should
resolve names of users and groups. When set to <b>early</b>
(the default), names will be resolved when the rules are
parsed. When set to <b>late</b>, names will be resolved for
every event. When set to <b>never</b>, names will never be
resolved and all devices will be owned by root.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udevadm
test&minus;builtin [</b><i>options</i>] [<i>command</i>]
[<i>devpath</i>|<i>file</i>|<i>unit</i>] <br>
Run a built&minus;in command <i>COMMAND</i> for device
<i>DEVPATH</i>, and print debug output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;a</b>,
<b>&minus;&minus;action=</b><i>ACTION</i></p>

<p style="margin-left:17%;">Type of event to be simulated.
Possible actions are &quot;add&quot;, &quot;remove&quot;,
&quot;change&quot;, &quot;move&quot;, &quot;online&quot;,
&quot;offline&quot;, &quot;bind&quot;, and
&quot;unbind&quot;. Also, the special value &quot;help&quot;
can be used to list the possible actions. The default value
is &quot;add&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udevadm wait
[</b><i>options</i>] [<i>device|syspath</i>] ... <br>
Wait for devices or device symlinks being created and
initialized by <b>systemd&minus;udevd</b>. Each device path
must start with &quot;/dev/&quot; or &quot;/sys/&quot;, e.g.
&quot;/dev/sda&quot;,
&quot;/dev/disk/by&minus;path/pci&minus;0000:3c:00.0&minus;nvme&minus;1&minus;part1&quot;,
&quot;/sys/devices/pci0000:00/0000:00:1f.6/net/eth0&quot;,
or &quot;/sys/class/net/eth0&quot;. This can take multiple
devices. This may be useful for waiting for devices being
processed by <b>systemd&minus;udevd</b> after e.g.
partitioning or formatting the devices.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;t</b>,
<b>&minus;&minus;timeout=</b><i>SECONDS</i></p>

<p style="margin-left:17%;">Maximum number of seconds to
wait for the specified devices or device symlinks being
created, initialized, or removed. The default value is
&quot;infinity&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;initialized=</b><i>BOOL</i></p>

<p style="margin-left:17%;">Check if
<b>systemd&minus;udevd</b> initialized devices. Defaults to
true. When false, the command only checks if the specified
devices exist. Set false to this setting if there is no udev
rules for the specified devices, as the devices will never
be considered as initialized in that case. See Initialized
Devices section below for more details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;removed</b></p>

<p style="margin-left:17%;">When specified, the command
wait for devices being removed instead of created or
initialized. If this is specified,
<b>&minus;&minus;initialized=</b> will be ignored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;settle</b></p>

<p style="margin-left:17%;">When specified, also watches
the udev event queue, and wait for all queued events being
processed by <b>systemd&minus;udevd</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Print a short help text and
exit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>udevadm lock
[</b><i>options</i>] [<i>command</i>] ... <b><br>
udevadm lock</b> takes an (advisory) exclusive lock on a
block device (or all specified devices), as per
<b><font color="#0000FF">Locking Block Device
Access</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">and invokes a program with the locks
taken. When the invoked program exits the locks are
automatically released and its return value is propagated as
exit code of <b>udevadm lock</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
tool is in particular useful to ensure that
<b>systemd-udevd.service</b>(8) does not probe a block
device while changes are made to it, for example partitions
created or file systems formatted. Note that many tools that
interface with block devices natively support taking
relevant locks, see for example <b>sfdisk</b>(8)'s
<b>&minus;&minus;lock</b> switch.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">The
command expects at least one block device specified via
<b>&minus;&minus;device=</b> or
<b>&minus;&minus;backing=</b>, and a command line to execute
as arguments.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>&minus;&minus;device=</b><i>DEVICE</i>,
<b>&minus;d</b> <i>DEVICE</i></font></p>

<p style="margin-left:17%;"><font color="#000000">Takes a
path to a device node of the device to lock. This switch may
be used multiple times (and in combination with
<b>&minus;&minus;backing=</b>) in order to lock multiple
devices. If a partition block device node is specified the
containing &quot;whole&quot; block device is automatically
determined and used for the lock, as per the specification.
If multiple devices are specified, they are deduplicated,
sorted by the major/minor of their device nodes and then
locked in order.</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">This
switch must be used at least once, to specify at least one
device to lock. (Alternatively, use
<b>&minus;&minus;backing=</b>, see below.)</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>&minus;&minus;backing=</b><i>PATH</i>,
<b>&minus;b</b> <i>PATH</i></font></p>

<p style="margin-left:17%;"><font color="#000000">If a path
to a device node is specified, identical to
<b>&minus;&minus;device=</b>. However, this switch
alternatively accepts a path to a regular file or directory,
in which case the block device of the file system the
file/directory resides on is automatically determined and
used as if it was specified with
<b>&minus;&minus;device=</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>&minus;&minus;timeout=</b><i>SECS</i>,
<b>&minus;t</b> <i>SECS</i></font></p>


<p style="margin-left:17%;"><font color="#000000">Specifies
how long to wait at most until all locks can be taken. Takes
a value in seconds, or in the usual supported time units,
see <b>systemd.time</b>(7). If specified as zero the lock is
attempted and if not successful the invocation will
immediately fail. If passed as &quot;infinity&quot; (the
default) the invocation will wait indefinitely until the
lock can be acquired. If the lock cannot be taken in the
specified time the specified command will not be executed
and the invocation will fail.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>&minus;&minus;print</b>,
<b>&minus;p</b></font></p>

<p style="margin-left:17%;"><font color="#000000">Instead
of locking the specified devices and executing a command,
just print the device paths that would be locked, and
execute no command. This command is useful to determine the
&quot;whole&quot; block device in case a partition block
device is specified. The devices will be sorted by their
device node major number as primary ordering key and the
minor number as secondary ordering key (i.e. they are shown
in the order they'd be locked). Note that the number of
lines printed here can be less than the number of
<b>&minus;&minus;device=</b> and
<b>&minus;&minus;backing=</b> switches specified in case
these resolve to the same &quot;whole&quot;
devices.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>&minus;h</b>,
<b>&minus;&minus;help</b></font></p>

<p style="margin-left:17%;"><font color="#000000">Print a
short help text and exit.</font></p>

<h2>INITIALIZED DEVICES
<a name="INITIALIZED DEVICES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Initialized
devices are those for which at least one udev rule already
completed execution &ndash; for any action but
&quot;remove&quot; &mdash; that set a property or other
device setting (and thus has an entry in the udev device
database). Devices are no longer considered initialized if a
&quot;remove&quot; action is seen for them (which removes
their entry in the udev device database). Note that devices
that have no udev rules are never considered initialized,
but might still be announced via the sd&minus;device API (or
similar).</font></p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;1.&nbsp;Format
a File System</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Take
a lock on the backing block device while creating a file
system, to ensure that <b>systemd&minus;udevd</b> doesn't
probe or announce the new superblock before it is
comprehensively written:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">#
udevadm lock &minus;&minus;device=/dev/sda1 mkfs.ext4
/dev/sda1</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;2.&nbsp;Format
a RAID File System</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Similar,
but take locks on multiple devices at once:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">#
udevadm lock &minus;&minus;device=/dev/sda1
&minus;&minus;device=/dev/sdb1 mkfs.btrfs /dev/sda1
/dev/sdb1</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>Example&nbsp;3.&nbsp;Copy
in a File System</b></font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Take
a lock on the backing block device while copying in a
prepared file system image, to ensure that
<b>systemd&minus;udevd</b> doesn't probe or announce the new
superblock before it is fully written:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">#
udevadm lock &minus;d /dev/sda1 dd if=fs.raw
of=/dev/sda1</font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>udev</b>(7),
<b>systemd-udevd.service</b>(8)</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="41%">


<p style="margin-top: 1em"><font color="#000000">Locking
Block Device Access</font></p></td>
<td width="42%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://systemd.io/BLOCK_DEVICE_LOCKING</font></p>
<hr>
</body>
</html>
