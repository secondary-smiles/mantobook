<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:57:06 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HWCLOCK</title>

</head>
<body>
<h1>hwclock</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">hwclock &minus;
time clocks utility</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>hwclock</b>
[<i>function</i>] [<i>option</i>...]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>hwclock</b>
is an administration tool for the time clocks. It can:
display the Hardware Clock time; set the Hardware Clock to a
specified time; set the Hardware Clock from the System
Clock; set the System Clock from the Hardware Clock;
compensate for Hardware Clock drift; correct the System
Clock timescale; set the kernel&rsquo;s timezone, NTP
timescale, and epoch (Alpha only); and predict future
Hardware Clock values based on its drift rate.</p>

<p style="margin-left:11%; margin-top: 1em">Since v2.26
important changes were made to the
<b>&minus;&minus;hctosys</b> function and the
<b>&minus;&minus;directisa</b> option, and a new option
<b>&minus;&minus;update&minus;drift</b> was added. See their
respective descriptions below.</p>

<h2>FUNCTIONS
<a name="FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
functions are mutually exclusive, only one can be given at a
time. If none is given, the default is
<b>&minus;&minus;show</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>&minus;a,
&minus;&minus;adjust</b></p>

<p style="margin-left:17%;">Add or subtract time from the
Hardware Clock to account for systematic drift since the
last time the clock was set or adjusted. See the discussion
below, under <b>The Adjust Function</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;getepoch</b>;
<b>&minus;&minus;setepoch</b></p>

<p style="margin-left:17%;">These functions are for Alpha
machines only, and are only available through the Linux
kernel RTC driver.</p>

<p style="margin-left:17%; margin-top: 1em">They are used
to read and set the kernel&rsquo;s Hardware Clock epoch
value. Epoch is the number of years into AD to which a zero
year value in the Hardware Clock refers. For example, if the
machine&rsquo;s BIOS sets the year counter in the Hardware
Clock to contain the number of full years since 1952, then
the kernel&rsquo;s Hardware Clock epoch value must be
1952.</p>

<p style="margin-left:17%; margin-top: 1em">The
<b>&minus;&minus;setepoch</b> function requires using the
<b>&minus;&minus;epoch</b> option to specify the year. For
example:</p>

<p style="margin-left:17%; margin-top: 1em"><b>hwclock
&minus;&minus;setepoch &minus;&minus;epoch=1952</b></p>

<p style="margin-left:17%; margin-top: 1em">The RTC driver
attempts to guess the correct epoch value, so setting it may
not be required.</p>

<p style="margin-left:17%; margin-top: 1em">This epoch
value is used whenever <b>hwclock</b> reads or sets the
Hardware Clock on an Alpha machine. For ISA machines the
kernel uses the fixed Hardware Clock epoch of 1900.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;param&minus;get=</b><i>parameter</i>;
<b>&minus;&minus;param&minus;set=</b><i>parameter</i>=<i>value</i></p>

<p style="margin-left:17%;">Read and set the RTC&rsquo;s
parameter. This is useful, for example, to retrieve the
RTC&rsquo;s feature or set the RTC&rsquo;s Backup Switchover
Mode.</p>


<p style="margin-left:17%; margin-top: 1em"><i>parameter</i>
is either a numeric RTC parameter value (see the
Kernel&rsquo;s <i>include/uapi/linux/rtc.h</i>) or an alias.
See <b>&minus;&minus;help</b> for a list of valid aliases.
<i>parameter</i> and <i>value</i>, if prefixed with 0x, are
interpreted as hexadecimal, otherwise decimal values.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;predict</b></p>

<p style="margin-left:17%;">Predict what the Hardware Clock
will read in the future based upon the time given by the
<b>&minus;&minus;date</b> option and the information in
<i>/etc/adjtime</i>. This is useful, for example, to account
for drift when setting a Hardware Clock wakeup (aka alarm).
See <b>rtcwake</b>(8).</p>

<p style="margin-left:17%; margin-top: 1em">Do not use this
function if the Hardware Clock is being modified by anything
other than the current operating system&rsquo;s
<b>hwclock</b> command, such as '11 minute mode' or from
dual&minus;booting another OS.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;r</b>,
<b>&minus;&minus;show</b>; <b>&minus;&minus;get</b></p>

<p style="margin-left:17%;">Read the Hardware Clock and
print its time to standard output in the <b>ISO 8601</b>
format. The time shown is always in local time, even if you
keep your Hardware Clock in UTC. See the
<b>&minus;&minus;localtime</b> option.</p>

<p style="margin-left:17%; margin-top: 1em">Showing the
Hardware Clock time is the default when no function is
specified.</p>

<p style="margin-left:17%; margin-top: 1em">The
<b>&minus;&minus;get</b> function also applies drift
correction to the time read, based upon the information in
<i>/etc/adjtime</i>. Do not use this function if the
Hardware Clock is being modified by anything other than the
current operating system&rsquo;s <b>hwclock</b> command,
such as '11 minute mode' or from dual&minus;booting another
OS.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;s</b>,
<b>&minus;&minus;hctosys</b></p>

<p style="margin-left:17%;">Set the System Clock from the
Hardware Clock. The time read from the Hardware Clock is
compensated to account for systematic drift before using it
to set the System Clock. See the discussion below, under
<b>The Adjust Function</b>.</p>

<p style="margin-left:17%; margin-top: 1em">The System
Clock must be kept in the UTC timescale for date&minus;time
applications to work correctly in conjunction with the
timezone configured for the system. If the Hardware Clock is
kept in local time then the time read from it must be
shifted to the UTC timescale before using it to set the
System Clock. The <b>&minus;&minus;hctosys</b> function does
this based upon the information in the <i>/etc/adjtime</i>
file or the command line arguments
<b>&minus;&minus;localtime</b> and <b>&minus;&minus;utc</b>.
Note: no daylight saving adjustment is made. See the
discussion below, under <b>LOCAL vs UTC</b>.</p>

<p style="margin-left:17%; margin-top: 1em">The kernel also
keeps a timezone value, the <b>&minus;&minus;hctosys</b>
function sets it to the timezone configured for the system.
The system timezone is configured by the <b>TZ</b>
environment variable or the <i>/etc/localtime</i> file, as
<b>tzset</b>(3) would interpret them. The obsolete
<i>tz_dsttime</i> field of the kernel&rsquo;s timezone value
is set to zero. (For details on what this field used to
mean, see <b>settimeofday</b>(2).)</p>

<p style="margin-left:17%; margin-top: 1em">When used in a
startup script, making the <b>&minus;&minus;hctosys</b>
function the first caller of <b>settimeofday</b>(2) from
boot, it will set the NTP '11 minute mode' timescale via the
<i>persistent_clock_is_local</i> kernel variable. If the
Hardware Clock&rsquo;s timescale configuration is changed
then a reboot is required to inform the kernel. See the
discussion below, under <b>Automatic Hardware Clock
Synchronization by the Kernel</b>.</p>

<p style="margin-left:17%; margin-top: 1em">This is a good
function to use in one of the system startup scripts before
the file systems are mounted read/write.</p>

<p style="margin-left:17%; margin-top: 1em">This function
should never be used on a running system. Jumping system
time will cause problems, such as corrupted filesystem
timestamps. Also, if something has changed the Hardware
Clock, like NTP&rsquo;s '11 minute mode', then
<b>&minus;&minus;hctosys</b> will set the time incorrectly
by including drift compensation.</p>

<p style="margin-left:17%; margin-top: 1em">Drift
compensation can be inhibited by setting the drift factor in
<i>/etc/adjtime</i> to zero. This setting will be persistent
as long as the <b>&minus;&minus;update&minus;drift</b>
option is not used with <b>&minus;&minus;systohc</b> at
shutdown (or anywhere else). Another way to inhibit this is
by using the <b>&minus;&minus;noadjfile</b> option when
calling the <b>&minus;&minus;hctosys</b> function. A third
method is to delete the <i>/etc/adjtime</i> file.
<b>Hwclock</b> will then default to using the UTC timescale
for the Hardware Clock. If the Hardware Clock is ticking
local time it will need to be defined in the file. This can
be done by calling <b>hwclock &minus;&minus;localtime
&minus;&minus;adjust</b>; when the file is not present this
command will not actually adjust the Clock, but it will
create the file with local time configured, and a drift
factor of zero.</p>

<p style="margin-left:17%; margin-top: 1em">A condition
under which inhibiting <b>hwclock</b>'s drift correction may
be desired is when dual&minus;booting multiple operating
systems. If while this instance of Linux is stopped, another
OS changes the Hardware Clock&rsquo;s value, then when this
instance is started again the drift correction applied will
be incorrect.</p>

<p style="margin-left:17%; margin-top: 1em">For
<b>hwclock</b>'s drift correction to work properly it is
imperative that nothing changes the Hardware Clock while its
Linux instance is not running.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;set</b></p>

<p style="margin-left:17%;">Set the Hardware Clock to the
time given by the <b>&minus;&minus;date</b> option, and
update the timestamps in <i>/etc/adjtime</i>. With the
<b>&minus;&minus;update&minus;drift</b> option also
(re)calculate the drift factor. Try it without the option if
<b>&minus;&minus;set</b> fails. See
<b>&minus;&minus;update&minus;drift</b> below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;systz</b></p>

<p style="margin-left:17%;">This is an alternate to the
<b>&minus;&minus;hctosys</b> function that does not read the
Hardware Clock nor set the System Clock; consequently there
is not any drift correction. It is intended to be used in a
startup script on systems with kernels above version 2.6
where you know the System Clock has been set from the
Hardware Clock by the kernel during boot.</p>

<p style="margin-left:17%; margin-top: 1em">It does the
following things that are detailed above in the
<b>&minus;&minus;hctosys</b> function:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Corrects
the System Clock timescale to UTC as needed. Only instead of
accomplishing this by setting the System Clock,
<b>hwclock</b> simply informs the kernel and it handles the
change.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Sets the
kernel&rsquo;s NTP '11 minute mode' timescale.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; Sets the
kernel&rsquo;s timezone.</p>

<p style="margin-left:11%; margin-top: 1em">The first two
are only available on the first call of
<b>settimeofday</b>(2) after boot. Consequently this option
only makes sense when used in a startup script. If the
Hardware Clocks timescale configuration is changed then a
reboot would be required to inform the kernel.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;w</b>,
<b>&minus;&minus;systohc</b></p>

<p style="margin-left:17%;">Set the Hardware Clock from the
System Clock, and update the timestamps in
<i>/etc/adjtime</i>. With the
<b>&minus;&minus;update&minus;drift</b> option also
(re)calculate the drift factor. Try it without the option if
<b>&minus;&minus;systohc</b> fails. See
<b>&minus;&minus;update&minus;drift</b> below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;h</b>,
<b>&minus;&minus;help</b></p>

<p style="margin-left:17%;">Display help text and exit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;V</b>,
<b>&minus;&minus;version</b></p>

<p style="margin-left:17%;">Print version and exit.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;adjfile=</b><i>filename</i></p>

<p style="margin-left:17%;">Override the default
<i>/etc/adjtime</i> file path.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;date=</b><i>date_string</i></p>

<p style="margin-left:17%;">This option must be used with
the <b>&minus;&minus;set</b> or <b>&minus;&minus;predict</b>
functions, otherwise it is ignored.</p>

<p style="margin-left:17%; margin-top: 1em"><b>hwclock
&minus;&minus;set &minus;&minus;date='16:45'</b></p>

<p style="margin-left:17%; margin-top: 1em"><b>hwclock
&minus;&minus;predict
&minus;&minus;date='2525&minus;08&minus;14 07:11:05'</b></p>

<p style="margin-left:17%; margin-top: 1em">The argument
must be in local time, even if you keep your Hardware Clock
in UTC. See the <b>&minus;&minus;localtime</b> option.
Therefore, the argument should not include any timezone
information. It also should not be a relative time like
&quot;+5 minutes&quot;, because <b>hwclock</b>'s precision
depends upon correlation between the argument&rsquo;s value
and when the enter key is pressed. Fractional seconds are
silently dropped. This option is capable of understanding
many time and date formats, but the previous parameters
should be observed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;delay=</b><i>seconds</i></p>

<p style="margin-left:17%;">This option can be used to
overwrite the internally used delay when setting the clock
time. The default is 0.5 (500ms) for rtc_cmos, for another
RTC types the delay is 0. If RTC type is impossible to
determine (from sysfs) then it defaults also to 0.5 to be
backwardly compatible.</p>

<p style="margin-left:17%; margin-top: 1em">The 500ms
default is based on commonly used MC146818A&minus;compatible
(x86) hardware clock. This Hardware Clock can only be set to
any integer time plus one half second. The integer time is
required because there is no interface to set or get a
fractional second. The additional half second delay is
because the Hardware Clock updates to the following second
precisely 500 ms after setting the new time. Unfortunately,
this behavior is hardware specific and in some cases another
delay is required.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;D</b>,
<b>&minus;&minus;debug</b></p>

<p style="margin-left:17%;">Use
<b>&minus;&minus;verbose</b>. The <b>&minus;&minus;debug</b>
option has been deprecated and may be repurposed or removed
in a future release.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;directisa</b></p>

<p style="margin-left:17%;">This option is meaningful for
ISA compatible machines in the x86 and x86_64 family. For
other machines, it has no effect. This option tells
<b>hwclock</b> to use explicit I/O instructions to access
the Hardware Clock. Without this option, <b>hwclock</b> will
use the rtc device file, which it assumes to be driven by
the Linux RTC device driver. As of v2.26 it will no longer
automatically use directisa when the rtc driver is
unavailable; this was causing an unsafe condition that could
allow two processes to access the Hardware Clock at the same
time. Direct hardware access from userspace should only be
used for testing, troubleshooting, and as a last resort when
all other methods fail. See the <b>&minus;&minus;rtc</b>
option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;epoch=</b><i>year</i></p>

<p style="margin-left:17%;">This option is required when
using the <b>&minus;&minus;setepoch</b> function. The
minimum <i>year</i> value is 1900. The maximum is system
dependent (<b>ULONG_MAX &minus; 1</b>).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;f</b>,
<b>&minus;&minus;rtc=</b><i>filename</i></p>

<p style="margin-left:17%;">Override <b>hwclock</b>'s
default rtc device file name. Otherwise it will use the
first one found in this order: <i>/dev/rtc0</i>,
<i>/dev/rtc</i>, <i>/dev/misc/rtc</i>. For
<b>IA&minus;64:</b> <i>/dev/efirtc /dev/misc/efirtc</i></p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;l</b>,
<b>&minus;&minus;localtime</b>; <b>&minus;u</b>,
<b>&minus;&minus;utc</b></p>

<p style="margin-left:17%;">Indicate which timescale the
Hardware Clock is set to.</p>

<p style="margin-left:17%; margin-top: 1em">The Hardware
Clock may be configured to use either the UTC or the local
timescale, but nothing in the clock itself says which
alternative is being used. The
<b>&minus;&minus;localtime</b> or <b>&minus;&minus;utc</b>
options give this information to the <b>hwclock</b> command.
If you specify the wrong one (or specify neither and take a
wrong default), both setting and reading the Hardware Clock
will be incorrect.</p>

<p style="margin-left:17%; margin-top: 1em">If you specify
neither <b>&minus;&minus;utc</b> nor
<b>&minus;&minus;localtime</b> then the one last given with
a set function (<b>&minus;&minus;set</b>,
<b>&minus;&minus;systohc</b>, or
<b>&minus;&minus;adjust</b>), as recorded in
<i>/etc/adjtime</i>, will be used. If the adjtime file
doesn&rsquo;t exist, the default is UTC.</p>

<p style="margin-left:17%; margin-top: 1em">Note: daylight
saving time changes may be inconsistent when the Hardware
Clock is kept in local time. See the discussion below, under
<b>LOCAL vs UTC</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;noadjfile</b></p>

<p style="margin-left:17%;">Disable the facilities provided
by <i>/etc/adjtime</i>. <b>hwclock</b> will not read nor
write to that file with this option. Either
<b>&minus;&minus;utc</b> or <b>&minus;&minus;localtime</b>
must be specified when using this option.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;test</b></p>

<p style="margin-left:17%;">Do not actually change anything
on the system, that is, the Clocks or <i>/etc/adjtime</i>
(<b>&minus;&minus;verbose</b> is implicit with this
option).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;&minus;update&minus;drift</b></p>

<p style="margin-left:17%;">Update the Hardware
Clock&rsquo;s drift factor in <i>/etc/adjtime</i>. It can
only be used with <b>&minus;&minus;set</b> or
<b>&minus;&minus;systohc</b>.</p>

<p style="margin-left:17%; margin-top: 1em">A minimum four
hour period between settings is required. This is to avoid
invalid calculations. The longer the period, the more
precise the resulting drift factor will be.</p>

<p style="margin-left:17%; margin-top: 1em">This option was
added in v2.26, because it is typical for systems to call
<b>hwclock &minus;&minus;systohc</b> at shutdown; with the
old behavior this would automatically (re)calculate the
drift factor which caused several problems:</p>

<p style="margin-left:23%; margin-top: 1em">&bull; When
using NTP with an '11 minute mode' kernel the drift factor
would be clobbered to near zero.</p>

<p style="margin-left:23%; margin-top: 1em">&bull; It would
not allow the use of 'cold' drift correction. With most
configurations using 'cold' drift will yield favorable
results. Cold, means when the machine is turned off which
can have a significant impact on the drift factor.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
(Re)calculating drift factor on every shutdown delivers
suboptimal results. For example, if ephemeral conditions
cause the machine to be abnormally hot the drift factor
calculation would be out of range.</p>

<p style="margin-left:23%; margin-top: 1em">&bull;
Significantly increased system shutdown times (as of v2.31
when not using <b>&minus;&minus;update&minus;drift</b> the
RTC is not read).</p>

<p style="margin-left:11%; margin-top: 1em">Having
<b>hwclock</b> calculate the drift factor is a good starting
point, but for optimal results it will likely need to be
adjusted by directly editing the <i>/etc/adjtime</i> file.
For most configurations once a machine&rsquo;s optimal drift
factor is crafted it should not need to be changed.
Therefore, the old behavior to automatically (re)calculate
drift was changed and now requires this option to be used.
See the discussion below, under <b>The Adjust
Function</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This option
requires reading the Hardware Clock before setting it. If it
cannot be read, then this option will cause the set
functions to fail. This can happen, for example, if the
Hardware Clock is corrupted by a power failure. In that
case, the clock must first be set without this option.
Despite it not working, the resulting drift correction
factor would be invalid anyway.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;v</b>,
<b>&minus;&minus;verbose</b></p>

<p style="margin-left:17%;">Display more details about what
<b>hwclock</b> is doing internally.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Clocks in a
Linux System</b> <br>
There are two types of date&minus;time clocks:</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Hardware
Clock:</b> This clock is an independent hardware device,
with its own power domain (battery, capacitor, etc), that
operates when the machine is powered off, or even
unplugged.</p>

<p style="margin-left:11%; margin-top: 1em">On an ISA
compatible system, this clock is specified as part of the
ISA standard. A control program can read or set this clock
only to a whole second, but it can also detect the edges of
the 1 second clock ticks, so the clock actually has
virtually infinite precision.</p>

<p style="margin-left:11%; margin-top: 1em">This clock is
commonly called the hardware clock, the real time clock, the
RTC, the BIOS clock, and the CMOS clock. Hardware Clock, in
its capitalized form, was coined for use by <b>hwclock</b>.
The Linux kernel also refers to it as the persistent
clock.</p>

<p style="margin-left:11%; margin-top: 1em">Some
non&minus;ISA systems have a few real time clocks with only
one of them having its own power domain. A very low power
external I2C or SPI clock chip might be used with a backup
battery as the hardware clock to initialize a more
functional integrated real&minus;time clock which is used
for most other purposes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The System
Clock:</b> This clock is part of the Linux kernel and is
driven by a timer interrupt. (On an ISA machine, the timer
interrupt is part of the ISA standard.) It has meaning only
while Linux is running on the machine. The System Time is
the number of seconds since 00:00:00 January 1, 1970 UTC (or
more succinctly, the number of seconds since 1969 UTC). The
System Time is not an integer, though. It has virtually
infinite precision.</p>

<p style="margin-left:11%; margin-top: 1em">The System Time
is the time that matters. The Hardware Clock&rsquo;s basic
purpose is to keep time when Linux is not running so that
the System Clock can be initialized from it at boot. Note
that in DOS, for which ISA was designed, the Hardware Clock
is the only real time clock.</p>

<p style="margin-left:11%; margin-top: 1em">It is important
that the System Time not have any discontinuities such as
would happen if you used the <b>date</b>(1) program to set
it while the system is running. You can, however, do
whatever you want to the Hardware Clock while the system is
running, and the next time Linux starts up, it will do so
with the adjusted time from the Hardware Clock. Note:
currently this is not possible on most systems because
<b>hwclock &minus;&minus;systohc</b> is called at
shutdown.</p>

<p style="margin-left:11%; margin-top: 1em">The Linux
kernel&rsquo;s timezone is set by <b>hwclock</b>. But
don&rsquo;t be misled &mdash; almost nobody cares what
timezone the kernel thinks it is in. Instead, programs that
care about the timezone (perhaps because they want to
display a local time for you) almost always use a more
traditional method of determining the timezone: They use the
<b>TZ</b> environment variable or the <i>/etc/localtime</i>
file, as explained in the man page for <b>tzset</b>(3).
However, some programs and fringe parts of the Linux kernel
such as filesystems use the kernel&rsquo;s timezone value.
An example is the vfat filesystem. If the kernel timezone
value is wrong, the vfat filesystem will report and set the
wrong timestamps on files. Another example is the
kernel&rsquo;s NTP '11 minute mode'. If the kernel&rsquo;s
timezone value and/or the <i>persistent_clock_is_local</i>
variable are wrong, then the Hardware Clock will be set
incorrectly by '11 minute mode'. See the discussion below,
under <b>Automatic Hardware Clock Synchronization by the
Kernel</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>hwclock</b>
sets the kernel&rsquo;s timezone to the value indicated by
<b>TZ</b> or <i>/etc/localtime</i> with the
<b>&minus;&minus;hctosys</b> or <b>&minus;&minus;systz</b>
functions.</p>

<p style="margin-left:11%; margin-top: 1em">The
kernel&rsquo;s timezone value actually consists of two
parts: 1) a field tz_minuteswest indicating how many minutes
local time (not adjusted for DST) lags behind UTC, and 2) a
field tz_dsttime indicating the type of Daylight Savings
Time (DST) convention that is in effect in the locality at
the present time. This second field is not used under Linux
and is always zero. See also <b>settimeofday</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Hardware
Clock Access Methods <br>
hwclock</b> uses many different ways to get and set Hardware
Clock values. The most normal way is to do I/O to the rtc
device special file, which is presumed to be driven by the
rtc device driver. Also, Linux systems using the rtc
framework with udev, are capable of supporting multiple
Hardware Clocks. This may bring about the need to override
the default rtc device by specifying one with the
<b>&minus;&minus;rtc</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">However, this
method is not always available as older systems do not have
an rtc driver. On these systems, the method of accessing the
Hardware Clock depends on the system hardware.</p>

<p style="margin-left:11%; margin-top: 1em">On an ISA
compatible system, <b>hwclock</b> can directly access the
&quot;CMOS memory&quot; registers that constitute the clock,
by doing I/O to Ports 0x70 and 0x71. It does this with
actual I/O instructions and consequently can only do it if
running with superuser effective userid. This method may be
used by specifying the <b>&minus;&minus;directisa</b>
option.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
really poor method of accessing the clock, for all the
reasons that userspace programs are generally not supposed
to do direct I/O and disable interrupts. <b>hwclock</b>
provides it for testing, troubleshooting, and because it may
be the only method available on ISA systems which do not
have a working rtc device driver.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Adjust
Function</b> <br>
The Hardware Clock is usually not very accurate. However,
much of its inaccuracy is completely predictable &minus; it
gains or loses the same amount of time every day. This is
called systematic drift. <b>hwclock</b>'s
<b>&minus;&minus;adjust</b> function lets you apply
systematic drift corrections to the Hardware Clock.</p>

<p style="margin-left:11%; margin-top: 1em">It works like
this: <b>hwclock</b> keeps a file, <i>/etc/adjtime</i>, that
keeps some historical information. This is called the
adjtime file.</p>

<p style="margin-left:11%; margin-top: 1em">Suppose you
start with no adjtime file. You issue a <b>hwclock
&minus;&minus;set</b> command to set the Hardware Clock to
the true current time. <b>hwclock</b> creates the adjtime
file and records in it the current time as the last time the
clock was calibrated. Five days later, the clock has gained
10 seconds, so you issue a <b>hwclock &minus;&minus;set
&minus;&minus;update&minus;drift</b> command to set it back
10 seconds. <b>hwclock</b> updates the adjtime file to show
the current time as the last time the clock was calibrated,
and records 2 seconds per day as the systematic drift rate.
24 hours go by, and then you issue a <b>hwclock
&minus;&minus;adjust</b> command. <b>hwclock</b> consults
the adjtime file and sees that the clock gains 2 seconds per
day when left alone and that it has been left alone for
exactly one day. So it subtracts 2 seconds from the Hardware
Clock. It then records the current time as the last time the
clock was adjusted. Another 24 hours go by and you issue
another <b>hwclock &minus;&minus;adjust</b>. <b>hwclock</b>
does the same thing: subtracts 2 seconds and updates the
adjtime file with the current time as the last time the
clock was adjusted.</p>

<p style="margin-left:11%; margin-top: 1em">When you use
the <b>&minus;&minus;update&minus;drift</b> option with
<b>&minus;&minus;set</b> or <b>&minus;&minus;systohc</b>,
the systematic drift rate is (re)calculated by comparing the
fully drift corrected current Hardware Clock time with the
new set time, from that it derives the 24 hour drift rate
based on the last calibrated timestamp from the adjtime
file. This updated drift factor is then saved in
<i>/etc/adjtime</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A small amount
of error creeps in when the Hardware Clock is set, so
<b>&minus;&minus;adjust</b> refrains from making any
adjustment that is less than 1 second. Later on, when you
request an adjustment again, the accumulated drift will be
more than 1 second and <b>&minus;&minus;adjust</b> will make
the adjustment including any fractional amount.</p>

<p style="margin-left:11%; margin-top: 1em"><b>hwclock
&minus;&minus;hctosys</b> also uses the adjtime file data to
compensate the value read from the Hardware Clock before
using it to set the System Clock. It does not share the 1
second limitation of <b>&minus;&minus;adjust</b>, and will
correct sub&minus;second drift values immediately. It does
not change the Hardware Clock time nor the adjtime file.
This may eliminate the need to use
<b>&minus;&minus;adjust</b>, unless something else on the
system needs the Hardware Clock to be compensated.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Adjtime
File</b> <br>
While named for its historical purpose of controlling
adjustments only, it actually contains other information
used by <b>hwclock</b> from one invocation to the next.</p>

<p style="margin-left:11%; margin-top: 1em">The format of
the adjtime file is, in ASCII:</p>

<p style="margin-left:11%; margin-top: 1em">Line 1: Three
numbers, separated by blanks: 1) the systematic drift rate
in seconds per day, floating point decimal; 2) the resulting
number of seconds since 1969 UTC of most recent adjustment
or calibration, decimal integer; 3) zero (for compatibility
with <b>clock</b>(8)) as a floating point decimal.</p>

<p style="margin-left:11%; margin-top: 1em">Line 2: One
number: the resulting number of seconds since 1969 UTC of
most recent calibration. Zero if there has been no
calibration yet or it is known that any previous calibration
is moot (for example, because the Hardware Clock has been
found, since that calibration, not to contain a valid time).
This is a decimal integer.</p>

<p style="margin-left:11%; margin-top: 1em">Line 3:
&quot;UTC&quot; or &quot;LOCAL&quot;. Tells whether the
Hardware Clock is set to Coordinated Universal Time or local
time. You can always override this value with options on the
<b>hwclock</b> command line.</p>

<p style="margin-left:11%; margin-top: 1em">You can use an
adjtime file that was previously used with the
<b>clock</b>(8) program with <b>hwclock</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Automatic
Hardware Clock Synchronization by the Kernel</b> <br>
You should be aware of another way that the Hardware Clock
is kept synchronized in some systems. The Linux kernel has a
mode wherein it copies the System Time to the Hardware Clock
every 11 minutes. This mode is a compile time option, so not
all kernels will have this capability. This is a good mode
to use when you are using something sophisticated like NTP
to keep your System Clock synchronized. (NTP is a way to
keep your System Time synchronized either to a time server
somewhere on the network or to a radio clock hooked up to
your system. See RFC 1305.)</p>

<p style="margin-left:11%; margin-top: 1em">If the kernel
is compiled with the '11 minute mode' option it will be
active when the kernel&rsquo;s clock discipline is in a
synchronized state. When in this state, bit 6 (the bit that
is set in the mask 0x0040) of the kernel&rsquo;s
<i>time_status</i> variable is unset. This value is output
as the 'status' line of the <b>adjtimex
&minus;&minus;print</b> or <b>ntptime</b> commands.</p>

<p style="margin-left:11%; margin-top: 1em">It takes an
outside influence, like the NTP daemon to put the
kernel&rsquo;s clock discipline into a synchronized state,
and therefore turn on '11 minute mode'. It can be turned off
by running anything that sets the System Clock the old
fashioned way, including <b>hwclock
&minus;&minus;hctosys</b>. However, if the NTP daemon is
still running, it will turn '11 minute mode' back on again
the next time it synchronizes the System Clock.</p>

<p style="margin-left:11%; margin-top: 1em">If your system
runs with '11 minute mode' on, it may need to use either
<b>&minus;&minus;hctosys</b> or <b>&minus;&minus;systz</b>
in a startup script, especially if the Hardware Clock is
configured to use the local timescale. Unless the kernel is
informed of what timescale the Hardware Clock is using, it
may clobber it with the wrong one. The kernel uses UTC by
default.</p>

<p style="margin-left:11%; margin-top: 1em">The first
userspace command to set the System Clock informs the kernel
what timescale the Hardware Clock is using. This happens via
the <i>persistent_clock_is_local</i> kernel variable. If
<b>&minus;&minus;hctosys</b> or <b>&minus;&minus;systz</b>
is the first, it will set this variable according to the
adjtime file or the appropriate command&minus;line argument.
Note that when using this capability and the Hardware Clock
timescale configuration is changed, then a reboot is
required to notify the kernel.</p>

<p style="margin-left:11%; margin-top: 1em"><b>hwclock
&minus;&minus;adjust</b> should not be used with NTP '11
minute mode'.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ISA Hardware
Clock Century value</b> <br>
There is some sort of standard that defines CMOS memory Byte
50 on an ISA machine as an indicator of what century it is.
<b>hwclock</b> does not use or set that byte because there
are some machines that don&rsquo;t define the byte that way,
and it really isn&rsquo;t necessary anyway, since the
year&minus;of&minus;century does a good job of implying
which century it is.</p>

<p style="margin-left:11%; margin-top: 1em">If you have a
bona fide use for a CMOS century byte, contact the
<b>hwclock</b> maintainer; an option may be appropriate.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
section is only relevant when you are using the &quot;direct
ISA&quot; method of accessing the Hardware Clock. ACPI
provides a standard way to access century values, when they
are supported by the hardware.</p>

<h2>DATE&minus;TIME CONFIGURATION
<a name="DATE&minus;TIME CONFIGURATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Keeping Time
without External Synchronization</b> <br>
This discussion is based on the following conditions:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Nothing
is running that alters the date&minus;time clocks, such as
NTP daemon or a cron job.&quot;</p>

<p style="margin-left:17%; margin-top: 1em">&bull; The
system timezone is configured for the correct local time.
See below, under <b>POSIX vs 'RIGHT'</b>.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Early
during startup the following are called, in this order:
<b>adjtimex &minus;&minus;tick</b> <i>value</i>
<b>&minus;&minus;frequency</b> <i>value</i> <b>hwclock
&minus;&minus;hctosys</b></p>

<p style="margin-left:17%; margin-top: 1em">&bull; During
shutdown the following is called: <b>hwclock
&minus;&minus;systohc</b></p>

<p style="margin-left:23%; margin-top: 1em">&bull; Systems
without <b>adjtimex</b> may use <b>ntptime</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Whether
maintaining precision time with NTP daemon or not, it makes
sense to configure the system to keep reasonably good
date&minus;time on its own.</p>

<p style="margin-left:11%; margin-top: 1em">The first step
in making that happen is having a clear understanding of the
big picture. There are two completely separate hardware
devices running at their own speed and drifting away from
the 'correct' time at their own rates. The methods and
software for drift correction are different for each of
them. However, most systems are configured to exchange
values between these two clocks at startup and shutdown. Now
the individual device&rsquo;s time keeping errors are
transferred back and forth between each other. Attempt to
configure drift correction for only one of them, and the
other&rsquo;s drift will be overlaid upon it.</p>

<p style="margin-left:11%; margin-top: 1em">This problem
can be avoided when configuring drift correction for the
System Clock by simply not shutting down the machine. This,
plus the fact that all of <b>hwclock</b>'s precision
(including calculating drift factors) depends upon the
System Clock&rsquo;s rate being correct, means that
configuration of the System Clock should be done first.</p>

<p style="margin-left:11%; margin-top: 1em">The System
Clock drift is corrected with the <b>adjtimex</b>(8)
command&rsquo;s <b>&minus;&minus;tick</b> and
<b>&minus;&minus;frequency</b> options. These two work
together: tick is the coarse adjustment and frequency is the
fine adjustment. (For systems that do not have an
<b>adjtimex</b> package, <b>ntptime &minus;f</b> <i>ppm</i>
may be used instead.)</p>

<p style="margin-left:11%; margin-top: 1em">Some Linux
distributions attempt to automatically calculate the System
Clock drift with <b>adjtimex</b>'s compare operation. Trying
to correct one drifting clock by using another drifting
clock as a reference is akin to a dog trying to catch its
own tail. Success may happen eventually, but great effort
and frustration will likely precede it. This automation may
yield an improvement over no configuration, but expecting
optimum results would be in error. A better choice for
manual configuration would be <b>adjtimex</b>'s
<b>&minus;&minus;log</b> options.</p>

<p style="margin-left:11%; margin-top: 1em">It may be more
effective to simply track the System Clock drift with
<b>sntp</b>, or <b>date &minus;Ins</b> and a precision
timepiece, and then calculate the correction manually.</p>

<p style="margin-left:11%; margin-top: 1em">After setting
the tick and frequency values, continue to test and refine
the adjustments until the System Clock keeps good time. See
<b>adjtimex</b>(2) for more information and the example
demonstrating manual drift calculations.</p>

<p style="margin-left:11%; margin-top: 1em">Once the System
Clock is ticking smoothly, move on to the Hardware
Clock.</p>

<p style="margin-left:11%; margin-top: 1em">As a rule, cold
drift will work best for most use cases. This should be true
even for 24/7 machines whose normal downtime consists of a
reboot. In that case the drift factor value makes little
difference. But on the rare occasion that the machine is
shut down for an extended period, then cold drift should
yield better results.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Steps to
calculate cold drift:</b></p>

<p style="margin-left:11%; margin-top: 1em">1</p>

<p style="margin-left:17%;"><b>Ensure that NTP daemon will
not be launched at startup.</b></p>

<p style="margin-left:11%; margin-top: 1em">2</p>

<p style="margin-left:17%;">The <i>System Clock</i> time
must be correct at shutdown!</p>

<p style="margin-left:11%; margin-top: 1em">3</p>

<p style="margin-left:17%;">Shut down the system.</p>

<p style="margin-left:11%; margin-top: 1em">4</p>

<p style="margin-left:17%;">Let an extended period pass
without changing the Hardware Clock.</p>

<p style="margin-left:11%; margin-top: 1em">5</p>

<p style="margin-left:17%;">Start the system.</p>

<p style="margin-left:11%; margin-top: 1em">6</p>

<p style="margin-left:17%;">Immediately use <b>hwclock</b>
to set the correct time, adding the
<b>&minus;&minus;update&minus;drift</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">Note: if step 6
uses <b>&minus;&minus;systohc</b>, then the System Clock
must be set correctly (step 6a) just before doing so.</p>

<p style="margin-left:11%; margin-top: 1em">Having
<b>hwclock</b> calculate the drift factor is a good starting
point, but for optimal results it will likely need to be
adjusted by directly editing the <i>/etc/adjtime</i> file.
Continue to test and refine the drift factor until the
Hardware Clock is corrected properly at startup. To check
this, first make sure that the System Time is correct before
shutdown and then use <b>sntp</b>, or <b>date &minus;Ins</b>
and a precision timepiece, immediately after startup.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LOCAL vs
UTC</b> <br>
Keeping the Hardware Clock in a local timescale causes
inconsistent daylight saving time results:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; If Linux
is running during a daylight saving time change, the time
written to the Hardware Clock will be adjusted for the
change.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; If Linux
is NOT running during a daylight saving time change, the
time read from the Hardware Clock will NOT be adjusted for
the change.</p>

<p style="margin-left:11%; margin-top: 1em">The Hardware
Clock on an ISA compatible system keeps only a date and
time, it has no concept of timezone nor daylight saving.
Therefore, when <b>hwclock</b> is told that it is in local
time, it assumes it is in the 'correct' local time and makes
no adjustments to the time read from it.</p>

<p style="margin-left:11%; margin-top: 1em">Linux handles
daylight saving time changes transparently only when the
Hardware Clock is kept in the UTC timescale. Doing so is
made easy for system administrators as <b>hwclock</b> uses
local time for its output and as the argument to the
<b>&minus;&minus;date</b> option.</p>

<p style="margin-left:11%; margin-top: 1em">POSIX systems,
like Linux, are designed to have the System Clock operate in
the UTC timescale. The Hardware Clock&rsquo;s purpose is to
initialize the System Clock, so also keeping it in UTC makes
sense.</p>

<p style="margin-left:11%; margin-top: 1em">Linux does,
however, attempt to accommodate the Hardware Clock being in
the local timescale. This is primarily for
dual&minus;booting with older versions of MS Windows. From
Windows 7 on, the RealTimeIsUniversal registry key is
supposed to be working properly so that its Hardware Clock
can be kept in UTC.</p>

<p style="margin-left:11%; margin-top: 1em"><b>POSIX vs
'RIGHT'</b> <br>
A discussion on date&minus;time configuration would be
incomplete without addressing timezones, this is mostly well
covered by <b>tzset</b>(3). One area that seems to have no
documentation is the 'right' directory of the Time Zone
Database, sometimes called tz or zoneinfo.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
separate databases in the zoneinfo system, posix and
'right'. 'Right' (now named zoneinfo&minus;leaps) includes
leap seconds and posix does not. To use the 'right' database
the System Clock must be set to (UTC + leap seconds), which
is equivalent to (TAI &minus; 10). This allows calculating
the exact number of seconds between two dates that cross a
leap second epoch. The System Clock is then converted to the
correct civil time, including UTC, by using the 'right'
timezone files which subtract the leap seconds. Note: this
configuration is considered experimental and is known to
have issues.</p>

<p style="margin-left:11%; margin-top: 1em">To configure a
system to use a particular database all of the files located
in its directory must be copied to the root of
<i>/usr/share/zoneinfo</i>. Files are never used directly
from the posix or 'right' subdirectories, e.g.,
TZ='<i>right/Europe/Dublin</i>'. This habit was becoming so
common that the upstream zoneinfo project restructured the
system&rsquo;s file tree by moving the posix and 'right'
subdirectories out of the zoneinfo directory and into
sibling directories:</p>


<p style="margin-left:11%; margin-top: 1em"><i>/usr/share/zoneinfo</i>,
<i>/usr/share/zoneinfo&minus;posix</i>,
<i>/usr/share/zoneinfo&minus;leaps</i></p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately,
some Linux distributions are changing it back to the old
tree structure in their packages. So the problem of system
administrators reaching into the 'right' subdirectory
persists. This causes the system timezone to be configured
to include leap seconds while the zoneinfo database is still
configured to exclude them. Then when an application such as
a World Clock needs the South_Pole timezone file; or an
email MTA, or <b>hwclock</b> needs the UTC timezone file;
they fetch it from the root of <i>/usr/share/zoneinfo</i> ,
because that is what they are supposed to do. Those files
exclude leap seconds, but the System Clock now includes
them, causing an incorrect time conversion.</p>

<p style="margin-left:11%; margin-top: 1em">Attempting to
mix and match files from these separate databases will not
work, because they each require the System Clock to use a
different timescale. The zoneinfo database must be
configured to use either posix or 'right', as described
above, or by assigning a database path to the <i>TZDIR</i>
environment variable.</p>

<h2>EXIT STATUS
<a name="EXIT STATUS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">One of the
following exit values will be returned:</p>


<p style="margin-left:11%; margin-top: 1em"><b>EXIT_SUCCESS</b>
('0' on POSIX systems)</p>

<p style="margin-left:17%;">Successful program
execution.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EXIT_FAILURE</b>
('1' on POSIX systems)</p>

<p style="margin-left:17%;">The operation failed or the
command syntax was not valid.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>TZ</b></p>

<p style="margin-left:17%;">If this variable is set its
value takes precedence over the system configured
timezone.</p>


<p style="margin-left:11%; margin-top: 1em"><b>TZDIR</b></p>

<p style="margin-left:17%;">If this variable is set its
value takes precedence over the system configured timezone
database directory path.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i>/etc/adjtime</i></p>

<p style="margin-left:17%;">The configuration and state
file for <b>hwclock</b>. See also
<b>adjtime_config</b>(5).</p>


<p style="margin-left:11%; margin-top: 1em"><i>/etc/localtime</i></p>

<p style="margin-left:17%;">The system timezone file.</p>


<p style="margin-left:11%; margin-top: 1em"><i>/usr/share/zoneinfo/</i></p>

<p style="margin-left:17%;">The system timezone database
directory.</p>

<p style="margin-left:11%; margin-top: 1em">Device files
<b>hwclock</b> may try for Hardware Clock access:
<i>/dev/rtc0 /dev/rtc /dev/misc/rtc /dev/efirtc
/dev/misc/efirtc</i></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><i><b>date</b></i>(1),
<b>adjtime_config</b>(5), <b>adjtimex</b>(8),
<b>gettimeofday</b>(2), <b>settimeofday</b>(2),
<b>crontab</b>(1p), <b>tzset</b>(3)</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Written by
<i>Bryan Henderson</i>
&lt;bryanh@giraffe&minus;data.com&gt;, September 1996, based
on work done on the <b>clock</b>(8) program by Charles
Hedrick, Rob Hooft, and Harald Koenig. See the source code
for complete history and credits.</p>

<h2>REPORTING BUGS
<a name="REPORTING BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">For bug
reports, use the issue tracker at
&lt;https://github.com/util&minus;linux/util&minus;linux/issues&gt;.</p>

<h2>AVAILABILITY
<a name="AVAILABILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>hwclock</b> command is part of the util&minus;linux
package which can be downloaded from <i>Linux Kernel
Archive</i>
&lt;https://www.kernel.org/pub/linux/utils/util&minus;linux/&gt;.</p>
<hr>
</body>
</html>
