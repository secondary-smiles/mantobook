<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:14 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::vector&lt; _Tp, _Alloc &gt;</title>

</head>
<body>
<h1>std::vector</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::vector&lt;
_Tp, _Alloc &gt; &minus; A standard container which offers
fixed time access to individual elements in any order.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;vector&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::_Vector_base&lt; _Tp, _Alloc &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Inherited by
<b>std::match_results&lt; _Bi_iter, _Alloc &gt;</b>
<tt>[private]</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Alloc
<b>allocator_type</b> <br>
typedef __gnu_cxx::__normal_iterator&lt; const_pointer,
<b>vector</b> &gt; <b>const_iterator</b> <br>
typedef _Alloc_traits::const_pointer <b>const_pointer</b>
<br>
typedef _Alloc_traits::const_reference
<b>const_reference</b> <br>
typedef <b>std::reverse_iterator</b>&lt; const_iterator &gt;
<b>const_reverse_iterator</b> <br>
typedef ptrdiff_t <b>difference_type</b> <br>
typedef __gnu_cxx::__normal_iterator&lt; pointer,
<b>vector</b> &gt; <b>iterator</b> <br>
typedef _Base::pointer <b>pointer</b> <br>
typedef _Alloc_traits::reference <b>reference</b> <br>
typedef <b>std::reverse_iterator</b>&lt; iterator &gt;
<b>reverse_iterator</b> <br>
typedef size_t <b>size_type</b> <br>
typedef _Tp <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>vector</b> ()=default <br>
Creates a vector with no elements. <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr
<b>vector</b> (_InputIterator __first, _InputIterator
__last, const allocator_type &amp;__a=allocator_type()) <br>
Builds a vector from a range. <br>
constexpr <b>vector</b> (const allocator_type &amp;__a)
noexcept <br>
Creates a vector with no elements. <br>
constexpr <b>vector</b> (const <b>vector</b> &amp;__x) <br>
Vector copy constructor. <br>
constexpr <b>vector</b> (const <b>vector</b> &amp;__x, const
__type_identity_t&lt; allocator_type &gt; &amp;__a) <br>
Copy constructor with alternative allocator. <br>
constexpr <b>vector</b> (<b>initializer_list</b>&lt;
value_type &gt; __l, const allocator_type
&amp;__a=allocator_type()) <br>
Builds a vector from an initializer list. <br>
constexpr <b>vector</b> (size_type __n, const allocator_type
&amp;__a=allocator_type()) <br>
Creates a vector with default constructed elements. <br>
constexpr <b>vector</b> (size_type __n, const value_type
&amp;__value, const allocator_type
&amp;__a=allocator_type()) <br>
Creates a vector with copies of an exemplar element. <b><br>
vector</b> (<b>vector</b> &amp;&amp;) noexcept=default <br>
Vector move constructor. <br>
constexpr <b>vector</b> (<b>vector</b> &amp;&amp;__rv, const
__type_identity_t&lt; allocator_type &gt; &amp;__m)
noexcept(noexcept(<b>vector</b>(<b>std::declval</b>&lt;
<b>vector</b> &amp;&amp; &gt;(), <b>std::declval</b>&lt;
const allocator_type &amp; &gt;(), <b>std::declval</b>&lt;
typename <b>_Alloc_traits::is_always_equal</b> &gt;())))
<br>
Move constructor with alternative allocator. <br>
constexpr <b>~vector</b> () noexcept <br>
template&lt;typename... _Args&gt; constexpr auto
<b>_M_emplace_aux</b> (const_iterator __position, _Args
&amp;&amp;... __args) &minus;&gt; iterator <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr
void <b>assign</b> (_InputIterator __first, _InputIterator
__last) <br>
Assigns a range to a vector. <br>
constexpr void <b>assign</b> (<b>initializer_list</b>&lt;
value_type &gt; __l) <br>
Assigns an initializer list to a vector. <br>
constexpr void <b>assign</b> (size_type __n, const
value_type &amp;__val) <br>
Assigns a given value to a vector. <br>
constexpr reference <b>at</b> (size_type __n) <br>
Provides access to the data contained in the vector. <br>
constexpr const_reference <b>at</b> (size_type __n) const
<br>
Provides access to the data contained in the vector. <br>
constexpr const_reference <b>back</b> () const noexcept <br>
constexpr reference <b>back</b> () noexcept <br>
constexpr const_iterator <b>begin</b> () const noexcept <br>
constexpr iterator <b>begin</b> () noexcept <br>
constexpr size_type <b>capacity</b> () const noexcept <br>
constexpr const_iterator <b>cbegin</b> () const noexcept
<br>
constexpr const_iterator <b>cend</b> () const noexcept <br>
constexpr void <b>clear</b> () noexcept <br>
constexpr <b>const_reverse_iterator crbegin</b> () const
noexcept <br>
constexpr <b>const_reverse_iterator crend</b> () const
noexcept <br>
constexpr const _Tp * <b>data</b> () const noexcept <br>
constexpr _Tp * <b>data</b> () noexcept <br>
template&lt;typename... _Args&gt; constexpr iterator
<b>emplace</b> (const_iterator __position, _Args
&amp;&amp;... __args) <br>
Inserts an object in vector before specified iterator. <br>
template&lt;typename... _Args&gt; constexpr reference
<b>emplace_back</b> (_Args &amp;&amp;... __args) <br>
constexpr bool <b>empty</b> () const noexcept <br>
constexpr const_iterator <b>end</b> () const noexcept <br>
constexpr iterator <b>end</b> () noexcept <br>
constexpr iterator <b>erase</b> (const_iterator __first,
const_iterator __last) <br>
Remove a range of elements. <br>
constexpr iterator <b>erase</b> (const_iterator __position)
<br>
Remove element at given position. <br>
constexpr const_reference <b>front</b> () const noexcept
<br>
constexpr reference <b>front</b> () noexcept <br>
constexpr allocator_type <b>get_allocator</b> () const
noexcept <br>
Get a copy of the memory allocation object. <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr
iterator <b>insert</b> (const_iterator __position,
_InputIterator __first, _InputIterator __last) <br>
Inserts a range into the vector. <br>
constexpr iterator <b>insert</b> (const_iterator __position,
const value_type &amp;__x) <br>
Inserts given value into vector before specified iterator.
<br>
constexpr iterator <b>insert</b> (const_iterator __position,
<b>initializer_list</b>&lt; value_type &gt; __l) <br>
Inserts an initializer_list into the vector. <br>
constexpr iterator <b>insert</b> (const_iterator __position,
size_type __n, const value_type &amp;__x) <br>
Inserts a number of copies of given data into the vector.
<br>
constexpr iterator <b>insert</b> (const_iterator __position,
value_type &amp;&amp;__x) <br>
Inserts given rvalue into vector before specified iterator.
<br>
constexpr size_type <b>max_size</b> () const noexcept <br>
constexpr <b>vector</b> &amp; <b>operator=</b> (const
<b>vector</b> &amp;__x) <br>
Vector assignment operator. <br>
constexpr <b>vector</b> &amp; <b>operator=</b>
(<b>initializer_list</b>&lt; value_type &gt; __l) <br>
Vector list assignment operator. <br>
constexpr <b>vector</b> &amp; <b>operator=</b>
(<b>vector</b> &amp;&amp;__x)
noexcept(_Alloc_traits::_S_nothrow_move()) <br>
Vector move assignment operator. <br>
constexpr const_reference <b>operator[]</b> (size_type __n)
const noexcept <br>
Subscript access to the data contained in the vector. <br>
constexpr reference <b>operator[]</b> (size_type __n)
noexcept <br>
Subscript access to the data contained in the vector. <br>
constexpr void <b>pop_back</b> () noexcept <br>
Removes last element. <br>
constexpr void <b>push_back</b> (const value_type &amp;__x)
<br>
Add data to the end of the vector. <br>
constexpr void <b>push_back</b> (value_type &amp;&amp;__x)
<br>
constexpr <b>const_reverse_iterator rbegin</b> () const
noexcept <br>
constexpr <b>reverse_iterator rbegin</b> () noexcept <br>
constexpr <b>const_reverse_iterator rend</b> () const
noexcept <br>
constexpr <b>reverse_iterator rend</b> () noexcept <br>
constexpr void <b>reserve</b> (size_type __n) <br>
Attempt to preallocate enough memory for specified number of
elements. <br>
constexpr void <b>resize</b> (size_type __new_size) <br>
Resizes the vector to the specified number of elements. <br>
constexpr void <b>resize</b> (size_type __new_size, const
value_type &amp;__x) <br>
Resizes the vector to the specified number of elements. <br>
constexpr void <b>shrink_to_fit</b> () <br>
constexpr size_type <b>size</b> () const noexcept <br>
constexpr void <b>swap</b> (<b>vector</b> &amp;__x) noexcept
<br>
Swaps data with another vector.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;">constexpr pointer
<b>_M_allocate</b> (size_t __n) <br>
template&lt;typename _ForwardIterator &gt; constexpr pointer
<b>_M_allocate_and_copy</b> (size_type __n, _ForwardIterator
__first, _ForwardIterator __last) <br>
template&lt;typename _ForwardIterator &gt; constexpr void
<b>_M_assign_aux</b> (_ForwardIterator __first,
_ForwardIterator __last, <b>std::forward_iterator_tag</b>)
<br>
template&lt;typename _InputIterator &gt; constexpr void
<b>_M_assign_aux</b> (_InputIterator __first, _InputIterator
__last, <b>std::input_iterator_tag</b>) <br>
template&lt;typename _InputIterator &gt; constexpr void
<b>_M_assign_dispatch</b> (_InputIterator __first,
_InputIterator __last, __false_type) <br>
template&lt;typename _Integer &gt; constexpr void
<b>_M_assign_dispatch</b> (_Integer __n, _Integer __val,
__true_type) <br>
constexpr size_type <b>_M_check_len</b> (size_type __n,
const char *__s) const <br>
constexpr void <b>_M_create_storage</b> (size_t __n) <br>
constexpr void <b>_M_deallocate</b> (pointer __p, size_t
__n) <br>
constexpr void <b>_M_default_append</b> (size_type __n) <br>
constexpr void <b>_M_default_initialize</b> (size_type __n)
<br>
template&lt;typename... _Args&gt; constexpr iterator
<b>_M_emplace_aux</b> (const_iterator __position, _Args
&amp;&amp;... __args) <br>
constexpr iterator <b>_M_emplace_aux</b> (const_iterator
__position, value_type &amp;&amp;__v) <br>
constexpr iterator <b>_M_erase</b> (iterator __first,
iterator __last) <br>
constexpr iterator <b>_M_erase</b> (iterator __position)
<br>
constexpr void <b>_M_erase_at_end</b> (pointer __pos)
noexcept <br>
constexpr void <b>_M_fill_assign</b> (size_type __n, const
value_type &amp;__val) <br>
constexpr void <b>_M_fill_initialize</b> (size_type __n,
const value_type &amp;__value) <br>
constexpr void <b>_M_fill_insert</b> (iterator __pos,
size_type __n, const value_type &amp;__x) <br>
constexpr const _Tp_alloc_type &amp;
<b>_M_get_Tp_allocator</b> () const noexcept <br>
constexpr _Tp_alloc_type &amp; <b>_M_get_Tp_allocator</b> ()
noexcept <br>
template&lt;typename _Arg &gt; constexpr void
<b>_M_insert_aux</b> (iterator __position, _Arg
&amp;&amp;__arg) <br>
template&lt;typename _InputIterator &gt; constexpr void
<b>_M_insert_dispatch</b> (iterator __pos, _InputIterator
__first, _InputIterator __last, __false_type) <br>
template&lt;typename _Integer &gt; constexpr void
<b>_M_insert_dispatch</b> (iterator __pos, _Integer __n,
_Integer __val, __true_type) <br>
constexpr iterator <b>_M_insert_rval</b> (const_iterator
__position, value_type &amp;&amp;__v) <br>
constexpr void <b>_M_range_check</b> (size_type __n) const
<br>
Safety check used only from at(). <br>
template&lt;typename _ForwardIterator &gt; constexpr void
<b>_M_range_initialize</b> (_ForwardIterator __first,
_ForwardIterator __last, <b>std::forward_iterator_tag</b>)
<br>
template&lt;typename _InputIterator &gt; constexpr void
<b>_M_range_initialize</b> (_InputIterator __first,
_InputIterator __last, <b>std::input_iterator_tag</b>) <br>
template&lt;typename _ForwardIterator &gt; constexpr void
<b>_M_range_insert</b> (iterator __pos, _ForwardIterator
__first, _ForwardIterator __last,
<b>std::forward_iterator_tag</b>) <br>
template&lt;typename _InputIterator &gt; constexpr void
<b>_M_range_insert</b> (iterator __pos, _InputIterator
__first, _InputIterator __last,
<b>std::input_iterator_tag</b>) <br>
template&lt;typename... _Args&gt; constexpr void
<b>_M_realloc_insert</b> (iterator __position, _Args
&amp;&amp;... __args) <br>
constexpr bool <b>_M_shrink_to_fit</b> ()</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Protected Member Functions</b></p>

<p style="margin-left:17%;">static constexpr size_type
<b>_S_check_init_len</b> (size_type __n, const
allocator_type &amp;__a) <br>
static constexpr size_type <b>_S_max_size</b> (const
_Tp_alloc_type &amp;__a) noexcept</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Attributes</b></p>

<p style="margin-left:17%;">_Vector_impl <b>_M_impl</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;</b>
<br>
class std::vector&lt; _Tp, _Alloc &gt;&quot;A standard
container which offers fixed time access to individual
elements in any order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++98</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_Tp</i> Type of element.
<i><br>
_Alloc</i> Allocator type, defaults to
allocator&lt;_Tp&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Meets the
requirements of a <tt>container</tt>, a <tt>reversible
container</tt>, and a <tt>sequence</tt>, including the
<tt>optional sequence requirements</tt> with the exception
of <tt>push_front</tt> and <tt>pop_front</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In some
terminology a vector can be described as a dynamic C-style
array, it offers fast and efficient access to individual
elements in any order and saves the user from worrying about
memory and size allocation. Subscripting ( [] ) access is
also provided as with C-style arrays.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::vector&lt; _Tp, _Alloc &gt;::vector ()</b>
<tt>[default]</tt> <br>
Creates a vector with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr std::vector&lt; _Tp, _Alloc &gt;::vector (const
allocator_type &amp; __a)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Creates a vector with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> An allocator
object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr std::vector&lt; _Tp, _Alloc &gt;::vector
(size_type __n, const allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Creates a vector with default constructed elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The number of
elements to initially create. <i><br>
__a</i> An allocator.</p>

<p style="margin-left:11%; margin-top: 1em">This
constructor fills the vector with <i>__n</i> default
constructed elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr std::vector&lt; _Tp, _Alloc &gt;::vector
(size_type __n, const value_type &amp; __value, const
allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Creates a vector with copies of an exemplar element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The number of
elements to initially create. <i><br>
__value</i> An element to copy. <i><br>
__a</i> An allocator.</p>

<p style="margin-left:11%; margin-top: 1em">This
constructor fills the vector with <i>__n</i> copies of
<i>__value</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr std::vector&lt; _Tp, _Alloc &gt;::vector (const
vector&lt; _Tp, _Alloc &gt; &amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Vector copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A vector of
identical element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">All the
elements of <i>__x</i> are copied, but any unused capacity
in <i>__x</i> will not be copied (i.e. capacity() == size()
in the new vector).</p>

<p style="margin-left:11%; margin-top: 1em">The
newly-created vector uses a copy of the allocator object
used by <i>__x</i> (unless the allocator traits dictate a
different object).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::vector&lt; _Tp, _Alloc &gt;::vector (vector&lt; _Tp,
_Alloc &gt; &amp;&amp;)</b> <tt>[default]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Vector move constructor. The newly-created vector contains
the exact contents of the moved instance. The contents of
the moved instance are a valid, but unspecified vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr std::vector&lt; _Tp, _Alloc &gt;::vector (const
vector&lt; _Tp, _Alloc &gt; &amp; __x, const
__type_identity_t&lt; allocator_type &gt; &amp; __a)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Copy constructor with alternative allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr std::vector&lt; _Tp, _Alloc &gt;::vector
(vector&lt; _Tp, _Alloc &gt; &amp;&amp; __rv, const
__type_identity_t&lt; allocator_type &gt; &amp; __m)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Move constructor with alternative allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr std::vector&lt; _Tp, _Alloc &gt;::vector
(initializer_list&lt; value_type &gt; __l, const
allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Builds a vector from an initializer list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list.
<i><br>
__a</i> An allocator.</p>

<p style="margin-left:11%; margin-top: 1em">Create a vector
consisting of copies of the elements in the initializer_list
<i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This will call
the element type&rsquo;s copy constructor N times (where N
is <i>__l.size()</i>) and do no memory reallocation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr
std::vector&lt; _Tp, _Alloc &gt;::vector (_InputIterator
__first, _InputIterator __last, const allocator_type &amp;
__a =</b> <tt>allocator_type()</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Builds a vector from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__a</i> An allocator.</p>

<p style="margin-left:11%; margin-top: 1em">Create a vector
consisting of copies of the elements from [first,last).</p>

<p style="margin-left:11%; margin-top: 1em">If the
iterators are forward, bidirectional, or random-access, then
this will call the elements&rsquo; copy constructor N times
(where N is distance(first,last)) and do no memory
reallocation. But if only input iterators are used, then
this will do at most 2N calls to the copy constructor, and
logN memory reallocations.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__iterator_category()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr std::vector&lt; _Tp, _Alloc &gt;::~vector ()</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The dtor only erases the elements, and note that if the
elements themselves are pointers, the pointed-to memory is
not touched in any way. Managing the pointer is the
user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::_Destroy()</b>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _ForwardIterator &gt; constexpr pointer
std::vector&lt; _Tp, _Alloc &gt;::_M_allocate_and_copy
(size_type __n, _ForwardIterator __first, _ForwardIterator
__last)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory expansion handler. Uses the member allocation
function to obtain <i>n</i> bytes of memory, and then copies
[first,last) into it.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc
&gt;::_M_range_check (size_type __n) const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[protected]</tt> <br>
Safety check used only from at().</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::vector&lt; _Tp, _Alloc &gt;::at()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr
void std::vector&lt; _Tp, _Alloc &gt;::assign
(_InputIterator __first, _InputIterator __last)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Assigns a range to a vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a vector with copies of the elements in the range
[__first,__last).</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the vector and that the
resulting vector&rsquo;s size is the same as the number of
elements assigned.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__iterator_category()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc &gt;::assign
(initializer_list&lt; value_type &gt; __l)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Assigns an initializer list to a vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a vector with copies of the elements in the
initializer list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the vector and that the
resulting vector&rsquo;s size is the same as the number of
elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc &gt;::assign
(size_type __n, const value_type &amp; __val)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Assigns a given value to a vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> Number of elements
to be assigned. <i><br>
__val</i> Value to be assigned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a vector with <i>__n</i> copies of the given value.
Note that the assignment completely changes the vector and
that the resulting vector&rsquo;s size is the same as the
number of elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr reference std::vector&lt; _Tp, _Alloc &gt;::at
(size_type __n)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Provides access to the data contained in the vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read/write reference to
data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__n</i> is an invalid index.</p>

<p style="margin-left:11%; margin-top: 1em">This function
provides for safer data access. The parameter is first
checked that it is in the range of the vector. The function
throws out_of_range if the check fails.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc
&gt;::_M_range_check()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_reference std::vector&lt; _Tp, _Alloc
&gt;::at (size_type __n) const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Provides access to the data contained in the vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) reference
to data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__n</i> is an invalid index.</p>

<p style="margin-left:11%; margin-top: 1em">This function
provides for safer data access. The parameter is first
checked that it is in the range of the vector. The function
throws out_of_range if the check fails.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc
&gt;::_M_range_check()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_reference std::vector&lt; _Tp, _Alloc
&gt;::back () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reference to the data at the
last element of the vector.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr reference std::vector&lt; _Tp, _Alloc &gt;::back
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reference to the data at the last
element of the vector.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::piecewise_constant_distribution&lt; _RealType
&gt;::max()</b>, and
<b>std::piecewise_linear_distribution&lt; _RealType
&gt;::max()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_iterator std::vector&lt; _Tp, _Alloc
&gt;::begin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the vector. Iteration is done in ordinary
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr iterator std::vector&lt; _Tp, _Alloc &gt;::begin
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points to the first
element in the vector. Iteration is done in ordinary element
order.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::vector&lt; _Tp, _Alloc &gt;::vector()</b>,
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::begin()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::crend()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::empty()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::erase()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::front()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::insert()</b>,
<b>__gnu_parallel::multiway_merge_exact_splitting()</b>,
<b>std::operator&lt;()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::operator=()</b>, <b>std::operator==()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::rend()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr size_type std::vector&lt; _Tp, _Alloc
&gt;::capacity () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the total number of elements that the vector can
hold before needing to allocate more memory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_iterator std::vector&lt; _Tp, _Alloc
&gt;::cbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the vector. Iteration is done in ordinary
element order.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::vector&lt; _Tp, _Alloc &gt;::erase()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::insert()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_iterator std::vector&lt; _Tp, _Alloc
&gt;::cend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the vector. Iteration is done in
ordinary element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc &gt;::clear
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Erases all the elements. Note that this function only erases
the elements, and that if the elements themselves are
pointers, the pointed-to memory is not touched in any way.
Managing the pointer is the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_reverse_iterator std::vector&lt; _Tp, _Alloc
&gt;::crbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last element in the vector. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_reverse_iterator std::vector&lt; _Tp, _Alloc
&gt;::crend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to one before the first element in the vector. Iteration is
done in reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr _Tp * std::vector&lt; _Tp, _Alloc &gt;::data
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a pointer such that [data(), data() + size()) is a
valid range. For a non-empty vector, data() ==
&amp;front().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename... _Args&gt; constexpr iterator
std::vector&lt; _Tp, _Alloc &gt;::emplace (const_iterator
__position, _Args &amp;&amp;... __args)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Inserts an object in vector before specified iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the vector. <i><br>
__args</i> Arguments.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert an object of type T constructed with
T(std::forward&lt;Args&gt;(args)...) before the specified
location. Note that this kind of operation could be
expensive for a vector and if it is frequently used the user
should consider using std::list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr bool std::vector&lt; _Tp, _Alloc &gt;::empty ()
const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns true if the vector is empty. (Thus begin() would
equal end().)</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::piecewise_constant_distribution&lt; _RealType
&gt;::densities()</b>,
<b>std::piecewise_linear_distribution&lt; _RealType
&gt;::densities()</b>, <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::end()</b>,
<b>std::piecewise_constant_distribution&lt; _RealType
&gt;::intervals()</b>,
<b>std::piecewise_linear_distribution&lt; _RealType
&gt;::intervals()</b>, <b>std::discrete_distribution&lt;
_IntType &gt;::max()</b>,
<b>std::piecewise_constant_distribution&lt; _RealType
&gt;::max()</b>, <b>std::piecewise_linear_distribution&lt;
_RealType &gt;::max()</b>,
<b>std::piecewise_constant_distribution&lt; _RealType
&gt;::min()</b>, <b>std::piecewise_linear_distribution&lt;
_RealType &gt;::min()</b>, <b>std::discrete_distribution&lt;
_IntType &gt;::probabilities()</b>,
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::ready()</b>, and <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_iterator std::vector&lt; _Tp, _Alloc
&gt;::end () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the vector. Iteration is done in
ordinary element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr iterator std::vector&lt; _Tp, _Alloc &gt;::end
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points one past the last
element in the vector. Iteration is done in ordinary element
order.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::vector&lt; _Tp, _Alloc &gt;::vector()</b>,
<b>std::vector&lt; _Tp, _Alloc &gt;::back()</b>,
<b>std::vector&lt; _Tp, _Alloc &gt;::crbegin()</b>,
<b>std::vector&lt; _Tp, _Alloc &gt;::empty()</b>,
<b>std::match_results&lt; _Bi_iter, _Alloc &gt;::end()</b>,
<b>__gnu_parallel::multiway_merge_exact_splitting()</b>,
<b>std::operator&lt;()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::operator=()</b>, <b>std::operator==()</b>,
<b>std::vector&lt; _Tp, _Alloc &gt;::push_back()</b>,
<b>std::vector&lt; _Tp, _Alloc &gt;::rbegin()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::resize()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr iterator std::vector&lt; _Tp, _Alloc &gt;::erase
(const_iterator __first, const_iterator __last)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Remove a range of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the first element to be erased. <i><br>
__last</i> Iterator pointing to one past the last element to
be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element pointed to by <i>__last</i> prior to erasing (or
end()).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will erase the elements in the range [__first,__last) and
shorten the vector accordingly.</p>

<p style="margin-left:11%; margin-top: 1em">Note This
operation could be expensive and if it is frequently used
the user should consider using std::list. The user is also
cautioned that this function only erases the elements, and
that if the elements themselves are pointers, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::cbegin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr iterator std::vector&lt; _Tp, _Alloc &gt;::erase
(const_iterator __position)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Remove element at given position.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> Iterator
pointing to element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
next element (or end()).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will erase the element at the given position and thus
shorten the vector by one.</p>

<p style="margin-left:11%; margin-top: 1em">Note This
operation could be expensive and if it is frequently used
the user should consider using std::list. The user is also
cautioned that this function only erases the element, and
that if the element is itself a pointer, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::cbegin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_reference std::vector&lt; _Tp, _Alloc
&gt;::front () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reference to the data at the
first element of the vector.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr reference std::vector&lt; _Tp, _Alloc &gt;::front
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reference to the data at the first
element of the vector.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::piecewise_constant_distribution&lt; _RealType
&gt;::min()</b>, and
<b>std::piecewise_linear_distribution&lt; _RealType
&gt;::min()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr allocator_type std::_Vector_base&lt; _Tp, _Alloc
&gt;::get_allocator () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Get a copy of the memory allocation object.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::get_allocator()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr
iterator std::vector&lt; _Tp, _Alloc &gt;::insert
(const_iterator __position, _InputIterator __first,
_InputIterator __last)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Inserts a range into the vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the vector. <i><br>
__first</i> An input iterator. <i><br>
__last</i> An input iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert copies of the data in the range [__first,__last)
into the vector before the location specified by
<i>pos</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
kind of operation could be expensive for a vector and if it
is frequently used the user should consider using
std::list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__iterator_category()</b>, <b>std::vector&lt; _Tp,
_Alloc &gt;::begin()</b>, and <b>std::vector&lt; _Tp, _Alloc
&gt;::cbegin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; constexpr vector&lt; _Tp, _Alloc
&gt;::iterator vector::insert (const_iterator __position,
const value_type &amp; __x)</b> <tt>[constexpr]</tt> <br>
Inserts given value into vector before specified
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the vector. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a copy of the given value before the specified
location. Note that this kind of operation could be
expensive for a vector and if it is frequently used the user
should consider using std::list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::begin()</b>, <b>std::cbegin()</b>,
<b>std::end()</b>, and <b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr iterator std::vector&lt; _Tp, _Alloc &gt;::insert
(const_iterator __position, initializer_list&lt; value_type
&gt; __l)</b> <tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt>
<br>
Inserts an initializer_list into the vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
into the vector. <i><br>
__l</i> An initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert copies of the data in the initializer_list
<i>l</i> into the vector before the location specified by
<i>position</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
kind of operation could be expensive for a vector and if it
is frequently used the user should consider using
std::list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::cbegin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr iterator std::vector&lt; _Tp, _Alloc &gt;::insert
(const_iterator __position, size_type __n, const value_type
&amp; __x)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Inserts a number of copies of given data into the
vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the vector. <i><br>
__n</i> Number of elements to be inserted. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a specified number of copies of the given data
before the location specified by <i>position</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
kind of operation could be expensive for a vector and if it
is frequently used the user should consider using
std::list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::cbegin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr iterator std::vector&lt; _Tp, _Alloc &gt;::insert
(const_iterator __position, value_type &amp;&amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Inserts given rvalue into vector before specified
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the vector. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a copy of the given rvalue before the specified
location. Note that this kind of operation could be
expensive for a vector and if it is frequently used the user
should consider using std::list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr size_type std::vector&lt; _Tp, _Alloc
&gt;::max_size () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the size() of the largest possible vector.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::max_size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; constexpr vector&lt; _Tp, _Alloc
&gt; &amp; vector::operator= (const vector&lt; _Tp, _Alloc
&gt; &amp; __x)</b> <tt>[constexpr]</tt> <br>
Vector assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A vector of
identical element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">All the
elements of <i>__x</i> are copied, but any unused capacity
in <i>__x</i> will not be copied.</p>

<p style="margin-left:11%; margin-top: 1em">Whether the
allocator is copied depends on the allocator traits.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>, <b>std::_Destroy()</b>,
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>,
<b>std::begin()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::end()</b>, <b>std::end()</b>, <b>std::vector&lt; _Tp,
_Alloc &gt;::size()</b>, and <b>std::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr vector &amp; std::vector&lt; _Tp, _Alloc
&gt;::operator= (initializer_list&lt; value_type &gt;
__l)</b> <tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Vector list assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a vector with copies of the elements in the
initializer list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the vector and that the
resulting vector&rsquo;s size is the same as the number of
elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr vector &amp; std::vector&lt; _Tp, _Alloc
&gt;::operator= (vector&lt; _Tp, _Alloc &gt; &amp;&amp;
__x)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Vector move assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A vector of
identical element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">The contents of
<i>__x</i> are moved into this vector (without copying, if
the allocators permit it). Afterwards <i>__x</i> is a valid,
but unspecified vector.</p>

<p style="margin-left:11%; margin-top: 1em">Whether the
allocator is moved depends on the allocator traits.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_reference std::vector&lt; _Tp, _Alloc
&gt;::operator[] (size_type __n) const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Subscript access to the data contained in the vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) reference
to data.</p>

<p style="margin-left:11%; margin-top: 1em">This operator
allows for easy, array-style, data access. Note that data
access with this operator is unchecked and out_of_range
lookups are not defined. (For checked lookups see at().)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr reference std::vector&lt; _Tp, _Alloc
&gt;::operator[] (size_type __n)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Subscript access to the data contained in the vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read/write reference to
data.</p>

<p style="margin-left:11%; margin-top: 1em">This operator
allows for easy, array-style, data access. Note that data
access with this operator is unchecked and out_of_range
lookups are not defined. (For checked lookups see at().)</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator[]()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc &gt;::pop_back
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Removes last element. This is a typical stack operation. It
shrinks the vector by one.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
data is returned, and if the last element&rsquo;s data is
needed, it should be retrieved before pop_back() is
called.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc &gt;::push_back
(const value_type &amp; __x)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Add data to the end of the vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Data to be
added.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical stack operation. The function creates an element at
the end of the vector and assigns the given data to it. Due
to the nature of a vector this operation can be done in
constant time if the vector has preallocated space
available.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_reverse_iterator std::vector&lt; _Tp, _Alloc
&gt;::rbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last element in the vector. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr reverse_iterator std::vector&lt; _Tp, _Alloc
&gt;::rbegin ()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to the
last element in the vector. Iteration is done in reverse
element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr const_reverse_iterator std::vector&lt; _Tp, _Alloc
&gt;::rend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to one before the first element in the vector. Iteration is
done in reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr reverse_iterator std::vector&lt; _Tp, _Alloc
&gt;::rend ()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to one
before the first element in the vector. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; constexpr void vector::reserve
(size_type __n)</b> <tt>[constexpr]</tt> <br>
Attempt to preallocate enough memory for specified number of
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> Number of elements
required.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::length_error</i> If
<i>n</i> exceeds <tt>max_size()</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to reserve enough memory for the vector to hold the
specified number of elements. If the number requested is
more than max_size(), length_error is thrown.</p>

<p style="margin-left:11%; margin-top: 1em">The advantage
of this function is that if optimal code is a necessity and
the user can determine the number of elements that will be
required, the user can reserve the memory in advance, and
thus prevent a possible reallocation of memory and copying
of vector data.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::_Destroy()</b>, and <b>std::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc &gt;::resize
(size_type __new_size)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Resizes the vector to the specified number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__new_size</i> Number of
elements the vector should contain.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will resize the vector to the specified number of elements.
If the number is smaller than the vector&rsquo;s current
size the vector is truncated, otherwise default constructed
elements are appended.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_parallel::__shrink_and_double()</b>, and
<b>__gnu_parallel::multiway_merge_exact_splitting()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc &gt;::resize
(size_type __new_size, const value_type &amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Resizes the vector to the specified number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__new_size</i> Number of
elements the vector should contain. <i><br>
__x</i> Data with which new elements should be
populated.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will resize the vector to the specified number of elements.
If the number is smaller than the vector&rsquo;s current
size the vector is truncated, otherwise the vector is
extended and new elements are populated with given data.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc
&gt;::shrink_to_fit ()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
A non-binding request to reduce capacity() to size().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr size_type std::vector&lt; _Tp, _Alloc &gt;::size
() const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of elements in the vector.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_parallel::__shrink()</b>,
<b>__gnu_parallel::__shrink_and_double()</b>,
<b>std::vector&lt; _Tp, _Alloc &gt;::_M_range_check()</b>,
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::empty()</b>, <b>__gnu_parallel::list_partition()</b>,
<b>std::discrete_distribution&lt; _IntType &gt;::max()</b>,
<b>std::vector&lt; _Tp, _Alloc &gt;::operator=()</b>,
<b>std::operator==()</b>, <b>std::vector&lt; _Tp, _Alloc
&gt;::resize()</b>, and <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
constexpr void std::vector&lt; _Tp, _Alloc &gt;::swap
(vector&lt; _Tp, _Alloc &gt; &amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Swaps data with another vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A vector of the same
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">This exchanges
the elements between two vectors in constant time. (Three
pointers, so it should be quite fast.) Note that the global
std::swap() function is specialized such that
std::swap(v1,v2) will feed to this function.</p>

<p style="margin-left:11%; margin-top: 1em">Whether the
allocators are swapped depends on the allocator traits.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::swap()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
