<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:35 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_Publish_name</title>

</head>
<body>
<h1>MPI_Publish_name</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_Publish_name</b>
&minus; Publishes a service name associated with a port</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Publish_name(const char *<i>service_name</i>,
MPI_Info <i>info</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>const char *<i>port_name</i>)</p></td></tr>
</table>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_PUBLISH_NAME(<i>SERVICE_NAME, INFO, PORT_NAME,
IERROR</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>CHARACTER*(*)</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">


<p><i>SERVICE_NAME, PORT_NAME</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">
</td>
<td width="62%">


<p><i>INFO, IERROR</i></p></td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_Publish_name(<i>service_name</i>, <i>info</i>,
<i>port_name</i>, <i>ierror</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Info), INTENT(IN) :: <i>info</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>CHARACTER(LEN=*), INTENT(IN) :: <i>service_name</i>,
<i>port_name</i></p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
void MPI::Publish_name(const char* <i>service_name</i>,
const MPI::Info&amp; <i>info</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>const char* <i>port_name</i>)</p></td></tr>
</table>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p style="margin-top: 1em">service_name</p></td>
<td width="3%"></td>
<td width="68%">


<p style="margin-top: 1em">A service name (string).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p>info</p></td>
<td width="3%"></td>
<td width="68%">


<p>Options to the name service functions (handle).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="18%">


<p>port_name</p></td>
<td width="3%"></td>
<td width="68%">


<p>A port name (string).</p></td></tr>
</table>

<h2>OUTPUT PARAMETER
<a name="OUTPUT PARAMETER"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em">IERROR</p></td>
<td width="12%"></td>
<td width="57%">


<p style="margin-top: 1em">Fortran only: Error status
(integer).</p> </td>
<td width="11%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This routine
publishes the pair (<i>service_name, port_name</i>) so that
an application may retrieve <i>port_name</i> by calling
MPI_Lookup_name with <i>service_name</i> as an argument. It
is an error to publish the same <i>service_name</i> twice,
or to use a <i>port_name</i> argument that was not
previously opened by the calling process via a call to
MPI_Open_port.</p>

<h2>INFO ARGUMENTS
<a name="INFO ARGUMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
keys for <i>info</i> are recognized:</p>

<p style="margin-left:11%; margin-top: 1em">Key Type
Description <br>
--- ---- -----------</p>


<p style="margin-left:11%; margin-top: 1em">ompi_global_scope
bool If set to true, publish the name in <br>
the global scope. Publish in the local <br>
scope otherwise. See the NAME SCOPE <br>
section for more details.</p>

<p style="margin-left:11%; margin-top: 1em">ompi_unique
bool If set to true, return an error if the <br>
specified service_name already exists. <br>
Default to overwriting any pre-existing <br>
value.</p>

<p style="margin-left:11%; margin-top: 1em"><i>bool</i>
info keys are actually strings but are evaluated as follows:
if the string value is a number, it is converted to an
integer and cast to a boolean (meaning that zero integers
are false and non-zero values are true). If the string value
is (case-insensitive) &quot;yes&quot; or &quot;true&quot;,
the boolean is true. If the string value is
(case-insensitive) &quot;no&quot; or &quot;false&quot;, the
boolean is false. All other string values are unrecognized,
and therefore false.</p>

<p style="margin-left:11%; margin-top: 1em">If no info key
is provided, the function will first check to see if a
global server has been specified and is available. If so,
then the publish function will default to global scope
first, followed by local. Otherwise, the data will default
to publish with local scope.</p>

<h2>NAME SCOPE
<a name="NAME SCOPE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Open MPI
supports two name scopes: <i>global</i> and <i>local</i>.
Local scope will place the specified service/port pair in a
data store located on the mpirun of the calling
process&rsquo; job. Thus, data published with local scope
will only be accessible to processes in jobs spawned by that
mpirun - e.g., processes in the calling process&rsquo; job,
or in jobs spawned via MPI_Comm_spawn.</p>

<p style="margin-left:11%; margin-top: 1em">Global scope
places the specified service/port pair in a data store
located on a central server that is accessible to all jobs
running in the cluster or environment. Thus, data published
with global scope can be accessed by multiple mpiruns and
used for MPI_Comm_Connect and MPI_Comm_accept between
jobs.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
global scope operations require both the presence of the
central server and that the calling process be able to
communicate to that server. MPI_Publish_name will return an
error if global scope is specified and a global server is
either not specified or cannot be found.</p>

<p style="margin-left:11%; margin-top: 1em">Open MPI
provides a server called <i>ompi-server</i> to support
global scope operations. Please refer to its manual page for
a more detailed description of data store/lookup
operations.</p>

<p style="margin-left:11%; margin-top: 1em">As an example
of the impact of these scoping rules, consider the case
where a job has been started with mpirun - call this job
&quot;job1&quot;. A process in job1 creates and publishes a
service/port pair using a local scope. Open MPI will store
this data in the data store within mpirun.</p>

<p style="margin-left:11%; margin-top: 1em">A process in
job1 (perhaps the same as did the publish, or perhaps some
other process in the job) subsequently calls MPI_Comm_spawn
to start another job (call it &quot;job2&quot;) under this
mpirun. Since the two jobs share a common mpirun, both jobs
have access to local scope data. Hence, a process in job2
can perform an MPI_Lookup_name with a local scope to
retrieve the information.</p>

<p style="margin-left:11%; margin-top: 1em">However, assume
another user starts a job using mpirun - call this job
&quot;job3&quot;. Because the service/port data published by
job1 specified local scope, processes in job3 cannot access
that data. In contrast, if the data had been published using
global scope, then any process in job3 could access the
data, provided that mpirun was given knowledge of how to
contact the central server and the process could establish
communication with it.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<p style="margin-left:11%; margin-top: 1em">See the MPI man
page for a full list of MPI error codes.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">MPI_Lookup_name
<br>
 MPI_Open_port</p>
<hr>
</body>
</html>
