<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:22 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IPC::Open3</title>

</head>
<body>
<h1>IPC::Open3</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">IPC::Open3
&minus; open a process for reading, writing, and error
handling using open3()</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use Symbol
'gensym'; # vivify a separate handle for STDERR <br>
my $pid = open3(my $chld_in, my $chld_out, my $chld_err =
gensym, <br>
'some', 'cmd', 'and', 'args'); <br>
# or pass the command through the shell <br>
my $pid = open3(my $chld_in, my $chld_out, my $chld_err =
gensym, <br>
'some cmd and args'); <br>
# read from parent STDIN <br>
# send STDOUT and STDERR to already open handle <br>
open my $outfile, '&gt;&gt;', 'output.txt' or die &quot;open
failed: $!&quot;; <br>
my $pid = open3('&lt;&amp;STDIN', $outfile, undef, <br>
'some', 'cmd', 'and', 'args'); <br>
# write to parent STDOUT and STDERR <br>
my $pid = open3(my $chld_in, '&gt;&amp;STDOUT',
'&gt;&amp;STDERR', <br>
'some', 'cmd', 'and', 'args'); <br>
# reap zombie and retrieve exit status <br>
waitpid( $pid, 0 ); <br>
my $child_exit_status = $? &gt;&gt; 8;</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Extremely
similar to <b>open2()</b>, <b>open3()</b> spawns the given
command and connects $chld_out for reading from the child,
$chld_in for writing to the child, and $chld_err for errors.
If $chld_err is false, or the same file descriptor as
$chld_out, then <small>STDOUT</small> and
<small>STDERR</small> of the child are on the same
filehandle. This means that an autovivified lexical cannot
be used for the <small>STDERR</small> filehandle, but gensym
from Symbol can be used to vivify a new glob reference, see
&quot; <small>SYNOPSIS&quot;</small> . The $chld_in will
have autoflush turned on.</p>

<p style="margin-left:11%; margin-top: 1em">If $chld_in
begins with &quot;&lt;&amp;&quot;, then $chld_in will be
closed in the parent, and the child will read from it
directly. If $chld_out or $chld_err begins with
&quot;&gt;&amp;&quot;, then the child will send output
directly to that filehandle. In both cases, there will be a
<b>dup</b>(2) instead of a <b>pipe</b>(2) made.</p>

<p style="margin-left:11%; margin-top: 1em">If either
reader or writer is the empty string or undefined, this will
be replaced by an autogenerated filehandle. If so, you must
pass a valid lvalue in the parameter slot so it can be
overwritten in the caller, or an exception will be
raised.</p>

<p style="margin-left:11%; margin-top: 1em">The filehandles
may also be integers, in which case they are understood as
file descriptors.</p>

<p style="margin-left:11%; margin-top: 1em"><b>open3()</b>
returns the process <small>ID</small> of the child process.
It doesn&rsquo;t return on failure: it just raises an
exception matching &quot;/^open3:/&quot;. However,
&quot;exec&quot; failures in the child (such as no such file
or permission denied), are just reported to $chld_err under
Windows and <small>OS/2,</small> as it is not possible to
trap them.</p>

<p style="margin-left:11%; margin-top: 1em">If the child
process dies for any reason, the next write to $chld_in is
likely to generate a <small>SIGPIPE</small> in the parent,
which is fatal by default. So you may wish to handle this
signal.</p>

<p style="margin-left:11%; margin-top: 1em">Note if you
specify &quot;&minus;&quot; as the command, in an analogous
fashion to &quot;open(my $fh, &quot;&minus;|&quot;)&quot;
the child process will just be the forked Perl process
rather than an external command. This feature isn&rsquo;t
yet supported on Win32 platforms.</p>

<p style="margin-left:11%; margin-top: 1em"><b>open3()</b>
does not wait for and reap the child process after it exits.
Except for short programs where it&rsquo;s acceptable to let
the operating system take care of this, you need to do this
yourself. This is normally as simple as calling
&quot;waitpid $pid, 0&quot; when you&rsquo;re done with the
process. Failing to do this can result in an accumulation of
defunct or &quot;zombie&quot; processes. See
&quot;waitpid&quot; in perlfunc for more information.</p>

<p style="margin-left:11%; margin-top: 1em">If you try to
read from the child&rsquo;s stdout writer and their stderr
writer, you&rsquo;ll have problems with blocking, which
means you&rsquo;ll want to use <b>select()</b> or
IO::Select, which means you&rsquo;d best use
<b>sysread()</b> instead of <b>readline()</b> for normal
stuff.</p>

<p style="margin-left:11%; margin-top: 1em">This is very
dangerous, as you may block forever. It assumes it&rsquo;s
going to talk to something like <b>bc</b>(1), both writing
to it and reading from it. This is presumably safe because
you &quot;know&quot; that commands like <b>bc</b>(1) will
read a line at a time and output a line at a time. Programs
like <b>sort</b>(1) that read their entire input stream
first, however, are quite apt to cause deadlock.</p>

<p style="margin-left:11%; margin-top: 1em">The big problem
with this approach is that if you don&rsquo;t have control
over source code being run in the child process, you
can&rsquo;t control what it does with pipe buffering. Thus
you can&rsquo;t just open a pipe to &quot;cat &minus;v&quot;
and continually read and write a line from it.</p>

<h2>See Also
<a name="See Also"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">IPC::Open2</p>

<p style="margin-left:17%;">Like Open3 but without
<small>STDERR</small> capture.</p>

<p style="margin-left:11%;">IPC::Run</p>

<p style="margin-left:17%;">This is a <small>CPAN</small>
module that has better error handling and more facilities
than Open3.</p>

<h2>WARNING
<a name="WARNING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The order of
arguments differs from that of <b>open2()</b>.</p>
<hr>
</body>
</html>
