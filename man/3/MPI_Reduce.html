<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:35 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_Reduce</title>

</head>
<body>
<h1>MPI_Reduce</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>MPI_Reduce,
MPI_Ireduce</b> &minus; Reduces values on all processes
within a group.</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Reduce(const void *<i>sendbuf</i>, void
*<i>recvbuf</i>, int <i>count</i>, <br>
MPI_Datatype <i>datatype</i>, MPI_Op <i>op</i>, int
<i>root</i>, <br>
MPI_Comm <i>comm</i>)</p>

<p style="margin-left:11%; margin-top: 1em">int
MPI_Ireduce(const void *<i>sendbuf</i>, void
*<i>recvbuf</i>, int <i>count</i>, <br>
MPI_Datatype <i>datatype</i>, MPI_Op <i>op</i>, int
<i>root</i>, <br>
MPI_Comm <i>comm</i>, MPI_Request <i>*request</i>)</p>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_REDUCE(<i>SENDBUF, RECVBUF, COUNT, DATATYPE, OP, ROOT,
COMM,</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p><i>IERROR</i>)</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>&lt;type&gt;</p></td>
<td width="8%"></td>
<td width="69%">


<p><i>SENDBUF(*), RECVBUF(*)</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="69%">


<p><i>COUNT, DATATYPE, OP, ROOT, COMM, IERROR</i></p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em">MPI_IREDUCE(<i>SENDBUF,
RECVBUF, COUNT, DATATYPE, OP, ROOT, COMM, <br>
REQUEST, IERROR</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>&lt;type&gt;</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>SENDBUF(*), RECVBUF(*)</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>COUNT, DATATYPE, OP, ROOT, COMM, REQUEST,
IERROR</i></p> </td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_Reduce(<i>sendbuf</i>, <i>recvbuf</i>, <i>count</i>,
<i>datatype</i>, <i>op</i>, <i>root</i>, <i>comm</i>,
<i>ierror</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(*), DIMENSION(..), INTENT(IN) :: <i>sendbuf</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(*), DIMENSION(..) :: <i>recvbuf</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, INTENT(IN) :: <i>count</i>, <i>root</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Datatype), INTENT(IN) :: <i>datatype</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Op), INTENT(IN) :: <i>op</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Comm), INTENT(IN) :: <i>comm</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em">MPI_Ireduce(<i>sendbuf</i>,
<i>recvbuf</i>, <i>count</i>, <i>datatype</i>, <i>op</i>,
<i>root</i>, <i>comm</i>, <i>request</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p><i>ierror</i>)</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS ::
<i>sendbuf</i></p> </td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(*), DIMENSION(..), ASYNCHRONOUS ::
<i>recvbuf</i></p> </td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>INTEGER, INTENT(IN) :: <i>count</i>, <i>root</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Datatype), INTENT(IN) :: <i>datatype</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Op), INTENT(IN) :: <i>op</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Comm), INTENT(IN) :: <i>comm</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Request), INTENT(OUT) :: <i>request</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td>
<td width="77%">
</td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
void MPI::Intracomm::Reduce(const void* <i>sendbuf</i>,
void* <i>recvbuf</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>int <i>count</i>, const MPI::Datatype&amp;
<i>datatype</i>, const MPI::Op&amp; <i>op</i>,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>int <i>root</i>) const</p></td></tr>
</table>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">sendbuf</p></td>
<td width="3%"></td>
<td width="71%">


<p style="margin-top: 1em">Address of send buffer
(choice).</p> </td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>count</p></td>
<td width="3%"></td>
<td width="71%">


<p>Number of elements in send buffer (integer).</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>datatype</p></td>
<td width="3%"></td>
<td width="71%">


<p>Data type of elements of send buffer (handle).</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>op</p></td>
<td width="3%"></td>
<td width="71%">


<p>Reduce operation (handle).</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>root</p></td>
<td width="3%"></td>
<td width="71%">


<p>Rank of root process (integer).</p></td>
<td width="3%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>comm</p></td>
<td width="3%"></td>
<td width="71%">


<p>Communicator (handle).</p></td>
<td width="3%">
</td></tr>
</table>

<h2>OUTPUT PARAMETERS
<a name="OUTPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p style="margin-top: 1em">recvbuf</p></td>
<td width="4%"></td>
<td width="74%">


<p style="margin-top: 1em">Address of receive buffer
(choice, significant only at root).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>request</p></td>
<td width="4%"></td>
<td width="74%">


<p>Request (handle, non-blocking only).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>IERROR</p></td>
<td width="4%"></td>
<td width="74%">


<p>Fortran only: Error status (integer).</p></td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The global
reduce functions (MPI_Reduce, MPI_Op_create, MPI_Op_free,
MPI_Allreduce, MPI_Reduce_scatter, MPI_Scan) perform a
global reduce operation (such as sum, max, logical AND,
etc.) across all the members of a group. The reduction
operation can be either one of a predefined list of
operations, or a user-defined operation. The global
reduction functions come in several flavors: a reduce that
returns the result of the reduction at one node, an
all-reduce that returns this result at all nodes, and a scan
(parallel prefix) operation. In addition, a reduce-scatter
operation combines the functionality of a reduce and a
scatter operation.</p>

<p style="margin-left:11%; margin-top: 1em">MPI_Reduce
combines the elements provided in the input buffer of each
process in the group, using the operation op, and returns
the combined value in the output buffer of the process with
rank root. The input buffer is defined by the arguments
sendbuf, count, and datatype; the output buffer is defined
by the arguments recvbuf, count, and datatype; both have the
same number of elements, with the same type. The routine is
called by all group members using the same arguments for
count, datatype, op, root, and comm. Thus, all processes
provide input buffers and output buffers of the same length,
with elements of the same type. Each process can provide one
element, or a sequence of elements, in which case the
combine operation is executed element-wise on each entry of
the sequence. For example, if the operation is MPI_MAX and
the send buffer contains two elements that are
floating-point numbers (count = 2 and datatype = MPI_FLOAT),
then recvbuf(1) = global max (sendbuf(1)) and recvbuf(2) =
global max(sendbuf(2)).</p>

<h2>USE OF IN-PLACE OPTION
<a name="USE OF IN-PLACE OPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When the
communicator is an intracommunicator, you can perform a
reduce operation in-place (the output buffer is used as the
input buffer). Use the variable MPI_IN_PLACE as the value of
the root process <i>sendbuf</i>. In this case, the input
data is taken at the root from the receive buffer, where it
will be replaced by the output data.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
MPI_IN_PLACE is a special kind of value; it has the same
restrictions on its use as MPI_BOTTOM.</p>

<p style="margin-left:11%; margin-top: 1em">Because the
in-place option converts the receive buffer into a
send-and-receive buffer, a Fortran binding that includes
INTENT must mark these as INOUT, not OUT.</p>

<h2>WHEN COMMUNICATOR IS AN INTER-COMMUNICATOR
<a name="WHEN COMMUNICATOR IS AN INTER-COMMUNICATOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When the
communicator is an inter-communicator, the root process in
the first group combines data from all the processes in the
second group and then performs the <i>op</i> operation. The
first group defines the root process. That process uses
MPI_ROOT as the value of its <i>root</i> argument. The
remaining processes use MPI_PROC_NULL as the value of their
<i>root</i> argument. All processes in the second group use
the rank of that root process in the first group as the
value of their <i>root</i> argument. Only the send buffer
arguments are significant in the second group, and only the
receive buffer arguments are significant in the root process
of the first group.</p>

<h2>PREDEFINED REDUCE OPERATIONS
<a name="PREDEFINED REDUCE OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The set of
predefined operations provided by MPI is listed below
(Predefined Reduce Operations). That section also enumerates
the datatypes each operation can be applied to. In addition,
users may define their own operations that can be overloaded
to operate on several datatypes, either basic or derived.
This is further explained in the description of the
user-defined operations (see the man pages for MPI_Op_create
and MPI_Op_free).</p>

<p style="margin-left:11%; margin-top: 1em">The operation
op is always assumed to be associative. All predefined
operations are also assumed to be commutative. Users may
define operations that are assumed to be associative, but
not commutative. The &lsquo;&lsquo;canonical&rsquo;&rsquo;
evaluation order of a reduction is determined by the ranks
of the processes in the group. However, the implementation
can take advantage of associativity, or associativity and
commutativity, in order to change the order of evaluation.
This may change the result of the reduction for operations
that are not strictly associative and commutative, such as
floating point addition.</p>

<p style="margin-left:11%; margin-top: 1em">Predefined
operators work only with the MPI types listed below
(Predefined Reduce Operations, and the section MINLOC and
MAXLOC, below). User-defined operators may operate on
general, derived datatypes. In this case, each argument that
the reduce operation is applied to is one element described
by such a datatype, which may contain several basic values.
This is further explained in Section 4.9.4 of the MPI
Standard, &quot;User-Defined Operations.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">The following
predefined operations are supplied for MPI_Reduce and
related functions MPI_Allreduce, MPI_Reduce_scatter, and
MPI_Scan. These operations are invoked by placing the
following in op:</p>

<p style="margin-left:11%; margin-top: 1em">Name Meaning
<br>
--------- --------------------</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_MAX maximum</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_MIN minimum</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_SUM sum</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_PROD product</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_LAND logical and</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_BAND bit-wise and</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_LOR logical or</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_BOR bit-wise or</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_LXOR logical xor</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_BXOR bit-wise xor</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_MAXLOC max value and location</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_MINLOC min value and location</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The two
operations MPI_MINLOC and MPI_MAXLOC are discussed
separately below (MINLOC and MAXLOC). For the other
predefined operations, we enumerate below the allowed
combinations of op and datatype arguments. First, define
groups of MPI basic datatypes in the following way:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>C integer: MPI_INT, MPI_LONG, MPI_SHORT,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_UNSIGNED_SHORT, MPI_UNSIGNED,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_UNSIGNED_LONG</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Fortran integer: MPI_INTEGER</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Floating-point: MPI_FLOAT, MPI_DOUBLE, MPI_REAL,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_DOUBLE_PRECISION, MPI_LONG_DOUBLE</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Logical: MPI_LOGICAL</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Complex: MPI_COMPLEX</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Byte: MPI_BYTE</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Now, the valid
datatypes for each option is specified below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>Op</p></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">


<p>Allowed Types</p></td></tr>
</table>

<p style="margin-left:11%;">----------------
---------------------------</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>MPI_MAX, MPI_MIN</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="46%">


<p>C integer, Fortran integer,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="46%">


<p>floating-point</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>MPI_SUM, MPI_PROD</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="46%">


<p>C integer, Fortran integer,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="46%">


<p>floating-point, complex</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>MPI_LAND, MPI_LOR,</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="46%">


<p>C integer, logical</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>MPI_LXOR</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>MPI_BAND, MPI_BOR,</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="46%">


<p>C integer, Fortran integer, byte</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>MPI_BXOR</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Example
1:</b> A routine that computes the dot product of two
vectors that are distributed across a group of processes and
returns the answer at process zero.</p>

<p style="margin-left:11%; margin-top: 1em">SUBROUTINE
PAR_BLAS1(m, a, b, c, comm) <br>
REAL a(m), b(m) ! local slice of array <br>
REAL c ! result (at process zero) <br>
REAL sum <br>
INTEGER m, comm, i, ierr</p>

<p style="margin-left:11%; margin-top: 1em">! local sum
<br>
sum = 0.0 <br>
DO i = 1, m <br>
sum = sum + a(i)*b(i) <br>
END DO</p>

<p style="margin-left:11%; margin-top: 1em">! global sum
<br>
CALL MPI_REDUCE(sum, c, 1, MPI_REAL, MPI_SUM, 0, comm, ierr)
<br>
RETURN</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
2:</b> A routine that computes the product of a vector and
an array that are distributed across a group of processes
and returns the answer at process zero.</p>

<p style="margin-left:11%; margin-top: 1em">SUBROUTINE
PAR_BLAS2(m, n, a, b, c, comm) <br>
REAL a(m), b(m,n) ! local slice of array <br>
REAL c(n) ! result <br>
REAL sum(n) <br>
INTEGER n, comm, i, j, ierr</p>

<p style="margin-left:11%; margin-top: 1em">! local sum
<br>
DO j= 1, n <br>
sum(j) = 0.0 <br>
DO i = 1, m <br>
sum(j) = sum(j) + a(i)*b(i,j) <br>
END DO <br>
END DO</p>

<p style="margin-left:11%; margin-top: 1em">! global sum
<br>
CALL MPI_REDUCE(sum, c, n, MPI_REAL, MPI_SUM, 0, comm,
ierr)</p>

<p style="margin-left:11%; margin-top: 1em">! return result
at process zero (and garbage at the other nodes) <br>
RETURN</p>

<h2>MINLOC AND MAXLOC
<a name="MINLOC AND MAXLOC"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The operator
MPI_MINLOC is used to compute a global minimum and also an
index attached to the minimum value. MPI_MAXLOC similarly
computes a global maximum and index. One application of
these is to compute a global minimum (maximum) and the rank
of the process containing this value.</p>

<p style="margin-left:11%; margin-top: 1em">The operation
that defines MPI_MAXLOC is</p>

<p style="margin-left:11%; margin-top: 1em">( u ) ( v ) ( w
) <br>
( ) o ( ) = ( ) <br>
( i ) ( j ) ( k )</p>

<p style="margin-left:11%; margin-top: 1em">where</p>

<p style="margin-left:11%; margin-top: 1em">w = max(u,
v)</p>

<p style="margin-left:11%; margin-top: 1em">and</p>

<p style="margin-left:11%; margin-top: 1em">( i if u &gt; v
<br>
( <br>
k = ( min(i, j) if u = v <br>
( <br>
( j if u &lt; v)</p>

<p style="margin-left:11%; margin-top: 1em">MPI_MINLOC is
defined similarly:</p>

<p style="margin-left:11%; margin-top: 1em">( u ) ( v ) ( w
) <br>
( ) o ( ) = ( ) <br>
( i ) ( j ) ( k )</p>

<p style="margin-left:11%; margin-top: 1em">where</p>

<p style="margin-left:11%; margin-top: 1em">w = min(u,
v)</p>

<p style="margin-left:11%; margin-top: 1em">and</p>

<p style="margin-left:11%; margin-top: 1em">( i if u &lt; v
<br>
( <br>
k = ( min(i, j) if u = v <br>
( <br>
( j if u &gt; v)</p>

<p style="margin-left:11%; margin-top: 1em">Both operations
are associative and commutative. Note that if MPI_MAXLOC is
applied to reduce a sequence of pairs (u(0), 0), (u(1),
1),&nbsp;..., (u(n-1), n-1), then the value returned is (u ,
r), where u= max(i) u(i) and r is the index of the first
global maximum in the sequence. Thus, if each process
supplies a value and its rank within the group, then a
reduce operation with op = MPI_MAXLOC will return the
maximum value and the rank of the first process with that
value. Similarly, MPI_MINLOC can be used to return a minimum
and its index. More generally, MPI_MINLOC computes a
lexicographic minimum, where elements are ordered according
to the first component of each pair, and ties are resolved
according to the second component.</p>

<p style="margin-left:11%; margin-top: 1em">The reduce
operation is defined to operate on arguments that consist of
a pair: value and index. For both Fortran and C, types are
provided to describe the pair. The potentially mixed-type
nature of such arguments is a problem in Fortran. The
problem is circumvented, for Fortran, by having the
MPI-provided type consist of a pair of the same type as
value, and coercing the index to this type also. In C, the
MPI-provided pair type has distinct types and the index is
an int.</p>

<p style="margin-left:11%; margin-top: 1em">In order to use
MPI_MINLOC and MPI_MAXLOC in a reduce operation, one must
provide a datatype argument that represents a pair (value
and index). MPI provides nine such predefined datatypes. The
operations MPI_MAXLOC and MPI_MINLOC can be used with each
of the following datatypes:</p>

<p style="margin-left:11%; margin-top: 1em">Fortran: <br>
Name Description <br>
MPI_2REAL pair of REALs <br>
MPI_2DOUBLE_PRECISION pair of DOUBLE-PRECISION variables
<br>
MPI_2INTEGER pair of INTEGERs</p>

<p style="margin-left:11%; margin-top: 1em">C:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Name</p><td width="17%"></td>
<td width="-9%"></td>
<td width="23%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="54%">


<p>Description</p></td></tr>
</table>

<p style="margin-left:11%;">MPI_FLOAT_INT float and int
<br>
MPI_DOUBLE_INT double and int <br>
MPI_LONG_INT long and int <br>
MPI_2INT pair of ints <br>
MPI_SHORT_INT short and int <br>
MPI_LONG_DOUBLE_INT long double and int</p>

<p style="margin-left:11%; margin-top: 1em">The data type
MPI_2REAL is equivalent to: <br>
MPI_TYPE_CONTIGUOUS(2, MPI_REAL, MPI_2REAL)</p>

<p style="margin-left:11%; margin-top: 1em">Similar
statements apply for MPI_2INTEGER, MPI_2DOUBLE_PRECISION,
and MPI_2INT.</p>

<p style="margin-left:11%; margin-top: 1em">The datatype
MPI_FLOAT_INT is as if defined by the following sequence of
instructions.</p>

<p style="margin-left:11%; margin-top: 1em">type[0] =
MPI_FLOAT <br>
type[1] = MPI_INT <br>
disp[0] = 0 <br>
disp[1] = sizeof(float) <br>
block[0] = 1 <br>
block[1] = 1 <br>
MPI_TYPE_STRUCT(2, block, disp, type, MPI_FLOAT_INT)</p>

<p style="margin-left:11%; margin-top: 1em">Similar
statements apply for MPI_LONG_INT and MPI_DOUBLE_INT.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
3:</b> Each process has an array of 30 doubles, in C. For
each of the 30 locations, compute the value and rank of the
process containing the largest value.</p>

<p style="margin-left:11%; margin-top: 1em">... <br>
/* each process has an array of 30 double: ain[30] <br>
*/ <br>
double ain[30], aout[30]; <br>
int ind[30]; <br>
struct { <br>
double val; <br>
int rank; <br>
} in[30], out[30]; <br>
int i, myrank, root;</p>


<p style="margin-left:11%; margin-top: 1em">MPI_Comm_rank(MPI_COMM_WORLD,
&amp;myrank); <br>
for (i=0; i&lt;30; ++i) { <br>
in[i].val = ain[i]; <br>
in[i].rank = myrank; <br>
} <br>
MPI_Reduce( in, out, 30, MPI_DOUBLE_INT, MPI_MAXLOC, root,
comm ); <br>
/* At this point, the answer resides on process root <br>
*/ <br>
if (myrank == root) { <br>
/* read ranks out <br>
*/ <br>
for (i=0; i&lt;30; ++i) { <br>
aout[i] = out[i].val; <br>
ind[i] = out[i].rank; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
4:</b> Same example, in Fortran.</p>

<p style="margin-left:11%; margin-top: 1em">... <br>
! each process has an array of 30 double: ain(30)</p>

<p style="margin-left:11%; margin-top: 1em">DOUBLE
PRECISION ain(30), aout(30) <br>
INTEGER ind(30); <br>
DOUBLE PRECISION in(2,30), out(2,30) <br>
INTEGER i, myrank, root, ierr;</p>


<p style="margin-left:11%; margin-top: 1em">MPI_COMM_RANK(MPI_COMM_WORLD,
myrank); <br>
DO I=1, 30 <br>
in(1,i) = ain(i) <br>
in(2,i) = myrank ! myrank is coerced to a double <br>
END DO</p>

<p style="margin-left:11%; margin-top: 1em">MPI_REDUCE( in,
out, 30, MPI_2DOUBLE_PRECISION, MPI_MAXLOC, root, <br>
comm, ierr ); <br>
! At this point, the answer resides on process root</p>

<p style="margin-left:11%; margin-top: 1em">IF (myrank .EQ.
root) THEN <br>
! read ranks out <br>
DO I= 1, 30 <br>
aout(i) = out(1,i) <br>
ind(i) = out(2,i) ! rank is coerced back to an integer <br>
END DO <br>
END IF</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example
5:</b> Each process has a nonempty array of values. Find the
minimum global value, the rank of the process that holds it,
and its index on this process.</p>

<p style="margin-left:11%; margin-top: 1em">#define LEN
1000</p>

<p style="margin-left:11%; margin-top: 1em">float val[LEN];
/* local array of values */ <br>
int count; /* local number of values */ <br>
int myrank, minrank, minindex; <br>
float minval;</p>

<p style="margin-left:11%; margin-top: 1em">struct { <br>
float value; <br>
int index; <br>
} in, out;</p>

<p style="margin-left:11%; margin-top: 1em">/* local minloc
*/ <br>
in.value = val[0]; <br>
in.index = 0; <br>
for (i=1; i &lt; count; i++) <br>
if (in.value &gt; val[i]) { <br>
in.value = val[i]; <br>
in.index = i; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* global
minloc */ <br>
MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank); <br>
in.index = myrank*LEN + in.index; <br>
MPI_Reduce( in, out, 1, MPI_FLOAT_INT, MPI_MINLOC, root,
comm ); <br>
/* At this point, the answer resides on process root <br>
*/ <br>
if (myrank == root) { <br>
/* read answer out <br>
*/ <br>
minval = out.value; <br>
minrank = out.index / LEN; <br>
minindex = out.index % LEN;</p>

<p style="margin-left:11%; margin-top: 1em">All MPI objects
(e.g., MPI_Datatype, MPI_Comm) are of type INTEGER in
Fortran.</p>

<h2>NOTES ON COLLECTIVE OPERATIONS
<a name="NOTES ON COLLECTIVE OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The reduction
functions ( <i>MPI_Op</i> ) do not return an error value. As
a result, if the functions detect an error, all they can do
is either call <i>MPI_Abort</i> or silently skip the
problem. Thus, if you change the error handler from
<i>MPI_ERRORS_ARE_FATAL</i> to something else, for example,
<i>MPI_ERRORS_RETURN</i> , then no error may be
indicated.</p>

<p style="margin-left:11%; margin-top: 1em">The reason for
this is the performance problems in ensuring that all
collective routines return the same error value.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Allreduce
<br>
MPI_Reduce_scatter <br>
MPI_Scan <br>
MPI_Op_create <br>
 MPI_Op_free</p>
<hr>
</body>
</html>
