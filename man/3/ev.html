<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:51 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LIBEV</title>

</head>
<body>
<h1>ev</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libev &minus; a
high performance full&minus;featured event loop written in
C</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;ev.h&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>EXAMPLE
PROGRAM</small></b> <br>
// a single header file is required <br>
#include &lt;ev.h&gt; <br>
#include &lt;stdio.h&gt; // for puts <br>
// every watcher type has its own typedef'd struct <br>
// with the name ev_TYPE <br>
ev_io stdin_watcher; <br>
ev_timer timeout_watcher; <br>
// all watcher callbacks have a similar signature <br>
// this callback is called when data is readable on stdin
<br>
static void <br>
stdin_cb (EV_P_ ev_io *w, int revents) <br>
{ <br>
puts (&quot;stdin ready&quot;); <br>
// for one&minus;shot events, one must manually stop the
watcher <br>
// with its corresponding stop function. <br>
ev_io_stop (EV_A_ w); <br>
// this causes all nested ev_run's to stop iterating <br>
ev_break (EV_A_ EVBREAK_ALL); <br>
} <br>
// another callback, this time for a time&minus;out <br>
static void <br>
timeout_cb (EV_P_ ev_timer *w, int revents) <br>
{ <br>
puts (&quot;timeout&quot;); <br>
// this causes the innermost ev_run to stop iterating <br>
ev_break (EV_A_ EVBREAK_ONE); <br>
} <br>
int <br>
main (void) <br>
{ <br>
// use the default event loop unless you have special needs
<br>
struct ev_loop *loop = EV_DEFAULT; <br>
// initialise an io watcher, then start it <br>
// this one will watch for stdin to become readable <br>
ev_io_init (&amp;stdin_watcher, stdin_cb, /*STDIN_FILENO*/
0, EV_READ); <br>
ev_io_start (loop, &amp;stdin_watcher); <br>
// initialise a timer watcher, then start it <br>
// simple non&minus;repeating 5.5 second timeout <br>
ev_timer_init (&amp;timeout_watcher, timeout_cb, 5.5, 0.);
<br>
ev_timer_start (loop, &amp;timeout_watcher); <br>
// now wait for events to arrive <br>
ev_run (loop, 0); <br>
// break was called, so exit <br>
return 0; <br>
}</p>

<h2>ABOUT THIS DOCUMENT
<a name="ABOUT THIS DOCUMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
documents the libev software package.</p>

<p style="margin-left:11%; margin-top: 1em">The newest
version of this document is also available as an
html-formatted web page you might find easier to navigate
when reading it for the first time:
&lt;http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">While this
document tries to be as complete as possible in documenting
libev, its usage and the rationale behind its design, it is
not a tutorial on event-based programming, nor will it
introduce event-based programming with libev.</p>

<p style="margin-left:11%; margin-top: 1em">Familiarity
with event based programming techniques in general is
assumed throughout this document.</p>

<h2>WHAT TO READ WHEN IN A HURRY
<a name="WHAT TO READ WHEN IN A HURRY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This manual
tries to be very detailed, but unfortunately, this also
makes it very long. If you just want to know the basics of
libev, I suggest reading &quot; <small>ANATOMY OF A
WATCHER&quot;</small> , then the &quot; <small>EXAMPLE
PROGRAM&quot;</small> above and look up the missing
functions in &quot; <small>GLOBAL FUNCTIONS&quot;</small>
and the &quot;ev_io&quot; and &quot;ev_timer&quot; sections
in &quot; <small>WATCHER TYPES&quot;</small> .</p>

<h2>ABOUT LIBEV
<a name="ABOUT LIBEV"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Libev is an
event loop: you register interest in certain events (such as
a file descriptor being readable or a timeout occurring),
and it will manage these event sources and provide your
program with events.</p>

<p style="margin-left:11%; margin-top: 1em">To do this, it
must take more or less complete control over your process
(or thread) by executing the <i>event loop</i> handler, and
will then communicate events via a callback mechanism.</p>

<p style="margin-left:11%; margin-top: 1em">You register
interest in certain events by registering so-called <i>event
watchers</i>, which are relatively small C structures you
initialise with the details of the event, and then hand it
over to libev by <i>starting</i> the watcher.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>FEATURES</small></b>
<br>
Libev supports &quot;select&quot;, &quot;poll&quot;, the
Linux-specific aio and &quot;epoll&quot; interfaces, the
BSD-specific &quot;kqueue&quot; and the Solaris-specific
event port mechanisms for file descriptor events
(&quot;ev_io&quot;), the Linux &quot;inotify&quot; interface
(for &quot;ev_stat&quot;), Linux eventfd/signalfd (for
faster and cleaner inter-thread wakeup
(&quot;ev_async&quot;)/signal handling
(&quot;ev_signal&quot;)) relative timers
(&quot;ev_timer&quot;), absolute timers with customised
rescheduling (&quot;ev_periodic&quot;), synchronous signals
(&quot;ev_signal&quot;), process status change events
(&quot;ev_child&quot;), and event watchers dealing with the
event loop mechanism itself (&quot;ev_idle&quot;,
&quot;ev_embed&quot;, &quot;ev_prepare&quot; and
&quot;ev_check&quot; watchers) as well as file watchers
(&quot;ev_stat&quot;) and even limited support for fork
events (&quot;ev_fork&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">It also is
quite fast (see this benchmark
&lt;http://libev.schmorp.de/bench.html&gt; comparing it to
libevent for example).</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CONVENTIONS</small></b>
<br>
Libev is very configurable. In this manual the default (and
most common) configuration will be described, which supports
multiple event loops. For more info about various
configuration options please have a look at
<b><small>EMBED</small></b> section in this manual. If libev
was configured without support for multiple event loops,
then all functions taking an initial argument of name
&quot;loop&quot; (which is always of type &quot;struct
ev_loop *&quot;) will not have this argument.</p>

<p style="margin-left:11%; margin-top: 1em"><b><small>TIME
REPRESENTATION</small></b> <br>
Libev represents time as a single floating point number,
representing the (fractional) number of seconds since the (
<small>POSIX</small> ) epoch (in practice somewhere near the
beginning of 1970, details are complicated, don&rsquo;t
ask). This type is called &quot;ev_tstamp&quot;, which is
what you should use too. It usually aliases to the
&quot;double&quot; type in C. When you need to do any
calculations on it, you should treat it as some floating
point value.</p>

<p style="margin-left:11%; margin-top: 1em">Unlike the name
component &quot;stamp&quot; might indicate, it is also used
for time differences (e.g. delays) throughout libev.</p>

<h2>ERROR HANDLING
<a name="ERROR HANDLING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Libev knows
three classes of errors: operating system errors, usage
errors and internal errors (bugs).</p>

<p style="margin-left:11%; margin-top: 1em">When libev
catches an operating system error it cannot handle (for
example a system call indicating a condition libev cannot
fix), it calls the callback set via
&quot;ev_set_syserr_cb&quot;, which is supposed to fix the
problem or abort. The default is to print a diagnostic
message and to call &quot;abort ()&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">When libev
detects a usage error such as a negative timer interval,
then it will print a diagnostic message and abort (via the
&quot;assert&quot; mechanism, so &quot;NDEBUG&quot; will
disable this checking): these are programming errors in the
libev caller and need to be fixed there.</p>

<p style="margin-left:11%; margin-top: 1em">Via the
&quot;EV_FREQUENT&quot; macro you can compile in and/or
enable extensive consistency checking code inside libev that
can be used to check for internal inconsistencies, suually
caused by application bugs.</p>

<p style="margin-left:11%; margin-top: 1em">Libev also has
a few internal error-checking &quot;assert&quot;ions. These
do not trigger under normal circumstances, as they indicate
either a bug in libev or worse.</p>

<h2>GLOBAL FUNCTIONS
<a name="GLOBAL FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These functions
can be called anytime, even before initialising the library
in any way. <br>
ev_tstamp ev_time ()</p>

<p style="margin-left:17%;">Returns the current time as
libev would use it. Please note that the &quot;ev_now&quot;
function is usually faster and also often returns the
timestamp you actually want to know. Also interesting is the
combination of &quot;ev_now_update&quot; and
&quot;ev_now&quot;.</p>

<p style="margin-left:11%;">ev_sleep (ev_tstamp
interval)</p>

<p style="margin-left:17%;">Sleep for the given interval:
The current thread will be blocked until either it is
interrupted or the given time interval has passed
(approximately &minus; it might return a bit earlier even if
not interrupted). Returns immediately if &quot;interval
&lt;= 0&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Basically this
is a sub-second-resolution &quot;sleep ()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The range of
the &quot;interval&quot; is limited &minus; libev only
guarantees to work with sleep times of up to one day
(&quot;interval &lt;= 86400&quot;).</p>

<p style="margin-left:11%;">int ev_version_major () <br>
int ev_version_minor ()</p>

<p style="margin-left:17%;">You can find out the major and
minor <small>ABI</small> version numbers of the library you
linked against by calling the functions
&quot;ev_version_major&quot; and
&quot;ev_version_minor&quot;. If you want, you can compare
against the global symbols &quot;EV_VERSION_MAJOR&quot; and
&quot;EV_VERSION_MINOR&quot;, which specify the version of
the library your program was compiled against.</p>

<p style="margin-left:17%; margin-top: 1em">These version
numbers refer to the <small>ABI</small> version of the
library, not the release version.</p>

<p style="margin-left:17%; margin-top: 1em">Usually,
it&rsquo;s a good idea to terminate if the major versions
mismatch, as this indicates an incompatible change. Minor
versions are usually compatible to older versions, so a
larger minor version alone is usually not a problem.</p>

<p style="margin-left:17%; margin-top: 1em">Example: Make
sure we haven&rsquo;t accidentally been linked against the
wrong version (note, however, that this will not detect
other <small>ABI</small> mismatches, such as
<small>LFS</small> or reentrancy).</p>

<p style="margin-left:17%; margin-top: 1em">assert
((&quot;libev version mismatch&quot;, <br>
ev_version_major () == EV_VERSION_MAJOR <br>
&amp;&amp; ev_version_minor () &gt;= EV_VERSION_MINOR));</p>

<p style="margin-left:11%;">unsigned int
ev_supported_backends ()</p>

<p style="margin-left:17%;">Return the set of all backends
(i.e. their corresponding &quot;EV_BACKEND_*&quot; value)
compiled into this binary of libev (independent of their
availability on the system you are running on). See
&quot;ev_default_loop&quot; for a description of the set
values.</p>

<p style="margin-left:17%; margin-top: 1em">Example: make
sure we have the epoll method, because yeah this is cool and
a must have and can we have a torrent of it please!!!11</p>

<p style="margin-left:17%; margin-top: 1em">assert
((&quot;sorry, no epoll, no sex&quot;, <br>
ev_supported_backends () &amp; EVBACKEND_EPOLL));</p>

<p style="margin-left:11%;">unsigned int
ev_recommended_backends ()</p>

<p style="margin-left:17%;">Return the set of all backends
compiled into this binary of libev and also recommended for
this platform, meaning it will work for most file descriptor
types. This set is often smaller than the one returned by
&quot;ev_supported_backends&quot;, as for example kqueue is
broken on most BSDs and will not be auto-detected unless you
explicitly request it (assuming you know what you are
doing). This is the set of backends that libev will probe
for if you specify no backends explicitly.</p>

<p style="margin-left:11%;">unsigned int
ev_embeddable_backends ()</p>

<p style="margin-left:17%;">Returns the set of backends
that are embeddable in other event loops. This value is
platform-specific but can include backends not available on
the current system. To find which embeddable backends might
be supported on the current system, you would need to look
at &quot;ev_embeddable_backends () &amp;
ev_supported_backends ()&quot;, likewise for recommended
ones.</p>

<p style="margin-left:17%; margin-top: 1em">See the
description of &quot;ev_embed&quot; watchers for more
info.</p>

<p style="margin-left:11%;">ev_set_allocator (void
*(*cb)(void *ptr, long size) throw ())</p>

<p style="margin-left:17%;">Sets the allocation function to
use (the prototype is similar &minus; the semantics are
identical to the &quot;realloc&quot; C89/SuS/POSIX
function). It is used to allocate and free memory (no
surprises here). If it returns zero when memory needs to be
allocated (&quot;size != 0&quot;), the library might abort
or take some potentially destructive action.</p>

<p style="margin-left:17%; margin-top: 1em">Since some
systems (at least OpenBSD and Darwin) fail to implement
correct &quot;realloc&quot; semantics, libev will use a
wrapper around the system &quot;realloc&quot; and
&quot;free&quot; functions by default.</p>

<p style="margin-left:17%; margin-top: 1em">You could
override this function in high-availability programs to,
say, free some memory if it cannot allocate memory, to use a
special allocator, or even to sleep a while and retry until
some memory is available.</p>

<p style="margin-left:17%; margin-top: 1em">Example: The
following is the &quot;realloc&quot; function that libev
itself uses which should work with &quot;realloc&quot; and
&quot;free&quot; functions of all kinds and is probably a
good basis for your own implementation.</p>

<p style="margin-left:17%; margin-top: 1em">static void *
<br>
ev_realloc_emul (void *ptr, long size) EV_NOEXCEPT <br>
{ <br>
if (size) <br>
return realloc (ptr, size); <br>
free (ptr); <br>
return 0; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">Example:
Replace the libev allocator with one that waits a bit and
then retries.</p>

<p style="margin-left:17%; margin-top: 1em">static void *
<br>
persistent_realloc (void *ptr, size_t size) <br>
{ <br>
if (!size) <br>
{ <br>
free (ptr); <br>
return 0; <br>
} <br>
for (;;) <br>
{ <br>
void *newptr = realloc (ptr, size); <br>
if (newptr) <br>
return newptr; <br>
sleep (60); <br>
} <br>
} <br>
... <br>
ev_set_allocator (persistent_realloc);</p>

<p style="margin-left:11%;">ev_set_syserr_cb (void
(*cb)(const char *msg) throw ())</p>

<p style="margin-left:17%;">Set the callback function to
call on a retryable system call error (such as failed
select, poll, epoll_wait). The message is a printable string
indicating the system call or subsystem causing the problem.
If this callback is set, then libev will expect it to remedy
the situation, no matter what, when it returns. That is,
libev will generally retry the requested operation, or, if
the condition doesn&rsquo;t go away, do bad stuff (such as
abort).</p>

<p style="margin-left:17%; margin-top: 1em">Example: This
is basically the same thing that libev does internally,
too.</p>

<p style="margin-left:17%; margin-top: 1em">static void
<br>
fatal_error (const char *msg) <br>
{ <br>
perror (msg); <br>
abort (); <br>
} <br>
... <br>
ev_set_syserr_cb (fatal_error);</p>

<p style="margin-left:11%;">ev_feed_signal (int signum)</p>

<p style="margin-left:17%;">This function can be used to
&quot;simulate&quot; a signal receive. It is completely safe
to call this function at any time, from any context,
including signal handlers or random threads.</p>

<p style="margin-left:17%; margin-top: 1em">Its main use is
to customise signal handling in your process, especially in
the presence of threads. For example, you could block
signals by default in all threads (and specifying
&quot;EVFLAG_NOSIGMASK&quot; when creating any loops), and
in one thread, use &quot;sigwait&quot; or any other
mechanism to wait for signals, then &quot;deliver&quot; them
to libev by calling &quot;ev_feed_signal&quot;.</p>

<h2>FUNCTIONS CONTROLLING EVENT LOOPS
<a name="FUNCTIONS CONTROLLING EVENT LOOPS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An event loop
is described by a &quot;struct ev_loop *&quot; (the
&quot;struct&quot; is <i>not</i> optional in this case
unless libev 3 compatibility is disabled, as libev 3 had an
&quot;ev_loop&quot; function colliding with the struct
name).</p>

<p style="margin-left:11%; margin-top: 1em">The library
knows two types of such loops, the <i>default</i> loop,
which supports child process events, and dynamically created
event loops which do not. <br>
struct ev_loop *ev_default_loop (unsigned int flags)</p>

<p style="margin-left:17%;">This returns the
&quot;default&quot; event loop object, which is what you
should normally use when you just need &quot;the event
loop&quot;. Event loop objects and the &quot;flags&quot;
parameter are described in more detail in the entry for
&quot;ev_loop_new&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If the default
loop is already initialised then this function simply
returns it (and ignores the flags. If that is troubling you,
check &quot;ev_backend ()&quot; afterwards). Otherwise it
will create it with the given flags, which should almost
always be 0, unless the caller is also the one calling
&quot;ev_run&quot; or otherwise qualifies as &quot;the main
program&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">If you
don&rsquo;t know what event loop to use, use the one
returned from this function (or via the
&quot;EV_DEFAULT&quot; macro).</p>

<p style="margin-left:17%; margin-top: 1em">Note that this
function is <i>not</i> thread-safe, so if you want to use it
from multiple threads, you have to employ some kind of mutex
(note also that this case is unlikely, as loops cannot be
shared easily between threads anyway).</p>

<p style="margin-left:17%; margin-top: 1em">The default
loop is the only loop that can handle &quot;ev_child&quot;
watchers, and to do this, it always registers a handler for
&quot;SIGCHLD&quot;. If this is a problem for your
application you can either create a dynamic loop with
&quot;ev_loop_new&quot; which doesn&rsquo;t do that, or you
can simply overwrite the &quot;SIGCHLD&quot; signal handler
<i>after</i> calling &quot;ev_default_init&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Example: This
is the most typical usage.</p>

<p style="margin-left:17%; margin-top: 1em">if
(!ev_default_loop (0)) <br>
fatal (&quot;could not initialise libev, bad $LIBEV_FLAGS in
environment?&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">Example:
Restrict libev to the select and poll backends, and do not
allow environment settings to be taken into account:</p>


<p style="margin-left:17%; margin-top: 1em">ev_default_loop
(EVBACKEND_POLL | EVBACKEND_SELECT | EVFLAG_NOENV);</p>

<p style="margin-left:11%;">struct ev_loop *ev_loop_new
(unsigned int flags)</p>

<p style="margin-left:17%;">This will create and initialise
a new event loop object. If the loop could not be
initialised, returns false.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is thread-safe, and one common way to use libev with threads
is indeed to create one loop per thread, and using the
default loop in the &quot;main&quot; or &quot;initial&quot;
thread.</p>

<p style="margin-left:17%; margin-top: 1em">The flags
argument can be used to specify special behaviour or
specific backends to use, and is usually specified as 0 (or
&quot;EVFLAG_AUTO&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">The following
flags are supported: <br>
&quot;EVFLAG_AUTO&quot;</p>

<p style="margin-left:23%;">The default flags value. Use
this if you have no clue (it&rsquo;s the right thing,
believe me).</p>

<p style="margin-left:17%;">&quot;EVFLAG_NOENV&quot;</p>

<p style="margin-left:23%;">If this flag bit is or&rsquo;ed
into the flag value (or the program runs setuid or setgid)
then libev will <i>not</i> look at the environment variable
&quot;LIBEV_FLAGS&quot;. Otherwise (the default), this
environment variable will override the flags completely if
it is found in the environment. This is useful to try out
specific backends to test their performance, to work around
bugs, or to make libev threadsafe (accessing environment
variables cannot be done in a threadsafe way, but usually it
works if no other thread modifies them).</p>


<p style="margin-left:17%;">&quot;EVFLAG_FORKCHECK&quot;</p>

<p style="margin-left:23%;">Instead of calling
&quot;ev_loop_fork&quot; manually after a fork, you can also
make libev check for a fork in each iteration by enabling
this flag.</p>

<p style="margin-left:23%; margin-top: 1em">This works by
calling &quot;getpid ()&quot; on every iteration of the
loop, and thus this might slow down your event loop if you
do a lot of loop iterations and little real work, but is
usually not noticeable (on my GNU/Linux system for example,
&quot;getpid&quot; is actually a simple 5&minus;insn
sequence without a system call and thus <i>very</i> fast,
but my GNU/Linux system also has &quot;pthread_atfork&quot;
which is even faster). (Update: glibc versions 2.25
apparently removed the &quot;getpid&quot; optimisation
again).</p>

<p style="margin-left:23%; margin-top: 1em">The big
advantage of this flag is that you can forget about fork
(and forget about forgetting to tell libev about forking,
although you still have to ignore &quot;SIGPIPE&quot;) when
you use this flag.</p>

<p style="margin-left:23%; margin-top: 1em">This flag
setting cannot be overridden or specified in the
&quot;LIBEV_FLAGS&quot; environment variable.</p>


<p style="margin-left:17%;">&quot;EVFLAG_NOINOTIFY&quot;</p>

<p style="margin-left:23%;">When this flag is specified,
then libev will not attempt to use the <i>inotify</i>
<small>API</small> for its &quot;ev_stat&quot; watchers.
Apart from debugging and testing, this flag can be useful to
conserve inotify file descriptors, as otherwise each loop
using &quot;ev_stat&quot; watchers consumes one inotify
handle.</p>


<p style="margin-left:17%;">&quot;EVFLAG_SIGNALFD&quot;</p>

<p style="margin-left:23%;">When this flag is specified,
then libev will attempt to use the <i>signalfd</i>
<small>API</small> for its &quot;ev_signal&quot; (and
&quot;ev_child&quot;) watchers. This <small>API</small>
delivers signals synchronously, which makes it both faster
and might make it possible to get the queued signal data. It
can also simplify signal handling with threads, as long as
you properly block signals in your threads that are not
interested in handling them.</p>

<p style="margin-left:23%; margin-top: 1em">Signalfd will
not be used by default as this changes your signal mask, and
there are a lot of shoddy libraries and programs
(glib&rsquo;s threadpool for example) that can&rsquo;t
properly initialise their signal masks.</p>


<p style="margin-left:17%;">&quot;EVFLAG_NOSIGMASK&quot;</p>

<p style="margin-left:23%;">When this flag is specified,
then libev will avoid to modify the signal mask.
Specifically, this means you have to make sure signals are
unblocked when you want to receive them.</p>

<p style="margin-left:23%; margin-top: 1em">This behaviour
is useful when you want to do your own signal handling, or
want to handle signals only in specific threads and want to
avoid libev unblocking the signals.</p>

<p style="margin-left:23%; margin-top: 1em">It&rsquo;s also
required by <small>POSIX</small> in a threaded program, as
libev calls &quot;sigprocmask&quot;, whose behaviour is
officially unspecified.</p>


<p style="margin-left:17%;">&quot;EVFLAG_NOTIMERFD&quot;</p>

<p style="margin-left:23%;">When this flag is specified,
the libev will avoid using a &quot;timerfd&quot; to detect
time jumps. It will still be able to detect time jumps, but
takes longer and has a lower accuracy in doing so, but saves
a file descriptor per loop.</p>

<p style="margin-left:23%; margin-top: 1em">The current
implementation only tries to use a &quot;timerfd&quot; when
the first &quot;ev_periodic&quot; watcher is started and
falls back on other methods if it cannot be created, but
this behaviour might change in the future.</p>

<p style="margin-left:17%;">&quot;EVBACKEND_SELECT&quot;
(value 1, portable select backend)</p>

<p style="margin-left:23%;">This is your standard
<b>select</b>(2) backend. Not <i>completely</i> standard, as
libev tries to roll its own fd_set with no limits on the
number of fds, but if that fails, expect a fairly low limit
on the number of fds when using this backend. It
doesn&rsquo;t scale too well (O(highest_fd)), but its
usually the fastest backend for a low number of
(low-numbered :) fds.</p>

<p style="margin-left:23%; margin-top: 1em">To get good
performance out of this backend you need a high amount of
parallelism (most of the file descriptors should be busy).
If you are writing a server, you should &quot;accept
()&quot; in a loop to accept as many connections as possible
during one iteration. You might also want to have a look at
&quot;ev_set_io_collect_interval ()&quot; to increase the
amount of readiness notifications you get per iteration.</p>

<p style="margin-left:23%; margin-top: 1em">This backend
maps &quot;EV_READ&quot; to the &quot;readfds&quot; set and
&quot;EV_WRITE&quot; to the &quot;writefds&quot; set (and to
work around Microsoft Windows bugs, also onto the
&quot;exceptfds&quot; set on that platform).</p>

<p style="margin-left:17%;">&quot;EVBACKEND_POLL&quot;
(value 2, poll backend, available everywhere <br>
except on windows)</p>

<p style="margin-left:23%;">And this is your standard
<b>poll</b>(2) backend. It&rsquo;s more complicated than
select, but handles sparse fds better and has no artificial
limit on the number of fds you can use (except it will slow
down considerably with a lot of inactive fds). It scales
similarly to select, i.e. O(total_fds). See the entry for
&quot;EVBACKEND_SELECT&quot;, above, for performance
tips.</p>

<p style="margin-left:23%; margin-top: 1em">This backend
maps &quot;EV_READ&quot; to &quot;POLLIN | POLLERR |
POLLHUP&quot;, and &quot;EV_WRITE&quot; to &quot;POLLOUT |
POLLERR | POLLHUP&quot;.</p>

<p style="margin-left:17%;">&quot;EVBACKEND_EPOLL&quot;
(value 4, Linux)</p>

<p style="margin-left:23%;">Use the Linux-specific
<b>epoll</b>(7) interface (for both pre&minus; and
post&minus;2.6.9 kernels).</p>

<p style="margin-left:23%; margin-top: 1em">For few fds,
this backend is a bit little slower than poll and select,
but it scales phenomenally better. While poll and select
usually scale like O(total_fds) where total_fds is the total
number of fds (or the highest fd), epoll scales either O(1)
or O(active_fds).</p>

<p style="margin-left:23%; margin-top: 1em">The epoll
mechanism deserves honorable mention as the most misdesigned
of the more advanced event mechanisms: mere annoyances
include silently dropping file descriptors, requiring a
system call per change per file descriptor (and unnecessary
guessing of parameters), problems with dup, returning before
the timeout value, resulting in additional iterations (and
only giving 5ms accuracy while select on the same platform
gives 0.1ms) and so on. The biggest issue is fork races,
however &minus; if a program forks then <i>both</i> parent
and child process have to recreate the epoll set, which can
take considerable time (one syscall per file descriptor) and
is of course hard to detect.</p>

<p style="margin-left:23%; margin-top: 1em">Epoll is also
notoriously buggy &minus; embedding epoll fds <i>should</i>
work, but of course <i>doesn&rsquo;t</i>, and epoll just
loves to report events for totally <i>different</i> file
descriptors (even already closed ones, so one cannot even
remove them from the set) than registered in the set
(especially on <small>SMP</small> systems). Libev tries to
counter these spurious notifications by employing an
additional generation counter and comparing that against the
events to filter out spurious ones, recreating the set when
required. Epoll also erroneously rounds down timeouts, but
gives you no way to know when and by how much, so sometimes
you have to busy-wait because epoll returns immediately
despite a nonzero timeout. And last not least, it also
refuses to work with some file descriptors which work
perfectly fine with &quot;select&quot; (files, many
character devices...).</p>

<p style="margin-left:23%; margin-top: 1em">Epoll is truly
the train wreck among event poll mechanisms, a frankenpoll,
cobbled together in a hurry, no thought to design or
interaction with others. Oh, the pain, will it ever
stop...</p>

<p style="margin-left:23%; margin-top: 1em">While stopping,
setting and starting an I/O watcher in the same iteration
will result in some caching, there is still a system call
per such incident (because the same <i>file descriptor</i>
could point to a different <i>file description</i> now), so
its best to avoid that. Also, &quot;dup ()&quot;&rsquo;ed
file descriptors might not work very well if you register
events for both file descriptors.</p>

<p style="margin-left:23%; margin-top: 1em">Best
performance from this backend is achieved by not
unregistering all watchers for a file descriptor until it
has been closed, if possible, i.e. keep at least one watcher
active per fd at all times. Stopping and starting a watcher
(without re-setting it) also usually doesn&rsquo;t cause
extra overhead. A fork can both result in spurious
notifications as well as in libev having to destroy and
recreate the epoll object, which can take considerable time
and thus should be avoided.</p>

<p style="margin-left:23%; margin-top: 1em">All this means
that, in practice, &quot;EVBACKEND_SELECT&quot; can be as
fast or faster than epoll for maybe up to a hundred file
descriptors, depending on the usage. So sad.</p>

<p style="margin-left:23%; margin-top: 1em">While nominally
embeddable in other event loops, this feature is broken in a
lot of kernel revisions, but probably(!) works in current
versions.</p>

<p style="margin-left:23%; margin-top: 1em">This backend
maps &quot;EV_READ&quot; and &quot;EV_WRITE&quot; in the
same way as &quot;EVBACKEND_POLL&quot;.</p>

<p style="margin-left:17%;">&quot;EVBACKEND_LINUXAIO&quot;
(value 64, Linux)</p>

<p style="margin-left:23%;">Use the Linux-specific Linux
<small>AIO</small> (<i>not</i> aio(7) but io_submit(2))
event interface available in post&minus;4.18 kernels (but
libev only tries to use it in 4.19+).</p>

<p style="margin-left:23%; margin-top: 1em">This is another
Linux train wreck of an event interface.</p>

<p style="margin-left:23%; margin-top: 1em">If this backend
works for you (as of this writing, it was very
experimental), it is the best event interface available on
Linux and might be well worth enabling it &minus; if it
isn&rsquo;t available in your kernel this will be detected
and this backend will be skipped.</p>

<p style="margin-left:23%; margin-top: 1em">This backend
can batch oneshot requests and supports a user-space ring
buffer to receive events. It also doesn&rsquo;t suffer from
most of the design problems of epoll (such as not being able
to remove event sources from the epoll set), and generally
sounds too good to be true. Because, this being the Linux
kernel, of course it suffers from a whole new set of
limitations, forcing you to fall back to epoll, inheriting
all its design issues.</p>

<p style="margin-left:23%; margin-top: 1em">For one, it is
not easily embeddable (but probably could be done using an
event fd at some extra overhead). It also is subject to a
system wide limit that can be configured in
<i>/proc/sys/fs/aio&minus;max&minus;nr</i>. If no
<small>AIO</small> requests are left, this backend will be
skipped during initialisation, and will switch to epoll when
the loop is active.</p>

<p style="margin-left:23%; margin-top: 1em">Most
problematic in practice, however, is that not all file
descriptors work with it. For example, in Linux 5.1,
<small>TCP</small> sockets, pipes, event fds, files,
<i>/dev/null</i> and many others are supported, but ttys do
not work properly (a known bug that the kernel developers
don&rsquo;t care about, see
&lt;https://lore.kernel.org/patchwork/patch/1047453/&gt;),
so this is not (yet?) a generic event polling interface.</p>

<p style="margin-left:23%; margin-top: 1em">Overall, it
seems the Linux developers just don&rsquo;t want it to have
a generic event handling mechanism other than
&quot;select&quot; or &quot;poll&quot;.</p>

<p style="margin-left:23%; margin-top: 1em">To work around
all these problem, the current version of libev uses its
epoll backend as a fallback for file descriptor types that
do not work. Or falls back completely to epoll if the kernel
acts up.</p>

<p style="margin-left:23%; margin-top: 1em">This backend
maps &quot;EV_READ&quot; and &quot;EV_WRITE&quot; in the
same way as &quot;EVBACKEND_POLL&quot;.</p>

<p style="margin-left:17%;">&quot;EVBACKEND_KQUEUE&quot;
(value 8, most <small>BSD</small> clones)</p>

<p style="margin-left:23%;">Kqueue deserves special
mention, as at the time this backend was implemented, it was
broken on all BSDs except NetBSD (usually it doesn&rsquo;t
work reliably with anything but sockets and pipes, except on
Darwin, where of course it&rsquo;s completely useless).
Unlike epoll, however, whose brokenness is by design, these
kqueue bugs can be (and mostly have been) fixed without
<small>API</small> changes to existing programs. For this
reason it&rsquo;s not being &quot;auto-detected&quot; on all
platforms unless you explicitly specify it in the flags
(i.e. using &quot;EVBACKEND_KQUEUE&quot;) or libev was
compiled on a known-to-be-good (&minus;enough) system like
NetBSD.</p>

<p style="margin-left:23%; margin-top: 1em">You still can
embed kqueue into a normal poll or select backend and use it
only for sockets (after having made sure that sockets work
with kqueue on the target platform). See
&quot;ev_embed&quot; watchers for more info.</p>

<p style="margin-left:23%; margin-top: 1em">It scales in
the same way as the epoll backend, but the interface to the
kernel is more efficient (which says nothing about its
actual speed, of course). While stopping, setting and
starting an I/O watcher does never cause an extra system
call as with &quot;EVBACKEND_EPOLL&quot;, it still adds up
to two event changes per incident. Support for &quot;fork
()&quot; is very bad (you might have to leak fds on fork,
but it&rsquo;s more sane than epoll) and it drops fds
silently in similarly hard-to-detect cases.</p>

<p style="margin-left:23%; margin-top: 1em">This backend
usually performs well under most conditions.</p>

<p style="margin-left:23%; margin-top: 1em">While nominally
embeddable in other event loops, this doesn&rsquo;t work
everywhere, so you might need to test for this. And since it
is broken almost everywhere, you should only use it when you
have a lot of sockets (for which it usually works), by
embedding it into another event loop (e.g.
&quot;EVBACKEND_SELECT&quot; or &quot;EVBACKEND_POLL&quot;
(but &quot;poll&quot; is of course also broken on <small>OS
X</small> )) and, did I mention it, using it only for
sockets.</p>

<p style="margin-left:23%; margin-top: 1em">This backend
maps &quot;EV_READ&quot; into an &quot;EVFILT_READ&quot;
kevent with &quot;NOTE_EOF&quot;, and &quot;EV_WRITE&quot;
into an &quot;EVFILT_WRITE&quot; kevent with
&quot;NOTE_EOF&quot;.</p>

<p style="margin-left:17%;">&quot;EVBACKEND_DEVPOLL&quot;
(value 16, Solaris 8)</p>

<p style="margin-left:23%;">This is not implemented yet
(and might never be, unless you send me an implementation).
According to reports, &quot;/dev/poll&quot; only supports
sockets and is not embeddable, which would limit the
usefulness of this backend immensely.</p>

<p style="margin-left:17%;">&quot;EVBACKEND_PORT&quot;
(value 32, Solaris 10)</p>

<p style="margin-left:23%;">This uses the Solaris 10 event
port mechanism. As with everything on Solaris, it&rsquo;s
really slow, but it still scales very well
(O(active_fds)).</p>

<p style="margin-left:23%; margin-top: 1em">While this
backend scales well, it requires one system call per active
file descriptor per loop iteration. For small and medium
numbers of file descriptors a &quot;slow&quot;
&quot;EVBACKEND_SELECT&quot; or &quot;EVBACKEND_POLL&quot;
backend might perform better.</p>

<p style="margin-left:23%; margin-top: 1em">On the positive
side, this backend actually performed fully to specification
in all tests and is fully embeddable, which is a rare feat
among the OS-specific backends (I vastly prefer correctness
over speed hacks).</p>

<p style="margin-left:23%; margin-top: 1em">On the negative
side, the interface is <i>bizarre</i> &minus; so bizarre
that even sun itself gets it wrong in their code examples:
The event polling function sometimes returns events to the
caller even though an error occurred, but with no indication
whether it has done so or not (yes, it&rsquo;s even
documented that way) &minus; deadly for edge-triggered
interfaces where you absolutely have to know whether an
event occurred or not because you have to re-arm the
watcher.</p>

<p style="margin-left:23%; margin-top: 1em">Fortunately
libev seems to be able to work around these idiocies.</p>

<p style="margin-left:23%; margin-top: 1em">This backend
maps &quot;EV_READ&quot; and &quot;EV_WRITE&quot; in the
same way as &quot;EVBACKEND_POLL&quot;.</p>

<p style="margin-left:17%;">&quot;EVBACKEND_ALL&quot;</p>

<p style="margin-left:23%;">Try all backends (even
potentially broken ones that wouldn&rsquo;t be tried with
&quot;EVFLAG_AUTO&quot;). Since this is a mask, you can do
stuff such as &quot;EVBACKEND_ALL &amp;
~EVBACKEND_KQUEUE&quot;.</p>

<p style="margin-left:23%; margin-top: 1em">It is
definitely not recommended to use this flag, use whatever
&quot;ev_recommended_backends ()&quot; returns, or simply do
not specify a backend at all.</p>

<p style="margin-left:17%;">&quot;EVBACKEND_MASK&quot;</p>

<p style="margin-left:23%;">Not a backend at all, but a
mask to select all backend bits from a &quot;flags&quot;
value, in case you want to mask out any backends from a
flags value (e.g. when modifying the &quot;LIBEV_FLAGS&quot;
environment variable).</p>

<p style="margin-left:17%; margin-top: 1em">If one or more
of the backend flags are or&rsquo;ed into the flags value,
then only these backends will be tried (in the reverse order
as listed here). If none are specified, all backends in
&quot;ev_recommended_backends ()&quot; will be tried.</p>

<p style="margin-left:17%; margin-top: 1em">Example: Try to
create a event loop that uses epoll and nothing else.</p>

<p style="margin-left:17%; margin-top: 1em">struct ev_loop
*epoller = ev_loop_new (EVBACKEND_EPOLL | EVFLAG_NOENV);
<br>
if (!epoller) <br>
fatal (&quot;no epoll found here, maybe it hides under your
chair&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">Example: Use
whatever libev has to offer, but make sure that kqueue is
used if available.</p>

<p style="margin-left:17%; margin-top: 1em">struct ev_loop
*loop = ev_loop_new (ev_recommended_backends () |
EVBACKEND_KQUEUE);</p>

<p style="margin-left:17%; margin-top: 1em">Example:
Similarly, on linux, you mgiht want to take advantage of the
linux aio backend if possible, but fall back to something
else if that isn&rsquo;t available.</p>

<p style="margin-left:17%; margin-top: 1em">struct ev_loop
*loop = ev_loop_new (ev_recommended_backends () |
EVBACKEND_LINUXAIO);</p>

<p style="margin-left:11%;">ev_loop_destroy (loop)</p>

<p style="margin-left:17%;">Destroys an event loop object
(frees all memory and kernel state etc.). None of the active
event watchers will be stopped in the normal sense, so e.g.
&quot;ev_is_active&quot; might still return true. It is your
responsibility to either stop all watchers cleanly yourself
<i>before</i> calling this function, or cope with the fact
afterwards (which is usually the easiest thing, you can just
ignore the watchers and/or &quot;free ()&quot; them for
example).</p>

<p style="margin-left:17%; margin-top: 1em">Note that
certain global state, such as signal state (and installed
signal handlers), will not be freed by this function, and
related watchers (such as signal and child watchers) would
need to be stopped manually.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is normally used on loop objects allocated by
&quot;ev_loop_new&quot;, but it can also be used on the
default loop returned by &quot;ev_default_loop&quot;, in
which case it is not thread-safe.</p>

<p style="margin-left:17%; margin-top: 1em">Note that it is
not advisable to call this function on the default loop
except in the rare occasion where you really need to free
its resources. If you need dynamically allocated loops it is
better to use &quot;ev_loop_new&quot; and
&quot;ev_loop_destroy&quot;.</p>

<p style="margin-left:11%;">ev_loop_fork (loop)</p>

<p style="margin-left:17%;">This function sets a flag that
causes subsequent &quot;ev_run&quot; iterations to
reinitialise the kernel state for backends that have one.
Despite the name, you can call it anytime you are allowed to
start or stop watchers (except inside an
&quot;ev_prepare&quot; callback), but it makes most sense
after forking, in the child process. You <i>must</i> call it
(or use &quot;EVFLAG_FORKCHECK&quot;) in the child before
resuming or calling &quot;ev_run&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">In addition, if
you want to reuse a loop (via this function or
&quot;EVFLAG_FORKCHECK&quot;), you <i>also</i> have to
ignore &quot;SIGPIPE&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Again, you
<i>have</i> to call it on <i>any</i> loop that you want to
re-use after a fork, <i>even if you do not plan to use the
loop in the parent</i>. This is because some kernel
interfaces *cough* <i>kqueue</i> *cough* do funny things
during fork.</p>

<p style="margin-left:17%; margin-top: 1em">On the other
hand, you only need to call this function in the child
process if and only if you want to use the event loop in the
child. If you just fork+exec or create a new loop in the
child, you don&rsquo;t have to call it at all (in fact,
&quot;epoll&quot; is so badly broken that it makes a
difference, but libev will usually detect this case on its
own and do a costly reset of the backend).</p>

<p style="margin-left:17%; margin-top: 1em">The function
itself is quite fast and it&rsquo;s usually not a problem to
call it just in case after a fork.</p>

<p style="margin-left:17%; margin-top: 1em">Example:
Automate calling &quot;ev_loop_fork&quot; on the default
loop when using pthreads.</p>

<p style="margin-left:17%; margin-top: 1em">static void
<br>
post_fork_child (void) <br>
{ <br>
ev_loop_fork (EV_DEFAULT); <br>
} <br>
... <br>
pthread_atfork (0, 0, post_fork_child);</p>

<p style="margin-left:11%;">int ev_is_default_loop
(loop)</p>

<p style="margin-left:17%;">Returns true when the given
loop is, in fact, the default loop, and false otherwise.</p>

<p style="margin-left:11%;">unsigned int ev_iteration
(loop)</p>

<p style="margin-left:17%;">Returns the current iteration
count for the event loop, which is identical to the number
of times libev did poll for new events. It starts at 0 and
happily wraps around with enough iterations.</p>

<p style="margin-left:17%; margin-top: 1em">This value can
sometimes be useful as a generation counter of sorts (it
&quot;ticks&quot; the number of loop iterations), as it
roughly corresponds with &quot;ev_prepare&quot; and
&quot;ev_check&quot; calls &minus; and is incremented
between the prepare and check phases.</p>

<p style="margin-left:11%;">unsigned int ev_depth
(loop)</p>

<p style="margin-left:17%;">Returns the number of times
&quot;ev_run&quot; was entered minus the number of times
&quot;ev_run&quot; was exited normally, in other words, the
recursion depth.</p>

<p style="margin-left:17%; margin-top: 1em">Outside
&quot;ev_run&quot;, this number is zero. In a callback, this
number is 1, unless &quot;ev_run&quot; was invoked
recursively (or from another thread), in which case it is
higher.</p>

<p style="margin-left:17%; margin-top: 1em">Leaving
&quot;ev_run&quot; abnormally (setjmp/longjmp, cancelling
the thread, throwing an exception etc.), doesn&rsquo;t count
as &quot;exit&quot; &minus; consider this as a hint to avoid
such ungentleman-like behaviour unless it&rsquo;s really
convenient, in which case it is fully supported.</p>

<p style="margin-left:11%;">unsigned int ev_backend
(loop)</p>

<p style="margin-left:17%;">Returns one of the
&quot;EVBACKEND_*&quot; flags indicating the event backend
in use.</p>

<p style="margin-left:11%;">ev_tstamp ev_now (loop)</p>

<p style="margin-left:17%;">Returns the current &quot;event
loop time&quot;, which is the time the event loop received
events and started processing them. This timestamp does not
change as long as callbacks are being processed, and this is
also the base time used for relative timers. You can treat
it as the timestamp of the event occurring (or more
correctly, libev finding out about it).</p>

<p style="margin-left:11%;">ev_now_update (loop)</p>

<p style="margin-left:17%;">Establishes the current time by
querying the kernel, updating the time returned by
&quot;ev_now ()&quot; in the progress. This is a costly
operation and is usually done automatically within
&quot;ev_run ()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is rarely useful, but when some event callback runs for a
very long time without entering the event loop, updating
libev&rsquo;s idea of the current time is a good idea.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;The special problem of time updates&quot; in the
&quot;ev_timer&quot; section.</p>

<p style="margin-left:11%;">ev_suspend (loop) <br>
ev_resume (loop)</p>

<p style="margin-left:17%;">These two functions suspend and
resume an event loop, for use when the loop is not used for
a while and timeouts should not be processed.</p>

<p style="margin-left:17%; margin-top: 1em">A typical use
case would be an interactive program such as a game: When
the user presses &quot;^Z&quot; to suspend the game and
resumes it an hour later it would be best to handle timeouts
as if no time had actually passed while the program was
suspended. This can be achieved by calling
&quot;ev_suspend&quot; in your &quot;SIGTSTP&quot; handler,
sending yourself a &quot;SIGSTOP&quot; and calling
&quot;ev_resume&quot; directly afterwards to resume timer
processing.</p>

<p style="margin-left:17%; margin-top: 1em">Effectively,
all &quot;ev_timer&quot; watchers will be delayed by the
time spend between &quot;ev_suspend&quot; and
&quot;ev_resume&quot;, and all &quot;ev_periodic&quot;
watchers will be rescheduled (that is, they will lose any
events that would have occurred while suspended).</p>

<p style="margin-left:17%; margin-top: 1em">After calling
&quot;ev_suspend&quot; you <b>must not</b> call <i>any</i>
function on the given loop other than &quot;ev_resume&quot;,
and you <b>must not</b> call &quot;ev_resume&quot; without a
previous call to &quot;ev_suspend&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Calling
&quot;ev_suspend&quot;/&quot;ev_resume&quot; has the side
effect of updating the event loop time (see
&quot;ev_now_update&quot;).</p>

<p style="margin-left:11%;">bool ev_run (loop, int
flags)</p>

<p style="margin-left:17%;">Finally, this is it, the event
handler. This function usually is called after you have
initialised all your watchers and you want to start handling
events. It will ask the operating system for any new events,
call the watcher callbacks, and then repeat the whole
process indefinitely: This is why event loops are called
<i>loops</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If the flags
argument is specified as 0, it will keep handling events
until either no event watchers are active anymore or
&quot;ev_break&quot; was called.</p>

<p style="margin-left:17%; margin-top: 1em">The return
value is false if there are no more active watchers (which
usually means &quot;all jobs done&quot; or
&quot;deadlock&quot;), and true in all other cases (which
usually means &quot; you should call &quot;ev_run&quot;
again&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">Please note
that an explicit &quot;ev_break&quot; is usually better than
relying on all watchers to be stopped when deciding when a
program has finished (especially in interactive programs),
but having a program that automatically loops as long as it
has to and no longer by virtue of relying on its watchers
stopping correctly, that is truly a thing of beauty.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is <i>mostly</i> exception-safe &minus; you can break out of
a &quot;ev_run&quot; call by calling &quot;longjmp&quot; in
a callback, throwing a C <small>++</small> exception and so
on. This does not decrement the &quot;ev_depth&quot; value,
nor will it clear any outstanding &quot;EVBREAK_ONE&quot;
breaks.</p>

<p style="margin-left:17%; margin-top: 1em">A flags value
of &quot;EVRUN_NOWAIT&quot; will look for new events, will
handle those events and any already outstanding ones, but
will not wait and block your process in case there are no
events and will return after one iteration of the loop. This
is sometimes useful to poll and handle new events while
doing lengthy calculations, to keep the program
responsive.</p>

<p style="margin-left:17%; margin-top: 1em">A flags value
of &quot;EVRUN_ONCE&quot; will look for new events (waiting
if necessary) and will handle those and any already
outstanding ones. It will block your process until at least
one new event arrives (which could be an event internal to
libev itself, so there is no guarantee that a
user-registered callback will be called), and will return
after one iteration of the loop.</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
if you are waiting for some external event in conjunction
with something not expressible using other libev watchers
(i.e. &quot;roll your own &quot;ev_run&quot;&quot;).
However, a pair of
&quot;ev_prepare&quot;/&quot;ev_check&quot; watchers is
usually a better approach for this kind of thing.</p>

<p style="margin-left:17%; margin-top: 1em">Here are the
gory details of what &quot;ev_run&quot; does (this is for
your understanding, not a guarantee that things will work
exactly like this in future versions):</p>

<p style="margin-left:17%; margin-top: 1em">&minus;
Increment loop depth. <br>
&minus; Reset the ev_break status. <br>
&minus; Before the first iteration, call any pending
watchers. <br>
LOOP: <br>
&minus; If EVFLAG_FORKCHECK was used, check for a fork. <br>
&minus; If a fork was detected (by any means), queue and
call all fork watchers. <br>
&minus; Queue and call all prepare watchers. <br>
&minus; If ev_break was called, goto FINISH. <br>
&minus; If we have been forked, detach and recreate the
kernel state <br>
as to not disturb the other process. <br>
&minus; Update the kernel state with all outstanding
changes. <br>
&minus; Update the &quot;event loop time&quot; (ev_now ()).
<br>
&minus; Calculate for how long to sleep or block, if at all
<br>
(active idle watchers, EVRUN_NOWAIT or not having <br>
any active watchers at all will result in not sleeping).
<br>
&minus; Sleep if the I/O and timer collect interval say so.
<br>
&minus; Increment loop iteration counter. <br>
&minus; Block the process, waiting for any events. <br>
&minus; Queue all outstanding I/O (fd) events. <br>
&minus; Update the &quot;event loop time&quot; (ev_now ()),
and do time jump adjustments. <br>
&minus; Queue all expired timers. <br>
&minus; Queue all expired periodics. <br>
&minus; Queue all idle watchers with priority higher than
that of pending events. <br>
&minus; Queue all check watchers. <br>
&minus; Call all queued watchers in reverse order (i.e.
check watchers first). <br>
Signals and child watchers are implemented as I/O watchers,
and will <br>
be handled here by queueing them when their watcher gets
executed. <br>
&minus; If ev_break has been called, or EVRUN_ONCE or
EVRUN_NOWAIT <br>
were used, or there are no active watchers, goto FINISH,
otherwise <br>
continue with step LOOP. <br>
FINISH: <br>
&minus; Reset the ev_break status iff it was EVBREAK_ONE.
<br>
&minus; Decrement the loop depth. <br>
&minus; Return.</p>

<p style="margin-left:17%; margin-top: 1em">Example: Queue
some jobs and then loop until no events are outstanding
anymore.</p>

<p style="margin-left:17%; margin-top: 1em">... queue jobs
here, make sure they register event watchers as long <br>
... as they still have work to do (even an idle watcher will
do..) <br>
ev_run (my_loop, 0); <br>
... jobs done or somebody called break. yeah!</p>

<p style="margin-left:11%;">ev_break (loop, how)</p>

<p style="margin-left:17%;">Can be used to make a call to
&quot;ev_run&quot; return early (but only after it has
processed all outstanding events). The &quot;how&quot;
argument must be either &quot;EVBREAK_ONE&quot;, which will
make the innermost &quot;ev_run&quot; call return, or
&quot;EVBREAK_ALL&quot;, which will make all nested
&quot;ev_run&quot; calls return.</p>

<p style="margin-left:17%; margin-top: 1em">This
&quot;break state&quot; will be cleared on the next call to
&quot;ev_run&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">It is safe to
call &quot;ev_break&quot; from outside any
&quot;ev_run&quot; calls, too, in which case it will have no
effect.</p>

<p style="margin-left:11%;">ev_ref (loop) <br>
ev_unref (loop)</p>

<p style="margin-left:17%;">Ref/unref can be used to add or
remove a reference count on the event loop: Every watcher
keeps one reference, and as long as the reference count is
nonzero, &quot;ev_run&quot; will not return on its own.</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
when you have a watcher that you never intend to unregister,
but that nevertheless should not keep &quot;ev_run&quot;
from returning. In such a case, call &quot;ev_unref&quot;
after starting, and &quot;ev_ref&quot; before stopping
it.</p>

<p style="margin-left:17%; margin-top: 1em">As an example,
libev itself uses this for its internal signal pipe: It is
not visible to the libev user and should not keep
&quot;ev_run&quot; from exiting if no event watchers
registered by it are active. It is also an excellent way to
do this for generic recurring timers or from within
third-party libraries. Just remember to <i>unref after
start</i> and <i>ref before stop</i> (but only if the
watcher wasn&rsquo;t active before, or was active before,
respectively. Note also that libev might stop watchers
itself (e.g. non-repeating timers) in which case you have to
&quot;ev_ref&quot; in the callback).</p>

<p style="margin-left:17%; margin-top: 1em">Example: Create
a signal watcher, but keep it from keeping
&quot;ev_run&quot; running when nothing else is active.</p>

<p style="margin-left:17%; margin-top: 1em">ev_signal
exitsig; <br>
ev_signal_init (&amp;exitsig, sig_cb, SIGINT); <br>
ev_signal_start (loop, &amp;exitsig); <br>
ev_unref (loop);</p>

<p style="margin-left:17%; margin-top: 1em">Example: For
some weird reason, unregister the above signal handler
again.</p>

<p style="margin-left:17%; margin-top: 1em">ev_ref (loop);
<br>
ev_signal_stop (loop, &amp;exitsig);</p>

<p style="margin-left:11%;">ev_set_io_collect_interval
(loop, ev_tstamp interval) <br>
ev_set_timeout_collect_interval (loop, ev_tstamp
interval)</p>

<p style="margin-left:17%;">These advanced functions
influence the time that libev will spend waiting for events.
Both time intervals are by default 0, meaning that libev
will try to invoke timer/periodic callbacks and I/O
callbacks with minimum latency.</p>

<p style="margin-left:17%; margin-top: 1em">Setting these
to a higher value (the &quot;interval&quot; <i>must</i> be
&gt;= 0) allows libev to delay invocation of I/O and
timer/periodic callbacks to increase efficiency of loop
iterations (or to increase power-saving opportunities).</p>

<p style="margin-left:17%; margin-top: 1em">The idea is
that sometimes your program runs just fast enough to handle
one (or very few) event(s) per loop iteration. While this
makes the program responsive, it also wastes a lot of
<small>CPU</small> time to poll for new events, especially
with backends like &quot;select ()&quot; which have a high
overhead for the actual polling but can deliver many events
at once.</p>

<p style="margin-left:17%; margin-top: 1em">By setting a
higher <i>io collect interval</i> you allow libev to spend
more time collecting I/O events, so you can handle more
events per iteration, at the cost of increasing latency.
Timeouts (both &quot;ev_periodic&quot; and
&quot;ev_timer&quot;) will not be affected. Setting this to
a non-null value will introduce an additional &quot;ev_sleep
()&quot; call into most loop iterations. The sleep time
ensures that libev will not poll for I/O events more often
then once per this interval, on average (as long as the host
time resolution is good enough).</p>

<p style="margin-left:17%; margin-top: 1em">Likewise, by
setting a higher <i>timeout collect interval</i> you allow
libev to spend more time collecting timeouts, at the expense
of increased latency/jitter/inexactness (the watcher
callback will be called later). &quot;ev_io&quot; watchers
will not be affected. Setting this to a non-null value will
not introduce any overhead in libev.</p>

<p style="margin-left:17%; margin-top: 1em">Many (busy)
programs can usually benefit by setting the I/O collect
interval to a value near 0.1 or so, which is often enough
for interactive servers (of course not for games), likewise
for timeouts. It usually doesn&rsquo;t make much sense to
set it to a lower value than 0.01, as this approaches the
timing granularity of most systems. Note that if you do
transactions with the outside world and you can&rsquo;t
increase the parallelity, then this setting will limit your
transaction rate (if you need to poll once per transaction
and the I/O collect interval is 0.01, then you can&rsquo;t
do more than 100 transactions per second).</p>

<p style="margin-left:17%; margin-top: 1em">Setting the
<i>timeout collect interval</i> can improve the opportunity
for saving power, as the program will &quot;bundle&quot;
timer callback invocations that are &quot;near&quot; in time
together, by delaying some, thus reducing the number of
times the process sleeps and wakes up again. Another useful
technique to reduce iterations/wake&minus;ups is to use
&quot;ev_periodic&quot; watchers and make sure they fire on,
say, one-second boundaries only.</p>

<p style="margin-left:17%; margin-top: 1em">Example: we
only need 0.1s timeout granularity, and we wish not to poll
more often than 100 times per second:</p>


<p style="margin-left:17%; margin-top: 1em">ev_set_timeout_collect_interval
(EV_DEFAULT_UC_ 0.1); <br>
ev_set_io_collect_interval (EV_DEFAULT_UC_ 0.01);</p>

<p style="margin-left:11%;">ev_invoke_pending (loop)</p>

<p style="margin-left:17%;">This call will simply invoke
all pending watchers while resetting their pending state.
Normally, &quot;ev_run&quot; does this automatically when
required, but when overriding the invoke callback this call
comes handy. This function can be invoked from a watcher
&minus; this can be useful for example when you want to do
some lengthy calculation and want to pass further event
handling to another thread (you still have to make sure only
one thread executes within &quot;ev_invoke_pending&quot; or
&quot;ev_run&quot; of course).</p>

<p style="margin-left:11%;">int ev_pending_count (loop)</p>

<p style="margin-left:17%;">Returns the number of pending
watchers &minus; zero indicates that no watchers are
pending.</p>

<p style="margin-left:11%;">ev_set_invoke_pending_cb (loop,
void (*invoke_pending_cb)( <small>EV_P</small> ))</p>

<p style="margin-left:17%;">This overrides the invoke
pending functionality of the loop: Instead of invoking all
pending watchers when there are any, &quot;ev_run&quot; will
call this callback instead. This is useful, for example,
when you want to invoke the actual watchers inside another
context (another thread etc.).</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
reset the callback, use &quot;ev_invoke_pending&quot; as new
callback.</p>

<p style="margin-left:11%;">ev_set_loop_release_cb (loop,
void (*release)( <small>EV_P</small> ) throw (), void <br>
(*acquire)( <small>EV_P</small> ) throw ())</p>

<p style="margin-left:17%;">Sometimes you want to share the
same loop between multiple threads. This can be done
relatively simply by putting mutex_lock/unlock calls around
each call to a libev function.</p>

<p style="margin-left:17%; margin-top: 1em">However,
&quot;ev_run&quot; can run an indefinite time, so it is not
feasible to wait for it to return. One way around this is to
wake up the event loop via &quot;ev_break&quot; and
&quot;ev_async_send&quot;, another way is to set these
<i>release</i> and <i>acquire</i> callbacks on the loop.</p>

<p style="margin-left:17%; margin-top: 1em">When set, then
&quot;release&quot; will be called just before the thread is
suspended waiting for new events, and &quot;acquire&quot; is
called just afterwards.</p>

<p style="margin-left:17%; margin-top: 1em">Ideally,
&quot;release&quot; will just call your mutex_unlock
function, and &quot;acquire&quot; will just call the
mutex_lock function again.</p>

<p style="margin-left:17%; margin-top: 1em">While event
loop modifications are allowed between invocations of
&quot;release&quot; and &quot;acquire&quot; (that&rsquo;s
their only purpose after all), no modifications done will
affect the event loop, i.e. adding watchers will have no
effect on the set of file descriptors being watched, or the
time waited. Use an &quot;ev_async&quot; watcher to wake up
&quot;ev_run&quot; when you want it to take note of any
changes you made.</p>

<p style="margin-left:17%; margin-top: 1em">In theory,
threads executing &quot;ev_run&quot; will be async-cancel
safe between invocations of &quot;release&quot; and
&quot;acquire&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See also the
locking example in the &quot;THREADS&quot; section later in
this document.</p>

<p style="margin-left:11%;">ev_set_userdata (loop, void
*data) <br>
void *ev_userdata (loop)</p>

<p style="margin-left:17%;">Set and retrieve a single
&quot;void *&quot; associated with a loop. When
&quot;ev_set_userdata&quot; has never been called, then
&quot;ev_userdata&quot; returns 0.</p>

<p style="margin-left:17%; margin-top: 1em">These two
functions can be used to associate arbitrary data with a
loop, and are intended solely for the
&quot;invoke_pending_cb&quot;, &quot;release&quot; and
&quot;acquire&quot; callbacks described above, but of course
can be (ab&minus;)used for any other purpose as well.</p>

<p style="margin-left:11%;">ev_verify (loop)</p>

<p style="margin-left:17%;">This function only does
something when &quot;EV_VERIFY&quot; support has been
compiled in, which is the default for non-minimal builds. It
tries to go through all internal structures and checks them
for validity. If anything is found to be inconsistent, it
will print an error message to standard error and call
&quot;abort ()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This can be
used to catch bugs inside libev itself: under normal
circumstances, this function will never abort as of course
libev keeps its data structures consistent.</p>

<h2>ANATOMY OF A WATCHER
<a name="ANATOMY OF A WATCHER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In the
following description, uppercase &quot;TYPE&quot; in names
stands for the watcher type, e.g. &quot;ev_TYPE_start&quot;
can mean &quot;ev_timer_start&quot; for timer watchers and
&quot;ev_io_start&quot; for I/O watchers.</p>

<p style="margin-left:11%; margin-top: 1em">A watcher is an
opaque structure that you allocate and register to record
your interest in some event. To make a concrete example,
imagine you want to wait for <small>STDIN</small> to become
readable, you would create an &quot;ev_io&quot; watcher for
that:</p>

<p style="margin-left:11%; margin-top: 1em">static void
my_cb (struct ev_loop *loop, ev_io *w, int revents) <br>
{ <br>
ev_io_stop (w); <br>
ev_break (loop, EVBREAK_ALL); <br>
} <br>
struct ev_loop *loop = ev_default_loop (0); <br>
ev_io stdin_watcher; <br>
ev_init (&amp;stdin_watcher, my_cb); <br>
ev_io_set (&amp;stdin_watcher, STDIN_FILENO, EV_READ); <br>
ev_io_start (loop, &amp;stdin_watcher); <br>
ev_run (loop, 0);</p>

<p style="margin-left:11%; margin-top: 1em">As you can see,
you are responsible for allocating the memory for your
watcher structures (and it is <i>usually</i> a bad idea to
do this on the stack).</p>

<p style="margin-left:11%; margin-top: 1em">Each watcher
has an associated watcher structure (called &quot;struct
ev_TYPE&quot; or simply &quot;ev_TYPE&quot;, as typedefs are
provided for all watcher structs).</p>

<p style="margin-left:11%; margin-top: 1em">Each watcher
structure must be initialised by a call to &quot;ev_init
(watcher *, callback)&quot;, which expects a callback to be
provided. This callback is invoked each time the event
occurs (or, in the case of I/O watchers, each time the event
loop detects that the file descriptor given is readable
and/or writable).</p>

<p style="margin-left:11%; margin-top: 1em">Each watcher
type further has its own &quot;ev_TYPE_set (watcher *,
...)&quot; macro to configure it, with arguments specific to
the watcher type. There is also a macro to combine
initialisation and setting in one call: &quot;ev_TYPE_init
(watcher *, callback, ...)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To make the
watcher actually watch out for events, you have to start it
with a watcher-specific start function (&quot;ev_TYPE_start
(loop, watcher *)&quot;), and you can stop watching for
events at any time by calling the corresponding stop
function (&quot;ev_TYPE_stop (loop, watcher *)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">As long as your
watcher is active (has been started but not stopped) you
must not touch the values stored in it except when
explicitly documented otherwise. Most specifically you must
never reinitialise it or call its &quot;ev_TYPE_set&quot;
macro.</p>

<p style="margin-left:11%; margin-top: 1em">Each and every
callback receives the event loop pointer as first, the
registered watcher structure as second, and a bitset of
received events as third argument.</p>

<p style="margin-left:11%; margin-top: 1em">The received
events usually include a single bit per event type received
(you can receive multiple events at the same time). The
possible bit masks are: <br>
&quot;EV_READ&quot; <br>
&quot;EV_WRITE&quot;</p>

<p style="margin-left:17%;">The file descriptor in the
&quot;ev_io&quot; watcher has become readable and/or
writable.</p>

<p style="margin-left:11%;">&quot;EV_TIMER&quot;</p>

<p style="margin-left:17%;">The &quot;ev_timer&quot;
watcher has timed out.</p>

<p style="margin-left:11%;">&quot;EV_PERIODIC&quot;</p>

<p style="margin-left:17%;">The &quot;ev_periodic&quot;
watcher has timed out.</p>

<p style="margin-left:11%;">&quot;EV_SIGNAL&quot;</p>

<p style="margin-left:17%;">The signal specified in the
&quot;ev_signal&quot; watcher has been received by a
thread.</p>

<p style="margin-left:11%;">&quot;EV_CHILD&quot;</p>

<p style="margin-left:17%;">The pid specified in the
&quot;ev_child&quot; watcher has received a status
change.</p>

<p style="margin-left:11%;">&quot;EV_STAT&quot;</p>

<p style="margin-left:17%;">The path specified in the
&quot;ev_stat&quot; watcher changed its attributes
somehow.</p>

<p style="margin-left:11%;">&quot;EV_IDLE&quot;</p>

<p style="margin-left:17%;">The &quot;ev_idle&quot; watcher
has determined that you have nothing better to do.</p>

<p style="margin-left:11%;">&quot;EV_PREPARE&quot; <br>
&quot;EV_CHECK&quot;</p>

<p style="margin-left:17%;">All &quot;ev_prepare&quot;
watchers are invoked just <i>before</i> &quot;ev_run&quot;
starts to gather new events, and all &quot;ev_check&quot;
watchers are queued (not invoked) just after
&quot;ev_run&quot; has gathered them, but before it queues
any callbacks for any received events. That means
&quot;ev_prepare&quot; watchers are the last watchers
invoked before the event loop sleeps or polls for new
events, and &quot;ev_check&quot; watchers will be invoked
before any other watchers of the same or lower priority
within an event loop iteration.</p>

<p style="margin-left:17%; margin-top: 1em">Callbacks of
both watcher types can start and stop as many watchers as
they want, and all of them will be taken into account (for
example, a &quot;ev_prepare&quot; watcher might start an
idle watcher to keep &quot;ev_run&quot; from blocking).</p>

<p style="margin-left:11%;">&quot;EV_EMBED&quot;</p>

<p style="margin-left:17%;">The embedded event loop
specified in the &quot;ev_embed&quot; watcher needs
attention.</p>

<p style="margin-left:11%;">&quot;EV_FORK&quot;</p>

<p style="margin-left:17%;">The event loop has been resumed
in the child process after fork (see
&quot;ev_fork&quot;).</p>

<p style="margin-left:11%;">&quot;EV_CLEANUP&quot;</p>

<p style="margin-left:17%;">The event loop is about to be
destroyed (see &quot;ev_cleanup&quot;).</p>

<p style="margin-left:11%;">&quot;EV_ASYNC&quot;</p>

<p style="margin-left:17%;">The given async watcher has
been asynchronously notified (see &quot;ev_async&quot;).</p>

<p style="margin-left:11%;">&quot;EV_CUSTOM&quot;</p>

<p style="margin-left:17%;">Not ever sent (or otherwise
used) by libev itself, but can be freely used by libev users
to signal watchers (e.g. via &quot;ev_feed_event&quot;).</p>

<p style="margin-left:11%;">&quot;EV_ERROR&quot;</p>

<p style="margin-left:17%;">An unspecified error has
occurred, the watcher has been stopped. This might happen
because the watcher could not be properly started because
libev ran out of memory, a file descriptor was found to be
closed or any other problem. Libev considers these
application bugs.</p>

<p style="margin-left:17%; margin-top: 1em">You best act on
it by reporting the problem and somehow coping with the
watcher being stopped. Note that well-written programs
should not receive an error ever, so when your watcher
receives it, this usually indicates a bug in your
program.</p>

<p style="margin-left:17%; margin-top: 1em">Libev will
usually signal a few &quot;dummy&quot; events together with
an error, for example it might indicate that a fd is
readable or writable, and if your callbacks is well-written
it can just attempt the operation and cope with the error
from <b>read()</b> or <b>write()</b>. This will not work in
multi-threaded programs, though, as the fd could already be
closed and reused for another thing, so beware.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>GENERIC
WATCHER FUNCTIONS</small></b> <br>
&quot;ev_init&quot; (ev_TYPE *watcher, callback)</p>

<p style="margin-left:17%;">This macro initialises the
generic portion of a watcher. The contents of the watcher
object can be arbitrary (so &quot;malloc&quot; will do).
Only the generic parts of the watcher are initialised, you
<i>need</i> to call the type-specific
&quot;ev_TYPE_set&quot; macro afterwards to initialise the
type-specific parts. For each type there is also a
&quot;ev_TYPE_init&quot; macro which rolls both calls into
one.</p>

<p style="margin-left:17%; margin-top: 1em">You can
reinitialise a watcher at any time as long as it has been
stopped (or never started) and there are no pending events
outstanding.</p>

<p style="margin-left:17%; margin-top: 1em">The callback is
always of type &quot;void (*)(struct ev_loop *loop, ev_TYPE
*watcher, int revents)&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Example:
Initialise an &quot;ev_io&quot; watcher in two steps.</p>

<p style="margin-left:17%; margin-top: 1em">ev_io w; <br>
ev_init (&amp;w, my_cb); <br>
ev_io_set (&amp;w, STDIN_FILENO, EV_READ);</p>

<p style="margin-left:11%;">&quot;ev_TYPE_set&quot;
(ev_TYPE *watcher, [args])</p>

<p style="margin-left:17%;">This macro initialises the
type-specific parts of a watcher. You need to call
&quot;ev_init&quot; at least once before you call this
macro, but you can call &quot;ev_TYPE_set&quot; any number
of times. You must not, however, call this macro on a
watcher that is active (it can be pending, however, which is
a difference to the &quot;ev_init&quot; macro).</p>

<p style="margin-left:17%; margin-top: 1em">Although some
watcher types do not have type-specific arguments (e.g.
&quot;ev_prepare&quot;) you still need to call its
&quot;set&quot; macro.</p>

<p style="margin-left:17%; margin-top: 1em">See
&quot;ev_init&quot;, above, for an example.</p>

<p style="margin-left:11%;">&quot;ev_TYPE_init&quot;
(ev_TYPE *watcher, callback, [args])</p>

<p style="margin-left:17%;">This convenience macro rolls
both &quot;ev_init&quot; and &quot;ev_TYPE_set&quot; macro
calls into a single call. This is the most convenient method
to initialise a watcher. The same limitations apply, of
course.</p>

<p style="margin-left:17%; margin-top: 1em">Example:
Initialise and set an &quot;ev_io&quot; watcher in one
step.</p>

<p style="margin-left:17%; margin-top: 1em">ev_io_init
(&amp;w, my_cb, STDIN_FILENO, EV_READ);</p>

<p style="margin-left:11%;">&quot;ev_TYPE_start&quot;
(loop, ev_TYPE *watcher)</p>

<p style="margin-left:17%;">Starts (activates) the given
watcher. Only active watchers will receive events. If the
watcher is already active nothing will happen.</p>

<p style="margin-left:17%; margin-top: 1em">Example: Start
the &quot;ev_io&quot; watcher that is being abused as
example in this whole section.</p>

<p style="margin-left:17%; margin-top: 1em">ev_io_start
(EV_DEFAULT_UC, &amp;w);</p>

<p style="margin-left:11%;">&quot;ev_TYPE_stop&quot; (loop,
ev_TYPE *watcher)</p>

<p style="margin-left:17%;">Stops the given watcher if
active, and clears the pending status (whether the watcher
was active or not).</p>

<p style="margin-left:17%; margin-top: 1em">It is possible
that stopped watchers are pending &minus; for example,
non-repeating timers are being stopped when they become
pending &minus; but calling &quot;ev_TYPE_stop&quot; ensures
that the watcher is neither active nor pending. If you want
to free or reuse the memory used by the watcher it is
therefore a good idea to always call its
&quot;ev_TYPE_stop&quot; function.</p>

<p style="margin-left:11%;">bool ev_is_active (ev_TYPE
*watcher)</p>

<p style="margin-left:17%;">Returns a true value iff the
watcher is active (i.e. it has been started and not yet been
stopped). As long as a watcher is active you must not modify
it.</p>

<p style="margin-left:11%;">bool ev_is_pending (ev_TYPE
*watcher)</p>

<p style="margin-left:17%;">Returns a true value iff the
watcher is pending, (i.e. it has outstanding events but its
callback has not yet been invoked). As long as a watcher is
pending (but not active) you must not call an init function
on it (but &quot;ev_TYPE_set&quot; is safe), you must not
change its priority, and you must make sure the watcher is
available to libev (e.g. you cannot &quot;free ()&quot;
it).</p>

<p style="margin-left:11%;">callback ev_cb (ev_TYPE
*watcher)</p>

<p style="margin-left:17%;">Returns the callback currently
set on the watcher.</p>

<p style="margin-left:11%;">ev_set_cb (ev_TYPE *watcher,
callback)</p>

<p style="margin-left:17%;">Change the callback. You can
change the callback at virtually any time (modulo
threads).</p>

<p style="margin-left:11%;">ev_set_priority (ev_TYPE
*watcher, int priority) <br>
int ev_priority (ev_TYPE *watcher)</p>

<p style="margin-left:17%;">Set and query the priority of
the watcher. The priority is a small integer between
&quot;EV_MAXPRI&quot; (default: 2) and &quot;EV_MINPRI&quot;
(default: &quot;&minus;2&quot;). Pending watchers with
higher priority will be invoked before watchers with lower
priority, but priority will not keep watchers from being
executed (except for &quot;ev_idle&quot; watchers).</p>

<p style="margin-left:17%; margin-top: 1em">If you need to
suppress invocation when higher priority events are pending
you need to look at &quot;ev_idle&quot; watchers, which
provide this functionality.</p>

<p style="margin-left:17%; margin-top: 1em">You <i>must
not</i> change the priority of a watcher as long as it is
active or pending.</p>

<p style="margin-left:17%; margin-top: 1em">Setting a
priority outside the range of &quot;EV_MINPRI&quot; to
&quot;EV_MAXPRI&quot; is fine, as long as you do not mind
that the priority value you query might or might not have
been clamped to the valid range.</p>

<p style="margin-left:17%; margin-top: 1em">The default
priority used by watchers when no priority has been set is
always 0, which is supposed to not be too high and not be
too low :).</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>WATCHER PRIORITY MODELS&quot;</small> , below, for a
more thorough treatment of priorities.</p>

<p style="margin-left:11%;">ev_invoke (loop, ev_TYPE
*watcher, int revents)</p>

<p style="margin-left:17%;">Invoke the &quot;watcher&quot;
with the given &quot;loop&quot; and &quot;revents&quot;.
Neither &quot;loop&quot; nor &quot;revents&quot; need to be
valid as long as the watcher callback can deal with that
fact, as both are simply passed through to the callback.</p>

<p style="margin-left:11%;">int ev_clear_pending (loop,
ev_TYPE *watcher)</p>

<p style="margin-left:17%;">If the watcher is pending, this
function clears its pending status and returns its
&quot;revents&quot; bitset (as if its callback was invoked).
If the watcher isn&rsquo;t pending it does nothing and
returns 0.</p>

<p style="margin-left:17%; margin-top: 1em">Sometimes it
can be useful to &quot;poll&quot; a watcher instead of
waiting for its callback to be invoked, which can be
accomplished with this function.</p>

<p style="margin-left:11%;">ev_feed_event (loop, ev_TYPE
*watcher, int revents)</p>

<p style="margin-left:17%;">Feeds the given event set into
the event loop, as if the specified event had happened for
the specified watcher (which must be a pointer to an
initialised but not necessarily started event watcher).
Obviously you must not free the watcher as long as it has
pending events.</p>

<p style="margin-left:17%; margin-top: 1em">Stopping the
watcher, letting libev invoke it, or calling
&quot;ev_clear_pending&quot; will clear the pending event,
even if the watcher was not started in the first place.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;ev_feed_fd_event&quot; and
&quot;ev_feed_signal_event&quot; for related functions that
do not need a watcher.</p>

<p style="margin-left:11%; margin-top: 1em">See also the
&quot; <small>ASSOCIATING CUSTOM DATA WITH A
WATCHER&quot;</small> and &quot; <small>BUILDING YOUR OWN
COMPOSITE WATCHERS&quot;</small> idioms.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WATCHER
STATES</small></b> <br>
There are various watcher states mentioned throughout this
manual &minus; active, pending and so on. In this section
these states and the rules to transition between them will
be described in more detail &minus; and while these rules
might look complicated, they usually do &quot;the right
thing&quot;. <br>
initialised</p>

<p style="margin-left:17%;">Before a watcher can be
registered with the event loop it has to be initialised.
This can be done with a call to &quot;ev_TYPE_init&quot;, or
calls to &quot;ev_init&quot; followed by the
watcher-specific &quot;ev_TYPE_set&quot; function.</p>

<p style="margin-left:17%; margin-top: 1em">In this state
it is simply some block of memory that is suitable for use
in an event loop. It can be moved around, freed, reused etc.
at will &minus; as long as you either keep the memory
contents intact, or call &quot;ev_TYPE_init&quot; again.</p>

<p style="margin-left:11%;">started/running/active</p>

<p style="margin-left:17%;">Once a watcher has been started
with a call to &quot;ev_TYPE_start&quot; it becomes property
of the event loop, and is actively waiting for events. While
in this state it cannot be accessed (except in a few
documented ways), moved, freed or anything else &minus; the
only legal thing is to keep a pointer to it, and call libev
functions on it that are documented to work on active
watchers.</p>

<p style="margin-left:11%;">pending</p>

<p style="margin-left:17%;">If a watcher is active and
libev determines that an event it is interested in has
occurred (such as a timer expiring), it will become pending.
It will stay in this pending state until either it is
stopped or its callback is about to be invoked, so it is not
normally pending inside the watcher callback.</p>

<p style="margin-left:17%; margin-top: 1em">The watcher
might or might not be active while it is pending (for
example, an expired non-repeating timer can be pending but
no longer active). If it is stopped, it can be freely
accessed (e.g. by calling &quot;ev_TYPE_set&quot;), but it
is still property of the event loop at this time, so cannot
be moved, freed or reused. And if it is active the rules
described in the previous item still apply.</p>

<p style="margin-left:17%; margin-top: 1em">It is also
possible to feed an event on a watcher that is not active
(e.g. via &quot;ev_feed_event&quot;), in which case it
becomes pending without being active.</p>

<p style="margin-left:11%;">stopped</p>

<p style="margin-left:17%;">A watcher can be stopped
implicitly by libev (in which case it might still be
pending), or explicitly by calling its
&quot;ev_TYPE_stop&quot; function. The latter will clear any
pending state the watcher might be in, regardless of whether
it was active or not, so stopping a watcher explicitly
before freeing it is often a good idea.</p>

<p style="margin-left:17%; margin-top: 1em">While stopped
(and not pending) the watcher is essentially in the
initialised state, that is, it can be reused, moved,
modified in any way you wish (but when you trash the memory
block, you need to &quot;ev_TYPE_init&quot; it again).</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WATCHER
PRIORITY MODELS</small></b> <br>
Many event loops support <i>watcher priorities</i>, which
are usually small integers that influence the ordering of
event callback invocation between watchers in some way, all
else being equal.</p>

<p style="margin-left:11%; margin-top: 1em">In libev,
watcher priorities can be set using
&quot;ev_set_priority&quot;. See its description for the
more technical details such as the actual priority
range.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
common ways how these these priorities are being interpreted
by event loops:</p>

<p style="margin-left:11%; margin-top: 1em">In the more
common lock-out model, higher priorities &quot;lock
out&quot; invocation of lower priority watchers, which means
as long as higher priority watchers receive events, lower
priority watchers are not being invoked.</p>

<p style="margin-left:11%; margin-top: 1em">The less common
only-for-ordering model uses priorities solely to order
callback invocation within a single event loop iteration:
Higher priority watchers are invoked before lower priority
ones, but they all get invoked before polling for new
events.</p>

<p style="margin-left:11%; margin-top: 1em">Libev uses the
second (only-for-ordering) model for all its watchers except
for idle watchers (which use the lock-out model).</p>

<p style="margin-left:11%; margin-top: 1em">The rationale
behind this is that implementing the lock-out model for
watchers is not well supported by most kernel interfaces,
and most event libraries will just poll for the same events
again and again as long as their callbacks have not been
executed, which is very inefficient in the common case of
one high-priority watcher locking out a mass of lower
priority ones.</p>

<p style="margin-left:11%; margin-top: 1em">Static
(ordering) priorities are most useful when you have two or
more watchers handling the same resource: a typical usage
example is having an &quot;ev_io&quot; watcher to receive
data, and an associated &quot;ev_timer&quot; to handle
timeouts. Under load, data might be received while the
program handles other jobs, but since timers normally get
invoked first, the timeout handler will be executed before
checking for data. In that case, giving the timer a lower
priority than the I/O watcher ensures that I/O will be
handled first even under adverse conditions (which is
usually, but not always, what you want).</p>

<p style="margin-left:11%; margin-top: 1em">Since idle
watchers use the &quot;lock-out&quot; model, meaning that
idle watchers will only be executed when no same or higher
priority watchers have received events, they can be used to
implement the &quot;lock-out&quot; model when required.</p>

<p style="margin-left:11%; margin-top: 1em">For example, to
emulate how many other event libraries handle priorities,
you can associate an &quot;ev_idle&quot; watcher to each
such watcher, and in the normal watcher callback, you just
start the idle watcher. The real processing is done in the
idle watcher callback. This causes libev to continuously
poll and process kernel event data for the watcher, but when
the lock-out case is known to be rare (which in turn is rare
:), this is workable.</p>

<p style="margin-left:11%; margin-top: 1em">Usually,
however, the lock-out model implemented that way will
perform miserably under the type of load it was designed to
handle. In that case, it might be preferable to stop the
real watcher before starting the idle watcher, so the kernel
will not have to process the event in case the actual
processing will be delayed for considerable time.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of an I/O watcher that should run at a strictly
lower priority than the default, and which should only
process data when no other events are pending:</p>

<p style="margin-left:11%; margin-top: 1em">ev_idle idle;
// actual processing watcher <br>
ev_io io; // actual event watcher <br>
static void <br>
io_cb (EV_P_ ev_io *w, int revents) <br>
{ <br>
// stop the I/O watcher, we received the event, but <br>
// are not yet ready to handle it. <br>
ev_io_stop (EV_A_ w); <br>
// start the idle watcher to handle the actual event. <br>
// it will not be executed as long as other watchers <br>
// with the default priority are receiving events. <br>
ev_idle_start (EV_A_ &amp;idle); <br>
} <br>
static void <br>
idle_cb (EV_P_ ev_idle *w, int revents) <br>
{ <br>
// actual processing <br>
read (STDIN_FILENO, ...); <br>
// have to start the I/O watcher again, as <br>
// we have handled the event <br>
ev_io_start (EV_P_ &amp;io); <br>
} <br>
// initialisation <br>
ev_idle_init (&amp;idle, idle_cb); <br>
ev_io_init (&amp;io, io_cb, STDIN_FILENO, EV_READ); <br>
ev_io_start (EV_DEFAULT_ &amp;io);</p>

<p style="margin-left:11%; margin-top: 1em">In the
&quot;real&quot; world, it might also be beneficial to start
a timer, so that low-priority connections can not be locked
out forever under load. This enables your program to keep a
lower latency for important connections during short periods
of high load, while not completely locking out less
important ones.</p>

<h2>WATCHER TYPES
<a name="WATCHER TYPES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
describes each watcher in detail, but will not repeat
information given in the last section. Any
initialisation/set macros, functions and members specific to
the watcher type are explained.</p>

<p style="margin-left:11%; margin-top: 1em">Most members
are additionally marked with either
<i>[read&minus;only]</i>, meaning that, while the watcher is
active, you can look at the member and expect some sensible
content, but you must not modify it (you can modify it while
the watcher is stopped to your hearts content), or
<i>[read&minus;write]</i>, which means you can expect it to
have some sensible content while the watcher is active, but
you can also modify it (within the same thread as the event
loop, i.e. without creating data races). Modifying it may
not do something sensible or take immediate effect (or do
anything at all), but libev will not crash or malfunction in
any way.</p>

<p style="margin-left:11%; margin-top: 1em">In any case,
the documentation for each member will explain what the
effects are, and if there are any additional access
restrictions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_io&quot;
&minus; is this file descriptor readable or writable?</b>
<br>
I/O watchers check whether a file descriptor is readable or
writable in each iteration of the event loop, or, more
precisely, when reading would not block the process and
writing would at least be able to write some data. This
behaviour is called level-triggering because you keep
receiving events as long as the condition persists. Remember
you can stop the watcher if you don&rsquo;t want to act on
the event and neither want to receive future events.</p>

<p style="margin-left:11%; margin-top: 1em">In general you
can register as many read and/or write event watchers per fd
as you want (as long as you don&rsquo;t confuse yourself).
Setting all file descriptors to non-blocking mode is also
usually a good idea (but not required if you know what you
are doing).</p>

<p style="margin-left:11%; margin-top: 1em">Another thing
you have to watch out for is that it is quite easy to
receive &quot;spurious&quot; readiness notifications, that
is, your callback might be called with &quot;EV_READ&quot;
but a subsequent &quot;read&quot;(2) will actually block
because there is no data. It is very easy to get into this
situation even with a relatively standard program structure.
Thus it is best to always use non-blocking I/O: An extra
&quot;read&quot;(2) returning &quot;EAGAIN&quot; is far
preferable to a program hanging until some data arrives.</p>

<p style="margin-left:11%; margin-top: 1em">If you cannot
run the fd in non-blocking mode (for example you should not
play around with an Xlib connection), then you have to
separately re-test whether a file descriptor is really ready
with a known-to-be good interface such as poll (fortunately
in the case of Xlib, it already does this on its own, so its
quite safe to use). Some people additionally use
&quot;SIGALRM&quot; and an interval timer, just to be sure
you won&rsquo;t block indefinitely.</p>

<p style="margin-left:11%; margin-top: 1em">But really,
best use non-blocking mode.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of disappearing file descriptors</i></p>

<p style="margin-left:11%; margin-top: 1em">Some backends
(e.g. kqueue, epoll, linuxaio) need to be told about closing
a file descriptor (either due to calling &quot;close&quot;
explicitly or any other means, such as &quot;dup2&quot;).
The reason is that you register interest in some file
descriptor, but when it goes away, the operating system will
silently drop this interest. If another file descriptor with
the same number then is registered with libev, there is no
efficient way to see that this is, in fact, a different file
descriptor.</p>

<p style="margin-left:11%; margin-top: 1em">To avoid having
to explicitly tell libev about such cases, libev follows the
following policy: Each time &quot;ev_io_set&quot; is being
called, libev will assume that this is potentially a new
file descriptor, otherwise it is assumed that the file
descriptor stays the same. That means that you <i>have</i>
to call &quot;ev_io_set&quot; (or &quot;ev_io_init&quot;)
when you change the descriptor even if the file descriptor
number itself did not change.</p>

<p style="margin-left:11%; margin-top: 1em">This is how one
would do it normally anyway, the important point is that the
libev application should not optimise around libev but
should leave optimisations to libev.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of dup&rsquo;ed file descriptors</i></p>

<p style="margin-left:11%; margin-top: 1em">Some backends
(e.g. epoll), cannot register events for file descriptors,
but only events for the underlying file descriptions. That
means when you have &quot;dup ()&quot;&rsquo;ed file
descriptors or weirder constellations, and register events
for them, only one file descriptor might actually receive
events.</p>

<p style="margin-left:11%; margin-top: 1em">There is no
workaround possible except not registering events for
potentially &quot;dup ()&quot;&rsquo;ed file descriptors, or
to resort to &quot;EVBACKEND_SELECT&quot; or
&quot;EVBACKEND_POLL&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of files</i></p>

<p style="margin-left:11%; margin-top: 1em">Many people try
to use &quot;select&quot; (or libev) on file descriptors
representing files, and expect it to become ready when their
program doesn&rsquo;t block on disk accesses (which can take
a long time on their own).</p>

<p style="margin-left:11%; margin-top: 1em">However, this
cannot ever work in the &quot;expected&quot; way &minus; you
get a readiness notification as soon as the kernel knows
whether and how much data is there, and in the case of open
files, that&rsquo;s always the case, so you always get a
readiness notification instantly, and your read (or possibly
write) will still block on the disk I/O.</p>

<p style="margin-left:11%; margin-top: 1em">Another way to
view it is that in the case of sockets, pipes, character
devices and so on, there is another party (the sender) that
delivers data on its own, but in the case of files, there is
no such thing: the disk will not send data on its own,
simply because it doesn&rsquo;t know what you wish to read
&minus; you would first have to request some data.</p>

<p style="margin-left:11%; margin-top: 1em">Since files are
typically not-so-well supported by advanced notification
mechanism, libev tries hard to emulate <small>POSIX</small>
behaviour with respect to files, even though you should not
use it. The reason for this is convenience: sometimes you
want to watch <small>STDIN</small> or <small>STDOUT,</small>
which is usually a tty, often a pipe, but also sometimes
files or special devices (for example, &quot;epoll&quot; on
Linux works with <i>/dev/random</i> but not with
<i>/dev/urandom</i>), and even though the file might better
be served with asynchronous I/O instead of with non-blocking
I/O, it is still useful when it &quot;just works&quot;
instead of freezing.</p>

<p style="margin-left:11%; margin-top: 1em">So avoid file
descriptors pointing to files when you know it (e.g. use
libeio), but use them when it is convenient, e.g. for
<small>STDIN/STDOUT,</small> or when you rarely read from a
file instead of from a socket, and want to reuse the same
code path.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of fork</i></p>

<p style="margin-left:11%; margin-top: 1em">Some backends
(epoll, kqueue, linuxaio, iouring) do not support &quot;fork
()&quot; at all or exhibit useless behaviour. Libev fully
supports fork, but needs to be told about it in the child if
you want to continue to use it in the child.</p>

<p style="margin-left:11%; margin-top: 1em">To support fork
in your child processes, you have to call &quot;ev_loop_fork
()&quot; after a fork in the child, enable
&quot;EVFLAG_FORKCHECK&quot;, or resort to
&quot;EVBACKEND_SELECT&quot; or
&quot;EVBACKEND_POLL&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of <small>SIGPIPE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">While not
really specific to libev, it is easy to forget about
&quot;SIGPIPE&quot;: when writing to a pipe whose other end
has been closed, your program gets sent a
<small>SIGPIPE,</small> which, by default, aborts your
program. For most programs this is sensible behaviour, for
daemons, this is usually undesirable.</p>

<p style="margin-left:11%; margin-top: 1em">So when you
encounter spurious, unexplained daemon exits, make sure you
ignore <small>SIGPIPE</small> (and maybe make sure you log
the exit status of your daemon somewhere, as that would have
given you a big clue).</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of</i> <b><i>accept()</i></b><i>ing when you
can&rsquo;t</i></p>

<p style="margin-left:11%; margin-top: 1em">Many
implementations of the <small>POSIX</small>
&quot;accept&quot; function (for example, found in
post&minus;2004 Linux) have the peculiar behaviour of not
removing a connection from the pending queue in all error
cases.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
larger servers often run out of file descriptors (because of
resource limits), causing &quot;accept&quot; to fail with
&quot;ENFILE&quot; but not rejecting the connection, leading
to libev signalling readiness on the next iteration again
(the connection still exists after all), and typically
causing the program to loop at 100% <small>CPU</small>
usage.</p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately,
the set of errors that cause this issue differs between
operating systems, there is usually little the app can do to
remedy the situation, and no known thread-safe method of
removing the connection to cope with overload is known (to
me).</p>

<p style="margin-left:11%; margin-top: 1em">One of the
easiest ways to handle this situation is to just ignore it
&minus; when the program encounters an overload, it will
just loop until the situation is over. While this is a form
of busy waiting, no <small>OS</small> offers an event-based
way to handle this situation, so it&rsquo;s the best one can
do.</p>

<p style="margin-left:11%; margin-top: 1em">A better way to
handle the situation is to log any errors other than
&quot;EAGAIN&quot; and &quot;EWOULDBLOCK&quot;, making sure
not to flood the log with such messages, and continue as
usual, which at least gives the user an idea of what could
be wrong (&quot;raise the ulimit!&quot;). For extra points
one could stop the &quot;ev_io&quot; watcher on the
listening fd &quot;for a while&quot;, which reduces
<small>CPU</small> usage.</p>

<p style="margin-left:11%; margin-top: 1em">If your program
is single-threaded, then you could also keep a dummy file
descriptor for overload situations (e.g. by opening
<i>/dev/null</i>), and when you run into &quot;ENFILE&quot;
or &quot;EMFILE&quot;, close it, run &quot;accept&quot;,
close that fd, and create a new dummy fd. This will
gracefully refuse clients under typical overload
conditions.</p>

<p style="margin-left:11%; margin-top: 1em">The last way to
handle it is to simply log the error and &quot;exit&quot;,
as is often done with &quot;malloc&quot; failures, but this
results in an easy opportunity for a DoS attack.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions</i> <br>
ev_io_init (ev_io *, callback, int fd, int events) <br>
ev_io_set (ev_io *, int fd, int events)</p>

<p style="margin-left:17%;">Configures an &quot;ev_io&quot;
watcher. The &quot;fd&quot; is the file descriptor to
receive events for and &quot;events&quot; is either
&quot;EV_READ&quot;, &quot;EV_WRITE&quot;, both
&quot;EV_READ | EV_WRITE&quot; or 0, to express the desire
to receive the given events.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
setting the &quot;events&quot; to 0 and starting the watcher
is supported, but not specially optimized &minus; if your
program sometimes happens to generate this combination this
is fine, but if it is easy to avoid starting an io watcher
watching for no events you should do so.</p>

<p style="margin-left:11%;">ev_io_modify (ev_io *, int
events)</p>

<p style="margin-left:17%;">Similar to
&quot;ev_io_set&quot;, but only changes the requested
events. Using this might be faster with some backends, as
libev can assume that the &quot;fd&quot; still refers to the
same underlying file description, something it cannot do
when using &quot;ev_io_set&quot;.</p>

<p style="margin-left:11%;">int fd [no&minus;modify]</p>

<p style="margin-left:17%;">The file descriptor being
watched. While it can be read at any time, you must not
modify this member even when the watcher is stopped &minus;
always use &quot;ev_io_set&quot; for that.</p>

<p style="margin-left:11%;">int events
[no&minus;modify]</p>

<p style="margin-left:17%;">The set of events the fd is
being watched for, among other flags. Remember that this is
a bit set &minus; to test for &quot;EV_READ&quot;, use
&quot;w&minus;&gt;events &amp; EV_READ&quot;, and similarly
for &quot;EV_WRITE&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">As with
&quot;fd&quot;, you must not modify this member even when
the watcher is stopped, always use &quot;ev_io_set&quot; or
&quot;ev_io_modify&quot; for that.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">Example: Call
&quot;stdin_readable_cb&quot; when
<small>STDIN_FILENO</small> has become, well readable, but
only once. Since it is likely line-buffered, you could
attempt to read a whole line in the callback.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
stdin_readable_cb (struct ev_loop *loop, ev_io *w, int
revents) <br>
{ <br>
ev_io_stop (loop, w); <br>
.. read from stdin here (or from w&minus;&gt;fd) and handle
any I/O errors <br>
} <br>
... <br>
struct ev_loop *loop = ev_default_init (0); <br>
ev_io stdin_readable; <br>
ev_io_init (&amp;stdin_readable, stdin_readable_cb,
STDIN_FILENO, EV_READ); <br>
ev_io_start (loop, &amp;stdin_readable); <br>
ev_run (loop, 0);</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_timer&quot;
&minus; relative and optionally repeating timeouts</b> <br>
Timer watchers are simple relative timers that generate an
event after a given time, and optionally repeating in
regular intervals after that.</p>

<p style="margin-left:11%; margin-top: 1em">The timers are
based on real time, that is, if you register an event that
times out after an hour and you reset your system clock to
January last year, it will still time out after (roughly)
one hour. &quot;Roughly&quot; because detecting time jumps
is hard, and some inaccuracies are unavoidable (the
monotonic clock option helps a lot here).</p>

<p style="margin-left:11%; margin-top: 1em">The callback is
guaranteed to be invoked only <i>after</i> its timeout has
passed (not <i>at</i>, so on systems with very
low-resolution clocks this might introduce a small delay,
see &quot;the special problem of being too early&quot;,
below). If multiple timers become ready during the same loop
iteration then the ones with earlier time-out values are
invoked before ones of the same priority with later time-out
values (but this is no longer true when a callback calls
&quot;ev_run&quot; recursively).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Be smart
about timeouts</i></p>

<p style="margin-left:11%; margin-top: 1em">Many real-world
problems involve some kind of timeout, usually for error
recovery. A typical example is an <small>HTTP</small>
request &minus; if the other side hangs, you want to raise
some error after a while.</p>

<p style="margin-left:11%; margin-top: 1em">What follows
are some ways to handle this problem, from obvious and
inefficient to smart and efficient.</p>

<p style="margin-left:11%; margin-top: 1em">In the
following, a 60 second activity timeout is assumed &minus; a
timeout that gets reset to 60 seconds each time there is
activity (e.g. each time some data or other life sign was
received). <br>
1. Use a timer and stop, reinitialise and start it on
activity.</p>

<p style="margin-left:17%;">This is the most obvious, but
not the most simple way: In the beginning, start the
watcher:</p>

<p style="margin-left:17%; margin-top: 1em">ev_timer_init
(timer, callback, 60., 0.); <br>
ev_timer_start (loop, timer);</p>

<p style="margin-left:17%; margin-top: 1em">Then, each time
there is some activity, &quot;ev_timer_stop&quot; it,
initialise it and start it again:</p>

<p style="margin-left:17%; margin-top: 1em">ev_timer_stop
(loop, timer); <br>
ev_timer_set (timer, 60., 0.); <br>
ev_timer_start (loop, timer);</p>

<p style="margin-left:17%; margin-top: 1em">This is
relatively simple to implement, but means that each time
there is some activity, libev will first have to remove the
timer from its internal data structure and then add it
again. Libev tries to be fast, but it&rsquo;s still not a
constant-time operation.</p>

<p style="margin-left:11%;">2. Use a timer and re-start it
with &quot;ev_timer_again&quot; inactivity.</p>

<p style="margin-left:17%;">This is the easiest way, and
involves using &quot;ev_timer_again&quot; instead of
&quot;ev_timer_start&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">To implement
this, configure an &quot;ev_timer&quot; with a
&quot;repeat&quot; value of 60 and then call
&quot;ev_timer_again&quot; at start and each time you
successfully read or write some data. If you go into an idle
state where you do not expect data to travel on the socket,
you can &quot;ev_timer_stop&quot; the timer, and
&quot;ev_timer_again&quot; will automatically restart it if
need be.</p>

<p style="margin-left:17%; margin-top: 1em">That means you
can ignore both the &quot;ev_timer_start&quot; function and
the &quot;after&quot; argument to &quot;ev_timer_set&quot;,
and only ever use the &quot;repeat&quot; member and
&quot;ev_timer_again&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">At start:</p>

<p style="margin-left:17%; margin-top: 1em">ev_init (timer,
callback); <br>
timer&minus;&gt;repeat = 60.; <br>
ev_timer_again (loop, timer);</p>

<p style="margin-left:17%; margin-top: 1em">Each time there
is some activity:</p>

<p style="margin-left:17%; margin-top: 1em">ev_timer_again
(loop, timer);</p>

<p style="margin-left:17%; margin-top: 1em">It is even
possible to change the time-out on the fly, regardless of
whether the watcher is active or not:</p>


<p style="margin-left:17%; margin-top: 1em">timer&minus;&gt;repeat
= 30.; <br>
ev_timer_again (loop, timer);</p>

<p style="margin-left:17%; margin-top: 1em">This is
slightly more efficient then stopping/starting the timer
each time you want to modify its timeout value, as libev
does not have to completely remove and re-insert the timer
from/into its internal data structure.</p>

<p style="margin-left:17%; margin-top: 1em">It is, however,
even simpler than the &quot;obvious&quot; way to do it.</p>

<p style="margin-left:11%;">3. Let the timer time out, but
then re-arm it as required.</p>

<p style="margin-left:17%;">This method is more tricky, but
usually most efficient: Most timeouts are relatively long
compared to the intervals between other activity &minus; in
our example, within 60 seconds, there are usually many I/O
events with associated activity resets.</p>

<p style="margin-left:17%; margin-top: 1em">In this case,
it would be more efficient to leave the &quot;ev_timer&quot;
alone, but remember the time of last activity, and check for
a real timeout only within the callback:</p>

<p style="margin-left:17%; margin-top: 1em">ev_tstamp
timeout = 60.; <br>
ev_tstamp last_activity; // time of last activity <br>
ev_timer timer; <br>
static void <br>
callback (EV_P_ ev_timer *w, int revents) <br>
{ <br>
// calculate when the timeout would happen <br>
ev_tstamp after = last_activity &minus; ev_now (EV_A) +
timeout; <br>
// if negative, it means we the timeout already occurred
<br>
if (after &lt; 0.) <br>
{ <br>
// timeout occurred, take action <br>
} <br>
else <br>
{ <br>
// callback was invoked, but there was some recent <br>
// activity. simply restart the timer to time out <br>
// after &quot;after&quot; seconds, which is the earliest
time <br>
// the timeout can occur. <br>
ev_timer_set (w, after, 0.); <br>
ev_timer_start (EV_A_ w); <br>
} <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">To summarise
the callback: first calculate in how many seconds the
timeout will occur (by calculating the absolute time when it
would occur, &quot;last_activity + timeout&quot;, and
subtracting the current time, &quot;ev_now (EV_A)&quot; from
that).</p>

<p style="margin-left:17%; margin-top: 1em">If this value
is negative, then we are already past the timeout, i.e. we
timed out, and need to do whatever is needed in this
case.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise, we
now the earliest time at which the timeout would trigger,
and simply start the timer with this timeout value.</p>

<p style="margin-left:17%; margin-top: 1em">In other words,
each time the callback is invoked it will check whether the
timeout occurred. If not, it will simply reschedule itself
to check again at the earliest time it could time out.
Rinse. Repeat.</p>

<p style="margin-left:17%; margin-top: 1em">This scheme
causes more callback invocations (about one every 60 seconds
minus half the average time between activity), but virtually
no calls to libev to change the timeout.</p>

<p style="margin-left:17%; margin-top: 1em">To start the
machinery, simply initialise the watcher and set
&quot;last_activity&quot; to the current time (meaning there
was some activity just now), then call the callback, which
will &quot;do the right thing&quot; and start the timer:</p>

<p style="margin-left:17%; margin-top: 1em">last_activity =
ev_now (EV_A); <br>
ev_init (&amp;timer, callback); <br>
callback (EV_A_ &amp;timer, 0);</p>

<p style="margin-left:17%; margin-top: 1em">When there is
some activity, simply store the current time in
&quot;last_activity&quot;, no libev calls at all:</p>

<p style="margin-left:17%; margin-top: 1em">if (activity
detected) <br>
last_activity = ev_now (EV_A);</p>

<p style="margin-left:17%; margin-top: 1em">When your
timeout value changes, then the timeout can be changed by
simply providing a new value, stopping the timer and calling
the callback, which will again do the right thing (for
example, time out immediately :).</p>

<p style="margin-left:17%; margin-top: 1em">timeout =
new_value; <br>
ev_timer_stop (EV_A_ &amp;timer); <br>
callback (EV_A_ &amp;timer, 0);</p>

<p style="margin-left:17%; margin-top: 1em">This technique
is slightly more complex, but in most cases where the
time-out is unlikely to be triggered, much more
efficient.</p>

<p style="margin-left:11%;">4. Wee, just use a
double-linked list for your timeouts.</p>

<p style="margin-left:17%;">If there is not one request,
but many thousands (millions...), all employing some kind of
timeout with the same timeout value, then one can do even
better:</p>

<p style="margin-left:17%; margin-top: 1em">When starting
the timeout, calculate the timeout value and put the timeout
at the <i>end</i> of the list.</p>

<p style="margin-left:17%; margin-top: 1em">Then use an
&quot;ev_timer&quot; to fire when the timeout at the
<i>beginning</i> of the list is expected to fire (for
example, using the technique #3).</p>

<p style="margin-left:17%; margin-top: 1em">When there is
some activity, remove the timer from the list, recalculate
the timeout, append it to the end of the list again, and
make sure to update the &quot;ev_timer&quot; if it was taken
from the beginning of the list.</p>

<p style="margin-left:17%; margin-top: 1em">This way, one
can manage an unlimited number of timeouts in O(1) time for
starting, stopping and updating the timers, at the expense
of a major complication, and having to use a constant
timeout. The constant timeout ensures that the list stays
sorted.</p>

<p style="margin-left:11%; margin-top: 1em">So which method
the best?</p>

<p style="margin-left:11%; margin-top: 1em">Method #2 is a
simple no-brain-required solution that is adequate in most
situations. Method #3 requires a bit more thinking, but
handles many cases better, and isn&rsquo;t very complicated
either. In most case, choosing either one is fine, with #3
being better in typical situations.</p>

<p style="margin-left:11%; margin-top: 1em">Method #1 is
almost always a bad idea, and buys you nothing. Method #4 is
rather complicated, but extremely efficient, something that
really pays off after the first million or so of active
timers, i.e. it&rsquo;s usually overkill :)</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of being too early</i></p>

<p style="margin-left:11%; margin-top: 1em">If you ask a
timer to call your callback after three seconds, then you
expect it to be invoked after three seconds &minus; but of
course, this cannot be guaranteed to infinite precision.
Less obviously, it cannot be guaranteed to any precision by
libev &minus; imagine somebody suspending the process with a
<small>STOP</small> signal for a few hours for example.</p>

<p style="margin-left:11%; margin-top: 1em">So, libev tries
to invoke your callback as soon as possible <i>after</i> the
delay has occurred, but cannot guarantee this.</p>

<p style="margin-left:11%; margin-top: 1em">A less obvious
failure mode is calling your callback too early: many event
loops compare timestamps with a &quot;elapsed delay &gt;=
requested delay&quot;, but this can cause your callback to
be invoked much earlier than you would expect.</p>

<p style="margin-left:11%; margin-top: 1em">To see why,
imagine a system with a clock that only offers full second
resolution (think windows if you can&rsquo;t come up with a
broken enough <small>OS</small> yourself). If you schedule a
one-second timer at the time 500.9, then the event loop will
schedule your timeout to elapse at a system time of 500
(500.9 truncated to the resolution) + 1, or 501.</p>

<p style="margin-left:11%; margin-top: 1em">If an event
library looks at the timeout 0.1s later, it will see
&quot;501 &gt;= 501&quot; and invoke the callback 0.1s after
it was started, even though a one-second delay was requested
&minus; this is being &quot;too early&quot;, despite best
intentions.</p>

<p style="margin-left:11%; margin-top: 1em">This is the
reason why libev will never invoke the callback if the
elapsed delay equals the requested delay, but only when the
elapsed delay is larger than the requested delay. In the
example above, libev would only invoke the callback at
system time 502, or 1.1s after the timer was started.</p>

<p style="margin-left:11%; margin-top: 1em">So, while libev
cannot guarantee that your callback will be invoked exactly
when requested, it <i>can</i> and <i>does</i> guarantee that
the requested delay has actually elapsed, or in other words,
it always errs on the &quot;too late&quot; side of
things.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of time updates</i></p>

<p style="margin-left:11%; margin-top: 1em">Establishing
the current time is a costly operation (it usually takes at
least one system call): <small>EV</small> therefore updates
its idea of the current time only before and after
&quot;ev_run&quot; collects new events, which causes a
growing difference between &quot;ev_now ()&quot; and
&quot;ev_time ()&quot; when handling lots of events in one
iteration.</p>

<p style="margin-left:11%; margin-top: 1em">The relative
timeouts are calculated relative to the &quot;ev_now
()&quot; time. This is usually the right thing as this
timestamp refers to the time of the event triggering
whatever timeout you are modifying/starting. If you suspect
event processing to be delayed and you <i>need</i> to base
the timeout on the current time, use something like the
following to adjust for it:</p>

<p style="margin-left:11%; margin-top: 1em">ev_timer_set
(&amp;timer, after + (ev_time () &minus; ev_now ()),
0.);</p>

<p style="margin-left:11%; margin-top: 1em">If the event
loop is suspended for a long time, you can also force an
update of the time returned by &quot;ev_now ()&quot; by
calling &quot;ev_now_update ()&quot;, although that will
push the event time of all outstanding events further into
the future.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of unsynchronised clocks</i></p>

<p style="margin-left:11%; margin-top: 1em">Modern systems
have a variety of clocks &minus; libev itself uses the
normal &quot;wall clock&quot; clock and, if available, the
monotonic clock (to avoid time jumps).</p>

<p style="margin-left:11%; margin-top: 1em">Neither of
these clocks is synchronised with each other or any other
clock on the system, so &quot;ev_time ()&quot; might return
a considerably different time than &quot;gettimeofday
()&quot; or &quot;time ()&quot;. On a GNU/Linux system, for
example, a call to &quot;gettimeofday&quot; might return a
second count that is one higher than a directly following
call to &quot;time&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The moral of
this is to only compare libev-related timestamps with
&quot;ev_time ()&quot; and &quot;ev_now ()&quot;, at least
if you want better precision than a second or so.</p>

<p style="margin-left:11%; margin-top: 1em">One more
problem arises due to this lack of synchronisation: if libev
uses the system monotonic clock and you compare timestamps
from &quot;ev_time&quot; or &quot;ev_now&quot; from when you
started your timer and when your callback is invoked, you
will find that sometimes the callback is a bit
&quot;early&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This is because
&quot;ev_timer&quot;s work in real time, not wall clock
time, so libev makes sure your callback is not invoked
before the delay happened, <i>measured according to the real
time</i>, not the system clock.</p>

<p style="margin-left:11%; margin-top: 1em">If your
timeouts are based on a physical timescale (e.g. &quot;time
out this connection after 100 seconds&quot;) then this
shouldn&rsquo;t bother you as it is exactly the right
behaviour.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
compare wall clock/system timestamps to your timers, then
you need to use &quot;ev_periodic&quot;s, as these are based
on the wall clock time, where your comparisons will always
generate correct results.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problems of suspended animation</i></p>

<p style="margin-left:11%; margin-top: 1em">When you leave
the server world it is quite customary to hit machines that
can suspend/hibernate &minus; what happens to the clocks
during such a suspend?</p>

<p style="margin-left:11%; margin-top: 1em">Some quick
tests made with a Linux 2.6.28 indicate that a suspend
freezes all processes, while the clocks (&quot;times&quot;,
&quot;CLOCK_MONOTONIC&quot;) continue to run until the
system is suspended, but they will not advance while the
system is suspended. That means, on resume, it will be as if
the program was frozen for a few seconds, but the suspend
time will not be counted towards &quot;ev_timer&quot; when a
monotonic clock source is used. The real time clock advanced
as expected, but if it is used as sole clocksource, then a
long suspend would be detected as a time jump by libev, and
timers would be adjusted accordingly.</p>

<p style="margin-left:11%; margin-top: 1em">I would not be
surprised to see different behaviour in different between
operating systems, <small>OS</small> versions or even
different hardware.</p>

<p style="margin-left:11%; margin-top: 1em">The other form
of suspend (job control, or sending a <small>SIGSTOP</small>
) will see a time jump in the monotonic clocks and the
realtime clock. If the program is suspended for a very long
time, and monotonic clock sources are in use, then you can
expect &quot;ev_timer&quot;s to expire as the full
suspension time will be counted towards the timers. When no
monotonic clock source is in use, then libev will again
assume a timejump and adjust accordingly.</p>

<p style="margin-left:11%; margin-top: 1em">It might be
beneficial for this latter case to call
&quot;ev_suspend&quot; and &quot;ev_resume&quot; in code
that handles &quot;SIGTSTP&quot;, to at least get
deterministic behaviour in this case (you can do nothing
against &quot;SIGSTOP&quot;).</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_timer_init (ev_timer *, callback, ev_tstamp after,
ev_tstamp repeat) <br>
ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp
repeat)</p>

<p style="margin-left:17%;">Configure the timer to trigger
after &quot;after&quot; seconds (fractional and negative
values are supported). If &quot;repeat&quot; is 0., then it
will automatically be stopped once the timeout is reached.
If it is positive, then the timer will automatically be
configured to trigger again &quot;repeat&quot; seconds
later, again, and again, until stopped manually.</p>

<p style="margin-left:17%; margin-top: 1em">The timer
itself will do a best-effort at avoiding drift, that is, if
you configure a timer to trigger every 10 seconds, then it
will normally trigger at exactly 10 second intervals. If,
however, your program cannot keep up with the timer (because
it takes longer than those 10 seconds to do stuff) the timer
will not fire more than once per event loop iteration.</p>

<p style="margin-left:11%;">ev_timer_again (loop, ev_timer
*)</p>

<p style="margin-left:17%;">This will act as if the timer
timed out, and restarts it again if it is repeating. It
basically works like calling &quot;ev_timer_stop&quot;,
updating the timeout to the &quot;repeat&quot; value and
calling &quot;ev_timer_start&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The exact
semantics are as in the following rules, all of which will
be applied to the watcher: <br>
If the timer is pending, the pending status is always
cleared. <br>
If the timer is started but non-repeating, stop it (as if it
timed <br>
out, without invoking it). <br>
If the timer is repeating, make the &quot;repeat&quot; value
the new timeout <br>
and start the timer, if necessary.</p>

<p style="margin-left:17%; margin-top: 1em">This sounds a
bit complicated, see &quot;Be smart about timeouts&quot;,
above, for a usage example.</p>

<p style="margin-left:11%;">ev_tstamp ev_timer_remaining
(loop, ev_timer *)</p>

<p style="margin-left:17%;">Returns the remaining time
until a timer fires. If the timer is active, then this time
is relative to the current event loop time, otherwise
it&rsquo;s the timeout value currently configured.</p>

<p style="margin-left:17%; margin-top: 1em">That is, after
an &quot;ev_timer_set (w, 5, 7)&quot;,
&quot;ev_timer_remaining&quot; returns 5. When the timer is
started and one second passes,
&quot;ev_timer_remaining&quot; will return 4. When the timer
expires and is restarted, it will return roughly 7 (likely
slightly less as callback invocation takes some time, too),
and so on.</p>

<p style="margin-left:11%;">ev_tstamp repeat
[read&minus;write]</p>

<p style="margin-left:17%;">The current &quot;repeat&quot;
value. Will be used each time the watcher times out or
&quot;ev_timer_again&quot; is called, and determines the
next timeout (if any), which is also when any modifications
are taken into account.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">Example: Create
a timer that fires after 60 seconds.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
one_minute_cb (struct ev_loop *loop, ev_timer *w, int
revents) <br>
{ <br>
.. one minute over, w is actually stopped right here <br>
} <br>
ev_timer mytimer; <br>
ev_timer_init (&amp;mytimer, one_minute_cb, 60., 0.); <br>
ev_timer_start (loop, &amp;mytimer);</p>

<p style="margin-left:11%; margin-top: 1em">Example: Create
a timeout timer that times out after 10 seconds of
inactivity.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
timeout_cb (struct ev_loop *loop, ev_timer *w, int revents)
<br>
{ <br>
.. ten seconds without any activity <br>
} <br>
ev_timer mytimer; <br>
ev_timer_init (&amp;mytimer, timeout_cb, 0., 10.); /* note,
only repeat used */ <br>
ev_timer_again (&amp;mytimer); /* start timer */ <br>
ev_run (loop, 0); <br>
// and in some piece of code that gets executed on any
&quot;activity&quot;: <br>
// reset the timeout to start ticking again at 10 seconds
<br>
ev_timer_again (&amp;mytimer);</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_periodic&quot;
&minus; to cron or not to cron?</b> <br>
Periodic watchers are also timers of a kind, but they are
very versatile (and unfortunately a bit complex).</p>

<p style="margin-left:11%; margin-top: 1em">Unlike
&quot;ev_timer&quot;, periodic watchers are not based on
real time (or relative time, the physical time that passes)
but on wall clock time (absolute time, the thing you can
read on your calendar or clock). The difference is that wall
clock time can run faster or slower than real time, and time
jumps are not uncommon (e.g. when you adjust your
wrist-watch).</p>

<p style="margin-left:11%; margin-top: 1em">You can tell a
periodic watcher to trigger after some specific point in
time: for example, if you tell a periodic watcher to trigger
&quot;in 10 seconds&quot; (by specifying e.g. &quot;ev_now
() + 10.&quot;, that is, an absolute time not a delay) and
then reset your system clock to January of the previous
year, then it will take a year or more to trigger the event
(unlike an &quot;ev_timer&quot;, which would still trigger
roughly 10 seconds after starting it, as it uses a relative
timeout).</p>


<p style="margin-left:11%; margin-top: 1em">&quot;ev_periodic&quot;
watchers can also be used to implement vastly more complex
timers, such as triggering an event on each &quot;midnight,
local time&quot;, or other complicated rules. This cannot
easily be done with &quot;ev_timer&quot; watchers, as those
cannot react to time jumps.</p>

<p style="margin-left:11%; margin-top: 1em">As with timers,
the callback is guaranteed to be invoked only when the point
in time where it is supposed to trigger has passed. If
multiple timers become ready during the same loop iteration
then the ones with earlier time-out values are invoked
before ones with later time-out values (but this is no
longer true when a callback calls &quot;ev_run&quot;
recursively).</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_periodic_init (ev_periodic *, callback, ev_tstamp offset,
ev_tstamp <br>
interval, reschedule_cb) <br>
ev_periodic_set (ev_periodic *, ev_tstamp offset, ev_tstamp
interval, <br>
reschedule_cb)</p>

<p style="margin-left:17%;">Lots of arguments, let&rsquo;s
sort it out... There are basically three modes of operation,
and we will explain them from simplest to most complex:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>absolute timer (offset = absolute time, interval = 0,
reschedule_cb = 0)</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">In this
configuration the watcher triggers an event after the wall
clock time &quot;offset&quot; has passed. It will not repeat
and will not adjust when a time jump occurs, that is, if it
is to be run at January 1st 2011 then it will be stopped and
invoked when the system clock reaches or surpasses this
point in time.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">repeating interval timer (offset
= offset within interval, interval &gt; 0, reschedule_cb =
0)</p> </td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">In this mode
the watcher will always be scheduled to time out at the next
&quot;offset + N * interval&quot; time (for some integer N,
which can also be negative) and then repeat, regardless of
any time jumps. The &quot;offset&quot; argument is merely an
offset into the &quot;interval&quot; periods.</p>

<p style="margin-left:23%; margin-top: 1em">This can be
used to create timers that do not drift with respect to the
system clock, for example, here is an
&quot;ev_periodic&quot; that triggers each hour, on the hour
(with respect to <small>UTC</small> ):</p>


<p style="margin-left:23%; margin-top: 1em">ev_periodic_set
(&amp;periodic, 0., 3600., 0);</p>

<p style="margin-left:23%; margin-top: 1em">This
doesn&rsquo;t mean there will always be 3600 seconds in
between triggers, but only that the callback will be called
when the system time shows a full hour ( <small>UTC</small>
), or more correctly, when the system time is evenly
divisible by 3600.</p>

<p style="margin-left:23%; margin-top: 1em">Another way to
think about it (for the mathematically inclined) is that
&quot;ev_periodic&quot; will try to run the callback in this
mode at the next possible time where &quot;time = offset
(mod interval)&quot;, regardless of any time jumps.</p>

<p style="margin-left:23%; margin-top: 1em">The
&quot;interval&quot; <i><small>MUST</small></i> be positive,
and for numerical stability, the interval value should be
higher than &quot;1/8192&quot; (which is around 100
microseconds) and &quot;offset&quot; should be higher than 0
and should have at most a similar magnitude as the current
time (say, within a factor of ten). Typical values for
offset are, in fact, 0 or something between 0 and
&quot;interval&quot;, which is also the recommended
range.</p>

<p style="margin-left:23%; margin-top: 1em">Note also that
there is an upper limit to how often a timer can fire (
<small>CPU</small> speed for example), so if
&quot;interval&quot; is very small then timing stability
will of course deteriorate. Libev itself tries to be exact
to be about one millisecond (if the <small>OS</small>
supports it and the machine is fast enough).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">manual reschedule mode (offset
ignored, interval ignored, reschedule_cb = callback)</p></td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">In this mode
the values for &quot;interval&quot; and &quot;offset&quot;
are both being ignored. Instead, each time the periodic
watcher gets scheduled, the reschedule callback will be
called with the watcher as first, and the current time as
second argument.</p>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
<i>This callback <small>MUST NOT</small> stop or destroy any
periodic watcher, ever, or make <small>ANY</small> other
event loop modifications whatsoever, unless explicitly
allowed by documentation here</i>.</p>

<p style="margin-left:23%; margin-top: 1em">If you need to
stop it, return &quot;now + 1e30&quot; (or so, fudge fudge)
and stop it afterwards (e.g. by starting an
&quot;ev_prepare&quot; watcher, which is the only event loop
modification you are allowed to do).</p>

<p style="margin-left:23%; margin-top: 1em">The callback
prototype is &quot;ev_tstamp (*reschedule_cb)(ev_periodic
*w, ev_tstamp now)&quot;, e.g.:</p>

<p style="margin-left:23%; margin-top: 1em">static
ev_tstamp <br>
my_rescheduler (ev_periodic *w, ev_tstamp now) <br>
{ <br>
return now + 60.; <br>
}</p>

<p style="margin-left:23%; margin-top: 1em">It must return
the next time to trigger, based on the passed time value
(that is, the lowest time value larger than to the second
argument). It will usually be called just before the
callback will be triggered, but might be called at other
times, too.</p>


<p style="margin-left:23%; margin-top: 1em"><small>NOTE:</small>
<i>This callback must always return a time that is higher
than or equal to the passed &quot;now&quot; value</i>.</p>

<p style="margin-left:23%; margin-top: 1em">This can be
used to create very complex timers, such as a timer that
triggers on &quot;next midnight, local time&quot;. To do
this, you would calculate the next midnight after
&quot;now&quot; and return the timestamp value for this.
Here is a (completely untested, no error checking) example
on how to do this:</p>

<p style="margin-left:23%; margin-top: 1em">#include
&lt;time.h&gt; <br>
static ev_tstamp <br>
my_rescheduler (ev_periodic *w, ev_tstamp now) <br>
{ <br>
time_t tnow = (time_t)now; <br>
struct tm tm; <br>
localtime_r (&amp;tnow, &amp;tm); <br>
tm.tm_sec = tm.tm_min = tm.tm_hour = 0; // midnight current
day <br>
++tm.tm_mday; // midnight next day <br>
return mktime (&amp;tm); <br>
}</p>

<p style="margin-left:23%; margin-top: 1em">Note: this code
might run into trouble on days that have more then two
midnights (beginning and end).</p>

<p style="margin-left:11%;">ev_periodic_again (loop,
ev_periodic *)</p>

<p style="margin-left:17%;">Simply stops and restarts the
periodic watcher again. This is only useful when you changed
some parameters or the reschedule callback would return a
different time than the last time it was called (e.g. in a
crond like program when the crontabs have changed).</p>

<p style="margin-left:11%;">ev_tstamp ev_periodic_at
(ev_periodic *)</p>

<p style="margin-left:17%;">When active, returns the
absolute time that the watcher is supposed to trigger next.
This is not the same as the &quot;offset&quot; argument to
&quot;ev_periodic_set&quot;, but indeed works even in
interval and manual rescheduling modes.</p>

<p style="margin-left:11%;">ev_tstamp offset
[read&minus;write]</p>

<p style="margin-left:17%;">When repeating, this contains
the offset value, otherwise this is the absolute point in
time (the &quot;offset&quot; value passed to
&quot;ev_periodic_set&quot;, although libev might modify
this value for better numerical stability).</p>

<p style="margin-left:17%; margin-top: 1em">Can be modified
any time, but changes only take effect when the periodic
timer fires or &quot;ev_periodic_again&quot; is being
called.</p>

<p style="margin-left:11%;">ev_tstamp interval
[read&minus;write]</p>

<p style="margin-left:17%;">The current interval value. Can
be modified any time, but changes only take effect when the
periodic timer fires or &quot;ev_periodic_again&quot; is
being called.</p>

<p style="margin-left:11%;">ev_tstamp
(*reschedule_cb)(ev_periodic *w, ev_tstamp now)
[read&minus;write]</p>

<p style="margin-left:17%;">The current reschedule
callback, or 0, if this functionality is switched off. Can
be changed any time, but changes only take effect when the
periodic timer fires or &quot;ev_periodic_again&quot; is
being called.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">Example: Call a
callback every hour, or, more precisely, whenever the system
time is divisible by 3600. The callback invocation times
have potentially a lot of jitter, but good long-term
stability.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
clock_cb (struct ev_loop *loop, ev_periodic *w, int revents)
<br>
{ <br>
... its now a full hour (UTC, or TAI or whatever your clock
follows) <br>
} <br>
ev_periodic hourly_tick; <br>
ev_periodic_init (&amp;hourly_tick, clock_cb, 0., 3600., 0);
<br>
ev_periodic_start (loop, &amp;hourly_tick);</p>

<p style="margin-left:11%; margin-top: 1em">Example: The
same as above, but use a reschedule callback to do it:</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;math.h&gt; <br>
static ev_tstamp <br>
my_scheduler_cb (ev_periodic *w, ev_tstamp now) <br>
{ <br>
return now + (3600. &minus; fmod (now, 3600.)); <br>
} <br>
ev_periodic_init (&amp;hourly_tick, clock_cb, 0., 0.,
my_scheduler_cb);</p>

<p style="margin-left:11%; margin-top: 1em">Example: Call a
callback every hour, starting now:</p>

<p style="margin-left:11%; margin-top: 1em">ev_periodic
hourly_tick; <br>
ev_periodic_init (&amp;hourly_tick, clock_cb, <br>
fmod (ev_now (loop), 3600.), 3600., 0); <br>
ev_periodic_start (loop, &amp;hourly_tick);</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_signal&quot;
&minus; signal me when a signal gets signalled!</b> <br>
Signal watchers will trigger an event when the process
receives a specific signal one or more times. Even though
signals are very asynchronous, libev will try its best to
deliver signals synchronously, i.e. as part of the normal
event processing, like any other event.</p>

<p style="margin-left:11%; margin-top: 1em">If you want
signals to be delivered truly asynchronously, just use
&quot;sigaction&quot; as you would do without libev and
forget about sharing the signal. You can even use
&quot;ev_async&quot; from a signal handler to synchronously
wake up an event loop.</p>

<p style="margin-left:11%; margin-top: 1em">You can
configure as many watchers as you like for the same signal,
but only within the same loop, i.e. you can watch for
&quot;SIGINT&quot; in your default loop and for
&quot;SIGIO&quot; in another loop, but you cannot watch for
&quot;SIGINT&quot; in both the default loop and another loop
at the same time. At the moment, &quot;SIGCHLD&quot; is
permanently tied to the default loop.</p>

<p style="margin-left:11%; margin-top: 1em">Only after the
first watcher for a signal is started will libev actually
register something with the kernel. It thus coexists with
your own signal handlers as long as you don&rsquo;t register
any with libev for the same signal.</p>

<p style="margin-left:11%; margin-top: 1em">If possible and
supported, libev will install its handlers with
&quot;SA_RESTART&quot; (or equivalent) behaviour enabled, so
system calls should not be unduly interrupted. If you have a
problem with system calls getting interrupted by signals you
can block all signals in an &quot;ev_check&quot; watcher and
unblock them in an &quot;ev_prepare&quot; watcher.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of inheritance over
fork/execve/pthread_create</i></p>

<p style="margin-left:11%; margin-top: 1em">Both the signal
mask (&quot;sigprocmask&quot;) and the signal disposition
(&quot;sigaction&quot;) are unspecified after starting a
signal watcher (and after stopping it again), that is, libev
might or might not block the signal, and might or might not
set or restore the installed signal handler (but see
&quot;EVFLAG_NOSIGMASK&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">While this does
not matter for the signal disposition (libev never sets
signals to &quot;SIG_IGN&quot;, so handlers will be reset to
&quot;SIG_DFL&quot; on &quot;execve&quot;), this matters for
the signal mask: many programs do not expect certain signals
to be blocked.</p>

<p style="margin-left:11%; margin-top: 1em">This means that
before calling &quot;exec&quot; (from the child) you should
reset the signal mask to whatever &quot;default&quot; you
expect (all clear is a good choice usually).</p>

<p style="margin-left:11%; margin-top: 1em">The simplest
way to ensure that the signal mask is reset in the child is
to install a fork handler with &quot;pthread_atfork&quot;
that resets it. That will catch fork calls done by libraries
(such as the libc) as well.</p>

<p style="margin-left:11%; margin-top: 1em">In current
versions of libev, the signal will not be blocked
indefinitely unless you use the &quot;signalfd&quot;
<small>API</small> (&quot;EV_SIGNALFD&quot;). While this
reduces the window of opportunity for problems, it will not
go away, as libev <i>has</i> to modify the signal mask, at
least temporarily.</p>

<p style="margin-left:11%; margin-top: 1em">So I
can&rsquo;t stress this enough: <i>If you do not reset your
signal mask when you expect it to be empty, you have a race
condition in your code</i>. This is not a libev-specific
thing, this is true for most event libraries.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of threads signal handling</i></p>


<p style="margin-left:11%; margin-top: 1em"><small>POSIX</small>
threads has problematic signal handling semantics,
specifically, a lot of functionality (sigfd, sigwait etc.)
only really works if all threads in a process block signals,
which is hard to achieve.</p>

<p style="margin-left:11%; margin-top: 1em">When you want
to use sigwait (or mix libev signal handling with your own
for the same signals), you can tackle this problem by
globally blocking all signals before creating any threads
(or creating them with a fully set sigprocmask) and also
specifying the &quot;EVFLAG_NOSIGMASK&quot; when creating
loops. Then designate one thread as &quot;signal receiver
thread&quot; which handles these signals. You can pass on
any signals that libev might be interested in by calling
&quot;ev_feed_signal&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_signal_init (ev_signal *, callback, int signum) <br>
ev_signal_set (ev_signal *, int signum)</p>

<p style="margin-left:17%;">Configures the watcher to
trigger on the given signal number (usually one of the
&quot;SIGxxx&quot; constants).</p>

<p style="margin-left:11%;">int signum
[read&minus;only]</p>

<p style="margin-left:17%;">The signal the watcher watches
out for.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">Example: Try to
exit cleanly on <small>SIGINT.</small></p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
sigint_cb (struct ev_loop *loop, ev_signal *w, int revents)
<br>
{ <br>
ev_break (loop, EVBREAK_ALL); <br>
} <br>
ev_signal signal_watcher; <br>
ev_signal_init (&amp;signal_watcher, sigint_cb, SIGINT);
<br>
ev_signal_start (loop, &amp;signal_watcher);</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_child&quot;
&minus; watch out for process status changes</b> <br>
Child watchers trigger when your process receives a
<small>SIGCHLD</small> in response to some child status
changes (most typically when a child of yours dies or
exits). It is permissible to install a child watcher
<i>after</i> the child has been forked (which implies it
might have already exited), as long as the event loop
isn&rsquo;t entered (or is continued from a watcher), i.e.,
forking and then immediately registering a watcher for the
child is fine, but forking and registering a watcher a few
event loop iterations later or in the next callback
invocation is not.</p>

<p style="margin-left:11%; margin-top: 1em">Only the
default event loop is capable of handling signals, and
therefore you can only register child watchers in the
default event loop.</p>

<p style="margin-left:11%; margin-top: 1em">Due to some
design glitches inside libev, child watchers will always be
handled at maximum priority (their priority is set to
&quot;EV_MAXPRI&quot; by libev)</p>

<p style="margin-left:11%; margin-top: 1em"><i>Process
Interaction</i></p>

<p style="margin-left:11%; margin-top: 1em">Libev grabs
&quot;SIGCHLD&quot; as soon as the default event loop is
initialised. This is necessary to guarantee proper behaviour
even if the first child watcher is started after the child
exits. The occurrence of &quot;SIGCHLD&quot; is recorded
asynchronously, but child reaping is done synchronously as
part of the event loop processing. Libev always reaps all
children, even ones not watched.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Overriding
the Built-In Processing</i></p>

<p style="margin-left:11%; margin-top: 1em">Libev offers no
special support for overriding the built-in child
processing, but if your application collides with
libev&rsquo;s default child handler, you can override it
easily by installing your own handler for
&quot;SIGCHLD&quot; after initialising the default loop, and
making sure the default loop never gets destroyed. You are
encouraged, however, to use an event-based approach to child
reaping and thus use libev&rsquo;s support for that, so
other libev users can use &quot;ev_child&quot; watchers
freely.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Stopping the
Child Watcher</i></p>

<p style="margin-left:11%; margin-top: 1em">Currently, the
child watcher never gets stopped, even when the child
terminates, so normally one needs to stop the watcher in the
callback. Future versions of libev might stop the watcher
automatically when a child exit is detected (calling
&quot;ev_child_stop&quot; twice is not a problem).</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_child_init (ev_child *, callback, int pid, int trace)
<br>
ev_child_set (ev_child *, int pid, int trace)</p>

<p style="margin-left:17%;">Configures the watcher to wait
for status changes of process &quot;pid&quot; (or <i>any</i>
process if &quot;pid&quot; is specified as 0). The callback
can look at the &quot;rstatus&quot; member of the
&quot;ev_child&quot; watcher structure to see the status
word (use the macros from &quot;sys/wait.h&quot; and see
your systems &quot;waitpid&quot; documentation). The
&quot;rpid&quot; member contains the pid of the process
causing the status change. &quot;trace&quot; must be either
0 (only activate the watcher when the process terminates) or
1 (additionally activate the watcher when the process is
stopped or continued).</p>

<p style="margin-left:11%;">int pid [read&minus;only]</p>

<p style="margin-left:17%;">The process id this watcher
watches out for, or 0, meaning any process id.</p>

<p style="margin-left:11%;">int rpid [read&minus;write]</p>

<p style="margin-left:17%;">The process id that detected a
status change.</p>

<p style="margin-left:11%;">int rstatus
[read&minus;write]</p>

<p style="margin-left:17%;">The process exit/trace status
caused by &quot;rpid&quot; (see your systems
&quot;waitpid&quot; and &quot;sys/wait.h&quot; documentation
for details).</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">Example:
&quot;fork()&quot; a new process and install a child handler
to wait for its completion.</p>

<p style="margin-left:11%; margin-top: 1em">ev_child cw;
<br>
static void <br>
child_cb (EV_P_ ev_child *w, int revents) <br>
{ <br>
ev_child_stop (EV_A_ w); <br>
printf (&quot;process %d exited with status %x\n&quot;,
w&minus;&gt;rpid, w&minus;&gt;rstatus); <br>
} <br>
pid_t pid = fork (); <br>
if (pid &lt; 0) <br>
// error <br>
else if (pid == 0) <br>
{ <br>
// the forked child executes here <br>
exit (1); <br>
} <br>
else <br>
{ <br>
ev_child_init (&amp;cw, child_cb, pid, 0); <br>
ev_child_start (EV_DEFAULT_ &amp;cw); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_stat&quot;
&minus; did the file attributes just change?</b> <br>
This watches a file system path for attribute changes. That
is, it calls &quot;stat&quot; on that path in regular
intervals (or when the <small>OS</small> says it changed)
and sees if it changed compared to the last time, invoking
the callback if it did. Starting the watcher
&quot;stat&quot;&rsquo;s the file, so only changes that
happen after the watcher has been started will be
reported.</p>

<p style="margin-left:11%; margin-top: 1em">The path does
not need to exist: changing from &quot;path exists&quot; to
&quot;path does not exist&quot; is a status change like any
other. The condition &quot;path does not exist&quot; (or
more correctly &quot;path cannot be stat&rsquo;ed&quot;) is
signified by the &quot;st_nlink&quot; field being zero
(which is otherwise always forced to be at least one) and
all the other fields of the stat buffer having unspecified
contents.</p>

<p style="margin-left:11%; margin-top: 1em">The path
<i>must not</i> end in a slash or contain special components
such as &quot;.&quot; or &quot;..&quot;. The path
<i>should</i> be absolute: If it is relative and your
working directory changes, then the behaviour is
undefined.</p>

<p style="margin-left:11%; margin-top: 1em">Since there is
no portable change notification interface available, the
portable implementation simply calls stat(2) regularly on
the path to see if it changed somehow. You can specify a
recommended polling interval for this case. If you specify a
polling interval of 0 (highly recommended!) then a
<i>suitable, unspecified default</i> value will be used
(which you can expect to be around five seconds, although
this might change dynamically). Libev will also impose a
minimum interval which is currently around 0.1, but
that&rsquo;s usually overkill.</p>

<p style="margin-left:11%; margin-top: 1em">This watcher
type is not meant for massive numbers of stat watchers, as
even with OS-supported change notifications, this can be
resource-intensive.</p>

<p style="margin-left:11%; margin-top: 1em">At the time of
this writing, the only OS-specific interface implemented is
the Linux inotify interface (implementing kqueue support is
left as an exercise for the reader. Note, however, that the
author sees no way of implementing &quot;ev_stat&quot;
semantics with kqueue, except as a hint).</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>ABI</small>
Issues (Largefile Support)</i></p>

<p style="margin-left:11%; margin-top: 1em">Libev by
default (unless the user overrides this) uses the default
compilation environment, which means that on systems with
large file support disabled by default, you get the 32 bit
version of the stat structure. When using the library from
programs that change the <small>ABI</small> to use 64 bit
file offsets the programs will fail. In that case you have
to compile libev with the same flags to get binary
compatibility. This is obviously the case with any flags
that change the <small>ABI,</small> but the problem is most
noticeably displayed with ev_stat and large file
support.</p>

<p style="margin-left:11%; margin-top: 1em">The solution
for this is to lobby your distribution maker to make large
file interfaces available by default (as e.g. FreeBSD does)
and not optional. Libev cannot simply switch on large file
support because it has to exchange stat structures with
application programs compiled using the default compilation
environment.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Inotify and
Kqueue</i></p>

<p style="margin-left:11%; margin-top: 1em">When
&quot;inotify (7)&quot; support has been compiled into libev
and present at runtime, it will be used to speed up change
detection where possible. The inotify descriptor will be
created lazily when the first &quot;ev_stat&quot; watcher is
being started.</p>

<p style="margin-left:11%; margin-top: 1em">Inotify
presence does not change the semantics of
&quot;ev_stat&quot; watchers except that changes might be
detected earlier, and in some cases, to avoid making regular
&quot;stat&quot; calls. Even in the presence of inotify
support there are many cases where libev has to resort to
regular &quot;stat&quot; polling, but as long as kernel
2.6.25 or newer is used (2.6.24 and older have too many
bugs), the path exists (i.e. stat succeeds), and the path
resides on a local filesystem (libev currently assumes only
ext2/3, jfs, reiserfs and xfs are fully working) libev
usually gets away without polling.</p>

<p style="margin-left:11%; margin-top: 1em">There is no
support for kqueue, as apparently it cannot be used to
implement this functionality, due to the requirement of
having a file descriptor open on the object at all times,
and detecting renames, unlinks etc. is difficult.</p>

<p style="margin-left:11%; margin-top: 1em"><i>&quot;stat
()&quot; is a synchronous operation</i></p>

<p style="margin-left:11%; margin-top: 1em">Libev
doesn&rsquo;t normally do any kind of I/O itself, and so is
not blocking the process. The exception are
&quot;ev_stat&quot; watchers &minus; those call &quot;stat
()&quot;, which is a synchronous operation.</p>

<p style="margin-left:11%; margin-top: 1em">For local
paths, this usually doesn&rsquo;t matter: unless the system
is very busy or the intervals between stat&rsquo;s are
large, a stat call will be fast, as the path data is usually
in memory already (except when starting the watcher).</p>

<p style="margin-left:11%; margin-top: 1em">For networked
file systems, calling &quot;stat ()&quot; can block an
indefinite time due to network issues, and even under good
conditions, a stat call often takes multiple
milliseconds.</p>

<p style="margin-left:11%; margin-top: 1em">Therefore, it
is best to avoid using &quot;ev_stat&quot; watchers on
networked paths, although this is fully supported by
libev.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of stat time resolution</i></p>

<p style="margin-left:11%; margin-top: 1em">The &quot;stat
()&quot; system call only supports full-second resolution
portably, and even on systems where the resolution is
higher, most file systems still only support whole
seconds.</p>

<p style="margin-left:11%; margin-top: 1em">That means
that, if the time is the only thing that changes, you can
easily miss updates: on the first update,
&quot;ev_stat&quot; detects a change and calls your
callback, which does something. When there is another update
within the same second, &quot;ev_stat&quot; will be unable
to detect unless the stat data does change in other ways
(e.g. file size).</p>

<p style="margin-left:11%; margin-top: 1em">The solution to
this is to delay acting on a change for slightly more than a
second (or till slightly after the next full second
boundary), using a roughly one-second-delay
&quot;ev_timer&quot; (e.g. &quot;ev_timer_set (w, 0., 1.02);
ev_timer_again (loop, w)&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">The .02 offset
is added to work around small timing inconsistencies of some
operating systems (where the second counter of the current
time might be be delayed. One such system is the Linux
kernel, where a call to &quot;gettimeofday&quot; might
return a timestamp with a full second later than a
subsequent &quot;time&quot; call &minus; if the equivalent
of &quot;time ()&quot; is used to update file times then
there will be a small window where the kernel uses the
previous second to update file times but libev might already
execute the timer callback).</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_stat_init (ev_stat *, callback, const char *path,
ev_tstamp <br>
interval) <br>
ev_stat_set (ev_stat *, const char *path, ev_tstamp
interval)</p>

<p style="margin-left:17%;">Configures the watcher to wait
for status changes of the given &quot;path&quot;. The
&quot;interval&quot; is a hint on how quickly a change is
expected to be detected and should normally be specified as
0 to let libev choose a suitable value. The memory pointed
to by &quot;path&quot; must point to the same path for as
long as the watcher is active.</p>

<p style="margin-left:17%; margin-top: 1em">The callback
will receive an &quot;EV_STAT&quot; event when a change was
detected, relative to the attributes at the time the watcher
was started (or the last change was detected).</p>

<p style="margin-left:11%;">ev_stat_stat (loop, ev_stat
*)</p>

<p style="margin-left:17%;">Updates the stat buffer
immediately with new values. If you change the watched path
in your callback, you could call this function to avoid
detecting this change (while introducing a race condition if
you are not the only one changing the path). Can also be
useful simply to find out the new values.</p>

<p style="margin-left:11%;">ev_statdata attr
[read&minus;only]</p>

<p style="margin-left:17%;">The most-recently detected
attributes of the file. Although the type is
&quot;ev_statdata&quot;, this is usually the (or one of the)
&quot;struct stat&quot; types suitable for your system, but
you can only rely on the POSIX-standardised members to be
present. If the &quot;st_nlink&quot; member is 0, then there
was some error while &quot;stat&quot;ing the file.</p>

<p style="margin-left:11%;">ev_statdata prev
[read&minus;only]</p>

<p style="margin-left:17%;">The previous attributes of the
file. The callback gets invoked whenever &quot;prev&quot; !=
&quot;attr&quot;, or, more precisely, one or more of these
members differ: &quot;st_dev&quot;, &quot;st_ino&quot;,
&quot;st_mode&quot;, &quot;st_nlink&quot;,
&quot;st_uid&quot;, &quot;st_gid&quot;, &quot;st_rdev&quot;,
&quot;st_size&quot;, &quot;st_atime&quot;,
&quot;st_mtime&quot;, &quot;st_ctime&quot;.</p>

<p style="margin-left:11%;">ev_tstamp interval
[read&minus;only]</p>

<p style="margin-left:17%;">The specified interval.</p>

<p style="margin-left:11%;">const char *path
[read&minus;only]</p>

<p style="margin-left:17%;">The file system path that is
being watched.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">Example: Watch
&quot;/etc/passwd&quot; for attribute changes.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
passwd_cb (struct ev_loop *loop, ev_stat *w, int revents)
<br>
{ <br>
/* /etc/passwd changed in some way */ <br>
if (w&minus;&gt;attr.st_nlink) <br>
{ <br>
printf (&quot;passwd current size %ld\n&quot;,
(long)w&minus;&gt;attr.st_size); <br>
printf (&quot;passwd current atime %ld\n&quot;,
(long)w&minus;&gt;attr.st_mtime); <br>
printf (&quot;passwd current mtime %ld\n&quot;,
(long)w&minus;&gt;attr.st_mtime); <br>
} <br>
else <br>
/* you shalt not abuse printf for puts */ <br>
puts (&quot;wow, /etc/passwd is not there, expect problems.
&quot; <br>
&quot;if this is windows, they already arrived\n&quot;);
<br>
} <br>
... <br>
ev_stat passwd; <br>
ev_stat_init (&amp;passwd, passwd_cb,
&quot;/etc/passwd&quot;, 0.); <br>
ev_stat_start (loop, &amp;passwd);</p>

<p style="margin-left:11%; margin-top: 1em">Example: Like
above, but additionally use a one-second delay so we do not
miss updates (however, frequent updates will delay
processing, too, so one might do the work both on
&quot;ev_stat&quot; callback invocation <i>and</i> on
&quot;ev_timer&quot; callback invocation).</p>

<p style="margin-left:11%; margin-top: 1em">static ev_stat
passwd; <br>
static ev_timer timer; <br>
static void <br>
timer_cb (EV_P_ ev_timer *w, int revents) <br>
{ <br>
ev_timer_stop (EV_A_ w); <br>
/* now it's one second after the most recent passwd change
*/ <br>
} <br>
static void <br>
stat_cb (EV_P_ ev_stat *w, int revents) <br>
{ <br>
/* reset the one&minus;second timer */ <br>
ev_timer_again (EV_A_ &amp;timer); <br>
} <br>
... <br>
ev_stat_init (&amp;passwd, stat_cb, &quot;/etc/passwd&quot;,
0.); <br>
ev_stat_start (loop, &amp;passwd); <br>
ev_timer_init (&amp;timer, timer_cb, 0., 1.02);</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_idle&quot;
&minus; when you&rsquo;ve got nothing better to do...</b>
<br>
Idle watchers trigger events when no other events of the
same or higher priority are pending (prepare, check and
other idle watchers do not count as receiving
&quot;events&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">That is, as
long as your process is busy handling sockets or timeouts
(or even signals, imagine) of the same or higher priority it
will not be triggered. But when your process is idle (or
only lower-priority watchers are pending), the idle watchers
are being called once per event loop iteration &minus; until
stopped, that is, or your process receives more events and
becomes busy again with higher priority stuff.</p>

<p style="margin-left:11%; margin-top: 1em">The most
noteworthy effect is that as long as any idle watchers are
active, the process will not block when waiting for new
events.</p>

<p style="margin-left:11%; margin-top: 1em">Apart from
keeping your process non-blocking (which is a useful effect
on its own sometimes), idle watchers are a good place to do
&quot;pseudo-background processing&quot;, or delay
processing stuff to after the event loop has handled all
outstanding events.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Abusing an
&quot;ev_idle&quot; watcher for its side-effect</i></p>

<p style="margin-left:11%; margin-top: 1em">As long as
there is at least one active idle watcher, libev will never
sleep unnecessarily. Or in other words, it will loop as fast
as possible. For this to work, the idle watcher
doesn&rsquo;t need to be invoked at all &minus; the lowest
priority will do.</p>

<p style="margin-left:11%; margin-top: 1em">This mode of
operation can be useful together with an
&quot;ev_check&quot; watcher, to do something on each event
loop iteration &minus; for example to balance load between
different connections.</p>

<p style="margin-left:11%; margin-top: 1em">See
&quot;Abusing an ev_check watcher for its side-effect&quot;
for a longer example.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_idle_init (ev_idle *, callback)</p>

<p style="margin-left:17%;">Initialises and configures the
idle watcher &minus; it has no parameters of any kind. There
is a &quot;ev_idle_set&quot; macro, but using it is utterly
pointless, believe me.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">Example:
Dynamically allocate an &quot;ev_idle&quot; watcher, start
it, and in the callback, free it. Also, use no error
checking, as usual.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
idle_cb (struct ev_loop *loop, ev_idle *w, int revents) <br>
{ <br>
// stop the watcher <br>
ev_idle_stop (loop, w); <br>
// now we can free it <br>
free (w); <br>
// now do something you wanted to do when the program has
<br>
// no longer anything immediate to do. <br>
} <br>
ev_idle *idle_watcher = malloc (sizeof (ev_idle)); <br>
ev_idle_init (idle_watcher, idle_cb); <br>
ev_idle_start (loop, idle_watcher);</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_prepare&quot;
and &quot;ev_check&quot; &minus; customise your event
loop!</b> <br>
Prepare and check watchers are often (but not always) used
in pairs: prepare watchers get invoked before the process
blocks and check watchers afterwards.</p>

<p style="margin-left:11%; margin-top: 1em">You <i>must
not</i> call &quot;ev_run&quot; (or similar functions that
enter the current event loop) or &quot;ev_loop_fork&quot;
from either &quot;ev_prepare&quot; or &quot;ev_check&quot;
watchers. Other loops than the current one are fine,
however. The rationale behind this is that you do not need
to check for recursion in those watchers, i.e. the sequence
will always be &quot;ev_prepare&quot;, blocking,
&quot;ev_check&quot; so if you have one watcher of each kind
they will always be called in pairs bracketing the blocking
call.</p>

<p style="margin-left:11%; margin-top: 1em">Their main
purpose is to integrate other event mechanisms into libev
and their use is somewhat advanced. They could be used, for
example, to track variable changes, implement your own
watchers, integrate net-snmp or a coroutine library and lots
more. They are also occasionally useful if you cache some
data and want to flush it before blocking (for example, in X
programs you might want to do an &quot;XFlush ()&quot; in an
&quot;ev_prepare&quot; watcher).</p>

<p style="margin-left:11%; margin-top: 1em">This is done by
examining in each prepare call which file descriptors need
to be watched by the other library, registering
&quot;ev_io&quot; watchers for them and starting an
&quot;ev_timer&quot; watcher for any timeouts (many
libraries provide exactly this functionality). Then, in the
check watcher, you check for any events that occurred (by
checking the pending status of all watchers and stopping
them) and call back into the library. The I/O and timer
callbacks will never actually be called (but must be valid
nevertheless, because you never know, you know?).</p>

<p style="margin-left:11%; margin-top: 1em">As another
example, the Perl Coro module uses these hooks to integrate
coroutines into libev programs, by yielding to other active
coroutines during each prepare and only letting the process
block if no coroutines are ready to run (it&rsquo;s actually
more complicated: it only runs coroutines with priority
higher than or equal to the event loop and one coroutine of
lower priority, but only once, using idle watchers to keep
the event loop from blocking if lower-priority coroutines
are active, thus mapping low-priority coroutines to
idle/background tasks).</p>

<p style="margin-left:11%; margin-top: 1em">When used for
this purpose, it is recommended to give &quot;ev_check&quot;
watchers highest (&quot;EV_MAXPRI&quot;) priority, to ensure
that they are being run before any other watchers after the
poll (this doesn&rsquo;t matter for &quot;ev_prepare&quot;
watchers).</p>

<p style="margin-left:11%; margin-top: 1em">Also,
&quot;ev_check&quot; watchers (and &quot;ev_prepare&quot;
watchers, too) should not activate (&quot;feed&quot;) events
into libev. While libev fully supports this, they might get
executed before other &quot;ev_check&quot; watchers did
their job. As &quot;ev_check&quot; watchers are often used
to embed other (non-libev) event loops those other event
loops might be in an unusable state until their
&quot;ev_check&quot; watcher ran (always remind yourself to
coexist peacefully with others).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Abusing an
&quot;ev_check&quot; watcher for its side-effect</i></p>


<p style="margin-left:11%; margin-top: 1em">&quot;ev_check&quot;
(and less often also &quot;ev_prepare&quot;) watchers can
also be useful because they are called once per event loop
iteration. For example, if you want to handle a large number
of connections fairly, you normally only do a bit of work
for each active connection, and if there is more work to do,
you wait for the next event loop iteration, so other
connections have a chance of making progress.</p>

<p style="margin-left:11%; margin-top: 1em">Using an
&quot;ev_check&quot; watcher is almost enough: it will be
called on the next event loop iteration. However, that
isn&rsquo;t as soon as possible &minus; without external
events, your &quot;ev_check&quot; watcher will not be
invoked.</p>

<p style="margin-left:11%; margin-top: 1em">This is where
&quot;ev_idle&quot; watchers come in handy &minus; all you
need is a single global idle watcher that is active as long
as you have one active &quot;ev_check&quot; watcher. The
&quot;ev_idle&quot; watcher makes sure the event loop will
not sleep, and the &quot;ev_check&quot; watcher makes sure a
callback gets invoked. Neither watcher alone can do
that.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_prepare_init (ev_prepare *, callback) <br>
ev_check_init (ev_check *, callback)</p>

<p style="margin-left:17%;">Initialises and configures the
prepare or check watcher &minus; they have no parameters of
any kind. There are &quot;ev_prepare_set&quot; and
&quot;ev_check_set&quot; macros, but using them is utterly,
utterly, utterly and completely pointless.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">There are a
number of principal ways to embed other event loops or
modules into libev. Here are some ideas on how to include
libadns into libev (there is a Perl module named
&quot;EV::ADNS&quot; that does this, which you could use as
a working example. Another Perl module named
&quot;EV::Glib&quot; embeds a Glib main context into libev,
and finally, &quot;Glib::EV&quot; embeds <small>EV</small>
into the Glib event loop).</p>

<p style="margin-left:11%; margin-top: 1em">Method 1: Add
<small>IO</small> watchers and a timeout watcher in a
prepare handler, and in a check watcher, destroy them and
call into libadns. What follows is pseudo-code only of
course. This requires you to either use a low priority for
the check watcher or use &quot;ev_clear_pending&quot;
explicitly, as the callbacks for the IO/timeout watchers
might not have been called yet.</p>

<p style="margin-left:11%; margin-top: 1em">static ev_io
iow [nfd]; <br>
static ev_timer tw; <br>
static void <br>
io_cb (struct ev_loop *loop, ev_io *w, int revents) <br>
{ <br>
} <br>
// create io watchers for each fd and a timer before
blocking <br>
static void <br>
adns_prepare_cb (struct ev_loop *loop, ev_prepare *w, int
revents) <br>
{ <br>
int timeout = 3600000; <br>
struct pollfd fds [nfd]; <br>
// actual code will need to loop here and realloc etc. <br>
adns_beforepoll (ads, fds, &amp;nfd, &amp;timeout,
timeval_from (ev_time ())); <br>
/* the callback is illegal, but won't be called as we stop
during check */ <br>
ev_timer_init (&amp;tw, 0, timeout * 1e&minus;3, 0.); <br>
ev_timer_start (loop, &amp;tw); <br>
// create one ev_io per pollfd <br>
for (int i = 0; i &lt; nfd; ++i) <br>
{ <br>
ev_io_init (iow + i, io_cb, fds [i].fd, <br>
((fds [i].events &amp; POLLIN ? EV_READ : 0) <br>
| (fds [i].events &amp; POLLOUT ? EV_WRITE : 0))); <br>
fds [i].revents = 0; <br>
ev_io_start (loop, iow + i); <br>
} <br>
} <br>
// stop all watchers after blocking <br>
static void <br>
adns_check_cb (struct ev_loop *loop, ev_check *w, int
revents) <br>
{ <br>
ev_timer_stop (loop, &amp;tw); <br>
for (int i = 0; i &lt; nfd; ++i) <br>
{ <br>
// set the relevant poll flags <br>
// could also call adns_processreadable etc. here <br>
struct pollfd *fd = fds + i; <br>
int revents = ev_clear_pending (iow + i); <br>
if (revents &amp; EV_READ ) fd&minus;&gt;revents |=
fd&minus;&gt;events &amp; POLLIN; <br>
if (revents &amp; EV_WRITE) fd&minus;&gt;revents |=
fd&minus;&gt;events &amp; POLLOUT; <br>
// now stop the watcher <br>
ev_io_stop (loop, iow + i); <br>
} <br>
adns_afterpoll (adns, fds, nfd, timeval_from (ev_now
(loop)); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Method 2: This
would be just like method 1, but you run
&quot;adns_afterpoll&quot; in the prepare watcher and would
dispose of the check watcher.</p>

<p style="margin-left:11%; margin-top: 1em">Method 3: If
the module to be embedded supports explicit event
notification (libadns does), you can also make use of the
actual watcher callbacks, and only destroy/create the
watchers in the prepare watcher.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
timer_cb (EV_P_ ev_timer *w, int revents) <br>
{ <br>
adns_state ads = (adns_state)w&minus;&gt;data; <br>
update_now (EV_A); <br>
adns_processtimeouts (ads, &amp;tv_now); <br>
} <br>
static void <br>
io_cb (EV_P_ ev_io *w, int revents) <br>
{ <br>
adns_state ads = (adns_state)w&minus;&gt;data; <br>
update_now (EV_A); <br>
if (revents &amp; EV_READ ) adns_processreadable (ads,
w&minus;&gt;fd, &amp;tv_now); <br>
if (revents &amp; EV_WRITE) adns_processwriteable (ads,
w&minus;&gt;fd, &amp;tv_now); <br>
} <br>
// do not ever call adns_afterpoll</p>

<p style="margin-left:11%; margin-top: 1em">Method 4: Do
not use a prepare or check watcher because the module you
want to embed is not flexible enough to support it. Instead,
you can override their poll function. The drawback with this
solution is that the main loop is now no longer controllable
by <small>EV.</small> The &quot;Glib::EV&quot; module uses
this approach, effectively embedding <small>EV</small> as a
client into the horrible libglib event loop.</p>

<p style="margin-left:11%; margin-top: 1em">static gint
<br>
event_poll_func (GPollFD *fds, guint nfds, gint timeout)
<br>
{ <br>
int got_events = 0; <br>
for (n = 0; n &lt; nfds; ++n) <br>
// create/start io watcher that sets the relevant bits in
fds[n] and increment got_events <br>
if (timeout &gt;= 0) <br>
// create/start timer <br>
// poll <br>
ev_run (EV_A_ 0); <br>
// stop timer again <br>
if (timeout &gt;= 0) <br>
ev_timer_stop (EV_A_ &amp;to); <br>
// stop io watchers again &minus; their callbacks should
have set <br>
for (n = 0; n &lt; nfds; ++n) <br>
ev_io_stop (EV_A_ iow [n]); <br>
return got_events; <br>
}</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_embed&quot;
&minus; when one backend isn&rsquo;t enough...</b> <br>
This is a rather advanced watcher type that lets you embed
one event loop into another (currently only
&quot;ev_io&quot; events are supported in the embedded loop,
other types of watchers might be handled in a delayed or
incorrect fashion and must not be used).</p>

<p style="margin-left:11%; margin-top: 1em">There are
primarily two reasons you would want that: work around bugs
and prioritise I/O.</p>

<p style="margin-left:11%; margin-top: 1em">As an example
for a bug workaround, the kqueue backend might only support
sockets on some platform, so it is unusable as generic
backend, but you still want to make use of it because you
have many sockets and it scales so nicely. In this case, you
would create a kqueue-based loop and embed it into your
default loop (which might use e.g. poll). Overall operation
will be a bit slower because first libev has to call
&quot;poll&quot; and then &quot;kevent&quot;, but at least
you can use both mechanisms for what they are best:
&quot;kqueue&quot; for scalable sockets and &quot;poll&quot;
if you want it to work :)</p>

<p style="margin-left:11%; margin-top: 1em">As for
prioritising I/O: under rare circumstances you have the case
where some fds have to be watched and handled very quickly
(with low latency), and even priorities and idle watchers
might have too much overhead. In this case you would put all
the high priority stuff in one loop and all the rest in a
second one, and embed the second one in the first.</p>

<p style="margin-left:11%; margin-top: 1em">As long as the
watcher is active, the callback will be invoked every time
there might be events pending in the embedded loop. The
callback must then call &quot;ev_embed_sweep (mainloop,
watcher)&quot; to make a single sweep and invoke their
callbacks (the callback doesn&rsquo;t need to invoke the
&quot;ev_embed_sweep&quot; function directly, it could also
start an idle watcher to give the embedded loop strictly
lower priority for example).</p>

<p style="margin-left:11%; margin-top: 1em">You can also
set the callback to 0, in which case the embed watcher will
automatically execute the embedded loop sweep whenever
necessary.</p>

<p style="margin-left:11%; margin-top: 1em">Fork detection
will be handled transparently while the &quot;ev_embed&quot;
watcher is active, i.e., the embedded loop will
automatically be forked when the embedding loop forks. In
other cases, the user is responsible for calling
&quot;ev_loop_fork&quot; on the embedded loop.</p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately,
not all backends are embeddable: only the ones returned by
&quot;ev_embeddable_backends&quot; are, which,
unfortunately, does not include any portable one.</p>

<p style="margin-left:11%; margin-top: 1em">So when you
want to use this feature you will always have to be prepared
that you cannot get an embeddable loop. The recommended way
to get around this is to have a separate variables for your
embeddable loop, try to create it, and if that fails, use
the normal loop for everything.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;ev_embed&quot;
and fork</i></p>

<p style="margin-left:11%; margin-top: 1em">While the
&quot;ev_embed&quot; watcher is running, forks in the
embedding loop will automatically be applied to the embedded
loop as well, so no special fork handling is required in
that case. When the watcher is not running, however, it is
still the task of the libev user to call &quot;ev_loop_fork
()&quot; as applicable.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_embed_init (ev_embed *, callback, struct ev_loop
*embedded_loop) <br>
ev_embed_set (ev_embed *, struct ev_loop *embedded_loop)</p>

<p style="margin-left:17%;">Configures the watcher to embed
the given loop, which must be embeddable. If the callback is
0, then &quot;ev_embed_sweep&quot; will be invoked
automatically, otherwise it is the responsibility of the
callback to invoke it (it will continue to be called until
the sweep has been done, if you do not want that, you need
to temporarily stop the embed watcher).</p>

<p style="margin-left:11%;">ev_embed_sweep (loop, ev_embed
*)</p>

<p style="margin-left:17%;">Make a single, non-blocking
sweep over the embedded loop. This works similarly to
&quot;ev_run (embedded_loop, EVRUN_NOWAIT)&quot;, but in the
most appropriate way for embedded loops.</p>

<p style="margin-left:11%;">struct ev_loop *other
[read&minus;only]</p>

<p style="margin-left:17%;">The embedded event loop.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">Example: Try to
get an embeddable event loop and embed it into the default
event loop. If that is not possible, use the default loop.
The default loop is stored in &quot;loop_hi&quot;, while the
embeddable loop is stored in &quot;loop_lo&quot; (which is
&quot;loop_hi&quot; in the case no embeddable loop can be
used).</p>

<p style="margin-left:11%; margin-top: 1em">struct ev_loop
*loop_hi = ev_default_init (0); <br>
struct ev_loop *loop_lo = 0; <br>
ev_embed embed; <br>
// see if there is a chance of getting one that works <br>
// (remember that a flags value of 0 means autodetection)
<br>
loop_lo = ev_embeddable_backends () &amp;
ev_recommended_backends () <br>
? ev_loop_new (ev_embeddable_backends () &amp;
ev_recommended_backends ()) <br>
: 0; <br>
// if we got one, then embed it, otherwise default to
loop_hi <br>
if (loop_lo) <br>
{ <br>
ev_embed_init (&amp;embed, 0, loop_lo); <br>
ev_embed_start (loop_hi, &amp;embed); <br>
} <br>
else <br>
loop_lo = loop_hi;</p>

<p style="margin-left:11%; margin-top: 1em">Example: Check
if kqueue is available but not recommended and create a
kqueue backend for use with sockets (which usually work with
any kqueue implementation). Store the
kqueue/socket&minus;only event loop in
&quot;loop_socket&quot;. (One might optionally use
&quot;EVFLAG_NOENV&quot;, too).</p>

<p style="margin-left:11%; margin-top: 1em">struct ev_loop
*loop = ev_default_init (0); <br>
struct ev_loop *loop_socket = 0; <br>
ev_embed embed; <br>
if (ev_supported_backends () &amp; ~ev_recommended_backends
() &amp; EVBACKEND_KQUEUE) <br>
if ((loop_socket = ev_loop_new (EVBACKEND_KQUEUE)) <br>
{ <br>
ev_embed_init (&amp;embed, 0, loop_socket); <br>
ev_embed_start (loop, &amp;embed); <br>
} <br>
if (!loop_socket) <br>
loop_socket = loop; <br>
// now use loop_socket for all sockets, and loop for
everything else</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_fork&quot;
&minus; the audacity to resume the event loop after a
fork</b> <br>
Fork watchers are called when a &quot;fork ()&quot; was
detected (usually because whoever is a good citizen cared to
tell libev about it by calling &quot;ev_loop_fork&quot;).
The invocation is done before the event loop blocks next and
before &quot;ev_check&quot; watchers are being called, and
only in the child after the fork. If whoever good citizen
calling &quot;ev_default_fork&quot; cheats and calls it in
the wrong process, the fork handlers will be invoked, too,
of course.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The special
problem of life after fork &minus; how is it
possible?</i></p>

<p style="margin-left:11%; margin-top: 1em">Most uses of
&quot;fork ()&quot; consist of forking, then some simple
calls to set up/change the process environment, followed by
a call to &quot;exec()&quot;. This sequence should be
handled by libev without any problems.</p>

<p style="margin-left:11%; margin-top: 1em">This changes
when the application actually wants to do event handling in
the child, or both parent in child, in effect
&quot;continuing&quot; after the fork.</p>

<p style="margin-left:11%; margin-top: 1em">The default
mode of operation (for libev, with application help to
detect forks) is to duplicate all the state in the child, as
would be expected when <i>either</i> the parent <i>or</i>
the child process continues.</p>

<p style="margin-left:11%; margin-top: 1em">When both
processes want to continue using libev, then this is usually
the wrong result. In that case, usually one process
(typically the parent) is supposed to continue with all
watchers in place as before, while the other process
typically wants to start fresh, i.e. without any active
watchers.</p>

<p style="margin-left:11%; margin-top: 1em">The cleanest
and most efficient way to achieve that with libev is to
simply create a new event loop, which of course will be
&quot;empty&quot;, and use that for new watchers. This has
the advantage of not touching more memory than necessary,
and thus avoiding the copy-on-write, and the disadvantage of
having to use multiple event loops (which do not support
signal watchers).</p>

<p style="margin-left:11%; margin-top: 1em">When this is
not possible, or you want to use the default loop for other
reasons, then in the process that wants to start
&quot;fresh&quot;, call &quot;ev_loop_destroy
(EV_DEFAULT)&quot; followed by &quot;ev_default_loop
(...)&quot;. Destroying the default loop will
&quot;orphan&quot; (not stop) all registered watchers, so
you have to be careful not to execute code that modifies
those watchers. Note also that in that case, you have to
re-register any signal watchers.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_fork_init (ev_fork *, callback)</p>

<p style="margin-left:17%;">Initialises and configures the
fork watcher &minus; it has no parameters of any kind. There
is a &quot;ev_fork_set&quot; macro, but using it is utterly
pointless, really.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_cleanup&quot;
&minus; even the best things end</b> <br>
Cleanup watchers are called just before the event loop is
being destroyed by a call to
&quot;ev_loop_destroy&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">While there is
no guarantee that the event loop gets destroyed, cleanup
watchers provide a convenient method to install cleanup
hooks for your program, worker threads and so on &minus; you
just to make sure to destroy the loop when you want them to
be invoked.</p>

<p style="margin-left:11%; margin-top: 1em">Cleanup
watchers are invoked in the same way as any other watcher.
Unlike all other watchers, they do not keep a reference to
the event loop (which makes a lot of sense if you think
about it). Like all other watchers, you can call libev
functions in the callback, except
&quot;ev_cleanup_start&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_cleanup_init (ev_cleanup *, callback)</p>

<p style="margin-left:17%;">Initialises and configures the
cleanup watcher &minus; it has no parameters of any kind.
There is a &quot;ev_cleanup_set&quot; macro, but using it is
utterly pointless, I assure you.</p>

<p style="margin-left:11%; margin-top: 1em">Example:
Register an atexit handler to destroy the default loop, so
any cleanup functions are called.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
program_exits (void) <br>
{ <br>
ev_loop_destroy (EV_DEFAULT_UC); <br>
} <br>
... <br>
atexit (program_exits);</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ev_async&quot;
&minus; how to wake up an event loop</b> <br>
In general, you cannot use an &quot;ev_loop&quot; from
multiple threads or other asynchronous sources such as
signal handlers (as opposed to multiple event loops &minus;
those are of course safe to use in different threads).</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes,
however, you need to wake up an event loop you do not
control, for example because it belongs to another thread.
This is what &quot;ev_async&quot; watchers do: as long as
the &quot;ev_async&quot; watcher is active, you can signal
it by calling &quot;ev_async_send&quot;, which is
thread&minus; and signal safe.</p>

<p style="margin-left:11%; margin-top: 1em">This
functionality is very similar to &quot;ev_signal&quot;
watchers, as signals, too, are asynchronous in nature, and
signals, too, will be compressed (i.e. the number of
callback invocations may be less than the number of
&quot;ev_async_send&quot; calls). In fact, you could use
signal watchers as a kind of &quot;global async
watchers&quot; by using a watcher on an otherwise unused
signal, and &quot;ev_feed_signal&quot; to signal this
watcher from another thread, even without knowing which loop
owns the signal.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Queueing</i></p>


<p style="margin-left:11%; margin-top: 1em">&quot;ev_async&quot;
does not support queueing of data in any way. The reason is
that the author does not know of a simple (or any) algorithm
for a multiple-writer-single-reader queue that works in all
cases and doesn&rsquo;t need elaborate support such as
pthreads or unportable memory access semantics.</p>

<p style="margin-left:11%; margin-top: 1em">That means that
if you want to queue data, you have to provide your own
queue. But at least I can tell you how to implement locking
around your queue: <br>
queueing from a signal handler context</p>

<p style="margin-left:17%;">To implement race-free
queueing, you simply add to the queue in the signal handler
but you block the signal handler in the watcher callback.
Here is an example that does that for some fictitious
<small>SIGUSR1</small> handler:</p>

<p style="margin-left:17%; margin-top: 1em">static ev_async
mysig; <br>
static void <br>
sigusr1_handler (void) <br>
{ <br>
sometype data; <br>
// no locking etc. <br>
queue_put (data); <br>
ev_async_send (EV_DEFAULT_ &amp;mysig); <br>
} <br>
static void <br>
mysig_cb (EV_P_ ev_async *w, int revents) <br>
{ <br>
sometype data; <br>
sigset_t block, prev; <br>
sigemptyset (&amp;block); <br>
sigaddset (&amp;block, SIGUSR1); <br>
sigprocmask (SIG_BLOCK, &amp;block, &amp;prev); <br>
while (queue_get (&amp;data)) <br>
process (data); <br>
if (sigismember (&amp;prev, SIGUSR1) <br>
sigprocmask (SIG_UNBLOCK, &amp;block, 0); <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">(Note: pthreads
in theory requires you to use &quot;pthread_setmask&quot;
instead of &quot;sigprocmask&quot; when you use threads, but
libev doesn&rsquo;t do it either...).</p>

<p style="margin-left:11%;">queueing from a thread
context</p>

<p style="margin-left:17%;">The strategy for threads is
different, as you cannot (easily) block threads but you can
easily preempt them, so to queue safely you need to employ a
traditional mutex lock, such as in this pthread example:</p>

<p style="margin-left:17%; margin-top: 1em">static ev_async
mysig; <br>
static pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;
<br>
static void <br>
otherthread (void) <br>
{ <br>
// only need to lock the actual queueing operation <br>
pthread_mutex_lock (&amp;mymutex); <br>
queue_put (data); <br>
pthread_mutex_unlock (&amp;mymutex); <br>
ev_async_send (EV_DEFAULT_ &amp;mysig); <br>
} <br>
static void <br>
mysig_cb (EV_P_ ev_async *w, int revents) <br>
{ <br>
pthread_mutex_lock (&amp;mymutex); <br>
while (queue_get (&amp;data)) <br>
process (data); <br>
pthread_mutex_unlock (&amp;mymutex); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em"><i>Watcher-Specific
Functions and Data Members</i> <br>
ev_async_init (ev_async *, callback)</p>

<p style="margin-left:17%;">Initialises and configures the
async watcher &minus; it has no parameters of any kind.
There is a &quot;ev_async_set&quot; macro, but using it is
utterly pointless, trust me.</p>

<p style="margin-left:11%;">ev_async_send (loop, ev_async
*)</p>

<p style="margin-left:17%;">Sends/signals/activates the
given &quot;ev_async&quot; watcher, that is, feeds an
&quot;EV_ASYNC&quot; event on the watcher into the event
loop, and instantly returns.</p>

<p style="margin-left:17%; margin-top: 1em">Unlike
&quot;ev_feed_event&quot;, this call is safe to do from
other threads, signal or similar contexts (see the
discussion of &quot;EV_ATOMIC_T&quot; in the embedding
section below on what exactly this means).</p>

<p style="margin-left:17%; margin-top: 1em">Note that, as
with other watchers in libev, multiple events might get
compressed into a single callback invocation (another way to
look at this is that &quot;ev_async&quot; watchers are
level-triggered: they are set on &quot;ev_async_send&quot;,
reset when the event loop detects that).</p>

<p style="margin-left:17%; margin-top: 1em">This call
incurs the overhead of at most one extra system call per
event loop iteration, if the event loop is blocked, and no
syscall at all if the event loop (or your program) is
processing events. That means that repeated calls are
basically free (there is no need to avoid calls for
performance reasons) and that the overhead becomes smaller
(typically zero) under load.</p>

<p style="margin-left:11%;">bool = ev_async_pending
(ev_async *)</p>

<p style="margin-left:17%;">Returns a non-zero value when
&quot;ev_async_send&quot; has been called on the watcher but
the event has not yet been processed (or even noted) by the
event loop.</p>


<p style="margin-left:17%; margin-top: 1em">&quot;ev_async_send&quot;
sets a flag in the watcher and wakes up the loop. When the
loop iterates next and checks for the watcher to have become
active, it will reset the flag again.
&quot;ev_async_pending&quot; can be used to very quickly
check whether invoking the loop might be a good idea.</p>

<p style="margin-left:17%; margin-top: 1em">Not that this
does <i>not</i> check whether the watcher itself is pending,
only whether it has been requested to make this watcher
pending: there is a time window between the event loop
checking and resetting the async notification, and the
callback being invoked.</p>

<h2>OTHER FUNCTIONS
<a name="OTHER FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">There are some
other functions of possible interest. Described. Here. Now.
<br>
ev_once (loop, int fd, int events, ev_tstamp timeout,
callback, arg)</p>

<p style="margin-left:17%;">This function combines a simple
timer and an I/O watcher, calls your callback on whichever
event happens first and automatically stops both watchers.
This is useful if you want to wait for a single event on an
fd or timeout without having to
allocate/configure/start/stop/free one or more watchers
yourself.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;fd&quot; is less than 0, then no I/O watcher will be
started and the &quot;events&quot; argument is being
ignored. Otherwise, an &quot;ev_io&quot; watcher for the
given &quot;fd&quot; and &quot;events&quot; set will be
created and started.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;timeout&quot; is less than 0, then no timeout watcher
will be started. Otherwise an &quot;ev_timer&quot; watcher
with after = &quot;timeout&quot; (and repeat = 0) will be
started. 0 is a valid timeout.</p>

<p style="margin-left:17%; margin-top: 1em">The callback
has the type &quot;void (*cb)(int revents, void *arg)&quot;
and is passed an &quot;revents&quot; set like normal event
callbacks (a combination of &quot;EV_ERROR&quot;,
&quot;EV_READ&quot;, &quot;EV_WRITE&quot; or
&quot;EV_TIMER&quot;) and the &quot;arg&quot; value passed
to &quot;ev_once&quot;. Note that it is possible to receive
<i>both</i> a timeout and an io event at the same time
&minus; you probably should give io events precedence.</p>

<p style="margin-left:17%; margin-top: 1em">Example: wait
up to ten seconds for data to appear on
<small>STDIN_FILENO.</small></p>

<p style="margin-left:17%; margin-top: 1em">static void
stdin_ready (int revents, void *arg) <br>
{ <br>
if (revents &amp; EV_READ) <br>
/* stdin might have data for us, joy! */; <br>
else if (revents &amp; EV_TIMER) <br>
/* doh, nothing entered */; <br>
} <br>
ev_once (STDIN_FILENO, EV_READ, 10., stdin_ready, 0);</p>

<p style="margin-left:11%;">ev_feed_fd_event (loop, int fd,
int revents)</p>

<p style="margin-left:17%;">Feed an event on the given fd,
as if a file descriptor backend detected the given
events.</p>

<p style="margin-left:11%;">ev_feed_signal_event (loop, int
signum)</p>

<p style="margin-left:17%;">Feed an event as if the given
signal occurred. See also &quot;ev_feed_signal&quot;, which
is async-safe.</p>

<h2>COMMON OR USEFUL IDIOMS (OR BOTH)
<a name="COMMON OR USEFUL IDIOMS (OR BOTH)"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
explains some common idioms that are not immediately
obvious. Note that examples are sprinkled over the whole
manual, and this section only contains stuff that
wouldn&rsquo;t fit anywhere else.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ASSOCIATING
CUSTOM DATA WITH A WATCHER</small></b> <br>
Each watcher has, by default, a &quot;void *data&quot;
member that you can read or modify at any time: libev will
completely ignore it. This can be used to associate
arbitrary data with your watcher. If you need more data and
don&rsquo;t want to allocate memory separately and store a
pointer to it in that data member, you can also
&quot;subclass&quot; the watcher type and provide your own
data:</p>

<p style="margin-left:11%; margin-top: 1em">struct my_io
<br>
{ <br>
ev_io io; <br>
int otherfd; <br>
void *somedata; <br>
struct whatever *mostinteresting; <br>
}; <br>
... <br>
struct my_io w; <br>
ev_io_init (&amp;w.io, my_cb, fd, EV_READ);</p>

<p style="margin-left:11%; margin-top: 1em">And since your
callback will be called with a pointer to the watcher, you
can cast it back to your own type:</p>

<p style="margin-left:11%; margin-top: 1em">static void
my_cb (struct ev_loop *loop, ev_io *w_, int revents) <br>
{ <br>
struct my_io *w = (struct my_io *)w_; <br>
... <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">More
interesting and less C&minus;conformant ways of casting your
callback function type instead have been omitted.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>BUILDING
YOUR OWN COMPOSITE WATCHERS</small></b> <br>
Another common scenario is to use some data structure with
multiple embedded watchers, in effect creating your own
watcher that combines multiple libev event sources into one
&quot;super-watcher&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">struct my_biggy
<br>
{ <br>
int some_data; <br>
ev_timer t1; <br>
ev_timer t2; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">In this case
getting the pointer to &quot;my_biggy&quot; is a bit more
complicated: Either you store the address of your
&quot;my_biggy&quot; struct in the &quot;data&quot; member
of the watcher (for woozies or C <small>++</small> coders),
or you need to use some pointer arithmetic using
&quot;offsetof&quot; inside your watchers (for real
programmers):</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;stddef.h&gt; <br>
static void <br>
t1_cb (EV_P_ ev_timer *w, int revents) <br>
{ <br>
struct my_biggy big = (struct my_biggy *) <br>
(((char *)w) &minus; offsetof (struct my_biggy, t1)); <br>
} <br>
static void <br>
t2_cb (EV_P_ ev_timer *w, int revents) <br>
{ <br>
struct my_biggy big = (struct my_biggy *) <br>
(((char *)w) &minus; offsetof (struct my_biggy, t2)); <br>
}</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>AVOIDING
FINISHING BEFORE RETURNING</small></b> <br>
Often you have structures like this in event-based
programs:</p>

<p style="margin-left:11%; margin-top: 1em">callback ()
<br>
{ <br>
free (request); <br>
} <br>
request = start_new_request (..., callback);</p>

<p style="margin-left:11%; margin-top: 1em">The intent is
to start some &quot;lengthy&quot; operation. The
&quot;request&quot; could be used to cancel the operation,
or do other things with it.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s not
uncommon to have code paths in &quot;start_new_request&quot;
that immediately invoke the callback, for example, to report
errors. Or you add some caching layer that finds that it can
skip the lengthy aspects of the operation and simply invoke
the callback with the result.</p>

<p style="margin-left:11%; margin-top: 1em">The problem
here is that this will happen <i>before</i>
&quot;start_new_request&quot; has returned, so
&quot;request&quot; is not set.</p>

<p style="margin-left:11%; margin-top: 1em">Even if you
pass the request by some safer means to the callback, you
might want to do something to the request after starting it,
such as canceling it, which probably isn&rsquo;t working so
well when the callback has already been invoked.</p>

<p style="margin-left:11%; margin-top: 1em">A common way
around all these issues is to make sure that
&quot;start_new_request&quot; <i>always</i> returns before
the callback is invoked. If &quot;start_new_request&quot;
immediately knows the result, it can artificially delay
invoking the callback by using a &quot;prepare&quot; or
&quot;idle&quot; watcher for example, or more sneakily, by
reusing an existing (stopped) watcher and pushing it into
the pending queue:</p>

<p style="margin-left:11%; margin-top: 1em">ev_set_cb
(watcher, callback); <br>
ev_feed_event (EV_A_ watcher, 0);</p>

<p style="margin-left:11%; margin-top: 1em">This way,
&quot;start_new_request&quot; can safely return before the
callback is invoked, while not delaying callback invocation
too much.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>MODEL/NESTED
EVENT LOOP INVOCATIONS AND EXIT CONDITIONS</small></b> <br>
Often (especially in <small>GUI</small> toolkits) there are
places where you have <i>modal</i> interaction, which is
most easily implemented by recursively invoking
&quot;ev_run&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This brings the
problem of exiting &minus; a callback might want to finish
the main &quot;ev_run&quot; call, but not the nested one
(e.g. user clicked &quot;Quit&quot;, but a modal &quot;Are
you sure?&quot; dialog is still waiting), or just the nested
one and not the main one (e.g. user clocked &quot;Ok&quot;
in a modal dialog), or some other combination: In these
cases, a simple &quot;ev_break&quot; will not work.</p>

<p style="margin-left:11%; margin-top: 1em">The solution is
to maintain &quot;break this loop&quot; variable for each
&quot;ev_run&quot; invocation, and use a loop around
&quot;ev_run&quot; until the condition is triggered, using
&quot;EVRUN_ONCE&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">// main loop
<br>
int exit_main_loop = 0; <br>
while (!exit_main_loop) <br>
ev_run (EV_DEFAULT_ EVRUN_ONCE); <br>
// in a modal watcher <br>
int exit_nested_loop = 0; <br>
while (!exit_nested_loop) <br>
ev_run (EV_A_ EVRUN_ONCE);</p>

<p style="margin-left:11%; margin-top: 1em">To exit from
any of these loops, just set the corresponding exit
variable:</p>

<p style="margin-left:11%; margin-top: 1em">// exit modal
loop <br>
exit_nested_loop = 1; <br>
// exit main program, after modal loop is finished <br>
exit_main_loop = 1; <br>
// exit both <br>
exit_main_loop = exit_nested_loop = 1;</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>THREAD
LOCKING EXAMPLE</small></b> <br>
Here is a fictitious example of how to run an event loop in
a different thread from where callbacks are being invoked
and watchers are created/added/removed.</p>

<p style="margin-left:11%; margin-top: 1em">For a
real-world example, see the &quot;EV::Loop::Async&quot; perl
module, which uses exactly this technique (which is suited
for many high-level languages).</p>

<p style="margin-left:11%; margin-top: 1em">The example
uses a pthread mutex to protect the loop data, a condition
variable to wait for callback invocations, an async watcher
to notify the event loop thread and an unspecified mechanism
to wake up the main thread.</p>

<p style="margin-left:11%; margin-top: 1em">First, you need
to associate some data with the event loop:</p>

<p style="margin-left:11%; margin-top: 1em">typedef struct
{ <br>
mutex_t lock; /* global loop lock */ <br>
ev_async async_w; <br>
thread_t tid; <br>
cond_t invoke_cv; <br>
} userdata; <br>
void prepare_loop (EV_P) <br>
{ <br>
// for simplicity, we use a static userdata struct. <br>
static userdata u; <br>
ev_async_init (&amp;u&minus;&gt;async_w, async_cb); <br>
ev_async_start (EV_A_ &amp;u&minus;&gt;async_w); <br>
pthread_mutex_init (&amp;u&minus;&gt;lock, 0); <br>
pthread_cond_init (&amp;u&minus;&gt;invoke_cv, 0); <br>
// now associate this with the loop <br>
ev_set_userdata (EV_A_ u); <br>
ev_set_invoke_pending_cb (EV_A_ l_invoke); <br>
ev_set_loop_release_cb (EV_A_ l_release, l_acquire); <br>
// then create the thread running ev_run <br>
pthread_create (&amp;u&minus;&gt;tid, 0, l_run, EV_A); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The callback
for the &quot;ev_async&quot; watcher does nothing: the
watcher is used solely to wake up the event loop so it takes
notice of any new watchers that might have been added:</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
async_cb (EV_P_ ev_async *w, int revents) <br>
{ <br>
// just used for the side effects <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;l_release&quot; and &quot;l_acquire&quot; callbacks
simply unlock/lock the mutex protecting the loop data,
respectively.</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
l_release (EV_P) <br>
{ <br>
userdata *u = ev_userdata (EV_A); <br>
pthread_mutex_unlock (&amp;u&minus;&gt;lock); <br>
} <br>
static void <br>
l_acquire (EV_P) <br>
{ <br>
userdata *u = ev_userdata (EV_A); <br>
pthread_mutex_lock (&amp;u&minus;&gt;lock); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The event loop
thread first acquires the mutex, and then jumps straight
into &quot;ev_run&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">void * <br>
l_run (void *thr_arg) <br>
{ <br>
struct ev_loop *loop = (struct ev_loop *)thr_arg; <br>
l_acquire (EV_A); <br>
pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, 0); <br>
ev_run (EV_A_ 0); <br>
l_release (EV_A); <br>
return 0; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Instead of
invoking all pending watchers, the &quot;l_invoke&quot;
callback will signal the main thread via some unspecified
mechanism (signals? pipe writes?
&quot;Async::Interrupt&quot;?) and then waits until all
pending watchers have been called (in a while loop because
a) spurious wakeups are possible and b) skipping
inter-thread-communication when there are no pending
watchers is very beneficial):</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
l_invoke (EV_P) <br>
{ <br>
userdata *u = ev_userdata (EV_A); <br>
while (ev_pending_count (EV_A)) <br>
{ <br>
wake_up_other_thread_in_some_magic_or_not_so_magic_way ();
<br>
pthread_cond_wait (&amp;u&minus;&gt;invoke_cv,
&amp;u&minus;&gt;lock); <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now, whenever
the main thread gets told to invoke pending watchers, it
will grab the lock, call &quot;ev_invoke_pending&quot; and
then signal the loop thread to continue:</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
real_invoke_pending (EV_P) <br>
{ <br>
userdata *u = ev_userdata (EV_A); <br>
pthread_mutex_lock (&amp;u&minus;&gt;lock); <br>
ev_invoke_pending (EV_A); <br>
pthread_cond_signal (&amp;u&minus;&gt;invoke_cv); <br>
pthread_mutex_unlock (&amp;u&minus;&gt;lock); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Whenever you
want to start/stop a watcher or do other modifications to an
event loop, you will now have to lock:</p>

<p style="margin-left:11%; margin-top: 1em">ev_timer
timeout_watcher; <br>
userdata *u = ev_userdata (EV_A); <br>
ev_timer_init (&amp;timeout_watcher, timeout_cb, 5.5, 0.);
<br>
pthread_mutex_lock (&amp;u&minus;&gt;lock); <br>
ev_timer_start (EV_A_ &amp;timeout_watcher); <br>
ev_async_send (EV_A_ &amp;u&minus;&gt;async_w); <br>
pthread_mutex_unlock (&amp;u&minus;&gt;lock);</p>

<p style="margin-left:11%; margin-top: 1em">Note that
sending the &quot;ev_async&quot; watcher is required because
otherwise an event loop currently blocking in the kernel
will have no knowledge about the newly added timer. By
waking up the loop it will pick up any new watchers in the
next event loop iteration.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>THREADS,
COROUTINES, CONTINUATIONS, QUEUES... INSTEAD OF
CALLBACKS</small></b> <br>
While the overhead of a callback that e.g. schedules a
thread is small, it is still an overhead. If you embed
libev, and your main usage is with some kind of threads or
coroutines, you might want to customise libev so that
doesn&rsquo;t need callbacks anymore.</p>

<p style="margin-left:11%; margin-top: 1em">Imagine you
have coroutines that you can switch to using a function
&quot;switch_to (coro)&quot;, that libev runs in a coroutine
called &quot;libev_coro&quot; and that due to some magic,
the currently active coroutine is stored in a global called
&quot;current_coro&quot;. Then you can build your own
&quot;wait for libev event&quot; primitive by changing
&quot;EV_CB_DECLARE&quot; and &quot;EV_CB_INVOKE&quot; (note
the differing &quot;;&quot; conventions):</p>

<p style="margin-left:11%; margin-top: 1em">#define
EV_CB_DECLARE(type) struct my_coro *cb; <br>
#define EV_CB_INVOKE(watcher) switch_to
((watcher)&minus;&gt;cb)</p>

<p style="margin-left:11%; margin-top: 1em">That means
instead of having a C callback function, you store the
coroutine to switch to in each watcher, and instead of
having libev call your callback, you instead have it switch
to that coroutine.</p>

<p style="margin-left:11%; margin-top: 1em">A coroutine
might now wait for an event with a function called
&quot;wait_for_event&quot;. (the watcher needs to be
started, as always, but it doesn&rsquo;t matter when, or
whether the watcher is active or not when this function is
called):</p>

<p style="margin-left:11%; margin-top: 1em">void <br>
wait_for_event (ev_watcher *w) <br>
{ <br>
ev_set_cb (w, current_coro); <br>
switch_to (libev_coro); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">That basically
suspends the coroutine inside &quot;wait_for_event&quot; and
continues the libev coroutine, which, when appropriate,
switches back to this or any other coroutine.</p>

<p style="margin-left:11%; margin-top: 1em">You can do
similar tricks if you have, say, threads with an event queue
&minus; instead of storing a coroutine, you store the queue
object and instead of switching to a coroutine, you push the
watcher onto the queue and notify any waiters.</p>

<p style="margin-left:11%; margin-top: 1em">To embed libev,
see &quot; <small>EMBEDDING&quot;</small> , but in short,
it&rsquo;s easiest to create two files, <i>my_ev.h</i> and
<i>my_ev.c</i> that include the respective libev files:</p>

<p style="margin-left:11%; margin-top: 1em">// my_ev.h <br>
#define EV_CB_DECLARE(type) struct my_coro *cb; <br>
#define EV_CB_INVOKE(watcher) switch_to
((watcher)&minus;&gt;cb) <br>
#include &quot;../libev/ev.h&quot; <br>
// my_ev.c <br>
#define EV_H &quot;my_ev.h&quot; <br>
#include &quot;../libev/ev.c&quot;</p>

<p style="margin-left:11%; margin-top: 1em">And then use
<i>my_ev.h</i> when you would normally use <i>ev.h</i>, and
compile <i>my_ev.c</i> into your project. When properly
specifying include paths, you can even use <i>ev.h</i> as
header file name directly.</p>

<h2>LIBEVENT EMULATION
<a name="LIBEVENT EMULATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Libev offers a
compatibility emulation layer for libevent. It cannot
emulate the internals of libevent, so here are some usage
hints:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="78%">


<p>Only the libevent&minus;1.4.1&minus;beta
<small>API</small> is being emulated.</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This was the
newest libevent version available when libev was
implemented, and is still mostly unchanged in 2010.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Use it by including
&lt;event.h&gt;, as usual.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The following members are fully supported: ev_base,
ev_callback, ev_arg, ev_fd, ev_res, ev_events.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Avoid using ev_flags and the EVLIST_*&minus;macros,
while it is maintained by libev, it does not work exactly
the same way as in libevent (consider it a private
<small>API</small> ).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Priorities are not currently supported. Initialising
priorities will fail and all watchers will have the same
priority, even though there is an ev_pri field.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>In libevent, the last base created gets the signals, in
libev, the base that registered the signal gets the
signals.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Other members are not supported.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The libev emulation is <i>not</i> <small>ABI</small>
compatible to libevent, you need to use the libev header
file and library.</p></td></tr>
</table>

<h2>C++ SUPPORT
<a name="C++ SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>C
<small>API</small></b> <br>
The normal C <small>API</small> should work fine when used
from C <small>++</small> : both ev.h and the libev sources
can be compiled as C <small>++</small> . Therefore, code
that uses the C <small>API</small> will work fine.</p>

<p style="margin-left:11%; margin-top: 1em">Proper
exception specifications might have to be added to callbacks
passed to libev: exceptions may be thrown only from watcher
callbacks, all other callbacks (allocator, syserr, loop
acquire/release and periodic reschedule callbacks) must not
throw exceptions, and might need a &quot;noexcept&quot;
specification. If you have code that needs to be compiled as
both C and C <small>++</small> you can use the
&quot;EV_NOEXCEPT&quot; macro for this:</p>

<p style="margin-left:11%; margin-top: 1em">static void
<br>
fatal_error (const char *msg) EV_NOEXCEPT <br>
{ <br>
perror (msg); <br>
abort (); <br>
} <br>
... <br>
ev_set_syserr_cb (fatal_error);</p>

<p style="margin-left:11%; margin-top: 1em">The only
<small>API</small> functions that can currently throw
exceptions are &quot;ev_run&quot;, &quot;ev_invoke&quot;,
&quot;ev_invoke_pending&quot; and
&quot;ev_loop_destroy&quot; (the latter because it runs
cleanup watchers).</p>

<p style="margin-left:11%; margin-top: 1em">Throwing
exceptions in watcher callbacks is only supported if libev
itself is compiled with a C <small>++</small> compiler or
your C and C <small>++</small> environments allow throwing
exceptions through C libraries (most do).</p>

<p style="margin-left:11%; margin-top: 1em"><b>C
<small>++</small> API</b> <big><br>
Libev comes with some simplistic wrapper classes for C</big>
++ <big>that mainly allow you to use some convenience
methods to start/stop watchers and also change the callback
model to a model using method callbacks on
objects.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>To use
it,</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#include
&lt;ev++.h&gt;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>This
automatically includes <i>ev.h</i> and puts all of its
definitions (many of them macros) into the global namespace.
All C</big> ++ <big>specific things are put into the
&quot;ev&quot; namespace. It should support all the same
embedding options as <i>ev.h</i>, most notably
&quot;EV_MULTIPLICITY&quot;.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Care has
been taken to keep the overhead low. The only data member
the C</big> ++ <big>classes add (compared to plain
C&minus;style watchers) is the event loop pointer that the
watcher is associated with (or no additional members at all
if you disable &quot;EV_MULTIPLICITY&quot; when embedding
libev).</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>Currently,
functions, static and non-static member functions and
classes with &quot;operator ()&quot; can be used as
callbacks. Other types should be easy to add as long as they
only need one additional pointer for context. If you need
support for other types of functors please contact the
author (preferably after implementing it).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>For all
this to work, your C</big> ++ <big>compiler either has to
use the same calling conventions as your C compiler (for
static member functions), or you have to embed libev and
compile libev itself as C</big> ++ <big>.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Here is a
list of things available in the &quot;ev&quot; namespace:
<br>
&quot;ev::READ&quot;, &quot;ev::WRITE&quot; etc.</big></p>

<p style="margin-left:17%;"><big>These are just enum values
with the same values as the &quot;EV_READ&quot; etc. macros
from <i>ev.h</i>.</big></p>

<p style="margin-left:11%;"><big>&quot;ev::tstamp&quot;,
&quot;ev::now&quot;</big></p>

<p style="margin-left:17%;"><big>Aliases to the same
types/functions as with the &quot;ev_&quot;
prefix.</big></p>

<p style="margin-left:11%;"><big>&quot;ev::io&quot;,
&quot;ev::timer&quot;, &quot;ev::periodic&quot;,
&quot;ev::idle&quot;, &quot;ev::sig&quot; etc.</big></p>

<p style="margin-left:17%;"><big>For each
&quot;ev_TYPE&quot; watcher in <i>ev.h</i> there is a
corresponding class of the same name in the &quot;ev&quot;
namespace, with the exception of &quot;ev_signal&quot; which
is called &quot;ev::sig&quot; to avoid clashes with the
&quot;signal&quot; macro defined by many
implementations.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>All of
those classes have these methods: <br>
ev::TYPE::TYPE () <br>
ev::TYPE::TYPE (loop) <br>
ev::TYPE::~TYPE</big></p>

<p style="margin-left:23%;"><big>The constructor
(optionally) takes an event loop to associate the watcher
with. If it is omitted, it will use
&quot;EV_DEFAULT&quot;.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>The
constructor calls &quot;ev_init&quot; for you, which means
you have to call the &quot;set&quot; method before starting
it.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>It will
not set a callback, however: You have to call the templated
&quot;set&quot; method to set a callback before you can
start the watcher.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>(The
reason why you have to use a method is a limitation in
C</big> ++ <big>which does not allow explicit template
arguments for constructors).</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>The
destructor automatically stops the watcher if it is
active.</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;set&lt;class,
&amp;class::method&gt; (object *)</big></p>

<p style="margin-left:23%;"><big>This method sets the
callback method to call. The method has to have a signature
of &quot;void (*)(ev_TYPE &amp;, int)&quot;, it receives the
watcher as first argument and the &quot;revents&quot; as
second. The object must be given as parameter and is stored
in the &quot;data&quot; member of the watcher.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>This
method synthesizes efficient thunking code to call your
method from the C callback that libev requires. If your
compiler can inline your callback (i.e. it is visible to it
at the place of the &quot;set&quot; call and your compiler
is good :), then the method will be fully inlined into the
thunking function, making it as fast as a direct C
callback.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>Example:
simple class declaration and watcher
initialisation</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>struct
myclass <br>
{ <br>
void io_cb (ev::io &amp;w, int revents) { } <br>
} <br>
myclass obj; <br>
ev::io iow; <br>
iow.set &lt;myclass, &amp;myclass::io_cb&gt;
(&amp;obj);</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;set (object
*)</big></p>

<p style="margin-left:23%;"><big>This is a variation of a
method callback &minus; leaving out the method to call will
default the method to &quot;operator ()&quot;, which makes
it possible to use functor objects without having to
manually specify the &quot;operator ()&quot; all the time.
Incidentally, you can then also leave out the template
argument list.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>The
&quot;operator ()&quot; method prototype must be &quot;void
operator ()(watcher &amp;w, int revents)&quot;.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>See the
method&minus;&quot;set&quot; above for more
details.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>Example:
use a functor object as callback.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>struct
myfunctor <br>
{ <br>
void operator() (ev::io &amp;w, int revents) <br>
{ <br>
... <br>
} <br>
} <br>
myfunctor f; <br>
ev::io w; <br>
w.set (&amp;f);</big></p>


<p style="margin-left:17%;"><big>w&minus;&gt;set&lt;function&gt;
(void *data = 0)</big></p>

<p style="margin-left:23%;"><big>Also sets a callback, but
uses a static method or plain function as callback. The
optional &quot;data&quot; argument will be stored in the
watcher&rsquo;s &quot;data&quot; member and is free for you
to use.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>The
prototype of the &quot;function&quot; must be &quot;void
(*)(ev::TYPE &amp;w, int)&quot;.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>See the
method&minus;&quot;set&quot; above for more
details.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>Example:
Use a plain function as callback.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>static
void io_cb (ev::io &amp;w, int revents) { } <br>
iow.set &lt;io_cb&gt; ();</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;set
(loop)</big></p>

<p style="margin-left:23%;"><big>Associates a different
&quot;struct ev_loop&quot; with this watcher. You can only
do this when the watcher is inactive (and not pending
either).</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;set
([arguments])</big></p>

<p style="margin-left:23%;"><big>Basically the same as
&quot;ev_TYPE_set&quot; (except for &quot;ev::embed&quot;
watchers&gt;), with the same arguments. Either this method
or a suitable start method must be called at least once.
Unlike the C counterpart, an active watcher gets
automatically stopped and restarted when reconfiguring it
with this method.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>For
&quot;ev::embed&quot; watchers this method is called
&quot;set_embed&quot;, to avoid clashing with the &quot;set
(loop)&quot; method.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>For
&quot;ev::io&quot; watchers there is an additional
&quot;set&quot; method that acepts a new event mask only,
and internally calls &quot;ev_io_modfify&quot;.</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;start
()</big></p>

<p style="margin-left:23%;"><big>Starts the watcher. Note
that there is no &quot;loop&quot; argument, as the
constructor already stores the event loop.</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;start
([arguments])</big></p>

<p style="margin-left:23%;"><big>Instead of calling
&quot;set&quot; and &quot;start&quot; methods separately, it
is often convenient to wrap them in one call. Uses the same
type of arguments as the configure &quot;set&quot; method of
the watcher.</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;stop
()</big></p>

<p style="margin-left:23%;"><big>Stops the watcher if it is
active. Again, no &quot;loop&quot; argument.</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;again ()
(&quot;ev::timer&quot;, &quot;ev::periodic&quot;
only)</big></p>

<p style="margin-left:23%;"><big>For &quot;ev::timer&quot;
and &quot;ev::periodic&quot;, this invokes the corresponding
&quot;ev_TYPE_again&quot; function.</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;sweep ()
(&quot;ev::embed&quot; only)</big></p>

<p style="margin-left:23%;"><big>Invokes
&quot;ev_embed_sweep&quot;.</big></p>

<p style="margin-left:17%;"><big>w&minus;&gt;update ()
(&quot;ev::stat&quot; only)</big></p>

<p style="margin-left:23%;"><big>Invokes
&quot;ev_stat_stat&quot;.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Example:
Define a class with two I/O and idle watchers, start the I/O
watchers in the constructor.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>class
myclass <br>
{ <br>
ev::io io ; void io_cb (ev::io &amp;w, int revents); <br>
ev::io io2 ; void io2_cb (ev::io &amp;w, int revents); <br>
ev::idle idle; void idle_cb (ev::idle &amp;w, int revents);
<br>
myclass (int fd) <br>
{ <br>
io .set &lt;myclass, &amp;myclass::io_cb &gt; (this); <br>
io2 .set &lt;myclass, &amp;myclass::io2_cb &gt; (this); <br>
idle.set &lt;myclass, &amp;myclass::idle_cb&gt; (this); <br>
io.set (fd, ev::WRITE); // configure the watcher <br>
io.start (); // start it whenever convenient <br>
io2.start (fd, ev::READ); // set + start in one call <br>
} <br>
};</big></p>

<h2>OTHER LANGUAGE BINDINGS
<a name="OTHER LANGUAGE BINDINGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big>Libev does
not offer other language bindings itself, but bindings for a
number of languages exist in the form of third-party
packages. If you know any interesting language binding in
addition to the ones listed here, drop me a note. <br>
Perl</big></p>

<p style="margin-left:17%;"><big>The</big> EV <big>module
implements the full libev</big> API <big>and is actually
used to test libev.</big> EV <big>is developed together with
libev. Apart from the</big> EV <big>core module, there are
additional modules that implement libev-compatible
interfaces to &quot;libadns&quot; (&quot;EV::ADNS&quot;, but
&quot;AnyEvent::DNS&quot; is preferred nowadays),
&quot;Net::SNMP&quot; (&quot;Net::SNMP::EV&quot;) and the
&quot;libglib&quot; event core (&quot;Glib::EV&quot; and
&quot;EV::Glib&quot;).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>It can be
found and installed via</big> CPAN, <big>its homepage is at
&lt;http://software.schmorp.de/pkg/EV&gt;.</big></p>

<p style="margin-left:11%;"><big>Python</big></p>

<p style="margin-left:17%;"><big>Python bindings can be
found at &lt;http://code.google.com/p/pyev/&gt;. It seems to
be quite complete and well-documented.</big></p>

<p style="margin-left:11%;"><big>Ruby</big></p>

<p style="margin-left:17%;"><big>Tony Arcieri has written a
ruby extension that offers access to a subset of the
libev</big> API <big>and adds file handle abstractions,
asynchronous</big> DNS <big>and more on top of it. It can be
found via gem servers. Its homepage is at
&lt;http://rev.rubyforge.org/&gt;.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Roger Pack
reports that using the link order &quot;&minus;lws2_32
&minus;lmsvcrt&minus;ruby&minus;190&quot; makes rev work
even on mingw.</big></p>

<p style="margin-left:11%;"><big>Haskell</big></p>

<p style="margin-left:17%;"><big>A haskell binding to libev
is available at
&lt;http://hackage.haskell.org/cgi&minus;bin/hackage&minus;scripts/package/hlibev&gt;.</big></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><big>D</big></p></td>
<td width="5%"></td>
<td width="83%">


<p><big>Leandro Lucarella has written a D language binding
(<i>ev.d</i>) for libev, to be found at
&lt;http://www.llucax.com.ar/proj/ev.d/index.html&gt;.</big></p> </td></tr>
</table>

<p style="margin-left:11%;"><big>Ocaml</big></p>

<p style="margin-left:17%;"><big>Erkki Seppala has written
Ocaml bindings for libev, to be found at
&lt;http://modeemi.cs.tut.fi/~flux/software/ocaml&minus;ev/&gt;.</big></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><big>Lua</big></p></td>
<td width="2%"></td>
<td width="83%">


<p><big>Brian Maher has written a partial interface to
libev for lua (at the time of this writing, only
&quot;ev_io&quot; and &quot;ev_timer&quot;), to be found at
&lt;http://github.com/brimworks/lua&minus;ev&gt;.</big></p> </td></tr>
</table>

<p style="margin-left:11%;"><big>Javascript</big></p>

<p style="margin-left:17%;"><big>Node.js
(&lt;http://nodejs.org&gt;) uses libev as the underlying
event library.</big></p>

<p style="margin-left:11%;"><big>Others</big></p>

<p style="margin-left:17%;"><big>There are others, and I
stopped counting.</big></p>

<h2>MACRO MAGIC
<a name="MACRO MAGIC"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big>Libev can
be compiled with a variety of options, the most fundamental
of which is &quot;EV_MULTIPLICITY&quot;. This option
determines whether (most) functions and callbacks have an
initial &quot;struct ev_loop *&quot; argument.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>To make it
easier to write programs that cope with either variant, the
following macros are defined: <br>
&quot;EV_A&quot;, &quot;EV_A_&quot;</big></p>

<p style="margin-left:17%;"><big>This provides the loop
<i>argument</i> for functions, if one is required (&quot;ev
loop argument&quot;). The &quot;EV_A&quot; form is used when
this is the sole argument, &quot;EV_A_&quot; is used when
other arguments are following. Example:</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>ev_unref
(EV_A); <br>
ev_timer_add (EV_A_ watcher); <br>
ev_run (EV_A_ 0);</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>It assumes
the variable &quot;loop&quot; of type &quot;struct ev_loop
*&quot; is in scope, which is often provided by the
following macro.</big></p>

<p style="margin-left:11%;"><big>&quot;EV_P&quot;,
&quot;EV_P_&quot;</big></p>

<p style="margin-left:17%;"><big>This provides the loop
<i>parameter</i> for functions, if one is required (&quot;ev
loop parameter&quot;). The &quot;EV_P&quot; form is used
when this is the sole parameter, &quot;EV_P_&quot; is used
when other parameters are following. Example:</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>// this is
how ev_unref is being declared <br>
static void ev_unref (EV_P); <br>
// this is how you can declare your typical callback <br>
static void cb (EV_P_ ev_timer *w, int revents)</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>It
declares a parameter &quot;loop&quot; of type &quot;struct
ev_loop *&quot;, quite suitable for use with
&quot;EV_A&quot;.</big></p>

<p style="margin-left:11%;"><big>&quot;EV_DEFAULT&quot;,
&quot;EV_DEFAULT_&quot;</big></p>

<p style="margin-left:17%;"><big>Similar to the other two
macros, this gives you the value of the default loop, if
multiple loops are supported (&quot;ev loop default&quot;).
The default loop will be initialised if it isn&rsquo;t
already initialised.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For
non-multiplicity builds, these macros do nothing, so you
always have to initialise the loop somewhere.</big></p>


<p style="margin-left:11%;"><big>&quot;EV_DEFAULT_UC&quot;,
&quot;EV_DEFAULT_UC_&quot;</big></p>

<p style="margin-left:17%;"><big>Usage identical to
&quot;EV_DEFAULT&quot; and &quot;EV_DEFAULT_&quot;, but
requires that the default loop has been initialised
(&quot;UC&quot; == unchecked). Their behaviour is undefined
when the default loop has not been initialised by a previous
execution of &quot;EV_DEFAULT&quot;, &quot;EV_DEFAULT_&quot;
or &quot;ev_default_init (...)&quot;.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>It is
often prudent to use &quot;EV_DEFAULT&quot; when
initialising the first watcher in a function but use
&quot;EV_DEFAULT_UC&quot; afterwards.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Example:
Declare and initialise a check watcher, utilising the above
macros so it will work regardless of whether multiple loops
are supported or not.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>static
void <br>
check_cb (EV_P_ ev_timer *w, int revents) <br>
{ <br>
ev_check_stop (EV_A_ w); <br>
} <br>
ev_check check; <br>
ev_check_init (&amp;check, check_cb); <br>
ev_check_start (EV_DEFAULT_ &amp;check); <br>
ev_run (EV_DEFAULT_ 0);</big></p>

<h2>EMBEDDING
<a name="EMBEDDING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big>Libev can
(and often is) directly embedded into host applications.
Examples of applications that embed it include the Deliantra
Game Server, the</big> EV <big>perl module, the</big> GNU
<big>Virtual Private Ethernet (gvpe) and
rxvt-unicode.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The goal
is to enable you to just copy the necessary files into your
source directory without having to change even a single line
in them, so you can easily upgrade by simply copying (or
having a checked-out copy of libev somewhere in your source
tree).</big></p>


<p style="margin-left:11%; margin-top: 1em"><b>FILESETS</b>
<big><br>
Depending on what features you need you need to include one
or more sets of files in your application.</big></p>

<p style="margin-left:11%; margin-top: 1em"><i>CORE EVENT
LOOP</i></p>

<p style="margin-left:11%; margin-top: 1em"><big>To include
only the libev core (all the &quot;ev_*&quot; functions),
with manual configuration (no autoconf):</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#define
EV_STANDALONE 1 <br>
#include &quot;ev.c&quot;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>This will
automatically include <i>ev.h</i>, too, and should be done
in a single C source file only to provide the function
implementations. To use it, do the same for <i>ev.h</i> in
all files wishing to use this</big> API <big>(best done by
writing a wrapper around <i>ev.h</i> that you can include
instead and where you can put other configuration
options):</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#define
EV_STANDALONE 1 <br>
#include &quot;ev.h&quot;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Both
header files and implementation files can be compiled with a
C</big> ++ <big>compiler (at least, that&rsquo;s a stated
goal, and breakage will be treated as a bug).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>You need
the following files in your source tree, or in a directory
in your include path (e.g. in libev/ when using
&minus;Ilibev):</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>ev.h <br>
ev.c <br>
ev_vars.h <br>
ev_wrap.h <br>
ev_win32.c required on win32 platforms only <br>
ev_select.c only when select backend is enabled <br>
ev_poll.c only when poll backend is enabled <br>
ev_epoll.c only when the epoll backend is enabled <br>
ev_linuxaio.c only when the linux aio backend is enabled
<br>
ev_iouring.c only when the linux io_uring backend is enabled
<br>
ev_kqueue.c only when the kqueue backend is enabled <br>
ev_port.c only when the solaris port backend is
enabled</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><i>ev.c</i>
includes the backend files directly when enabled, so you
only need to compile this single file.</big></p>

<p style="margin-left:11%; margin-top: 1em"><i>LIBEVENT
COMPATIBILITY API</i></p>

<p style="margin-left:11%; margin-top: 1em"><big>To include
the libevent compatibility</big> API, <big>also
include:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#include
&quot;event.c&quot;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>in the
file including <i>ev.c</i>, and:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#include
&quot;event.h&quot;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>in the
files that want to use the libevent</big> API. <big>This
also includes <i>ev.h</i>.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>You need
the following additional files for this:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>event.h
<br>
event.c</big></p>

<p style="margin-left:11%; margin-top: 1em"><i>AUTOCONF
SUPPORT</i></p>

<p style="margin-left:11%; margin-top: 1em"><big>Instead of
using &quot;EV_STANDALONE=1&quot; and providing your
configuration in whatever way you want, you can also
&quot;m4_include([libev.m4])&quot; in your
<i>configure.ac</i> and leave &quot;EV_STANDALONE&quot;
undefined. <i>ev.c</i> will then include <i>config.h</i> and
configure itself accordingly.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>For this
of course you need the m4 file:</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>libev.m4</big></p>


<p style="margin-left:11%; margin-top: 1em"><b>PREPROCESSOR
SYMBOLS/MACROS</b> <big><br>
Libev can be configured via a variety of preprocessor
symbols you have to define before including (or compiling)
any of its files. The default in the absence of autoconf is
documented for every option.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Symbols
marked with &quot;(h)&quot; do not change the</big> ABI,
<big>and can have different values when compiling libev vs.
including <i>ev.h</i>, so it is permissible to redefine them
before including <i>ev.h</i> without breaking compatibility
to a compiled library. All other symbols change the</big>
ABI, <big>which means all users of libev and the libev code
itself must be compiled with compatible settings.</big> <br>
EV_COMPAT3 <big>(h)</big></p>

<p style="margin-left:17%;"><big>Backwards compatibility is
a major concern for libev. This is why this release of libev
comes with wrappers for the functions and symbols that have
been renamed between libev version 3 and 4.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>You can
disable these wrappers (to test compatibility with future
versions) by defining &quot;EV_COMPAT3&quot; to 0 when
compiling your sources. This has the additional advantage
that you can drop the &quot;struct&quot; from &quot;struct
ev_loop&quot; declarations, as libev will provide an
&quot;ev_loop&quot; typedef in that case.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In some
future version, the default for &quot;EV_COMPAT3&quot; will
become 0, and in some even more future version the
compatibility code will be removed completely.</big></p>

<p style="margin-left:11%;">EV_STANDALONE
<big>(h)</big></p>

<p style="margin-left:17%;"><big>Must always be 1 if you do
not use autoconf configuration, which keeps libev from
including <i>config.h</i>, and it also defines dummy
implementations for some libevent functions (such as
logging, which is not supported). It will also not define
any of the structs usually found in <i>event.h</i> that are
not directly supported by the libev core alone.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In
standalone mode, libev will still try to automatically
deduce the configuration, but has to be more
conservative.</big></p>

<p style="margin-left:11%;">EV_USE_FLOOR</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will use the &quot;floor ()&quot; function for its periodic
reschedule calculations, otherwise libev will fall back on a
portable (slower) implementation. If you enable this, you
usually have to link against libm or something equivalent.
Enabling this when the &quot;floor&quot; function is not
available will fail, so the safe default is to not enable
this.</big></p>

<p style="margin-left:11%;">EV_USE_MONOTONIC</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will try to detect the availability of the monotonic clock
option at both compile time and runtime. Otherwise no use of
the monotonic clock option will be attempted. If you enable
this, you usually have to link against librt or something
similar. Enabling it when the functionality isn&rsquo;t
available is safe, though, although you have to make sure
you link against any libraries where the
&quot;clock_gettime&quot; function is hiding in (often
<i>&minus;lrt</i>). See also
&quot;EV_USE_CLOCK_SYSCALL&quot;.</big></p>

<p style="margin-left:11%;">EV_USE_REALTIME</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will try to detect the availability of the real-time clock
option at compile time (and assume its availability at
runtime if successful). Otherwise no use of the real-time
clock option will be attempted. This effectively replaces
&quot;gettimeofday&quot; by &quot;clock_get (CLOCK_REALTIME,
...)&quot; and will not normally affect correctness. See the
note about libraries in the description of
&quot;EV_USE_MONOTONIC&quot;, though. Defaults to the
opposite value of
&quot;EV_USE_CLOCK_SYSCALL&quot;.</big></p>

<p style="margin-left:11%;">EV_USE_CLOCK_SYSCALL</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will try to use a direct syscall instead of calling the
system-provided &quot;clock_gettime&quot; function. This
option exists because on GNU/Linux,
&quot;clock_gettime&quot; is in &quot;librt&quot;, but
&quot;librt&quot; unconditionally pulls in
&quot;libpthread&quot;, slowing down single-threaded
programs needlessly. Using a direct syscall is slightly
slower (in theory), because no optimised vdso implementation
can be used, but avoids the pthread dependency. Defaults to
1 on GNU/Linux with glibc 2.x or higher, as it simplifies
linking (no need for &quot;&minus;lrt&quot;).</big></p>

<p style="margin-left:11%;">EV_USE_NANOSLEEP</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will assume that &quot;nanosleep ()&quot; is available and
will use it for delays. Otherwise it will use &quot;select
()&quot;.</big></p>

<p style="margin-left:11%;">EV_USE_EVENTFD</p>

<p style="margin-left:17%;"><big>If defined to be 1, then
libev will assume that &quot;eventfd ()&quot; is available
and will probe for kernel support at runtime. This will
improve &quot;ev_signal&quot; and &quot;ev_async&quot;
performance and reduce resource consumption. If undefined,
it will be enabled if the headers indicate GNU/Linux + Glibc
2.7 or newer, otherwise disabled.</big></p>

<p style="margin-left:11%;">EV_USE_SIGNALFD</p>

<p style="margin-left:17%;"><big>If defined to be 1, then
libev will assume that &quot;signalfd ()&quot; is available
and will probe for kernel support at runtime. This enables
the use of</big> EVFLAG_SIGNALFD <big>for faster and simpler
signal handling. If undefined, it will be enabled if the
headers indicate GNU/Linux + Glibc 2.7 or newer, otherwise
disabled.</big></p>

<p style="margin-left:11%;">EV_USE_TIMERFD</p>

<p style="margin-left:17%;"><big>If defined to be 1, then
libev will assume that &quot;timerfd ()&quot; is available
and will probe for kernel support at runtime. This allows
libev to detect time jumps accurately. If undefined, it will
be enabled if the headers indicate GNU/Linux + Glibc 2.8 or
newer and define &quot;TFD_TIMER_CANCEL_ON_SET&quot;,
otherwise disabled.</big></p>

<p style="margin-left:11%;">EV_USE_EVENTFD</p>

<p style="margin-left:17%;"><big>If defined to be 1, then
libev will assume that &quot;eventfd ()&quot; is available
and will probe for kernel support at runtime. This will
improve &quot;ev_signal&quot; and &quot;ev_async&quot;
performance and reduce resource consumption. If undefined,
it will be enabled if the headers indicate GNU/Linux + Glibc
2.7 or newer, otherwise disabled.</big></p>

<p style="margin-left:11%;">EV_USE_SELECT</p>

<p style="margin-left:17%;"><big>If undefined or defined to
be 1, libev will compile in support for the
&quot;select&quot;(2) backend. No attempt at auto-detection
will be done: if no other method takes over, select will be
it. Otherwise the select backend will not be compiled
in.</big></p>

<p style="margin-left:11%;">EV_SELECT_USE_FD_SET</p>

<p style="margin-left:17%;"><big>If defined to 1, then the
select backend will use the system &quot;fd_set&quot;
structure. This is useful if libev doesn&rsquo;t compile due
to a missing &quot;NFDBITS&quot; or &quot;fd_mask&quot;
definition or it mis-guesses the bitset layout on exotic
systems. This usually limits the range of file descriptors
to some low limit such as 1024 or might have other
limitations (winsocket only allows 64 sockets). The
&quot;FD_SETSIZE&quot; macro, set before compilation,
configures the maximum size of the
&quot;fd_set&quot;.</big></p>

<p style="margin-left:11%;">EV_SELECT_IS_WINSOCKET</p>

<p style="margin-left:17%;"><big>When defined to 1, the
select backend will assume that select/socket/connect etc.
don&rsquo;t understand file descriptors but wants osf
handles on win32 (this is the case when the select to be
used is the winsock select). This means that it will call
&quot;_get_osfhandle&quot; on the fd to convert it to
an</big> OS <big>handle. Otherwise, it is assumed that all
these functions actually work on fds, even on win32. Should
not be defined on non&minus;win32 platforms.</big></p>

<p style="margin-left:11%;">EV_FD_TO_WIN32_HANDLE
<big>(fd)</big></p>

<p style="margin-left:17%;"><big>If
&quot;EV_SELECT_IS_WINSOCKET&quot; is enabled, then libev
needs a way to map file descriptors to socket handles. When
not defining this symbol (the default), then libev will call
&quot;_get_osfhandle&quot;, which is usually correct. In
some cases, programs use their own file descriptor
management, in which case they can provide this function to
map fds to socket handles.</big></p>

<p style="margin-left:11%;">EV_WIN32_HANDLE_TO_FD
<big>(handle)</big></p>

<p style="margin-left:17%;"><big>If
&quot;EV_SELECT_IS_WINSOCKET&quot; then libev maps handles
to file descriptors using the standard
&quot;_open_osfhandle&quot; function. For programs
implementing their own fd to handle mapping, overwriting
this function makes it easier to do so. This can be done by
defining this macro to an appropriate value.</big></p>

<p style="margin-left:11%;">EV_WIN32_CLOSE_FD
<big>(fd)</big></p>

<p style="margin-left:17%;"><big>If programs implement
their own fd to handle mapping on win32, then this macro can
be used to override the &quot;close&quot; function, useful
to unregister file descriptors again. Note that the
replacement function has to close the underlying</big> OS
<big>handle.</big></p>

<p style="margin-left:11%;">EV_USE_WSASOCKET</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will use &quot;WSASocket&quot; to create its internal
communication socket, which works better in some
environments. Otherwise, the normal &quot;socket&quot;
function will be used, which works better in other
environments.</big></p>

<p style="margin-left:11%;">EV_USE_POLL</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will compile in support for the &quot;poll&quot;(2) backend.
Otherwise it will be enabled on non&minus;win32 platforms.
It takes precedence over select.</big></p>

<p style="margin-left:11%;">EV_USE_EPOLL</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will compile in support for the Linux &quot;epoll&quot;(7)
backend. Its availability will be detected at runtime,
otherwise another method will be used as fallback. This is
the preferred backend for GNU/Linux systems. If undefined,
it will be enabled if the headers indicate GNU/Linux + Glibc
2.4 or newer, otherwise disabled.</big></p>

<p style="margin-left:11%;">EV_USE_LINUXAIO</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will compile in support for the Linux aio backend
(&quot;EV_USE_EPOLL&quot; must also be enabled). If
undefined, it will be enabled on linux, otherwise
disabled.</big></p>

<p style="margin-left:11%;">EV_USE_IOURING</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will compile in support for the Linux io_uring backend
(&quot;EV_USE_EPOLL&quot; must also be enabled). Due to
it&rsquo;s current limitations it has to be requested
explicitly. If undefined, it will be enabled on linux,
otherwise disabled.</big></p>

<p style="margin-left:11%;">EV_USE_KQUEUE</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will compile in support for the</big> BSD <big>style
&quot;kqueue&quot;(2) backend. Its actual availability will
be detected at runtime, otherwise another method will be
used as fallback. This is the preferred backend for</big>
BSD <big>and BSD-like systems, although on most BSDs kqueue
only supports some types of fds correctly (the only platform
we found that supports ptys for example was NetBSD), so
kqueue might be compiled in, but not be used unless
explicitly requested. The best way to use it is to find out
whether kqueue supports your type of fd properly and use an
embedded kqueue loop.</big></p>

<p style="margin-left:11%;">EV_USE_PORT</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will compile in support for the Solaris 10 port style
backend. Its availability will be detected at runtime,
otherwise another method will be used as fallback. This is
the preferred backend for Solaris 10 systems.</big></p>

<p style="margin-left:11%;">EV_USE_DEVPOLL</p>

<p style="margin-left:17%;"><big>Reserved for future
expansion, works like the</big> USE <big>symbols
above.</big></p>

<p style="margin-left:11%;">EV_USE_INOTIFY</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will compile in support for the Linux inotify interface to
speed up &quot;ev_stat&quot; watchers. Its actual
availability will be detected at runtime. If undefined, it
will be enabled if the headers indicate GNU/Linux + Glibc
2.4 or newer, otherwise disabled.</big></p>

<p style="margin-left:11%;">EV_NO_SMP</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will assume that memory is always coherent between threads,
that is, threads can be used, but threads never run on
different cpus (or different cpu cores). This reduces
dependencies and makes libev faster.</big></p>

<p style="margin-left:11%;">EV_NO_THREADS</p>

<p style="margin-left:17%;"><big>If defined to be 1, libev
will assume that it will never be called from different
threads (that includes signal handlers), which is a stronger
assumption than &quot;EV_NO_SMP&quot;, above. This reduces
dependencies and makes libev faster.</big></p>

<p style="margin-left:11%;">EV_ATOMIC_T</p>

<p style="margin-left:17%;"><big>Libev requires an integer
type (suitable for storing 0 or 1) whose access is atomic
with respect to other threads or signal contexts. No such
type is easily found in the C language, so you can provide
your own type that you know is safe for your purposes. It is
used both for signal handler &quot;locking&quot; as well as
for signal and thread safety in &quot;ev_async&quot;
watchers.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In the
absence of this define, libev will use &quot;sig_atomic_t
volatile&quot; (from <i>signal.h</i>), which is usually good
enough on most platforms.</big></p>

<p style="margin-left:11%;">EV_H <big>(h)</big></p>

<p style="margin-left:17%;"><big>The name of the
<i>ev.h</i> header file used to include it. The default if
undefined is &quot;ev.h&quot; in <i>event.h</i>, <i>ev.c</i>
and <i>ev++.h</i>. This can be used to virtually rename the
<i>ev.h</i> header file in case of conflicts.</big></p>

<p style="margin-left:11%;">EV_CONFIG_H <big>(h)</big></p>

<p style="margin-left:17%;"><big>If
&quot;EV_STANDALONE&quot; isn&rsquo;t 1, this variable can
be used to override <i>ev.c</i>&rsquo;s idea of where to
find the <i>config.h</i> file, similarly to
&quot;EV_H&quot;, above.</big></p>

<p style="margin-left:11%;">EV_EVENT_H <big>(h)</big></p>

<p style="margin-left:17%;"><big>Similarly to
&quot;EV_H&quot;, this macro can be used to override
<i>event.c</i>&rsquo;s idea of how the <i>event.h</i> header
can be found, the default is &quot;event.h&quot;.</big></p>

<p style="margin-left:11%;">EV_PROTOTYPES
<big>(h)</big></p>

<p style="margin-left:17%;"><big>If defined to be 0, then
<i>ev.h</i> will not define any function prototypes, but
still define all the structs and other symbols. This is
occasionally useful if you want to provide your own wrapper
functions around libev functions.</big></p>

<p style="margin-left:11%;">EV_MULTIPLICITY</p>

<p style="margin-left:17%;"><big>If undefined or defined to
1, then all event-loop-specific functions will have the
&quot;struct ev_loop *&quot; as first argument, and you can
create additional independent event loops. Otherwise there
will be no support for multiple event loops and there is no
first event loop pointer argument. Instead, all functions
act on the single default loop.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Note that
&quot;EV_DEFAULT&quot; and &quot;EV_DEFAULT_&quot; will no
longer provide a default loop when multiplicity is switched
off &minus; you always have to initialise the loop manually
in this case.</big></p>

<p style="margin-left:11%;">EV_MINPRI <br>
EV_MAXPRI</p>

<p style="margin-left:17%;"><big>The range of allowed
priorities. &quot;EV_MINPRI&quot; must be smaller or equal
to &quot;EV_MAXPRI&quot;, but otherwise there are no
non-obvious limitations. You can provide for more priorities
by overriding those symbols (usually defined to be
&quot;&minus;2&quot; and 2, respectively).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>When doing
priority-based operations, libev usually has to linearly
search all the priorities, so having many of them (hundreds)
uses a lot of space and time, so using the defaults of five
priorities (&minus;2 .. +2) is usually fine.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>If your
embedding application does not need any priorities, defining
these both to 0 will save some memory and</big> CPU.</p>

<p style="margin-left:11%;">EV_PERIODIC_ENABLE,
EV_IDLE_ENABLE, EV_EMBED_ENABLE, EV_STAT_ENABLE, <br>
EV_PREPARE_ENABLE, EV_CHECK_ENABLE, EV_FORK_ENABLE,
EV_SIGNAL_ENABLE, <br>
EV_ASYNC_ENABLE, EV_CHILD_ENABLE.</p>

<p style="margin-left:17%;"><big>If undefined or defined to
be 1 (and the platform supports it), then the respective
watcher type is supported. If defined to be 0, then it is
not. Disabling watcher types mainly saves code
size.</big></p>

<p style="margin-left:11%;">EV_FEATURES</p>

<p style="margin-left:17%;"><big>If you need to shave off
some kilobytes of code at the expense of some speed (but
with the full</big> API <big>), you can define this symbol
to request certain subsets of functionality. The default is
to enable all features that can be enabled on the
platform.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>A typical
way to use this symbol is to define it to 0 (or to a bitset
with some broad features you want) and then selectively
re-enable additional parts you want, for example if you want
everything minimal, but multiple event loop support, async
and child watchers and the poll backend, use this:</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#define
EV_FEATURES 0 <br>
#define EV_MULTIPLICITY 1 <br>
#define EV_USE_POLL 1 <br>
#define EV_CHILD_ENABLE 1 <br>
#define EV_ASYNC_ENABLE 1</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The actual
value is a bitset, it can be a combination of the following
values (by default, all of these are enabled): <br>
1 &minus; faster/larger code</big></p>

<p style="margin-left:23%;"><big>Use larger code to speed
up some operations.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>Currently
this is used to override some inlining decisions (enlarging
the code size by roughly 30% on amd64).</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>When
optimising for size, use of compiler flags such as
&quot;&minus;Os&quot; with gcc is recommended, as well as
&quot;&minus;DNDEBUG&quot;, as libev contains a number of
assertions.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>The
default is off when &quot;__OPTIMIZE_SIZE__&quot; is defined
by your compiler (e.g. gcc with
&quot;&minus;Os&quot;).</big></p>

<p style="margin-left:17%;"><big>2 &minus; faster/larger
data structures</big></p>

<p style="margin-left:23%;"><big>Replaces the small
2&minus;heap for timer management by a faster 4&minus;heap,
larger hash table sizes and so on. This will usually further
increase code size and can additionally have an effect on
the size of data structures at runtime.</big></p>

<p style="margin-left:23%; margin-top: 1em"><big>The
default is off when &quot;__OPTIMIZE_SIZE__&quot; is defined
by your compiler (e.g. gcc with
&quot;&minus;Os&quot;).</big></p>

<p style="margin-left:17%;"><big>4 &minus; full</big> API
<big>configuration</big></p>

<p style="margin-left:23%;"><big>This enables priorities
(sets &quot;EV_MAXPRI&quot;=2 and
&quot;EV_MINPRI&quot;=&minus;2), and enables multiplicity
(&quot;EV_MULTIPLICITY&quot;=1).</big></p>

<p style="margin-left:17%;"><big>8 &minus; full</big>
API</p>

<p style="margin-left:23%;"><big>This enables a lot of the
&quot;lesser used&quot;</big> API <big>functions. See
&quot;ev.h&quot; for details on which parts of the</big> API
<big>are still available without this feature, and do not
complain if this subset changes over time.</big></p>

<p style="margin-left:17%;"><big>16 &minus; enable all
optional watcher types</big></p>

<p style="margin-left:23%;"><big>Enables all optional
watcher types. If you want to selectively enable only some
watcher types other than I/O and timers (e.g. prepare,
embed, async, child...) you can enable them manually by
defining &quot;EV_watchertype_ENABLE&quot; to 1
instead.</big></p>

<p style="margin-left:17%;"><big>32 &minus; enable all
backends</big></p>

<p style="margin-left:23%;"><big>This enables all backends
&minus; without this feature, you need to enable at least
one backend manually (&quot;EV_USE_SELECT&quot; is a good
choice).</big></p>

<p style="margin-left:17%;"><big>64 &minus; enable
OS-specific &quot;helper&quot; APIs</big></p>

<p style="margin-left:23%;"><big>Enable inotify, eventfd,
signalfd and similar OS-specific helper APIs by
default.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Compiling
with &quot;gcc &minus;Os &minus;DEV_STANDALONE
&minus;DEV_USE_EPOLL=1 &minus;DEV_FEATURES=0&quot; reduces
the compiled size of libev from 24.7Kb code/2.8Kb data to
6.5Kb code/0.3Kb data on my GNU/Linux amd64 system, while
still giving you I/O watchers, timers and monotonic clock
support.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>With an
intelligent-enough linker (gcc+binutils are intelligent
enough when you use
&quot;&minus;Wl,&minus;&minus;gc&minus;sections
&minus;ffunction&minus;sections&quot;) functions unused by
your program might be left out as well &minus; a binary
starting a timer and an I/O watcher then might come out at
only 5Kb.</big></p>

<p style="margin-left:11%;">EV_API_STATIC</p>

<p style="margin-left:17%;"><big>If this symbol is defined
(by default it is not), then all identifiers will have
static linkage. This means that libev will not export any
identifiers, and you cannot link against libev anymore. This
can be useful when you embed libev, only want to use libev
functions in a single file, and do not want its identifiers
to be visible.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>To use
this, define &quot;EV_API_STATIC&quot; and include
<i>ev.c</i> in the file that wants to use libev.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>This
option only works when libev is compiled with a C compiler,
as C</big> ++ <big>doesn&rsquo;t support the required
declaration syntax.</big></p>

<p style="margin-left:11%;">EV_AVOID_STDIO</p>

<p style="margin-left:17%;"><big>If this is set to 1 at
compiletime, then libev will avoid using stdio functions
(printf, scanf, perror etc.). This will increase the code
size somewhat, but if your program doesn&rsquo;t otherwise
depend on stdio and your libc allows it, this avoids linking
in the stdio library which is quite big.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Note that
error messages might become less precise when this option is
enabled.</big></p>

<p style="margin-left:11%;">EV_NSIG</p>

<p style="margin-left:17%;"><big>The highest supported
signal number, +1 (or, the number of signals): Normally,
libev tries to deduce the maximum number of signals
automatically, but sometimes this fails, in which case it
can be specified. Also, using a lower number than detected
(32 should be good for about any system in existence) can
save some memory, as libev statically allocates some
12&minus;24 bytes per signal number.</big></p>

<p style="margin-left:11%;">EV_PID_HASHSIZE</p>

<p style="margin-left:17%;"><big>&quot;ev_child&quot;
watchers use a small hash table to distribute workload by
pid. The default size is 16 (or 1 with
&quot;EV_FEATURES&quot; disabled), usually more than enough.
If you need to manage thousands of children you might want
to increase this value (<i>must</i> be a power of
two).</big></p>

<p style="margin-left:11%;">EV_INOTIFY_HASHSIZE</p>

<p style="margin-left:17%;"><big>&quot;ev_stat&quot;
watchers use a small hash table to distribute workload by
inotify watch id. The default size is 16 (or 1 with
&quot;EV_FEATURES&quot; disabled), usually more than enough.
If you need to manage thousands of &quot;ev_stat&quot;
watchers you might want to increase this value (<i>must</i>
be a power of two).</big></p>

<p style="margin-left:11%;">EV_USE_4HEAP</p>

<p style="margin-left:17%;"><big>Heaps are not very
cache-efficient. To improve the cache-efficiency of the
timer and periodics heaps, libev uses a 4&minus;heap when
this symbol is defined to 1. The 4&minus;heap uses more
complicated (longer) code but has noticeably faster
performance with many (thousands) of watchers.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The
default is 1, unless &quot;EV_FEATURES&quot; overrides it,
in which case it will be 0.</big></p>

<p style="margin-left:11%;">EV_HEAP_CACHE_AT</p>

<p style="margin-left:17%;"><big>Heaps are not very
cache-efficient. To improve the cache-efficiency of the
timer and periodics heaps, libev can cache the timestamp
(<i>at</i>) within the heap structure (selected by defining
&quot;EV_HEAP_CACHE_AT&quot; to 1), which uses 8&minus;12
bytes more per watcher and a few hundred bytes more code,
but avoids random read accesses on heap changes. This
improves performance noticeably with many (hundreds) of
watchers.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The
default is 1, unless &quot;EV_FEATURES&quot; overrides it,
in which case it will be 0.</big></p>

<p style="margin-left:11%;">EV_VERIFY</p>

<p style="margin-left:17%;"><big>Controls how much internal
verification (see &quot;ev_verify ()&quot;) will be done: If
set to 0, no internal verification code will be compiled in.
If set to 1, then verification code will be compiled in, but
not called. If set to 2, then the internal verification code
will be called once per loop, which can slow down libev. If
set to 3, then the verification code will be called very
frequently, which will slow down libev
considerably.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>Verification
errors are reported via C&rsquo;s &quot;assert&quot;
mechanism, so if you disable that (e.g. by defining
&quot;NDEBUG&quot;) then no errors will be
reported.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The
default is 1, unless &quot;EV_FEATURES&quot; overrides it,
in which case it will be 0.</big></p>

<p style="margin-left:11%;">EV_COMMON</p>

<p style="margin-left:17%;"><big>By default, all watchers
have a &quot;void *data&quot; member. By redefining this
macro to something else you can include more and other types
of members. You have to define it each time you include one
of the files, though, and it must be identical each
time.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>For
example, the perl</big> EV <big>module uses something like
this:</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#define
EV_COMMON \ <br>
SV *self; /* contains this struct */ \ <br>
SV *cb_sv, *fh /* note no trailing &quot;;&quot;
*/</big></p>

<p style="margin-left:11%;">EV_CB_DECLARE <big>(type)</big>
<br>
EV_CB_INVOKE <big>(watcher, revents) <br>
ev_set_cb (ev, cb)</big></p>

<p style="margin-left:17%;"><big>Can be used to change the
callback member declaration in each watcher, and the way
callbacks are invoked and set. Must expand to a struct
member definition and a statement, respectively. See the
<i>ev.h</i> header file for their default definitions. One
possible use for overriding these is to avoid the
&quot;struct ev_loop *&quot; as first argument in all cases,
or to use method calls instead of plain function calls in
C</big> ++ <big>.</big></p>

<p style="margin-left:11%; margin-top: 1em"><b>EXPORTED API
SYMBOLS</b> <big><br>
If you need to re-export the</big> API <big>(e.g. via
a</big> DLL <big>) and you need a list of exported symbols,
you can use the provided <i>Symbol.*</i> files which list
all public symbols, one per line:</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>Symbols.ev
for libev proper <br>
Symbols.event for the libevent emulation</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>This can
also be used to rename all public symbols to avoid clashes
with multiple versions of libev linked together (which is
obviously bad in itself, but sometimes it is inconvenient to
avoid this).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>A sed
command like this will create wrapper
&quot;#define&quot;&rsquo;s that you need to include before
including <i>ev.h</i>:</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>&lt;Symbols.ev
sed &minus;e &quot;s/.*/#define &amp; myprefix_&amp;/&quot;
&gt;wrap.h</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>This would
create a file <i>wrap.h</i> which essentially looks like
this:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#define
ev_backend myprefix_ev_backend <br>
#define ev_check_start myprefix_ev_check_start <br>
#define ev_check_stop myprefix_ev_check_stop <br>
...</big></p>


<p style="margin-left:11%; margin-top: 1em"><b>EXAMPLES</b>
<big><br>
For a real-world example of a program the includes libev
verbatim, you can have a look at the</big> EV <big>perl
module (&lt;http://software.schmorp.de/pkg/EV.html&gt;). It
has the libev files in the <i>libev/</i> subdirectory and
includes them in the</big> <i>EV/EVAPI <big>.h</big></i>
<big>(public interface) and</big> <i>EV <big>.xs</big></i>
<big>(implementation) files. Only the</big> <i>EV
<big>.xs</big></i> <big>file will be compiled. It is pretty
complex because it provides its own header file.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The usage
in rxvt-unicode is simpler. It has a <i>ev_cpp.h</i> header
file that everybody includes and which overrides some
configure choices:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#define
EV_FEATURES 8 <br>
#define EV_USE_SELECT 1 <br>
#define EV_PREPARE_ENABLE 1 <br>
#define EV_IDLE_ENABLE 1 <br>
#define EV_SIGNAL_ENABLE 1 <br>
#define EV_CHILD_ENABLE 1 <br>
#define EV_USE_STDEXCEPT 0 <br>
#define EV_CONFIG_H &lt;config.h&gt; <br>
#include &quot;ev++.h&quot;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>And a
<i>ev_cpp.C</i> implementation file that contains libev
proper and is compiled:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#include
&quot;ev_cpp.h&quot; <br>
#include &quot;ev.c&quot;</big></p>

<h2>INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT
<a name="INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>THREADS AND
COROUTINES</b> <i><br>
THREADS</i></p>

<p style="margin-left:11%; margin-top: 1em"><big>All libev
functions are reentrant and thread-safe unless explicitly
documented otherwise, but libev implements no locking
itself. This means that you can use as many loops as you
want in parallel, as long as there are no concurrent calls
into any libev function with the same loop parameter
(&quot;ev_default_*&quot; calls have an implicit default
loop parameter, of course): libev guarantees that different
event loops share no data structures that need any
locking.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Or to put
it differently: calls with different loop parameters can be
done concurrently from multiple threads, calls with the same
loop parameter must be done serially (but can be done from
different threads, as long as only one thread ever is inside
a call at any point in time, e.g. by using a mutex per
loop).</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>Specifically
to support threads (and signal handlers), libev implements
so-called &quot;ev_async&quot; watchers, which allow some
limited form of concurrency on the same event loop, namely
waking it up &quot;from the outside&quot;.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>If you
want to know which design (one loop, locking, or multiple
loops without or something else still) is best for your
problem, then I cannot help you, but here is some generic
advice:</big></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><big>&bull;</big></p></td>
<td width="5%"></td>
<td width="83%">


<p><big>most applications have a main thread: use the
default libev loop in that thread, or create a separate
thread running only the default loop.</big></p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><big>This helps
integrating other libraries or software modules that use
libev themselves and don&rsquo;t care/know about
threading.</big></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><big>&bull;</big></p></td>
<td width="5%"></td>
<td width="68%">


<p style="margin-top: 1em"><big>one loop per thread is
usually a good model.</big></p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><big>Doing this
is almost never wrong, sometimes a better-performance model
exists, but it is always a good start.</big></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><big>&bull;</big></p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em"><big>other models exist, such as
the leader/follower pattern, where one loop is handed
through multiple threads in a kind of round-robin
fashion.</big></p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><big>Choosing a
model is hard &minus; look around, learn, know that usually
you can do better than you currently do :&minus;)</big></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><big>&bull;</big></p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em"><big>often you need to talk to
some other thread which blocks in the event loop.</big></p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><big>&quot;ev_async&quot;
watchers can be used to wake them up from other threads
safely (or from signal contexts...).</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>An example
use would be to communicate signals or other events that
only work in the default loop by registering the signal
watcher with the default loop and triggering an
&quot;ev_async&quot; watcher from the default loop watcher
callback into the event loop interested in the
signal.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>See also
&quot;</big> THREAD LOCKING EXAMPLE&quot; <big>.</big></p>


<p style="margin-left:11%; margin-top: 1em"><i>COROUTINES</i></p>

<p style="margin-left:11%; margin-top: 1em"><big>Libev is
very accommodating to coroutines (&quot;cooperative
threads&quot;): libev fully supports nesting calls to its
functions from different coroutines (e.g. you can call
&quot;ev_run&quot; on the same loop from two different
coroutines, and switch freely between both coroutines
running the loop, as long as you don&rsquo;t confuse
yourself). The only exception is that you must not do this
from &quot;ev_periodic&quot; reschedule callbacks.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Care has
been taken to ensure that libev does not keep local state
inside &quot;ev_run&quot;, and other calls do not usually
allow for coroutine switches as they do not call any
callbacks.</big></p>

<p style="margin-left:11%; margin-top: 1em"><b>COMPILER
WARNINGS</b> <big><br>
Depending on your compiler and compiler settings, you might
get no or a lot of warnings when compiling libev code. Some
people are apparently scared by this.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>However,
these are unavoidable for many reasons. For one, each
compiler has different warnings, and each user has different
tastes regarding warning options. &quot;Warn-free&quot; code
therefore cannot be a goal except when targeting a specific
compiler and compiler-version.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Another
reason is that some compiler warnings require elaborate
workarounds, or other changes to the code that make it less
clear and less maintainable.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>And of
course, some compiler warnings are just plain stupid, or
simply wrong (because they don&rsquo;t actually warn about
the condition their message seems to warn about). For
example, certain older gcc versions had some warnings that
resulted in an extreme number of false positives. These have
been fixed, but some people still insist on making code
warn-free with such buggy versions.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>While
libev is written to generate as few warnings as possible,
&quot;warn-free&quot; code is not a goal, and it is
recommended not to build libev with any compiler warnings
enabled unless you are prepared to cope with them (e.g. by
ignoring them). Remember that warnings are just that:
warnings, not errors, or proof of bugs.</big></p>


<p style="margin-left:11%; margin-top: 1em"><b>VALGRIND</b>
<big><br>
Valgrind has a special section here because it is a popular
tool that is highly useful. Unfortunately, valgrind reports
are very hard to interpret.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>If you
think you found a bug (memory leak, uninitialised data
access etc.) in libev, then check twice: If valgrind reports
something like:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>==2274==
definitely lost: 0 bytes in 0 blocks. <br>
==2274== possibly lost: 0 bytes in 0 blocks. <br>
==2274== still reachable: 256 bytes in 1 blocks.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Then there
is no memory leak, just as memory accounted to global
variables is not a memleak &minus; the memory is still being
referenced, and didn&rsquo;t leak.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>Similarly,
under some circumstances, valgrind might report kernel bugs
as if it were a bug in libev (e.g. in realloc or in the poll
backend, although an acceptable workaround has been found
here), or it might be confused.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Keep in
mind that valgrind is a very good tool, but only a tool.
Don&rsquo;t make it into some kind of religion.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>If you are
unsure about something, feel free to contact the mailing
list with the full valgrind report and an explanation on why
you think this is a bug in libev (best check the archives,
too :). However, don&rsquo;t be annoyed when you get a brisk
&quot;this is no bug&quot; answer and take the chance of
learning how to interpret valgrind properly.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>If you
need, for some reason, empty reports from valgrind for your
project I suggest using suppression lists.</big></p>

<h2>PORTABILITY NOTES
<a name="PORTABILITY NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>GNU/LINUX 32
BIT LIMITATIONS</b> <big><br>
GNU/Linux is the only common platform that supports 64 bit
file/large file interfaces but <i>disables</i> them by
default.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>That means
that libev compiled in the default environment doesn&rsquo;t
support files larger than 2GiB or so, which mainly affects
&quot;ev_stat&quot; watchers.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>Unfortunately,
many programs try to work around this GNU/Linux issue by
enabling the large file</big> API, <big>which makes them
incompatible with the standard libev compiled for their
system.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Likewise,
libev cannot enable the large file</big> API <big>itself as
this would suddenly make it incompatible to the default
compile time environment, i.e. all programs not using
special compile switches.</big></p>

<p style="margin-left:11%; margin-top: 1em"><b>OS/X AND
DARWIN BUGS</b> <big><br>
The whole thing is a bug if you ask me &minus; basically any
system interface you touch is broken, whether it is locales,
poll, kqueue or even the OpenGL drivers.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><i>&quot;kqueue&quot;
is buggy</i></big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The kqueue
syscall is broken in all known versions &minus; most
versions support only sockets, many support pipes.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Libev
tries to work around this by not using &quot;kqueue&quot; by
default on this rotten platform, but of course you can still
ask for it when creating a loop &minus; embedding a
socket-only kqueue loop into a select-based one is probably
going to work well.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><i>&quot;poll&quot;
is buggy</i></big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Instead of
fixing &quot;kqueue&quot;, Apple replaced their (working)
&quot;poll&quot; implementation by something calling
&quot;kqueue&quot; internally around the 10.5.6 release, so
now &quot;kqueue&quot; <i>and</i> &quot;poll&quot; are
broken.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Libev
tries to work around this by not using &quot;poll&quot; by
default on this rotten platform, but of course you can still
ask for it when creating a loop.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><i>&quot;select&quot;
is buggy</i></big></p>

<p style="margin-left:11%; margin-top: 1em"><big>All
that&rsquo;s left is &quot;select&quot;, and of course Apple
found a way to fuck this one up as well: On</big> OS/X,
<big>&quot;select&quot; actively limits the number of file
descriptors you can pass in to 1024 &minus; your program
suddenly crashes when you use more.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>There is
an undocumented &quot;workaround&quot; for this &minus;
defining &quot;_DARWIN_UNLIMITED_SELECT&quot;, which libev
tries to use, so select <i>should</i> work on</big>
OS/X.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SOLARIS
PROBLEMS AND WORKAROUNDS</b> <i><big><br>
&quot;errno&quot; reentrancy</big></i></p>

<p style="margin-left:11%; margin-top: 1em"><big>The
default compile environment on Solaris is unfortunately so
thread-unsafe that you can&rsquo;t even use
components/libraries compiled without
&quot;&minus;D_REENTRANT&quot; in a threaded program, which,
of course, isn&rsquo;t defined by default. A valid, if
stupid, implementation choice.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>If you
want to use libev in threaded environments you have to make
sure it&rsquo;s compiled with &quot;_REENTRANT&quot;
defined.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big><i>Event
port backend</i></big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The
scalable event interface for Solaris is called &quot;event
ports&quot;. Unfortunately, this mechanism is very buggy in
all major releases. If you run into high</big> CPU
<big>usage, your program freezes or you get a large number
of spurious wakeups, make sure you have all the relevant and
latest kernel patches applied. No, I don&rsquo;t know which
ones, but there are multiple ones to apply, and afterwards,
event ports actually work great.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>If you
can&rsquo;t get it to work, you can try running the program
by setting the environment variable
&quot;LIBEV_FLAGS=3&quot; to only allow &quot;poll&quot; and
&quot;select&quot; backends.</big></p>

<p style="margin-left:11%; margin-top: 1em"><b>AIX POLL
BUG</b> <br>
AIX <big>unfortunately has a broken &quot;poll.h&quot;
header. Libev works around this by trying to avoid the poll
backend altogether (i.e. it&rsquo;s not even compiled in),
which normally isn&rsquo;t a big problem as
&quot;select&quot; works fine with large bitsets on</big>
AIX, <big>and</big> AIX <big>is dead anyway.</big></p>

<p style="margin-left:11%; margin-top: 1em"><b>WIN32
PLATFORM LIMITATIONS AND WORKAROUNDS</b> <i><big><br>
General issues</big></i></p>

<p style="margin-left:11%; margin-top: 1em"><big>Win32
doesn&rsquo;t support any of the standards (e.g.</big> POSIX
<big>) that libev requires, and its I/O model is
fundamentally incompatible with the</big> POSIX <big>model.
Libev still offers limited functionality on this platform in
the form of the &quot;EVBACKEND_SELECT&quot; backend, and
only supports socket descriptors. This only applies when
using Win32 natively, not when using e.g. cygwin. Actually,
it only applies to the microsofts own compilers, as every
compiler comes with a slightly differently
broken/incompatible environment.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Lifting
these limitations would basically require the full
re-implementation of the I/O system. If you are into this
kind of thing, then note that glib does exactly that for you
in a very portable way (note also that glib is the slowest
event library known to man).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>There is
no supported compilation method available on windows except
embedding it into other applications.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Sensible
signal handling is officially unsupported by Microsoft
&minus; libev tries its best, but under most conditions,
signals will simply not work.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Not a
libev limitation but worth mentioning: windows apparently
doesn&rsquo;t accept large writes: instead of resulting in a
partial write, windows will either accept everything or
return &quot;ENOBUFS&quot; if the buffer is too large, so
make sure you only write small amounts into your sockets
(less than a megabyte seems safe, but this apparently
depends on the amount of memory available).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Due to the
many, low, and arbitrary limits on the win32 platform and
the abysmal performance of winsockets, using a large number
of sockets is not recommended (and not reasonable). If your
program needs to use more than a hundred or so sockets, then
likely it needs to use a totally different implementation
for windows, as libev offers the</big> POSIX <big>readiness
notification model, which cannot be implemented efficiently
on windows (due to Microsoft monopoly games).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>A typical
way to use libev under windows is to embed it (see the
embedding section for details) and use the following
<i>evwrap.h</i> header file instead of
<i>ev.h</i>:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#define
EV_STANDALONE /* keeps ev from requiring config.h */ <br>
#define EV_SELECT_IS_WINSOCKET 1 /* configure libev for
windows select */ <br>
#include &quot;ev.h&quot;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>And
compile the following <i>evwrap.c</i> file into your project
(make sure you do <i>not</i> compile the <i>ev.c</i> or any
other embedded source files!):</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#include
&quot;evwrap.h&quot; <br>
#include &quot;ev.c&quot;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big><i>The
winsocket &quot;select&quot; function</i></big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The
winsocket &quot;select&quot; function doesn&rsquo;t
follow</big> POSIX <big>in that it requires socket
<i>handles</i> and not socket <i>file descriptors</i> (it is
also extremely buggy). This makes select very inefficient,
and also requires a mapping from file descriptors to socket
handles (the Microsoft C runtime provides the function
&quot;_open_osfhandle&quot; for this). See the discussion of
the &quot;EV_SELECT_USE_FD_SET&quot;,
&quot;EV_SELECT_IS_WINSOCKET&quot; and
&quot;EV_FD_TO_WIN32_HANDLE&quot; preprocessor symbols for
more info.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The
configuration for a &quot;naked&quot; win32 using the
Microsoft runtime libraries and raw winsocket select
is:</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>#define
EV_USE_SELECT 1 <br>
#define EV_SELECT_IS_WINSOCKET 1 /* forces
EV_SELECT_USE_FD_SET, too */</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Note that
winsockets handling of fd sets is O(n), so you can easily
get a complexity in the O(nX) range when using
win32.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><i>Limited
number of file descriptors</i></big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Windows
has numerous arbitrary (and low) limits on things.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Early
versions of winsocket&rsquo;s select only supported waiting
for a maximum of 64 handles (probably owning to the fact
that all windows kernels can only wait for 64 things at the
same time internally; Microsoft recommends spawning a chain
of threads and wait for 63 handles and the previous thread
in each. Sounds great!).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Newer
versions support more handles, but you need to define
&quot;FD_SETSIZE&quot; to some high number (e.g. 2048)
before compiling the winsocket select call (which might be
in libev or elsewhere, for example, perl and many other
interpreters do their own select emulation on
windows).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Another
limit is the number of file descriptors in the Microsoft
runtime libraries, which by default is 64 (there must be a
hidden <i>64</i> fetish or something like this inside
Microsoft). You can increase this by calling
&quot;_setmaxstdio&quot;, which can increase this limit to
2048 (another arbitrary limit), but is broken in many
versions of the Microsoft runtime libraries. This might get
you to about 512 or 2048 sockets (depending on windows
version and/or the phase of the moon). To get more, you need
to wrap all I/O functions and provide your own fd
management, but the cost of calling select (O(nX)) will
likely make this unworkable.</big></p>

<p style="margin-left:11%; margin-top: 1em"><b>PORTABILITY
REQUIREMENTS</b> <big><br>
In addition to a working ISO-C implementation and of course
the backend-specific APIs, libev relies on a few additional
extensions: <br>
&quot;void (*)(ev_watcher_type *, int revents)&quot; must
have compatible calling <br>
conventions regardless of &quot;ev_watcher_type
*&quot;.</big></p>

<p style="margin-left:17%;"><big>Libev assumes not only
that all watcher pointers have the same internal structure
(guaranteed by</big> POSIX <big>but not by</big> ISO C
<big>for example), but it also assumes that the same
(machine) code can be used to call any watcher callback: The
watcher callbacks have different type signatures, but libev
calls them using an &quot;ev_watcher *&quot;
internally.</big></p>

<p style="margin-left:11%;"><big>null pointers and integer
zero are represented by 0 bytes</big></p>

<p style="margin-left:17%;"><big>Libev uses
&quot;memset&quot; to initialise structs and arrays to 0
bytes, and relies on this setting pointers and integers to
null.</big></p>

<p style="margin-left:11%;"><big>pointer accesses must be
thread-atomic</big></p>

<p style="margin-left:17%;"><big>Accessing a pointer value
must be atomic, it must both be readable and writable in one
piece &minus; this is the case on all current
architectures.</big></p>

<p style="margin-left:11%;"><big>&quot;sig_atomic_t
volatile&quot; must be thread-atomic as well</big></p>

<p style="margin-left:17%;"><big>The type
&quot;sig_atomic_t volatile&quot; (or whatever is defined as
&quot;EV_ATOMIC_T&quot;) must be atomic with respect to
accesses from different threads. This is not part of the
specification for &quot;sig_atomic_t&quot;, but is believed
to be sufficiently portable.</big></p>

<p style="margin-left:11%;"><big>&quot;sigprocmask&quot;
must work in a threaded environment</big></p>

<p style="margin-left:17%;"><big>Libev uses
&quot;sigprocmask&quot; to temporarily block signals. This
is not allowed in a threaded program
(&quot;pthread_sigmask&quot; has to be used). Typical
pthread implementations will either allow
&quot;sigprocmask&quot; in the &quot;main thread&quot; or
will block signals process-wide, both behaviours would be
compatible with libev. Interaction between
&quot;sigprocmask&quot; and &quot;pthread_sigmask&quot;
could complicate things, however.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>The most
portable way to handle signals is to block signals in all
threads except the initial one, and run the signal handling
loop in the initial thread as well.</big></p>

<p style="margin-left:11%;"><big>&quot;long&quot; must be
large enough for common memory allocation sizes</big></p>

<p style="margin-left:17%;"><big>To improve portability and
simplify its</big> API, <big>libev uses &quot;long&quot;
internally instead of &quot;size_t&quot; when allocating its
data structures. On non-POSIX systems (Microsoft...) this
might be unexpectedly low, but is still at least 31 bits
everywhere, which is enough for hundreds of millions of
watchers.</big></p>

<p style="margin-left:11%;"><big>&quot;double&quot; must
hold a time value in seconds with enough accuracy</big></p>

<p style="margin-left:17%;"><big>The type
&quot;double&quot; is used to represent timestamps. It is
required to have at least 51 bits of mantissa (and 9 bits of
exponent), which is good enough for at least into the year
4000 with millisecond accuracy (the design goal for libev).
This requirement is overfulfilled by implementations
using</big> IEEE 754, <big>which is basically all existing
ones.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>With</big>
IEEE 754 <big>doubles, you get microsecond accuracy until at
least the year 2255 (and millisecond accuracy till the year
287396 &minus; by then, libev is either obsolete or somebody
patched it to use &quot;long double&quot; or something like
that, just kidding).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>If you
know of other additional requirements drop me a
note.</big></p>

<h2>ALGORITHMIC COMPLEXITIES
<a name="ALGORITHMIC COMPLEXITIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big>In this
section the complexities of (many of) the algorithms used
inside libev will be documented. For complexity discussions
about backends see the documentation for
&quot;ev_default_init&quot;.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>All of the
following are about amortised time: If an array needs to be
extended, libev needs to realloc and move the whole array,
but this happens asymptotically rarer with higher number of
elements, so O(1) might mean that libev does a lengthy
realloc operation in rare cases, but on average it is much
faster and asymptotically approaches constant time. <br>
Starting and stopping timer/periodic watchers: O(log <br>
skipped_other_timers)</big></p>

<p style="margin-left:17%;"><big>This means that, when you
have a watcher that triggers in one hour and there are 100
watchers that would trigger before that, then inserting will
have to skip roughly seven (&quot;ld 100&quot;) of these
watchers.</big></p>

<p style="margin-left:11%;"><big>Changing timer/periodic
watchers (by autorepeat or calling again): <br>
O(log skipped_other_timers)</big></p>

<p style="margin-left:17%;"><big>That means that changing a
timer costs less than removing/adding them, as only the
relative motion in the event queue has to be paid
for.</big></p>

<p style="margin-left:11%;"><big>Starting
io/check/prepare/idle/signal/child/fork/async watchers:
O(1)</big></p>

<p style="margin-left:17%;"><big>These just add the watcher
into an array or at the head of a list.</big></p>

<p style="margin-left:11%;"><big>Stopping
check/prepare/idle/fork/async watchers: O(1) <br>
Stopping an io/signal/child watcher: <br>
O(number_of_watchers_for_this_(fd/signal/pid %</big>
EV_PID_HASHSIZE <big>))</big></p>

<p style="margin-left:17%;"><big>These watchers are stored
in lists, so they need to be walked to find the correct
watcher to remove. The lists are usually short (you
don&rsquo;t usually have many watchers waiting for the same
fd or signal: one is typical, two is rare).</big></p>

<p style="margin-left:11%;"><big>Finding the next timer in
each loop iteration: O(1)</big></p>

<p style="margin-left:17%;"><big>By virtue of using a
binary or 4&minus;heap, the next timer is always found at a
fixed position in the storage array.</big></p>

<p style="margin-left:11%;"><big>Each change on a file
descriptor per loop iteration: <br>
O(number_of_watchers_for_this_fd)</big></p>

<p style="margin-left:17%;"><big>A change means an I/O
watcher gets started or stopped, which requires libev to
recalculate its status (and possibly tell the kernel,
depending on backend and whether &quot;ev_io_set&quot; was
used).</big></p>

<p style="margin-left:11%;"><big>Activating one watcher
(putting it into the pending state): O(1) <br>
Priority handling: O(number_of_priorities)</big></p>

<p style="margin-left:17%;"><big>Priorities are implemented
by allocating some space for each priority. When doing
priority-based operations, libev usually has to linearly
search all the priorities, but starting/stopping and
activating watchers becomes O(1) with respect to priority
handling.</big></p>

<p style="margin-left:11%;"><big>Sending an ev_async: O(1)
<br>
Processing ev_async_send: O(number_of_async_watchers) <br>
Processing signals: O(max_signal_number)</big></p>

<p style="margin-left:17%;"><big>Sending involves a system
call <i>iff</i> there were no other
&quot;ev_async_send&quot; calls in the current loop
iteration and the loop is currently blocked. Checking for
async and signal events involves iterating over all running
async watchers or all signal numbers.</big></p>

<h2>PORTING FROM LIBEV 3.X TO 4.X
<a name="PORTING FROM LIBEV 3.X TO 4.X"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big>The major
version 4 introduced some incompatible changes to the</big>
API.</p>

<p style="margin-left:11%; margin-top: 1em"><big>At the
moment, the &quot;ev.h&quot; header file provides
compatibility definitions for all changes, so most programs
should still compile. The compatibility layer might be
removed in later versions of libev, so better update to the
new</big> API <big>early than late. <br>
&quot;EV_COMPAT3&quot; backwards compatibility
mechanism</big></p>

<p style="margin-left:17%;"><big>The backward compatibility
mechanism can be controlled by &quot;EV_COMPAT3&quot;. See
&quot;</big> PREPROCESSOR SYMBOLS/MACROS&quot; <big>in the
&quot;</big> EMBEDDING&quot; <big>section.</big></p>


<p style="margin-left:11%;"><big>&quot;ev_default_destroy&quot;
and &quot;ev_default_fork&quot; have been removed</big></p>

<p style="margin-left:17%;"><big>These calls can be
replaced easily by their &quot;ev_loop_xxx&quot;
counterparts:</big></p>


<p style="margin-left:17%; margin-top: 1em"><big>ev_loop_destroy
(EV_DEFAULT_UC); <br>
ev_loop_fork (EV_DEFAULT);</big></p>

<p style="margin-left:11%;"><big>function/symbol
renames</big></p>

<p style="margin-left:17%;"><big>A number of functions and
symbols have been renamed:</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>ev_loop
=&gt; ev_run <br>
EVLOOP_NONBLOCK =&gt; EVRUN_NOWAIT <br>
EVLOOP_ONESHOT =&gt; EVRUN_ONCE <br>
ev_unloop =&gt; ev_break <br>
EVUNLOOP_CANCEL =&gt; EVBREAK_CANCEL <br>
EVUNLOOP_ONE =&gt; EVBREAK_ONE <br>
EVUNLOOP_ALL =&gt; EVBREAK_ALL <br>
EV_TIMEOUT =&gt; EV_TIMER <br>
ev_loop_count =&gt; ev_iteration <br>
ev_loop_depth =&gt; ev_depth <br>
ev_loop_verify =&gt; ev_verify</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>Most
functions working on &quot;struct ev_loop&quot; objects
don&rsquo;t have an &quot;ev_loop_&quot; prefix, so it was
removed; &quot;ev_loop&quot;, &quot;ev_unloop&quot; and
associated constants have been renamed to not collide with
the &quot;struct ev_loop&quot; anymore and
&quot;EV_TIMER&quot; now follows the same naming scheme as
all other watcher types. Note that &quot;ev_loop_fork&quot;
is still called &quot;ev_loop_fork&quot; because it would
otherwise clash with the &quot;ev_fork&quot;
typedef.</big></p>

<p style="margin-left:11%;"><big>&quot;EV_MINIMAL&quot;
mechanism replaced by &quot;EV_FEATURES&quot;</big></p>

<p style="margin-left:17%;"><big>The preprocessor symbol
&quot;EV_MINIMAL&quot; has been replaced by a different
mechanism, &quot;EV_FEATURES&quot;. Programs using
&quot;EV_MINIMAL&quot; usually compile and work, but the
library code will of course be larger.</big></p>

<h2>GLOSSARY
<a name="GLOSSARY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big>active</big></p>

<p style="margin-left:17%;"><big>A watcher is active as
long as it has been started and not yet stopped. See
&quot;</big> WATCHER STATES&quot; <big>for
details.</big></p>

<p style="margin-left:11%;"><big>application</big></p>

<p style="margin-left:17%;"><big>In this document, an
application is whatever is using libev.</big></p>

<p style="margin-left:11%;"><big>backend</big></p>

<p style="margin-left:17%;"><big>The part of the code
dealing with the operating system interfaces.</big></p>

<p style="margin-left:11%;"><big>callback</big></p>

<p style="margin-left:17%;"><big>The address of a function
that is called when some event has been detected. Callbacks
are being passed the event loop, the watcher that received
the event, and the actual event bitset.</big></p>

<p style="margin-left:11%;"><big>callback/watcher
invocation</big></p>

<p style="margin-left:17%;"><big>The act of calling the
callback associated with a watcher.</big></p>

<p style="margin-left:11%;"><big>event</big></p>

<p style="margin-left:17%;"><big>A change of state of some
external event, such as data now being available for reading
on a file descriptor, time having passed or simply not
having any other events happening anymore.</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>In libev,
events are represented as single bits (such as
&quot;EV_READ&quot; or &quot;EV_TIMER&quot;).</big></p>

<p style="margin-left:11%;"><big>event library</big></p>

<p style="margin-left:17%;"><big>A software package
implementing an event model and loop.</big></p>

<p style="margin-left:11%;"><big>event loop</big></p>

<p style="margin-left:17%;"><big>An entity that handles and
processes external events and converts them into callback
invocations.</big></p>

<p style="margin-left:11%;"><big>event model</big></p>

<p style="margin-left:17%;"><big>The model used to describe
how an event loop handles and processes watchers and
events.</big></p>

<p style="margin-left:11%;"><big>pending</big></p>

<p style="margin-left:17%;"><big>A watcher is pending as
soon as the corresponding event has been detected. See
&quot;</big> WATCHER STATES&quot; <big>for
details.</big></p>

<p style="margin-left:11%;"><big>real time</big></p>

<p style="margin-left:17%;"><big>The physical time that is
observed. It is apparently strictly monotonic :)</big></p>

<p style="margin-left:11%;"><big>wall-clock time</big></p>

<p style="margin-left:17%;"><big>The time and date as shown
on clocks. Unlike real time, it can actually be wrong and
jump forwards and backwards, e.g. when you adjust your
clock.</big></p>

<p style="margin-left:11%;"><big>watcher</big></p>

<p style="margin-left:17%;"><big>A data structure that
describes interest in certain events. Watchers need to be
started (attached to an event loop) before they can receive
events.</big></p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><big>Marc
Lehmann &lt;libev@schmorp.de&gt;, with repeated corrections
by Mikael Magnusson and Emanuele Giaquinta, and minor
corrections by many others.</big></p>
<hr>
</body>
</html>
