<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:10 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::__debug</title>

</head>
<body>
<h1>std::__debug</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">std::__debug
&minus; GNU debug code, replaces standard behavior with
debug behavior.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">class <b>bitset</b> <br>
Class std::bitset with additional safety/checking/debug
instrumentation. <br>
class <b>deque</b> <br>
Class std::deque with safety/checking/debug instrumentation.
<br>
class <b>forward_list</b> <br>
Class std::forward_list with safety/checking/debug
instrumentation. <br>
class <b>list</b> <br>
Class std::list with safety/checking/debug instrumentation.
<br>
class <b>map</b> <br>
Class std::map with safety/checking/debug instrumentation.
<br>
class <b>multimap</b> <br>
Class std::multimap with safety/checking/debug
instrumentation. <br>
class <b>multiset</b> <br>
Class std::multiset with safety/checking/debug
instrumentation. <br>
class <b>set</b> <br>
Class std::set with safety/checking/debug instrumentation.
<br>
class <b>unordered_map</b> <br>
Class std::unordered_map with safety/checking/debug
instrumentation. <br>
class <b>unordered_multimap</b> <br>
Class std::unordered_multimap with safety/checking/debug
instrumentation. <br>
class <b>unordered_multiset</b> <br>
Class std::unordered_multiset with safety/checking/debug
instrumentation. <br>
class <b>unordered_set</b> <br>
Class std::unordered_set with safety/checking/debug
instrumentation. <br>
class <b>vector</b> <br>
Class std::vector with safety/checking/debug
instrumentation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;">template&lt;typename
_InputIterator , typename _ValT = typename
iterator_traits&lt;_InputIterator&gt;::value_type, typename
_Allocator = allocator&lt;_ValT&gt;, typename =
_RequireInputIter&lt;_InputIterator&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>deque</b>
(_InputIterator, _InputIterator, _Allocator=_Allocator())
&minus;&gt; <b>deque</b>&lt; _ValT, _Allocator &gt; <br>
template&lt;typename _Tp , typename _Allocator =
allocator&lt;_Tp&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>deque</b>
(size_t, _Tp, _Allocator=_Allocator()) &minus;&gt;
<b>deque</b>&lt; _Tp, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _ValT =
typename iterator_traits&lt;_InputIterator&gt;::value_type,
typename _Allocator = allocator&lt;_ValT&gt;, typename =
_RequireInputIter&lt;_InputIterator&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>forward_list</b>
(_InputIterator, _InputIterator, _Allocator=_Allocator())
&minus;&gt; <b>forward_list</b>&lt; _ValT, _Allocator &gt;
<br>
template&lt;typename _Tp , typename _Allocator =
allocator&lt;_Tp&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>forward_list</b>
(size_t, _Tp, _Allocator=_Allocator()) &minus;&gt;
<b>forward_list</b>&lt; _Tp, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _ValT =
typename iterator_traits&lt;_InputIterator&gt;::value_type,
typename _Allocator = allocator&lt;_ValT&gt;, typename =
_RequireInputIter&lt;_InputIterator&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>list</b>
(_InputIterator, _InputIterator, _Allocator=_Allocator())
&minus;&gt; <b>list</b>&lt; _ValT, _Allocator &gt; <br>
template&lt;typename _Tp , typename _Allocator =
allocator&lt;_Tp&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>list</b> (size_t,
_Tp, _Allocator=_Allocator()) &minus;&gt; <b>list</b>&lt;
_Tp, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt; <b>map</b>
(_InputIterator, _InputIterator, _Allocator) &minus;&gt;
<b>map</b>&lt; __iter_key_t&lt; _InputIterator &gt;,
__iter_val_t&lt; _InputIterator &gt;, <b>less</b>&lt;
__iter_key_t&lt; _InputIterator &gt; &gt;, _Allocator &gt;
<br>
template&lt;typename _InputIterator , typename _Compare =
less&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, typename
_Allocator =
allocator&lt;__iter_to_alloc_t&lt;_InputIterator&gt;&gt;,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireNotAllocator&lt;_Compare&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>map</b>
(_InputIterator, _InputIterator, _Compare=_Compare(),
_Allocator=_Allocator()) &minus;&gt; <b>map</b>&lt;
__iter_key_t&lt; _InputIterator &gt;, __iter_val_t&lt;
_InputIterator &gt;, _Compare, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename
_Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>map</b>
(<b>initializer_list</b>&lt; <b>pair</b>&lt; _Key, _Tp &gt;
&gt;, _Allocator) &minus;&gt; <b>map</b>&lt; _Key, _Tp,
<b>less</b>&lt; _Key &gt;, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename _Compare
= less&lt;_Key&gt;, typename _Allocator =
allocator&lt;pair&lt;const _Key, _Tp&gt;&gt;, typename =
_RequireNotAllocator&lt;_Compare&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>map</b>
(<b>initializer_list</b>&lt; <b>pair</b>&lt; _Key, _Tp &gt;
&gt;, _Compare=_Compare(), _Allocator=_Allocator())
&minus;&gt; <b>map</b>&lt; _Key, _Tp, _Compare, _Allocator
&gt; <br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt; <b>multimap</b>
(_InputIterator, _InputIterator, _Allocator) &minus;&gt;
<b>multimap</b>&lt; __iter_key_t&lt; _InputIterator &gt;,
__iter_val_t&lt; _InputIterator &gt;, <b>less</b>&lt;
__iter_key_t&lt; _InputIterator &gt; &gt;, _Allocator &gt;
<br>
template&lt;typename _InputIterator , typename _Compare =
less&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, typename
_Allocator =
allocator&lt;__iter_to_alloc_t&lt;_InputIterator&gt;&gt;,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireNotAllocator&lt;_Compare&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>multimap</b>
(_InputIterator, _InputIterator, _Compare=_Compare(),
_Allocator=_Allocator()) &minus;&gt; <b>multimap</b>&lt;
__iter_key_t&lt; _InputIterator &gt;, __iter_val_t&lt;
_InputIterator &gt;, _Compare, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename
_Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>multimap</b>
(<b>initializer_list</b>&lt; <b>pair</b>&lt; _Key, _Tp &gt;
&gt;, _Allocator) &minus;&gt; <b>multimap</b>&lt; _Key, _Tp,
<b>less</b>&lt; _Key &gt;, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename _Compare
= less&lt;_Key&gt;, typename _Allocator =
allocator&lt;pair&lt;const _Key, _Tp&gt;&gt;, typename =
_RequireNotAllocator&lt;_Compare&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>multimap</b>
(<b>initializer_list</b>&lt; <b>pair</b>&lt; _Key, _Tp &gt;
&gt;, _Compare=_Compare(), _Allocator=_Allocator())
&minus;&gt; <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt; <b>multiset</b>
(_InputIterator, _InputIterator, _Allocator) &minus;&gt;
<b>multiset</b>&lt; typename <b>iterator_traits</b>&lt;
_InputIterator &gt;::value_type, <b>less</b>&lt; typename
<b>iterator_traits</b>&lt; _InputIterator &gt;::value_type
&gt;, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Compare =
less&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename _Allocator = allocator&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireNotAllocator&lt;_Compare&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>multiset</b>
(_InputIterator, _InputIterator, _Compare=_Compare(),
_Allocator=_Allocator()) &minus;&gt; <b>multiset</b>&lt;
typename <b>iterator_traits</b>&lt; _InputIterator
&gt;::value_type, _Compare, _Allocator &gt; <br>
template&lt;typename _Key , typename _Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>multiset</b>
(<b>initializer_list</b>&lt; _Key &gt;, _Allocator)
&minus;&gt; <b>multiset</b>&lt; _Key, <b>less</b>&lt; _Key
&gt;, _Allocator &gt; <br>
template&lt;typename _Key , typename _Compare =
less&lt;_Key&gt;, typename _Allocator =
allocator&lt;_Key&gt;, typename =
_RequireNotAllocator&lt;_Compare&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>multiset</b>
(<b>initializer_list</b>&lt; _Key &gt;, _Compare=_Compare(),
_Allocator=_Allocator()) &minus;&gt; <b>multiset</b>&lt;
_Key, _Compare, _Allocator &gt; <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator!=</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator!=</b> (const <b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__ly) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator!=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator!=</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator!=</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator!=</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator!=</b> (const <b>set</b>&lt;
_Key, _Compare, _Allocator &gt; &amp;__lhs, const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__rhs)
<br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator!=</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;size_t _Nb&gt; constexpr <b>bitset</b>&lt; _Nb
&gt; <b>operator&amp;</b> (const <b>bitset</b>&lt; _Nb &gt;
&amp;__x, const <b>bitset</b>&lt; _Nb &gt; &amp;__y)
noexcept <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;</b> (const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__ly) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&lt;</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&lt;</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&lt;</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&lt;</b> (const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__lhs,
const <b>set</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;</b> (const <b>vector</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , size_t
_Nb&gt; <b>std::basic_ostream</b>&lt; _CharT, _Traits &gt;
&amp; <b>operator&lt;&lt;</b> (<b>std::basic_ostream</b>&lt;
_CharT, _Traits &gt; &amp;__os, const <b>bitset</b>&lt; _Nb
&gt; &amp;__x) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;=</b> (const <b>deque</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;=</b> (const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__ly) <br>
Based on operator&lt;. <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&lt;=</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&lt;=</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__lhs,
const <b>set</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&lt;=</b> (const <b>vector</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator==</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator==</b> (const <b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__ly) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator==</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator==</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator==</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator==</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator==</b> (const <b>set</b>&lt;
_Key, _Compare, _Allocator &gt; &amp;__lhs, const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__rhs)
<br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; bool <b>operator==</b>
(const <b>unordered_map</b>&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__x, const <b>unordered_map</b>&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; bool <b>operator==</b>
(const <b>unordered_multimap</b>&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt; &amp;__x, const
<b>unordered_multimap</b>&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__y) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; bool <b>operator==</b> (const
<b>unordered_multiset</b>&lt; _Value, _Hash, _Pred, _Alloc
&gt; &amp;__x, const <b>unordered_multiset</b>&lt; _Value,
_Hash, _Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; bool <b>operator==</b> (const
<b>unordered_set</b>&lt; _Value, _Hash, _Pred, _Alloc &gt;
&amp;__x, const <b>unordered_set</b>&lt; _Value, _Hash,
_Pred, _Alloc &gt; &amp;__y) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator==</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;</b> (const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__ly) <br>
Based on operator&lt;. <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&gt;</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&gt;</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&gt;</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&gt;</b> (const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__lhs,
const <b>set</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;</b> (const <b>vector</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;=</b> (const <b>deque</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;=</b> (const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__lx, const <b>forward_list</b>&lt; _Tp,
_Alloc &gt; &amp;__ly) <br>
Based on operator&lt;. <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__lhs, const <b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&gt;=</b> (const
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>map</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; bool <b>operator&gt;=</b> (const
<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const
<b>multiset</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__lhs, const <b>multiset</b>&lt; _Key, _Compare,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const
<b>set</b>&lt; _Key, _Compare, _Allocator &gt; &amp;__lhs,
const <b>set</b>&lt; _Key, _Compare, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _Tp , typename _Alloc &gt; bool
<b>operator&gt;=</b> (const <b>vector</b>&lt; _Tp, _Alloc
&gt; &amp;__lhs, const <b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , size_t
_Nb&gt; <b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp; <b>operator&gt;&gt;</b> (<b>std::basic_istream</b>&lt;
_CharT, _Traits &gt; &amp;__is, <b>bitset</b>&lt; _Nb &gt;
&amp;__x) <br>
template&lt;size_t _Nb&gt; constexpr <b>bitset</b>&lt; _Nb
&gt; <b>operator^</b> (const <b>bitset</b>&lt; _Nb &gt;
&amp;__x, const <b>bitset</b>&lt; _Nb &gt; &amp;__y)
noexcept <br>
template&lt;size_t _Nb&gt; constexpr <b>bitset</b>&lt; _Nb
&gt; <b>operator|</b> (const <b>bitset</b>&lt; _Nb &gt;
&amp;__x, const <b>bitset</b>&lt; _Nb &gt; &amp;__y)
noexcept <br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt; <b>set</b>
(_InputIterator, _InputIterator, _Allocator) &minus;&gt;
<b>set</b>&lt; typename <b>iterator_traits</b>&lt;
_InputIterator &gt;::value_type, <b>less</b>&lt; typename
<b>iterator_traits</b>&lt; _InputIterator &gt;::value_type
&gt;, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Compare =
less&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename _Allocator = allocator&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireNotAllocator&lt;_Compare&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>set</b>
(_InputIterator, _InputIterator, _Compare=_Compare(),
_Allocator=_Allocator()) &minus;&gt; <b>set</b>&lt; typename
<b>iterator_traits</b>&lt; _InputIterator &gt;::value_type,
_Compare, _Allocator &gt; <br>
template&lt;typename _Key , typename _Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>set</b>
(<b>initializer_list</b>&lt; _Key &gt;, _Allocator)
&minus;&gt; <b>set</b>&lt; _Key, <b>less</b>&lt; _Key &gt;,
_Allocator &gt; <br>
template&lt;typename _Key , typename _Compare =
less&lt;_Key&gt;, typename _Allocator =
allocator&lt;_Key&gt;, typename =
_RequireNotAllocator&lt;_Compare&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>set</b>
(<b>initializer_list</b>&lt; _Key &gt;, _Compare=_Compare(),
_Allocator=_Allocator()) &minus;&gt; <b>set</b>&lt; _Key,
_Compare, _Allocator &gt; <br>
template&lt;typename _Tp , typename _Alloc &gt; void
<b>swap</b> (<b>deque</b>&lt; _Tp, _Alloc &gt; &amp;__lhs,
<b>deque</b>&lt; _Tp, _Alloc &gt; &amp;__rhs)
noexcept(/*<b>conditional</b> */) <br>
template&lt;typename _Tp , typename _Alloc &gt; void
<b>swap</b> (<b>forward_list</b>&lt; _Tp, _Alloc &gt;
&amp;__lx, <b>forward_list</b>&lt; _Tp, _Alloc &gt;
&amp;__ly) noexcept(noexcept(__lx.swap(__ly))) <br>
See std::forward_list::swap(). <br>
template&lt;typename _Tp , typename _Alloc &gt; void
<b>swap</b> (<b>list</b>&lt; _Tp, _Alloc &gt; &amp;__lhs,
<b>list</b>&lt; _Tp, _Alloc &gt; &amp;__rhs)
noexcept(/*<b>conditional</b> */) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; void <b>swap</b> (<b>map</b>&lt;
_Key, _Tp, _Compare, _Allocator &gt; &amp;__lhs,
<b>map</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__rhs) noexcept(/*<b>conditional</b> */) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Allocator &gt; void <b>swap</b>
(<b>multimap</b>&lt; _Key, _Tp, _Compare, _Allocator &gt;
&amp;__lhs, <b>multimap</b>&lt; _Key, _Tp, _Compare,
_Allocator &gt; &amp;__rhs) noexcept(/*<b>conditional</b>
*/) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; void <b>swap</b> (<b>multiset</b>&lt; _Key,
_Compare, _Allocator &gt; &amp;__x, <b>multiset</b>&lt;
_Key, _Compare, _Allocator &gt; &amp;__y)
noexcept(/*<b>conditional</b> */) <br>
template&lt;typename _Key , typename _Compare , typename
_Allocator &gt; void <b>swap</b> (<b>set</b>&lt; _Key,
_Compare, _Allocator &gt; &amp;__x, <b>set</b>&lt; _Key,
_Compare, _Allocator &gt; &amp;__y)
noexcept(/*<b>conditional</b> */) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; void <b>swap</b>
(<b>unordered_map</b>&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt; &amp;__x, <b>unordered_map</b>&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt; &amp;__y)
noexcept(noexcept(__x.swap(__y))) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Pred , typename _Alloc &gt; void <b>swap</b>
(<b>unordered_multimap</b>&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp;__x, <b>unordered_multimap</b>&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt; &amp;__y)
noexcept(noexcept(__x.swap(__y))) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; void <b>swap</b>
(<b>unordered_multiset</b>&lt; _Value, _Hash, _Pred, _Alloc
&gt; &amp;__x, <b>unordered_multiset</b>&lt; _Value, _Hash,
_Pred, _Alloc &gt; &amp;__y)
noexcept(noexcept(__x.swap(__y))) <br>
template&lt;typename _Value , typename _Hash , typename
_Pred , typename _Alloc &gt; void <b>swap</b>
(<b>unordered_set</b>&lt; _Value, _Hash, _Pred, _Alloc &gt;
&amp;__x, <b>unordered_set</b>&lt; _Value, _Hash, _Pred,
_Alloc &gt; &amp;__y) noexcept(noexcept(__x.swap(__y))) <br>
template&lt;typename _Tp , typename _Alloc &gt; void
<b>swap</b> (<b>vector</b>&lt; _Tp, _Alloc &gt; &amp;__lhs,
<b>vector</b>&lt; _Tp, _Alloc &gt; &amp;__rhs)
noexcept(/*<b>conditional</b> */) <br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_map</b> (_InputIterator, _InputIterator,
_Allocator) &minus;&gt; <b>unordered_map</b>&lt;
__iter_key_t&lt; _InputIterator &gt;, __iter_val_t&lt;
_InputIterator &gt;, <b>hash</b>&lt; __iter_key_t&lt;
_InputIterator &gt; &gt;, <b>equal_to</b>&lt;
__iter_key_t&lt; _InputIterator &gt; &gt;, _Allocator &gt;
<br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_map</b> (_InputIterator, _InputIterator,
typename <b>unordered_map</b>&lt; int, int &gt;::size_type,
_Allocator) &minus;&gt; <b>unordered_map</b>&lt;
__iter_key_t&lt; _InputIterator &gt;, __iter_val_t&lt;
_InputIterator &gt;, <b>hash</b>&lt; __iter_key_t&lt;
_InputIterator &gt; &gt;, <b>equal_to</b>&lt;
__iter_key_t&lt; _InputIterator &gt; &gt;, _Allocator &gt;
<br>
template&lt;typename _InputIterator , typename _Hash ,
typename _Allocator , typename =
_RequireInputIter&lt;_InputIterator&gt;, typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b>
(_InputIterator, _InputIterator, typename
<b>unordered_map</b>&lt; int, int &gt;::size_type, _Hash,
_Allocator) &minus;&gt; <b>unordered_map</b>&lt;
__iter_key_t&lt; _InputIterator &gt;, __iter_val_t&lt;
_InputIterator &gt;, _Hash, <b>equal_to</b>&lt;
__iter_key_t&lt; _InputIterator &gt; &gt;, _Allocator &gt;
<br>
template&lt;typename _InputIterator , typename _Hash =
hash&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, typename
_Pred = equal_to&lt;__iter_key_t&lt;_InputIterator&gt;&gt;,
typename _Allocator =
allocator&lt;__iter_to_alloc_t&lt;_InputIterator&gt;&gt;,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireNotAllocator&lt;_Pred&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b>
(_InputIterator, _InputIterator, typename
<b>unordered_map</b>&lt; int, int &gt;::size_type={},
_Hash=_Hash(), _Pred=_Pred(), _Allocator=_Allocator())
&minus;&gt; <b>unordered_map</b>&lt; __iter_key_t&lt;
_InputIterator &gt;, __iter_val_t&lt; _InputIterator &gt;,
_Hash, _Pred, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename
_Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b>
(<b>initializer_list</b>&lt; <b>pair</b>&lt; _Key, _Tp &gt;
&gt;, _Allocator) &minus;&gt; <b>unordered_map</b>&lt; _Key,
_Tp, <b>hash</b>&lt; _Key &gt;, <b>equal_to</b>&lt; _Key
&gt;, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename
_Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b>
(<b>initializer_list</b>&lt; <b>pair</b>&lt; _Key, _Tp &gt;
&gt;, typename <b>unordered_map</b>&lt; int, int
&gt;::size_type, _Allocator) &minus;&gt;
<b>unordered_map</b>&lt; _Key, _Tp, <b>hash</b>&lt; _Key
&gt;, <b>equal_to</b>&lt; _Key &gt;, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Allocator , typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b>
(<b>initializer_list</b>&lt; <b>pair</b>&lt; _Key, _Tp &gt;
&gt;, typename <b>unordered_map</b>&lt; int, int
&gt;::size_type, _Hash, _Allocator) &minus;&gt;
<b>unordered_map</b>&lt; _Key, _Tp, _Hash,
<b>equal_to</b>&lt; _Key &gt;, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename _Hash =
hash&lt;_Key&gt;, typename _Pred = equal_to&lt;_Key&gt;,
typename _Allocator = allocator&lt;pair&lt;const _Key,
_Tp&gt;&gt;, typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireNotAllocator&lt;_Pred&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b>
(<b>initializer_list</b>&lt; <b>pair</b>&lt; _Key, _Tp &gt;
&gt;, typename <b>unordered_map</b>&lt; int, int
&gt;::size_type={}, _Hash=_Hash(), _Pred=_Pred(),
_Allocator=_Allocator()) &minus;&gt;
<b>unordered_map</b>&lt; _Key, _Tp, _Hash, _Pred, _Allocator
&gt; <br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multimap</b> (_InputIterator, _InputIterator,
_Allocator) &minus;&gt; <b>unordered_multimap</b>&lt;
__iter_key_t&lt; _InputIterator &gt;, __iter_val_t&lt;
_InputIterator &gt;, <b>hash</b>&lt; __iter_key_t&lt;
_InputIterator &gt; &gt;, <b>equal_to</b>&lt;
__iter_key_t&lt; _InputIterator &gt; &gt;, _Allocator &gt;
<br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multimap</b> (_InputIterator, _InputIterator,
<b>unordered_multimap</b>&lt; int, int &gt;::size_type,
_Allocator) &minus;&gt; <b>unordered_multimap</b>&lt;
__iter_key_t&lt; _InputIterator &gt;, __iter_val_t&lt;
_InputIterator &gt;, <b>hash</b>&lt; __iter_key_t&lt;
_InputIterator &gt; &gt;, <b>equal_to</b>&lt;
__iter_key_t&lt; _InputIterator &gt; &gt;, _Allocator &gt;
<br>
template&lt;typename _InputIterator , typename _Hash ,
typename _Allocator , typename =
_RequireInputIter&lt;_InputIterator&gt;, typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multimap</b> (_InputIterator, _InputIterator,
<b>unordered_multimap</b>&lt; int, int &gt;::size_type,
_Hash, _Allocator) &minus;&gt; <b>unordered_multimap</b>&lt;
__iter_key_t&lt; _InputIterator &gt;, __iter_val_t&lt;
_InputIterator &gt;, _Hash, <b>equal_to</b>&lt;
__iter_key_t&lt; _InputIterator &gt; &gt;, _Allocator &gt;
<br>
template&lt;typename _InputIterator , typename _Hash =
hash&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, typename
_Pred = equal_to&lt;__iter_key_t&lt;_InputIterator&gt;&gt;,
typename _Allocator =
allocator&lt;__iter_to_alloc_t&lt;_InputIterator&gt;&gt;,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireNotAllocator&lt;_Pred&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multimap</b> (_InputIterator, _InputIterator,
<b>unordered_multimap</b>&lt; int, int &gt;::size_type={},
_Hash=_Hash(), _Pred=_Pred(), _Allocator=_Allocator())
&minus;&gt; <b>unordered_multimap</b>&lt; __iter_key_t&lt;
_InputIterator &gt;, __iter_val_t&lt; _InputIterator &gt;,
_Hash, _Pred, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename
_Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multimap</b> (<b>initializer_list</b>&lt;
<b>pair</b>&lt; _Key, _Tp &gt; &gt;, _Allocator) &minus;&gt;
<b>unordered_multimap</b>&lt; _Key, _Tp, <b>hash</b>&lt;
_Key &gt;, <b>equal_to</b>&lt; _Key &gt;, _Allocator &gt;
<br>
template&lt;typename _Key , typename _Tp , typename
_Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multimap</b> (<b>initializer_list</b>&lt;
<b>pair</b>&lt; _Key, _Tp &gt; &gt;,
<b>unordered_multimap</b>&lt; int, int &gt;::size_type,
_Allocator) &minus;&gt; <b>unordered_multimap</b>&lt; _Key,
_Tp, <b>hash</b>&lt; _Key &gt;, <b>equal_to</b>&lt; _Key
&gt;, _Allocator &gt; <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _Allocator , typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multimap</b> (<b>initializer_list</b>&lt;
<b>pair</b>&lt; _Key, _Tp &gt; &gt;,
<b>unordered_multimap</b>&lt; int, int &gt;::size_type,
_Hash, _Allocator) &minus;&gt; <b>unordered_multimap</b>&lt;
_Key, _Tp, _Hash, <b>equal_to</b>&lt; _Key &gt;, _Allocator
&gt; <br>
template&lt;typename _Key , typename _Tp , typename _Hash =
hash&lt;_Key&gt;, typename _Pred = equal_to&lt;_Key&gt;,
typename _Allocator = allocator&lt;pair&lt;const _Key,
_Tp&gt;&gt;, typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireNotAllocator&lt;_Pred&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multimap</b> (<b>initializer_list</b>&lt;
<b>pair</b>&lt; _Key, _Tp &gt; &gt;,
<b>unordered_multimap</b>&lt; int, int &gt;::size_type={},
_Hash=_Hash(), _Pred=_Pred(), _Allocator=_Allocator())
&minus;&gt; <b>unordered_multimap</b>&lt; _Key, _Tp, _Hash,
_Pred, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multiset</b> (_InputIterator, _InputIterator,
<b>unordered_multiset</b>&lt; int &gt;::size_type,
_Allocator) &minus;&gt; <b>unordered_multiset</b>&lt;
typename <b>iterator_traits</b>&lt; _InputIterator
&gt;::value_type, <b>hash</b>&lt; typename
<b>iterator_traits</b>&lt; _InputIterator &gt;::value_type
&gt;, <b>equal_to</b>&lt; typename
<b>iterator_traits</b>&lt; _InputIterator &gt;::value_type
&gt;, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Hash ,
typename _Allocator , typename =
_RequireInputIter&lt;_InputIterator&gt;, typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multiset</b> (_InputIterator, _InputIterator,
<b>unordered_multiset</b>&lt; int &gt;::size_type, _Hash,
_Allocator) &minus;&gt; <b>unordered_multiset</b>&lt;
typename <b>iterator_traits</b>&lt; _InputIterator
&gt;::value_type, _Hash, <b>equal_to</b>&lt; typename
<b>iterator_traits</b>&lt; _InputIterator &gt;::value_type
&gt;, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Hash =
hash&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename _Pred = equal_to&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename _Allocator = allocator&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireNotAllocator&lt;_Pred&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multiset</b> (_InputIterator, _InputIterator,
<b>unordered_multiset</b>&lt; int &gt;::size_type={},
_Hash=_Hash(), _Pred=_Pred(), _Allocator=_Allocator())
&minus;&gt; <b>unordered_multiset</b>&lt; typename
<b>iterator_traits</b>&lt; _InputIterator &gt;::value_type,
_Hash, _Pred, _Allocator &gt; <br>
template&lt;typename _Tp , typename _Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multiset</b> (<b>initializer_list</b>&lt; _Tp
&gt;, <b>unordered_multiset</b>&lt; int &gt;::size_type,
_Allocator) &minus;&gt; <b>unordered_multiset</b>&lt; _Tp,
<b>hash</b>&lt; _Tp &gt;, <b>equal_to</b>&lt; _Tp &gt;,
_Allocator &gt; <br>
template&lt;typename _Tp , typename _Hash , typename
_Allocator , typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multiset</b> (<b>initializer_list</b>&lt; _Tp
&gt;, <b>unordered_multiset</b>&lt; int &gt;::size_type,
_Hash, _Allocator) &minus;&gt; <b>unordered_multiset</b>&lt;
_Tp, _Hash, <b>equal_to</b>&lt; _Tp &gt;, _Allocator &gt;
<br>
template&lt;typename _Tp , typename _Hash = hash&lt;_Tp&gt;,
typename _Pred = equal_to&lt;_Tp&gt;, typename _Allocator =
allocator&lt;_Tp&gt;, typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireNotAllocator&lt;_Pred&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_multiset</b> (<b>initializer_list</b>&lt; _Tp
&gt;, <b>unordered_multiset</b>&lt; int &gt;::size_type={},
_Hash=_Hash(), _Pred=_Pred(), _Allocator=_Allocator())
&minus;&gt; <b>unordered_multiset</b>&lt; _Tp, _Hash, _Pred,
_Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Allocator ,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireAllocator&lt;_Allocator&gt;&gt;
<b>unordered_set</b> (_InputIterator, _InputIterator,
<b>unordered_set</b>&lt; int &gt;::size_type, _Allocator)
&minus;&gt; <b>unordered_set</b>&lt; typename
<b>iterator_traits</b>&lt; _InputIterator &gt;::value_type,
<b>hash</b>&lt; typename <b>iterator_traits</b>&lt;
_InputIterator &gt;::value_type &gt;, <b>equal_to</b>&lt;
typename <b>iterator_traits</b>&lt; _InputIterator
&gt;::value_type &gt;, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Hash ,
typename _Allocator , typename =
_RequireInputIter&lt;_InputIterator&gt;, typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b>
(_InputIterator, _InputIterator, <b>unordered_set</b>&lt;
int &gt;::size_type, _Hash, _Allocator) &minus;&gt;
<b>unordered_set</b>&lt; typename <b>iterator_traits</b>&lt;
_InputIterator &gt;::value_type, _Hash, <b>equal_to</b>&lt;
typename <b>iterator_traits</b>&lt; _InputIterator
&gt;::value_type &gt;, _Allocator &gt; <br>
template&lt;typename _InputIterator , typename _Hash =
hash&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename _Pred = equal_to&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename _Allocator = allocator&lt;typename
iterator_traits&lt;_InputIterator&gt;::value_type&gt;,
typename = _RequireInputIter&lt;_InputIterator&gt;, typename
= _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireNotAllocator&lt;_Pred&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b>
(_InputIterator, _InputIterator, <b>unordered_set</b>&lt;
int &gt;::size_type={}, _Hash=_Hash(), _Pred=_Pred(),
_Allocator=_Allocator()) &minus;&gt;
<b>unordered_set</b>&lt; typename <b>iterator_traits</b>&lt;
_InputIterator &gt;::value_type, _Hash, _Pred, _Allocator
&gt; <br>
template&lt;typename _Tp , typename _Allocator , typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b>
(<b>initializer_list</b>&lt; _Tp &gt;,
<b>unordered_set</b>&lt; int &gt;::size_type, _Allocator)
&minus;&gt; <b>unordered_set</b>&lt; _Tp, <b>hash</b>&lt;
_Tp &gt;, <b>equal_to</b>&lt; _Tp &gt;, _Allocator &gt; <br>
template&lt;typename _Tp , typename _Hash , typename
_Allocator , typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b>
(<b>initializer_list</b>&lt; _Tp &gt;,
<b>unordered_set</b>&lt; int &gt;::size_type, _Hash,
_Allocator) &minus;&gt; <b>unordered_set</b>&lt; _Tp, _Hash,
<b>equal_to</b>&lt; _Tp &gt;, _Allocator &gt; <br>
template&lt;typename _Tp , typename _Hash = hash&lt;_Tp&gt;,
typename _Pred = equal_to&lt;_Tp&gt;, typename _Allocator =
allocator&lt;_Tp&gt;, typename =
_RequireNotAllocatorOrIntegral&lt;_Hash&gt;, typename =
_RequireNotAllocator&lt;_Pred&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b>
(<b>initializer_list</b>&lt; _Tp &gt;,
<b>unordered_set</b>&lt; int &gt;::size_type={},
_Hash=_Hash(), _Pred=_Pred(), _Allocator=_Allocator())
&minus;&gt; <b>unordered_set</b>&lt; _Tp, _Hash, _Pred,
_Allocator &gt; <br>
template&lt;typename _InputIterator , typename _ValT =
typename iterator_traits&lt;_InputIterator&gt;::value_type,
typename _Allocator = allocator&lt;_ValT&gt;, typename =
_RequireInputIter&lt;_InputIterator&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>vector</b>
(_InputIterator, _InputIterator, _Allocator=_Allocator())
&minus;&gt; <b>vector</b>&lt; _ValT, _Allocator &gt; <br>
template&lt;typename _Tp , typename _Allocator =
allocator&lt;_Tp&gt;, typename =
_RequireAllocator&lt;_Allocator&gt;&gt; <b>vector</b>
(size_t, _Tp, _Allocator=_Allocator()) &minus;&gt;
<b>vector</b>&lt; _Tp, _Allocator &gt;</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">GNU debug code,
replaces standard behavior with debug behavior.</p>

<p style="margin-left:11%; margin-top: 1em">Macros and
namespaces used by the implementation outside of debug
wrappers to verify certain properties. The
__glibcxx_requires_xxx macros are merely wrappers around the
__glibcxx_check_xxx wrappers when we are compiling with
debug mode, but disappear when we are in release mode so
that there is no checking performed in, e.g., the standard
library algorithms.</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; bool std::__debug::operator&lt;=
(const forward_list&lt; _Tp, _Alloc &gt; &amp; __lx, const
forward_list&lt; _Tp, _Alloc &gt; &amp; __ly)</b>
<tt>[inline]</tt> <br>
Based on operator&lt;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; bool std::__debug::operator&gt;
(const forward_list&lt; _Tp, _Alloc &gt; &amp; __lx, const
forward_list&lt; _Tp, _Alloc &gt; &amp; __ly)</b>
<tt>[inline]</tt> <br>
Based on operator&lt;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; bool std::__debug::operator&gt;=
(const forward_list&lt; _Tp, _Alloc &gt; &amp; __lx, const
forward_list&lt; _Tp, _Alloc &gt; &amp; __ly)</b>
<tt>[inline]</tt> <br>
Based on operator&lt;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void std::__debug::swap
(forward_list&lt; _Tp, _Alloc &gt; &amp; __lx,
forward_list&lt; _Tp, _Alloc &gt; &amp; __ly)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
See std::forward_list::swap().</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
