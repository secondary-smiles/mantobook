<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:12 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__gnu_parallel::_IteratorPair&lt; _Iterator1, _Iterator2, _IteratorCategory &gt;</title>

</head>
<body>
<h1>__gnu_parallel::_IteratorPair</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">__gnu_parallel::_IteratorPair&lt;
_Iterator1, _Iterator2, _IteratorCategory &gt; &minus; A
pair of iterators. The usual iterator operations are applied
to both child iterators.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;iterator.h&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::pair&lt; _Iterator1, _Iterator2 &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef
<b>std::iterator_traits</b>&lt; _Iterator1 &gt;
<b>_TraitsType</b> <br>
typedef _TraitsType::difference_type <b>difference_type</b>
<br>
typedef _Iterator1 <b>first_type</b> <br>
The type of the <tt>first</tt> member. <br>
typedef _IteratorCategory <b>iterator_category</b> <br>
typedef <b>_IteratorPair</b> * <b>pointer</b> <br>
typedef <b>_IteratorPair</b> &amp; <b>reference</b> <br>
typedef _Iterator2 <b>second_type</b> <br>
The type of the <tt>second</tt> member. <br>
typedef void <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>_IteratorPair</b> (const
_Iterator1 &amp;__first, const _Iterator2 &amp;__second)
<b><br>
operator _Iterator2</b> () const <b><br>
_IteratorPair operator+</b> (difference_type __delta) const
<b><br>
_IteratorPair</b> &amp; <b>operator++</b> () <br>
const <b>_IteratorPair operator++</b> (int) <br>
difference_type <b>operator&minus;</b> (const
<b>_IteratorPair</b> &amp;__other) const <b><br>
_IteratorPair</b> &amp; <b>operator&minus;&minus;</b> ()
<br>
const <b>_IteratorPair operator&minus;&minus;</b> (int)
<b><br>
_IteratorPair</b> &amp; <b>operator=</b> (const
<b>_IteratorPair</b> &amp;__other) <br>
constexpr void <b>swap</b> (<b>pair</b> &amp;__p)
noexcept(__and_&lt; __is_nothrow_swappable&lt; _Iterator1
&gt;, __is_nothrow_swappable&lt; _Iterator2 &gt;
&gt;::value) <br>
Swap the first members and then the second members.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Attributes</b></p>

<p style="margin-left:17%;">_Iterator1 <b>first</b> <br>
The first member. <br>
_Iterator2 <b>second</b> <br>
The second member.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Related
Functions</b> <br>
(Note that these are not member functions.)</p>

<p style="margin-left:17%;">constexpr <b>pair</b>&lt;
typename __decay_and_strip&lt; _Iterator1 &gt;::__type,
typename __decay_and_strip&lt; _Iterator2 &gt;::__type &gt;
<b>make_pair</b> (_Iterator1 &amp;&amp;__x, _Iterator2
&amp;&amp;__y) <br>
A convenience wrapper for creating a pair from two
objects.</p>

<p style="margin-left:23%; margin-top: 1em">constexpr
enable_if&lt; __and_&lt; __is_swappable&lt; _Iterator1 &gt;,
__is_swappable&lt; _Iterator2 &gt; &gt;::value &gt;::type
<b>swap</b> (<b>pair</b>&lt; _Iterator1, _Iterator2 &gt;
&amp;__x, <b>pair</b>&lt; _Iterator1, _Iterator2 &gt;
&amp;__y) noexcept(noexcept(__x.swap(__y))) <br>
constexpr bool <b>operator==</b> (const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__x, const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__y) <br>
Two pairs of the same type are equal iff their members are
equal. <br>
constexpr bool <b>operator&lt;</b> (const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__x, const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__y) <br>
constexpr bool <b>operator!=</b> (const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__x, const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__y) <br>
Uses <tt>operator==</tt> to find the result. <br>
constexpr bool <b>operator&gt;</b> (const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__x, const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__y) <br>
Uses <tt>operator&lt;</tt> to find the result. <br>
constexpr bool <b>operator&lt;=</b> (const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__x, const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__y) <br>
Uses <tt>operator&lt;</tt> to find the result. <br>
constexpr bool <b>operator&gt;=</b> (const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__x, const <b>pair</b>&lt;
_Iterator1, _Iterator2 &gt; &amp;__y) <br>
Uses <tt>operator&lt;</tt> to find the result.</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator1, typename _Iterator2, typename
_IteratorCategory&gt;</b> <br>
class __gnu_parallel::_IteratorPair&lt; _Iterator1,
_Iterator2, _IteratorCategory &gt;&quot;A pair of iterators.
The usual iterator operations are applied to both child
iterators.</p>

<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>typedef
_Iterator1 std::pair&lt; _Iterator1 , _Iterator2
&gt;::first_type</b> <tt>[inherited]</tt> <br>
The type of the <tt>first</tt> member.</p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef
_Iterator2 std::pair&lt; _Iterator1 , _Iterator2
&gt;::second_type</b> <tt>[inherited]</tt> <br>
The type of the <tt>second</tt> member.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>constexpr
void std::pair&lt; _Iterator1 , _Iterator2 &gt;::swap
(pair&lt; _Iterator1, _Iterator2 &gt; &amp; __p)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt><b>,</b> <tt>[inherited]</tt> <br>
Swap the first members and then the second members.</p>

<h2>Friends And Related Function Documentation
<a name="Friends And Related Function Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>constexpr
pair&lt; typename __decay_and_strip&lt; _Iterator1
&gt;::__type, typename __decay_and_strip&lt; _Iterator2
&gt;::__type &gt; make_pair (_Iterator1 &amp;&amp; __x,
_Iterator2 &amp;&amp; __y)</b> <tt>[related]</tt> <br>
A convenience wrapper for creating a pair from two
objects.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> The first object.
<i><br>
__y</i> The second object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A newly-constructed
pair&lt;&gt; object of the appropriate type.</p>

<p style="margin-left:11%; margin-top: 1em">The C++98
standard says the objects are passed by reference-to-const,
but C++03 says they are passed by value (this was LWG issue
#181).</p>

<p style="margin-left:11%; margin-top: 1em">Since C++11
they have been passed by forwarding reference and then
forwarded to the new members of the pair. To create a pair
with a member of reference type, pass a
<tt>reference_wrapper</tt> to this function.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool operator!= (const pair&lt; _Iterator1 , _Iterator2 &gt;
&amp; __x, const pair&lt; _Iterator1 , _Iterator2 &gt; &amp;
__y)</b> <tt>[related]</tt> <br>
Uses <tt>operator==</tt> to find the result.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool operator&lt; (const pair&lt; _Iterator1 , _Iterator2
&gt; &amp; __x, const pair&lt; _Iterator1 , _Iterator2 &gt;
&amp; __y)</b> <tt>[related]</tt> <br>
Defines a lexicographical order for pairs.</p>

<p style="margin-left:11%; margin-top: 1em">For two pairs
of the same type, <tt>P</tt> is ordered before <tt>Q</tt> if
<tt>P.first</tt> is less than <tt>Q.first</tt>, or if
<tt>P.first</tt> and <tt>Q.first</tt> are equivalent
(neither is less than the other) and <tt>P.second</tt> is
less than <tt>Q.second</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool operator&lt;= (const pair&lt; _Iterator1 , _Iterator2
&gt; &amp; __x, const pair&lt; _Iterator1 , _Iterator2 &gt;
&amp; __y)</b> <tt>[related]</tt> <br>
Uses <tt>operator&lt;</tt> to find the result.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool operator== (const pair&lt; _Iterator1 , _Iterator2 &gt;
&amp; __x, const pair&lt; _Iterator1 , _Iterator2 &gt; &amp;
__y)</b> <tt>[related]</tt> <br>
Two pairs of the same type are equal iff their members are
equal.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool operator&gt; (const pair&lt; _Iterator1 , _Iterator2
&gt; &amp; __x, const pair&lt; _Iterator1 , _Iterator2 &gt;
&amp; __y)</b> <tt>[related]</tt> <br>
Uses <tt>operator&lt;</tt> to find the result.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool operator&gt;= (const pair&lt; _Iterator1 , _Iterator2
&gt; &amp; __x, const pair&lt; _Iterator1 , _Iterator2 &gt;
&amp; __y)</b> <tt>[related]</tt> <br>
Uses <tt>operator&lt;</tt> to find the result.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
enable_if&lt; __and_&lt; __is_swappable&lt; _Iterator1 &gt;,
__is_swappable&lt; _Iterator2 &gt; &gt;::value &gt;::type
swap (pair&lt; _Iterator1 , _Iterator2 &gt; &amp; __x,
pair&lt; _Iterator1 , _Iterator2 &gt; &amp; __y)</b>
<tt>[related]</tt> <br>
Swap overload for pairs. Calls std::pair::swap().</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">This std::swap overload is not
declared in C++03 mode, which has performance implications,
e.g. see https://gcc.gnu.org/PR38466</p>

<h2>Member Data Documentation
<a name="Member Data Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>_Iterator1
std::pair&lt; _Iterator1 , _Iterator2 &gt;::first</b>
<tt>[inherited]</tt> <br>
The first member.</p>

<p style="margin-left:11%; margin-top: 1em"><b>_Iterator2
std::pair&lt; _Iterator1 , _Iterator2 &gt;::second</b>
<tt>[inherited]</tt> <br>
The second member.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
