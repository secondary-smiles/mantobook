<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:57 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EVP_PKEY_CTX_CTRL</title>

</head>
<body>
<h1>EVP_PKEY_CTX_set_dsa_paramgen_seed</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">EVP_PKEY_CTX_ctrl,
EVP_PKEY_CTX_ctrl_str, EVP_PKEY_CTX_ctrl_uint64,
EVP_PKEY_CTX_md, EVP_PKEY_CTX_set_signature_md,
EVP_PKEY_CTX_get_signature_md, EVP_PKEY_CTX_set_mac_key,
EVP_PKEY_CTX_set_group_name, EVP_PKEY_CTX_get_group_name,
EVP_PKEY_CTX_set_rsa_padding, EVP_PKEY_CTX_get_rsa_padding,
EVP_PKEY_CTX_set_rsa_pss_saltlen,
EVP_PKEY_CTX_get_rsa_pss_saltlen,
EVP_PKEY_CTX_set_rsa_keygen_bits,
EVP_PKEY_CTX_set_rsa_keygen_pubexp,
EVP_PKEY_CTX_set1_rsa_keygen_pubexp,
EVP_PKEY_CTX_set_rsa_keygen_primes,
EVP_PKEY_CTX_set_rsa_mgf1_md_name,
EVP_PKEY_CTX_set_rsa_mgf1_md, EVP_PKEY_CTX_get_rsa_mgf1_md,
EVP_PKEY_CTX_get_rsa_mgf1_md_name,
EVP_PKEY_CTX_set_rsa_oaep_md_name,
EVP_PKEY_CTX_set_rsa_oaep_md, EVP_PKEY_CTX_get_rsa_oaep_md,
EVP_PKEY_CTX_get_rsa_oaep_md_name,
EVP_PKEY_CTX_set0_rsa_oaep_label,
EVP_PKEY_CTX_get0_rsa_oaep_label,
EVP_PKEY_CTX_set_dsa_paramgen_bits,
EVP_PKEY_CTX_set_dsa_paramgen_q_bits,
EVP_PKEY_CTX_set_dsa_paramgen_md,
EVP_PKEY_CTX_set_dsa_paramgen_md_props,
EVP_PKEY_CTX_set_dsa_paramgen_gindex,
EVP_PKEY_CTX_set_dsa_paramgen_type,
EVP_PKEY_CTX_set_dsa_paramgen_seed,
EVP_PKEY_CTX_set_dh_paramgen_prime_len,
EVP_PKEY_CTX_set_dh_paramgen_subprime_len,
EVP_PKEY_CTX_set_dh_paramgen_generator,
EVP_PKEY_CTX_set_dh_paramgen_type,
EVP_PKEY_CTX_set_dh_paramgen_gindex,
EVP_PKEY_CTX_set_dh_paramgen_seed,
EVP_PKEY_CTX_set_dh_rfc5114, EVP_PKEY_CTX_set_dhx_rfc5114,
EVP_PKEY_CTX_set_dh_pad, EVP_PKEY_CTX_set_dh_nid,
EVP_PKEY_CTX_set_dh_kdf_type, EVP_PKEY_CTX_get_dh_kdf_type,
EVP_PKEY_CTX_set0_dh_kdf_oid, EVP_PKEY_CTX_get0_dh_kdf_oid,
EVP_PKEY_CTX_set_dh_kdf_md, EVP_PKEY_CTX_get_dh_kdf_md,
EVP_PKEY_CTX_set_dh_kdf_outlen,
EVP_PKEY_CTX_get_dh_kdf_outlen,
EVP_PKEY_CTX_set0_dh_kdf_ukm, EVP_PKEY_CTX_get0_dh_kdf_ukm,
EVP_PKEY_CTX_set_ec_paramgen_curve_nid,
EVP_PKEY_CTX_set_ec_param_enc,
EVP_PKEY_CTX_set_ecdh_cofactor_mode,
EVP_PKEY_CTX_get_ecdh_cofactor_mode,
EVP_PKEY_CTX_set_ecdh_kdf_type,
EVP_PKEY_CTX_get_ecdh_kdf_type,
EVP_PKEY_CTX_set_ecdh_kdf_md, EVP_PKEY_CTX_get_ecdh_kdf_md,
EVP_PKEY_CTX_set_ecdh_kdf_outlen,
EVP_PKEY_CTX_get_ecdh_kdf_outlen,
EVP_PKEY_CTX_set0_ecdh_kdf_ukm,
EVP_PKEY_CTX_get0_ecdh_kdf_ukm, EVP_PKEY_CTX_set1_id,
EVP_PKEY_CTX_get1_id, EVP_PKEY_CTX_get1_id_len,
EVP_PKEY_CTX_set_kem_op &minus; algorithm specific control
operations</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/evp.h&gt; <br>
int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int
optype, <br>
int cmd, int p1, void *p2); <br>
int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype,
int optype, <br>
int cmd, uint64_t value); <br>
int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char
*type, <br>
const char *value); <br>
int EVP_PKEY_CTX_md(EVP_PKEY_CTX *ctx, int optype, int cmd,
const char *md); <br>
int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br>
int EVP_PKEY_CTX_get_signature_md(EVP_PKEY_CTX *ctx, const
EVP_MD **pmd); <br>
int EVP_PKEY_CTX_set_mac_key(EVP_PKEY_CTX *ctx, const
unsigned char *key, <br>
int len); <br>
int EVP_PKEY_CTX_set_group_name(EVP_PKEY_CTX *ctx, const
char *name); <br>
int EVP_PKEY_CTX_get_group_name(EVP_PKEY_CTX *ctx, char
*name, size_t namelen); <br>
int EVP_PKEY_CTX_set_kem_op(EVP_PKEY_CTX *ctx, const char
*op); <br>
#include &lt;openssl/rsa.h&gt; <br>
int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int
pad); <br>
int EVP_PKEY_CTX_get_rsa_padding(EVP_PKEY_CTX *ctx, int
*pad); <br>
int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int
saltlen); <br>
int EVP_PKEY_CTX_get_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int
*saltlen); <br>
int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int
mbits); <br>
int EVP_PKEY_CTX_set1_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx,
BIGNUM *pubexp); <br>
int EVP_PKEY_CTX_set_rsa_keygen_primes(EVP_PKEY_CTX *ctx,
int primes); <br>
int EVP_PKEY_CTX_set_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx,
const char *mdname, <br>
const char *mdprops); <br>
int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br>
int EVP_PKEY_CTX_get_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const
EVP_MD **md); <br>
int EVP_PKEY_CTX_get_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx,
char *name, <br>
size_t namelen); <br>
int EVP_PKEY_CTX_set_rsa_oaep_md_name(EVP_PKEY_CTX *ctx,
const char *mdname, <br>
const char *mdprops); <br>
int EVP_PKEY_CTX_set_rsa_oaep_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br>
int EVP_PKEY_CTX_get_rsa_oaep_md(EVP_PKEY_CTX *ctx, const
EVP_MD **md); <br>
int EVP_PKEY_CTX_get_rsa_oaep_md_name(EVP_PKEY_CTX *ctx,
char *name, <br>
size_t namelen); <br>
int EVP_PKEY_CTX_set0_rsa_oaep_label(EVP_PKEY_CTX *ctx, void
*label, <br>
int len); <br>
int EVP_PKEY_CTX_get0_rsa_oaep_label(EVP_PKEY_CTX *ctx,
unsigned char **label); <br>
#include &lt;openssl/dsa.h&gt; <br>
int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx,
int nbits); <br>
int EVP_PKEY_CTX_set_dsa_paramgen_q_bits(EVP_PKEY_CTX *ctx,
int qbits); <br>
int EVP_PKEY_CTX_set_dsa_paramgen_md(EVP_PKEY_CTX *ctx,
const EVP_MD *md); <br>
int EVP_PKEY_CTX_set_dsa_paramgen_md_props(EVP_PKEY_CTX
*ctx, <br>
const char *md_name, <br>
const char *md_properties); <br>
int EVP_PKEY_CTX_set_dsa_paramgen_type(EVP_PKEY_CTX *ctx,
const char *name); <br>
int EVP_PKEY_CTX_set_dsa_paramgen_gindex(EVP_PKEY_CTX *ctx,
int gindex); <br>
int EVP_PKEY_CTX_set_dsa_paramgen_seed(EVP_PKEY_CTX *ctx,
<br>
const unsigned char *seed, <br>
size_t seedlen); <br>
#include &lt;openssl/dh.h&gt; <br>
int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX
*ctx, int len); <br>
int EVP_PKEY_CTX_set_dh_paramgen_subprime_len(EVP_PKEY_CTX
*ctx, int len); <br>
int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX
*ctx, int gen); <br>
int EVP_PKEY_CTX_set_dh_paramgen_type(EVP_PKEY_CTX *ctx, int
type); <br>
int EVP_PKEY_CTX_set_dh_pad(EVP_PKEY_CTX *ctx, int pad);
<br>
int EVP_PKEY_CTX_set_dh_nid(EVP_PKEY_CTX *ctx, int nid);
<br>
int EVP_PKEY_CTX_set_dh_rfc5114(EVP_PKEY_CTX *ctx, int
rfc5114); <br>
int EVP_PKEY_CTX_set_dhx_rfc5114(EVP_PKEY_CTX *ctx, int
rfc5114); <br>
int EVP_PKEY_CTX_set_dh_paramgen_gindex(EVP_PKEY_CTX *ctx,
int gindex); <br>
int EVP_PKEY_CTX_set_dh_paramgen_seed(EVP_PKEY_CTX *ctx,
<br>
const unsigned char *seed, <br>
size_t seedlen); <br>
int EVP_PKEY_CTX_set_dh_kdf_type(EVP_PKEY_CTX *ctx, int
kdf); <br>
int EVP_PKEY_CTX_get_dh_kdf_type(EVP_PKEY_CTX *ctx); <br>
int EVP_PKEY_CTX_set0_dh_kdf_oid(EVP_PKEY_CTX *ctx,
ASN1_OBJECT *oid); <br>
int EVP_PKEY_CTX_get0_dh_kdf_oid(EVP_PKEY_CTX *ctx,
ASN1_OBJECT **oid); <br>
int EVP_PKEY_CTX_set_dh_kdf_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br>
int EVP_PKEY_CTX_get_dh_kdf_md(EVP_PKEY_CTX *ctx, const
EVP_MD **md); <br>
int EVP_PKEY_CTX_set_dh_kdf_outlen(EVP_PKEY_CTX *ctx, int
len); <br>
int EVP_PKEY_CTX_get_dh_kdf_outlen(EVP_PKEY_CTX *ctx, int
*len); <br>
int EVP_PKEY_CTX_set0_dh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned
char *ukm, int len); <br>
#include &lt;openssl/ec.h&gt; <br>
int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX
*ctx, int nid); <br>
int EVP_PKEY_CTX_set_ec_param_enc(EVP_PKEY_CTX *ctx, int
param_enc); <br>
int EVP_PKEY_CTX_set_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx,
int cofactor_mode); <br>
int EVP_PKEY_CTX_get_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx);
<br>
int EVP_PKEY_CTX_set_ecdh_kdf_type(EVP_PKEY_CTX *ctx, int
kdf); <br>
int EVP_PKEY_CTX_get_ecdh_kdf_type(EVP_PKEY_CTX *ctx); <br>
int EVP_PKEY_CTX_set_ecdh_kdf_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br>
int EVP_PKEY_CTX_get_ecdh_kdf_md(EVP_PKEY_CTX *ctx, const
EVP_MD **md); <br>
int EVP_PKEY_CTX_set_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx, int
len); <br>
int EVP_PKEY_CTX_get_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx, int
*len); <br>
int EVP_PKEY_CTX_set0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx,
unsigned char *ukm, int len); <br>
int EVP_PKEY_CTX_set1_id(EVP_PKEY_CTX *ctx, void *id, size_t
id_len); <br>
int EVP_PKEY_CTX_get1_id(EVP_PKEY_CTX *ctx, void *id); <br>
int EVP_PKEY_CTX_get1_id_len(EVP_PKEY_CTX *ctx, size_t
*id_len);</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining
<b><small>OPENSSL_API_COMPAT</small></b> with a suitable
version value, see <b>openssl_user_macros</b>(7):</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/rsa.h&gt; <br>
int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx,
BIGNUM *pubexp); <br>
#include &lt;openssl/dh.h&gt; <br>
int EVP_PKEY_CTX_get0_dh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned
char **ukm); <br>
#include &lt;openssl/ec.h&gt; <br>
int EVP_PKEY_CTX_get0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx,
unsigned char **ukm);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_ctrl()</b>
sends a control operation to the context <i>ctx</i>. The key
type used must match <i>keytype</i> if it is not &minus;1.
The parameter <i>optype</i> is a mask indicating which
operations the control can be applied to. The control
command is indicated in <i>cmd</i> and any additional
arguments in <i>p1</i> and <i>p2</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For <i>cmd</i>
= <b><small>EVP_PKEY_CTRL_SET_MAC_KEY</small></b> ,
<i>p1</i> is the length of the <small>MAC</small> key, and
<i>p2</i> is the <small>MAC</small> key. This is used by
Poly1305, SipHash, <small>HMAC</small> and
<small>CMAC.</small></p>

<p style="margin-left:11%; margin-top: 1em">Applications
will not normally call <b>EVP_PKEY_CTX_ctrl()</b> directly
but will instead call one of the algorithm specific
functions below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_ctrl_uint64()</b>
is a wrapper that directly passes a uint64 value as
<i>p2</i> to <b>EVP_PKEY_CTX_ctrl()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_ctrl_str()</b>
allows an application to send an algorithm specific control
operation to a context <i>ctx</i> in string form. This is
intended to be used for options specified on the command
line or in text files. The commands supported are documented
in the openssl utility command line pages for the option
<i>&minus;pkeyopt</i> which is supported by the
<i>pkeyutl</i>, <i>genpkey</i> and <i>req</i> commands.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_md()</b>
sends a message digest control operation to the context
<i>ctx</i>. The message digest is specified by its name
<i>md</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_signature_md()</b>
sets the message digest type used in a signature. It can be
used in the <small>RSA, DSA</small> and <small>ECDSA</small>
algorithms.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_signature_md()</b>gets
the message digest type used in a signature. It can be used
in the <small>RSA, DSA</small> and <small>ECDSA</small>
algorithms.</p>

<p style="margin-left:11%; margin-top: 1em">Key generation
typically involves setting up parameters to be used and
generating the private and public key data. Some algorithm
implementations allow private key data to be set explicitly
using <b>EVP_PKEY_CTX_set_mac_key()</b>. In this case key
generation is simply the process of setting up the
parameters for the key and then setting the raw key data to
the value explicitly. Normally applications would call
<b>EVP_PKEY_new_raw_private_key</b>(3) or similar functions
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_mac_key()</b>
can be used with any of the algorithms supported by the
<b>EVP_PKEY_new_raw_private_key</b>(3) function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_group_name()</b>
sets the group name to <i>name</i> for parameter and key
generation. For example for <small>EC</small> keys this will
set the curve name and for <small>DH</small> keys it will
set the name of the finite field group.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_group_name()</b>
finds the group name that&rsquo;s currently set with
<i>ctx</i>, and writes it to the location that <i>name</i>
points at, as long as its size <i>namelen</i> is large
enough to store that name, including a terminating
<small>NUL</small> byte.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>RSA</small>
parameters <br>
EVP_PKEY_CTX_set_rsa_padding()</b> sets the
<small>RSA</small> padding mode for <i>ctx</i>. The
<i>pad</i> parameter can take the value
<b><small>RSA_PKCS1_PADDING</small></b> for PKCS#1 padding,
<b><small>RSA_NO_PADDING</small></b> for no padding,
<b><small>RSA_PKCS1_OAEP_PADDING</small></b> for
<small>OAEP</small> padding (encrypt and decrypt only),
<b><small>RSA_X931_PADDING</small></b> for X9.31 padding
(signature operations only),
<b><small>RSA_PKCS1_PSS_PADDING</small></b> (sign and verify
only) and <b><small>RSA_PKCS1_WITH_TLS_PADDING</small></b>
for <small>TLS RSA</small> ClientKeyExchange message padding
(decryption only).</p>

<p style="margin-left:11%; margin-top: 1em">Two
<small>RSA</small> padding modes behave differently if
<b>EVP_PKEY_CTX_set_signature_md()</b> is used. If this
function is called for PKCS#1 padding the plaintext buffer
is an actual digest value and is encapsulated in a
DigestInfo structure according to PKCS#1 when signing and
this structure is expected (and stripped off) when
verifying. If this control is not used with
<small>RSA</small> and PKCS#1 padding then the supplied data
is used directly and not encapsulated. In the case of X9.31
padding for <small>RSA</small> the algorithm identifier byte
is added or checked and removed if this control is called.
If it is not called then the first byte of the plaintext
buffer is expected to be the algorithm identifier byte.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_padding()</b>
gets the <small>RSA</small> padding mode for <i>ctx</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_pss_saltlen()</b>
sets the <small>RSA PSS</small> salt length to
<i>saltlen</i>. As its name implies it is only supported for
<small>PSS</small> padding. If this function is not called
then the maximum salt length is used when signing and auto
detection when verifying. Three special values are
supported: <b><small><br>
RSA_PSS_SALTLEN_DIGEST</small></b></p>

<p style="margin-left:17%;">sets the salt length to the
digest length.</p>


<p style="margin-left:11%;"><b><small>RSA_PSS_SALTLEN_MAX</small></b></p>

<p style="margin-left:17%;">sets the salt length to the
maximum permissible value.</p>


<p style="margin-left:11%;"><b><small>RSA_PSS_SALTLEN_AUTO</small></b></p>

<p style="margin-left:17%;">causes the salt length to be
automatically determined based on the
<b><small>PSS</small></b> block structure when verifying.
When signing, it has the same meaning as
<b><small>RSA_PSS_SALTLEN_MAX</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_pss_saltlen()</b>
gets the <small>RSA PSS</small> salt length for <i>ctx</i>.
The padding mode must already have been set to
<b><small>RSA_PKCS1_PSS_PADDING</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_keygen_bits()</b>
sets the <small>RSA</small> key length for
<small>RSA</small> key generation to <i>bits</i>. If not
specified 2048 bits is used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set1_rsa_keygen_pubexp()</b>
sets the public exponent value for <small>RSA</small> key
generation to the value stored in <i>pubexp</i>. Currently
it should be an odd integer. In accordance with the OpenSSL
naming convention, the <i>pubexp</i> pointer must be freed
independently of the <small>EVP_PKEY_CTX</small> (ie, it is
internally copied). If not specified 65537 is used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_keygen_pubexp()</b>
does the same as
<b>EVP_PKEY_CTX_set1_rsa_keygen_pubexp()</b> except that
there is no internal copy and therefore <i>pubexp</i> should
not be modified or freed after the call.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_keygen_primes()</b>
sets the number of primes for <small>RSA</small> key
generation to <i>primes</i>. If not specified 2 is used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_mgf1_md_name()</b>
sets the <small>MGF1</small> digest for <small>RSA</small>
padding schemes to the digest named <i>mdname</i>. If the
<small>RSA</small> algorithm implementation for the selected
provider supports it then the digest will be fetched using
the properties <i>mdprops</i>. If not explicitly set the
signing digest is used. The padding mode must have been set
to <b><small>RSA_PKCS1_OAEP_PADDING</small></b> or
<b><small>RSA_PKCS1_PSS_PADDING</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_mgf1_md()</b>
does the same as <b>EVP_PKEY_CTX_set_rsa_mgf1_md_name()</b>
except that the name of the digest is inferred from the
supplied <i>md</i> and it is not possible to specify any
properties.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_mgf1_md_name()</b>
gets the name of the <small>MGF1</small> digest algorithm
for <i>ctx</i>. If not explicitly set the signing digest is
used. The padding mode must have been set to
<b><small>RSA_PKCS1_OAEP_PADDING</small></b> or
<b><small>RSA_PKCS1_PSS_PADDING</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_mgf1_md()</b>
does the same as <b>EVP_PKEY_CTX_get_rsa_mgf1_md_name()</b>
except that it returns a pointer to an <small>EVP_MD</small>
object instead. Note that only known, built-in
<small>EVP_MD</small> objects will be returned. The
<small>EVP_MD</small> object may be <small>NULL</small> if
the digest is not one of these (such as a digest only
implemented in a third party provider).</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_oaep_md_name()</b>
sets the message digest type used in <small>RSA OAEP</small>
to the digest named <i>mdname</i>. If the <small>RSA</small>
algorithm implementation for the selected provider supports
it then the digest will be fetched using the properties
<i>mdprops</i>. The padding mode must have been set to
<b><small>RSA_PKCS1_OAEP_PADDING</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_oaep_md()</b>
does the same as <b>EVP_PKEY_CTX_set_rsa_oaep_md_name()</b>
except that the name of the digest is inferred from the
supplied <i>md</i> and it is not possible to specify any
properties.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_oaep_md_name()</b>
gets the message digest algorithm name used in <small>RSA
OAEP</small> and stores it in the buffer <i>name</i> which
is of size <i>namelen</i>. The padding mode must have been
set to <b><small>RSA_PKCS1_OAEP_PADDING</small></b> . The
buffer should be sufficiently large for any expected digest
algorithm names or the function will fail.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_oaep_md()</b>
does the same as <b>EVP_PKEY_CTX_get_rsa_oaep_md_name()</b>
except that it returns a pointer to an <small>EVP_MD</small>
object instead. Note that only known, built-in
<small>EVP_MD</small> objects will be returned. The
<small>EVP_MD</small> object may be <small>NULL</small> if
the digest is not one of these (such as a digest only
implemented in a third party provider).</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set0_rsa_oaep_label()</b>
sets the <small>RSA OAEP</small> label to binary data
<i>label</i> and its length in bytes to <i>len</i>. If
<i>label</i> is <small>NULL</small> or <i>len</i> is 0, the
label is cleared. The library takes ownership of the label
so the caller should not free the original memory pointed to
by <i>label</i>. The padding mode must have been set to
<b><small>RSA_PKCS1_OAEP_PADDING</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get0_rsa_oaep_label()</b>
gets the <small>RSA OAEP</small> label to <i>label</i>. The
return value is the label length. The padding mode must have
been set to <b><small>RSA_PKCS1_OAEP_PADDING</small></b> .
The resulting pointer is owned by the library and should not
be freed by the caller.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>RSA_PKCS1_WITH_TLS_PADDING</small></b>
is used when decrypting an <small>RSA</small> encrypted
<small>TLS</small> pre-master secret in a <small>TLS</small>
ClientKeyExchange message. It is the same as
<small>RSA_PKCS1_PADDING</small> except that it additionally
verifies that the result is the correct length and the first
two bytes are the protocol version initially requested by
the client. If the encrypted content is publicly invalid
then the decryption will fail. However, if the padding
checks fail then decryption will still appear to succeed but
a random <small>TLS</small> premaster secret will be
returned instead. This padding mode accepts two parameters
which can be set using the <b>EVP_PKEY_CTX_set_params</b>(3)
function. These are
<small>OSSL_ASYM_CIPHER_PARAM_TLS_CLIENT_VERSION</small> and
<small>OSSL_ASYM_CIPHER_PARAM_TLS_NEGOTIATED_VERSION,</small>
both of which are expected to be unsigned integers. Normally
only the first of these will be set and represents the
<small>TLS</small> protocol version that was first requested
by the client (e.g. 0x0303 for TLSv1.2, 0x0302 for TLSv1.1
etc). Historically some buggy clients would use the
negotiated protocol version instead of the protocol version
first requested. If this behaviour should be tolerated then
<small>OSSL_ASYM_CIPHER_PARAM_TLS_NEGOTIATED_VERSION</small>
should be set to the actual negotiated protocol version.
Otherwise it should be left unset.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DSA</small>
parameters <br>
EVP_PKEY_CTX_set_dsa_paramgen_bits()</b> sets the number of
bits used for <small>DSA</small> parameter generation to
<b>nbits</b>. If not specified, 2048 is used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_q_bits()</b>
sets the number of bits in the subprime parameter <i>q</i>
for <small>DSA</small> parameter generation to <i>qbits</i>.
If not specified, 224 is used. If a digest function is
specified below, this parameter is ignored and instead, the
number of bits in <i>q</i> matches the size of the
digest.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_md()</b>
sets the digest function used for <small>DSA</small>
parameter generation to <i>md</i>. If not specified, one of
<small>SHA&minus;1, SHA&minus;224,</small> or
<small>SHA&minus;256</small> is selected to match the bit
length of <i>q</i> above.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_md_props()</b>
sets the digest function used for <small>DSA</small>
parameter generation using <i>md_name</i> and
<i>md_properties</i> to retrieve the digest from a provider.
If not specified, <i>md_name</i> will be set to one of
<small>SHA&minus;1, SHA&minus;224,</small> or
<small>SHA&minus;256</small> depending on the bit length of
<i>q</i> above. <i>md_properties</i> is a property query
string that has a default value of &rsquo;&rsquo; if not
specified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_gindex()</b>
sets the <i>gindex</i> used by the generator G. The default
value is &minus;1 which uses unverifiable g, otherwise a
positive value uses verifiable g. This value must be saved
if key validation of g is required, since it is not part of
a persisted key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_seed()</b>
sets the <i>seed</i> to use for generation rather than using
a randomly generated value for the seed. This is useful for
testing purposes only and can fail if the seed does not
produce primes for both p &amp; q on its first iteration.
This value must be saved if key validation of p, q, and
verifiable g are required, since it is not part of a
persisted key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_type()</b>
sets the generation type to use
<small>FIPS186&minus;4</small> generation if <i>name</i> is
&quot;fips186_4&quot;, or <small>FIPS186&minus;2</small>
generation if <i>name</i> is &quot;fips186_2&quot;. The
default value for the default provider is
&quot;fips186_2&quot;. The default value for the
<small>FIPS</small> provider is &quot;fips186_4&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DH</small>
parameters <br>
EVP_PKEY_CTX_set_dh_paramgen_prime_len()</b> sets the length
of the <small>DH</small> prime parameter <i>p</i> for
<small>DH</small> parameter generation. If this function is
not called then 2048 is used. Only accepts lengths greater
than or equal to 256.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_subprime_len()</b>
sets the length of the <small>DH</small> optional subprime
parameter <i>q</i> for <small>DH</small> parameter
generation. The default is 256 if the prime is at least 2048
bits long or 160 otherwise. The <small>DH</small> paramgen
type must have been set to &quot;fips186_4&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_generator()</b>
sets <small>DH</small> generator to <i>gen</i> for
<small>DH</small> parameter generation. If not specified 2
is used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_type()</b>
sets the key type for <small>DH</small> parameter
generation. The supported parameters are: <b><small><br>
DH_PARAMGEN_TYPE_GROUP</small></b></p>

<p style="margin-left:17%;">Use a named group. If only the
safe prime parameter <i>p</i> is set this can be used to
select a ffdhe safe prime group of the correct size.</p>


<p style="margin-left:11%;"><b><small>DH_PARAMGEN_TYPE_FIPS_186_4</small></b></p>

<p style="margin-left:17%;"><small>FIPS186&minus;4
FFC</small> parameter generator.</p>


<p style="margin-left:11%;"><b><small>DH_PARAMGEN_TYPE_FIPS_186_2</small></b></p>

<p style="margin-left:17%;"><small>FIPS186&minus;2
FFC</small> parameter generator (X9.42 <small>DH</small>
).</p>


<p style="margin-left:11%;"><b><small>DH_PARAMGEN_TYPE_GENERATOR</small></b></p>

<p style="margin-left:17%;">Uses a safe prime generator g
(PKCS#3 format).</p>

<p style="margin-left:11%; margin-top: 1em">The default in
the default provider is
<b><small>DH_PARAMGEN_TYPE_GENERATOR</small></b> for the
&quot; <small>DH&quot;</small> keytype, and
<b><small>DH_PARAMGEN_TYPE_FIPS_186_2</small></b> for the
&quot; <small>DHX&quot;</small> keytype. In the
<small>FIPS</small> provider the default value is
<b><small>DH_PARAMGEN_TYPE_GROUP</small></b> for the &quot;
<small>DH&quot;</small> keytype and &lt;
<b><small>DH_PARAMGEN_TYPE_FIPS_186_4</small></b> for the
&quot; <small>DHX&quot;</small> keytype.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_gindex()</b>
sets the <i>gindex</i> used by the generator G. The default
value is &minus;1 which uses unverifiable g, otherwise a
positive value uses verifiable g. This value must be saved
if key validation of g is required, since it is not part of
a persisted key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_seed()</b>
sets the <i>seed</i> to use for generation rather than using
a randomly generated value for the seed. This is useful for
testing purposes only and can fail if the seed does not
produce primes for both p &amp; q on its first iteration.
This value must be saved if key validation of p, q, and
verifiable g are required, since it is not part of a
persisted key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_pad()</b>
sets the <small>DH</small> padding mode. If <i>pad</i> is 1
the shared secret is padded with zeros up to the size of the
<small>DH</small> prime <i>p</i>. If <i>pad</i> is zero (the
default) then no padding is performed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_nid()</b>
sets the <small>DH</small> parameters to values
corresponding to <i>nid</i> as defined in
<small>RFC7919</small> or <small>RFC3526.</small> The
<i>nid</i> parameter must be <b>NID_ffdhe2048</b>,
<b>NID_ffdhe3072</b>, <b>NID_ffdhe4096</b>,
<b>NID_ffdhe6144</b>, <b>NID_ffdhe8192</b>,
<b>NID_modp_1536</b>, <b>NID_modp_2048</b>,
<b>NID_modp_3072</b>, <b>NID_modp_4096</b>,
<b>NID_modp_6144</b>, <b>NID_modp_8192</b> or
<b>NID_undef</b> to clear the stored value. This function
can be called during parameter or key generation. The nid
parameter and the rfc5114 parameter are mutually
exclusive.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_rfc5114()</b>
and <b>EVP_PKEY_CTX_set_dhx_rfc5114()</b> both set the
<small>DH</small> parameters to the values defined in
<small>RFC5114.</small> The <i>rfc5114</i> parameter must be
1, 2 or 3 corresponding to <small>RFC5114</small> sections
2.1, 2.2 and 2.3. or 0 to clear the stored value. This macro
can be called during parameter generation. The <i>ctx</i>
must have a key type of <b><small>EVP_PKEY_DHX</small></b> .
The rfc5114 parameter and the nid parameter are mutually
exclusive.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>DH</small>
key derivation function parameters</b> <br>
Note that all of the following functions require that the
<i>ctx</i> parameter has a private key type of
<b><small>EVP_PKEY_DHX</small></b> . When using key
derivation, the output of <b>EVP_PKEY_derive()</b> is the
output of the <small>KDF</small> instead of the
<small>DH</small> shared secret. The <small>KDF</small>
output is typically used as a Key Encryption Key (
<small>KEK</small> ) that in turn encrypts a Content
Encryption Key ( <small>CEK</small> ).</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_kdf_type()</b>
sets the key derivation function type to <i>kdf</i> for
<small>DH</small> key derivation. Possible values are
<b><small>EVP_PKEY_DH_KDF_NONE</small></b> and
<b><small>EVP_PKEY_DH_KDF_X9_42</small></b> which uses the
key derivation specified in <small>RFC2631</small> (based on
the keying algorithm described in X9.42). When using key
derivation, the <i>kdf_oid</i>, <i>kdf_md</i> and
<i>kdf_outlen</i> parameters must also be specified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_dh_kdf_type()</b>
gets the key derivation function type for <i>ctx</i> used
for <small>DH</small> key derivation. Possible values are
<b><small>EVP_PKEY_DH_KDF_NONE</small></b> and
<b><small>EVP_PKEY_DH_KDF_X9_42</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set0_dh_kdf_oid()</b>
sets the key derivation function object identifier to
<i>oid</i> for <small>DH</small> key derivation. This
<small>OID</small> should identify the algorithm to be used
with the Content Encryption Key. The library takes ownership
of the object identifier so the caller should not free the
original memory pointed to by <i>oid</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get0_dh_kdf_oid()</b>
gets the key derivation function oid for <i>ctx</i> used for
<small>DH</small> key derivation. The resulting pointer is
owned by the library and should not be freed by the
caller.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_kdf_md()</b>
sets the key derivation function message digest to <i>md</i>
for <small>DH</small> key derivation. Note that
<small>RFC2631</small> specifies that this digest should be
<small>SHA1</small> but OpenSSL tolerates other digests.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_dh_kdf_md()</b>
gets the key derivation function message digest for
<i>ctx</i> used for <small>DH</small> key derivation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_kdf_outlen()</b>
sets the key derivation function output length to <i>len</i>
for <small>DH</small> key derivation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_dh_kdf_outlen()</b>
gets the key derivation function output length for
<i>ctx</i> used for <small>DH</small> key derivation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set0_dh_kdf_ukm()</b>
sets the user key material to <i>ukm</i> and its length to
<i>len</i> for <small>DH</small> key derivation. This
parameter is optional and corresponds to the partyAInfo
field in <small>RFC2631</small> terms. The specification
requires that it is 512 bits long but this is not enforced
by OpenSSL. The library takes ownership of the user key
material so the caller should not free the original memory
pointed to by <i>ukm</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get0_dh_kdf_ukm()</b>
gets the user key material for <i>ctx</i>. The return value
is the user key material length. The resulting pointer is
owned by the library and should not be freed by the
caller.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>EC</small>
parameters</b> <br>
Use <b>EVP_PKEY_CTX_set_group_name()</b> (described above)
to set the curve name to <i>name</i> for parameter and key
generation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ec_paramgen_curve_nid()</b>
does the same as <b>EVP_PKEY_CTX_set_group_name()</b>, but
is specific to <small>EC</small> and uses a <i>nid</i>
rather than a name string.</p>

<p style="margin-left:11%; margin-top: 1em">For
<small>EC</small> parameter generation, one of
<b>EVP_PKEY_CTX_set_group_name()</b> or
<b>EVP_PKEY_CTX_set_ec_paramgen_curve_nid()</b> must be
called or an error occurs because there is no default curve.
These function can also be called to set the curve
explicitly when generating an <small>EC</small> key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_group_name()</b>
(described above) can be used to obtain the curve name
that&rsquo;s currently set with <i>ctx</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ec_param_enc()</b>
sets the <small>EC</small> parameter encoding to
<i>param_enc</i> when generating <small>EC</small>
parameters or an <small>EC</small> key. The encoding can be
<b><small>OPENSSL_EC_EXPLICIT_CURVE</small></b> for explicit
parameters (the default in versions of OpenSSL before 1.1.0)
or <b><small>OPENSSL_EC_NAMED_CURVE</small></b> to use named
curve form. For maximum compatibility the named curve form
should be used. Note: the
<b><small>OPENSSL_EC_NAMED_CURVE</small></b> value was added
in OpenSSL 1.1.0; previous versions should use 0
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ECDH</small>
parameters <br>
EVP_PKEY_CTX_set_ecdh_cofactor_mode()</b> sets the cofactor
mode to <i>cofactor_mode</i> for <small>ECDH</small> key
derivation. Possible values are 1 to enable cofactor key
derivation, 0 to disable it and &minus;1 to clear the stored
cofactor mode and fallback to the private key cofactor
mode.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_ecdh_cofactor_mode()</b>
returns the cofactor mode for <i>ctx</i> used for
<small>ECDH</small> key derivation. Possible values are 1
when cofactor key derivation is enabled and 0 otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ECDH</small>
key derivation function parameters <br>
EVP_PKEY_CTX_set_ecdh_kdf_type()</b> sets the key derivation
function type to <i>kdf</i> for <small>ECDH</small> key
derivation. Possible values are
<b><small>EVP_PKEY_ECDH_KDF_NONE</small></b> and
<b><small>EVP_PKEY_ECDH_KDF_X9_63</small></b> which uses the
key derivation specified in X9.63. When using key
derivation, the <i>kdf_md</i> and <i>kdf_outlen</i>
parameters must also be specified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_ecdh_kdf_type()</b>
returns the key derivation function type for <i>ctx</i> used
for <small>ECDH</small> key derivation. Possible values are
<b><small>EVP_PKEY_ECDH_KDF_NONE</small></b> and
<b><small>EVP_PKEY_ECDH_KDF_X9_63</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ecdh_kdf_md()</b>
sets the key derivation function message digest to <i>md</i>
for <small>ECDH</small> key derivation. Note that X9.63
specifies that this digest should be <small>SHA1</small> but
OpenSSL tolerates other digests.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_ecdh_kdf_md()</b>
gets the key derivation function message digest for
<i>ctx</i> used for <small>ECDH</small> key derivation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ecdh_kdf_outlen()</b>
sets the key derivation function output length to <i>len</i>
for <small>ECDH</small> key derivation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_ecdh_kdf_outlen()</b>
gets the key derivation function output length for
<i>ctx</i> used for <small>ECDH</small> key derivation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set0_ecdh_kdf_ukm()</b>
sets the user key material to <i>ukm</i> for
<small>ECDH</small> key derivation. This parameter is
optional and corresponds to the shared info in X9.63 terms.
The library takes ownership of the user key material so the
caller should not free the original memory pointed to by
<i>ukm</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get0_ecdh_kdf_ukm()</b>
gets the user key material for <i>ctx</i>. The return value
is the user key material length. The resulting pointer is
owned by the library and should not be freed by the
caller.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Other
parameters <br>
EVP_PKEY_CTX_set1_id()</b>, <b>EVP_PKEY_CTX_get1_id()</b>
and <b>EVP_PKEY_CTX_get1_id_len()</b> are used to manipulate
the special identifier field for specific signature
algorithms such as <small>SM2.</small> The
<b>EVP_PKEY_CTX_set1_id()</b> sets an <small>ID</small>
pointed by <i>id</i> with the length <i>id_len</i> to the
library. The library takes a copy of the id so that the
caller can safely free the original memory pointed to by
<i>id</i>. <b>EVP_PKEY_CTX_get1_id_len()</b> returns the
length of the <small>ID</small> set via a previous call to
<b>EVP_PKEY_CTX_set1_id()</b>. The length is usually used to
allocate adequate memory for further calls to
<b>EVP_PKEY_CTX_get1_id()</b>. <b>EVP_PKEY_CTX_get1_id()</b>
returns the previously set <small>ID</small> value to caller
in <i>id</i>. The caller should allocate adequate memory
space for the <i>id</i> before calling
<b>EVP_PKEY_CTX_get1_id()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_kem_op()</b>
sets the <small>KEM</small> operation to run. This can be
set after <b>EVP_PKEY_encapsulate_init()</b> or
<b>EVP_PKEY_decapsulate_init()</b> to select the kem
operation. <small>RSA</small> is the only key type that
supports encapsulation currently, and as there is no default
operation for the <small>RSA</small> type, this function
must be called before <b>EVP_PKEY_encapsulate()</b> or
<b>EVP_PKEY_decapsulate()</b>.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All other
functions described on this page return a positive value for
success and 0 or a negative value for failure. In particular
a return value of &minus;2 indicates the operation is not
supported by the public key algorithm.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_params</b>(3),
<b>EVP_PKEY_CTX_new</b>(3), <b>EVP_PKEY_encrypt</b>(3),
<b>EVP_PKEY_decrypt</b>(3), <b>EVP_PKEY_sign</b>(3),
<b>EVP_PKEY_verify</b>(3),
<b>EVP_PKEY_verify_recover</b>(3),
<b>EVP_PKEY_derive</b>(3), <b>EVP_PKEY_keygen</b>(3)
<b>EVP_PKEY_encapsulate</b>(3)
<b>EVP_PKEY_decapsulate</b>(3)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_oaep_md_name()</b>,
<b>EVP_PKEY_CTX_get_rsa_mgf1_md_name()</b>,
<b>EVP_PKEY_CTX_set_rsa_mgf1_md_name()</b>,
<b>EVP_PKEY_CTX_set_rsa_oaep_md_name()</b>,
<b>EVP_PKEY_CTX_set_dsa_paramgen_md_props()</b>,
<b>EVP_PKEY_CTX_set_dsa_paramgen_gindex()</b>,
<b>EVP_PKEY_CTX_set_dsa_paramgen_type()</b>,
<b>EVP_PKEY_CTX_set_dsa_paramgen_seed()</b>,
<b>EVP_PKEY_CTX_set_group_name()</b> and
<b>EVP_PKEY_CTX_get_group_name()</b> were added in OpenSSL
3.0.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_PKEY_CTX_set1_id()</b>, <b>EVP_PKEY_CTX_get1_id()</b>
and <b>EVP_PKEY_CTX_get1_id_len()</b> macros were added in
1.1.1, other functions were added in OpenSSL 1.0.0.</p>

<p style="margin-left:11%; margin-top: 1em">In OpenSSL
1.1.1 and below the functions were mostly macros. From
OpenSSL 3.0 they are all functions.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_keygen_pubexp()</b>,
<b>EVP_PKEY_CTX_get0_dh_kdf_ukm()</b>, and
<b>EVP_PKEY_CTX_get0_ecdh_kdf_ukm()</b> were deprecated in
OpenSSL 3.0.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2006&minus;2021 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
