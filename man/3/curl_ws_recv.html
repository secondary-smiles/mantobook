<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:28 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>curl_ws_recv</title>

</head>
<body>
<h1>curl_ws_recv</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">curl_ws_recv -
receive WebSocket data</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;curl/easy.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">CURLcode
curl_ws_recv(CURL *curl, void *buffer, size_t buflen, <br>
size_t *recv, struct curl_ws_frame **meta);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This function
call is EXPERIMENTAL.</p>

<p style="margin-left:11%; margin-top: 1em">Retrieves as
much as possible of a received WebSocket data fragment into
the <b>buffer</b>, but not more than <b>buflen</b> bytes.
<i>recv</i> is set to the number of bytes actually
stored.</p>

<p style="margin-left:11%; margin-top: 1em">If there is
more fragment data to deliver than what fits in the provided
<i>buffer</i>, libcurl returns a full buffer and the
application needs to call this function again to continue
draining the buffer.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>meta</i>
pointer gets set to point to a <i>struct curl_ws_frame</i>
that contains information about the received data. See the
<i>curl_ws_meta(3)</i> for details on that struct.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">size_t rlen;
<br>
struct curl_ws_frame *meta; <br>
char buffer[256]; <br>
CURLcode result = curl_ws_recv(curl, buffer, sizeof(buffer),
&amp;rlen, &amp;meta);</p>

<h2>AVAILABILITY
<a name="AVAILABILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Added in
7.86.0.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Returns
<b>CURLE_OK</b> if everything is okay, and a non-zero number
for errors. Returns <b>CURLE_GOT_NOTHING</b> if the
associated connection is closed.</p>

<p style="margin-left:11%; margin-top: 1em">Instead of
blocking, the function returns <b>CURLE_AGAIN</b>. The
correct behavior is then to wait for the socket to signal
readability before calling this function again.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>curl_easy_setopt</b>(3),
<b>curl_easy_perform</b>(3), <b>curl_easy_getinfo</b>(3),
<b>curl_ws_send</b>(3)</p>
<hr>
</body>
</html>
