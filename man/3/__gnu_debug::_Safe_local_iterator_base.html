<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:12 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__gnu_debug::_Safe_local_iterator_base</title>

</head>
<body>
<h1>__gnu_debug::_Safe_local_iterator_base</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">__gnu_debug::_Safe_local_iterator_base
&minus; Basic functionality for a <i>safe</i> iterator.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;safe_unordered_base.h&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
<b>__gnu_debug::_Safe_iterator_base</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Inherited by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">bool <b>_M_attached_to</b>
(const <b>_Safe_sequence_base</b> *__seq) const <br>
bool <b>_M_can_compare</b> (const <b>_Safe_iterator_base</b>
&amp;__x) const throw () <br>
void <b>_M_invalidate</b> () <br>
void <b>_M_reset</b> () throw () <br>
bool <b>_M_singular</b> () const throw () <br>
void <b>_M_unlink</b> () throw ()</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Attributes</b></p>

<p style="margin-left:17%;"><b>_Safe_iterator_base</b> *
<b>_M_next <br>
_Safe_iterator_base</b> * <b>_M_prior <br>
_Safe_sequence_base</b> * <b>_M_sequence</b> <br>
unsigned int <b>_M_version</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>


<p style="margin-left:17%;"><b>_Safe_local_iterator_base</b>
() <b><br>
_Safe_local_iterator_base</b> (const
<b>_Safe_local_iterator_base</b> &amp;__x, bool __constant)
<b><br>
_Safe_local_iterator_base</b> (const
<b>_Safe_sequence_base</b> *__seq, bool __constant) <br>
void <b>_M_attach</b> (<b>_Safe_sequence_base</b> *__seq,
bool __constant) <br>
void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b>
*__seq, bool __constant) throw () <br>
void <b>_M_detach</b> () <br>
void <b>_M_detach_single</b> () throw () <b><br>
_Safe_unordered_container_base</b> * <b>_M_get_container</b>
() const noexcept <br>
__gnu_cxx::__mutex &amp; <b>_M_get_mutex</b> () throw ()</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Basic
functionality for a <i>safe</i> iterator.</p>

<p style="margin-left:11%; margin-top: 1em">The
_Safe_local_iterator_base base class implements the
functionality of a safe local iterator that is not specific
to a particular iterator type. It contains a pointer back to
the container it references along with iterator version
information and pointers to form a doubly-linked list of
local iterators referenced by the container.</p>

<p style="margin-left:11%; margin-top: 1em">This class must
not perform any operations that can throw an exception, or
the exception guarantees of derived iterators will be
broken.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base
()</b> <tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Initializes the iterator and makes it singular.</p>


<p style="margin-left:11%; margin-top: 1em"><b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base
(const _Safe_sequence_base * __seq, bool __constant)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Initialize the iterator to reference the container pointed
to by <tt>__seq</tt>. <tt>__constant</tt> is true when we
are initializing a constant local iterator, and false if it
is a mutable local iterator. Note that <tt>__seq</tt> may be
NULL, in which case the iterator will be singular.
Otherwise, the iterator will reference <tt>__seq</tt> and be
nonsingular.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>_M_attach()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base
(const _Safe_local_iterator_base &amp; __x, bool
__constant)</b> <tt>[inline]</tt><b>,</b>
<tt>[protected]</tt> <br>
Initializes the iterator to reference the same container
that <tt>__x</tt> does. <tt>__constant</tt> is true if this
is a constant iterator, and false if it is mutable.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>_M_attach()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_local_iterator_base::_M_attach
(_Safe_sequence_base * __seq, bool __constant)</b>
<tt>[protected]</tt> <br>
Attaches this iterator to the given container, detaching it
from whatever container it was attached to originally. If
the new container is the NULL pointer, the iterator is left
unattached.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>_Safe_local_iterator_base()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_local_iterator_base::_M_attach_single
(_Safe_sequence_base * __seq, bool __constant)</b>
<tt>[protected]</tt> <br>
Likewise, but not thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach_single()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_attached_to (const
_Safe_sequence_base * __seq) const</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Determines if we are attached to the given sequence.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_can_compare (const
_Safe_iterator_base &amp; __x) const</b>
<tt>[inherited]</tt> <br>
Can we compare this iterator to the given iterator
<tt>__x</tt>? Returns true if both iterators are nonsingular
and reference the same sequence.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_local_iterator_base::_M_detach ()</b>
<tt>[protected]</tt> <br>
Detach the iterator for whatever container it is attached
to, if any.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_local_iterator_base::_M_detach_single
()</b> <tt>[protected]</tt> <br>
Likewise, but not thread-safe.</p>


<p style="margin-left:11%; margin-top: 1em"><b>__gnu_cxx::__mutex
&amp; __gnu_debug::_Safe_iterator_base::_M_get_mutex ()</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
For use in _Safe_iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator++()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator++()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_invalidate ()</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Invalidate the iterator, making it singular.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_reset ()</b>
<tt>[inherited]</tt> <br>
Reset all member variables</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_singular () const</b>
<tt>[inherited]</tt> <br>
Is this iterator singular?</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>,
<b>__gnu_debug::__check_singular_aux()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_dereferenceable()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_dereferenceable()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_incrementable()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_incrementable()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_unlink ()</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Unlink itself</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_next</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_prior</b>.</p>

<h2>Member Data Documentation
<a name="Member Data Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>_Safe_iterator_base*
__gnu_debug::_Safe_iterator_base::_M_next</b>
<tt>[inherited]</tt> <br>
Pointer to the next iterator in the sequence&rsquo;s list of
iterators. Only valid when _M_sequence != NULL.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_sequence&lt; _SafeSequence
&gt;::_M_invalidate_if()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>_Safe_iterator_base*
__gnu_debug::_Safe_iterator_base::_M_prior</b>
<tt>[inherited]</tt> <br>
Pointer to the previous iterator in the sequence&rsquo;s
list of iterators. Only valid when _M_sequence != NULL.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_sequence&lt; _SafeSequence
&gt;::_M_invalidate_if()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>_Safe_sequence_base*
__gnu_debug::_Safe_iterator_base::_M_sequence</b>
<tt>[inherited]</tt> <br>
The sequence this iterator references; may be NULL to
indicate a singular iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>,
<b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>,
<b>_Safe_local_iterator_base()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_attached_to()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>unsigned int
__gnu_debug::_Safe_iterator_base::_M_version</b>
<tt>[inherited]</tt> <br>
The version number of this iterator. The sentinel value 0 is
used to indicate an invalidated iterator (i.e., one that is
singular because of an operation on the container). This
version number must equal the version number in the sequence
referenced by _M_sequence for the iterator to be
non-singular.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator_base::_M_invalidate()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
