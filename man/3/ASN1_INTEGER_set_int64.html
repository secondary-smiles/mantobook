<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:17 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ASN1_INTEGER_GET_INT64</title>

</head>
<body>
<h1>ASN1_INTEGER_set_int64</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">ASN1_INTEGER_get_uint64,
ASN1_INTEGER_set_uint64, ASN1_INTEGER_get_int64,
ASN1_INTEGER_get, ASN1_INTEGER_set_int64, ASN1_INTEGER_set,
BN_to_ASN1_INTEGER, ASN1_INTEGER_to_BN,
ASN1_ENUMERATED_get_int64, ASN1_ENUMERATED_get,
ASN1_ENUMERATED_set_int64, ASN1_ENUMERATED_set,
BN_to_ASN1_ENUMERATED, ASN1_ENUMERATED_to_BN &minus; ASN.1
INTEGER and ENUMERATED utilities</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/asn1.h&gt; <br>
int ASN1_INTEGER_get_int64(int64_t *pr, const ASN1_INTEGER
*a); <br>
long ASN1_INTEGER_get(const ASN1_INTEGER *a); <br>
int ASN1_INTEGER_set_int64(ASN1_INTEGER *a, int64_t r); <br>
int ASN1_INTEGER_set(ASN1_INTEGER *a, long v); <br>
int ASN1_INTEGER_get_uint64(uint64_t *pr, const ASN1_INTEGER
*a); <br>
int ASN1_INTEGER_set_uint64(ASN1_INTEGER *a, uint64_t r);
<br>
ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn,
ASN1_INTEGER *ai); <br>
BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM
*bn); <br>
int ASN1_ENUMERATED_get_int64(int64_t *pr, const
ASN1_ENUMERATED *a); <br>
long ASN1_ENUMERATED_get(const ASN1_ENUMERATED *a); <br>
int ASN1_ENUMERATED_set_int64(ASN1_ENUMERATED *a, int64_t
r); <br>
int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v); <br>
ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(const BIGNUM *bn,
ASN1_ENUMERATED *ai); <br>
BIGNUM *ASN1_ENUMERATED_to_BN(const ASN1_ENUMERATED *ai,
BIGNUM *bn);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These functions
convert to and from <b><small>ASN1_INTEGER</small></b> and
<b><small>ASN1_ENUMERATED</small></b> structures.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_get_int64()</b>
converts an <b><small>ASN1_INTEGER</small></b> into an
<b>int64_t</b> type If successful it returns 1 and sets
<i>*pr</i> to the value of <i>a</i>. If it fails (due to
invalid type or the value being too big to fit into an
<b>int64_t</b> type) it returns 0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_get_uint64()</b>
is similar to <b>ASN1_INTEGER_get_int64_t()</b> except it
converts to a <b>uint64_t</b> type and an error is returned
if the passed integer is negative.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_get()</b>
also returns the value of <i>a</i> but it returns 0 if
<i>a</i> is <small>NULL</small> and &minus;1 on error (which
is ambiguous because &minus;1 is a legitimate value for an
<b><small>ASN1_INTEGER</small></b> ). New applications
should use <b>ASN1_INTEGER_get_int64()</b> instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_set_int64()</b>
sets the value of <b><small>ASN1_INTEGER</small></b>
<i>a</i> to the <b>int64_t</b> value <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_set_uint64()</b>
sets the value of <b><small>ASN1_INTEGER</small></b>
<i>a</i> to the <b>uint64_t</b> value <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_set()</b>
sets the value of <b><small>ASN1_INTEGER</small></b>
<i>a</i> to the <i>long</i> value <i>v</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_to_ASN1_INTEGER()</b>
converts <b><small>BIGNUM</small></b> <i>bn</i> to an
<b><small>ASN1_INTEGER</small></b> . If <i>ai</i> is
<small>NULL</small> a new <b><small>ASN1_INTEGER</small></b>
structure is returned. If <i>ai</i> is not
<small>NULL</small> then the existing structure will be used
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_to_BN()</b>
converts <small>ASN1_INTEGER</small> <i>ai</i> into a
<b><small>BIGNUM</small></b> . If <i>bn</i> is
<small>NULL</small> a new <b><small>BIGNUM</small></b>
structure is returned. If <i>bn</i> is not
<small>NULL</small> then the existing structure will be used
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_ENUMERATED_get_int64()</b>,
<b>ASN1_ENUMERATED_set_int64()</b>,
<b>ASN1_ENUMERATED_set()</b>, <b>BN_to_ASN1_ENUMERATED()</b>
and <b>ASN1_ENUMERATED_to_BN()</b> behave in an identical
way to their <small>ASN1_INTEGER</small> counterparts except
they operate on an <b><small>ASN1_ENUMERATED</small></b>
value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_ENUMERATED_get()</b>
returns the value of <i>a</i> in a similar way to
<b>ASN1_INTEGER_get()</b> but it returns <b>0xffffffffL</b>
if the value of <i>a</i> will not fit in a long type. New
applications should use <b>ASN1_ENUMERATED_get_int64()</b>
instead.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In general an
<b><small>ASN1_INTEGER</small></b> or
<b><small>ASN1_ENUMERATED</small></b> type can contain an
integer of almost arbitrary size and so cannot always be
represented by a C <b>int64_t</b> type. However, in many
cases (for example version numbers) they represent small
integers which can be more easily manipulated if converted
to an appropriate C integer type.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The ambiguous
return values of <b>ASN1_INTEGER_get()</b> and
<b>ASN1_ENUMERATED_get()</b> mean these functions should be
avoided if possible. They are retained for compatibility.
Normally the ambiguous return values are not legitimate
values for the fields they represent.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_set_int64()</b>,
<b>ASN1_INTEGER_set()</b>,
<b>ASN1_ENUMERATED_set_int64()</b> and
<b>ASN1_ENUMERATED_set()</b> return 1 for success and 0 for
failure. They will only fail if a memory allocation error
occurs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_get_int64()</b>
and <b>ASN1_ENUMERATED_get_int64()</b> return 1 for success
and 0 for failure. They will fail if the passed type is
incorrect (this will only happen if there is a programming
error) or if the value exceeds the range of an
<b>int64_t</b> type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_to_ASN1_INTEGER()</b>
and <b>BN_to_ASN1_ENUMERATED()</b> return an
<b><small>ASN1_INTEGER</small></b> or
<b><small>ASN1_ENUMERATED</small></b> structure respectively
or <small>NULL</small> if an error occurs. They will only
fail due to a memory allocation error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_to_BN()</b>
and <b>ASN1_ENUMERATED_to_BN()</b> return a
<b><small>BIGNUM</small></b> structure of
<small>NULL</small> if an error occurs. They can fail if the
passed type is incorrect (due to programming error) or due
to a memory allocation failure.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ERR_get_error</b>(3)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ASN1_INTEGER_set_int64()</b>,
<b>ASN1_INTEGER_get_int64()</b>,
<b>ASN1_ENUMERATED_set_int64()</b> and
<b>ASN1_ENUMERATED_get_int64()</b> were added in OpenSSL
1.1.0.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2015&minus;2021 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
