<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:14 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc &gt;</title>

</head>
<body>
<h1>std::unordered_set</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt; &minus; A standard
container composed of unique keys (containing at most one of
each key value) in which the elements&rsquo; keys are the
elements themselves.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;unordered_set&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">using <b>insert_return_type</b>
= typename _Hashtable::insert_return_type <br>
using <b>node_type</b> = typename _Hashtable::node_type</p>

<p style="margin-left:23%; margin-top: 1em">typedef
_Hashtable::key_type <b>key_type</b> <br>
Public typedefs. <br>
typedef _Hashtable::value_type <b>value_type</b> <br>
Public typedefs. <br>
typedef _Hashtable::hasher <b>hasher</b> <br>
Public typedefs. <br>
typedef _Hashtable::key_equal <b>key_equal</b> <br>
Public typedefs. <br>
typedef _Hashtable::allocator_type <b>allocator_type</b>
<br>
Public typedefs.</p>

<p style="margin-left:23%; margin-top: 1em">typedef
_Hashtable::pointer <b>pointer</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::const_pointer <b>const_pointer</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::reference <b>reference</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::const_reference <b>const_reference</b>
<br>
Iterator-related typedefs. <br>
typedef _Hashtable::iterator <b>iterator</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::const_iterator <b>const_iterator</b>
<br>
Iterator-related typedefs. <br>
typedef _Hashtable::local_iterator <b>local_iterator</b>
<br>
Iterator-related typedefs. <br>
typedef _Hashtable::const_local_iterator
<b>const_local_iterator</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::size_type <b>size_type</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::difference_type <b>difference_type</b>
<br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>unordered_set</b> ()=default
<br>
Default constructor. <br>
template&lt;typename _InputIterator &gt;
<b>unordered_set</b> (_InputIterator __first, _InputIterator
__last, <b>size_type</b> __n, const <b>allocator_type</b>
&amp;__a) <br>
template&lt;typename _InputIterator &gt;
<b>unordered_set</b> (_InputIterator __first, _InputIterator
__last, <b>size_type</b> __n, const <b>hasher</b> &amp;__hf,
const <b>allocator_type</b> &amp;__a) <br>
template&lt;typename _InputIterator &gt;
<b>unordered_set</b> (_InputIterator __first, _InputIterator
__last, <b>size_type</b> __n=0, const <b>hasher</b>
&amp;__hf=<b>hasher</b>(), const <b>key_equal</b>
&amp;__eql=<b>key_equal</b>(), const <b>allocator_type</b>
&amp;__a=<b>allocator_type</b>()) <br>
Builds an unordered_set from a range. <b><br>
unordered_set</b> (const <b>allocator_type</b> &amp;__a)
<br>
Creates an unordered_set with no elements. <b><br>
unordered_set</b> (const <b>unordered_set</b> &amp;)=default
<br>
Copy constructor. <b><br>
unordered_set</b> (const <b>unordered_set</b> &amp;__uset,
const <b>allocator_type</b> &amp;__a) <b><br>
unordered_set</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l, <b>size_type</b> __n, const
<b>allocator_type</b> &amp;__a) <b><br>
unordered_set</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l, <b>size_type</b> __n, const
<b>hasher</b> &amp;__hf, const <b>allocator_type</b>
&amp;__a) <b><br>
unordered_set</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l, <b>size_type</b> __n=0, const
<b>hasher</b> &amp;__hf=<b>hasher</b>(), const
<b>key_equal</b> &amp;__eql=<b>key_equal</b>(), const
<b>allocator_type</b> &amp;__a=<b>allocator_type</b>()) <br>
Builds an unordered_set from an initializer_list. <b><br>
unordered_set</b> (<b>size_type</b> __n, const
<b>allocator_type</b> &amp;__a) <b><br>
unordered_set</b> (<b>size_type</b> __n, const <b>hasher</b>
&amp;__hf, const <b>allocator_type</b> &amp;__a) <b><br>
unordered_set</b> (<b>size_type</b> __n, const <b>hasher</b>
&amp;__hf=<b>hasher</b>(), const <b>key_equal</b>
&amp;__eql=<b>key_equal</b>(), const <b>allocator_type</b>
&amp;__a=<b>allocator_type</b>()) <br>
Default constructor creates no elements. <b><br>
unordered_set</b> (<b>unordered_set</b> &amp;&amp;)=default
<br>
Move constructor. <b><br>
unordered_set</b> (<b>unordered_set</b> &amp;&amp;__uset,
const <b>allocator_type</b> &amp;__a)
noexcept(noexcept(_Hashtable(<b>std::move</b>(__uset._M_h),
__a))) <b><br>
size_type bucket</b> (const <b>key_type</b> &amp;__key)
const <b><br>
size_type bucket_count</b> () const noexcept <br>
Returns the number of buckets of the unordered_set. <b><br>
size_type bucket_size</b> (<b>size_type</b> __n) const
<b><br>
const_iterator cbegin</b> () const noexcept <b><br>
const_iterator cend</b> () const noexcept <br>
void <b>clear</b> () noexcept <br>
template&lt;typename... _Args&gt; <b>std::pair</b>&lt;
<b>iterator</b>, bool &gt; <b>emplace</b> (_Args
&amp;&amp;... __args) <br>
Attempts to build and insert an element into the
unordered_set. <br>
template&lt;typename... _Args&gt; <b>iterator
emplace_hint</b> (<b>const_iterator</b> __pos, _Args
&amp;&amp;... __args) <br>
Attempts to insert an element into the unordered_set. <br>
bool <b>empty</b> () const noexcept <br>
Returns true if the unordered_set is empty. <b><br>
size_type erase</b> (const <b>key_type</b> &amp;__x) <br>
Erases elements according to the provided key. <b><br>
iterator erase</b> (<b>const_iterator</b> __first,
<b>const_iterator</b> __last) <br>
Erases a [__first,__last) range of elements from an
unordered_set. <br>
node_type <b>extract</b> (const <b>key_type</b> &amp;__key)
<br>
Extract a node. <br>
node_type <b>extract</b> (<b>const_iterator</b> __pos) <br>
Extract a node. <b><br>
allocator_type get_allocator</b> () const noexcept <br>
Returns the allocator object used by the unordered_set.
<b><br>
hasher hash_function</b> () const <br>
Returns the hash functor object with which the unordered_set
was constructed. <br>
template&lt;typename _InputIterator &gt; void <b>insert</b>
(_InputIterator __first, _InputIterator __last) <br>
A template function that attempts to insert a range of
elements. <b><br>
iterator insert</b> (<b>const_iterator</b>, node_type
&amp;&amp;__nh) <br>
Re-insert an extracted node. <br>
void <b>insert</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l) <br>
Attempts to insert a list of elements into the
unordered_set. <br>
insert_return_type <b>insert</b> (node_type &amp;&amp;__nh)
<br>
Re-insert an extracted node. <b><br>
key_equal key_eq</b> () const <br>
Returns the key comparison object with which the
unordered_set was constructed. <br>
float <b>load_factor</b> () const noexcept <br>
Returns the average number of elements per bucket. <b><br>
size_type max_bucket_count</b> () const noexcept <br>
Returns the maximum number of buckets of the unordered_set.
<br>
float <b>max_load_factor</b> () const noexcept <br>
Returns a positive number that the unordered_set tries to
keep the load factor less than or equal to. <br>
void <b>max_load_factor</b> (float __z) <br>
Change the unordered_set maximum load factor. <b><br>
size_type max_size</b> () const noexcept <br>
Returns the maximum size of the unordered_set. <br>
template&lt;typename _H2 , typename _P2 &gt; void
<b>merge</b> (<b>unordered_multiset</b>&lt; _Value, _H2,
_P2, _Alloc &gt; &amp;&amp;__source) <br>
template&lt;typename _H2 , typename _P2 &gt; void
<b>merge</b> (<b>unordered_multiset</b>&lt; _Value, _H2,
_P2, _Alloc &gt; &amp;__source) <br>
template&lt;typename _H2 , typename _P2 &gt; void
<b>merge</b> (<b>unordered_set</b>&lt; _Value, _H2, _P2,
_Alloc &gt; &amp;&amp;__source) <br>
template&lt;typename _H2 , typename _P2 &gt; void
<b>merge</b> (<b>unordered_set</b>&lt; _Value, _H2, _P2,
_Alloc &gt; &amp;__source) <b><br>
unordered_set</b> &amp; <b>operator=</b> (const
<b>unordered_set</b> &amp;)=default <br>
Copy assignment operator. <b><br>
unordered_set</b> &amp; <b>operator=</b>
(<b>initializer_list</b>&lt; <b>value_type</b> &gt; __l)
<br>
Unordered_set list assignment operator. <b><br>
unordered_set</b> &amp; <b>operator=</b>
(<b>unordered_set</b> &amp;&amp;)=default <br>
Move assignment operator. <br>
void <b>rehash</b> (<b>size_type</b> __n) <br>
May rehash the unordered_set. <br>
void <b>reserve</b> (<b>size_type</b> __n) <br>
Prepare the unordered_set for a specified number of
elements. <b><br>
size_type size</b> () const noexcept <br>
Returns the size of the unordered_set. <br>
void <b>swap</b> (<b>unordered_set</b> &amp;__x)
noexcept(noexcept(_M_h.swap(__x._M_h))) <br>
Swaps data with another unordered_set.</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
begin</b> () noexcept <b><br>
const_iterator begin</b> () const noexcept</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
end</b> () noexcept <b><br>
const_iterator end</b> () const noexcept</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
<b>iterator</b>, bool &gt; <b>insert</b> (const
<b>value_type</b> &amp;__x) <br>
Attempts to insert an element into the unordered_set.
<b><br>
std::pair</b>&lt; <b>iterator</b>, bool &gt; <b>insert</b>
(<b>value_type</b> &amp;&amp;__x) <br>
Attempts to insert an element into the unordered_set.</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
insert</b> (<b>const_iterator</b> __hint, const
<b>value_type</b> &amp;__x) <br>
Attempts to insert an element into the unordered_set.
<b><br>
iterator insert</b> (<b>const_iterator</b> __hint,
<b>value_type</b> &amp;&amp;__x) <br>
Attempts to insert an element into the unordered_set.</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
erase</b> (<b>const_iterator</b> __position) <br>
Erases an element from an unordered_set. <b><br>
iterator erase</b> (<b>iterator</b> __position) <br>
Erases an element from an unordered_set.</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
find</b> (const <b>key_type</b> &amp;__x) <br>
Tries to locate an element in an unordered_set. <br>
template&lt;typename _Kt &gt; auto <b>find</b> (const _Kt
&amp;__k) &minus;&gt; decltype(_M_h._M_find_tr(__k)) <br>
Tries to locate an element in an unordered_set. <b><br>
const_iterator find</b> (const <b>key_type</b> &amp;__x)
const <br>
Tries to locate an element in an unordered_set. <br>
template&lt;typename _Kt &gt; auto <b>find</b> (const _Kt
&amp;__k) const &minus;&gt; decltype(_M_h._M_find_tr(__k))
<br>
Tries to locate an element in an unordered_set.</p>

<p style="margin-left:23%; margin-top: 1em"><b>size_type
count</b> (const <b>key_type</b> &amp;__x) const <br>
Finds the number of elements. <br>
template&lt;typename _Kt &gt; auto <b>count</b> (const _Kt
&amp;__k) const &minus;&gt; decltype(_M_h._M_count_tr(__k))
<br>
Finds the number of elements.</p>

<p style="margin-left:23%; margin-top: 1em">bool
<b>contains</b> (const <b>key_type</b> &amp;__x) const <br>
Finds whether an element with the given key exists. <br>
template&lt;typename _Kt &gt; auto <b>contains</b> (const
_Kt &amp;__k) const &minus;&gt;
decltype(_M_h._M_find_tr(__k), void(), true) <br>
Finds whether an element with the given key exists.</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
<b>iterator</b>, <b>iterator</b> &gt; <b>equal_range</b>
(const <b>key_type</b> &amp;__x) <br>
Finds a subsequence matching given key. <br>
template&lt;typename _Kt &gt; auto <b>equal_range</b> (const
_Kt &amp;__k) &minus;&gt;
decltype(_M_h._M_equal_range_tr(__k)) <br>
Finds a subsequence matching given key. <b><br>
std::pair</b>&lt; <b>const_iterator</b>,
<b>const_iterator</b> &gt; <b>equal_range</b> (const
<b>key_type</b> &amp;__x) const <br>
Finds a subsequence matching given key. <br>
template&lt;typename _Kt &gt; auto <b>equal_range</b> (const
_Kt &amp;__k) const &minus;&gt;
decltype(_M_h._M_equal_range_tr(__k)) <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:23%; margin-top: 1em"><b>local_iterator
begin</b> (<b>size_type</b> __n) <br>
Returns a read-only (constant) iterator pointing to the
first bucket element. <b><br>
const_local_iterator begin</b> (<b>size_type</b> __n) const
<br>
Returns a read-only (constant) iterator pointing to the
first bucket element. <b><br>
const_local_iterator cbegin</b> (<b>size_type</b> __n) const
<br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:23%; margin-top: 1em"><b>local_iterator
end</b> (<b>size_type</b> __n) <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements. <b><br>
const_local_iterator end</b> (<b>size_type</b> __n) const
<br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements. <b><br>
const_local_iterator cend</b> (<b>size_type</b> __n) const
<br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename _Value1 ,
typename _Hash1 , typename _Pred1 , typename _Alloc1 &gt;
bool <b>operator==</b> (const <b>unordered_set</b>&lt;
_Value1, _Hash1, _Pred1, _Alloc1 &gt; &amp;, const
<b>unordered_set</b>&lt; _Value1, _Hash1, _Pred1, _Alloc1
&gt; &amp;) <br>
template&lt;typename , typename , typename &gt; class
<b>std::_Hash_merge_helper</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value, typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt;</b> <br>
class std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;&quot;A standard container composed of unique keys
(containing at most one of each key value) in which the
elements&rsquo; keys are the elements themselves.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++11</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_Value</i> Type of key
objects. <i><br>
_Hash</i> Hashing function object type, defaults to
hash&lt;_Value&gt;. <i><br>
_Pred</i> Predicate function object type, defaults to
equal_to&lt;_Value&gt;. <i><br>
_Alloc</i> Allocator type, defaults to
allocator&lt;_Key&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Meets the
requirements of a <tt>container</tt>, and <tt>unordered
associative container</tt></p>

<p style="margin-left:11%; margin-top: 1em">Base is
_Hashtable, dispatched at compile time via template alias
__uset_hashtable.</p>

<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef
_Hashtable::allocator_type std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::allocator_type</b> <br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef
_Hashtable::const_iterator std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::const_iterator</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef
_Hashtable::const_local_iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::const_local_iterator</b>
<br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef
_Hashtable::const_pointer std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::const_pointer</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef
_Hashtable::const_reference std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::const_reference</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef
_Hashtable::difference_type std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::difference_type</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef _Hashtable::hasher
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::hasher</b> <br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef _Hashtable::iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::iterator</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef _Hashtable::key_equal
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::key_equal</b> <br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef _Hashtable::key_type
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::key_type</b> <br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef
_Hashtable::local_iterator std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::local_iterator</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef _Hashtable::pointer
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::pointer</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef _Hashtable::reference
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::reference</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef _Hashtable::size_type
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::size_type</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; typedef _Hashtable::value_type
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::value_type</b> <br>
Public typedefs.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::unordered_set ()</b>
<tt>[default]</tt> <br>
Default constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::unordered_set (size_type __n,
const hasher &amp; __hf = hasher</b><tt>()</tt><b>, const
key_equal &amp; __eql = key_equal</b><tt>()</tt><b>, const
allocator_type &amp; __a =
allocator_type</b><tt>()</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt> <br>
Default constructor creates no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> Minimal initial
number of buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename
_InputIterator &gt; std::unordered_set&lt; _Value, _Hash,
_Pred, _Alloc &gt;::unordered_set (_InputIterator __first,
_InputIterator __last, size_type __n =</b> <tt>0</tt><b>,
const hasher &amp; __hf = hasher</b><tt>()</tt><b>, const
key_equal &amp; __eql = key_equal</b><tt>()</tt><b>, const
allocator_type &amp; __a =
allocator_type</b><tt>()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds an unordered_set from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__n</i> Minimal initial number of buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create an
unordered_set consisting of copies of the elements from
[__first,__last). This is linear in N (where N is
distance(__first,__last)).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::unordered_set (const
unordered_set&lt; _Value, _Hash, _Pred, _Alloc &gt;
&amp;)</b> <tt>[default]</tt> <br>
Copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::unordered_set (unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt; &amp;&amp;)</b>
<tt>[default]</tt> <br>
Move constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::unordered_set (const
allocator_type &amp; __a)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
Creates an unordered_set with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> An allocator
object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::unordered_set
(initializer_list&lt; value_type &gt; __l, size_type __n
=</b> <tt>0</tt><b>, const hasher &amp; __hf =
hasher</b><tt>()</tt><b>, const key_equal &amp; __eql =
key_equal</b><tt>()</tt><b>, const allocator_type &amp; __a
= allocator_type</b><tt>()</tt><b>)</b> <tt>[inline]</tt>
<br>
Builds an unordered_set from an initializer_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list.
<i><br>
__n</i> Minimal initial number of buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create an
unordered_set consisting of copies of the elements in the
list. This is linear in N (where N is
<i>__l.size()</i>).</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::begin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::begin ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; local_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::begin (size_type __n)</b> <tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_local_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::begin (size_type __n) const</b> <tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; size_type std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::bucket_count () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of buckets of the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::cbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_local_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::cbegin (size_type __n) const</b> <tt>[inline]</tt>
<br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::cend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_local_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::cend (size_type __n) const</b> <tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; void std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::clear ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Erases all elements in an unordered_set. Note that this
function only erases the elements, and that if the elements
themselves are pointers, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename _Kt &gt;
auto std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::contains (const _Kt &amp; __k) const &minus;&gt;
decltype(_M_h._M_find_tr(__k), void(), true)</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds whether
an element with the given key exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of elements to
be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if there is any element
with the specified key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; bool std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::contains (const key_type
&amp; __x) const</b> <tt>[inline]</tt> <br>
Finds whether an element with the given key exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of elements to
be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if there is any element
with the specified key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename _Kt &gt;
auto std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::count (const _Kt &amp; __k) const &minus;&gt;
decltype(_M_h._M_count_tr(__k))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds the
number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Element to
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Number of elements with
specified key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
only makes sense for unordered_multisets; for unordered_set
the result will either be 0 (not present) or 1
(present).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; size_type std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::count (const key_type
&amp; __x) const</b> <tt>[inline]</tt> <br>
Finds the number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Element to
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Number of elements with
specified key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
only makes sense for unordered_multisets; for unordered_set
the result will either be 0 (not present) or 1
(present).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename...
_Args&gt; std::pair&lt; iterator, bool &gt;
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::emplace (_Args &amp;&amp;... __args)</b>
<tt>[inline]</tt> <br>
Attempts to build and insert an element into the
unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__args</i> Arguments used to
generate an element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
element, and the second is a bool that is true if the
element was actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to build and insert an element into the
unordered_set. An unordered_set relies on unique keys and
thus an element is only inserted if it is not already
present in the unordered_set.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename...
_Args&gt; iterator std::unordered_set&lt; _Value, _Hash,
_Pred, _Alloc &gt;::emplace_hint (const_iterator __pos,
_Args &amp;&amp;... __args)</b> <tt>[inline]</tt> <br>
Attempts to insert an element into the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> An iterator that
serves as a hint as to where the element should be inserted.
<i><br>
__args</i> Arguments used to generate the element to be
inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key equivalent to the one generated from
<i>__args</i> (may or may not be the element itself).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
emplace() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">For more on
<i>hinting</i>, see:
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; bool std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::empty () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns true if the unordered_set is empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::end () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::end ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the unordered_set.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::extract()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; local_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::end (size_type __n)</b> <tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_local_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::end (size_type __n) const</b> <tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename _Kt &gt;
auto std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::equal_range (const _Kt &amp; __k) &minus;&gt;
decltype(_M_h._M_equal_range_tr(__k))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds a
subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for multisets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename _Kt &gt;
auto std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::equal_range (const _Kt &amp; __k) const &minus;&gt;
decltype(_M_h._M_equal_range_tr(__k))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds a
subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for multisets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::pair&lt; iterator, iterator
&gt; std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::equal_range (const key_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for multisets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::pair&lt; const_iterator,
const_iterator &gt; std::unordered_set&lt; _Value, _Hash,
_Pred, _Alloc &gt;::equal_range (const key_type &amp; __x)
const</b> <tt>[inline]</tt> <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for multisets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; size_type std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::erase (const key_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Erases elements according to the provided key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of element to be
erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The number of elements
erased.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases all the elements located by the given key from an
unordered_set. For an unordered_set the result of this
function can only be 0 (not present) or 1 (present). Note
that this function only erases the element, and that if the
element is itself a pointer, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::erase (const_iterator
__first, const_iterator __last)</b> <tt>[inline]</tt> <br>
Erases a [__first,__last) range of elements from an
unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the start of the range to be erased. <i><br>
__last</i> Iterator pointing to the end of the range to be
erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The iterator <i>__last</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases a sequence of elements from an unordered_set. Note
that this function only erases the element, and that if the
element is itself a pointer, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::erase (const_iterator
__position)</b> <tt>[inline]</tt> <br>
Erases an element from an unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
pointing to the element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element immediately following <i>__position</i> prior to the
element being erased. If no such element exists, end() is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases an element, pointed to by the given iterator, from an
unordered_set. Note that this function only erases the
element, and that if the element is itself a pointer, the
pointed-to memory is not touched in any way. Managing the
pointer is the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::erase (iterator
__position)</b> <tt>[inline]</tt> <br>
Erases an element from an unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
pointing to the element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element immediately following <i>__position</i> prior to the
element being erased. If no such element exists, end() is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases an element, pointed to by the given iterator, from an
unordered_set. Note that this function only erases the
element, and that if the element is itself a pointer, the
pointed-to memory is not touched in any way. Managing the
pointer is the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; node_type std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::extract (const key_type
&amp; __key)</b> <tt>[inline]</tt> <br>
Extract a node.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; node_type std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::extract (const_iterator
__pos)</b> <tt>[inline]</tt> <br>
Extract a node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename _Kt &gt;
auto std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::find (const _Kt &amp; __k) &minus;&gt;
decltype(_M_h._M_find_tr(__k))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Tries to locate
an element in an unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Element to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename _Kt &gt;
auto std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::find (const _Kt &amp; __k) const &minus;&gt;
decltype(_M_h._M_find_tr(__k))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Tries to locate
an element in an unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Element to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::find (const key_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Tries to locate an element in an unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Element to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; const_iterator
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::find (const key_type &amp; __x) const</b>
<tt>[inline]</tt> <br>
Tries to locate an element in an unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Element to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; allocator_type
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::get_allocator () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the allocator object used by the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; hasher std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::hash_function ()
const</b> <tt>[inline]</tt> <br>
Returns the hash functor object with which the unordered_set
was constructed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; template&lt;typename
_InputIterator &gt; void std::unordered_set&lt; _Value,
_Hash, _Pred, _Alloc &gt;::insert (_InputIterator __first,
_InputIterator __last)</b> <tt>[inline]</tt> <br>
A template function that attempts to insert a range of
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the start of the range to be inserted. <i><br>
__last</i> Iterator pointing to the end of the range.</p>

<p style="margin-left:11%; margin-top: 1em">Complexity
similar to that of the range constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::pair&lt; iterator, bool
&gt; std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::insert (const value_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Attempts to insert an element into the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Element to be
inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
element, and the second is a bool that is true if the
element was actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert an element into the unordered_set. An
unordered_set relies on unique keys and thus an element is
only inserted if it is not already present in the
unordered_set.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::insert (const_iterator
__hint, const value_type &amp; __x)</b> <tt>[inline]</tt>
<br>
Attempts to insert an element into the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the element should be inserted.
<i><br>
__x</i> Element to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the
element passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">For more on
<i>hinting</i>, see:
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::insert (const_iterator
__hint, value_type &amp;&amp; __x)</b> <tt>[inline]</tt>
<br>
Attempts to insert an element into the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the element should be inserted.
<i><br>
__x</i> Element to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the
element passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">For more on
<i>hinting</i>, see:
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; iterator std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::insert (const_iterator,
node_type &amp;&amp; __nh)</b> <tt>[inline]</tt> <br>
Re-insert an extracted node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; void std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::insert
(initializer_list&lt; value_type &gt; __l)</b>
<tt>[inline]</tt> <br>
Attempts to insert a list of elements into the
unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> A
std::initializer_list&lt;value_type&gt; of elements to be
inserted.</p>

<p style="margin-left:11%; margin-top: 1em">Complexity
similar to that of the range constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; insert_return_type
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::insert (node_type &amp;&amp; __nh)</b>
<tt>[inline]</tt> <br>
Re-insert an extracted node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; std::pair&lt; iterator, bool
&gt; std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::insert (value_type &amp;&amp; __x)</b>
<tt>[inline]</tt> <br>
Attempts to insert an element into the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Element to be
inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
element, and the second is a bool that is true if the
element was actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert an element into the unordered_set. An
unordered_set relies on unique keys and thus an element is
only inserted if it is not already present in the
unordered_set.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; key_equal std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::key_eq () const</b>
<tt>[inline]</tt> <br>
Returns the key comparison object with which the
unordered_set was constructed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; float std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::load_factor () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the average number of elements per bucket.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; size_type std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::max_bucket_count ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the maximum number of buckets of the
unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; float std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::max_load_factor ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a positive number that the unordered_set tries to
keep the load factor less than or equal to.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; void std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::max_load_factor (float
__z)</b> <tt>[inline]</tt> <br>
Change the unordered_set maximum load factor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__z</i> The new maximum load
factor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; size_type std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::max_size () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the maximum size of the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; unordered_set &amp;
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::operator= (const unordered_set&lt; _Value, _Hash,
_Pred, _Alloc &gt; &amp;)</b> <tt>[default]</tt> <br>
Copy assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; unordered_set &amp;
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::operator= (initializer_list&lt; value_type &gt;
__l)</b> <tt>[inline]</tt> <br>
Unordered_set list assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills an unordered_set with copies of the elements in the
initializer list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the unordered_set and that the
resulting unordered_set&rsquo;s size is the same as the
number of elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; unordered_set &amp;
std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc
&gt;::operator= (unordered_set&lt; _Value, _Hash, _Pred,
_Alloc &gt; &amp;&amp;)</b> <tt>[default]</tt> <br>
Move assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; void std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::rehash (size_type
__n)</b> <tt>[inline]</tt> <br>
May rehash the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The new number of
buckets.</p>

<p style="margin-left:11%; margin-top: 1em">Rehash will
occur only if the new number of buckets respect the
unordered_set maximum load factor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; void std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::reserve (size_type
__n)</b> <tt>[inline]</tt> <br>
Prepare the unordered_set for a specified number of
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> Number of elements
required.</p>

<p style="margin-left:11%; margin-top: 1em">Same as
rehash(ceil(n / max_load_factor())).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; size_type std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::size () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the size of the unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Value , typename _Hash = hash&lt;_Value&gt;, typename _Pred
= equal_to&lt;_Value&gt;, typename _Alloc =
allocator&lt;_Value&gt;&gt; void std::unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt;::swap (unordered_set&lt;
_Value, _Hash, _Pred, _Alloc &gt; &amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Swaps data with another unordered_set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> An unordered_set of
the same element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">This exchanges
the elements between two sets in constant time. Note that
the global std::swap() function is specialized such that
std::swap(s1,s2) will feed to this function.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
