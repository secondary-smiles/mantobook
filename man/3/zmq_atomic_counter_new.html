<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:48 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ZMQ_ATOMIC_COUNTER_N</title>

</head>
<body>
<h1>zmq_atomic_counter_new</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">zmq_atomic_counter_new
&minus; create a new atomic counter</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>void
*zmq_atomic_counter_new (void);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>zmq_atomic_counter_new</i> function creates a new atomic
counter. You can use this in multithreaded applications to
do, for example, reference counting of shared objects. The
atomic counter is at least 32 bits large. This function uses
platform specific atomic operations.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>zmq_atomic_counter_new()</i> function returns the new
atomic counter if successful. Otherwise it returns NULL.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Test code
for atomic counters</b>.</p>

<p style="margin-left:17%; margin-top: 1em">void *counter =
zmq_atomic_counter_new (); <br>
assert (zmq_atomic_counter_value (counter) == 0); <br>
assert (zmq_atomic_counter_inc (counter) == 0); <br>
assert (zmq_atomic_counter_inc (counter) == 1); <br>
assert (zmq_atomic_counter_inc (counter) == 2); <br>
assert (zmq_atomic_counter_value (counter) == 3); <br>
assert (zmq_atomic_counter_dec (counter) == 1); <br>
assert (zmq_atomic_counter_dec (counter) == 1); <br>
assert (zmq_atomic_counter_dec (counter) == 0); <br>
zmq_atomic_counter_set (counter, 2); <br>
assert (zmq_atomic_counter_dec (counter) == 1); <br>
assert (zmq_atomic_counter_dec (counter) == 0); <br>
zmq_atomic_counter_destroy (&amp;counter); <br>
return 0;</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>zmq_atomic_counter_set</b>(3)
<b>zmq_atomic_counter_inc</b>(3)
<b>zmq_atomic_counter_dec</b>(3)
<b>zmq_atomic_counter_value</b>(3)
<b>zmq_atomic_counter_destroy</b>(3)</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page was
written by the 0MQ community. To make a change please read
the 0MQ Contribution Policy at
<b><font color="#0000FF">http://www.zeromq.org/docs:contributing</font></b><font color="#000000">.</font></p>
<hr>
</body>
</html>
