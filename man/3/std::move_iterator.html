<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:13 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::move_iterator&lt; _Iterator &gt;</title>

</head>
<body>
<h1>std::move_iterator</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::move_iterator&lt;
_Iterator &gt;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;iterator&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
std::__detail::__move_iter_cat&lt; _Iterator &gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">using <b>difference_type</b> =
iter_difference_t&lt; _Iterator &gt; <br>
using <b>iterator_concept</b> = decltype(_S_iter_concept())
<br>
using <b>iterator_type</b> = _Iterator <br>
using <b>pointer</b> = _Iterator <br>
using <b>reference</b> = iter_rvalue_reference_t&lt;
_Iterator &gt; <br>
using <b>value_type</b> = iter_value_t&lt; _Iterator
&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Iter &gt;
<br>
requires __convertible&lt;_Iter&gt;constexpr
<b>move_iterator</b> (const <b>move_iterator</b>&lt; _Iter
&gt; &amp;__i)&quot; <br>
constexpr <b>move_iterator</b> (iterator_type __i) <br>
constexpr iterator_type <b>base</b> () &amp;&amp; <br>
constexpr const iterator_type &amp; <b>base</b> () const
&amp;noexcept <br>
constexpr reference <b>operator*</b> () const <br>
constexpr <b>move_iterator operator+</b> (difference_type
__n) const <br>
constexpr <b>move_iterator</b> &amp; <b>operator++</b> ()
<br>
constexpr <b>move_iterator operator++</b> (int) <br>
constexpr void <b>operator++</b> (int) <br>
constexpr <b>move_iterator</b> &amp; <b>operator+=</b>
(difference_type __n) <br>
constexpr <b>move_iterator operator&minus;</b>
(difference_type __n) const <br>
constexpr <b>move_iterator</b> &amp;
<b>operator&minus;&minus;</b> () <br>
constexpr <b>move_iterator operator&minus;&minus;</b> (int)
<br>
constexpr <b>move_iterator</b> &amp; <b>operator&minus;=</b>
(difference_type __n) <br>
constexpr pointer <b>operator&minus;&gt;</b> () const <br>
template&lt;typename _Iter &gt; <br>
requires __convertible&lt;_Iter&gt; &amp;&amp;
assignable_from&lt;_Iterator&amp;, const
_Iter&amp;&gt;constexpr <b>move_iterator</b> &amp;
<b>operator=</b> (const <b>move_iterator</b>&lt; _Iter &gt;
&amp;__i)&quot; <br>
constexpr reference <b>operator[]</b> (difference_type __n)
const</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">constexpr
iter_rvalue_reference_t&lt; _Iterator &gt; <b>iter_move</b>
(const <b>move_iterator</b> &amp;__i)
noexcept(noexcept(ranges::iter_move(__i._M_current))) <br>
template&lt;indirectly_swappable&lt; _Iterator &gt;
_Iter2&gt; constexpr void <b>iter_swap</b> (const
<b>move_iterator</b> &amp;__x, const
<b>move_iterator</b>&lt; _Iter2 &gt; &amp;__y)
noexcept(noexcept(ranges::iter_swap(__x._M_current,
__y._M_current))) <br>
template&lt;sized_sentinel_for&lt; _Iterator &gt; _Sent&gt;
constexpr iter_difference_t&lt; _Iterator &gt;
<b>operator&minus;</b> (const <b>move_iterator</b> &amp;__x,
const move_sentinel&lt; _Sent &gt; &amp;__y) <br>
template&lt;sized_sentinel_for&lt; _Iterator &gt; _Sent&gt;
constexpr iter_difference_t&lt; _Iterator &gt;
<b>operator&minus;</b> (const move_sentinel&lt; _Sent &gt;
&amp;__x, const <b>move_iterator</b> &amp;__y) <br>
template&lt;sentinel_for&lt; _Iterator &gt; _Sent&gt;
constexpr bool <b>operator==</b> (const <b>move_iterator</b>
&amp;__x, const move_sentinel&lt; _Sent &gt; &amp;__y)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator&gt;</b> <br>
class std::move_iterator&lt; _Iterator &gt;&quot;Class
template move_iterator is an iterator adapter with the same
behavior as the underlying iterator except that its
dereference operator implicitly converts the value returned
by the underlying iterator&rsquo;s dereference operator to
an rvalue reference. Some generic algorithms can be called
with move iterators to replace copying with moving.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
