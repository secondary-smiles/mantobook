<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:00 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SD&minus;ID128</title>

</head>
<body>
<h1>SD_ID128_ALLF</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">sd-id128,
SD_ID128_ALLF, SD_ID128_CONST_STR, SD_ID128_FORMAT_STR,
SD_ID128_FORMAT_VAL, SD_ID128_MAKE, SD_ID128_MAKE_STR,
SD_ID128_MAKE_UUID_STR, SD_ID128_NULL,
SD_ID128_UUID_FORMAT_STR, sd_id128_equal,
sd_id128_string_equal, sd_id128_in_set,
sd_id128_in_set_sentinel, sd_id128_in_setv,
sd_id128_is_allf, sd_id128_is_null, sd_id128_t &minus; APIs
for processing 128&minus;bit IDs</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;systemd/sd&minus;id128.h&gt;</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_ALLF</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_NULL</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_CONST_STR(</b><i>id</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_FORMAT_STR</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_FORMAT_VAL(</b><i>id</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_MAKE(</b><i>v0</i><b>,</b>
<i>v1</i><b>,</b> <i>v2</i><b>,</b> <i>v3</i><b>,</b>
<i>v4</i><b>,</b> <i>v5</i><b>,</b> <i>v6</i><b>,</b>
<i>v7</i><b>,</b> <i>v8</i><b>,</b> <i>v9</i><b>,</b>
<i>vA</i><b>,</b> <i>vB</i><b>,</b> <i>vC</i><b>,</b>
<i>vD</i><b>,</b> <i>vE</i><b>,</b> <i>vF</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_MAKE_STR(</b><i>v0</i><b>,</b>
<i>v1</i><b>,</b> <i>v2</i><b>,</b> <i>v3</i><b>,</b>
<i>v4</i><b>,</b> <i>v5</i><b>,</b> <i>v6</i><b>,</b>
<i>v7</i><b>,</b> <i>v8</i><b>,</b> <i>v9</i><b>,</b>
<i>vA</i><b>,</b> <i>vB</i><b>,</b> <i>vC</i><b>,</b>
<i>vD</i><b>,</b> <i>vE</i><b>,</b> <i>vF</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_MAKE_UUID_STR(</b><i>v0</i><b>,</b>
<i>v1</i><b>,</b> <i>v2</i><b>,</b> <i>v3</i><b>,</b>
<i>v4</i><b>,</b> <i>v5</i><b>,</b> <i>v6</i><b>,</b>
<i>v7</i><b>,</b> <i>v8</i><b>,</b> <i>v9</i><b>,</b>
<i>vA</i><b>,</b> <i>vB</i><b>,</b> <i>vC</i><b>,</b>
<i>vD</i><b>,</b> <i>vE</i><b>,</b> <i>vF</i><b>)</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>SD_ID128_UUID_FORMAT_STR</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
sd_id128_equal(sd_id128_t&nbsp;</b><i>a</i><b>,
sd_id128_t&nbsp;</b><i>b</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
sd_id128_string_equal(const&nbsp;char&nbsp;*</b><i>a</i><b>,
sd_id128_t&nbsp;</b><i>b</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
sd_id128_is_null(sd_id128_t&nbsp;</b><i>id</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
sd_id128_is_allf(sd_id128_t&nbsp;</b><i>id</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
sd_id128_in_setv(sd_id128_t&nbsp;</b><i>id</i><b>,
va_list&nbsp;</b><i>ap</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
sd_id128_in_set_sentinel(sd_id128_t&nbsp;</b><i>id</i><b>,
..., SD_ID128_NULL</b>);</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
sd_id128_in_set(sd_id128_t&nbsp;</b><i>id</i><b>,
...);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>pkg&minus;config
&minus;&minus;cflags &minus;&minus;libs libsystemd</b></p></td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">sd&minus;id128.h
provides APIs to generate, convert, and compare
128&minus;bit ID values. The 128&minus;bit ID values
processed and generated by these APIs are a generalization
of OSF UUIDs as defined by <b><font color="#0000FF">RFC
4122</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">but use a simpler string format. These
functions impose no structure on the used IDs, much unlike
OSF UUIDs or Microsoft GUIDs, but are mostly compatible with
those types of IDs.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">A
128&minus;bit ID is implemented as the following union
type:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">typedef
union sd_id128 { <br>
uint8_t bytes[16]; <br>
uint64_t qwords[2]; <br>
} sd_id128_t;</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">This
union type allows accessing the 128&minus;bit ID as 16
separate bytes or two 64&minus;bit words. It is generally
safer to access the ID components by their 8&minus;bit array
to avoid endianness issues. This union is intended to be
passed by value (as opposed to
pass&minus;by&minus;reference) and may be directly
manipulated by clients.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">A
couple of macros are defined to denote and decode
128&minus;bit IDs:</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SD_ID128_MAKE()</b>
is used to write a constant ID in source code. A commonly
used idiom is to assign a name to an ID using this
macro:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">#define
SD_MESSAGE_COREDUMP
SD_ID128_MAKE(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SD_ID128_NULL</b>
defines an ID consisting of only <b>NUL</b> bytes (i.e. all
bits off).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SD_ID128_ALLF</b>
defines an ID consisting of only <b>0xFF</b> bytes (i.e. all
bits on).</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SD_ID128_MAKE_STR()</b>
is similar to <b>SD_ID128_MAKE()</b>, but creates a <b>const
char*</b> expression that can be conveniently used in
message formats and such:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">#include
&lt;stdio.h&gt; <br>
#define SD_MESSAGE_COREDUMP_STR
SD_ID128_MAKE_STR(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">int
main(int argc, char **argv) { <br>
puts(&quot;Match for coredumps: MESSAGE_ID=&quot;
SD_MESSAGE_COREDUMP_STR); <br>
}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SD_ID128_CONST_STR()</b>
converts constant IDs into constant strings for output. The
following example code will output the string
&quot;fc2e22bc6ee647b6b90729ab34a250b1&quot;:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">int
main(int argc, char *argv[]) { <br>
puts(&quot;Match for coredumps: %s&quot;,
SD_ID128_CONST_STR(SD_MESSAGE_COREDUMP)); <br>
}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SD_ID128_FORMAT_STR</b>
and <b>SD_ID128_FORMAT_VAL()</b> is used to format an ID in
a <b>printf</b>(3) format string, as shown in the following
example:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">int
main(int argc, char *argv[]) { <br>
sd_id128_t id; <br>
id =
SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
<br>
printf(&quot;The ID encoded in this C file is &quot;
SD_ID128_FORMAT_STR &quot;.\n&quot;,
SD_ID128_FORMAT_VAL(id)); <br>
return 0; <br>
}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>SD_ID128_UUID_FORMAT_STR</b>
and <b>SD_ID128_MAKE_UUID_STR()</b> are similar to
<b>SD_ID128_FORMAT_STR</b> and <b>SD_ID128_MAKE_STR()</b>,
but include separating hyphens to conform to the
&quot;</font><b><font color="#0000FF">canonical
representation</font></b>
<small><font color="#000000">[2]</font></small>
<font color="#000000">&quot;. They format the string based
on</font> <b><font color="#0000FF">RFC4122</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">Variant 1 rules, i.e. converting from
Big Endian byte order. This matches behaviour of most other
Linux userspace infrastructure. It's probably best to avoid
UUIDs of other variants, in order to avoid unnecessary
ambiguities. All 128&minus;bit IDs generated by the
sd&minus;id128 APIs strictly conform to Variant 1 Version 4
UUIDs, as per RFC 4122.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>sd_id128_equal()</b>
compares two 128&minus;bit IDs:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">int
main(int argc, char *argv[]) { <br>
sd_id128_t a, b, c; <br>
a =
SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
<br>
b =
SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e);
<br>
c = a; <br>
assert(sd_id128_equal(a, c)); <br>
assert(!sd_id128_equal(a, b)); <br>
return 0; <br>
}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>sd_id128_string_equal()</b>
is similar to <b>sd_id128_equal()</b>, but the first ID is
formatted as <b>const char*</b>. The same restrictions apply
as to the first argument of
<b>sd_id128_from_string()</b>.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>sd_id128_is_null()</b>
checks if an ID consists of only <b>NUL</b>
bytes:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">assert(sd_id128_is_null(SD_ID128_NULL));</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">Similarly,
<b>sd_id128_is_allf()</b> checks if an ID consists of only
<b>0xFF</b> bytes (all bits on):</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">assert(sd_id128_is_allf(SD_ID128_ALLF));</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>sd_id128_in_set_sentinel()</b>
takes a list of IDs and returns true if the first argument
is equal to any of the subsequent arguments. The argument
list is terminated by an <b>SD_ID128_NULL</b> sentinel,
which must be present.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>sd_id128_in_set()</b>
is a convenience function that takes a list of IDs and
returns true if the first argument is equal to any of the
subsequent arguments:</font></p>


<p style="margin-left:17%; margin-top: 1em"><font color="#000000">int
main(int argc, char *argv[]) { <br>
sd_id12_t a =
SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
<br>
assert(sd_id128_in_set(a, a)); <br>
assert(sd_id128_in_set(a, a, a)); <br>
assert(!sd_id128_in_set(a)); <br>
assert(!sd_id128_in_set(a, <br>

SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e)
<br>

SD_ID128_MAKE(2f,88,28,5f,9c,44,09,9d,d7,15,77,04,bc,85,7e,e3)
<br>
SD_ID128_ALLF)); <br>
return 0; <br>
}</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>sd_id128_in_set()</b>
is defined as a macro over
<b>sd_id128_in_set_sentinel()</b>, adding the
<b>SD_ID128_NULL</b> sentinel automatically. Since
<b>sd_id128_in_set_sentinel()</b> uses <b>SD_ID128_NULL</b>
as the sentinel, <b>SD_ID128_NULL</b> cannot be otherwise
placed in the argument list.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>sd_id128_in_setv()</b>
is similar to <b>sd_id128_in_set_sentinel()</b>, but takes a
struct varargs argument.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">New
randomized IDs may be generated with
<b>systemd-id128</b>(1)'s <b>new</b> command.</font></p>


<p style="margin-left:11%; margin-top: 1em"><font color="#000000">See
<b>sd_id128_to_string</b>(3), <b>sd_id128_randomize</b>(3)
and <b>sd_id128_get_machine</b>(3) for information about
other implemented functions.</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000">These
APIs are implemented as a shared library, which can be
compiled and linked to with the
<b>libsystemd&nbsp;pkg-config</b>(1) file.</font></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><font color="#000000"><b>systemd</b>(1),
<b>sd_id128_to_string</b>(3), <b>sd_id128_randomize</b>(3),
<b>sd_id128_get_machine</b>(3), <b>printf</b>(3),
<b>journalctl</b>(1), <b>sd-journal</b>(7),
<b>pkg-config</b>(1), <b>machine-id</b>(5)</font></p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="2%"></td>
<td width="12%">


<p style="margin-top: 1em"><font color="#000000">RFC
4122</font></p> </td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://tools.ietf.org/html/rfc4122</font></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="12%"></td>
<td width="3%">



<p style="margin-top: 1em"><font color="#000000">2.</font></p> </td>
<td width="2%"></td>
<td width="37%">


<p style="margin-top: 1em"><font color="#000000">canonical
representation</font></p> </td>
<td width="46%">
</td></tr>
</table>


<p style="margin-left:17%;"><font color="#000000">https://en.wikipedia.org/wiki/Universally_unique_identifier#Format</font></p>
<hr>
</body>
</html>
