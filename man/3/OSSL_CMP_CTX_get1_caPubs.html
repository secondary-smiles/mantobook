<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:41 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>OSSL_CMP_CTX_NEW</title>

</head>
<body>
<h1>OSSL_CMP_CTX_get1_caPubs</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">OSSL_CMP_CTX_new,
OSSL_CMP_CTX_free, OSSL_CMP_CTX_reinit,
OSSL_CMP_CTX_set_option, OSSL_CMP_CTX_get_option,
OSSL_CMP_CTX_set_log_cb, OSSL_CMP_CTX_set_log_verbosity,
OSSL_CMP_CTX_print_errors, OSSL_CMP_CTX_set1_serverPath,
OSSL_CMP_CTX_set1_server, OSSL_CMP_CTX_set_serverPort,
OSSL_CMP_CTX_set1_proxy, OSSL_CMP_CTX_set1_no_proxy,
OSSL_CMP_CTX_set_http_cb, OSSL_CMP_CTX_set_http_cb_arg,
OSSL_CMP_CTX_get_http_cb_arg, OSSL_CMP_transfer_cb_t,
OSSL_CMP_CTX_set_transfer_cb,
OSSL_CMP_CTX_set_transfer_cb_arg,
OSSL_CMP_CTX_get_transfer_cb_arg, OSSL_CMP_CTX_set1_srvCert,
OSSL_CMP_CTX_set1_expected_sender,
OSSL_CMP_CTX_set0_trustedStore,
OSSL_CMP_CTX_get0_trustedStore, OSSL_CMP_CTX_set1_untrusted,
OSSL_CMP_CTX_get0_untrusted, OSSL_CMP_CTX_set1_cert,
OSSL_CMP_CTX_build_cert_chain, OSSL_CMP_CTX_set1_pkey,
OSSL_CMP_CTX_set1_referenceValue,
OSSL_CMP_CTX_set1_secretValue, OSSL_CMP_CTX_set1_recipient,
OSSL_CMP_CTX_push0_geninfo_ITAV,
OSSL_CMP_CTX_reset_geninfo_ITAVs,
OSSL_CMP_CTX_set1_extraCertsOut, OSSL_CMP_CTX_set0_newPkey,
OSSL_CMP_CTX_get0_newPkey, OSSL_CMP_CTX_set1_issuer,
OSSL_CMP_CTX_set1_subjectName,
OSSL_CMP_CTX_push1_subjectAltName,
OSSL_CMP_CTX_set0_reqExtensions,
OSSL_CMP_CTX_reqExtensions_have_SAN,
OSSL_CMP_CTX_push0_policy, OSSL_CMP_CTX_set1_oldCert,
OSSL_CMP_CTX_set1_p10CSR, OSSL_CMP_CTX_push0_genm_ITAV,
OSSL_CMP_certConf_cb_t, OSSL_CMP_certConf_cb,
OSSL_CMP_CTX_set_certConf_cb,
OSSL_CMP_CTX_set_certConf_cb_arg,
OSSL_CMP_CTX_get_certConf_cb_arg, OSSL_CMP_CTX_get_status,
OSSL_CMP_CTX_get0_statusString,
OSSL_CMP_CTX_get_failInfoCode, OSSL_CMP_CTX_get0_newCert,
OSSL_CMP_CTX_get1_newChain, OSSL_CMP_CTX_get1_caPubs,
OSSL_CMP_CTX_get1_extraCertsIn,
OSSL_CMP_CTX_set1_transactionID,
OSSL_CMP_CTX_set1_senderNonce &minus; functions for managing
the CMP client context data structure</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/cmp.h&gt; <br>
OSSL_CMP_CTX *OSSL_CMP_CTX_new(OSSL_LIB_CTX *libctx, const
char *propq); <br>
void OSSL_CMP_CTX_free(OSSL_CMP_CTX *ctx); <br>
int OSSL_CMP_CTX_reinit(OSSL_CMP_CTX *ctx); <br>
int OSSL_CMP_CTX_set_option(OSSL_CMP_CTX *ctx, int opt, int
val); <br>
int OSSL_CMP_CTX_get_option(const OSSL_CMP_CTX *ctx, int
opt); <br>
/* logging and error reporting: */ <br>
int OSSL_CMP_CTX_set_log_cb(OSSL_CMP_CTX *ctx,
OSSL_CMP_log_cb_t cb); <br>
#define OSSL_CMP_CTX_set_log_verbosity(ctx, level) <br>
void OSSL_CMP_CTX_print_errors(const OSSL_CMP_CTX *ctx);
<br>
/* message transfer: */ <br>
int OSSL_CMP_CTX_set1_serverPath(OSSL_CMP_CTX *ctx, const
char *path); <br>
int OSSL_CMP_CTX_set1_server(OSSL_CMP_CTX *ctx, const char
*address); <br>
int OSSL_CMP_CTX_set_serverPort(OSSL_CMP_CTX *ctx, int
port); <br>
int OSSL_CMP_CTX_set1_proxy(OSSL_CMP_CTX *ctx, const char
*name); <br>
int OSSL_CMP_CTX_set1_no_proxy(OSSL_CMP_CTX *ctx, const char
*names); <br>
int OSSL_CMP_CTX_set_http_cb(OSSL_CMP_CTX *ctx,
HTTP_bio_cb_t cb); <br>
int OSSL_CMP_CTX_set_http_cb_arg(OSSL_CMP_CTX *ctx, void
*arg); <br>
void *OSSL_CMP_CTX_get_http_cb_arg(const OSSL_CMP_CTX *ctx);
<br>
typedef OSSL_CMP_MSG *(*OSSL_CMP_transfer_cb_t)(OSSL_CMP_CTX
*ctx, <br>
const OSSL_CMP_MSG *req); <br>
int OSSL_CMP_CTX_set_transfer_cb(OSSL_CMP_CTX *ctx, <br>
OSSL_CMP_transfer_cb_t cb); <br>
int OSSL_CMP_CTX_set_transfer_cb_arg(OSSL_CMP_CTX *ctx, void
*arg); <br>
void *OSSL_CMP_CTX_get_transfer_cb_arg(const OSSL_CMP_CTX
*ctx); <br>
/* server authentication: */ <br>
int OSSL_CMP_CTX_set1_srvCert(OSSL_CMP_CTX *ctx, X509
*cert); <br>
int OSSL_CMP_CTX_set1_expected_sender(OSSL_CMP_CTX *ctx,
<br>
const X509_NAME *name); <br>
int OSSL_CMP_CTX_set0_trustedStore(OSSL_CMP_CTX *ctx,
X509_STORE *store); <br>
X509_STORE *OSSL_CMP_CTX_get0_trustedStore(const
OSSL_CMP_CTX *ctx); <br>
int OSSL_CMP_CTX_set1_untrusted(OSSL_CMP_CTX *ctx,
STACK_OF(X509) *certs); <br>
STACK_OF(X509) *OSSL_CMP_CTX_get0_untrusted(const
OSSL_CMP_CTX *ctx); <br>
/* client authentication: */ <br>
int OSSL_CMP_CTX_set1_cert(OSSL_CMP_CTX *ctx, X509 *cert);
<br>
int OSSL_CMP_CTX_build_cert_chain(OSSL_CMP_CTX *ctx,
X509_STORE *own_trusted, <br>
STACK_OF(X509) *candidates); <br>
int OSSL_CMP_CTX_set1_pkey(OSSL_CMP_CTX *ctx, EVP_PKEY
*pkey); <br>
int OSSL_CMP_CTX_set1_referenceValue(OSSL_CMP_CTX *ctx, <br>
const unsigned char *ref, int len); <br>
int OSSL_CMP_CTX_set1_secretValue(OSSL_CMP_CTX *ctx, const
unsigned char *sec, <br>
const int len); <br>
/* CMP message header and extra certificates: */ <br>
int OSSL_CMP_CTX_set1_recipient(OSSL_CMP_CTX *ctx, const
X509_NAME *name); <br>
int OSSL_CMP_CTX_push0_geninfo_ITAV(OSSL_CMP_CTX *ctx,
OSSL_CMP_ITAV *itav); <br>
int OSSL_CMP_CTX_reset_geninfo_ITAVs(OSSL_CMP_CTX *ctx);
<br>
int OSSL_CMP_CTX_set1_extraCertsOut(OSSL_CMP_CTX *ctx, <br>
STACK_OF(X509) *extraCertsOut); <br>
/* certificate template: */ <br>
int OSSL_CMP_CTX_set0_newPkey(OSSL_CMP_CTX *ctx, int priv,
EVP_PKEY *pkey); <br>
EVP_PKEY *OSSL_CMP_CTX_get0_newPkey(const OSSL_CMP_CTX *ctx,
int priv); <br>
int OSSL_CMP_CTX_set1_issuer(OSSL_CMP_CTX *ctx, const
X509_NAME *name); <br>
int OSSL_CMP_CTX_set1_subjectName(OSSL_CMP_CTX *ctx, const
X509_NAME *name); <br>
int OSSL_CMP_CTX_push1_subjectAltName(OSSL_CMP_CTX *ctx,
<br>
const GENERAL_NAME *name); <br>
int OSSL_CMP_CTX_set0_reqExtensions(OSSL_CMP_CTX *ctx,
X509_EXTENSIONS *exts); <br>
int OSSL_CMP_CTX_reqExtensions_have_SAN(OSSL_CMP_CTX *ctx);
<br>
int OSSL_CMP_CTX_push0_policy(OSSL_CMP_CTX *ctx, POLICYINFO
*pinfo); <br>
int OSSL_CMP_CTX_set1_oldCert(OSSL_CMP_CTX *ctx, X509
*cert); <br>
int OSSL_CMP_CTX_set1_p10CSR(OSSL_CMP_CTX *ctx, const
X509_REQ *csr); <br>
/* misc body contents: */ <br>
int OSSL_CMP_CTX_push0_genm_ITAV(OSSL_CMP_CTX *ctx,
OSSL_CMP_ITAV *itav); <br>
/* certificate confirmation: */ <br>
typedef int (*OSSL_CMP_certConf_cb_t)(OSSL_CMP_CTX *ctx,
X509 *cert, <br>
int fail_info, const char **txt); <br>
int OSSL_CMP_certConf_cb(OSSL_CMP_CTX *ctx, X509 *cert, int
fail_info, <br>
const char **text); <br>
int OSSL_CMP_CTX_set_certConf_cb(OSSL_CMP_CTX *ctx,
OSSL_CMP_certConf_cb_t cb); <br>
int OSSL_CMP_CTX_set_certConf_cb_arg(OSSL_CMP_CTX *ctx, void
*arg); <br>
void *OSSL_CMP_CTX_get_certConf_cb_arg(const OSSL_CMP_CTX
*ctx); <br>
/* result fetching: */ <br>
int OSSL_CMP_CTX_get_status(const OSSL_CMP_CTX *ctx); <br>
OSSL_CMP_PKIFREETEXT *OSSL_CMP_CTX_get0_statusString(const
OSSL_CMP_CTX *ctx); <br>
int OSSL_CMP_CTX_get_failInfoCode(const OSSL_CMP_CTX *ctx);
<br>
X509 *OSSL_CMP_CTX_get0_newCert(const OSSL_CMP_CTX *ctx);
<br>
STACK_OF(X509) *OSSL_CMP_CTX_get1_newChain(const
OSSL_CMP_CTX *ctx); <br>
STACK_OF(X509) *OSSL_CMP_CTX_get1_caPubs(const OSSL_CMP_CTX
*ctx); <br>
STACK_OF(X509) *OSSL_CMP_CTX_get1_extraCertsIn(const
OSSL_CMP_CTX *ctx); <br>
/* for testing and debugging purposes: */ <br>
int OSSL_CMP_CTX_set1_transactionID(OSSL_CMP_CTX *ctx, <br>
const ASN1_OCTET_STRING *id); <br>
int OSSL_CMP_CTX_set1_senderNonce(OSSL_CMP_CTX *ctx, <br>
const ASN1_OCTET_STRING *nonce);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This is the
context <small>API</small> for using <small>CMP</small>
(Certificate Management Protocol) with OpenSSL.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_new()</b>
allocates an <b><small>OSSL_CMP_CTX</small></b> structure
associated with the library context <i>libctx</i> and
property query string <i>propq</i>, both of which may be
<small>NULL</small> to select the defaults. It initializes
the remaining fields to their default values &minus; for
instance, the logging verbosity is set to
<small>OSSL_CMP_LOG_INFO,</small> the message timeout is set
to 120 seconds, and the proof-of-possession method is set to
<small>OSSL_CRMF_POPO_SIGNATURE.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_free()</b>
deallocates an <small>OSSL_CMP_CTX</small> structure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_reinit()</b>
prepares the given <i>ctx</i> for a further transaction by
clearing the internal <small>CMP</small> transaction (aka
session) status, PKIStatusInfo, and any previous results
(newCert, newChain, caPubs, and extraCertsIn) from the last
executed transaction. It also clears any ITAVs that were
added by <b>OSSL_CMP_CTX_push0_genm_ITAV()</b>. All other
field values (i.e., <small>CMP</small> options) are retained
for potential re-use.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_option()</b>
sets the given value for the given option (e.g.,
<small>OSSL_CMP_OPT_IMPLICIT_CONFIRM</small> ) in the given
<small>OSSL_CMP_CTX</small> structure.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options can be set: <b><small><br>
OSSL_CMP_OPT_LOG_VERBOSITY</small></b></p>

<p style="margin-left:17%;">The level of severity needed
for actually outputting log messages <br>
due to errors, warnings, general info, debugging, etc. <br>
Default is OSSL_CMP_LOG_INFO. See also
L&lt;OSSL_CMP_log_open(3)&gt;.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_KEEP_ALIVE</small></b></p>

<p style="margin-left:17%;">If the given value is 0 then
HTTP connections are not kept open <br>
after receiving a response, which is the default behavior
for HTTP 1.0. <br>
If the value is 1 or 2 then persistent connections are
requested. <br>
If the value is 2 then persistent connections are required,
<br>
i.e., in case the server does not grant them an error
occurs. <br>
The default value is 1: prefer to keep the connection
open.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_MSG_TIMEOUT</small></b></p>

<p style="margin-left:17%;">Number of seconds a CMP
request&minus;response message round trip <br>
is allowed to take before a timeout error is returned. <br>
A value &lt;= 0 means no limitation (waiting indefinitely).
<br>
Default is to use the B&lt;OSSL_CMP_OPT_TOTAL_TIMEOUT&gt;
setting.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_TOTAL_TIMEOUT</small></b></p>

<p style="margin-left:17%;">Maximum total number of seconds
a transaction may take, <br>
including polling etc. <br>
A value &lt;= 0 means no limitation (waiting indefinitely).
<br>
Default is 0.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_VALIDITY_DAYS</small></b></p>

<p style="margin-left:17%;">Number of days new certificates
are asked to be valid for.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_SUBJECTALTNAME_NODEFAULT</small></b></p>

<p style="margin-left:17%;">Do not take default Subject
Alternative Names <br>
from the reference certificate.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_SUBJECTALTNAME_CRITICAL</small></b></p>

<p style="margin-left:17%;">Demand that the given Subject
Alternative Names are flagged as critical.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_POLICIES_CRITICAL</small></b></p>

<p style="margin-left:17%;">Demand that the given policies
are flagged as critical.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_POPO_METHOD</small></b></p>

<p style="margin-left:17%;">Select the proof of possession
method to use. Possible values are: <br>
OSSL_CRMF_POPO_NONE &minus; ProofOfPossession field omitted
<br>
OSSL_CRMF_POPO_RAVERIFIED &minus; assert that the RA has
already <br>
verified the PoPo <br>
OSSL_CRMF_POPO_SIGNATURE &minus; sign a value with private
key, <br>
which is the default. <br>
OSSL_CRMF_POPO_KEYENC &minus; decrypt the encrypted
certificate <br>
(&quot;indirect method&quot;) <br>
Note that a signature&minus;based POPO can only be produced
if a private key <br>
is provided as the newPkey or client's pkey component of the
CMP context.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_DIGEST_ALGNID</small></b></p>

<p style="margin-left:17%;">The NID of the digest algorithm
to be used in RFC 4210's MSG_SIG_ALG <br>
for signature&minus;based message protection and
Proof&minus;of&minus;Possession (POPO). <br>
Default is SHA256.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_OWF_ALGNID</small></b>
The <small>NID</small> of the digest algorithm to be used as
<br>
one-way function ( <small>OWF</small> ) in <small>RFC
4210</small> &rsquo;s <small>MSG_MAC_ALG</small> for
PBM-based message <br>
protection. Default is <small>SHA256. <b><br>
OSSL_CMP_OPT_MAC_ALGNID</b></small> The <small>NID</small>
of the <small>MAC</small> algorithm to be used in <small>RFC
<br>
4210</small> &rsquo;s <small>MSG_MAC_ALG</small> for
PBM-based message protection. Default is <small><br>
HMAC&minus;SHA1</small> as per <small>RFC 4210. <b><br>
OSSL_CMP_OPT_REVOCATION_REASON</b></small></p>

<p style="margin-left:17%;">The reason code to be included
in a Revocation Request (RR); <br>
values: 0..10 (RFC 5210, 5.3.1) or &minus;1 for none, which
is the default.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_IMPLICIT_CONFIRM</small></b></p>

<p style="margin-left:17%;">Request server to enable
implicit confirm mode, where the client <br>
does not need to send confirmation upon receiving the <br>
certificate. If the server does not enable implicit
confirmation <br>
in the return message, then confirmation is sent anyway.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_DISABLE_CONFIRM</small></b></p>

<p style="margin-left:17%;">Do not confirm enrolled
certificates, to cope with broken servers <br>
not supporting implicit confirmation correctly. <br>
B&lt;WARNING:&gt; This setting leads to unspecified behavior
and it is meant <br>
exclusively to allow interoperability with server
implementations violating <br>
RFC 4210.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_UNPROTECTED_SEND</small></b></p>

<p style="margin-left:17%;">Send messages without
CMP&minus;level protection.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_UNPROTECTED_ERRORS</small></b></p>

<p style="margin-left:17%;">Accept unprotected error
responses which are either explicitly <br>
unprotected or where protection verification failed. Applies
to regular <br>
error messages as well as certificate responses (IP/CP/KUP)
and <br>
revocation responses (RP) with rejection. <br>
B&lt;WARNING:&gt; This setting leads to unspecified behavior
and it is meant <br>
exclusively to allow interoperability with server
implementations violating <br>
RFC 4210.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_IGNORE_KEYUSAGE</small></b></p>

<p style="margin-left:17%;">Ignore key usage restrictions
in the signer's certificate when <br>
validating signature&minus;based protection in received CMP
messages. <br>
Else, 'digitalSignature' must be allowed by CMP signer
certificates.</p>


<p style="margin-left:11%;"><b><small>OSSL_CMP_OPT_PERMIT_TA_IN_EXTRACERTS_FOR_IR</small></b></p>

<p style="margin-left:17%;">Allow retrieving a trust anchor
from extraCerts and using that <br>
to validate the certificate chain of an IP message.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get_option()</b>
reads the current value of the given option (e.g.,
<small>OSSL_CMP_OPT_IMPLICIT_CONFIRM</small> ) from the
given <small>OSSL_CMP_CTX</small> structure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_log_cb()</b>
sets in <i>ctx</i> the callback function <i>cb</i> for
handling error queue entries and logging messages. When
<i>cb</i> is <small>NULL</small> errors are printed to
<small>STDERR</small> (if available, else ignored) any log
messages are ignored. Alternatively,
<b>OSSL_CMP_log_open</b>(3) may be used to direct logging to
<small>STDOUT.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_log_verbosity()</b>
is a macro setting the
<small>OSSL_CMP_OPT_LOG_VERBOSITY</small> context option to
the given level.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_print_errors()</b>
outputs any entries in the OpenSSL error queue. It is
similar to <b>ERR_print_errors_cb</b>(3) but uses the
<small>CMP</small> log callback function if set in the
<i>ctx</i> for uniformity with <small>CMP</small> logging if
given. Otherwise it uses <b>ERR_print_errors</b>(3) to print
to <small>STDERR</small> (unless
<small>OPENSSL_NO_STDIO</small> is defined).</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_serverPath()</b>
sets the <small>HTTP</small> path of the <small>CMP</small>
server on the host, also known as &quot; <small>CMP</small>
alias&quot;. The default is &quot;/&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_server()</b>
sets the given server <i>address</i> (which may be a
hostname or <small>IP</small> address or <small>NULL</small>
) in the given <i>ctx</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_serverPort()</b>
sets the port of the <small>CMP</small> server to connect
to. If not used or the <i>port</i> argument is 0 the default
port applies, which is 80 for <small>HTTP</small> and 443
for <small>HTTPS.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_proxy()</b>
sets the <small>HTTP</small> proxy to be used for connecting
to the given <small>CMP</small> server unless overruled by
any &quot;no_proxy&quot; settings (see below). If
<small>TLS</small> is not used this defaults to the value of
the environment variable &quot;http_proxy&quot; if set, else
&quot;HTTP_PROXY&quot;. Otherwise defaults to the value of
&quot;https_proxy&quot; if set, else
&quot;HTTPS_PROXY&quot;. An empty proxy string specifies not
to use a proxy. Else the format is
&quot;[http[s]://]address[:port][/path]&quot;, where any
path given is ignored. The default port number is 80, or 443
in case &quot;https:&quot; is given.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_no_proxy()</b>
sets the list of server hostnames not to use an
<small>HTTP</small> proxy for. The names may be separated by
commas and/or whitespace. Defaults to the environment
variable &quot;no_proxy&quot; if set, else
&quot;NO_PROXY&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_http_cb()</b>
sets the optional <small>BIO</small> connect/disconnect
callback function, which has the prototype</p>

<p style="margin-left:11%; margin-top: 1em">typedef BIO
*(*HTTP_bio_cb_t) (BIO *bio, void *ctx, int connect, int
detail);</p>

<p style="margin-left:11%; margin-top: 1em">The callback
may modify the <i>bio</i> provided by
<b>OSSL_CMP_MSG_http_perform</b>(3), whereby it may make use
of a custom defined argument <i>ctx</i> stored in the
<small>OSSL_CMP_CTX</small> by means of
<b>OSSL_CMP_CTX_set_http_cb_arg()</b>. During connection
establishment, just after calling
<b>BIO_do_connect_retry()</b>, the function is invoked with
the <i>connect</i> argument being 1 and the <i>detail</i>
argument being 1 if <small>HTTPS</small> is requested, i.e.,
<small>SSL/TLS</small> should be enabled. On disconnect
<i>connect</i> is 0 and <i>detail</i> is 1 in case no error
occurred, else 0. For instance, on connect the function may
prepend a <small>TLS BIO</small> to implement
<small>HTTPS</small> ; after disconnect it may do some
diagnostic output and/or specific cleanup. The function
should return <small>NULL</small> to indicate failure. After
disconnect the modified <small>BIO</small> will be
deallocated using <b>BIO_free_all()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_http_cb_arg()</b>
sets an argument, respectively a pointer to a structure
containing arguments, optionally to be used by the http
connect/disconnect callback function. <i>arg</i> is not
consumed, and it must therefore explicitly be freed when not
needed any more. <i>arg</i> may be <small>NULL</small> to
clear the entry.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get_http_cb_arg()</b>
gets the argument, respectively the pointer to a structure
containing arguments, previously set by
<b>OSSL_CMP_CTX_set_http_cb_arg()</b> or <small>NULL</small>
if unset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_transfer_cb()</b>
sets the message transfer callback function, which has the
type</p>

<p style="margin-left:11%; margin-top: 1em">typedef
OSSL_CMP_MSG *(*OSSL_CMP_transfer_cb_t) (OSSL_CMP_CTX *ctx,
<br>
const OSSL_CMP_MSG *req);</p>

<p style="margin-left:11%; margin-top: 1em">Returns 1 on
success, 0 on error.</p>

<p style="margin-left:11%; margin-top: 1em">Default is
<small>NULL,</small> which implies the use of
<b>OSSL_CMP_MSG_http_perform</b>(3). The callback should
send the <small>CMP</small> request message it obtains via
the <i>req</i> parameter and on success return the response,
else it must return <small>NULL.</small> The transfer
callback may make use of a custom defined argument stored in
the ctx by means of
<b>OSSL_CMP_CTX_set_transfer_cb_arg()</b>, which may be
retrieved again through
<b>OSSL_CMP_CTX_get_transfer_cb_arg()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_transfer_cb_arg()</b>
sets an argument, respectively a pointer to a structure
containing arguments, optionally to be used by the transfer
callback. <i>arg</i> is not consumed, and it must therefore
explicitly be freed when not needed any more. <i>arg</i> may
be <small>NULL</small> to clear the entry.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get_transfer_cb_arg()</b>
gets the argument, respectively the pointer to a structure
containing arguments, previously set by
<b>OSSL_CMP_CTX_set_transfer_cb_arg()</b> or
<small>NULL</small> if unset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_srvCert()</b>
sets the expected server cert in <i>ctx</i> and trusts it
directly (even if it is expired) when verifying signed
response messages. May be used alternatively to
<b>OSSL_CMP_CTX_set0_trustedStore()</b> to pin the accepted
server. Any previously set value is freed. The <i>cert</i>
argument may be <small>NULL</small> to clear the entry. If
set, the subject of the certificate is also used as default
value for the recipient of <small>CMP</small> requests and
as default value for the expected sender of
<small>CMP</small> responses.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_expected_sender()</b>
sets the Distinguished Name ( <small>DN</small> ) expected
in the sender field of <small>CMP</small> response messages.
Defaults to the subject of the pinned server certificate, if
any. This can be used to make sure that only a particular
entity is accepted as <small>CMP</small> message signer, and
attackers are not able to use arbitrary certificates of a
trusted <small>PKI</small> hierarchy to fraudulently pose as
<small>CMP</small> server. Note that this gives slightly
more freedom than <b>OSSL_CMP_CTX_set1_srvCert()</b>, which
pins the server to the holder of a particular certificate,
while the expected sender name will continue to match after
updates of the server cert.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set0_trustedStore()</b>
sets the certificate store of type X509_STORE containing
trusted (root) <small>CA</small> certificates. The store may
also hold CRLs and a certificate verification callback
function used for <small>CMP</small> server authentication.
Any store entry already set before is freed. When given a
<small>NULL</small> parameter the entry is cleared.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get0_trustedStore()</b>
returns a pointer to the currently set certificate store
containing trusted cert etc., or an empty store if
unset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_untrusted()</b>
sets up a list of non-trusted certificates of intermediate
CAs that may be useful for path construction for the
<small>CMP</small> client certificate, for the
<small>TLS</small> client certificate (if any), when
verifying the <small>CMP</small> server certificate, and
when verifying newly enrolled certificates. The reference
counts of those certificates handled successfully are
increased.</p>


<p style="margin-left:11%; margin-top: 1em">OSSL_CMP_CTX_get0_untrusted(
<small>OSSL_CMP_CTX</small> *ctx) returns a pointer to the
list of untrusted certs, which may be empty if unset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_cert()</b>
sets the certificate related to the client&rsquo;s private
key used for <small>CMP</small> message protection.
Therefore the public key of this <i>cert</i> must correspond
to the private key set before or thereafter via
<b>OSSL_CMP_CTX_set1_pkey()</b>. When using signature-based
protection of <small>CMP</small> request messages this
<small>CMP</small> signer certificate will be included first
in the extraCerts field. It serves as fallback reference
certificate, see <b>OSSL_CMP_CTX_set1_oldCert()</b>. The
subject of this <i>cert</i> will be used as the sender field
of outgoing messages, while the subject of any cert set via
<b>OSSL_CMP_CTX_set1_oldCert()</b> and any value set via
<b>OSSL_CMP_CTX_set1_subjectName()</b> are used as
fallback.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>cert</i>
argument may be <small>NULL</small> to clear the entry.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_build_cert_chain()</b>
builds a certificate chain for the <small>CMP</small> signer
certificate previously set in the <i>ctx</i>. It adds the
optional <i>candidates</i>, a list of intermediate
<small>CA</small> certs that may already constitute the
targeted chain, to the untrusted certs that may already
exist in the <i>ctx</i>. Then the function uses this
augumented set of certs for chain construction. If
<i>own_trusted</i> is <small>NULL</small> it builds the
chain as far down as possible and ignores any verification
errors. Else the <small>CMP</small> signer certificate must
be verifiable where the chain reaches a trust anchor
contained in <i>own_trusted</i>. On success the function
stores the resulting chain in <i>ctx</i> for inclusion in
the extraCerts field of signature-protected messages.
Calling this function is optional; by default a chain
construction is performed on demand that is equivalent to
calling this function with the <i>candidates</i> and
<i>own_trusted</i> arguments being <small>NULL.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_pkey()</b>
sets the client&rsquo;s private key corresponding to the
<small>CMP</small> signer certificate set via
<b>OSSL_CMP_CTX_set1_cert()</b>. This key is used create
signature-based protection (protectionAlg =
<small>MSG_SIG_ALG</small> ) of outgoing messages unless a
<small>PBM</small> secret has been set via
<b>OSSL_CMP_CTX_set1_secretValue()</b>. The <i>pkey</i>
argument may be <small>NULL</small> to clear the entry.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_secretValue()</b>
sets the byte string <i>sec</i> with length <i>len</i> as
<small>PBM</small> secret in the given <i>ctx</i> or clears
it if the <i>sec</i> argument is <small>NULL.</small> If
present, this secret is used to create PBM-based protection
of outgoing messages and to verify any PBM-based protection
of incoming messages (protectionAlg =
<small>MSG_MAC_ALG</small> ). <small>PBM</small> stands for
Password-Based <small>MAC.</small> PBM-based protection
takes precedence over signature-based protection.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_referenceValue()</b>
sets the given referenceValue <i>ref</i> with length
<i>len</i> in the given <i>ctx</i> or clears it if the
<i>ref</i> argument is <small>NULL.</small> According to
<small>RFC 4210</small> section 5.1.1, if no value for the
sender field in <small>CMP</small> message headers can be
determined (i.e., no <small>CMP</small> signer certificate
and no subject <small>DN</small> is set via
<b>OSSL_CMP_CTX_set1_subjectName()</b> then the sender field
will contain the NULL-DN and the senderKID field of the
<small>CMP</small> message header must be set. When
signature-based protection is used the senderKID will be set
to the subjectKeyIdentifier of the <small>CMP</small> signer
certificate as far as present. If not present or when
PBM-based protection is used the <i>ref</i> value is taken
as the fallback value for the senderKID.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_recipient()</b>
sets the recipient name that will be used in the PKIHeader
of <small>CMP</small> request messages, i.e. the X509 name
of the ( <small>CA</small> ) server.</p>

<p style="margin-left:11%; margin-top: 1em">The recipient
field in the header of a <small>CMP</small> message is
mandatory. If not given explicitly the recipient is
determined in the following order: the subject of the
<small>CMP</small> server certificate set using
<b>OSSL_CMP_CTX_set1_srvCert()</b>, the value set using
<b>OSSL_CMP_CTX_set1_issuer()</b>, the issuer of the
certificate set using <b>OSSL_CMP_CTX_set1_oldCert()</b>,
the issuer of the <small>CMP</small> signer certificate, as
far as any of those is present, else the NULL-DN as last
resort.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_push0_geninfo_ITAV()</b>
adds <i>itav</i> to the stack in the <i>ctx</i> to be added
to the GeneralInfo field of the <small>CMP</small>
PKIMessage header of a request message sent with this
context.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_reset_geninfo_ITAVs()</b>
clears any ITAVs that were added by
<b>OSSL_CMP_CTX_push0_geninfo_ITAV()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_extraCertsOut()</b>
sets the stack of extraCerts that will be sent to
remote.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set0_newPkey()</b>
can be used to explicitly set the given
<small>EVP_PKEY</small> structure as the private or public
key to be certified in the <small>CMP</small> context. The
<i>priv</i> parameter must be 0 if and only if the given key
is a public key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get0_newPkey()</b>
gives the key to use for certificate enrollment dependent on
fields of the <small>CMP</small> context structure: the
newPkey (which may be a private or public key) if present,
else the public key in the p10CSR if present, else the
client&rsquo;s private key. If the <i>priv</i> parameter is
not 0 and the selected key does not have a private component
then <small>NULL</small> is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_issuer()</b>
sets the name of the intended issuer that will be set in the
CertTemplate, i.e., the X509 name of the <small>CA</small>
server.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_subjectName()</b>
sets the subject <small>DN</small> that will be used in the
CertTemplate structure when requesting a new cert. For Key
Update Requests ( <small>KUR</small> ), it defaults to the
subject <small>DN</small> of the reference certificate, see
<b>OSSL_CMP_CTX_set1_oldCert()</b>. This default is used for
Initialization Requests ( <small>IR</small> ) and
Certification Requests ( <small>CR</small> ) only if no SANs
are set. The <i>subjectName</i> is also used as fallback for
the sender field of outgoing <small>CMP</small> messages if
no reference certificate is available.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_push1_subjectAltName()</b>
adds the given X509 name to the list of alternate names on
the certificate template request. This cannot be used if any
Subject Alternative Name extension is set via
<b>OSSL_CMP_CTX_set0_reqExtensions()</b>. By default, unless
<b><small>OSSL_CMP_OPT_SUBJECTALTNAME_NODEFAULT</small></b>
has been set, the Subject Alternative Names are copied from
the reference certificate, see
<b>OSSL_CMP_CTX_set1_oldCert()</b>. If set and the subject
<small>DN</small> is not set with
<b>OSSL_CMP_CTX_set1_subjectName()</b> then the certificate
template of an <small>IR</small> and <small>CR</small> will
not be filled with the default subject <small>DN</small>
from the reference certificate. If a subject
<small>DN</small> is desired it needs to be set explicitly
with <b>OSSL_CMP_CTX_set1_subjectName()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set0_reqExtensions()</b>
sets the X.509v3 extensions to be used in
<small>IR/CR/KUR.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_reqExtensions_have_SAN()</b>
returns 1 if the context contains a Subject Alternative Name
extension, else 0 or &minus;1 on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_push0_policy()</b>
adds the certificate policy info object to the
X509_EXTENSIONS of the requested certificate template.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_oldCert()</b>
sets the old certificate to be updated in Key Update
Requests ( <small>KUR</small> ) or to be revoked in
Revocation Requests ( <small>RR</small> ). It must be given
for <small>RR,</small> else it defaults to the
<small>CMP</small> signer certificate. The <i>reference
certificate</i> determined in this way, if any, is also used
for deriving default subject <small>DN,</small> public key,
Subject Alternative Names, and the default issuer entry in
the requested certificate template of
<small>IR/CR/KUR.</small> The subject of the reference
certificate is used as the sender field value in
<small>CMP</small> message headers. Its issuer is used as
default recipient in <small>CMP</small> message headers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_p10CSR()</b>
sets the PKCS#10 <small>CSR</small> to use in P10CR
messages. If such a <small>CSR</small> is provided, its
subject, public key, and extension fields are also used as
fallback values for the certificate template of
<small>IR/CR/KUR</small> messages.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_push0_genm_ITAV()</b>
adds <i>itav</i> to the stack in the <i>ctx</i> which will
be the body of a General Message sent with this context.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_certConf_cb()</b>
is the default certificate confirmation callback function.
If the callback argument is not <small>NULL</small> it must
point to a trust store. In this case the function checks
that the newly enrolled certificate can be verified using
this trust store and untrusted certificates from the
<i>ctx</i>, which have been augmented by the list of
extraCerts received. If the callback argument is
<small>NULL</small> the function tries building an
approximate chain as far as possible using the same
untrusted certificates from the <i>ctx</i>, and if this
fails it takes the received extraCerts as fallback. The
resulting cert chain can be retrieved using
<b>OSSL_CMP_CTX_get1_newChain()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_certConf_cb()</b>
sets the callback used for evaluating the newly enrolled
certificate before the library sends, depending on its
result, a positive or negative certConf message to the
server. The callback has type</p>

<p style="margin-left:11%; margin-top: 1em">typedef int
(*OSSL_CMP_certConf_cb_t) (OSSL_CMP_CTX *ctx, X509 *cert,
<br>
int fail_info, const char **txt);</p>

<p style="margin-left:11%; margin-top: 1em">and should
inspect the certificate it obtains via the <i>cert</i>
parameter and may overrule the pre-decision given in the
<i>fail_info</i> and <i>*txt</i> parameters. If it accepts
the certificate it must return 0, indicating success. Else
it must return a bit field reflecting PKIFailureInfo with at
least one failure bit and may set the <i>*txt</i> output
parameter to point to a string constant with more detail.
The transfer callback may make use of a custom defined
argument stored in the <i>ctx</i> by means of
<b>OSSL_CMP_CTX_set_certConf_cb_arg()</b>, which may be
retrieved again through
<b>OSSL_CMP_CTX_get_certConf_cb_arg()</b>. Typically, the
callback will check at least that the certificate can be
verified using a set of trusted certificates. It also could
compare the subject <small>DN</small> and other fields of
the newly enrolled certificate with the certificate template
of the request.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set_certConf_cb_arg()</b>
sets an argument, respectively a pointer to a structure
containing arguments, optionally to be used by the certConf
callback. <i>arg</i> is not consumed, and it must therefore
explicitly be freed when not needed any more. <i>arg</i> may
be <small>NULL</small> to clear the entry.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get_certConf_cb_arg()</b>
gets the argument, respectively the pointer to a structure
containing arguments, previously set by
<b>OSSL_CMP_CTX_set_certConf_cb_arg()</b>, or
<small>NULL</small> if unset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get_status()</b>
returns for client contexts the PKIstatus from the last
received CertRepMessage or Revocation Response or error
message: =item <b>OSSL_CMP_PKISTATUS_accepted</b> on
sucessful receipt of a <small>GENP</small> message: <b><br>
OSSL_CMP_PKISTATUS_request</b></p>

<p style="margin-left:17%;">if an
<small>IR/CR/KUR/RR/GENM</small> request message could not
be produced,</p>


<p style="margin-left:11%;"><b>OSSL_CMP_PKISTATUS_trans</b></p>

<p style="margin-left:17%;">on a transmission error or
transaction error for this type of request, and</p>


<p style="margin-left:11%;"><b>OSSL_CMP_PKISTATUS_unspecified</b></p>

<p style="margin-left:17%;">if no such request was
attempted or <b>OSSL_CMP_CTX_reinit()</b> has been
called.</p>

<p style="margin-left:11%; margin-top: 1em">For server
contexts it returns <b>OSSL_CMP_PKISTATUS_trans</b> if a
transaction is open, otherwise
<b>OSSL_CMP_PKISTATUS_unspecified</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get0_statusString()</b>
returns the statusString from the last received
CertRepMessage or Revocation Response or error message, or
<small>NULL</small> if unset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get_failInfoCode()</b>
returns the error code from the failInfo field of the last
received CertRepMessage or Revocation Response or error
message, or &minus;1 if no such response was received or
<b>OSSL_CMP_CTX_reinit()</b> has been called. This is a bit
field and the flags for it are specified in the header file
<i>&lt;openssl/cmp.h&gt;</i>. The flags start with
<small>OSSL_CMP_CTX_FAILINFO,</small> for example:
OSSL_CMP_CTX_FAILINFO_badAlg. Returns &minus;1 if the
failInfoCode field is unset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get0_newCert()</b>
returns the pointer to the newly obtained certificate in
case it is available, else <small>NULL.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get1_newChain()</b>
returns a pointer to a duplicate of the stack of X.509
certificates computed by <b>OSSL_CMP_certConf_cb()</b> (if
this function has been called) on the last received
certificate response message <small>IP/CP/KUP.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get1_caPubs()</b>
returns a pointer to a duplicate of the list of X.509
certificates in the caPubs field of the last received
certificate response message (of type <small>IP, CP,</small>
or <small>KUP</small> ), or an empty stack if no caPubs have
been received in the current transaction.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get1_extraCertsIn()</b>
returns a pointer to a duplicate of the list of X.509
certificates contained in the extraCerts field of the last
received response message (except for pollRep and PKIConf),
or an empty stack if no extraCerts have been received in the
current transaction.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_transactionID()</b>
sets the given transaction <small>ID</small> in the given
<small>OSSL_CMP_CTX</small> structure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_set1_senderNonce()</b>
stores the last sent sender <i>nonce</i> in the <i>ctx</i>.
This will be used to validate the recipNonce in incoming
messages.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>CMP</small>
is defined in <small>RFC 4210</small> (and
<small>CRMF</small> in <small>RFC 4211</small> ).</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_free()</b>
and <b>OSSL_CMP_CTX_print_errors()</b> do not return
anything.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_new()</b>,
<b>OSSL_CMP_CTX_get_http_cb_arg()</b>,
<b>OSSL_CMP_CTX_get_transfer_cb_arg()</b>,
<b>OSSL_CMP_CTX_get0_trustedStore()</b>,
<b>OSSL_CMP_CTX_get0_untrusted()</b>,
<b>OSSL_CMP_CTX_get0_newPkey()</b>,
<b>OSSL_CMP_CTX_get_certConf_cb_arg()</b>,
<b>OSSL_CMP_CTX_get0_statusString()</b>,
<b>OSSL_CMP_CTX_get0_newCert()</b>,
<b>OSSL_CMP_CTX_get0_newChain()</b>,
<b>OSSL_CMP_CTX_get1_caPubs()</b>, and
<b>OSSL_CMP_CTX_get1_extraCertsIn()</b> return the intended
pointer value as described above or <small>NULL</small> on
error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_get_option()</b>,
<b>OSSL_CMP_CTX_reqExtensions_have_SAN()</b>,
<b>OSSL_CMP_CTX_get_status()</b>, and
<b>OSSL_CMP_CTX_get_failInfoCode()</b> return the intended
value as described above or &minus;1 on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_certConf_cb()</b>
returns <i>fail_info</i> if it is not equal to 0, else 0 on
successful validation, or else a bit field with the
<b>OSSL_CMP_PKIFAILUREINFO_incorrectData</b> bit set.</p>

<p style="margin-left:11%; margin-top: 1em">All other
functions, including <b>OSSL_CMP_CTX_reinit()</b> and
<b>OSSL_CMP_CTX_reset_geninfo_ITAVs()</b>, return 1 on
success, 0 on error.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
code omits error handling.</p>

<p style="margin-left:11%; margin-top: 1em">Set up a
<small>CMP</small> client context for sending requests and
verifying responses:</p>

<p style="margin-left:11%; margin-top: 1em">cmp_ctx =
OSSL_CMP_CTX_new(); <br>
OSSL_CMP_CTX_set1_server(cmp_ctx, name_or_address); <br>
OSSL_CMP_CTX_set1_serverPort(cmp_ctx, port_string); <br>
OSSL_CMP_CTX_set1_serverPath(cmp_ctx, path_or_alias); <br>
OSSL_CMP_CTX_set0_trustedStore(cmp_ctx, ts);</p>

<p style="margin-left:11%; margin-top: 1em">Set up client
credentials for password-based protection (
<small>PBM</small> ):</p>


<p style="margin-left:11%; margin-top: 1em">OSSL_CMP_CTX_set1_referenceValue(cmp_ctx,
ref, ref_len); <br>
OSSL_CMP_CTX_set1_secretValue(cmp_ctx, sec, sec_len);</p>

<p style="margin-left:11%; margin-top: 1em">Set up the
details for certificate requests:</p>


<p style="margin-left:11%; margin-top: 1em">OSSL_CMP_CTX_set1_subjectName(cmp_ctx,
name); <br>
OSSL_CMP_CTX_set0_newPkey(cmp_ctx, 1, initialKey);</p>

<p style="margin-left:11%; margin-top: 1em">Perform an
Initialization Request transaction:</p>

<p style="margin-left:11%; margin-top: 1em">initialCert =
OSSL_CMP_exec_IR_ses(cmp_ctx);</p>

<p style="margin-left:11%; margin-top: 1em">Reset the
transaction state of the <small>CMP</small> context and the
credentials:</p>


<p style="margin-left:11%; margin-top: 1em">OSSL_CMP_CTX_reinit(cmp_ctx);
<br>
OSSL_CMP_CTX_set1_referenceValue(cmp_ctx, NULL, 0); <br>
OSSL_CMP_CTX_set1_secretValue(cmp_ctx, NULL, 0);</p>

<p style="margin-left:11%; margin-top: 1em">Perform a
Certification Request transaction, making use of the new
credentials:</p>


<p style="margin-left:11%; margin-top: 1em">OSSL_CMP_CTX_set1_cert(cmp_ctx,
initialCert); <br>
OSSL_CMP_CTX_set1_pkey(cmp_ctx, initialKey); <br>
OSSL_CMP_CTX_set0_newPkey(cmp_ctx, 1, curentKey); <br>
currentCert = OSSL_CMP_exec_CR_ses(cmp_ctx);</p>

<p style="margin-left:11%; margin-top: 1em">Perform a Key
Update Request, signed using the cert (and key) to be
updated:</p>


<p style="margin-left:11%; margin-top: 1em">OSSL_CMP_CTX_reinit(cmp_ctx);
<br>
OSSL_CMP_CTX_set1_cert(cmp_ctx, currentCert); <br>
OSSL_CMP_CTX_set1_pkey(cmp_ctx, currentKey); <br>
OSSL_CMP_CTX_set0_newPkey(cmp_ctx, 1, updatedKey); <br>
currentCert = OSSL_CMP_exec_KUR_ses(cmp_ctx); <br>
currentKey = updatedKey;</p>

<p style="margin-left:11%; margin-top: 1em">Perform a
General Message transaction including, as an example, the
id-it-signKeyPairTypes <small>OID</small> and prints info on
the General Response contents:</p>


<p style="margin-left:11%; margin-top: 1em">OSSL_CMP_CTX_reinit(cmp_ctx);
<br>
ASN1_OBJECT *type =
OBJ_txt2obj(&quot;1.3.6.1.5.5.7.4.2&quot;, 1); <br>
OSSL_CMP_ITAV *itav = OSSL_CMP_ITAV_create(type, NULL); <br>
OSSL_CMP_CTX_push0_genm_ITAV(cmp_ctx, itav); <br>
STACK_OF(OSSL_CMP_ITAV) *itavs; <br>
itavs = OSSL_CMP_exec_GENM_ses(cmp_ctx); <br>
print_itavs(itavs); <br>
sk_OSSL_CMP_ITAV_pop_free(itavs, OSSL_CMP_ITAV_free);</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_exec_IR_ses</b>(3),
<b>OSSL_CMP_exec_CR_ses</b>(3),
<b>OSSL_CMP_exec_KUR_ses</b>(3),
<b>OSSL_CMP_exec_GENM_ses</b>(3),
<b>OSSL_CMP_exec_certreq</b>(3),
<b>OSSL_CMP_MSG_http_perform</b>(3),
<b>ERR_print_errors_cb</b>(3)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The OpenSSL
<small>CMP</small> support was added in OpenSSL 3.0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>OSSL_CMP_CTX_reset_geninfo_ITAVs()</b>
was added in OpenSSL 3.0.8.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2007&minus;2023 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
