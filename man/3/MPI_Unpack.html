<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:36 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_Unpack</title>

</head>
<body>
<h1>MPI_Unpack</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_Unpack</b>
&minus; Unpacks a datatype into contiguous memory.</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Unpack(const void *<i>inbuf</i>, int <i>insize</i>,
int <i>*position</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>void <i>*outbuf</i>, int <i>outcount</i>, MPI_Datatype
<i>datatype</i>,</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>MPI_Comm <i>comm</i>)</p></td></tr>
</table>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_UNPACK(<i>INBUF, INSIZE, POSITION, OUTBUF,
OUTCOUNT,</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p><i>DATATYPE, COMM, IERROR</i>)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>&lt;type&gt;</p></td>
<td width="8%"></td>
<td width="69%">


<p><i>INBUF(*), OUTBUF(*)</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="69%">


<p><i>INSIZE, POSITION, OUTCOUNT, DATATYPE,</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p><i>COMM, IERROR</i></p></td>
<td width="69%">
</td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_Unpack(<i>inbuf</i>, <i>insize</i>, <i>position</i>,
<i>outbuf</i>, <i>outcount</i>, <i>datatype</i>,
<i>comm</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p><i>ierror</i>)</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(*), DIMENSION(..), INTENT(IN) :: <i>inbuf</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(*), DIMENSION(..) :: <i>outbuf</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>INTEGER, INTENT(IN) :: <i>insize</i>,
<i>outcount</i></p> </td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>INTEGER, INTENT(INOUT) :: <i>position</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Datatype), INTENT(IN) :: <i>datatype</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Comm), INTENT(IN) :: <i>comm</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td>
<td width="77%">
</td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
void Datatype::Unpack(const void* <i>inbuf</i>, int
<i>insize</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>void *<i>outbuf</i>, int <i>outcount</i>, int&amp;
<i>position</i>,</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>const Comm&amp; <i>comm</i>) const</p></td></tr>
</table>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">inbuf</p></td>
<td width="3%"></td>
<td width="66%">


<p style="margin-top: 1em">Input buffer start (choice).</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>insize</p></td>
<td width="3%"></td>
<td width="66%">


<p>Size of input buffer, in bytes (integer).</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>outcount</p></td>
<td width="3%"></td>
<td width="66%">


<p>Number of items to be unpacked (integer).</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>datatype</p></td>
<td width="3%"></td>
<td width="66%">


<p>Datatype of each output data item (handle).</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>comm</p></td>
<td width="3%"></td>
<td width="66%">


<p>Communicator for packed message (handle).</p></td>
<td width="8%">
</td></tr>
</table>

<h2>INPUT/OUTPUT PARAMETER
<a name="INPUT/OUTPUT PARAMETER"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">position</p></td>
<td width="3%"></td>
<td width="56%">


<p style="margin-top: 1em">Current position in bytes
(integer).</p> </td>
<td width="18%">
</td></tr>
</table>

<h2>OUTPUT PARAMETERS
<a name="OUTPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em">outbuf</p></td>
<td width="6%"></td>
<td width="57%">


<p style="margin-top: 1em">Output buffer start
(choice).</p> </td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>IERROR</p></td>
<td width="6%"></td>
<td width="57%">


<p>Fortran only: Error status (integer).</p></td>
<td width="17%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Unpacks a
message into the receive buffer specified by outbuf,
outcount, datatype from the buffer space specified by inbuf
and insize. The output buffer can be any communication
buffer allowed in MPI_Recv. The input buffer is a contiguous
storage area containing insize bytes, starting at address
inbuf. The input value of position is the first location in
the input buffer occupied by the packed message.
<i>position</i> is incremented by the size of the packed
message, so that the output value of position is the first
location in the input buffer after the locations occupied by
the message that was unpacked. <i>comm</i> is the
communicator used to receive the packed message.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Note the
difference between MPI_Recv and MPI_Unpack: In MPI_Recv, the
<i>count</i> argument specifies the maximum number of items
that can be received. The actual number of items received is
determined by the length of the incoming message. In
MPI_Unpack, the count argument specifies the actual number
of items that are to be unpacked; the &quot;size&quot; of
the corresponding message is the increment in position. The
reason for this change is that the &quot;incoming message
size&quot; is not predetermined since the user decides how
much to unpack; nor is it easy to determine the
&quot;message size&quot; from the number of items to be
unpacked.</p>

<p style="margin-left:11%; margin-top: 1em">To understand
the behavior of pack and unpack, it is convenient to think
of the data part of a message as being the sequence obtained
by concatenating the successive values sent in that message.
The pack operation stores this sequence in the buffer space,
as if sending the message to that buffer. The unpack
operation retrieves this sequence from buffer space, as if
receiving a message from that buffer. (It is helpful to
think of internal Fortran files or sscanf in C for a similar
function.)</p>

<p style="margin-left:11%; margin-top: 1em">Several
messages can be successively packed into one packing unit.
This is effected by several successive related calls to
MPI_Pack, where the first call provides position = 0, and
each successive call inputs the value of position that was
output by the previous call, and the same values for outbuf,
outcount, and comm. This packing unit now contains the
equivalent information that would have been stored in a
message by one send call with a send buffer that is the
&quot;concatenation&quot; of the individual send
buffers.</p>

<p style="margin-left:11%; margin-top: 1em">A packing unit
can be sent using type MPI_Packed. Any point-to-point or
collective communication function can be used to move the
sequence of bytes that forms the packing unit from one
process to another. This packing unit can now be received
using any receive operation, with any datatype: The
type-matching rules are relaxed for messages sent with type
MPI_Packed.</p>

<p style="margin-left:11%; margin-top: 1em">A message sent
with any type (including MPI_Packed) can be received using
the type MPI_Packed. Such a message can then be unpacked by
calls to MPI_Unpack.</p>

<p style="margin-left:11%; margin-top: 1em">A packing unit
(or a message created by a regular, &quot;typed&quot; send)
can be unpacked into several successive messages. This is
effected by several successive related calls to MPI_Unpack,
where the first call provides position = 0, and each
successive call inputs the value of position that was output
by the previous call, and the same values for inbuf, insize,
and comm.</p>

<p style="margin-left:11%; margin-top: 1em">The
concatenation of two packing units is not necessarily a
packing unit; nor is a substring of a packing unit
necessarily a packing unit. Thus, one cannot concatenate two
packing units and then unpack the result as one packing
unit; nor can one unpack a substring of a packing unit as a
separate packing unit. Each packing unit that was created by
a related sequence of pack calls or by a regular send must
be unpacked as a unit, by a sequence of related unpack
calls.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Pack <br>
 MPI_Pack_size</p>
<hr>
</body>
</html>
