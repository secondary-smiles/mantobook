<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:34 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_Comm_spawn</title>

</head>
<body>
<h1>MPI_Comm_spawn</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_Comm_spawn</b>
&minus; Spawns a number of identical binaries.</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Comm_spawn(const char *<i>command</i>, char
*<i>argv</i>[], int <i>maxprocs</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>MPI_Info <i>info</i>, int <i>root</i>, MPI_Comm
<i>comm</i>,</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>MPI_Comm *<i>intercomm</i>, int
<i>array_of_errcodes</i>[])</p> </td></tr>
</table>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_COMM_SPAWN(<i>COMMAND, ARGV, MAXPROCS, INFO, ROOT,
COMM,</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p><i>INTERCOMM, ARRAY_OF_ERRCODES, IERROR</i>)</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>CHARACTER*(*) <i>COMMAND, ARGV(*)</i></p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>INFO, MAXPROCS, ROOT, COMM, INTERCOMM,</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p><i>ARRAY_OF_ERRCODES(*), IERROR</i></p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_Comm_spawn(<i>command</i>, <i>argv</i>, <i>maxprocs</i>,
<i>info</i>, <i>root</i>, <i>comm</i>, <i>intercomm</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="77%">


<p><i>array_of_errcodes</i>, <i>ierror</i>)</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>CHARACTER(LEN=*), INTENT(IN) :: <i>command</i>,
<i>argv(*)</i></p> </td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>INTEGER, INTENT(IN) :: <i>maxprocs</i>, <i>root</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Info), INTENT(IN) :: <i>info</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Comm), INTENT(IN) :: <i>comm</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>TYPE(MPI_Comm), INTENT(OUT) :: <i>intercomm</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>INTEGER :: <i>array_of_errcodes(*)</i></p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td>
<td width="77%">
</td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
MPI::Intercomm MPI::Intracomm::Spawn(const char*
<i>command</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>const char* <i>argv</i>[], int <i>maxprocs</i>, const
MPI::Info&amp; <i>info</i>,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>int <i>root</i>, int <i>array_of_errcodes</i>[])
const</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">MPI::Intercomm
MPI::Intracomm::Spawn(const char* <i>command</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>const char* <i>argv</i>[], int <i>maxprocs</i>, const
MPI::Info&amp; <i>info</i>,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>int <i>root</i>) const</p></td></tr>
</table>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">command</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">Name of program to be spawned
(string, significant only at <i>root</i>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>argv</p></td>
<td width="3%"></td>
<td width="74%">


<p>Arguments to <i>command</i> (array of strings,
significant only at <i>root</i>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>maxprocs</p></td>
<td width="3%"></td>
<td width="74%">


<p>Maximum number of processes to start (integer,
significant only at <i>root</i>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>info</p></td>
<td width="3%"></td>
<td width="74%">


<p>A set of key-value pairs telling the runtime system
where and how to start the processes (handle, significant
only at <i>root</i>).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>root</p></td>
<td width="3%"></td>
<td width="74%">


<p>Rank of process in which previous arguments are examined
(integer).</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>comm</p></td>
<td width="3%"></td>
<td width="74%">


<p>Intracommunicator containing group of spawning processes
(handle).</p> </td></tr>
</table>

<h2>OUTPUT PARAMETER
<a name="OUTPUT PARAMETER"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="14%">


<p style="margin-top: 1em">intercomm</p></td>
<td width="1%"></td>
<td width="74%">


<p style="margin-top: 1em">Intercommunicator between
original group and the newly spawned group (handle).</p></td></tr>
</table>

<p style="margin-left:11%;">array_of_errcodes</p>

<p style="margin-left:26%;">One code per process (array of
integers).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>IERROR</p></td>
<td width="6%"></td>
<td width="57%">


<p>Fortran only: Error status (integer).</p></td>
<td width="17%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Comm_spawn
tries to start <i>maxprocs</i> identical copies of the MPI
program specified by <i>command</i>, establishing
communication with them and returning an intercommunicator.
The spawned processes are referred to as children. The
children have their own MPI_COMM_WORLD, which is separate
from that of the parents. MPI_Comm_spawn is collective over
<i>comm</i>, and also may not return until MPI_Init has been
called in the children. Similarly, MPI_Init in the children
may not return until all parents have called MPI_Comm_spawn.
In this sense, MPI_Comm_spawn in the parents and MPI_Init in
the children form a collective operation over the union of
parent and child processes. The intercommunicator returned
by MPI_Comm_spawn contains the parent processes in the local
group and the child processes in the remote group. The
ordering of processes in the local and remote groups is the
same as the as the ordering of the group of the <i>comm</i>
in the parents and of MPI_COMM_WORLD of the children,
respectively. This intercommunicator can be obtained in the
children through the function MPI_Comm_get_parent.</p>

<p style="margin-left:11%; margin-top: 1em">The MPI
standard allows an implementation to use the
MPI_UNIVERSE_SIZE attribute of MPI_COMM_WORLD to specify the
number of processes that will be active in a program.
Although this implementation of the MPI standard defines
MPI_UNIVERSE_SIZE, it does not allow the user to set its
value. If you try to set the value of MPI_UNIVERSE_SIZE, you
will get an error message.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>command</i> Argument</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>command</i> argument is a string containing the name of a
program to be spawned. The string is null-terminated in C.
In Fortran, leading and trailing spaces are stripped. MPI
looks for the file first in the working directory of the
spawning process.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>argv</i>
Argument</p>

<p style="margin-left:11%; margin-top: 1em"><i>argv</i> is
an array of strings containing arguments that are passed to
the program. The first element of <i>argv</i> is the first
argument passed to <i>command</i>, not, as is conventional
in some contexts, the command itself. The argument list is
terminated by NULL in C and C++ and an empty string in
Fortran (note that it is the MPI application&rsquo;s
responsibility to ensure that the last entry of the
<i>argv</i> array is an empty string; the compiler will not
automatically insert it). In Fortran, leading and trailing
spaces are always stripped, so that a string consisting of
all spaces is considered an empty string. The constant
MPI_ARGV_NULL may be used in C, C++ and Fortran to indicate
an empty argument list. In C and C++, this constant is the
same as NULL.</p>

<p style="margin-left:11%; margin-top: 1em">In C, the
MPI_Comm_spawn argument <i>argv</i> differs from the
<i>argv</i> argument of <i>main</i> in two respects. First,
it is shifted by one element. Specifically, <i>argv</i>[0]
of <i>main</i> contains the name of the program (given by
<i>command</i>). <i>argv</i>[1] of <i>main</i> corresponds
to <i>argv</i>[0] in MPI_Comm_spawn, <i>argv</i>[2] of
<i>main</i> to <i>argv</i>[1] of MPI_Comm_spawn, and so on.
Second, <i>argv</i> of MPI_Comm_spawn must be
null-terminated, so that its length can be determined.
Passing an <i>argv</i> of MPI_ARGV_NULL to MPI_Comm_spawn
results in <i>main</i> receiving <i>argc</i> of 1 and an
<i>argv</i> whose element 0 is the name of the program.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>maxprocs</i> Argument</p>

<p style="margin-left:11%; margin-top: 1em">Open MPI tries
to spawn <i>maxprocs</i> processes. If it is unable to spawn
<i>maxprocs</i> processes, it raises an error of class
MPI_ERR_SPAWN. If MPI is able to spawn the specified number
of processes, MPI_Comm_spawn returns successfully and the
number of spawned processes, <i>m</i>, is given by the size
of the remote group of <i>intercomm</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A spawn call
with the default behavior is called hard. A spawn call for
which fewer than <i>maxprocs</i> processes may be returned
is called soft.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>info</i>
Argument</p>

<p style="margin-left:11%; margin-top: 1em">The <i>info</i>
argument is an opaque handle of type MPI_Info in C,
MPI::Info in C++ and INTEGER in Fortran. It is a container
for a number of user-specified (<i>key,value</i>) pairs.
<i>key</i> and <i>value</i> are strings (null-terminated
char* in C, character*(*) in Fortran). Routines to create
and manipulate the <i>info</i> argument are described in
Section 4.10 of the MPI-2 standard.</p>

<p style="margin-left:11%; margin-top: 1em">For the SPAWN
calls, <i>info</i> provides additional,
implementation-dependent instructions to MPI and the runtime
system on how to start processes. An application may pass
MPI_INFO_NULL in C or Fortran. Portable programs not
requiring detailed control over process locations should use
MPI_INFO_NULL.</p>

<p style="margin-left:11%; margin-top: 1em">The following
keys for <i>info</i> are recognized in Open MPI. (The
reserved values mentioned in Section 5.3.4 of the MPI-2
standard are not implemented.)</p>

<p style="margin-left:11%; margin-top: 1em">Key Type
Description <br>
--- ---- -----------</p>

<p style="margin-left:11%; margin-top: 1em">host char *
Host on which the process should be <br>
spawned. See the <i>orte_host</i> man <br>
page for an explanation of how this <br>
will be used. <br>
hostfile char * Hostfile containing the hosts on which <br>
the processes are to be spawned. See <br>
the <i>orte_hostfile</i> man page for <br>
an explanation of how this will be <br>
used. <br>
add-host char * Add the specified host to the list of <br>
hosts known to this job and use it for <br>
the associated process. This will be <br>
used similarly to the -host option. <br>
add-hostfile char * Hostfile containing hosts to be added
<br>
to the list of hosts known to this job <br>
and use it for the associated <br>
process. This will be used similarly <br>
to the -hostfile option. <br>
wdir char * Directory where the executable is <br>
located. If files are to be <br>
pre-positioned, then this location is <br>
the desired working directory at time <br>
of execution - if not specified, then <br>
it will automatically be set to <i><br>
ompi_preload_files_dest_dir</i>. <br>
ompi_prefix char * Same as the --prefix command line <br>
argument to mpirun. <br>
ompi_preload_binary bool If set to true, pre-position the
<br>
specified executable onto the remote <br>
host. A destination directory must <br>
also be provided. <br>
ompi_preload_files char * A comma-separated list of files
that <br>
are to be pre-positioned in addition <br>
to the executable. Note that this <br>
option does not depend upon <i><br>
ompi_preload_binary</i> - files can <br>
be moved to the target even if an <br>
executable is not moved. <br>
ompi_stdin_target char * Comma-delimited list of ranks to
<br>
receive stdin when forwarded. <br>
ompi_non_mpi bool If set to true, launching a non-MPI <br>
application; the returned communicator <br>
will be MPI_COMM_NULL. Failure to set <br>
this flag when launching a non-MPI <br>
application will cause both the child <br>
and parent jobs to &quot;hang&quot;. <br>
ompi_param char * Pass an OMPI MCA parameter to the <br>
child job. If that parameter already <br>
exists in the environment, the value <br>
will be overwritten by the provided <br>
value. <br>
mapper char * Mapper to be used for this job <br>
map_by char * Mapping directive indicating how <br>
processes are to be mapped (slot, <br>
node, socket, etc.). <br>
rank_by char * Ranking directive indicating how <br>
processes are to be ranked (slot, <br>
node, socket, etc.). <br>
bind_to char * Binding directive indicating how <br>
processes are to be bound (core, slot, <br>
node, socket, etc.). <br>
path char * List of directories to search for <br>
the executable <br>
npernode char * Number of processes to spawn on <br>
each node of the allocation <br>
pernode bool Equivalent to npernode of 1 <br>
ppr char * Spawn specified number of processes <br>
on each of the identified object type <br>
env char * Newline-delimited list of envars to <br>
be passed to the spawned procs</p>

<p style="margin-left:11%; margin-top: 1em"><i>bool</i>
info keys are actually strings but are evaluated as follows:
if the string value is a number, it is converted to an
integer and cast to a boolean (meaning that zero integers
are false and non-zero values are true). If the string value
is (case-insensitive) &quot;yes&quot; or &quot;true&quot;,
the boolean is true. If the string value is
(case-insensitive) &quot;no&quot; or &quot;false&quot;, the
boolean is false. All other string values are unrecognized,
and therefore false.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>root</i>
Argument</p>

<p style="margin-left:11%; margin-top: 1em">All arguments
before the <i>root</i> argument are examined only on the
process whose rank in <i>comm</i> is equal to <i>root</i>.
The value of these arguments on other processes is
ignored.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>array_of_errcodes</i> Argument</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>array_of_errcodes</i> is an array of length
<i>maxprocs</i> in which MPI reports the status of the
processes that MPI was requested to start. If all
<i>maxprocs</i> processes were spawned,
<i>array_of_errcodes</i> is filled in with the value
MPI_SUCCESS. If anyof the processes are <i>not</i> spawned,
<i>array_of_errcodes</i> is filled in with the value
MPI_ERR_SPAWN. In C or Fortran, an application may pass
MPI_ERRCODES_IGNORE if it is not interested in the error
codes. In C++ this constant does not exist, and the
<i>array_of_errcodes</i> argument may be omitted from the
argument list.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Completion of
MPI_Comm_spawn in the parent does not necessarily mean that
MPI_Init has been called in the children (although the
returned intercommunicator can be used immediately).</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">MPI_Comm_spawn_multiple(3)
<br>
MPI_Comm_get_parent(3) <br>
 mpirun(1)</p>
<hr>
</body>
</html>
