<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:13 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::priority_queue&lt; _Tp, _Sequence, _Compare &gt;</title>

</head>
<body>
<h1>std::priority_queue</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::priority_queue&lt;
_Tp, _Sequence, _Compare &gt; &minus; A standard container
automatically sorting its contents.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;queue&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef
_Sequence::const_reference <b>const_reference</b> <br>
typedef _Sequence <b>container_type</b> <br>
typedef _Sequence::reference <b>reference</b> <br>
typedef _Sequence::size_type <b>size_type</b> <br>
typedef _Compare <b>value_compare</b> <br>
typedef _Sequence::value_type <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>template&lt;typename _Seq = _Sequence, typename
_Requires = typename
enable_if&lt;__and_&lt;is_default_constructible&lt;_Compare&gt;,</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">



<p>is_default_constructible&lt;_Seq&gt;&gt;::value&gt;::type&gt;
<b>priority_queue</b> ()</p></td></tr>
</table>

<p style="margin-left:17%;">Default constructor creates no
elements. <br>
template&lt;typename _InputIterator , typename _Alloc ,
typename = std::_RequireInputIter&lt;_InputIterator&gt;,
typename _Requires = _Uses&lt;_Alloc&gt;&gt;
<b>priority_queue</b> (_InputIterator __first,
_InputIterator __last, const _Alloc &amp;__alloc) <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
<b>priority_queue</b> (_InputIterator __first,
_InputIterator __last, const _Compare &amp;__x, _Sequence
&amp;&amp;__s) <br>
template&lt;typename _InputIterator , typename _Alloc ,
typename _Requires = _Uses&lt;_Alloc&gt;&gt;
<b>priority_queue</b> (_InputIterator __first,
_InputIterator __last, const _Compare &amp;__x, _Sequence
&amp;&amp;__s, const _Alloc &amp;__alloc) <br>
template&lt;typename _InputIterator , typename _Alloc ,
typename = std::_RequireInputIter&lt;_InputIterator&gt;,
typename _Requires = _Uses&lt;_Alloc&gt;&gt;
<b>priority_queue</b> (_InputIterator __first,
_InputIterator __last, const _Compare &amp;__x, const _Alloc
&amp;__alloc) <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
<b>priority_queue</b> (_InputIterator __first,
_InputIterator __last, const _Compare &amp;__x, const
_Sequence &amp;__s) <br>
template&lt;typename _InputIterator , typename _Alloc ,
typename = std::_RequireInputIter&lt;_InputIterator&gt;,
typename _Requires = _Uses&lt;_Alloc&gt;&gt;
<b>priority_queue</b> (_InputIterator __first,
_InputIterator __last, const _Compare &amp;__x, const
_Sequence &amp;__s, const _Alloc &amp;__alloc) <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
<b>priority_queue</b> (_InputIterator __first,
_InputIterator __last, const _Compare &amp;__x=_Compare())
<br>
Builds a queue from a range. <br>
template&lt;typename _Alloc , typename _Requires =
_Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const _Alloc
&amp;__a) <br>
template&lt;typename _Alloc , typename _Requires =
_Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const
_Compare &amp;__x, _Sequence &amp;&amp;__c, const _Alloc
&amp;__a) <b><br>
priority_queue</b> (const _Compare &amp;__x, _Sequence
&amp;&amp;__s=_Sequence()) <br>
template&lt;typename _Alloc , typename _Requires =
_Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const
_Compare &amp;__x, const _Alloc &amp;__a) <br>
template&lt;typename _Alloc , typename _Requires =
_Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const
_Compare &amp;__x, const _Sequence &amp;__c, const _Alloc
&amp;__a) <b><br>
priority_queue</b> (const _Compare &amp;__x, const _Sequence
&amp;__s) <br>
template&lt;typename _Alloc , typename _Requires =
_Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const
<b>priority_queue</b> &amp;__q, const _Alloc &amp;__a) <br>
template&lt;typename _Alloc , typename _Requires =
_Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b>
(<b>priority_queue</b> &amp;&amp;__q, const _Alloc &amp;__a)
<br>
template&lt;typename... _Args&gt; void <b>emplace</b> (_Args
&amp;&amp;... __args) <br>
bool <b>empty</b> () const <br>
void <b>pop</b> () <br>
Removes first element. <br>
void <b>push</b> (const value_type &amp;__x) <br>
Add data to the queue. <br>
void <b>push</b> (value_type &amp;&amp;__x) <br>
size_type <b>size</b> () const <br>
void <b>swap</b> (<b>priority_queue</b> &amp;__pq)
noexcept(__and_&lt;//c++1z or gnu++11
__is_nothrow_swappable&lt; _Sequence &gt;,
__is_nothrow_swappable&lt; _Compare &gt; &gt;::value) <br>
const_reference <b>top</b> () const</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Attributes</b></p>

<p style="margin-left:17%;">_Sequence <b>c</b> <br>
_Compare <b>comp</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Sequence = vector&lt;_Tp&gt;, typename
_Compare = less&lt;typename
_Sequence::value_type&gt;&gt;</b> <br>
class std::priority_queue&lt; _Tp, _Sequence, _Compare
&gt;&quot;A standard container automatically sorting its
contents.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_Tp</i> Type of element.
<i><br>
_Sequence</i> Type of underlying sequence, defaults to
vector&lt;_Tp&gt;. <i><br>
_Compare</i> Comparison function object type, defaults to
less&lt;_Sequence::value_type&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">This is not a
true container, but an <i>adaptor</i>. It holds another
container, and provides a wrapper interface to that
container. The wrapper is what enforces priority-based
sorting and queue behavior. Very few of the standard
container/sequence interface requirements are met (e.g.,
iterators).</p>

<p style="margin-left:11%; margin-top: 1em">The second
template parameter defines the type of the underlying
sequence/container. It defaults to std::vector, but it can
be any type that supports <tt>front()</tt>,
<tt>push_back</tt>, <tt>pop_back</tt>, and random-access
iterators, such as std::deque or an appropriate user-defined
type.</p>

<p style="margin-left:11%; margin-top: 1em">The third
template parameter supplies the means of making priority
comparisons. It defaults to <tt>less&lt;value_type&gt;</tt>
but can be anything defining a strict weak ordering.</p>

<p style="margin-left:11%; margin-top: 1em">Members not
found in <i>normal</i> containers are
<tt>container_type</tt>, which is a typedef for the second
Sequence parameter, and <tt>push</tt>, <tt>pop</tt>, and
<tt>top</tt>, which are standard queue operations.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">No equality/comparison
operators are provided for priority_queue.</p>

<p style="margin-left:17%; margin-top: 1em">Sorting of the
elements takes place as they are added to, and removed from,
the priority_queue using the priority_queue&rsquo;s member
functions. If you access the elements by other means, and
change their data such that the sorting order would be
different, the priority_queue will not re-sort the elements
for you. (How could it know to do so?)</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>template&lt;typename _Tp , typename _Sequence =
vector&lt;_Tp&gt;, typename _Compare = less&lt;typename
_Sequence::value_type&gt;&gt; template&lt;typename _Seq =
_Sequence, typename _Requires = typename
enable_if&lt;__and_&lt;is_default_constructible&lt;_Compare&gt;,</b></p> </td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">



<p><b>is_default_constructible&lt;_Seq&gt;&gt;::value&gt;::type&gt;
std::priority_queue&lt; _Tp, _Sequence, _Compare
&gt;::priority_queue ()</b> <tt>[inline]</tt></p></td></tr>
</table>

<p style="margin-left:11%;">Default constructor creates no
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Sequence = vector&lt;_Tp&gt;, typename
_Compare = less&lt;typename _Sequence::value_type&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
std::priority_queue&lt; _Tp, _Sequence, _Compare
&gt;::priority_queue (_InputIterator __first, _InputIterator
__last, const _Compare &amp; __x =</b>
<tt>_Compare()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds a queue from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__x</i> A comparison functor describing a strict weak
ordering. <i><br>
__s</i> An initial sequence with which to start.</p>

<p style="margin-left:11%; margin-top: 1em">Begins by
copying <i>__s</i>, inserting a copy of the elements from
[first,last) into the copy of <i>__s</i>, then ordering the
copy according to <i>__x</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information on function objects, see the documentation on
<b>functor base classes</b>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Sequence = vector&lt;_Tp&gt;, typename
_Compare = less&lt;typename _Sequence::value_type&gt;&gt;
bool std::priority_queue&lt; _Tp, _Sequence, _Compare
&gt;::empty () const</b> <tt>[inline]</tt> <br>
Returns true if the queue is empty.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_parallel::multiseq_partition()</b>, and
<b>__gnu_parallel::multiseq_selection()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Sequence = vector&lt;_Tp&gt;, typename
_Compare = less&lt;typename _Sequence::value_type&gt;&gt;
void std::priority_queue&lt; _Tp, _Sequence, _Compare
&gt;::pop ()</b> <tt>[inline]</tt> <br>
Removes first element. This is a typical queue operation. It
shrinks the queue by one. The time complexity of the
operation depends on the underlying sequence.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
data is returned, and if the first element&rsquo;s data is
needed, it should be retrieved before pop() is called.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_parallel::multiseq_partition()</b>, and
<b>__gnu_parallel::multiseq_selection()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Sequence = vector&lt;_Tp&gt;, typename
_Compare = less&lt;typename _Sequence::value_type&gt;&gt;
void std::priority_queue&lt; _Tp, _Sequence, _Compare
&gt;::push (const value_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Add data to the queue.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Data to be
added.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical queue operation. The time complexity of the
operation depends on the underlying sequence.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_parallel::multiseq_partition()</b>, and
<b>__gnu_parallel::multiseq_selection()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Sequence = vector&lt;_Tp&gt;, typename
_Compare = less&lt;typename _Sequence::value_type&gt;&gt;
size_type std::priority_queue&lt; _Tp, _Sequence, _Compare
&gt;::size () const</b> <tt>[inline]</tt> <br>
Returns the number of elements in the queue.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Sequence = vector&lt;_Tp&gt;, typename
_Compare = less&lt;typename _Sequence::value_type&gt;&gt;
const_reference std::priority_queue&lt; _Tp, _Sequence,
_Compare &gt;::top () const</b> <tt>[inline]</tt> <br>
Returns a read-only (constant) reference to the data at the
first element of the queue.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_parallel::multiseq_partition()</b>, and
<b>__gnu_parallel::multiseq_selection()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
