<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:35 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_Op_create</title>

</head>
<body>
<h1>MPI_Op_create</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_Op_create</b>
&minus; Creates a user-defined combination function
handle.</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Op_create(MPI_User_function *<i>function</i>, int
<i>commute</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>MPI_Op *<i>op</i>)</p></td></tr>
</table>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_OP_CREATE(<i>FUNCTION, COMMUTE, OP, IERROR</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>EXTERNAL</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>FUNCTION</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>LOGICAL</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>COMMUTE</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>OP, IERROR</i></p></td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_Op_create(<i>user_fn</i>, <i>commute</i>, <i>op</i>,
<i>ierror</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>PROCEDURE(MPI_User_function) :: <i>user_fn</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>LOGICAL, INTENT(IN) :: <i>commute</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Op), INTENT(OUT) :: <i>op</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
void Op::Init(User function* <i>function</i>, bool
<i>commute</i>)</p>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">function</p></td>
<td width="3%"></td>
<td width="57%">


<p style="margin-top: 1em">User-defined function
(function).</p> </td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>commute</p></td>
<td width="3%"></td>
<td width="57%">


<p>True if commutative; false otherwise.</p></td>
<td width="17%">
</td></tr>
</table>

<h2>OUTPUT PARAMETERS
<a name="OUTPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em">op</p></td>
<td width="6%"></td>
<td width="57%">


<p style="margin-top: 1em">Operation (handle).</p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>IERROR</p></td>
<td width="6%"></td>
<td width="57%">


<p>Fortran only: Error status (integer).</p></td>
<td width="17%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Op_create
binds a user-defined global operation to an op handle that
can subsequently be used in MPI_Reduce, MPI_Allreduce,
MPI_Reduce_scatter, and MPI_Scan. The user-defined operation
is assumed to be associative. If commute = true, then the
operation should be both commutative and associative. If
commute = false, then the order of operands is fixed and is
defined to be in ascending, process rank order, beginning
with process zero. The order of evaluation can be changed,
taking advantage of the associativity of the operation. If
commute = true then the order of evaluation can be changed,
taking advantage of commutativity and associativity.</p>


<p style="margin-left:11%; margin-top: 1em"><i>function</i>
is the user-defined function, which must have the following
four arguments: invec, inoutvec, len, and datatype.</p>

<p style="margin-left:11%; margin-top: 1em">The ANSI-C
prototype for the function is the following:</p>

<p style="margin-left:11%; margin-top: 1em">typedef void
MPI_User_function(void *invec, void *inoutvec, <br>
int *len, <br>
MPI_Datatype *datatype);</p>

<p style="margin-left:11%; margin-top: 1em">The Fortran
declaration of the user-defined function appears below.</p>

<p style="margin-left:11%; margin-top: 1em">FUNCTION
USER_FUNCTION( INVEC(*), INOUTVEC(*), LEN, TYPE) <br>
&lt;type&gt; INVEC(LEN), INOUTVEC(LEN) <br>
INTEGER LEN, TYPE</p>

<p style="margin-left:11%; margin-top: 1em">The datatype
argument is a handle to the data type that was passed into
the call to MPI_Reduce. The user reduce function should be
written such that the following holds: Let
u[0],&nbsp;...,&nbsp;u[len-1] be the len elements in the
communication buffer described by the arguments invec, len,
and datatype when the function is invoked; let
v[0],&nbsp;...,&nbsp;v[len-1] be len elements in the
communication buffer described by the arguments inoutvec,
len, and datatype when the function is invoked; let
w[0],&nbsp;...,&nbsp;w[len-1] be len elements in the
communication buffer described by the arguments inoutvec,
len, and datatype when the function returns; then w[i] =
u[i] o v[i], for i=0&nbsp;,...,&nbsp;len-1, where o is the
reduce operation that the function computes.</p>

<p style="margin-left:11%; margin-top: 1em">Informally, we
can think of invec and inoutvec as arrays of len elements
that function is combining. The result of the reduction
over-writes values in inoutvec, hence the name. Each
invocation of the function results in the pointwise
evaluation of the reduce operator on len elements: i.e, the
function returns in inoutvec[i] the value invec[i] o
inoutvec[i], for i = 0...,&nbsp;count-1, where o is the
combining operation computed by the function.</p>

<p style="margin-left:11%; margin-top: 1em">By internally
comparing the value of the datatype argument to known,
global handles, it is possible to overload the use of a
single user-defined function for several different data
types.</p>

<p style="margin-left:11%; margin-top: 1em">General
datatypes may be passed to the user function. However, use
of datatypes that are not contiguous is likely to lead to
inefficiencies.</p>

<p style="margin-left:11%; margin-top: 1em">No MPI
communication function may be called inside the user
function. MPI_Abort may be called inside the function in
case of an error.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Suppose one
defines a library of user-defined reduce functions that are
overloaded: The datatype argument is used to select the
right execution path at each invocation, according to the
types of the operands. The user-defined reduce function
cannot &quot;decode&quot; the datatype argument that it is
passed, and cannot identify, by itself, the correspondence
between the datatype handles and the datatype they
represent. This correspondence was established when the
datatypes were created. Before the library is used, a
library initialization preamble must be executed. This
preamble code will define the datatypes that are used by the
library and store handles to these datatypes in global,
static variables that are shared by the user code and the
library code.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Example:</b>
Example of user-defined reduce:</p>

<p style="margin-left:11%; margin-top: 1em">Compute the
product of an array of complex numbers, in C.</p>

<p style="margin-left:11%; margin-top: 1em">typedef struct
{ <br>
double real,imag; <br>
} Complex;</p>

<p style="margin-left:11%; margin-top: 1em">/* the
user-defined function <br>
*/ <br>
void myProd( Complex *in, Complex *inout, int *len, <br>
MPI_Datatype *dptr ) <br>
{ <br>
int i; <br>
Complex c;</p>

<p style="margin-left:11%; margin-top: 1em">for (i=0; i&lt;
*len; ++i) { <br>
c.real = inout-&gt;real*in-&gt;real - <br>
inout-&gt;imag*in-&gt;imag; <br>
c.imag = inout-&gt;real*in-&gt;imag + <br>
inout-&gt;imag*in-&gt;real; <br>
*inout = c; <br>
in++; inout++; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">/* and, to call
it... <br>
*/ <br>
...</p>

<p style="margin-left:11%; margin-top: 1em">/* each process
has an array of 100 Complexes <br>
*/ <br>
Complex a[100], answer[100]; <br>
MPI_Op myOp; <br>
MPI_Datatype ctype;</p>

<p style="margin-left:11%; margin-top: 1em">/* explain to
MPI how type Complex is defined <br>
*/ <br>
MPI_Type_contiguous( 2, MPI_DOUBLE, &amp;ctype ); <br>
MPI_Type_commit( &amp;ctype ); <br>
/* create the complex-product user-op <br>
*/ <br>
MPI_Op_create( myProd, True, &amp;myOp );</p>

<p style="margin-left:11%; margin-top: 1em">MPI_Reduce( a,
answer, 100, ctype, myOp, root, comm );</p>

<p style="margin-left:11%; margin-top: 1em">/* At this
point, the answer, which consists of 100 Complexes, <br>
* resides on process root <br>
*/</p>

<p style="margin-left:11%; margin-top: 1em">The Fortran
version of MPI_Reduce will invoke a user-defined reduce
function using the Fortran calling conventions and will pass
a Fortran-type datatype argument; the C version will use C
calling convention and the C representation of a datatype
handle. Users who plan to mix languages should define their
reduction functions accordingly.</p>

<h2>NOTES ON COLLECTIVE OPERATIONS
<a name="NOTES ON COLLECTIVE OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The reduction
functions ( <i>MPI_Op</i> ) do not return an error value. As
a result, if the functions detect an error, all they can do
is either call <i>MPI_Abort</i> or silently skip the
problem. Thus, if you change the error handler from
<i>MPI_ERRORS_ARE_FATAL</i> to something else, for example,
<i>MPI_ERRORS_RETURN</i> , then no error may be
indicated.</p>

<p style="margin-left:11%; margin-top: 1em">The reason for
this is the performance problems in ensuring that all
collective routines return the same error value.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Reduce <br>
MPI_Reduce_scatter <br>
MPI_Allreduce <br>
MPI_Scan <br>
 MPI_Op_free</p>
<hr>
</body>
</html>
