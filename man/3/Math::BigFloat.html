<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:32 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Math::BigFloat</title>

</head>
<body>
<h1>Math::BigFloat</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Math::BigFloat
&minus; arbitrary size floating point math package</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat; <br>
# Configuration methods (may be used as class methods and
instance methods) <br>
Math::BigFloat&minus;&gt;accuracy(); # get class accuracy
<br>
Math::BigFloat&minus;&gt;accuracy($n); # set class accuracy
<br>
Math::BigFloat&minus;&gt;precision(); # get class precision
<br>
Math::BigFloat&minus;&gt;precision($n); # set class
precision <br>
Math::BigFloat&minus;&gt;round_mode(); # get class rounding
mode <br>
Math::BigFloat&minus;&gt;round_mode($m); # set global round
mode, must be one of <br>
# 'even', 'odd', '+inf', '&minus;inf', 'zero', <br>
# 'trunc', or 'common' <br>
Math::BigFloat&minus;&gt;config(&quot;lib&quot;); # name of
backend math library <br>
# Constructor methods (when the class methods below are used
as instance <br>
# methods, the value is assigned the invocand) <br>
$x = Math::BigFloat&minus;&gt;new($str); # defaults to 0
<br>
$x = Math::BigFloat&minus;&gt;new('0x123'); # from
hexadecimal <br>
$x = Math::BigFloat&minus;&gt;new('0o377'); # from octal
<br>
$x = Math::BigFloat&minus;&gt;new('0b101'); # from binary
<br>
$x = Math::BigFloat&minus;&gt;from_hex('0xc.afep+3'); # from
hex <br>
$x = Math::BigFloat&minus;&gt;from_hex('cafe'); # ditto <br>
$x = Math::BigFloat&minus;&gt;from_oct('1.3267p&minus;4'); #
from octal <br>
$x = Math::BigFloat&minus;&gt;from_oct('01.3267p&minus;4');
# ditto <br>
$x = Math::BigFloat&minus;&gt;from_oct('0o1.3267p&minus;4');
# ditto <br>
$x = Math::BigFloat&minus;&gt;from_oct('0377'); # ditto <br>
$x = Math::BigFloat&minus;&gt;from_bin('0b1.1001p&minus;4');
# from binary <br>
$x = Math::BigFloat&minus;&gt;from_bin('0101'); # ditto <br>
$x = Math::BigFloat&minus;&gt;from_ieee754($b,
&quot;binary64&quot;); # from IEEE&minus;754 bytes <br>
$x = Math::BigFloat&minus;&gt;bzero(); # create a +0 <br>
$x = Math::BigFloat&minus;&gt;bone(); # create a +1 <br>
$x = Math::BigFloat&minus;&gt;bone('&minus;'); # create a
&minus;1 <br>
$x = Math::BigFloat&minus;&gt;binf(); # create a +inf <br>
$x = Math::BigFloat&minus;&gt;binf('&minus;'); # create a
&minus;inf <br>
$x = Math::BigFloat&minus;&gt;bnan(); # create a
Not&minus;A&minus;Number <br>
$x = Math::BigFloat&minus;&gt;bpi(); # returns pi <br>
$y = $x&minus;&gt;copy(); # make a copy (unlike $y = $x)
<br>
$y = $x&minus;&gt;as_int(); # return as BigInt <br>
# Boolean methods (these don't modify the invocand) <br>
$x&minus;&gt;is_zero(); # if $x is 0 <br>
$x&minus;&gt;is_one(); # if $x is +1 <br>
$x&minus;&gt;is_one(&quot;+&quot;); # ditto <br>
$x&minus;&gt;is_one(&quot;&minus;&quot;); # if $x is
&minus;1 <br>
$x&minus;&gt;is_inf(); # if $x is +inf or &minus;inf <br>
$x&minus;&gt;is_inf(&quot;+&quot;); # if $x is +inf <br>
$x&minus;&gt;is_inf(&quot;&minus;&quot;); # if $x is
&minus;inf <br>
$x&minus;&gt;is_nan(); # if $x is NaN <br>
$x&minus;&gt;is_positive(); # if $x &gt; 0 <br>
$x&minus;&gt;is_pos(); # ditto <br>
$x&minus;&gt;is_negative(); # if $x &lt; 0 <br>
$x&minus;&gt;is_neg(); # ditto <br>
$x&minus;&gt;is_odd(); # if $x is odd <br>
$x&minus;&gt;is_even(); # if $x is even <br>
$x&minus;&gt;is_int(); # if $x is an integer <br>
# Comparison methods <br>
$x&minus;&gt;bcmp($y); # compare numbers (undef, &lt; 0, ==
0, &gt; 0) <br>
$x&minus;&gt;bacmp($y); # compare absolutely (undef, &lt; 0,
== 0, &gt; 0) <br>
$x&minus;&gt;beq($y); # true if and only if $x == $y <br>
$x&minus;&gt;bne($y); # true if and only if $x != $y <br>
$x&minus;&gt;blt($y); # true if and only if $x &lt; $y <br>
$x&minus;&gt;ble($y); # true if and only if $x &lt;= $y <br>
$x&minus;&gt;bgt($y); # true if and only if $x &gt; $y <br>
$x&minus;&gt;bge($y); # true if and only if $x &gt;= $y <br>
# Arithmetic methods <br>
$x&minus;&gt;bneg(); # negation <br>
$x&minus;&gt;babs(); # absolute value <br>
$x&minus;&gt;bsgn(); # sign function (&minus;1, 0, 1, or
NaN) <br>
$x&minus;&gt;bnorm(); # normalize (no&minus;op) <br>
$x&minus;&gt;binc(); # increment $x by 1 <br>
$x&minus;&gt;bdec(); # decrement $x by 1 <br>
$x&minus;&gt;badd($y); # addition (add $y to $x) <br>
$x&minus;&gt;bsub($y); # subtraction (subtract $y from $x)
<br>
$x&minus;&gt;bmul($y); # multiplication (multiply $x by $y)
<br>
$x&minus;&gt;bmuladd($y,$z); # $x = $x * $y + $z <br>
$x&minus;&gt;bdiv($y); # division (floored), set $x to
quotient <br>
# return (quo,rem) or quo if scalar <br>
$x&minus;&gt;btdiv($y); # division (truncated), set $x to
quotient <br>
# return (quo,rem) or quo if scalar <br>
$x&minus;&gt;bmod($y); # modulus (x % y) <br>
$x&minus;&gt;btmod($y); # modulus (truncated) <br>
$x&minus;&gt;bmodinv($mod); # modular multiplicative inverse
<br>
$x&minus;&gt;bmodpow($y,$mod); # modular exponentiation (($x
** $y) % $mod) <br>
$x&minus;&gt;bpow($y); # power of arguments (x ** y) <br>
$x&minus;&gt;blog(); # logarithm of $x to base e (Euler's
number) <br>
$x&minus;&gt;blog($base); # logarithm of $x to base $base
(e.g., base 2) <br>
$x&minus;&gt;bexp(); # calculate e ** $x where e is Euler's
number <br>
$x&minus;&gt;bnok($y); # x over y (binomial coefficient n
over k) <br>
$x&minus;&gt;bsin(); # sine <br>
$x&minus;&gt;bcos(); # cosine <br>
$x&minus;&gt;batan(); # inverse tangent <br>
$x&minus;&gt;batan2($y); # two&minus;argument inverse
tangent <br>
$x&minus;&gt;bsqrt(); # calculate square root <br>
$x&minus;&gt;broot($y); # $y'th root of $x (e.g. $y == 3
=&gt; cubic root) <br>
$x&minus;&gt;bfac(); # factorial of $x (1*2*3*4*..$x) <br>
$x&minus;&gt;blsft($n); # left shift $n places in base 2
<br>
$x&minus;&gt;blsft($n,$b); # left shift $n places in base $b
<br>
# returns (quo,rem) or quo (scalar context) <br>
$x&minus;&gt;brsft($n); # right shift $n places in base 2
<br>
$x&minus;&gt;brsft($n,$b); # right shift $n places in base
$b <br>
# returns (quo,rem) or quo (scalar context) <br>
# Bitwise methods <br>
$x&minus;&gt;band($y); # bitwise and <br>
$x&minus;&gt;bior($y); # bitwise inclusive or <br>
$x&minus;&gt;bxor($y); # bitwise exclusive or <br>
$x&minus;&gt;bnot(); # bitwise not (two's complement) <br>
# Rounding methods <br>
$x&minus;&gt;round($A,$P,$mode); # round to accuracy or
precision using <br>
# rounding mode $mode <br>
$x&minus;&gt;bround($n); # accuracy: preserve $n digits <br>
$x&minus;&gt;bfround($n); # $n &gt; 0: round to $nth digit
left of dec. point <br>
# $n &lt; 0: round to $nth digit right of dec. point <br>
$x&minus;&gt;bfloor(); # round towards minus infinity <br>
$x&minus;&gt;bceil(); # round towards plus infinity <br>
$x&minus;&gt;bint(); # round towards zero <br>
# Other mathematical methods <br>
$x&minus;&gt;bgcd($y); # greatest common divisor <br>
$x&minus;&gt;blcm($y); # least common multiple <br>
# Object property methods (do not modify the invocand) <br>
$x&minus;&gt;sign(); # the sign, either +, &minus; or NaN
<br>
$x&minus;&gt;digit($n); # the nth digit, counting from the
right <br>
$x&minus;&gt;digit(&minus;$n); # the nth digit, counting
from the left <br>
$x&minus;&gt;length(); # return number of digits in number
<br>
($xl,$f) = $x&minus;&gt;length(); # length of number and
length of fraction <br>
# part, latter is always 0 digits long <br>
# for Math::BigInt objects <br>
$x&minus;&gt;mantissa(); # return (signed) mantissa as
BigInt <br>
$x&minus;&gt;exponent(); # return exponent as BigInt <br>
$x&minus;&gt;parts(); # return (mantissa,exponent) as BigInt
<br>
$x&minus;&gt;sparts(); # mantissa and exponent (as integers)
<br>
$x&minus;&gt;nparts(); # mantissa and exponent (normalised)
<br>
$x&minus;&gt;eparts(); # mantissa and exponent (engineering
notation) <br>
$x&minus;&gt;dparts(); # integer and fraction part <br>
$x&minus;&gt;fparts(); # numerator and denominator <br>
$x&minus;&gt;numerator(); # numerator <br>
$x&minus;&gt;denominator(); # denominator <br>
# Conversion methods (do not modify the invocand) <br>
$x&minus;&gt;bstr(); # decimal notation, possibly zero
padded <br>
$x&minus;&gt;bsstr(); # string in scientific notation with
integers <br>
$x&minus;&gt;bnstr(); # string in normalized notation <br>
$x&minus;&gt;bestr(); # string in engineering notation <br>
$x&minus;&gt;bdstr(); # string in decimal notation <br>
$x&minus;&gt;as_hex(); # as signed hexadecimal string with
prefixed 0x <br>
$x&minus;&gt;as_bin(); # as signed binary string with
prefixed 0b <br>
$x&minus;&gt;as_oct(); # as signed octal string with
prefixed 0 <br>
$x&minus;&gt;to_ieee754($format); # to bytes encoded
according to IEEE 754&minus;2008 <br>
# Other conversion methods <br>
$x&minus;&gt;numify(); # return as scalar (might overflow or
underflow)</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Math::BigFloat
provides support for arbitrary precision floating point.
Overloading is also provided for Perl operators.</p>

<p style="margin-left:11%; margin-top: 1em">All operators
(including basic math operations) are overloaded if you
declare your big floating point numbers as</p>

<p style="margin-left:11%; margin-top: 1em">$x =
Math::BigFloat &minus;&gt;
new('12_3.456_789_123_456_789E&minus;2');</p>

<p style="margin-left:11%; margin-top: 1em">Operations with
overloaded operators preserve the arguments, which is
exactly what you expect.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Input</b>
<br>
Input values to these routines may be any scalar number or
string that looks like a number. Anything that is accepted
by Perl as a literal numeric constant should be accepted by
this module.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Leading and trailing whitespace is ignored.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Leading zeros are ignored, except for floating point
numbers with a binary exponent, in which case the number is
interpreted as an octal floating point number. For example,
&quot;01.4p+0&quot; gives 1.5, &quot;00.4p+0&quot; gives
0.5, but &quot;0.4p+0&quot; gives a NaN. And while
&quot;0377&quot; gives 255, &quot;0377p0&quot; gives
255.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the string has a &quot;0x&quot; or &quot;0X&quot;
prefix, it is interpreted as a hexadecimal number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the string has a &quot;0o&quot; or &quot;0O&quot;
prefix, it is interpreted as an octal number. A floating
point literal with a &quot;0&quot; prefix is also
interpreted as an octal number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the string has a &quot;0b&quot; or &quot;0B&quot;
prefix, it is interpreted as a binary number.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Underline characters are allowed in the same way as they
are allowed in literal numerical constants.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the string can not be interpreted, NaN is
returned.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>For hexadecimal, octal, and binary floating point
numbers, the exponent must be separated from the significand
(mantissa) by the letter &quot;p&quot; or &quot;P&quot;, not
&quot;e&quot; or &quot;E&quot; as with decimal numbers.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Some examples
of valid string input</p>

<p style="margin-left:11%; margin-top: 1em">Input string
Resulting value <br>
123 123 <br>
1.23e2 123 <br>
12300e&minus;2 123 <br>
67_538_754 67538754 <br>
&minus;4_5_6.7_8_9e+0_1_0 &minus;4567890000000 <br>
0x13a 314 <br>
0x13ap0 314 <br>
0x1.3ap+8 314 <br>
0x0.00013ap+24 314 <br>
0x13a000p&minus;12 314 <br>
0o472 314 <br>
0o1.164p+8 314 <br>
0o0.0001164p+20 314 <br>
0o1164000p&minus;10 314 <br>
0472 472 Note! <br>
01.164p+8 314 <br>
00.0001164p+20 314 <br>
01164000p&minus;10 314 <br>
0b100111010 314 <br>
0b1.0011101p+8 314 <br>
0b0.00010011101p+12 314 <br>
0b100111010000p&minus;3 314 <br>
0x1.921fb5p+1 3.14159262180328369140625e+0 <br>
0o1.2677025p1 2.71828174591064453125 <br>
01.2677025p1 2.71828174591064453125 <br>
0b1.1001p&minus;4 9.765625e&minus;2</p>

<p style="margin-left:11%; margin-top: 1em"><b>Output</b>
<br>
Output values are usually Math::BigFloat objects.</p>

<p style="margin-left:11%; margin-top: 1em">Boolean
operators &quot;is_zero()&quot;, &quot;is_one()&quot;,
&quot;is_inf()&quot;, etc. return true or false.</p>

<p style="margin-left:11%; margin-top: 1em">Comparison
operators &quot;bcmp()&quot; and &quot;bacmp()&quot;) return
&minus;1, 0, 1, or undef.</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Math::BigFloat
supports all methods that Math::BigInt supports, except it
calculates non-integer results when possible. Please see
Math::BigInt for a full description of each method. Below
are just the most important differences:</p>


<p style="margin-left:11%; margin-top: 1em"><b>Configuration
methods <br>
accuracy()</b></p>

<p style="margin-left:17%;">$x&minus;&gt;accuracy(5); #
local for $x <br>
CLASS&minus;&gt;accuracy(5); # global for all members of
CLASS <br>
# Note: This also applies to new()! <br>
$A = $x&minus;&gt;accuracy(); # read out accuracy that
affects $x <br>
$A = CLASS&minus;&gt;accuracy(); # read out global
accuracy</p>

<p style="margin-left:17%; margin-top: 1em">Set or get the
global or local accuracy, aka how many significant digits
the results have. If you set a global accuracy, then this
also applies to <b>new()</b>!</p>

<p style="margin-left:17%; margin-top: 1em">Warning! The
accuracy <i>sticks</i>, e.g. once you created a number under
the influence of &quot;CLASS&minus;&gt;accuracy($A)&quot;,
all results from math operations with that number will also
be rounded.</p>

<p style="margin-left:17%; margin-top: 1em">In most cases,
you should probably round the results explicitly using one
of &quot;<b>round()</b>&quot; in Math::BigInt,
&quot;<b>bround()</b>&quot; in Math::BigInt or
&quot;<b>bfround()</b>&quot; in Math::BigInt or by passing
the desired accuracy to the math operation as additional
parameter:</p>

<p style="margin-left:17%; margin-top: 1em">my $x =
Math::BigInt&minus;&gt;new(30000); <br>
my $y = Math::BigInt&minus;&gt;new(7); <br>
print scalar $x&minus;&gt;copy()&minus;&gt;bdiv($y, 2); #
print 4300 <br>
print scalar
$x&minus;&gt;copy()&minus;&gt;bdiv($y)&minus;&gt;bround(2);
# print 4300</p>

<p style="margin-left:11%;"><b>precision()</b></p>


<p style="margin-left:17%;">$x&minus;&gt;precision(&minus;2);
# local for $x, round at the second <br>
# digit right of the dot <br>
$x&minus;&gt;precision(2); # ditto, round at the second
digit <br>
# left of the dot <br>
CLASS&minus;&gt;precision(5); # Global for all members of
CLASS <br>
# This also applies to new()! <br>
CLASS&minus;&gt;precision(&minus;5); # ditto <br>
$P = CLASS&minus;&gt;precision(); # read out global
precision <br>
$P = $x&minus;&gt;precision(); # read out precision that
affects $x</p>

<p style="margin-left:17%; margin-top: 1em">Note: You
probably want to use &quot;<b>accuracy()</b>&quot; instead.
With &quot;<b>accuracy()</b>&quot; you set the number of
digits each result should have, with
&quot;<b>precision()</b>&quot; you set the place where to
round!</p>

<p style="margin-left:11%; margin-top: 1em"><b>Constructor
methods <br>
from_hex()</b></p>

<p style="margin-left:17%;">$x &minus;&gt;
from_hex(&quot;0x1.921fb54442d18p+1&quot;); <br>
$x = Math::BigFloat &minus;&gt;
from_hex(&quot;0x1.921fb54442d18p+1&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">Interpret input
as a hexadecimal string.A prefix (&quot;0x&quot;,
&quot;x&quot;, ignoring case) is optional. A single
underscore character (&quot;_&quot;) may be placed between
any two digits. If the input is invalid, a NaN is returned.
The exponent is in base 2 using decimal digits.</p>

<p style="margin-left:17%; margin-top: 1em">If called as an
instance method, the value is assigned to the invocand.</p>

<p style="margin-left:11%;"><b>from_oct()</b></p>

<p style="margin-left:17%;">$x &minus;&gt;
from_oct(&quot;1.3267p&minus;4&quot;); <br>
$x = Math::BigFloat &minus;&gt;
from_oct(&quot;1.3267p&minus;4&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">Interpret input
as an octal string. A single underscore character
(&quot;_&quot;) may be placed between any two digits. If the
input is invalid, a NaN is returned. The exponent is in base
2 using decimal digits.</p>

<p style="margin-left:17%; margin-top: 1em">If called as an
instance method, the value is assigned to the invocand.</p>

<p style="margin-left:11%;"><b>from_bin()</b></p>

<p style="margin-left:17%;">$x &minus;&gt;
from_bin(&quot;0b1.1001p&minus;4&quot;); <br>
$x = Math::BigFloat &minus;&gt;
from_bin(&quot;0b1.1001p&minus;4&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">Interpret input
as a hexadecimal string. A prefix (&quot;0b&quot; or
&quot;b&quot;, ignoring case) is optional. A single
underscore character (&quot;_&quot;) may be placed between
any two digits. If the input is invalid, a NaN is returned.
The exponent is in base 2 using decimal digits.</p>

<p style="margin-left:17%; margin-top: 1em">If called as an
instance method, the value is assigned to the invocand.</p>

<p style="margin-left:11%;"><b>from_ieee754()</b></p>

<p style="margin-left:17%;">Interpret the input as a value
encoded as described in <small>IEEE754&minus;2008.</small>
The input can be given as a byte string, hex string or
binary string. The input is assumed to be in big-endian
byte-order.</p>

<p style="margin-left:17%; margin-top: 1em"># both $dbl and
$mbf are 3.141592... <br>
$bytes = &quot;\x40\x09\x21\xfb\x54\x44\x2d\x18&quot;; <br>
$dbl = unpack &quot;d&gt;&quot;, $bytes; <br>
$mbf = Math::BigFloat &minus;&gt; from_ieee754($bytes,
&quot;binary64&quot;);</p>

<p style="margin-left:11%;"><b>bpi()</b></p>

<p style="margin-left:17%;">print
Math::BigFloat&minus;&gt;bpi(100), &quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Calculate
<small>PI</small> to N digits (including the 3 before the
dot). The result is rounded according to the current
rounding mode, which defaults to &quot;even&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Arithmetic
methods <br>
bmuladd()</b></p>


<p style="margin-left:17%;">$x&minus;&gt;bmuladd($y,$z);</p>

<p style="margin-left:17%; margin-top: 1em">Multiply $x by
$y, and then add $z to the result.</p>

<p style="margin-left:17%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>

<p style="margin-left:11%;"><b>bdiv()</b></p>

<p style="margin-left:17%;">$q = $x&minus;&gt;bdiv($y);
<br>
($q, $r) = $x&minus;&gt;bdiv($y);</p>

<p style="margin-left:17%; margin-top: 1em">In scalar
context, divides $x by $y and returns the result to the
given or default accuracy/precision. In list context, does
floored division (F&minus;division), returning an integer $q
and a remainder $r so that $x = $q * $y + $r. The remainer
(modulo) is equal to what is returned by
&quot;$x&minus;&gt;bmod($y)&quot;.</p>

<p style="margin-left:11%;"><b>bmod()</b></p>

<p style="margin-left:17%;">$x&minus;&gt;bmod($y);</p>

<p style="margin-left:17%; margin-top: 1em">Returns $x
modulo $y. When $x is finite, and $y is finite and non-zero,
the result is identical to the remainder after floored
division (F&minus;division). If, in addition, both $x and $y
are integers, the result is identical to the result from
Perl&rsquo;s % operator.</p>

<p style="margin-left:11%;"><b>bexp()</b></p>

<p style="margin-left:17%;">$x&minus;&gt;bexp($accuracy); #
calculate e ** X</p>

<p style="margin-left:17%; margin-top: 1em">Calculates the
expression &quot;e ** $x&quot; where &quot;e&quot; is
Euler&rsquo;s number.</p>

<p style="margin-left:17%; margin-top: 1em">This method was
added in v1.82 of Math::BigInt (April 2007).</p>

<p style="margin-left:11%;"><b>bnok()</b></p>

<p style="margin-left:17%;">$x&minus;&gt;bnok($y); # x over
y (binomial coefficient n over k)</p>

<p style="margin-left:17%; margin-top: 1em">Calculates the
binomial coefficient n over k, also called the
&quot;choose&quot; function. The result is equivalent
to:</p>

<p style="margin-left:17%; margin-top: 1em">( n ) n! <br>
| &minus; | =
&minus;&minus;&minus;&minus;&minus;&minus;&minus; <br>
( k ) k!(n&minus;k)!</p>

<p style="margin-left:17%; margin-top: 1em">This method was
added in v1.84 of Math::BigInt (April 2007).</p>

<p style="margin-left:11%;"><b>bsin()</b></p>

<p style="margin-left:17%;">my $x =
Math::BigFloat&minus;&gt;new(1); <br>
print $x&minus;&gt;bsin(100), &quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Calculate the
sinus of $x, modifying $x in place.</p>

<p style="margin-left:17%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>

<p style="margin-left:11%;"><b>bcos()</b></p>

<p style="margin-left:17%;">my $x =
Math::BigFloat&minus;&gt;new(1); <br>
print $x&minus;&gt;bcos(100), &quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Calculate the
cosinus of $x, modifying $x in place.</p>

<p style="margin-left:17%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>

<p style="margin-left:11%;"><b>batan()</b></p>

<p style="margin-left:17%;">my $x =
Math::BigFloat&minus;&gt;new(1); <br>
print $x&minus;&gt;batan(100), &quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Calculate the
arcus tanges of $x, modifying $x in place. See also
&quot;<b>batan2()</b>&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>

<p style="margin-left:11%;"><b>batan2()</b></p>

<p style="margin-left:17%;">my $y =
Math::BigFloat&minus;&gt;new(2); <br>
my $x = Math::BigFloat&minus;&gt;new(3); <br>
print $y&minus;&gt;batan2($x), &quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Calculate the
arcus tanges of $y divided by $x, modifying $y in place. See
also &quot;<b>batan()</b>&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>

<p style="margin-left:11%;"><b>as_float()</b></p>

<p style="margin-left:17%;">This method is called when
Math::BigFloat encounters an object it doesn&rsquo;t know
how to handle. For instance, assume $x is a Math::BigFloat,
or subclass thereof, and $y is defined, but not a
Math::BigFloat, or subclass thereof. If you do</p>

<p style="margin-left:17%; margin-top: 1em">$x &minus;&gt;
badd($y);</p>

<p style="margin-left:17%; margin-top: 1em">$y needs to be
converted into an object that $x can deal with. This is done
by first checking if $y is something that $x might be
upgraded to. If that is the case, no further attempts are
made. The next is to see if $y supports the method
&quot;as_float()&quot;. The method &quot;as_float()&quot; is
expected to return either an object that has the same class
as $x, a subclass thereof, or a string that
&quot;ref($x)&minus;&gt;new()&quot; can parse to create an
object.</p>

<p style="margin-left:17%; margin-top: 1em">In
Math::BigFloat, &quot;as_float()&quot; has the same effect
as &quot;copy()&quot;.</p>

<p style="margin-left:11%;"><b>to_ieee754()</b></p>

<p style="margin-left:17%;">Encodes the invocand as a byte
string in the given format as specified in <small>IEEE
754&minus;2008.</small> Note that the encoded value is the
nearest possible representation of the value. This value
might not be exactly the same as the value in the
invocand.</p>

<p style="margin-left:17%; margin-top: 1em"># $x =
3.1415926535897932385 <br>
$x = Math::BigFloat &minus;&gt; bpi(30); <br>
$b = $x &minus;&gt; to_ieee754(&quot;binary64&quot;); #
encode as 8 bytes <br>
$h = unpack &quot;H*&quot;, $b; #
&quot;400921fb54442d18&quot; <br>
# 3.141592653589793115997963... <br>
$y = Math::BigFloat &minus;&gt; from_ieee754($h,
&quot;binary64&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">All binary
formats in <small>IEEE 754&minus;2008</small> are accepted.
For convenience, som aliases are recognized:
&quot;half&quot; for &quot;binary16&quot;,
&quot;single&quot; for &quot;binary32&quot;,
&quot;double&quot; for &quot;binary64&quot;,
&quot;quadruple&quot; for &quot;binary128&quot;,
&quot;octuple&quot; for &quot;binary256&quot;, and
&quot;sexdecuple&quot; for &quot;binary512&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&lt;https://en.wikipedia.org/wiki/IEEE_754&gt;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>ACCURACY
AND PRECISION</small></b> <br>
See also: Rounding.</p>

<p style="margin-left:11%; margin-top: 1em">Math::BigFloat
supports both precision (rounding to a certain place before
or after the dot) and accuracy (rounding to a certain number
of digits). For a full documentation, examples and tips on
these topics please see the large section about rounding in
Math::BigInt.</p>

<p style="margin-left:11%; margin-top: 1em">Since things
like sqrt(2) or &quot;1 / 3&quot; must presented with a
limited accuracy lest a operation consumes all resources,
each operation produces no more than the requested number of
digits.</p>

<p style="margin-left:11%; margin-top: 1em">If there is no
global precision or accuracy set, <b>and</b> the operation
in question was not called with a requested precision or
accuracy, <b>and</b> the input $x has no accuracy or
precision set, then a fallback parameter will be used. For
historical reasons, it is called &quot;div_scale&quot; and
can be accessed via:</p>

<p style="margin-left:11%; margin-top: 1em">$d =
Math::BigFloat&minus;&gt;div_scale(); # query <br>
Math::BigFloat&minus;&gt;div_scale($n); # set to $n
digits</p>

<p style="margin-left:11%; margin-top: 1em">The default
value for &quot;div_scale&quot; is 40.</p>

<p style="margin-left:11%; margin-top: 1em">In case the
result of one operation has more digits than specified, it
is rounded. The rounding mode taken is either the default
mode, or the one supplied to the operation after the
<i>scale</i>:</p>

<p style="margin-left:11%; margin-top: 1em">$x =
Math::BigFloat&minus;&gt;new(2); <br>
Math::BigFloat&minus;&gt;accuracy(5); # 5 digits max <br>
$y = $x&minus;&gt;copy()&minus;&gt;bdiv(3); # gives 0.66667
<br>
$y = $x&minus;&gt;copy()&minus;&gt;bdiv(3,6); # gives
0.666667 <br>
$y = $x&minus;&gt;copy()&minus;&gt;bdiv(3,6,undef,'odd'); #
gives 0.666667 <br>
Math::BigFloat&minus;&gt;round_mode('zero'); <br>
$y = $x&minus;&gt;copy()&minus;&gt;bdiv(3,6); # will also
give 0.666667</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;Math::BigFloat&minus;&gt;accuracy()&quot; and
&quot;Math::BigFloat&minus;&gt;precision()&quot; set the
global variables, and thus <b>any</b> newly created number
will be subject to the global rounding <b>immediately</b>.
This means that in the examples above, the 3 as argument to
&quot;bdiv()&quot; will also get an accuracy of
<b>5</b>.</p>

<p style="margin-left:11%; margin-top: 1em">It is less
confusing to either calculate the result fully, and
afterwards round it explicitly, or use the additional
parameters to the math functions like so:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat; <br>
$x = Math::BigFloat&minus;&gt;new(2); <br>
$y = $x&minus;&gt;copy()&minus;&gt;bdiv(3); <br>
print $y&minus;&gt;bround(5),&quot;\n&quot;; # gives 0.66667
<br>
or <br>
use Math::BigFloat; <br>
$x = Math::BigFloat&minus;&gt;new(2); <br>
$y = $x&minus;&gt;copy()&minus;&gt;bdiv(3,5); # gives
0.66667 <br>
print &quot;$y\n&quot;;</p>


<p style="margin-left:11%; margin-top: 1em"><b>Rounding</b>
<br>
bfround ( +$scale )</p>

<p style="margin-left:17%;">Rounds to the $scale&rsquo;th
place left from the &rsquo;.&rsquo;, counting from the dot.
The first digit is numbered 1.</p>

<p style="margin-left:11%;">bfround ( &minus;$scale )</p>

<p style="margin-left:17%;">Rounds to the $scale&rsquo;th
place right from the &rsquo;.&rsquo;, counting from the
dot.</p>

<p style="margin-left:11%;">bfround ( 0 )</p>

<p style="margin-left:17%;">Rounds to an integer.</p>

<p style="margin-left:11%;">bround ( +$scale )</p>

<p style="margin-left:17%;">Preserves accuracy to $scale
digits from the left (aka significant digits) and pads the
rest with zeros. If the number is between 1 and &minus;1,
the significant digits count from the first non-zero after
the &rsquo;.&rsquo;</p>

<p style="margin-left:11%;">bround ( &minus;$scale ) and
bround ( 0 )</p>

<p style="margin-left:17%;">These are effectively
no-ops.</p>

<p style="margin-left:11%; margin-top: 1em">All rounding
functions take as a second parameter a rounding mode from
one of the following: &rsquo;even&rsquo;, &rsquo;odd&rsquo;,
&rsquo;+inf&rsquo;, &rsquo;&minus;inf&rsquo;,
&rsquo;zero&rsquo;, &rsquo;trunc&rsquo; or
&rsquo;common&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">The default
rounding mode is &rsquo;even&rsquo;. By using
&quot;Math::BigFloat&minus;&gt;round_mode($round_mode);&quot;
you can get and set the default mode for subsequent
rounding. The usage of
&quot;$Math::BigFloat::$round_mode&quot; is no longer
supported. The second parameter to the round functions then
overrides the default temporarily.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;as_number()&quot; function returns a BigInt from a
Math::BigFloat. It uses &rsquo;trunc&rsquo; as rounding mode
to make it equivalent to:</p>

<p style="margin-left:11%; margin-top: 1em">$x = 2.5; <br>
$y = int($x) + 2;</p>

<p style="margin-left:11%; margin-top: 1em">You can
override this by passing the desired rounding mode as
parameter to &quot;as_number()&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">$x =
Math::BigFloat&minus;&gt;new(2.5); <br>
$y = $x&minus;&gt;as_number('odd'); # $y = 3</p>

<h2>NUMERIC LITERALS
<a name="NUMERIC LITERALS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">After &quot;use
Math::BigFloat ':constant'&quot; all numeric literals in the
given scope are converted to &quot;Math::BigFloat&quot;
objects. This conversion happens at compile time.</p>

<p style="margin-left:11%; margin-top: 1em">For
example,</p>

<p style="margin-left:11%; margin-top: 1em">perl
&minus;MMath::BigFloat=:constant &minus;le 'print
2e&minus;150'</p>

<p style="margin-left:11%; margin-top: 1em">prints the
exact value of &quot;2e&minus;150&quot;. Note that without
conversion of constants the expression
&quot;2e&minus;150&quot; is calculated using Perl scalars,
which leads to an inaccuracte result.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
strings are not affected, so that</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat qw/:constant/; <br>
$y = &quot;1234567890123456789012345678901234567890&quot;
<br>
+ &quot;123456789123456789&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">does not give
you what you expect. You need an explicit
Math::BigFloat&minus;&gt;<b>new()</b> around at least one of
the operands. You should also quote large constants to
prevent loss of precision:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat; <br>
$x =
Math::BigFloat&minus;&gt;new(&quot;1234567889123456789123456789123456789&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">Without the
quotes Perl converts the large number to a floating point
constant at compile time, and then converts the result to a
Math::BigFloat object at runtime, which results in an
inaccurate result.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Hexadecimal,
octal, and binary floating point literals</b> <br>
Perl (and this module) accepts hexadecimal, octal, and
binary floating point literals, but use them with care with
Perl versions before v5.32.0, because some versions of Perl
silently give the wrong result. Below are some examples of
different ways to write the number decimal 314.</p>

<p style="margin-left:11%; margin-top: 1em">Hexadecimal
floating point literals:</p>

<p style="margin-left:11%; margin-top: 1em">0x1.3ap+8
0X1.3AP+8 <br>
0x1.3ap8 0X1.3AP8 <br>
0x13a0p&minus;4 0X13A0P&minus;4</p>

<p style="margin-left:11%; margin-top: 1em">Octal floating
point literals (with &quot;0&quot; prefix):</p>

<p style="margin-left:11%; margin-top: 1em">01.164p+8
01.164P+8 <br>
01.164p8 01.164P8 <br>
011640p&minus;4 011640P&minus;4</p>

<p style="margin-left:11%; margin-top: 1em">Octal floating
point literals (with &quot;0o&quot; prefix) (requires
v5.34.0):</p>

<p style="margin-left:11%; margin-top: 1em">0o1.164p+8
0O1.164P+8 <br>
0o1.164p8 0O1.164P8 <br>
0o11640p&minus;4 0O11640P&minus;4</p>

<p style="margin-left:11%; margin-top: 1em">Binary floating
point literals:</p>

<p style="margin-left:11%; margin-top: 1em">0b1.0011101p+8
0B1.0011101P+8 <br>
0b1.0011101p8 0B1.0011101P8 <br>
0b10011101000p&minus;2 0B10011101000P&minus;2</p>

<p style="margin-left:11%; margin-top: 1em"><b>Math
library</b> <br>
Math with the numbers is done (by default) by a module
called Math::BigInt::Calc. This is equivalent to saying:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat lib =&gt; &quot;Calc&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">You can change
this by using:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat lib =&gt; &quot;GMP&quot;;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note</b>:
General purpose packages should not be explicit about the
library to use; let the script author decide which is
best.</p>

<p style="margin-left:11%; margin-top: 1em">Note: The
keyword &rsquo;lib&rsquo; will warn when the requested
library could not be loaded. To suppress the warning use
&rsquo;try&rsquo; instead:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat try =&gt; &quot;GMP&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If your script
works with huge numbers and Calc is too slow for them, you
can also for the loading of one of these libraries and if
none of them can be used, the code will die:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat only =&gt; &quot;GMP,Pari&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">The following
would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to
Math::BigInt::Calc:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat lib =&gt;
&quot;Foo,Math::BigInt::Bar&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">See the
respective low-level library documentation for further
details.</p>

<p style="margin-left:11%; margin-top: 1em">See
Math::BigInt for more details about using a different
low-level library.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
Math::BigInt::Lite</b> <br>
For backwards compatibility reasons it is still possible to
request a different storage class for use with
Math::BigFloat:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat with =&gt; 'Math::BigInt::Lite';</p>

<p style="margin-left:11%; margin-top: 1em">However, this
request is ignored, as the current code now uses the
low-level math library for directly storing the number
parts.</p>

<h2>EXPORTS
<a name="EXPORTS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;Math::BigFloat&quot;
exports nothing by default, but can export the
&quot;bpi()&quot; method:</p>

<p style="margin-left:11%; margin-top: 1em">use
Math::BigFloat qw/bpi/; <br>
print bpi(10), &quot;\n&quot;;</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Do not try to
be clever to insert some operations in between switching
libraries:</p>

<p style="margin-left:11%; margin-top: 1em">require
Math::BigFloat; <br>
my $matter = Math::BigFloat&minus;&gt;bone() + 4; # load
BigInt and Calc <br>
Math::BigFloat&minus;&gt;import( lib =&gt; 'Pari' ); # load
Pari, too <br>
my $anti_matter = Math::BigFloat&minus;&gt;bone()+4; # now
use Pari</p>

<p style="margin-left:11%; margin-top: 1em">This will
create objects with numbers stored in two different backend
libraries, and <b><small>VERY BAD THINGS</small></b> will
happen when you use these together:</p>

<p style="margin-left:11%; margin-top: 1em">my
$flash_and_bang = $matter + $anti_matter; # Don't do this!
<br>
stringify, <b>bstr()</b></p>

<p style="margin-left:17%;">Both stringify and
<b>bstr()</b> now drop the leading &rsquo;+&rsquo;. The old
code would return &rsquo;+1.23&rsquo;, the new returns
&rsquo;1.23&rsquo;. See the documentation in Math::BigInt
for reasoning and details.</p>

<p style="margin-left:11%;"><b>brsft()</b></p>

<p style="margin-left:17%;">The following will probably not
print what you expect:</p>

<p style="margin-left:17%; margin-top: 1em">my $c =
Math::BigFloat&minus;&gt;new('3.14159'); <br>
print $c&minus;&gt;brsft(3,10),&quot;\n&quot;; # prints
0.00314153.1415</p>

<p style="margin-left:17%; margin-top: 1em">It prints both
quotient and remainder, since print calls
&quot;brsft()&quot; in list context. Also,
&quot;$c&minus;&gt;brsft()&quot; will modify $c, so be
careful. You probably want to use</p>

<p style="margin-left:17%; margin-top: 1em">print scalar
$c&minus;&gt;copy()&minus;&gt;brsft(3,10),&quot;\n&quot;;
<br>
# or if you really want to modify $c <br>
print scalar $c&minus;&gt;brsft(3,10),&quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">instead.</p>

<p style="margin-left:11%;">Modifying and =</p>

<p style="margin-left:17%;">Beware of:</p>

<p style="margin-left:17%; margin-top: 1em">$x =
Math::BigFloat&minus;&gt;new(5); <br>
$y = $x;</p>

<p style="margin-left:17%; margin-top: 1em">It will not do
what you think, e.g. making a copy of $x. Instead it just
makes a second reference to the <b>same</b> object and
stores it in $y. Thus anything that modifies $x will modify
$y (except overloaded math operators), and vice versa. See
Math::BigInt for details and how to avoid that.</p>

<p style="margin-left:11%;"><b>precision()</b> vs.
<b>accuracy()</b></p>

<p style="margin-left:17%;">A common pitfall is to use
&quot;<b>precision()</b>&quot; when you want to round a
result to a certain number of digits:</p>

<p style="margin-left:17%; margin-top: 1em">use
Math::BigFloat; <br>
Math::BigFloat&minus;&gt;precision(4); # does not do what
you <br>
# think it does <br>
my $x = Math::BigFloat&minus;&gt;new(12345); # rounds $x to
&quot;12000&quot;! <br>
print &quot;$x\n&quot;; # print &quot;12000&quot; <br>
my $y = Math::BigFloat&minus;&gt;new(3); # rounds $y to
&quot;0&quot;! <br>
print &quot;$y\n&quot;; # print &quot;0&quot; <br>
$z = $x / $y; # 12000 / 0 =&gt; NaN! <br>
print &quot;$z\n&quot;; <br>
print $z&minus;&gt;precision(),&quot;\n&quot;; # 4</p>

<p style="margin-left:17%; margin-top: 1em">Replacing
&quot;<b>precision()</b>&quot; with
&quot;<b>accuracy()</b>&quot; is probably not what you want,
either:</p>

<p style="margin-left:17%; margin-top: 1em">use
Math::BigFloat; <br>
Math::BigFloat&minus;&gt;accuracy(4); # enables global
rounding: <br>
my $x = Math::BigFloat&minus;&gt;new(123456); # rounded
immediately <br>
# to &quot;12350&quot; <br>
print &quot;$x\n&quot;; # print &quot;123500&quot; <br>
my $y = Math::BigFloat&minus;&gt;new(3); # rounded to
&quot;3 <br>
print &quot;$y\n&quot;; # print &quot;3&quot; <br>
print $z =
$x&minus;&gt;copy()&minus;&gt;bdiv($y),&quot;\n&quot;; #
41170 <br>
print $z&minus;&gt;accuracy(),&quot;\n&quot;; # 4</p>

<p style="margin-left:17%; margin-top: 1em">What you want
to use instead is:</p>

<p style="margin-left:17%; margin-top: 1em">use
Math::BigFloat; <br>
my $x = Math::BigFloat&minus;&gt;new(123456); # no rounding
<br>
print &quot;$x\n&quot;; # print &quot;123456&quot; <br>
my $y = Math::BigFloat&minus;&gt;new(3); # no rounding <br>
print &quot;$y\n&quot;; # print &quot;3&quot; <br>
print $z =
$x&minus;&gt;copy()&minus;&gt;bdiv($y,4),&quot;\n&quot;; #
41150 <br>
print $z&minus;&gt;accuracy(),&quot;\n&quot;; # undef</p>

<p style="margin-left:17%; margin-top: 1em">In addition to
computing what you expected, the last example also does
<b>not</b> &quot;taint&quot; the result with an accuracy or
precision setting, which would influence any further
operation.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please report
any bugs or feature requests to
&quot;bug&minus;math&minus;bigint at rt.cpan.org&quot;, or
through the web interface at
&lt;https://rt.cpan.org/Ticket/Create.html?Queue=Math&minus;BigInt&gt;
(requires login). We will be notified, and then you&rsquo;ll
automatically be notified of progress on your bug as I make
changes.</p>

<h2>SUPPORT
<a name="SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You can find
documentation for this module with the perldoc command.</p>

<p style="margin-left:11%; margin-top: 1em">perldoc
Math::BigFloat</p>

<p style="margin-left:11%; margin-top: 1em">You can also
look for information at:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p>GitHub</p></td>
<td width="74%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;https://github.com/pjacklam/p5&minus;Math&minus;BigInt&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="40%">


<p style="margin-top: 1em"><small>RT: CPAN</small> &rsquo;s
request tracker</p></td>
<td width="43%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;https://rt.cpan.org/Dist/Display.html?Name=Math&minus;BigInt&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="12%">


<p style="margin-top: 1em">MetaCPAN</p></td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;https://metacpan.org/release/Math&minus;BigInt&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="29%">


<p style="margin-top: 1em"><small>CPAN</small> Testers
Matrix</p> </td>
<td width="54%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;http://matrix.cpantesters.org/?dist=Math&minus;BigInt&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="18%">


<p style="margin-top: 1em"><small>CPAN</small> Ratings</p></td>
<td width="65%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;https://cpanratings.perl.org/dist/Math&minus;BigInt&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">The Bignum mailing list</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="23%"></td>
<td width="31%">


<p style="margin-top: 1em">Post to mailing list</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">&quot;bignum at
lists.scsys.co.uk&quot;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="26%">


<p style="margin-top: 1em">View mailing list</p></td>
<td width="51%">
</td></tr>
</table>


<p style="margin-left:23%; margin-top: 1em">&lt;http://lists.scsys.co.uk/pipermail/bignum/&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="32%">


<p style="margin-top: 1em">Subscribe/Unsubscribe</p></td>
<td width="45%">
</td></tr>
</table>


<p style="margin-left:23%; margin-top: 1em">&lt;http://lists.scsys.co.uk/cgi&minus;bin/mailman/listinfo/bignum&gt;</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
free software; you may redistribute it and/or modify it
under the same terms as Perl itself.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Math::BigInt
and Math::BigInt as well as the backends
Math::BigInt::FastCalc, Math::BigInt::GMP, and
Math::BigInt::Pari.</p>

<p style="margin-left:11%; margin-top: 1em">The pragmas
bignum, bigint and bigrat.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Mark Biggar, overloaded
interface by Ilya Zakharevich, 1996&minus;2001.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Completely rewritten by Tels
&lt;http://bloodgate.com&gt; in 2001&minus;2008.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Florian Ragwitz &lt;flora@cpan.org&gt;, 2010.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Peter John Acklam &lt;pjacklam@gmail.com&gt;,
2011&minus;.</p> </td></tr>
 </table>
<hr>
</body>
</html>
