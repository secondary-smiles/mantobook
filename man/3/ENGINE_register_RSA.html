<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:48 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ENGINE_ADD</title>

</head>
<body>
<h1>ENGINE_register_RSA</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ENGINE_get_DH,
ENGINE_get_DSA, ENGINE_by_id, ENGINE_get_cipher_engine,
ENGINE_get_default_DH, ENGINE_get_default_DSA,
ENGINE_get_default_RAND, ENGINE_get_default_RSA,
ENGINE_get_digest_engine, ENGINE_get_first, ENGINE_get_last,
ENGINE_get_next, ENGINE_get_prev, ENGINE_new,
ENGINE_get_ciphers, ENGINE_get_ctrl_function,
ENGINE_get_digests, ENGINE_get_destroy_function,
ENGINE_get_finish_function, ENGINE_get_init_function,
ENGINE_get_load_privkey_function,
ENGINE_get_load_pubkey_function, ENGINE_load_private_key,
ENGINE_load_public_key, ENGINE_get_RAND, ENGINE_get_RSA,
ENGINE_get_id, ENGINE_get_name, ENGINE_get_cmd_defns,
ENGINE_get_cipher, ENGINE_get_digest, ENGINE_add,
ENGINE_cmd_is_executable, ENGINE_ctrl, ENGINE_ctrl_cmd,
ENGINE_ctrl_cmd_string, ENGINE_finish, ENGINE_free,
ENGINE_get_flags, ENGINE_init, ENGINE_register_DH,
ENGINE_register_DSA, ENGINE_register_RAND,
ENGINE_register_RSA, ENGINE_register_all_complete,
ENGINE_register_ciphers, ENGINE_register_complete,
ENGINE_register_digests, ENGINE_remove, ENGINE_set_DH,
ENGINE_set_DSA, ENGINE_set_RAND, ENGINE_set_RSA,
ENGINE_set_ciphers, ENGINE_set_cmd_defns,
ENGINE_set_ctrl_function, ENGINE_set_default,
ENGINE_set_default_DH, ENGINE_set_default_DSA,
ENGINE_set_default_RAND, ENGINE_set_default_RSA,
ENGINE_set_default_ciphers, ENGINE_set_default_digests,
ENGINE_set_default_string, ENGINE_set_destroy_function,
ENGINE_set_digests, ENGINE_set_finish_function,
ENGINE_set_flags, ENGINE_set_id, ENGINE_set_init_function,
ENGINE_set_load_privkey_function,
ENGINE_set_load_pubkey_function, ENGINE_set_name,
ENGINE_up_ref, ENGINE_get_table_flags, ENGINE_cleanup,
ENGINE_load_builtin_engines, ENGINE_register_all_DH,
ENGINE_register_all_DSA, ENGINE_register_all_RAND,
ENGINE_register_all_RSA, ENGINE_register_all_ciphers,
ENGINE_register_all_digests, ENGINE_set_table_flags,
ENGINE_unregister_DH, ENGINE_unregister_DSA,
ENGINE_unregister_RAND, ENGINE_unregister_RSA,
ENGINE_unregister_ciphers, ENGINE_unregister_digests &minus;
ENGINE cryptographic module support</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/engine.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining
<b><small>OPENSSL_API_COMPAT</small></b> with a suitable
version value, see <b>openssl_user_macros</b>(7):</p>

<p style="margin-left:11%; margin-top: 1em">ENGINE
*ENGINE_get_first(void); <br>
ENGINE *ENGINE_get_last(void); <br>
ENGINE *ENGINE_get_next(ENGINE *e); <br>
ENGINE *ENGINE_get_prev(ENGINE *e); <br>
int ENGINE_add(ENGINE *e); <br>
int ENGINE_remove(ENGINE *e); <br>
ENGINE *ENGINE_by_id(const char *id); <br>
int ENGINE_init(ENGINE *e); <br>
int ENGINE_finish(ENGINE *e); <br>
void ENGINE_load_builtin_engines(void); <br>
ENGINE *ENGINE_get_default_RSA(void); <br>
ENGINE *ENGINE_get_default_DSA(void); <br>
ENGINE *ENGINE_get_default_DH(void); <br>
ENGINE *ENGINE_get_default_RAND(void); <br>
ENGINE *ENGINE_get_cipher_engine(int nid); <br>
ENGINE *ENGINE_get_digest_engine(int nid); <br>
int ENGINE_set_default_RSA(ENGINE *e); <br>
int ENGINE_set_default_DSA(ENGINE *e); <br>
int ENGINE_set_default_DH(ENGINE *e); <br>
int ENGINE_set_default_RAND(ENGINE *e); <br>
int ENGINE_set_default_ciphers(ENGINE *e); <br>
int ENGINE_set_default_digests(ENGINE *e); <br>
int ENGINE_set_default_string(ENGINE *e, const char *list);
<br>
int ENGINE_set_default(ENGINE *e, unsigned int flags); <br>
unsigned int ENGINE_get_table_flags(void); <br>
void ENGINE_set_table_flags(unsigned int flags); <br>
int ENGINE_register_RSA(ENGINE *e); <br>
void ENGINE_unregister_RSA(ENGINE *e); <br>
void ENGINE_register_all_RSA(void); <br>
int ENGINE_register_DSA(ENGINE *e); <br>
void ENGINE_unregister_DSA(ENGINE *e); <br>
void ENGINE_register_all_DSA(void); <br>
int ENGINE_register_DH(ENGINE *e); <br>
void ENGINE_unregister_DH(ENGINE *e); <br>
void ENGINE_register_all_DH(void); <br>
int ENGINE_register_RAND(ENGINE *e); <br>
void ENGINE_unregister_RAND(ENGINE *e); <br>
void ENGINE_register_all_RAND(void); <br>
int ENGINE_register_ciphers(ENGINE *e); <br>
void ENGINE_unregister_ciphers(ENGINE *e); <br>
void ENGINE_register_all_ciphers(void); <br>
int ENGINE_register_digests(ENGINE *e); <br>
void ENGINE_unregister_digests(ENGINE *e); <br>
void ENGINE_register_all_digests(void); <br>
int ENGINE_register_complete(ENGINE *e); <br>
int ENGINE_register_all_complete(void); <br>
int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void
(*f)(void)); <br>
int ENGINE_cmd_is_executable(ENGINE *e, int cmd); <br>
int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name, <br>
long i, void *p, void (*f)(void), int cmd_optional); <br>
int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name,
const char *arg, <br>
int cmd_optional); <br>
ENGINE *ENGINE_new(void); <br>
int ENGINE_free(ENGINE *e); <br>
int ENGINE_up_ref(ENGINE *e); <br>
int ENGINE_set_id(ENGINE *e, const char *id); <br>
int ENGINE_set_name(ENGINE *e, const char *name); <br>
int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);
<br>
int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);
<br>
int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth); <br>
int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD
*rand_meth); <br>
int ENGINE_set_destroy_function(ENGINE *e,
ENGINE_GEN_INT_FUNC_PTR destroy_f); <br>
int ENGINE_set_init_function(ENGINE *e,
ENGINE_GEN_INT_FUNC_PTR init_f); <br>
int ENGINE_set_finish_function(ENGINE *e,
ENGINE_GEN_INT_FUNC_PTR finish_f); <br>
int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR
ctrl_f); <br>
int ENGINE_set_load_privkey_function(ENGINE *e,
ENGINE_LOAD_KEY_PTR loadpriv_f); <br>
int ENGINE_set_load_pubkey_function(ENGINE *e,
ENGINE_LOAD_KEY_PTR loadpub_f); <br>
int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);
<br>
int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);
<br>
int ENGINE_set_flags(ENGINE *e, int flags); <br>
int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN
*defns); <br>
const char *ENGINE_get_id(const ENGINE *e); <br>
const char *ENGINE_get_name(const ENGINE *e); <br>
const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e); <br>
const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e); <br>
const DH_METHOD *ENGINE_get_DH(const ENGINE *e); <br>
const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e); <br>
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const
ENGINE *e); <br>
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const
ENGINE *e); <br>
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const
ENGINE *e); <br>
ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE
*e); <br>
ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const
ENGINE *e); <br>
ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const
ENGINE *e); <br>
ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e); <br>
ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e); <br>
const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);
<br>
const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid); <br>
int ENGINE_get_flags(const ENGINE *e); <br>
const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE
*e); <br>
EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char
*key_id, <br>
UI_METHOD *ui_method, void *callback_data); <br>
EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char
*key_id, <br>
UI_METHOD *ui_method, void *callback_data);</p>

<p style="margin-left:11%; margin-top: 1em">The following
function has been deprecated since OpenSSL 1.1.0, and can be
hidden entirely by defining
<b><small>OPENSSL_API_COMPAT</small></b> with a suitable
version value, see <b>openssl_user_macros</b>(7):</p>

<p style="margin-left:11%; margin-top: 1em">void
ENGINE_cleanup(void);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All of the
functions described on this page are deprecated.
Applications should instead use the provider APIs.</p>

<p style="margin-left:11%; margin-top: 1em">These functions
create, manipulate, and use cryptographic modules in the
form of <b><small>ENGINE</small></b> objects. These objects
act as containers for implementations of cryptographic
algorithms, and support a reference-counted mechanism to
allow them to be dynamically loaded in and out of the
running application.</p>

<p style="margin-left:11%; margin-top: 1em">The
cryptographic functionality that can be provided by an
<b><small>ENGINE</small></b> implementation includes the
following abstractions;</p>

<p style="margin-left:11%; margin-top: 1em">RSA_METHOD
&minus; for providing alternative RSA implementations <br>
DSA_METHOD, DH_METHOD, RAND_METHOD, ECDH_METHOD,
ECDSA_METHOD, <br>
&minus; similarly for other OpenSSL APIs <br>
EVP_CIPHER &minus; potentially multiple cipher algorithms
(indexed by 'nid') <br>
EVP_DIGEST &minus; potentially multiple hash algorithms
(indexed by 'nid') <br>
key&minus;loading &minus; loading public and/or private
EVP_PKEY keys</p>

<p style="margin-left:11%; margin-top: 1em"><b>Reference
counting and handles</b> <br>
Due to the modular nature of the <small>ENGINE API,</small>
pointers to ENGINEs need to be treated as handles &minus;
i.e. not only as pointers, but also as references to the
underlying <small>ENGINE</small> object. Ie. one should
obtain a new reference when making copies of an
<small>ENGINE</small> pointer if the copies will be used
(and released) independently.</p>


<p style="margin-left:11%; margin-top: 1em"><small>ENGINE</small>
objects have two levels of reference-counting to match the
way in which the objects are used. At the most basic level,
each <small>ENGINE</small> pointer is inherently a
<b>structural</b> reference &minus; a structural reference
is required to use the pointer value at all, as this kind of
reference is a guarantee that the structure can not be
deallocated until the reference is released.</p>

<p style="margin-left:11%; margin-top: 1em">However, a
structural reference provides no guarantee that the
<small>ENGINE</small> is initialised and able to use any of
its cryptographic implementations. Indeed it&rsquo;s quite
possible that most ENGINEs will not initialise at all in
typical environments, as ENGINEs are typically used to
support specialised hardware. To use an
<small>ENGINE</small> &rsquo;s functionality, you need a
<b>functional</b> reference. This kind of reference can be
considered a specialised form of structural reference,
because each functional reference implicitly contains a
structural reference as well &minus; however to avoid
difficult-to-find programming bugs, it is recommended to
treat the two kinds of reference independently. If you have
a functional reference to an <small>ENGINE,</small> you have
a guarantee that the <small>ENGINE</small> has been
initialised and is ready to perform cryptographic
operations, and will remain initialised until after you have
released your reference.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Structural
references</i></p>

<p style="margin-left:11%; margin-top: 1em">This basic type
of reference is used for instantiating new ENGINEs,
iterating across OpenSSL&rsquo;s internal linked-list of
loaded ENGINEs, reading information about an
<small>ENGINE,</small> etc. Essentially a structural
reference is sufficient if you only need to query or
manipulate the data of an <small>ENGINE</small>
implementation rather than use its functionality.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>ENGINE_new()</b> function returns a structural reference
to a new (empty) <small>ENGINE</small> object. There are
other <small>ENGINE API</small> functions that return
structural references such as; <b>ENGINE_by_id()</b>,
<b>ENGINE_get_first()</b>, <b>ENGINE_get_last()</b>,
<b>ENGINE_get_next()</b>, <b>ENGINE_get_prev()</b>. All
structural references should be released by a corresponding
to call to the <b>ENGINE_free()</b> function &minus; the
<small>ENGINE</small> object itself will only actually be
cleaned up and deallocated when the last structural
reference is released.</p>

<p style="margin-left:11%; margin-top: 1em">It should also
be noted that many <small>ENGINE API</small> function calls
that accept a structural reference will internally obtain
another reference &minus; typically this happens whenever
the supplied <small>ENGINE</small> will be needed by OpenSSL
after the function has returned. Eg. the function to add a
new <small>ENGINE</small> to OpenSSL&rsquo;s internal list
is <b>ENGINE_add()</b> &minus; if this function returns
success, then OpenSSL will have stored a new structural
reference internally so the caller is still responsible for
freeing their own reference with <b>ENGINE_free()</b> when
they are finished with it. In a similar way, some functions
will automatically release the structural reference passed
to it if part of the function&rsquo;s job is to do so. Eg.
the <b>ENGINE_get_next()</b> and <b>ENGINE_get_prev()</b>
functions are used for iterating across the internal
<small>ENGINE</small> list &minus; they will return a new
structural reference to the next (or previous)
<small>ENGINE</small> in the list or <small>NULL</small> if
at the end (or beginning) of the list, but in either case
the structural reference passed to the function is released
on behalf of the caller.</p>

<p style="margin-left:11%; margin-top: 1em">To clarify a
particular function&rsquo;s handling of references, one
should always consult that function&rsquo;s documentation
&quot;man&quot; page, or failing that the
<i>&lt;openssl/engine.h&gt;</i> header file includes some
hints.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Functional
references</i></p>

<p style="margin-left:11%; margin-top: 1em">As mentioned,
functional references exist when the cryptographic
functionality of an <small>ENGINE</small> is required to be
available. A functional reference can be obtained in one of
two ways; from an existing structural reference to the
required <small>ENGINE,</small> or by asking OpenSSL for the
default operational <small>ENGINE</small> for a given
cryptographic purpose.</p>

<p style="margin-left:11%; margin-top: 1em">To obtain a
functional reference from an existing structural reference,
call the <b>ENGINE_init()</b> function. This returns zero if
the <small>ENGINE</small> was not already operational and
couldn&rsquo;t be successfully initialised (e.g. lack of
system drivers, no special hardware attached, etc),
otherwise it will return nonzero to indicate that the
<small>ENGINE</small> is now operational and will have
allocated a new <b>functional</b> reference to the
<small>ENGINE.</small> All functional references are
released by calling <b>ENGINE_finish()</b> (which removes
the implicit structural reference as well).</p>

<p style="margin-left:11%; margin-top: 1em">The second way
to get a functional reference is by asking OpenSSL for a
default implementation for a given task, e.g. by
<b>ENGINE_get_default_RSA()</b>,
<b>ENGINE_get_default_cipher_engine()</b>, etc. These are
discussed in the next section, though they are not usually
required by application programmers as they are used
automatically when creating and using the relevant
algorithm-specific types in OpenSSL, such as <small>RSA,
DSA, EVP_CIPHER_CTX,</small> etc.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Default
implementations</b> <br>
For each supported abstraction, the <small>ENGINE</small>
code maintains an internal table of state to control which
implementations are available for a given abstraction and
which should be used by default. These implementations are
registered in the tables and indexed by an &rsquo;nid&rsquo;
value, because abstractions like <small>EVP_CIPHER</small>
and <small>EVP_DIGEST</small> support many distinct
algorithms and modes, and ENGINEs can support arbitrarily
many of them. In the case of other abstractions like
<small>RSA, DSA,</small> etc, there is only one
&quot;algorithm&quot; so all implementations implicitly
register using the same &rsquo;nid&rsquo; index.</p>

<p style="margin-left:11%; margin-top: 1em">When a default
<small>ENGINE</small> is requested for a given
abstraction/algorithm/mode, (e.g. when calling
RSA_new_method( <small>NULL</small> )), a
&quot;get_default&quot; call will be made to the
<small>ENGINE</small> subsystem to process the corresponding
state table and return a functional reference to an
initialised <small>ENGINE</small> whose implementation
should be used. If no <small>ENGINE</small> should (or can)
be used, it will return <small>NULL</small> and the caller
will operate with a <small>NULL ENGINE</small> handle
&minus; this usually equates to using the conventional
software implementation. In the latter case, OpenSSL will
from then on behave the way it used to before the
<small>ENGINE API</small> existed.</p>

<p style="margin-left:11%; margin-top: 1em">Each state
table has a flag to note whether it has processed this
&quot;get_default&quot; query since the table was last
modified, because to process this question it must iterate
across all the registered ENGINEs in the table trying to
initialise each of them in turn, in case one of them is
operational. If it returns a functional reference to an
<small>ENGINE,</small> it will also cache another reference
to speed up processing future queries (without needing to
iterate across the table). Likewise, it will cache a
<small>NULL</small> response if no <small>ENGINE</small> was
available so that future queries won&rsquo;t repeat the same
iteration unless the state table changes. This behaviour can
also be changed; if the
<small>ENGINE_TABLE_FLAG_NOINIT</small> flag is set (using
<b>ENGINE_set_table_flags()</b>), no attempted
initialisations will take place, instead the only way for
the state table to return a non-NULL <small>ENGINE</small>
to the &quot;get_default&quot; query will be if one is
expressly set in the table. Eg.
<b>ENGINE_set_default_RSA()</b> does the same job as
<b>ENGINE_register_RSA()</b> except that it also sets the
state table&rsquo;s cached response for the
&quot;get_default&quot; query. In the case of abstractions
like <small>EVP_CIPHER,</small> where implementations are
indexed by &rsquo;nid&rsquo;, these flags and
cached-responses are distinct for each &rsquo;nid&rsquo;
value.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Application
requirements</b> <br>
This section will explain the basic things an application
programmer should support to make the most useful elements
of the <small>ENGINE</small> functionality available to the
user. The first thing to consider is whether the programmer
wishes to make alternative <small>ENGINE</small> modules
available to the application and user. OpenSSL maintains an
internal linked list of &quot;visible&quot; ENGINEs from
which it has to operate &minus; at start-up, this list is
empty and in fact if an application does not call any
<small>ENGINE API</small> calls and it uses static linking
against openssl, then the resulting application binary will
not contain any alternative <small>ENGINE</small> code at
all. So the first consideration is whether any/all available
<small>ENGINE</small> implementations should be made visible
to OpenSSL &minus; this is controlled by calling the various
&quot;load&quot; functions.</p>

<p style="margin-left:11%; margin-top: 1em">The fact that
ENGINEs are made visible to OpenSSL (and thus are linked
into the program and loaded into memory at run-time) does
not mean they are &quot;registered&quot; or called into use
by OpenSSL automatically &minus; that behaviour is something
for the application to control. Some applications will want
to allow the user to specify exactly which
<small>ENGINE</small> they want used if any is to be used at
all. Others may prefer to load all support and have OpenSSL
automatically use at run-time any <small>ENGINE</small> that
is able to successfully initialise &minus; i.e. to assume
that this corresponds to acceleration hardware attached to
the machine or some such thing. There are probably numerous
other ways in which applications may prefer to handle
things, so we will simply illustrate the consequences as
they apply to a couple of simple cases and leave developers
to consider these and the source code to openssl&rsquo;s
built-in utilities as guides.</p>

<p style="margin-left:11%; margin-top: 1em">If no
<small>ENGINE API</small> functions are called within an
application, then OpenSSL will not allocate any internal
resources. Prior to OpenSSL 1.1.0, however, if any ENGINEs
are loaded, even if not registered or used, it was necessary
to call <b>ENGINE_cleanup()</b> before the program
exits.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Using a
specific <small>ENGINE</small> implementation</i></p>

<p style="margin-left:11%; margin-top: 1em">Here
we&rsquo;ll assume an application has been configured by its
user or admin to want to use the &quot; <small>ACME&quot;
ENGINE</small> if it is available in the version of OpenSSL
the application was compiled with. If it is available, it
should be used by default for all <small>RSA, DSA,</small>
and symmetric cipher operations, otherwise OpenSSL should
use its built-in software as per usual. The following code
illustrates how to approach this;</p>

<p style="margin-left:11%; margin-top: 1em">ENGINE *e; <br>
const char *engine_id = &quot;ACME&quot;; <br>
ENGINE_load_builtin_engines(); <br>
e = ENGINE_by_id(engine_id); <br>
if (!e) <br>
/* the engine isn't available */ <br>
return; <br>
if (!ENGINE_init(e)) { <br>
/* the engine couldn't initialise, release 'e' */ <br>
ENGINE_free(e); <br>
return; <br>
} <br>
if (!ENGINE_set_default_RSA(e)) <br>
/* <br>
* This should only happen when 'e' can't initialise, but the
previous <br>
* statement suggests it did. <br>
*/ <br>
abort(); <br>
ENGINE_set_default_DSA(e); <br>
ENGINE_set_default_ciphers(e); <br>
/* Release the functional reference from ENGINE_init() */
<br>
ENGINE_finish(e); <br>
/* Release the structural reference from ENGINE_by_id() */
<br>
ENGINE_free(e);</p>


<p style="margin-left:11%; margin-top: 1em"><i>Automatically
using built-in <small>ENGINE</small> implementations</i></p>

<p style="margin-left:11%; margin-top: 1em">Here
we&rsquo;ll assume we want to load and register all
<small>ENGINE</small> implementations bundled with OpenSSL,
such that for any cryptographic algorithm required by
OpenSSL &minus; if there is an <small>ENGINE</small> that
implements it and can be initialised, it should be used. The
following code illustrates how this can work;</p>

<p style="margin-left:11%; margin-top: 1em">/* Load all
bundled ENGINEs into memory and make them visible */ <br>
ENGINE_load_builtin_engines(); <br>
/* Register all of them for every algorithm they
collectively implement */ <br>
ENGINE_register_all_complete();</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
all that&rsquo;s required. Eg. the next time OpenSSL tries
to set up an <small>RSA</small> key, any bundled ENGINEs
that implement <small>RSA_METHOD</small> will be passed to
<b>ENGINE_init()</b> and if any of those succeed, that
<small>ENGINE</small> will be set as the default for
<small>RSA</small> use from then on.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Advanced
configuration support</b> <br>
There is a mechanism supported by the <small>ENGINE</small>
framework that allows each <small>ENGINE</small>
implementation to define an arbitrary set of configuration
&quot;commands&quot; and expose them to OpenSSL and any
applications based on OpenSSL. This mechanism is entirely
based on the use of name-value pairs and assumes
<small>ASCII</small> input (no unicode or <small>UTF</small>
for now!), so it is ideal if applications want to provide a
transparent way for users to provide arbitrary configuration
&quot;directives&quot; directly to such ENGINEs. It is also
possible for the application to dynamically interrogate the
loaded <small>ENGINE</small> implementations for the names,
descriptions, and input flags of their available
&quot;control commands&quot;, providing a more flexible
configuration scheme. However, if the user is expected to
know which <small>ENGINE</small> device he/she is using (in
the case of specialised hardware, this goes without saying)
then applications may not need to concern themselves with
discovering the supported control commands and simply prefer
to pass settings into ENGINEs exactly as they are provided
by the user.</p>

<p style="margin-left:11%; margin-top: 1em">Before
illustrating how control commands work, it is worth
mentioning what they are typically used for. Broadly
speaking there are two uses for control commands; the first
is to provide the necessary details to the implementation
(which may know nothing at all specific to the host system)
so that it can be initialised for use. This could include
the path to any driver or config files it needs to load,
required network addresses, smart-card identifiers,
passwords to initialise protected devices, logging
information, etc etc. This class of commands typically needs
to be passed to an <small>ENGINE</small> <b>before</b>
attempting to initialise it, i.e. before calling
<b>ENGINE_init()</b>. The other class of commands consist of
settings or operations that tweak certain behaviour or cause
certain operations to take place, and these commands may
work either before or after <b>ENGINE_init()</b>, or in some
cases both. <small>ENGINE</small> implementations should
provide indications of this in the descriptions attached to
built-in control commands and/or in external product
documentation.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Issuing
control commands to an <small>ENGINE</small></i></p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
illustrate by example; a function for which the caller
supplies the name of the <small>ENGINE</small> it wishes to
use, a table of string-pairs for use before initialisation,
and another table for use after initialisation. Note that
the string-pairs used for control commands consist of a
command &quot;name&quot; followed by the command
&quot;parameter&quot; &minus; the parameter could be
<small>NULL</small> in some cases but the name can not. This
function should initialise the <small>ENGINE</small>
(issuing the &quot;pre&quot; commands beforehand and the
&quot;post&quot; commands afterwards) and set it as the
default for everything except <small>RAND</small> and then
return a boolean success or failure.</p>

<p style="margin-left:11%; margin-top: 1em">int
generic_load_engine_fn(const char *engine_id, <br>
const char **pre_cmds, int pre_num, <br>
const char **post_cmds, int post_num) <br>
{ <br>
ENGINE *e = ENGINE_by_id(engine_id); <br>
if (!e) return 0; <br>
while (pre_num&minus;&minus;) { <br>
if (!ENGINE_ctrl_cmd_string(e, pre_cmds[0], pre_cmds[1], 0))
{ <br>
fprintf(stderr, &quot;Failed command (%s &minus;
%s:%s)\n&quot;, engine_id, <br>
pre_cmds[0], pre_cmds[1] ? pre_cmds[1] :
&quot;(NULL)&quot;); <br>
ENGINE_free(e); <br>
return 0; <br>
} <br>
pre_cmds += 2; <br>
} <br>
if (!ENGINE_init(e)) { <br>
fprintf(stderr, &quot;Failed initialisation\n&quot;); <br>
ENGINE_free(e); <br>
return 0; <br>
} <br>
/* <br>
* ENGINE_init() returned a functional reference, so free the
structural <br>
* reference from ENGINE_by_id(). <br>
*/ <br>
ENGINE_free(e); <br>
while (post_num&minus;&minus;) { <br>
if (!ENGINE_ctrl_cmd_string(e, post_cmds[0], post_cmds[1],
0)) { <br>
fprintf(stderr, &quot;Failed command (%s &minus;
%s:%s)\n&quot;, engine_id, <br>
post_cmds[0], post_cmds[1] ? post_cmds[1] :
&quot;(NULL)&quot;); <br>
ENGINE_finish(e); <br>
return 0; <br>
} <br>
post_cmds += 2; <br>
} <br>
ENGINE_set_default(e, ENGINE_METHOD_ALL &amp;
~ENGINE_METHOD_RAND); <br>
/* Success */ <br>
return 1; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<b>ENGINE_ctrl_cmd_string()</b> accepts a boolean argument
that can relax the semantics of the function &minus; if set
nonzero it will only return failure if the
<small>ENGINE</small> supported the given command name but
failed while executing it, if the <small>ENGINE</small>
doesn&rsquo;t support the command name it will simply return
success without doing anything. In this case we assume the
user is only supplying commands specific to the given
<small>ENGINE</small> so we set this to
<small>FALSE.</small></p>

<p style="margin-left:11%; margin-top: 1em"><i>Discovering
supported control commands</i></p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to discover at run-time the names, numerical-ids,
descriptions and input parameters of the control commands
supported by an <small>ENGINE</small> using a structural
reference. Note that some control commands are defined by
OpenSSL itself and it will intercept and handle these
control commands on behalf of the <small>ENGINE,</small>
i.e. the <small>ENGINE</small> &rsquo;s <b>ctrl()</b>
handler is not used for the control command.
<i>&lt;openssl/engine.h&gt;</i> defines an index,
<small>ENGINE_CMD_BASE,</small> that all control commands
implemented by ENGINEs should be numbered from. Any command
value lower than this symbol is considered a
&quot;generic&quot; command is handled directly by the
OpenSSL core routines.</p>

<p style="margin-left:11%; margin-top: 1em">It is using
these &quot;core&quot; control commands that one can
discover the control commands implemented by a given
<small>ENGINE,</small> specifically the commands:</p>


<p style="margin-left:11%; margin-top: 1em">ENGINE_HAS_CTRL_FUNCTION
<br>
ENGINE_CTRL_GET_FIRST_CMD_TYPE <br>
ENGINE_CTRL_GET_NEXT_CMD_TYPE <br>
ENGINE_CTRL_GET_CMD_FROM_NAME <br>
ENGINE_CTRL_GET_NAME_LEN_FROM_CMD <br>
ENGINE_CTRL_GET_NAME_FROM_CMD <br>
ENGINE_CTRL_GET_DESC_LEN_FROM_CMD <br>
ENGINE_CTRL_GET_DESC_FROM_CMD <br>
ENGINE_CTRL_GET_CMD_FLAGS</p>

<p style="margin-left:11%; margin-top: 1em">Whilst these
commands are automatically processed by the OpenSSL
framework code, they use various properties exposed by each
<small>ENGINE</small> to process these queries. An
<small>ENGINE</small> has 3 properties it exposes that can
affect how this behaves; it can supply a <b>ctrl()</b>
handler, it can specify
<small>ENGINE_FLAGS_MANUAL_CMD_CTRL</small> in the
<small>ENGINE</small> &rsquo;s flags, and it can expose an
array of control command descriptions. If an
<small>ENGINE</small> specifies the
<small>ENGINE_FLAGS_MANUAL_CMD_CTRL</small> flag, then it
will simply pass all these &quot;core&quot; control commands
directly to the <small>ENGINE</small> &rsquo;s <b>ctrl()</b>
handler (and thus, it must have supplied one), so it is up
to the <small>ENGINE</small> to reply to these
&quot;discovery&quot; commands itself. If that flag is not
set, then the OpenSSL framework code will work with the
following rules:</p>

<p style="margin-left:11%; margin-top: 1em">if no ctrl()
handler supplied; <br>
ENGINE_HAS_CTRL_FUNCTION returns FALSE (zero), <br>
all other commands fail. <br>
if a ctrl() handler was supplied but no array of control
commands; <br>
ENGINE_HAS_CTRL_FUNCTION returns TRUE, <br>
all other commands fail. <br>
if a ctrl() handler and array of control commands was
supplied; <br>
ENGINE_HAS_CTRL_FUNCTION returns TRUE, <br>
all other commands proceed processing ...</p>

<p style="margin-left:11%; margin-top: 1em">If the
<small>ENGINE</small> &rsquo;s array of control commands is
empty then all other commands will fail, otherwise;
<small>ENGINE_CTRL_GET_FIRST_CMD_TYPE</small> returns the
identifier of the first command supported by the
<small>ENGINE, ENGINE_GET_NEXT_CMD_TYPE</small> takes the
identifier of a command supported by the
<small>ENGINE</small> and returns the next command
identifier or fails if there are no more,
<small>ENGINE_CMD_FROM_NAME</small> takes a string name for
a command and returns the corresponding identifier or fails
if no such command name exists, and the remaining commands
take a command identifier and return properties of the
corresponding commands. All except
<small>ENGINE_CTRL_GET_FLAGS</small> return the string
length of a command name or description, or populate a
supplied character buffer with a copy of the command name or
description. <small>ENGINE_CTRL_GET_FLAGS</small> returns a
bitwise-OR&rsquo;d mask of the following possible
values:</p>


<p style="margin-left:11%; margin-top: 1em">ENGINE_CMD_FLAG_NUMERIC
<br>
ENGINE_CMD_FLAG_STRING <br>
ENGINE_CMD_FLAG_NO_INPUT <br>
ENGINE_CMD_FLAG_INTERNAL</p>

<p style="margin-left:11%; margin-top: 1em">If the
<small>ENGINE_CMD_FLAG_INTERNAL</small> flag is set, then
any other flags are purely informational to the caller
&minus; this flag will prevent the command being usable for
any higher-level <small>ENGINE</small> functions such as
<b>ENGINE_ctrl_cmd_string()</b>. &quot;
<small>INTERNAL&quot;</small> commands are not intended to
be exposed to text-based configuration by applications,
administrations, users, etc. These can support arbitrary
operations via <b>ENGINE_ctrl()</b>, including passing to
and/or from the control commands data of any arbitrary type.
These commands are supported in the discovery mechanisms
simply to allow applications to determine if an
<small>ENGINE</small> supports certain specific commands it
might want to use (e.g. application &quot;foo&quot; might
query various ENGINEs to see if they implement &quot;
<small>FOO_GET_VENDOR_LOGO_GIF&quot;</small> &minus; and
<small>ENGINE</small> could therefore decide whether or not
to support this &quot;foo&quot;&minus;specific
extension).</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>OPENSSL_ENGINES</small></b></p>

<p style="margin-left:17%;">The path to the engines
directory. Ignored in set-user-ID and set-group-ID
programs.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_first()</b>,
<b>ENGINE_get_last()</b>, <b>ENGINE_get_next()</b> and
<b>ENGINE_get_prev()</b> return a valid
<b><small>ENGINE</small></b> structure or
<small>NULL</small> if an error occurred.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_add()</b>
and <b>ENGINE_remove()</b> return 1 on success or 0 on
error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_by_id()</b>
returns a valid <b><small>ENGINE</small></b> structure or
<small>NULL</small> if an error occurred.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_init()</b>
and <b>ENGINE_finish()</b> return 1 on success or 0 on
error.</p>

<p style="margin-left:11%; margin-top: 1em">All
<b>ENGINE_get_default_TYPE()</b> functions,
<b>ENGINE_get_cipher_engine()</b> and
<b>ENGINE_get_digest_engine()</b> return a valid
<b><small>ENGINE</small></b> structure on success or
<small>NULL</small> if an error occurred.</p>

<p style="margin-left:11%; margin-top: 1em">All
<b>ENGINE_set_default_TYPE()</b> functions return 1 on
success or 0 on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_set_default()</b>
returns 1 on success or 0 on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_table_flags()</b>
returns an unsigned integer value representing the global
table flags which are used to control the registration
behaviour of <b><small>ENGINE</small></b>
implementations.</p>

<p style="margin-left:11%; margin-top: 1em">All
<b>ENGINE_register_TYPE()</b> functions return 1 on success
or 0 on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_register_complete()</b>
and <b>ENGINE_register_all_complete()</b> always return
1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_ctrl()</b>
returns a positive value on success or others on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_cmd_is_executable()</b>
returns 1 if <b>cmd</b> is executable or 0 otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_ctrl_cmd()</b>
and <b>ENGINE_ctrl_cmd_string()</b> return 1 on success or 0
on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_new()</b>
returns a valid <b><small>ENGINE</small></b> structure on
success or <small>NULL</small> if an error occurred.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_free()</b>
always returns 1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_up_ref()</b>
returns 1 on success or 0 on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_set_id()</b>
and <b>ENGINE_set_name()</b> return 1 on success or 0 on
error.</p>

<p style="margin-left:11%; margin-top: 1em">All other
<b>ENGINE_set_*</b> functions return 1 on success or 0 on
error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_id()</b>
and <b>ENGINE_get_name()</b> return a string representing
the identifier and the name of the <small>ENGINE</small>
<b>e</b> respectively.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_RSA()</b>,
<b>ENGINE_get_DSA()</b>, <b>ENGINE_get_DH()</b> and
<b>ENGINE_get_RAND()</b> return corresponding method
structures for each algorithms.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_destroy_function()</b>,
<b>ENGINE_get_init_function()</b>,
<b>ENGINE_get_finish_function()</b>,
<b>ENGINE_get_ctrl_function()</b>,
<b>ENGINE_get_load_privkey_function()</b>,
<b>ENGINE_get_load_pubkey_function()</b>,
<b>ENGINE_get_ciphers()</b> and <b>ENGINE_get_digests()</b>
return corresponding function pointers of the callbacks.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_cipher()</b>
returns a valid <b><small>EVP_CIPHER</small></b> structure
on success or <small>NULL</small> if an error occurred.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_digest()</b>
returns a valid <b><small>EVP_MD</small></b> structure on
success or <small>NULL</small> if an error occurred.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_flags()</b>
returns an integer representing the <small>ENGINE</small>
flags which are used to control various behaviours of an
<small>ENGINE.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_get_cmd_defns()</b>
returns an <b><small>ENGINE_CMD_DEFN</small></b> structure
or <small>NULL</small> if it&rsquo;s not set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_load_private_key()</b>
and <b>ENGINE_load_public_key()</b> return a valid
<b><small>EVP_PKEY</small></b> structure on success or
<small>NULL</small> if an error occurred.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>OPENSSL_init_crypto</b>(3),
<b>RSA_new_method</b>(3), <b>DSA_new</b>(3),
<b>DH_new</b>(3), <b>RAND_bytes</b>(3), <b>config</b>(5)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All of these
functions were deprecated in OpenSSL 3.0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ENGINE_cleanup()</b>
was deprecated in OpenSSL 1.1.0 by the automatic cleanup
done by <b>OPENSSL_cleanup()</b> and should not be used.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2002&minus;2021 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
