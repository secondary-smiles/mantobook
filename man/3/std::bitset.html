<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:11 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::bitset&lt; _Nb &gt;</title>

</head>
<body>
<h1>std::bitset</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::bitset&lt;
_Nb &gt; &minus; The bitset class represents a
<i>fixed-size</i> sequence of bits.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::_Base_bitset&lt;((_Nb)/(__CHAR_BIT__
*__SIZEOF_LONG__)+((_Nb) %(__CHAR_BIT__ *__SIZEOF_LONG__)==0
? 0 :1))&gt;</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">class <b>reference</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">constexpr <b>bitset</b> ()
noexcept <br>
All bits set to zero. <br>
template&lt;typename _CharT &gt; constexpr <b>bitset</b>
(const _CharT *__str, typename <b>__bitset::__string</b>&lt;
_CharT &gt;::size_type __n=<b>__bitset::__string</b>&lt;
_CharT &gt;::npos, _CharT __zero=_CharT(&rsquo;0&rsquo;),
_CharT __one=_CharT(&rsquo;1&rsquo;)) <br>
template&lt;class _CharT , class _Traits , class _Alloc &gt;
constexpr <b>bitset</b> (const <b>std::basic_string</b>&lt;
_CharT, _Traits, _Alloc &gt; &amp;__s, size_t __position,
size_t __n) <br>
template&lt;class _CharT , class _Traits , class _Alloc &gt;
constexpr <b>bitset</b> (const <b>std::basic_string</b>&lt;
_CharT, _Traits, _Alloc &gt; &amp;__s, size_t __position,
size_t __n, _CharT __zero, _CharT
__one=_CharT(&rsquo;1&rsquo;)) <br>
template&lt;class _CharT , class _Traits , class _Alloc &gt;
constexpr <b>bitset</b> (const <b>std::basic_string</b>&lt;
_CharT, _Traits, _Alloc &gt; &amp;__s, size_t __position=0)
<br>
constexpr <b>bitset</b> (unsigned long long __val) noexcept
<br>
Initial bits bitwise-copied from a single word (others set
to zero). <br>
constexpr size_t <b>_Find_first</b> () const noexcept <br>
Finds the index of the first &rsquo;on&rsquo; bit. <br>
constexpr size_t <b>_Find_next</b> (size_t __prev) const
noexcept <br>
Finds the index of the next &rsquo;on&rsquo; bit after prev.
<br>
constexpr bool <b>all</b> () const noexcept <br>
Tests whether all the bits are on. <br>
constexpr bool <b>any</b> () const noexcept <br>
Tests whether any of the bits are on. <br>
constexpr size_t <b>count</b> () const noexcept <br>
Returns the number of bits which are set. <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp; <b>flip</b> ()
noexcept <br>
Toggles every bit to its opposite value. <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp; <b>flip</b>
(size_t __position) <br>
Toggles a given bit to its opposite value. <br>
constexpr bool <b>none</b> () const noexcept <br>
Tests whether any of the bits are on. <br>
constexpr <b>bitset</b>&lt; _Nb &gt; <b>operator~</b> ()
const noexcept <br>
See the no-argument flip(). <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp; <b>reset</b> ()
noexcept <br>
Sets every bit to false. <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp; <b>reset</b>
(size_t __position) <br>
Sets a given bit to false. <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp; <b>set</b> ()
noexcept <br>
Sets every bit to true. <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp; <b>set</b>
(size_t __position, bool __val=true) <br>
Sets a given bit to a particular value. <br>
constexpr size_t <b>size</b> () const noexcept <br>
Returns the total number of bits. <br>
constexpr bool <b>test</b> (size_t __position) const <br>
Tests the value of a bit. <br>
template&lt;class _CharT , class _Traits , class _Alloc &gt;
constexpr <b>std::basic_string</b>&lt; _CharT, _Traits,
_Alloc &gt; <b>to_string</b> () const <br>
Returns a character interpretation of the bitset. <br>
template&lt;class _CharT , class _Traits &gt; constexpr
<b>std::basic_string</b>&lt; _CharT, _Traits,
<b>std::allocator</b>&lt; _CharT &gt; &gt; <b>to_string</b>
() const <br>
template&lt;class _CharT &gt; constexpr
<b>std::basic_string</b>&lt; _CharT,
<b>std::char_traits</b>&lt; _CharT &gt;,
<b>std::allocator</b>&lt; _CharT &gt; &gt; <b>to_string</b>
() const <br>
constexpr <b>std::basic_string</b>&lt; char,
<b>std::char_traits</b>&lt; char &gt;,
<b>std::allocator</b>&lt; char &gt; &gt; <b>to_string</b> ()
const <br>
template&lt;class _CharT , class _Traits , class _Alloc &gt;
constexpr <b>std::basic_string</b>&lt; _CharT, _Traits,
_Alloc &gt; <b>to_string</b> (_CharT __zero, _CharT
__one=_CharT(&rsquo;1&rsquo;)) const <br>
template&lt;class _CharT , class _Traits &gt; constexpr
<b>std::basic_string</b>&lt; _CharT, _Traits,
<b>std::allocator</b>&lt; _CharT &gt; &gt; <b>to_string</b>
(_CharT __zero, _CharT __one=_CharT(&rsquo;1&rsquo;)) const
<br>
template&lt;class _CharT &gt; constexpr
<b>std::basic_string</b>&lt; _CharT,
<b>std::char_traits</b>&lt; _CharT &gt;,
<b>std::allocator</b>&lt; _CharT &gt; &gt; <b>to_string</b>
(_CharT __zero, _CharT __one=_CharT(&rsquo;1&rsquo;)) const
<br>
constexpr <b>std::basic_string</b>&lt; char,
<b>std::char_traits</b>&lt; char &gt;,
<b>std::allocator</b>&lt; char &gt; &gt; <b>to_string</b>
(char __zero, char __one=&rsquo;1&rsquo;) const <br>
constexpr unsigned long long <b>to_ullong</b> () const <br>
constexpr unsigned long <b>to_ulong</b> () const <br>
Returns a numerical interpretation of the bitset.</p>

<p style="margin-left:23%; margin-top: 1em">constexpr
<b>bitset</b>&lt; _Nb &gt; &amp; <b>operator&amp;=</b>
(const <b>bitset</b>&lt; _Nb &gt; &amp;__rhs) noexcept <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp; <b>operator|=</b>
(const <b>bitset</b>&lt; _Nb &gt; &amp;__rhs) noexcept <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp; <b>operator^=</b>
(const <b>bitset</b>&lt; _Nb &gt; &amp;__rhs) noexcept</p>

<p style="margin-left:23%; margin-top: 1em">constexpr
<b>bitset</b>&lt; _Nb &gt; &amp; <b>operator&lt;&lt;=</b>
(size_t __position) noexcept <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp;
<b>operator&gt;&gt;=</b> (size_t __position) noexcept</p>

<p style="margin-left:23%; margin-top: 1em">constexpr
<b>bitset</b>&lt; _Nb &gt; &amp; <b>_Unchecked_set</b>
(size_t __pos) noexcept <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp;
<b>_Unchecked_set</b> (size_t __pos, int __val) noexcept
<br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp;
<b>_Unchecked_reset</b> (size_t __pos) noexcept <br>
constexpr <b>bitset</b>&lt; _Nb &gt; &amp;
<b>_Unchecked_flip</b> (size_t __pos) noexcept <br>
constexpr bool <b>_Unchecked_test</b> (size_t __pos) const
noexcept</p>

<p style="margin-left:23%; margin-top: 1em">constexpr
<b>reference operator[]</b> (size_t __position) <br>
Array-indexing support. <br>
constexpr bool <b>operator[]</b> (size_t __position) const
<br>
Array-indexing support.</p>

<p style="margin-left:23%; margin-top: 1em">constexpr bool
<b>operator==</b> (const <b>bitset</b>&lt; _Nb &gt;
&amp;__rhs) const noexcept <br>
These comparisons for equality/inequality are, well,
<i>bitwise</i>.</p>

<p style="margin-left:23%; margin-top: 1em">constexpr
<b>bitset</b>&lt; _Nb &gt; <b>operator&lt;&lt;</b> (size_t
__position) const noexcept <br>
Self-explanatory. <br>
constexpr <b>bitset</b>&lt; _Nb &gt; <b>operator&gt;&gt;</b>
(size_t __position) const noexcept <br>
Self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;class _CharT ,
class _Traits , size_t _Nb2&gt;
<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;
<b>operator&lt;&lt;</b> (<b>std::basic_ostream</b>&lt;
_CharT, _Traits &gt; &amp;, const <b>bitset</b>&lt; _Nb2
&gt; &amp;) <br>
template&lt;class _CharT , class _Traits , size_t _Nb2&gt;
<b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;
<b>operator&gt;&gt;</b> (<b>std::basic_istream</b>&lt;
_CharT, _Traits &gt; &amp;, <b>bitset</b>&lt; _Nb2 &gt;
&amp;) <br>
class <b>reference</b> <br>
struct <b>std::hash&lt; bitset &gt;</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt;</b> <br>
class std::bitset&lt; _Nb &gt;&quot;The bitset class
represents a <i>fixed-size</i> sequence of bits.</p>

<p style="margin-left:11%; margin-top: 1em">(Note that
bitset does <i>not</i> meet the formal requirements of a
<tt>container</tt>. Mainly, it lacks iterators.)</p>

<p style="margin-left:11%; margin-top: 1em">The template
argument, <i>Nb</i>, may be any non-negative number,
specifying the number of bits (e.g., &rsquo;0&rsquo;,
&rsquo;12&rsquo;, &rsquo;1024*1024&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">In the general
unoptimized case, storage is allocated in word-sized blocks.
Let B be the number of bits in a word, then (Nb+(B-1))/B
words will be used for storage. B - NbB bits are unused.
(They are the high-order bits in the highest word.) It is a
class invariant that those unused bits are always zero.</p>

<p style="margin-left:11%; margin-top: 1em">If you think of
bitset as <i>a simple array of bits</i>, be aware that your
mental picture is reversed: a bitset behaves the same way as
bits in integers do, with the bit at index 0 in the <i>least
significant / right-hand</i> position, and the bit at index
Nb-1 in the <i>most significant / left-hand</i> position.
Thus, unlike other containers, a bitset&rsquo;s index
<i>counts from right to left</i>, to put it very
loosely.</p>

<p style="margin-left:11%; margin-top: 1em">This behavior
is preserved when translating to and from strings. For
example, the first line of the following program probably
prints <i>b(&rsquo;a&rsquo;) is 0001100001</i> on a modern
ASCII system.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;bitset&gt; <br>
#include &lt;iostream&gt; <br>
#include &lt;sstream&gt;</p>

<p style="margin-left:11%; margin-top: 1em">using namespace
std;</p>

<p style="margin-left:11%; margin-top: 1em">int main() <br>
{ <br>
long a = &rsquo;a&rsquo;; <br>
bitset&lt;10&gt; b(a);</p>

<p style="margin-left:11%; margin-top: 1em">cout &lt;&lt;
&quot;b(&rsquo;a&rsquo;) is &quot; &lt;&lt; b &lt;&lt;
endl;</p>

<p style="margin-left:11%; margin-top: 1em">ostringstream
s; <br>
s &lt;&lt; b; <br>
string str = s.str(); <br>
cout &lt;&lt; &quot;index 3 in the string is &quot; &lt;&lt;
str[3] &lt;&lt; &quot; but\n&quot; <br>
&lt;&lt; &quot;index 3 in the bitset is &quot; &lt;&lt; b[3]
&lt;&lt; endl; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Also see:
https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_containers.html
for a description of extensions.</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
actual code isn&rsquo;t contained in bitset&lt;&gt; itself,
but in the base class _Base_bitset. The base class works
with whole words, not with individual bits. This allows us
to specialize _Base_bitset for the important special case
where the bitset is only a single word.</p>

<p style="margin-left:11%; margin-top: 1em">Extra confusion
can result due to the fact that the storage for _Base_bitset
<i>is</i> a regular array, and is indexed as such. This is
carefully encapsulated.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr std::bitset&lt; _Nb &gt;::bitset ()</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
All bits set to zero.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr std::bitset&lt; _Nb &gt;::bitset (unsigned
long long __val)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Initial bits bitwise-copied from a single word (others set
to zero).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; template&lt;class _CharT , class _Traits , class
_Alloc &gt; constexpr std::bitset&lt; _Nb &gt;::bitset
(const std::basic_string&lt; _CharT, _Traits, _Alloc &gt;
&amp; __s, size_t __position =</b> <tt>0</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Use a subset of a string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__s</i> A string of <i>0</i>
and <i>1</i> characters. <i><br>
__position</i> Index of the first character in <i>__s</i> to
use; defaults to zero.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>pos</i> is bigger the size of <i>__s</i>. <i><br>
std::invalid_argument</i> If a character appears in the
string which is neither <i>0</i> nor <i>1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; template&lt;class _CharT , class _Traits , class
_Alloc &gt; constexpr std::bitset&lt; _Nb &gt;::bitset
(const std::basic_string&lt; _CharT, _Traits, _Alloc &gt;
&amp; __s, size_t __position, size_t __n)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Use a subset of a string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__s</i> A string of <i>0</i>
and <i>1</i> characters. <i><br>
__position</i> Index of the first character in <i>__s</i> to
use. <i><br>
__n</i> The number of characters to copy.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__position</i> is bigger the size of <i>__s</i>. <i><br>
std::invalid_argument</i> If a character appears in the
string which is neither <i>0</i> nor <i>1</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; template&lt;typename _CharT &gt; constexpr
std::bitset&lt; _Nb &gt;::bitset (const _CharT * __str,
typename __bitset&lt; _Nb &gt;::__string&lt; _CharT
&gt;::size_type __n =</b> <tt>__bitset&lt; _Nb
&gt;::__string&lt;_CharT&gt;::npos</tt><b>, _CharT __zero
=</b> <tt>_CharT(&rsquo;0&rsquo;)</tt><b>, _CharT __one
=</b> <tt>_CharT(&rsquo;1&rsquo;)</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Construct from a character array.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__str</i> An array of
characters <i>zero</i> and <i>one</i>. <i><br>
__n</i> The number of characters to use. <i><br>
__zero</i> The character corresponding to the value 0.
<i><br>
__one</i> The character corresponding to the value 1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::invalid_argument</i> If
a character appears in the string which is neither
<i>__zero</i> nor <i>__one</i>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bool std::bitset&lt; _Nb &gt;::all ()
const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Tests whether all the bits are on.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if all the bits are
set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bool std::bitset&lt; _Nb &gt;::any ()
const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Tests whether any of the bits are on.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if at least one bit is
set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr size_t std::bitset&lt; _Nb &gt;::count ()
const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of bits which are set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::flip ()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Toggles every bit to its opposite value.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::bitset&lt; _Nb &gt;::operator~()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::flip (size_t __position)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Toggles a given bit to its opposite value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> The index of
the bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>pos</i> is bigger the size of the set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bool std::bitset&lt; _Nb &gt;::none ()
const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Tests whether any of the bits are on.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if none of the bits are
set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::operator&amp;= (const bitset&lt; _Nb &gt; &amp;
__rhs)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Operations on bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__rhs</i> A same-sized
bitset.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; std::bitset&lt; _Nb
&gt;::operator&lt;&lt; (size_t __position) const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::operator&lt;&lt;= (size_t __position)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Operations on bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> The number of
places to shift.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bool std::bitset&lt; _Nb &gt;::operator==
(const bitset&lt; _Nb &gt; &amp; __rhs) const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
These comparisons for equality/inequality are, well,
<i>bitwise</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; std::bitset&lt; _Nb
&gt;::operator&gt;&gt; (size_t __position) const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::operator&gt;&gt;= (size_t __position)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Operations on bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> The number of
places to shift.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr reference std::bitset&lt; _Nb
&gt;::operator[] (size_t __position)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Array-indexing support.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> Index into
the bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A bool for a <i>const
bitset</i>. For non-const bitsets, an instance of the
reference proxy class.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">These operators do no range
checking and throw no exceptions, as required by DR 11 to
the standard.</p>


<p style="margin-left:11%; margin-top: 1em">_GLIBCXX_RESOLVE_LIB_DEFECTS
Note that this implementation already resolves DR 11 (items
1 and 2), but does not do the range-checking required by
that DR&rsquo;s resolution. -pme The DR has since been
changed: range-checking is a precondition (users&rsquo;
responsibility), and these functions must not throw.
-pme</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bool std::bitset&lt; _Nb &gt;::operator[]
(size_t __position) const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Array-indexing support.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> Index into
the bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A bool for a <i>const
bitset</i>. For non-const bitsets, an instance of the
reference proxy class.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">These operators do no range
checking and throw no exceptions, as required by DR 11 to
the standard.</p>


<p style="margin-left:11%; margin-top: 1em">_GLIBCXX_RESOLVE_LIB_DEFECTS
Note that this implementation already resolves DR 11 (items
1 and 2), but does not do the range-checking required by
that DR&rsquo;s resolution. -pme The DR has since been
changed: range-checking is a precondition (users&rsquo;
responsibility), and these functions must not throw.
-pme</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::operator^= (const bitset&lt; _Nb &gt; &amp;
__rhs)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Operations on bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__rhs</i> A same-sized
bitset.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::operator|= (const bitset&lt; _Nb &gt; &amp;
__rhs)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Operations on bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__rhs</i> A same-sized
bitset.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; std::bitset&lt; _Nb
&gt;::operator~ () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
See the no-argument flip().</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::bitset&lt; _Nb &gt;::flip()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::reset ()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Sets every bit to false.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::reset (size_t __position)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Sets a given bit to false.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> The index of
the bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>pos</i> is bigger the size of the set.</p>

<p style="margin-left:11%; margin-top: 1em">Same as writing
<tt>set(pos,false)</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::set ()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Sets every bit to true.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bitset&lt; _Nb &gt; &amp; std::bitset&lt;
_Nb &gt;::set (size_t __position, bool __val =</b>
<tt>true</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Sets a given bit to a particular value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> The index of
the bit. <i><br>
__val</i> Either true or false, defaults to true.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>pos</i> is bigger the size of the set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr size_t std::bitset&lt; _Nb &gt;::size ()
const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the total number of bits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr bool std::bitset&lt; _Nb &gt;::test
(size_t __position) const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Tests the value of a bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> The index of
a bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The value at <i>pos</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>pos</i> is bigger the size of the set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; template&lt;class _CharT , class _Traits , class
_Alloc &gt; constexpr std::basic_string&lt; _CharT, _Traits,
_Alloc &gt; std::bitset&lt; _Nb &gt;::to_string () const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Returns a character interpretation of the bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The string equivalent of the
bits.</p>

<p style="margin-left:11%; margin-top: 1em">Note the
ordering of the bits: decreasing character positions
correspond to increasing bit positions (see the main class
notes for an example).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;size_t
_Nb&gt; constexpr unsigned long std::bitset&lt; _Nb
&gt;::to_ulong () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Returns a numerical interpretation of the bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The integral equivalent of the
bits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::overflow_error</i> If
there are too many bits to be represented in an <tt>unsigned
long</tt>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
