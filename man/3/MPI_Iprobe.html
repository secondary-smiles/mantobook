<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:35 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_Iprobe</title>

</head>
<body>
<h1>MPI_Iprobe</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_Iprobe</b>
&minus; Nonblocking test for a message.</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Iprobe(int <i>source</i>, int <i>tag</i>, MPI_Comm
<i>comm</i>, int <i>*flag</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>MPI_Status <i>*status</i>)</p></td></tr>
</table>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_IPROBE(<i>SOURCE, TAG, COMM, FLAG, STATUS,
IERROR</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>LOGICAL</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>FLAG</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>SOURCE, TAG, COMM, STATUS(MPI_STATUS_SIZE),
IERROR</i></p> </td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_Iprobe(<i>source</i>, <i>tag</i>, <i>comm</i>,
<i>flag</i>, <i>status</i>, <i>ierror</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, INTENT(IN) :: <i>source</i>, <i>tag</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Comm), INTENT(IN) :: <i>comm</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>LOGICAL, INTENT(OUT) :: <i>flag</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Status) :: <i>status</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
bool Comm::Iprobe(int <i>source</i>, int <i>tag</i>,
Status&amp; <i>status</i>) const</p>

<p style="margin-left:11%; margin-top: 1em">bool
Comm::Iprobe(int <i>source</i>, int <i>tag</i>) const</p>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em">source</p></td>
<td width="6%"></td>
<td width="62%">


<p style="margin-top: 1em">Source rank or MPI_ANY_SOURCE
(integer).</p> </td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>tag</p></td>
<td width="6%"></td>
<td width="62%">


<p>Tag value or MPI_ANY_TAG (integer).</p></td>
<td width="12%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>comm</p></td>
<td width="6%"></td>
<td width="62%">


<p>Communicator (handle).</p></td>
<td width="12%">
</td></tr>
</table>

<h2>OUTPUT PARAMETERS
<a name="OUTPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em">flag</p></td>
<td width="6%"></td>
<td width="57%">


<p style="margin-top: 1em">Message-waiting flag
(logical).</p> </td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>status</p></td>
<td width="6%"></td>
<td width="57%">


<p>Status object (status).</p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>IERROR</p></td>
<td width="6%"></td>
<td width="57%">


<p>Fortran only: Error status (integer).</p></td>
<td width="17%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The MPI_Probe
and MPI_Iprobe operations allow checking of incoming
messages without actual receipt of them. The user can then
decide how to receive them, based on the information
returned by the probe (basically, the information returned
by status). In particular, the user may allocate memory for
the receive buffer, according to the length of the probed
message.</p>


<p style="margin-left:11%; margin-top: 1em">MPI_Iprobe(source,
tag, comm, flag, status) returns flag = true if there is a
message that can be received and that matches the pattern
specified by the arguments source, tag, and comm. The call
matches the same message that would have been received by a
call to MPI_Recv(..., source, tag, comm, status) executed at
the same point in the program, and returns in status the
same value that would have been returned by MPI_Recv().
Otherwise, the call returns flag = false, and leaves status
undefined.</p>

<p style="margin-left:11%; margin-top: 1em">If MPI_Iprobe
returns flag = true, then the content of the status object
can be subsequently accessed as described in Section 3.2.5
of the MPI-1 Standard, &quot;Return Status,&quot; to find
the source, tag, and length of the probed message.</p>

<p style="margin-left:11%; margin-top: 1em">A subsequent
receive executed with the same context, and the source and
tag returned in status by MPI_Iprobe will receive the
message that was matched by the probe if no other
intervening receive occurs after the probe. If the receiving
process is multithreaded, it is the user&rsquo;s
responsibility to ensure that the last condition holds.</p>

<p style="margin-left:11%; margin-top: 1em">The source
argument of MPI_Probe can be MPI_ANY_SOURCE, and the tag
argument can be MPI_ANY_TAG, so that one can probe for
messages from an arbitrary source and/or with an arbitrary
tag. However, a specific communication context must be
provided with the comm argument.</p>

<p style="margin-left:11%; margin-top: 1em">If your
application does not need to examine the <i>status</i>
field, you can save resources by using the predefined
constant MPI_STATUS_IGNORE as a special value for the
<i>status</i> argument.</p>

<p style="margin-left:11%; margin-top: 1em">It is not
necessary to receive a message immediately after it has been
probed for, and the same message may be probed for several
times before it is received.</p>

<h2>NOTE
<a name="NOTE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Users of
libmpi-mt should remember that two threads may do an
MPI_Iprobe that actually returns true for the same message
for both threads.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Probe <br>
 MPI_Cancel</p>
<hr>
</body>
</html>
