<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:12 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::experimental</title>

</head>
<body>
<h1>std::experimental</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::experimental
&minus; Namespace for features defined in ISO Technical
Specifications.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">class <b>any</b> <br>
A type-safe container of any type. <br>
class <b>bad_any_cast</b> <br>
Exception class thrown by a failed <tt>any_cast</tt>. <br>
class <b>bad_optional_access</b> <br>
Exception class thrown when a disengaged optional object is
dereferenced. <br>
class <b>basic_string_view</b> <br>
A non-owning reference to a string. <br>
struct <b>in_place_t</b> <br>
Tag type for in-place construction. <br>
struct <b>nullopt_t</b> <br>
Tag type to disengage optional objects. <br>
class <b>optional</b> <br>
Class template for optional values. <br>
class <b>ostream_joiner</b> <br>
Output iterator that inserts a delimiter between elements.
<br>
struct <b>owner_less&lt; shared_ptr&lt; _Tp &gt; &gt;</b>
<br>
Partial specialization of owner_less for shared_ptr. <br>
struct <b>owner_less&lt; weak_ptr&lt; _Tp &gt; &gt;</b> <br>
Partial specialization of owner_less for weak_ptr. <br>
class <b>propagate_const</b> <br>
Const-propagating wrapper.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Typedefs</b></p>

<p style="margin-left:17%;">template&lt;typename _RAIter ,
typename _Hash , typename _Pred , typename _Val = typename
iterator_traits&lt;_RAIter&gt;::value_type, typename _Diff =
typename iterator_traits&lt;_RAIter&gt;::difference_type&gt;
using <b>__boyer_moore_base_t</b> = std::__conditional_t&lt;
std::__is_byte_like&lt; _Val, _Pred &gt;::value,
__boyer_moore_array_base&lt; _Diff, 256, _Pred &gt;,
__boyer_moore_map_base&lt; _Val, _Diff, _Hash, _Pred &gt;
&gt; <br>
template&lt;typename _Tp &gt; using
<b>__propagate_const_elem_type</b> =
<b>remove_reference_t</b>&lt;
decltype(*<b>std::declval</b>&lt; _Tp &amp; &gt;())&gt; <br>
using <b>erased_type</b> = std::__erased_type <br>
using <b>string_view</b> = <b>basic_string_view</b>&lt; char
&gt; <br>
using <b>u16string_view</b> = <b>basic_string_view</b>&lt;
char16_t &gt; <br>
using <b>u32string_view</b> = <b>basic_string_view</b>&lt;
char32_t &gt; <br>
using <b>wstring_view</b> = <b>basic_string_view</b>&lt;
wchar_t &gt;</p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Fn ,
typename _Tuple , std::size_t... _Idx&gt; constexpr
decltype(auto) <b>__apply_impl</b> (_Fn &amp;&amp;__f,
_Tuple &amp;&amp;__t, <b>std::index_sequence</b>&lt; _Idx...
&gt;) <br>
template&lt;typename _Tp , size_t _Nm, size_t... _Idx&gt;
constexpr <b>array</b>&lt; <b>remove_cv_t</b>&lt; _Tp &gt;,
_Nm &gt; <b>__to_array</b> (_Tp(&amp;__a)[_Nm],
<b>index_sequence</b>&lt; _Idx... &gt;) <b><br>
std::default_random_engine</b> &amp;
<b>_S_randint_engine</b> () <br>
template&lt;typename _ValueType &gt; _ValueType
<b>any_cast</b> (const <b>any</b> &amp;__any) <br>
Access the contained object. <br>
template&lt;typename _Fn , typename _Tuple &gt; constexpr
decltype(auto) <b>apply</b> (_Fn &amp;&amp;__f, _Tuple
&amp;&amp;__t) <br>
template&lt;typename _Tp &gt; bool
<b>atomic_compare_exchange_strong</b> (shared_ptr&lt; _Tp
&gt; *__p, shared_ptr&lt; _Tp &gt; *__v, shared_ptr&lt; _Tp
&gt; __w) <br>
template&lt;typename _Tp &gt; bool
<b>atomic_compare_exchange_strong_explicit</b>
(shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt; _Tp &gt; *__v,
shared_ptr&lt; _Tp &gt; __w, <b>memory_order</b> __success,
<b>memory_order</b> __failure) <br>
template&lt;typename _Tp &gt; bool
<b>atomic_compare_exchange_weak</b> (shared_ptr&lt; _Tp &gt;
*__p, shared_ptr&lt; _Tp &gt; *__v, shared_ptr&lt; _Tp &gt;
__w) <br>
template&lt;typename _Tp &gt; bool
<b>atomic_compare_exchange_weak_explicit</b> (shared_ptr&lt;
_Tp &gt; *__p, shared_ptr&lt; _Tp &gt; *__v, shared_ptr&lt;
_Tp &gt; __w, <b>memory_order</b> __success,
<b>memory_order</b> __failure) <br>
template&lt;typename _Tp &gt; void <b>atomic_exchange</b>
(shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt; _Tp &gt; __r)
<br>
template&lt;typename _Tp &gt; shared_ptr&lt; _Tp &gt;
<b>atomic_exchange_explicit</b> (const shared_ptr&lt; _Tp
&gt; *__p, shared_ptr&lt; _Tp &gt; __r, <b>memory_order</b>
__mo) <br>
template&lt;typename _Tp &gt; bool
<b>atomic_is_lock_free</b> (const shared_ptr&lt; _Tp &gt;
*__p) <br>
template&lt;typename _Tp &gt; shared_ptr&lt; _Tp &gt;
<b>atomic_load</b> (const shared_ptr&lt; _Tp &gt; *__p) <br>
template&lt;typename _Tp &gt; shared_ptr&lt; _Tp &gt;
<b>atomic_load_explicit</b> (const shared_ptr&lt; _Tp &gt;
*__p, <b>memory_order</b> __mo) <br>
template&lt;typename _Tp &gt; void <b>atomic_store</b>
(shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt; _Tp &gt; __r)
<br>
template&lt;typename _Tp &gt; shared_ptr&lt; _Tp &gt;
<b>atomic_store_explicit</b> (const shared_ptr&lt; _Tp &gt;
*__p, shared_ptr&lt; _Tp &gt; __r, <b>memory_order</b> __mo)
<br>
template&lt;typename _Tp , typename _Tp1 &gt; shared_ptr&lt;
_Tp &gt; <b>const_pointer_cast</b> (const shared_ptr&lt;
_Tp1 &gt; &amp;__r) noexcept <br>
template&lt;typename _Tp , typename _Tp1 &gt; shared_ptr&lt;
_Tp &gt; <b>dynamic_pointer_cast</b> (const shared_ptr&lt;
_Tp1 &gt; &amp;__r) noexcept <br>
template&lt;typename _CharT , typename _Traits , typename
_Alloc , typename _Up &gt; void <b>erase</b>
(<b>basic_string</b>&lt; _CharT, _Traits, _Alloc &gt;
&amp;__cont, const _Up &amp;__value) <br>
template&lt;typename _Tp , typename _Alloc , typename _Up
&gt; void <b>erase</b> (<b>deque</b>&lt; _Tp, _Alloc &gt;
&amp;__cont, const _Up &amp;__value) <br>
template&lt;typename _Tp , typename _Alloc , typename _Up
&gt; void <b>erase</b> (<b>forward_list</b>&lt; _Tp, _Alloc
&gt; &amp;__cont, const _Up &amp;__value) <br>
template&lt;typename _Tp , typename _Alloc , typename _Up
&gt; void <b>erase</b> (<b>list</b>&lt; _Tp, _Alloc &gt;
&amp;__cont, const _Up &amp;__value) <br>
template&lt;typename _Tp , typename _Alloc , typename _Up
&gt; void <b>erase</b> (<b>vector</b>&lt; _Tp, _Alloc &gt;
&amp;__cont, const _Up &amp;__value) <br>
template&lt;typename _CharT , typename _Traits , typename
_Alloc , typename _Predicate &gt; void <b>erase_if</b>
(<b>basic_string</b>&lt; _CharT, _Traits, _Alloc &gt;
&amp;__cont, _Predicate __pred) <br>
template&lt;typename _Tp , typename _Alloc , typename
_Predicate &gt; void <b>erase_if</b> (<b>deque</b>&lt; _Tp,
_Alloc &gt; &amp;__cont, _Predicate __pred) <br>
template&lt;typename _Tp , typename _Alloc , typename
_Predicate &gt; void <b>erase_if</b>
(<b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;__cont,
_Predicate __pred) <br>
template&lt;typename _Tp , typename _Alloc , typename
_Predicate &gt; void <b>erase_if</b> (<b>list</b>&lt; _Tp,
_Alloc &gt; &amp;__cont, _Predicate __pred) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Alloc , typename _Predicate &gt; void
<b>erase_if</b> (<b>map</b>&lt; _Key, _Tp, _Compare, _Alloc
&gt; &amp;__cont, _Predicate __pred) <br>
template&lt;typename _Key , typename _Tp , typename _Compare
, typename _Alloc , typename _Predicate &gt; void
<b>erase_if</b> (<b>multimap</b>&lt; _Key, _Tp, _Compare,
_Alloc &gt; &amp;__cont, _Predicate __pred) <br>
template&lt;typename _Key , typename _Compare , typename
_Alloc , typename _Predicate &gt; void <b>erase_if</b>
(<b>multiset</b>&lt; _Key, _Compare, _Alloc &gt;
&amp;__cont, _Predicate __pred) <br>
template&lt;typename _Key , typename _Compare , typename
_Alloc , typename _Predicate &gt; void <b>erase_if</b>
(<b>set</b>&lt; _Key, _Compare, _Alloc &gt; &amp;__cont,
_Predicate __pred) <br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _CPred , typename _Alloc , typename _Predicate &gt;
void <b>erase_if</b> (<b>unordered_map</b>&lt; _Key, _Tp,
_Hash, _CPred, _Alloc &gt; &amp;__cont, _Predicate __pred)
<br>
template&lt;typename _Key , typename _Tp , typename _Hash ,
typename _CPred , typename _Alloc , typename _Predicate &gt;
void <b>erase_if</b> (<b>unordered_multimap</b>&lt; _Key,
_Tp, _Hash, _CPred, _Alloc &gt; &amp;__cont, _Predicate
__pred) <br>
template&lt;typename _Key , typename _Hash , typename _CPred
, typename _Alloc , typename _Predicate &gt; void
<b>erase_if</b> (<b>unordered_multiset</b>&lt; _Key, _Hash,
_CPred, _Alloc &gt; &amp;__cont, _Predicate __pred) <br>
template&lt;typename _Key , typename _Hash , typename _CPred
, typename _Alloc , typename _Predicate &gt; void
<b>erase_if</b> (<b>unordered_set</b>&lt; _Key, _Hash,
_CPred, _Alloc &gt; &amp;__cont, _Predicate __pred) <br>
template&lt;typename _Tp , typename _Alloc , typename
_Predicate &gt; void <b>erase_if</b> (<b>vector</b>&lt; _Tp,
_Alloc &gt; &amp;__cont, _Predicate __pred) <br>
template&lt;typename _Mn , typename _Nn &gt; constexpr
<b>common_type_t</b>&lt; _Mn, _Nn &gt; <b>gcd</b> (_Mn __m,
_Nn __n) noexcept <br>
Greatest common divisor. <br>
template&lt;typename _Del , typename _Tp &gt; _Del *
<b>get_deleter</b> (const shared_ptr&lt; _Tp &gt; &amp;__p)
noexcept <br>
C++14 20.8.2.2.10. <br>
template&lt;typename _Tp &gt; constexpr const _Tp &amp;
<b>get_underlying</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt) noexcept <br>
template&lt;typename _Tp &gt; constexpr _Tp &amp;
<b>get_underlying</b> (<b>propagate_const</b>&lt; _Tp &gt;
&amp;__pt) noexcept <br>
template&lt;typename _Mn , typename _Nn &gt; constexpr
<b>common_type_t</b>&lt; _Mn, _Nn &gt; <b>lcm</b> (_Mn __m,
_Nn __n) <br>
Least common multiple. <br>
template&lt;typename _Dest = void, typename... _Types&gt;
constexpr <b>array</b>&lt; typename __make_array_elem&lt;
_Dest, _Types... &gt;::type, sizeof...(_Types)&gt;
<b>make_array</b> (_Types &amp;&amp;... __t) <br>
Create a std::array from a variable-length list of
arguments. <br>
template&lt;typename _RAIter , typename _Hash =
std::hash&lt;typename
std::iterator_traits&lt;_RAIter&gt;::value_type&gt;,
typename _BinaryPredicate = equal_to&lt;&gt;&gt;
boyer_moore_horspool_searcher&lt; _RAIter, _Hash,
_BinaryPredicate &gt;
<b>make_boyer_moore_horspool_searcher</b> (_RAIter
__pat_first, _RAIter __pat_last, _Hash __hf=_Hash(),
_BinaryPredicate __pred=_BinaryPredicate()) <br>
Generator function for boyer_moore_horspool_searcher. <br>
template&lt;typename _RAIter , typename _Hash =
std::hash&lt;typename
std::iterator_traits&lt;_RAIter&gt;::value_type&gt;,
typename _BinaryPredicate = equal_to&lt;&gt;&gt;
boyer_moore_searcher&lt; _RAIter, _Hash, _BinaryPredicate
&gt; <b>make_boyer_moore_searcher</b> (_RAIter __pat_first,
_RAIter __pat_last, _Hash __hf=_Hash(), _BinaryPredicate
__pred=_BinaryPredicate()) <br>
Generator function for boyer_moore_searcher. <br>
template&lt;typename _ForwardIterator , typename
_BinaryPredicate = std::equal_to&lt;&gt;&gt;
default_searcher&lt; _ForwardIterator, _BinaryPredicate &gt;
<b>make_default_searcher</b> (_ForwardIterator __pat_first,
_ForwardIterator __pat_last, _BinaryPredicate
__pred=_BinaryPredicate()) <br>
Generator function for default_searcher. <br>
template&lt;typename _Tp &gt; observer_ptr&lt; _Tp &gt;
<b>make_observer</b> (_Tp *__p) noexcept <br>
template&lt;typename _CharT , typename _Traits , typename
_DelimT &gt; <b>ostream_joiner</b>&lt; <b>decay_t</b>&lt;
_DelimT &gt;, _CharT, _Traits &gt;
<b>make_ostream_joiner</b> (<b>basic_ostream</b>&lt; _CharT,
_Traits &gt; &amp;__os, _DelimT &amp;&amp;__delimiter) <br>
Object generator for ostream_joiner. <br>
template&lt;typename _Fn &gt; auto <b>not_fn</b> (_Fn
&amp;&amp;__fn)
noexcept(<b>std::is_nothrow_constructible</b>&lt;
<b>std::decay_t</b>&lt; _Fn &gt;, _Fn &amp;&amp;
&gt;::value) <br>
[func.not_fn] Function template not_fn <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator!=</b> (__type_identity_t&lt;
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator!=</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
__type_identity_t&lt; <b>basic_string_view</b>&lt; _CharT,
_Traits &gt; &gt; __y) noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator!=</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator!=</b> (const _Tp &amp;__t, const
<b>propagate_const</b>&lt; _Up &gt; &amp;__pu) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator!=</b> (const <b>propagate_const</b>&lt; _Tp &gt;
&amp;__pt, const _Up &amp;__u) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator!=</b> (const <b>propagate_const</b>&lt; _Tp &gt;
&amp;__pt, const <b>propagate_const</b>&lt; _Up &gt;
&amp;__pu) <br>
template&lt;typename _Tp &gt; constexpr bool
<b>operator!=</b> (const <b>propagate_const</b>&lt; _Tp &gt;
&amp;__pt, nullptr_t) <br>
template&lt;typename _Tp &gt; bool <b>operator!=</b> (const
shared_ptr&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept <br>
template&lt;typename _Tp1 , typename _Tp2 &gt; bool
<b>operator!=</b> (const shared_ptr&lt; _Tp1 &gt; &amp;__a,
const shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept <br>
template&lt;typename _Tp &gt; constexpr bool
<b>operator!=</b> (nullptr_t, const
<b>propagate_const</b>&lt; _Tp &gt; &amp;__pu) <br>
template&lt;typename _Tp &gt; bool <b>operator!=</b>
(nullptr_t, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
<br>
template&lt;typename _Tp &gt; bool <b>operator!=</b>
(nullptr_t, observer_ptr&lt; _Tp &gt; __p) noexcept <br>
template&lt;typename _Tp &gt; bool <b>operator!=</b>
(observer_ptr&lt; _Tp &gt; __p, nullptr_t) noexcept <br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator!=</b> (observer_ptr&lt; _Tp &gt; __p1,
observer_ptr&lt; _Up &gt; __p2) <br>
constexpr <b>basic_string_view</b>&lt; char &gt;
<b>operator&rsquo;&rsquo;sv</b> (const char *__str, size_t
__len) noexcept <br>
constexpr <b>basic_string_view</b>&lt; char16_t &gt;
<b>operator&rsquo;&rsquo;sv</b> (const char16_t *__str,
size_t __len) noexcept <br>
constexpr <b>basic_string_view</b>&lt; char32_t &gt;
<b>operator&rsquo;&rsquo;sv</b> (const char32_t *__str,
size_t __len) noexcept <br>
constexpr <b>basic_string_view</b>&lt; wchar_t &gt;
<b>operator&rsquo;&rsquo;sv</b> (const wchar_t *__str,
size_t __len) noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&lt;</b> (__type_identity_t&lt;
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&lt;</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
__type_identity_t&lt; <b>basic_string_view</b>&lt; _CharT,
_Traits &gt; &gt; __y) noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&lt;</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&lt;</b> (const _Tp &amp;__t, const
<b>propagate_const</b>&lt; _Up &gt; &amp;__pu) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&lt;</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt, const _Up &amp;__u) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&lt;</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt, const <b>propagate_const</b>&lt; _Up &gt;
&amp;__pu) <br>
template&lt;typename _Tp &gt; bool <b>operator&lt;</b>
(const shared_ptr&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
<br>
template&lt;typename _Tp1 , typename _Tp2 &gt; bool
<b>operator&lt;</b> (const shared_ptr&lt; _Tp1 &gt;
&amp;__a, const shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept
<br>
template&lt;typename _Tp &gt; bool <b>operator&lt;</b>
(nullptr_t, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
<br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator&lt;</b> (observer_ptr&lt; _Tp &gt; __p1,
observer_ptr&lt; _Up &gt; __p2) <br>
template&lt;typename _CharT , typename _Traits &gt;
<b>basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;
<b>operator&lt;&lt;</b> (<b>basic_ostream</b>&lt; _CharT,
_Traits &gt; &amp;__os, <b>basic_string_view</b>&lt; _CharT,
_Traits &gt; __str) <br>
template&lt;typename _Ch , typename _Tr , typename _Tp &gt;
<b>std::basic_ostream</b>&lt; _Ch, _Tr &gt; &amp;
<b>operator&lt;&lt;</b> (<b>std::basic_ostream</b>&lt; _Ch,
_Tr &gt; &amp;__os, const shared_ptr&lt; _Tp &gt; &amp;__p)
<br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&lt;=</b> (__type_identity_t&lt;
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&lt;=</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
__type_identity_t&lt; <b>basic_string_view</b>&lt; _CharT,
_Traits &gt; &gt; __y) noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&lt;=</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&lt;=</b> (const _Tp &amp;__t, const
<b>propagate_const</b>&lt; _Up &gt; &amp;__pu) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&lt;=</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt, const _Up &amp;__u) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&lt;=</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt, const <b>propagate_const</b>&lt; _Up &gt;
&amp;__pu) <br>
template&lt;typename _Tp &gt; bool <b>operator&lt;=</b>
(const shared_ptr&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
<br>
template&lt;typename _Tp1 , typename _Tp2 &gt; bool
<b>operator&lt;=</b> (const shared_ptr&lt; _Tp1 &gt;
&amp;__a, const shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept
<br>
template&lt;typename _Tp &gt; bool <b>operator&lt;=</b>
(nullptr_t, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
<br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator&lt;=</b> (observer_ptr&lt; _Tp &gt; __p1,
observer_ptr&lt; _Up &gt; __p2) <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator==</b> (__type_identity_t&lt;
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator==</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
__type_identity_t&lt; <b>basic_string_view</b>&lt; _CharT,
_Traits &gt; &gt; __y) noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator==</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator==</b> (const _Tp &amp;__t, const
<b>propagate_const</b>&lt; _Up &gt; &amp;__pu) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator==</b> (const <b>propagate_const</b>&lt; _Tp &gt;
&amp;__pt, const _Up &amp;__u) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator==</b> (const <b>propagate_const</b>&lt; _Tp &gt;
&amp;__pt, const <b>propagate_const</b>&lt; _Up &gt;
&amp;__pu) <br>
template&lt;typename _Tp &gt; constexpr bool
<b>operator==</b> (const <b>propagate_const</b>&lt; _Tp &gt;
&amp;__pt, nullptr_t) <br>
template&lt;typename _Tp &gt; bool <b>operator==</b> (const
shared_ptr&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept <br>
template&lt;typename _Tp1 , typename _Tp2 &gt; bool
<b>operator==</b> (const shared_ptr&lt; _Tp1 &gt; &amp;__a,
const shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept <br>
template&lt;typename _Tp &gt; constexpr bool
<b>operator==</b> (nullptr_t, const
<b>propagate_const</b>&lt; _Tp &gt; &amp;__pu) <br>
template&lt;typename _Tp &gt; bool <b>operator==</b>
(nullptr_t, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
<br>
template&lt;typename _Tp &gt; bool <b>operator==</b>
(nullptr_t, observer_ptr&lt; _Tp &gt; __p) noexcept <br>
template&lt;typename _Tp &gt; bool <b>operator==</b>
(observer_ptr&lt; _Tp &gt; __p, nullptr_t) noexcept <br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator==</b> (observer_ptr&lt; _Tp &gt; __p1,
observer_ptr&lt; _Up &gt; __p2) <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&gt;</b> (__type_identity_t&lt;
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&gt;</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
__type_identity_t&lt; <b>basic_string_view</b>&lt; _CharT,
_Traits &gt; &gt; __y) noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&gt;</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&gt;</b> (const _Tp &amp;__t, const
<b>propagate_const</b>&lt; _Up &gt; &amp;__pu) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&gt;</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt, const _Up &amp;__u) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&gt;</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt, const <b>propagate_const</b>&lt; _Up &gt;
&amp;__pu) <br>
template&lt;typename _Tp &gt; bool <b>operator&gt;</b>
(const shared_ptr&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
<br>
template&lt;typename _Tp1 , typename _Tp2 &gt; bool
<b>operator&gt;</b> (const shared_ptr&lt; _Tp1 &gt;
&amp;__a, const shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept
<br>
template&lt;typename _Tp &gt; bool <b>operator&gt;</b>
(nullptr_t, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
<br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator&gt;</b> (observer_ptr&lt; _Tp &gt; __p1,
observer_ptr&lt; _Up &gt; __p2) <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&gt;=</b> (__type_identity_t&lt;
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&gt;=</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
__type_identity_t&lt; <b>basic_string_view</b>&lt; _CharT,
_Traits &gt; &gt; __y) noexcept <br>
template&lt;typename _CharT , typename _Traits &gt;
constexpr bool <b>operator&gt;=</b>
(<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __x,
<b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y)
noexcept <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&gt;=</b> (const _Tp &amp;__t, const
<b>propagate_const</b>&lt; _Up &gt; &amp;__pu) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&gt;=</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt, const _Up &amp;__u) <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>operator&gt;=</b> (const <b>propagate_const</b>&lt; _Tp
&gt; &amp;__pt, const <b>propagate_const</b>&lt; _Up &gt;
&amp;__pu) <br>
template&lt;typename _Tp &gt; bool <b>operator&gt;=</b>
(const shared_ptr&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
<br>
template&lt;typename _Tp1 , typename _Tp2 &gt; bool
<b>operator&gt;=</b> (const shared_ptr&lt; _Tp1 &gt;
&amp;__a, const shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept
<br>
template&lt;typename _Tp &gt; bool <b>operator&gt;=</b>
(nullptr_t, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
<br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator&gt;=</b> (observer_ptr&lt; _Tp &gt; __p1,
observer_ptr&lt; _Up &gt; __p2) <br>
template&lt;typename _IntType &gt; _IntType <b>randint</b>
(_IntType __a, _IntType __b) <br>
template&lt;typename _Tp , typename _Tp1 &gt; shared_ptr&lt;
_Tp &gt; <b>reinterpret_pointer_cast</b> (const
shared_ptr&lt; _Tp1 &gt; &amp;__r) noexcept <br>
void <b>reseed</b> () <br>
void <b>reseed</b>
(<b>default_random_engine::result_type</b> __value) <br>
template&lt;typename _PopulationIterator , typename
_SampleIterator , typename _Distance &gt; _SampleIterator
<b>sample</b> (_PopulationIterator __first,
_PopulationIterator __last, _SampleIterator __out, _Distance
__n) <br>
template&lt;typename _PopulationIterator , typename
_SampleIterator , typename _Distance , typename
_UniformRandomNumberGenerator &gt; _SampleIterator
<b>sample</b> (_PopulationIterator __first,
_PopulationIterator __last, _SampleIterator __out, _Distance
__n, _UniformRandomNumberGenerator &amp;&amp;__g) <br>
Take a random sample from a population. <br>
template&lt;typename _ForwardIterator , typename _Searcher
&gt; _ForwardIterator <b>search</b> (_ForwardIterator
__first, _ForwardIterator __last, const _Searcher
&amp;__searcher) <br>
template&lt;typename _RandomAccessIterator &gt; void
<b>shuffle</b> (_RandomAccessIterator __first,
_RandomAccessIterator __last) <br>
template&lt;typename _Tp , typename _Tp1 &gt; shared_ptr&lt;
_Tp &gt; <b>static_pointer_cast</b> (const shared_ptr&lt;
_Tp1 &gt; &amp;__r) noexcept <br>
void <b>swap</b> (<b>any</b> &amp;__x, <b>any</b> &amp;__y)
noexcept <br>
Exchange the states of two <tt>any</tt> objects. <br>
template&lt;typename _Tp &gt; void <b>swap</b>
(observer_ptr&lt; _Tp &gt; &amp;__p1, observer_ptr&lt; _Tp
&gt; &amp;__p2) noexcept <br>
template&lt;typename _Tp &gt; constexpr
<b>enable_if_t</b>&lt; __is_swappable&lt; _Tp &gt;::value,
void &gt; <b>swap</b> (<b>propagate_const</b>&lt; _Tp &gt;
&amp;__pt, <b>propagate_const</b>&lt; _Tp &gt; &amp;__pt2)
noexcept(__is_nothrow_swappable&lt; _Tp &gt;::value) <br>
template&lt;typename _Tp &gt; void <b>swap</b>
(shared_ptr&lt; _Tp &gt; &amp;__a, shared_ptr&lt; _Tp &gt;
&amp;__b) noexcept <br>
template&lt;typename _Tp &gt; void <b>swap</b> (weak_ptr&lt;
_Tp &gt; &amp;__a, weak_ptr&lt; _Tp &gt; &amp;__b) noexcept
<br>
template&lt;typename _Tp , size_t _Nm&gt; constexpr
<b>array</b>&lt; <b>remove_cv_t</b>&lt; _Tp &gt;, _Nm &gt;
<b>to_array</b> (_Tp(&amp;__a)[_Nm])
noexcept(<b>is_nothrow_constructible</b>&lt;
<b>remove_cv_t</b>&lt; _Tp &gt;, _Tp &amp; &gt;::value) <br>
Create a std::array from an array.</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_ValueType &gt; _ValueType <b>any_cast</b> (<b>any</b>
&amp;__any) <br>
Access the contained object. <br>
template&lt;typename _ValueType , typename
<b>enable_if</b>&lt;!<b>is_move_constructible</b>&lt;
_ValueType &gt;::value||<b>is_lvalue_reference</b>&lt;
_ValueType &gt;::value, bool &gt;::type = true&gt;
_ValueType <b>any_cast</b> (<b>any</b> &amp;&amp;__any) <br>
Access the contained object. <br>
template&lt;typename _ValueType , typename
<b>enable_if</b>&lt; <b>is_move_constructible</b>&lt;
_ValueType &gt;::value
&amp;&amp;!<b>is_lvalue_reference</b>&lt; _ValueType
&gt;::value, bool &gt;::type = false&gt; _ValueType
<b>any_cast</b> (<b>any</b> &amp;&amp;__any) <br>
Access the contained object.</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_ValueType &gt; const _ValueType * <b>any_cast</b> (const
<b>any</b> *__any) noexcept <br>
Access the contained object. <br>
template&lt;typename _ValueType &gt; _ValueType *
<b>any_cast</b> (<b>any</b> *__any) noexcept <br>
Access the contained object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Variables</b></p>

<p style="margin-left:17%;">template&lt;typename _Yp ,
typename _Tp &gt; constexpr bool <b>__sp_compatible_v</b>
<br>
template&lt;typename _Tp , typename _Yp &gt; constexpr bool
<b>__sp_is_constructible_v</b> <br>
constexpr <b>in_place_t in_place</b> <br>
Tag for in-place construction. <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_bind_expression_v</b> <br>
Variable template for std::is_bind_expression. <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_error_code_enum_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_error_condition_enum_v</b> <br>
template&lt;typename _Tp &gt; constexpr int
<b>is_placeholder_v</b> <br>
Variable template for std::is_placeholder. <br>
constexpr <b>nullopt_t nullopt</b> <br>
Tag to disengage optional objects. <br>
template&lt;typename _R1 , typename _R2 &gt; constexpr bool
<b>ratio_equal_v</b> <br>
template&lt;typename _R1 , typename _R2 &gt; constexpr bool
<b>ratio_greater_equal_v</b> <br>
template&lt;typename _R1 , typename _R2 &gt; constexpr bool
<b>ratio_greater_v</b> <br>
template&lt;typename _R1 , typename _R2 &gt; constexpr bool
<b>ratio_less_equal_v</b> <br>
template&lt;typename _R1 , typename _R2 &gt; constexpr bool
<b>ratio_less_v</b> <br>
template&lt;typename _R1 , typename _R2 &gt; constexpr bool
<b>ratio_not_equal_v</b> <br>
template&lt;typename _Tp &gt; constexpr size_t
<b>tuple_size_v</b></p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_Tp &gt; constexpr bool <b>is_void_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_null_pointer_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_integral_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_floating_point_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_array_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_pointer_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_lvalue_reference_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_rvalue_reference_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_member_object_pointer_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_member_function_pointer_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_enum_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_union_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_class_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_function_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_reference_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_arithmetic_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_fundamental_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_object_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_scalar_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_compound_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_member_pointer_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_const_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_volatile_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_trivial_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_trivially_copyable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_standard_layout_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool <b>is_pod_v</b>
<br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_literal_type_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_empty_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_polymorphic_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_abstract_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_final_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_signed_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_unsigned_v</b> <br>
template&lt;typename _Tp , typename... _Args&gt; constexpr
bool <b>is_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_default_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_copy_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_move_constructible_v</b> <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>is_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_copy_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_move_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_destructible_v</b> <br>
template&lt;typename _Tp , typename... _Args&gt; constexpr
bool <b>is_trivially_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_trivially_default_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_trivially_copy_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_trivially_move_constructible_v</b> <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>is_trivially_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_trivially_copy_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_trivially_move_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_trivially_destructible_v</b> <br>
template&lt;typename _Tp , typename... _Args&gt; constexpr
bool <b>is_nothrow_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_nothrow_default_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_nothrow_copy_constructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_nothrow_move_constructible_v</b> <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>is_nothrow_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_nothrow_copy_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_nothrow_move_assignable_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_nothrow_destructible_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>has_virtual_destructor_v</b> <br>
template&lt;typename _Tp &gt; constexpr size_t
<b>alignment_of_v</b> <br>
template&lt;typename _Tp &gt; constexpr size_t <b>rank_v</b>
<br>
template&lt;typename _Tp , unsigned _Idx = 0&gt; constexpr
size_t <b>extent_v</b> <br>
template&lt;typename _Tp , typename _Up &gt; constexpr bool
<b>is_same_v</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>is_same_v&lt; _Tp, _Tp &gt;</b> <br>
template&lt;typename _Base , typename _Derived &gt;
constexpr bool <b>is_base_of_v</b> <br>
template&lt;typename _From , typename _To &gt; constexpr
bool <b>is_convertible_v</b></p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename...
_Bn&gt; constexpr bool <b>conjunction_v</b> <br>
template&lt;typename... _Bn&gt; constexpr bool
<b>disjunction_v</b> <br>
template&lt;typename _Pp &gt; constexpr bool
<b>negation_v</b></p>

<p style="margin-left:17%;">template&lt;typename... &gt;
using <b>void_t</b> = void <br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;typename _Default , template&lt; typename...
&gt; class _Op, typename... _Args&gt; using
<b>detected_or</b> = std::__detected_or&lt; _Default, _Op,
_Args... &gt; <br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;typename _Default , template&lt; typename...
&gt; class _Op, typename... _Args&gt; using
<b>detected_or_t</b> = typename detected_or&lt; _Default,
_Op, _Args... &gt;::type <br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;template&lt; typename... &gt; class _Op,
typename... _Args&gt; using <b>detected_t</b> =
detected_or_t&lt; nonesuch, _Op, _Args... &gt; <br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;template&lt; typename... &gt; class _Op,
typename... _Args&gt; using <b>is_detected</b> = typename
detected_or&lt; void, _Op, _Args... &gt;::__is_detected <br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;typename _Expected , template&lt; typename...
&gt; class _Op, typename... _Args&gt; using
<b>is_detected_exact</b> = <b>is_same</b>&lt; _Expected,
detected_t&lt; _Op, _Args... &gt; &gt; <br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;typename _To , template&lt; typename... &gt;
class _Op, typename... _Args&gt; using
<b>is_detected_convertible</b> = is_convertible&lt;
detected_t&lt; _Op, _Args... &gt;, _To &gt; <br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;template&lt; typename... &gt; class _Op,
typename... _Args&gt; constexpr bool <b>is_detected_v</b>
<br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;typename _Expected , template&lt; typename...
&gt; class _Op, typename... _Args&gt; constexpr bool
<b>is_detected_exact_v</b> <br>
A metafunction that always yields void, used for detecting
valid types. <br>
template&lt;typename _To , template&lt; typename... &gt;
class _Op, typename... _Args&gt; constexpr bool
<b>is_detected_convertible_v</b> <br>
A metafunction that always yields void, used for detecting
valid types.</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Namespace for
features defined in ISO Technical Specifications.</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Mn , typename _Nn &gt; constexpr common_type_t&lt; _Mn, _Nn
&gt; std::experimental::fundamentals_v2::gcd (_Mn __m, _Nn
__n)</b> <tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Greatest common divisor.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::gcd()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Del , typename _Tp &gt; _Del *
std::experimental::fundamentals_v2::get_deleter (const
shared_ptr&lt; _Tp &gt; &amp; __p)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
C++14 20.8.2.2.10.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Mn , typename _Nn &gt; constexpr common_type_t&lt; _Mn, _Nn
&gt; std::experimental::fundamentals_v2::lcm (_Mn __m, _Nn
__n)</b> <tt>[constexpr]</tt> <br>
Least common multiple.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::lcm()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_RAIter , typename _Hash = std::hash&lt;typename
std::iterator_traits&lt;_RAIter&gt;::value_type&gt;,
typename _BinaryPredicate = equal_to&lt;&gt;&gt;
boyer_moore_horspool_searcher&lt; _RAIter, _Hash,
_BinaryPredicate &gt;
std::experimental::fundamentals_v1::make_boyer_moore_horspool_searcher
(_RAIter __pat_first, _RAIter __pat_last, _Hash __hf =</b>
<tt>_Hash()</tt><b>, _BinaryPredicate __pred =</b>
<tt>_BinaryPredicate()</tt><b>)</b> <tt>[inline]</tt> <br>
Generator function for boyer_moore_horspool_searcher.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>make_boyer_moore_horspool_searcher()</b>, and
<b>std::move()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>make_boyer_moore_horspool_searcher()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_RAIter , typename _Hash = std::hash&lt;typename
std::iterator_traits&lt;_RAIter&gt;::value_type&gt;,
typename _BinaryPredicate = equal_to&lt;&gt;&gt;
boyer_moore_searcher&lt; _RAIter, _Hash, _BinaryPredicate
&gt;
std::experimental::fundamentals_v1::make_boyer_moore_searcher
(_RAIter __pat_first, _RAIter __pat_last, _Hash __hf =</b>
<tt>_Hash()</tt><b>, _BinaryPredicate __pred =</b>
<tt>_BinaryPredicate()</tt><b>)</b> <tt>[inline]</tt> <br>
Generator function for boyer_moore_searcher.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>make_boyer_moore_searcher()</b>, and
<b>std::move()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>make_boyer_moore_searcher()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_ForwardIterator , typename _BinaryPredicate =
std::equal_to&lt;&gt;&gt; default_searcher&lt;
_ForwardIterator, _BinaryPredicate &gt;
std::experimental::fundamentals_v1::make_default_searcher
(_ForwardIterator __pat_first, _ForwardIterator __pat_last,
_BinaryPredicate __pred =</b>
<tt>_BinaryPredicate()</tt><b>)</b> <tt>[inline]</tt> <br>
Generator function for default_searcher.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>make_default_searcher()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>make_default_searcher()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT , typename _Traits , typename _DelimT &gt;
ostream_joiner&lt; decay_t&lt; _DelimT &gt;, _CharT, _Traits
&gt; std::experimental::fundamentals_v2::make_ostream_joiner
(basic_ostream&lt; _CharT, _Traits &gt; &amp; __os, _DelimT
&amp;&amp; __delimiter)</b> <tt>[inline]</tt> <br>
Object generator for ostream_joiner.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>make_ostream_joiner()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>make_ostream_joiner()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Fn &gt; auto std::experimental::fundamentals_v2::not_fn
(_Fn &amp;&amp; __fn)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
[func.not_fn] Function template not_fn</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::not_fn()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_PopulationIterator , typename _SampleIterator , typename
_Distance , typename _UniformRandomNumberGenerator &gt;
_SampleIterator std::experimental::fundamentals_v2::sample
(_PopulationIterator __first, _PopulationIterator __last,
_SampleIterator __out, _Distance __n,
_UniformRandomNumberGenerator &amp;&amp; __g)</b> <br>
Take a random sample from a population.</p>

<h2>Variable Documentation
<a name="Variable Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; constexpr bool
std::experimental::fundamentals_v1::is_bind_expression_v</b>
<tt>[constexpr]</tt> <br>
Variable template for std::is_bind_expression.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; constexpr int
std::experimental::fundamentals_v1::is_placeholder_v</b>
<tt>[constexpr]</tt> <br>
Variable template for std::is_placeholder.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
