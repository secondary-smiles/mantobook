<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:55 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EVP_DIGESTINIT</title>

</head>
<body>
<h1>EVP_MD_CTX_pkey_ctx</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">EVP_MD_fetch,
EVP_MD_up_ref, EVP_MD_free, EVP_MD_get_params,
EVP_MD_gettable_params, EVP_MD_CTX_new, EVP_MD_CTX_reset,
EVP_MD_CTX_free, EVP_MD_CTX_copy, EVP_MD_CTX_copy_ex,
EVP_MD_CTX_ctrl, EVP_MD_CTX_set_params,
EVP_MD_CTX_get_params, EVP_MD_settable_ctx_params,
EVP_MD_gettable_ctx_params, EVP_MD_CTX_settable_params,
EVP_MD_CTX_gettable_params, EVP_MD_CTX_set_flags,
EVP_MD_CTX_clear_flags, EVP_MD_CTX_test_flags, EVP_Q_digest,
EVP_Digest, EVP_DigestInit_ex2, EVP_DigestInit_ex,
EVP_DigestInit, EVP_DigestUpdate, EVP_DigestFinal_ex,
EVP_DigestFinalXOF, EVP_DigestFinal, EVP_MD_is_a,
EVP_MD_get0_name, EVP_MD_get0_description,
EVP_MD_names_do_all, EVP_MD_get0_provider, EVP_MD_get_type,
EVP_MD_get_pkey_type, EVP_MD_get_size,
EVP_MD_get_block_size, EVP_MD_get_flags,
EVP_MD_CTX_get0_name, EVP_MD_CTX_md, EVP_MD_CTX_get0_md,
EVP_MD_CTX_get1_md, EVP_MD_CTX_get_type,
EVP_MD_CTX_get_size, EVP_MD_CTX_get_block_size,
EVP_MD_CTX_get0_md_data, EVP_MD_CTX_update_fn,
EVP_MD_CTX_set_update_fn, EVP_md_null, EVP_get_digestbyname,
EVP_get_digestbynid, EVP_get_digestbyobj,
EVP_MD_CTX_get_pkey_ctx, EVP_MD_CTX_set_pkey_ctx,
EVP_MD_do_all_provided, EVP_MD_type, EVP_MD_nid,
EVP_MD_name, EVP_MD_pkey_type, EVP_MD_size,
EVP_MD_block_size, EVP_MD_flags, EVP_MD_CTX_size,
EVP_MD_CTX_block_size, EVP_MD_CTX_type, EVP_MD_CTX_pkey_ctx,
EVP_MD_CTX_md_data &minus; EVP digest routines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/evp.h&gt; <br>
EVP_MD *EVP_MD_fetch(OSSL_LIB_CTX *ctx, const char
*algorithm, <br>
const char *properties); <br>
int EVP_MD_up_ref(EVP_MD *md); <br>
void EVP_MD_free(EVP_MD *md); <br>
int EVP_MD_get_params(const EVP_MD *digest, OSSL_PARAM
params[]); <br>
const OSSL_PARAM *EVP_MD_gettable_params(const EVP_MD
*digest); <br>
EVP_MD_CTX *EVP_MD_CTX_new(void); <br>
int EVP_MD_CTX_reset(EVP_MD_CTX *ctx); <br>
void EVP_MD_CTX_free(EVP_MD_CTX *ctx); <br>
void EVP_MD_CTX_ctrl(EVP_MD_CTX *ctx, int cmd, int p1, void*
p2); <br>
int EVP_MD_CTX_get_params(EVP_MD_CTX *ctx, OSSL_PARAM
params[]); <br>
int EVP_MD_CTX_set_params(EVP_MD_CTX *ctx, const OSSL_PARAM
params[]); <br>
const OSSL_PARAM *EVP_MD_settable_ctx_params(const EVP_MD
*md); <br>
const OSSL_PARAM *EVP_MD_gettable_ctx_params(const EVP_MD
*md); <br>
const OSSL_PARAM *EVP_MD_CTX_settable_params(EVP_MD_CTX
*ctx); <br>
const OSSL_PARAM *EVP_MD_CTX_gettable_params(EVP_MD_CTX
*ctx); <br>
void EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags); <br>
void EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);
<br>
int EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx, int flags);
<br>
int EVP_Q_digest(OSSL_LIB_CTX *libctx, const char *name,
const char *propq, <br>
const void *data, size_t datalen, <br>
unsigned char *md, size_t *mdlen); <br>
int EVP_Digest(const void *data, size_t count, unsigned char
*md, <br>
unsigned int *size, const EVP_MD *type, ENGINE *impl); <br>
int EVP_DigestInit_ex2(EVP_MD_CTX *ctx, const EVP_MD *type,
<br>
const OSSL_PARAM params[]); <br>
int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type,
ENGINE *impl); <br>
int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t
cnt); <br>
int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,
unsigned int *s); <br>
int EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md,
size_t len); <br>
int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX
*in); <br>
int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
<br>
int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,
unsigned int *s); <br>
int EVP_MD_CTX_copy(EVP_MD_CTX *out, EVP_MD_CTX *in); <br>
const char *EVP_MD_get0_name(const EVP_MD *md); <br>
const char *EVP_MD_get0_description(const EVP_MD *md); <br>
int EVP_MD_is_a(const EVP_MD *md, const char *name); <br>
int EVP_MD_names_do_all(const EVP_MD *md, <br>
void (*fn)(const char *name, void *data), <br>
void *data); <br>
const OSSL_PROVIDER *EVP_MD_get0_provider(const EVP_MD *md);
<br>
int EVP_MD_get_type(const EVP_MD *md); <br>
int EVP_MD_get_pkey_type(const EVP_MD *md); <br>
int EVP_MD_get_size(const EVP_MD *md); <br>
int EVP_MD_get_block_size(const EVP_MD *md); <br>
unsigned long EVP_MD_get_flags(const EVP_MD *md); <br>
const EVP_MD *EVP_MD_CTX_get0_md(const EVP_MD_CTX *ctx);
<br>
EVP_MD *EVP_MD_CTX_get1_md(EVP_MD_CTX *ctx); <br>
const char *EVP_MD_CTX_get0_name(const EVP_MD_CTX *ctx);
<br>
int EVP_MD_CTX_get_size(const EVP_MD_CTX *ctx); <br>
int EVP_MD_CTX_get_block_size(const EVP_MD_CTX *ctx); <br>
int EVP_MD_CTX_get_type(const EVP_MD_CTX *ctx); <br>
void *EVP_MD_CTX_get0_md_data(const EVP_MD_CTX *ctx); <br>
const EVP_MD *EVP_md_null(void); <br>
const EVP_MD *EVP_get_digestbyname(const char *name); <br>
const EVP_MD *EVP_get_digestbynid(int type); <br>
const EVP_MD *EVP_get_digestbyobj(const ASN1_OBJECT *o);
<br>
EVP_PKEY_CTX *EVP_MD_CTX_get_pkey_ctx(const EVP_MD_CTX
*ctx); <br>
void EVP_MD_CTX_set_pkey_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX
*pctx); <br>
void EVP_MD_do_all_provided(OSSL_LIB_CTX *libctx, <br>
void (*fn)(EVP_MD *mac, void *arg), <br>
void *arg); <br>
#define EVP_MD_type EVP_MD_get_type <br>
#define EVP_MD_nid EVP_MD_get_type <br>
#define EVP_MD_name EVP_MD_get0_name <br>
#define EVP_MD_pkey_type EVP_MD_get_pkey_type <br>
#define EVP_MD_size EVP_MD_get_size <br>
#define EVP_MD_block_size EVP_MD_get_block_size <br>
#define EVP_MD_flags EVP_MD_get_flags <br>
#define EVP_MD_CTX_size EVP_MD_CTX_get_size <br>
#define EVP_MD_CTX_block_size EVP_MD_CTX_get_block_size <br>
#define EVP_MD_CTX_type EVP_MD_CTX_get_type <br>
#define EVP_MD_CTX_pkey_ctx EVP_MD_CTX_get_pkey_ctx <br>
#define EVP_MD_CTX_md_data EVP_MD_CTX_get0_md_data</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining
<b><small>OPENSSL_API_COMPAT</small></b> with a suitable
version value, see <b>openssl_user_macros</b>(7):</p>

<p style="margin-left:11%; margin-top: 1em">const EVP_MD
*EVP_MD_CTX_md(const EVP_MD_CTX *ctx); <br>
int (*EVP_MD_CTX_update_fn(EVP_MD_CTX *ctx))(EVP_MD_CTX
*ctx, <br>
const void *data, size_t count); <br>
void EVP_MD_CTX_set_update_fn(EVP_MD_CTX *ctx, <br>
int (*update)(EVP_MD_CTX *ctx, <br>
const void *data, size_t count));</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>EVP</small> digest routines are a high-level
interface to message digests, and should be used instead of
the digest-specific functions.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>EVP_MD</small></b> type is a structure for digest
method implementation. <b><br>
EVP_MD_fetch()</b></p>

<p style="margin-left:17%;">Fetches the digest
implementation for the given <i>algorithm</i> from any
provider offering it, within the criteria given by the
<i>properties</i>. See &quot; <small>ALGORITHM
FETCHING&quot;</small> in <b>crypto</b>(7) for further
information.</p>

<p style="margin-left:17%; margin-top: 1em">The returned
value must eventually be freed with
<b>EVP_MD_free()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Fetched
<b><small>EVP_MD</small></b> structures are reference
counted.</p>

<p style="margin-left:11%;"><b>EVP_MD_up_ref()</b></p>

<p style="margin-left:17%;">Increments the reference count
for an <b><small>EVP_MD</small></b> structure.</p>

<p style="margin-left:11%;"><b>EVP_MD_free()</b></p>

<p style="margin-left:17%;">Decrements the reference count
for the fetched <b><small>EVP_MD</small></b> structure. If
the reference count drops to 0 then the structure is
freed.</p>

<p style="margin-left:11%;"><b>EVP_MD_CTX_new()</b></p>

<p style="margin-left:17%;">Allocates and returns a digest
context.</p>

<p style="margin-left:11%;"><b>EVP_MD_CTX_reset()</b></p>

<p style="margin-left:17%;">Resets the digest context
<i>ctx</i>. This can be used to reuse an already existing
context.</p>

<p style="margin-left:11%;"><b>EVP_MD_CTX_free()</b></p>

<p style="margin-left:17%;">Cleans up digest context
<i>ctx</i> and frees up the space allocated to it.</p>

<p style="margin-left:11%;"><b>EVP_MD_CTX_ctrl()</b></p>

<p style="margin-left:17%;"><i>This is a legacy method.</i>
<b><i>EVP_MD_CTX_set_params()</i></b> <i>and</i>
<b><i>EVP_MD_CTX_get_params()</i></b> <i>is the mechanism
that should be used to set and get parameters that are used
by providers.</i></p>

<p style="margin-left:17%; margin-top: 1em">Performs
digest-specific control actions on context <i>ctx</i>. The
control command is indicated in <i>cmd</i> and any
additional arguments in <i>p1</i> and <i>p2</i>.
<b>EVP_MD_CTX_ctrl()</b> must be called after
<b>EVP_DigestInit_ex2()</b>. Other restrictions may apply
depending on the control type and digest implementation.</p>

<p style="margin-left:17%; margin-top: 1em">If this
function happens to be used with a fetched
<b><small>EVP_MD</small></b> , it will translate the
controls that are known to OpenSSL into
<b><small>OSSL_PARAM</small></b> (3) parameters with keys
defined by OpenSSL and call <b>EVP_MD_CTX_get_params()</b>
or <b>EVP_MD_CTX_set_params()</b> as is appropriate for each
control command.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>CONTROLS&quot;</small> below for more information,
including what translations are being done.</p>

<p style="margin-left:11%;"><b>EVP_MD_get_params()</b></p>

<p style="margin-left:17%;">Retrieves the requested list of
<i>params</i> from a <small>MD</small> <i>md</i>. See &quot;
<small>PARAMETERS&quot;</small> below for more
information.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_get_params()</b></p>

<p style="margin-left:17%;">Retrieves the requested list of
<i>params</i> from a <small>MD</small> context <i>ctx</i>.
See &quot; <small>PARAMETERS&quot;</small> below for more
information.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_set_params()</b></p>

<p style="margin-left:17%;">Sets the list of <i>params</i>
into a <small>MD</small> context <i>ctx</i>. See &quot;
<small>PARAMETERS&quot;</small> below for more
information.</p>


<p style="margin-left:11%;"><b>EVP_MD_gettable_params()</b></p>

<p style="margin-left:17%;">Get a constant
<b><small>OSSL_PARAM</small></b> (3) array that describes
the retrievable parameters that can be used with
<b>EVP_MD_get_params()</b>.</p>


<p style="margin-left:11%;"><b>EVP_MD_gettable_ctx_params()</b>,
<b>EVP_MD_CTX_gettable_params()</b></p>

<p style="margin-left:17%;">Get a constant
<b><small>OSSL_PARAM</small></b> (3) array that describes
the retrievable parameters that can be used with
<b>EVP_MD_CTX_get_params()</b>.
<b>EVP_MD_gettable_ctx_params()</b> returns the parameters
that can be retrieved from the algorithm, whereas
<b>EVP_MD_CTX_gettable_params()</b> returns the parameters
that can be retrieved in the context&rsquo;s current
state.</p>


<p style="margin-left:11%;"><b>EVP_MD_settable_ctx_params()</b>,
<b>EVP_MD_CTX_settable_params()</b></p>

<p style="margin-left:17%;">Get a constant
<b><small>OSSL_PARAM</small></b> (3) array that describes
the settable parameters that can be used with
<b>EVP_MD_CTX_set_params()</b>.
<b>EVP_MD_settable_ctx_params()</b> returns the parameters
that can be set from the algorithm, whereas
<b>EVP_MD_CTX_settable_params()</b> returns the parameters
that can be set in the context&rsquo;s current state.</p>

<p style="margin-left:11%;"><b>EVP_MD_CTX_set_flags()</b>,
<b>EVP_MD_CTX_clear_flags()</b>, <b><br>
EVP_MD_CTX_test_flags()</b></p>

<p style="margin-left:17%;">Sets, clears and tests
<i>ctx</i> flags. See &quot; <small>FLAGS&quot;</small>
below for more information.</p>

<p style="margin-left:11%;"><b>EVP_Q_digest()</b> is a
quick one-shot digest function.</p>

<p style="margin-left:17%;">It hashes <i>datalen</i> bytes
of data at <i>data</i> using the digest algorithm
<i>name</i>, which is fetched using the optional
<i>libctx</i> and <i>propq</i> parameters. The digest value
is placed in <i>md</i> and its length is written at
<i>mdlen</i> if the pointer is not <small>NULL.</small> At
most <b><small>EVP_MAX_MD_SIZE</small></b> bytes will be
written.</p>

<p style="margin-left:11%;"><b>EVP_Digest()</b></p>

<p style="margin-left:17%;">A wrapper around the Digest
Init_ex, Update and Final_ex functions. Hashes <i>count</i>
bytes of data at <i>data</i> using a digest <i>type</i> from
<small>ENGINE</small> <i>impl</i>. The digest value is
placed in <i>md</i> and its length is written at <i>size</i>
if the pointer is not <small>NULL.</small> At most
<b><small>EVP_MAX_MD_SIZE</small></b> bytes will be written.
If <i>impl</i> is <small>NULL</small> the default
implementation of digest <i>type</i> is used.</p>


<p style="margin-left:11%;"><b>EVP_DigestInit_ex2()</b></p>

<p style="margin-left:17%;">Sets up digest context
<i>ctx</i> to use a digest <i>type</i>. <i>type</i> is
typically supplied by a function such as <b>EVP_sha1()</b>,
or a value explicitly fetched with
<b>EVP_MD_fetch()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">The parameters
<b>params</b> are set on the context after
initialisation.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>type</i>
parameter can be <small>NULL</small> if <i>ctx</i> has been
already initialized with another <b>EVP_DigestInit_ex()</b>
call and has not been reset with
<b>EVP_MD_CTX_reset()</b>.</p>

<p style="margin-left:11%;"><b>EVP_DigestInit_ex()</b></p>

<p style="margin-left:17%;">Sets up digest context
<i>ctx</i> to use a digest <i>type</i>. <i>type</i> is
typically supplied by a function such as <b>EVP_sha1()</b>,
or a value explicitly fetched with
<b>EVP_MD_fetch()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">If <i>impl</i>
is non-NULL, its implementation of the digest <i>type</i> is
used if there is one, and if not, the default implementation
is used.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>type</i>
parameter can be <small>NULL</small> if <i>ctx</i> has been
already initialized with another <b>EVP_DigestInit_ex()</b>
call and has not been reset with
<b>EVP_MD_CTX_reset()</b>.</p>

<p style="margin-left:11%;"><b>EVP_DigestUpdate()</b></p>

<p style="margin-left:17%;">Hashes <i>cnt</i> bytes of data
at <i>d</i> into the digest context <i>ctx</i>. This
function can be called several times on the same <i>ctx</i>
to hash additional data.</p>


<p style="margin-left:11%;"><b>EVP_DigestFinal_ex()</b></p>

<p style="margin-left:17%;">Retrieves the digest value from
<i>ctx</i> and places it in <i>md</i>. If the <i>s</i>
parameter is not <small>NULL</small> then the number of
bytes of data written (i.e. the length of the digest) will
be written to the integer at <i>s</i>, at most
<b><small>EVP_MAX_MD_SIZE</small></b> bytes will be written.
After calling <b>EVP_DigestFinal_ex()</b> no additional
calls to <b>EVP_DigestUpdate()</b> can be made, but
<b>EVP_DigestInit_ex2()</b> can be called to initialize a
new digest operation.</p>


<p style="margin-left:11%;"><b>EVP_DigestFinalXOF()</b></p>

<p style="margin-left:17%;">Interfaces to extendable-output
functions, XOFs, such as <small>SHAKE128</small> and
<small>SHAKE256.</small> It retrieves the digest value from
<i>ctx</i> and places it in <i>len</i>&minus;sized
<i>md</i>. After calling this function no additional calls
to <b>EVP_DigestUpdate()</b> can be made, but
<b>EVP_DigestInit_ex2()</b> can be called to initialize a
new operation.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_copy_ex()</b></p>

<p style="margin-left:17%;">Can be used to copy the message
digest state from <i>in</i> to <i>out</i>. This is useful if
large amounts of data are to be hashed which only differ in
the last few bytes.</p>

<p style="margin-left:11%;"><b>EVP_DigestInit()</b></p>

<p style="margin-left:17%;">Behaves in the same way as
<b>EVP_DigestInit_ex2()</b> except it doesn&rsquo;t set any
parameters and calls <b>EVP_MD_CTX_reset()</b> so it cannot
be used with an <i>type</i> of <small>NULL.</small></p>

<p style="margin-left:11%;"><b>EVP_DigestFinal()</b></p>

<p style="margin-left:17%;">Similar to
<b>EVP_DigestFinal_ex()</b> except after computing the
digest the digest context <i>ctx</i> is automatically
cleaned up with <b>EVP_MD_CTX_reset()</b>.</p>

<p style="margin-left:11%;"><b>EVP_MD_CTX_copy()</b></p>

<p style="margin-left:17%;">Similar to
<b>EVP_MD_CTX_copy_ex()</b> except the destination
<i>out</i> does not have to be initialized.</p>

<p style="margin-left:11%;"><b>EVP_MD_is_a()</b></p>

<p style="margin-left:17%;">Returns 1 if <i>md</i> is an
implementation of an algorithm that&rsquo;s identifiable
with <i>name</i>, otherwise 0.</p>

<p style="margin-left:17%; margin-top: 1em">If <i>md</i> is
a legacy digest (it&rsquo;s the return value from the likes
of <b>EVP_sha256()</b> rather than the result of an
<b>EVP_MD_fetch()</b>), only cipher names registered with
the default library context (see
<b><small>OSSL_LIB_CTX</small></b> (3)) will be
considered.</p>

<p style="margin-left:11%;"><b>EVP_MD_get0_name()</b>,
<b>EVP_MD_CTX_get0_name()</b></p>

<p style="margin-left:17%;">Return the name of the given
message digest. For fetched message digests with multiple
names, only one of them is returned; it&rsquo;s recommended
to use <b>EVP_MD_names_do_all()</b> instead.</p>


<p style="margin-left:11%;"><b>EVP_MD_names_do_all()</b></p>

<p style="margin-left:17%;">Traverses all names for the
<i>md</i>, and calls <i>fn</i> with each name and
<i>data</i>. This is only useful with fetched
<b><small>EVP_MD</small></b> s.</p>


<p style="margin-left:11%;"><b>EVP_MD_get0_description()</b></p>

<p style="margin-left:17%;">Returns a description of the
digest, meant for display and human consumption. The
description is at the discretion of the digest
implementation.</p>


<p style="margin-left:11%;"><b>EVP_MD_get0_provider()</b></p>

<p style="margin-left:17%;">Returns an
<b><small>OSSL_PROVIDER</small></b> pointer to the provider
that implements the given <b><small>EVP_MD</small></b> .</p>

<p style="margin-left:11%;"><b>EVP_MD_get_size()</b>,
<b>EVP_MD_CTX_get_size()</b></p>

<p style="margin-left:17%;">Return the size of the message
digest when passed an <b><small>EVP_MD</small></b> or an
<b><small>EVP_MD_CTX</small></b> structure, i.e. the size of
the hash.</p>


<p style="margin-left:11%;"><b>EVP_MD_get_block_size()</b>,
<b>EVP_MD_CTX_get_block_size()</b></p>

<p style="margin-left:17%;">Return the block size of the
message digest when passed an <b><small>EVP_MD</small></b>
or an <b><small>EVP_MD_CTX</small></b> structure.</p>

<p style="margin-left:11%;"><b>EVP_MD_get_type()</b>,
<b>EVP_MD_CTX_get_type()</b></p>

<p style="margin-left:17%;">Return the <small>NID</small>
of the <small>OBJECT IDENTIFIER</small> representing the
given message digest when passed an
<b><small>EVP_MD</small></b> structure. For example,
&quot;EVP_MD_get_type(EVP_sha1())&quot; returns
<b>NID_sha1</b>. This function is normally used when setting
<small>ASN1</small> OIDs.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_get0_md_data()</b></p>

<p style="margin-left:17%;">Return the digest method
private data for the passed <b><small>EVP_MD_CTX</small></b>
. The space is allocated by OpenSSL and has the size
originally set with
<b>EVP_MD_meth_set_app_datasize()</b>.</p>

<p style="margin-left:11%;"><b>EVP_MD_CTX_get0_md()</b>,
<b>EVP_MD_CTX_get1_md()</b></p>

<p style="margin-left:17%;"><b>EVP_MD_CTX_get0_md()</b>
returns the <b><small>EVP_MD</small></b> structure
corresponding to the passed <b><small>EVP_MD_CTX</small></b>
. This will be the same <b><small>EVP_MD</small></b> object
originally passed to <b>EVP_DigestInit_ex2()</b> (or other
similar function) when the <small>EVP_MD_CTX</small> was
first initialised. Note that where explicit fetch is in use
(see <b>EVP_MD_fetch</b>(3)) the value returned from this
function will not have its reference count incremented and
therefore it should not be used after the
<small>EVP_MD_CTX</small> is freed.
<b>EVP_MD_CTX_get1_md()</b> is the same except the ownership
is passed to the caller and is from the passed
<b><small>EVP_MD_CTX</small></b> .</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_set_update_fn()</b></p>

<p style="margin-left:17%;">Sets the update function for
<i>ctx</i> to <i>update</i>. This is the function that is
called by <b>EVP_DigestUpdate()</b>. If not set, the update
function from the <b><small>EVP_MD</small></b> type
specified at initialization is used.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_update_fn()</b></p>

<p style="margin-left:17%;">Returns the update function for
<i>ctx</i>.</p>

<p style="margin-left:11%;"><b>EVP_MD_get_flags()</b></p>

<p style="margin-left:17%;">Returns the <i>md</i> flags.
Note that these are different from the
<b><small>EVP_MD_CTX</small></b> ones. See
<b>EVP_MD_meth_set_flags</b>(3) for more information.</p>


<p style="margin-left:11%;"><b>EVP_MD_get_pkey_type()</b></p>

<p style="margin-left:17%;">Returns the <small>NID</small>
of the public key signing algorithm associated with this
digest. For example <b>EVP_sha1()</b> is associated with
<small>RSA</small> so this will return
<b>NID_sha1WithRSAEncryption</b>. Since digests and
signature algorithms are no longer linked this function is
only retained for compatibility reasons.</p>

<p style="margin-left:11%;"><b>EVP_md_null()</b></p>

<p style="margin-left:17%;">A &quot;null&quot; message
digest that does nothing: i.e. the hash it returns is of
zero length.</p>

<p style="margin-left:11%;"><b>EVP_get_digestbyname()</b>,
<b>EVP_get_digestbynid()</b>,
<b>EVP_get_digestbyobj()</b></p>

<p style="margin-left:17%;">Returns an
<b><small>EVP_MD</small></b> structure when passed a digest
name, a digest <b><small>NID</small></b> or an
<b><small>ASN1_OBJECT</small></b> structure
respectively.</p>

<p style="margin-left:17%; margin-top: 1em">The
<b>EVP_get_digestbyname()</b> function is present for
backwards compatibility with OpenSSL prior to version 3 and
is different to the <b>EVP_MD_fetch()</b> function since it
does not attempt to &quot;fetch&quot; an implementation of
the cipher. Additionally, it only knows about digests that
are built-in to OpenSSL and have an associated
<small>NID.</small> Similarly <b>EVP_get_digestbynid()</b>
and <b>EVP_get_digestbyobj()</b> also return objects without
an associated implementation.</p>

<p style="margin-left:17%; margin-top: 1em">When the digest
objects returned by these functions are used (such as in a
call to <b>EVP_DigestInit_ex()</b>) an implementation of the
digest will be implicitly fetched from the loaded providers.
This fetch could fail if no suitable implementation is
available. Use <b>EVP_MD_fetch()</b> instead to explicitly
fetch the algorithm and an associated implementation from a
provider.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>ALGORITHM FETCHING&quot;</small> in <b>crypto</b>(7)
for more information about fetching.</p>

<p style="margin-left:17%; margin-top: 1em">The digest
objects returned from these functions do not need to be
freed with <b>EVP_MD_free()</b>.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_get_pkey_ctx()</b></p>

<p style="margin-left:17%;">Returns the
<b><small>EVP_PKEY_CTX</small></b> assigned to <i>ctx</i>.
The returned pointer should not be freed by the caller.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_set_pkey_ctx()</b></p>

<p style="margin-left:17%;">Assigns an
<b><small>EVP_PKEY_CTX</small></b> to
<b><small>EVP_MD_CTX</small></b> . This is usually used to
provide a customized <b><small>EVP_PKEY_CTX</small></b> to
<b>EVP_DigestSignInit</b>(3) or
<b>EVP_DigestVerifyInit</b>(3). The <i>pctx</i> passed to
this function should be freed by the caller. A
<small>NULL</small> <i>pctx</i> pointer is also allowed to
clear the <b><small>EVP_PKEY_CTX</small></b> assigned to
<i>ctx</i>. In such case, freeing the cleared
<b><small>EVP_PKEY_CTX</small></b> or not depends on how the
<b><small>EVP_PKEY_CTX</small></b> is created.</p>


<p style="margin-left:11%;"><b>EVP_MD_do_all_provided()</b></p>

<p style="margin-left:17%;">Traverses all messages digests
implemented by all activated providers in the given library
context <i>libctx</i>, and for each of the implementations,
calls the given function <i>fn</i> with the implementation
method and the given <i>arg</i> as argument.</p>

<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<b><small>OSSL_PARAM</small></b> (3) for information about
passing parameters.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_MD_CTX_set_params()</b>
can be used with the following <small>OSSL_PARAM</small>
keys: <br>
&quot;xoflen&quot; (
<b><small>OSSL_DIGEST_PARAM_XOFLEN</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Sets the digest length for
extendable output functions. It is used by the
<small>SHAKE</small> algorithm and should not exceed what
can be given using a <b>size_t</b>.</p>

<p style="margin-left:11%;">&quot;pad-type&quot; (
<b><small>OSSL_DIGEST_PARAM_PAD_TYPE</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Sets the padding type. It is
used by the <small>MDC2</small> algorithm.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_MD_CTX_get_params()</b>
can be used with the following <small>OSSL_PARAM</small>
keys: <br>
&quot;micalg&quot; (
<b><small>OSSL_PARAM_DIGEST_KEY_MICALG</small></b> ) &lt;
<small>UTF8</small> string&gt;.</p>

<p style="margin-left:17%;">Gets the digest Message
Integrity Check algorithm string. This is used when creating
S/MIME multipart/signed messages, as specified in <small>RFC
3851.</small> It may be used by external engines or
providers.</p>

<h2>CONTROLS
<a name="CONTROLS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_MD_CTX_ctrl()</b>
can be used to send the following standard controls:
<small><br>
EVP_MD_CTRL_MICALG</small></p>

<p style="margin-left:17%;">Gets the digest Message
Integrity Check algorithm string. This is used when creating
S/MIME multipart/signed messages, as specified in <small>RFC
3851.</small> The string value is written to <i>p2</i>.</p>

<p style="margin-left:17%; margin-top: 1em">When used with
a fetched <b><small>EVP_MD</small></b> ,
<b>EVP_MD_CTX_get_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;micalg&quot; (
<b><small>OSSL_DIGEST_PARAM_MICALG</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_MD_CTRL_XOF_LEN</small></p>

<p style="margin-left:17%;">This control sets the digest
length for extendable output functions to <i>p1</i>. Sending
this control directly should not be necessary, the use of
<b>EVP_DigestFinalXOF()</b> is preferred. Currently used by
<small>SHAKE.</small></p>

<p style="margin-left:17%; margin-top: 1em">When used with
a fetched <b><small>EVP_MD</small></b> ,
<b>EVP_MD_CTX_get_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;xoflen&quot; (
<b><small>OSSL_DIGEST_PARAM_XOFLEN</small></b> ).</p>

<h2>FLAGS
<a name="FLAGS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_MD_CTX_set_flags()</b>,
<b>EVP_MD_CTX_clear_flags()</b> and
<b>EVP_MD_CTX_test_flags()</b> can be used the manipulate
and test these <b><small>EVP_MD_CTX</small></b> flags:
<small><br>
EVP_MD_CTX_FLAG_ONESHOT</small></p>

<p style="margin-left:17%;">This flag instructs the digest
to optimize for one update only, if possible.</p>


<p style="margin-left:11%;"><small>EVP_MD_CTX_FLAG_NO_INIT</small></p>

<p style="margin-left:17%;">This flag instructs
<b>EVP_DigestInit()</b> and similar not to initialise the
implementation specific data.</p>


<p style="margin-left:11%;"><small>EVP_MD_CTX_FLAG_FINALISE</small></p>

<p style="margin-left:17%;">Some functions such as
EVP_DigestSign only finalise copies of internal contexts so
additional data can be included after the finalisation call.
This is inefficient if this functionality is not required,
and can be disabled with this flag.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_MD_fetch()</b></p>

<p style="margin-left:17%;">Returns a pointer to a
<b><small>EVP_MD</small></b> for success or
<small>NULL</small> for failure.</p>

<p style="margin-left:11%;"><b>EVP_MD_up_ref()</b></p>

<p style="margin-left:17%;">Returns 1 for success or 0 for
failure.</p>

<p style="margin-left:11%;"><b>EVP_Q_digest()</b>,
<b>EVP_Digest()</b>, <b>EVP_DigestInit_ex2()</b>, <b><br>
EVP_DigestInit_ex()</b>, <b>EVP_DigestInit()</b>,
<b>EVP_DigestUpdate()</b>, <b><br>
EVP_DigestFinal_ex()</b>, <b>EVP_DigestFinalXOF()</b>, and
<b>EVP_DigestFinal()</b></p>

<p style="margin-left:17%;">return 1 for success and 0 for
failure.</p>

<p style="margin-left:11%;"><b>EVP_MD_CTX_ctrl()</b></p>

<p style="margin-left:17%;">Returns 1 if successful or 0
for failure.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_set_params()</b>,
<b>EVP_MD_CTX_get_params()</b></p>

<p style="margin-left:17%;">Returns 1 if successful or 0
for failure.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_settable_params()</b>,
<b>EVP_MD_CTX_gettable_params()</b></p>

<p style="margin-left:17%;">Return an array of constant
<b><small>OSSL_PARAM</small></b> (3)s, or
<small>NULL</small> if there is none to get.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_copy_ex()</b></p>

<p style="margin-left:17%;">Returns 1 if successful or 0
for failure.</p>

<p style="margin-left:11%;"><b>EVP_MD_get_type()</b>,
<b>EVP_MD_get_pkey_type()</b></p>

<p style="margin-left:17%;">Returns the <small>NID</small>
of the corresponding <small>OBJECT IDENTIFIER</small> or
NID_undef if none exists.</p>

<p style="margin-left:11%;"><b>EVP_MD_get_size()</b>,
<b>EVP_MD_get_block_size()</b>,
<b>EVP_MD_CTX_get_size()</b>, <b><br>
EVP_MD_CTX_get_block_size()</b></p>

<p style="margin-left:17%;">Returns the digest or block
size in bytes or &minus;1 for failure.</p>

<p style="margin-left:11%;"><b>EVP_md_null()</b></p>

<p style="margin-left:17%;">Returns a pointer to the
<b><small>EVP_MD</small></b> structure of the
&quot;null&quot; message digest.</p>

<p style="margin-left:11%;"><b>EVP_get_digestbyname()</b>,
<b>EVP_get_digestbynid()</b>,
<b>EVP_get_digestbyobj()</b></p>

<p style="margin-left:17%;">Returns either an
<b><small>EVP_MD</small></b> structure or
<small>NULL</small> if an error occurs.</p>


<p style="margin-left:11%;"><b>EVP_MD_CTX_set_pkey_ctx()</b></p>

<p style="margin-left:17%;">This function has no return
value.</p>


<p style="margin-left:11%;"><b>EVP_MD_names_do_all()</b></p>

<p style="margin-left:17%;">Returns 1 if the callback was
called for all names. A return value of 0 means that the
callback was not called for any names.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b><small>EVP</small></b> interface to message digests
should almost always be used in preference to the low-level
interfaces. This is because the code then becomes
transparent to the digest used and much more flexible.</p>

<p style="margin-left:11%; margin-top: 1em">New
applications should use the <small>SHA&minus;2</small> (such
as <b>EVP_sha256</b>(3)) or the <small>SHA&minus;3</small>
digest algorithms (such as <b>EVP_sha3_512</b>(3)). The
other digest algorithms are still in common use.</p>

<p style="margin-left:11%; margin-top: 1em">For most
applications the <i>impl</i> parameter to
<b>EVP_DigestInit_ex()</b> will be set to
<small>NULL</small> to use the default digest
implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Ignoring
failure returns of <b>EVP_DigestInit_ex()</b>,
<b>EVP_DigestInit_ex2()</b>, or <b>EVP_DigestInit()</b> can
lead to undefined behavior on subsequent calls updating or
finalizing the <b><small>EVP_MD_CTX</small></b> such as the
<b>EVP_DigestUpdate()</b> or <b>EVP_DigestFinal()</b>
functions. The only valid calls on the
<b><small>EVP_MD_CTX</small></b> when initialization fails
are calls that attempt another initialization of the context
or release the context.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>EVP_DigestInit()</b>, <b>EVP_DigestFinal()</b> and
<b>EVP_MD_CTX_copy()</b> are obsolete but are retained to
maintain compatibility with existing code. New applications
should use <b>EVP_DigestInit_ex()</b>,
<b>EVP_DigestFinal_ex()</b> and <b>EVP_MD_CTX_copy_ex()</b>
because they can efficiently reuse a digest context instead
of initializing and cleaning it up on each call and allow
non default implementations of digests to be specified.</p>

<p style="margin-left:11%; margin-top: 1em">If digest
contexts are not cleaned up after use, memory leaks will
occur.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_MD_CTX_get0_name()</b>,
<b>EVP_MD_CTX_get_size()</b>,
<b>EVP_MD_CTX_get_block_size()</b>,
<b>EVP_MD_CTX_get_type()</b>, <b>EVP_get_digestbynid()</b>
and <b>EVP_get_digestbyobj()</b> are defined as macros.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_MD_CTX_ctrl()</b>
sends commands to message digests for additional
configuration or control.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This example
digests the data &quot;Test Message\n&quot; and &quot;Hello
World\n&quot;, using the digest name passed on the command
line.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;string.h&gt; <br>
#include &lt;openssl/evp.h&gt; <br>
int main(int argc, char *argv[]) <br>
{ <br>
EVP_MD_CTX *mdctx; <br>
const EVP_MD *md; <br>
char mess1[] = &quot;Test Message\n&quot;; <br>
char mess2[] = &quot;Hello World\n&quot;; <br>
unsigned char md_value[EVP_MAX_MD_SIZE]; <br>
unsigned int md_len, i; <br>
if (argv[1] == NULL) { <br>
printf(&quot;Usage: mdtest digestname\n&quot;); <br>
exit(1); <br>
} <br>
md = EVP_get_digestbyname(argv[1]); <br>
if (md == NULL) { <br>
printf(&quot;Unknown message digest %s\n&quot;, argv[1]);
<br>
exit(1); <br>
} <br>
mdctx = EVP_MD_CTX_new(); <br>
if (!EVP_DigestInit_ex2(mdctx, md, NULL)) { <br>
printf(&quot;Message digest initialization failed.\n&quot;);
<br>
EVP_MD_CTX_free(mdctx); <br>
exit(1); <br>
} <br>
if (!EVP_DigestUpdate(mdctx, mess1, strlen(mess1))) { <br>
printf(&quot;Message digest update failed.\n&quot;); <br>
EVP_MD_CTX_free(mdctx); <br>
exit(1); <br>
} <br>
if (!EVP_DigestUpdate(mdctx, mess2, strlen(mess2))) { <br>
printf(&quot;Message digest update failed.\n&quot;); <br>
EVP_MD_CTX_free(mdctx); <br>
exit(1); <br>
} <br>
if (!EVP_DigestFinal_ex(mdctx, md_value, &amp;md_len)) {
<br>
printf(&quot;Message digest finalization failed.\n&quot;);
<br>
EVP_MD_CTX_free(mdctx); <br>
exit(1); <br>
} <br>
EVP_MD_CTX_free(mdctx); <br>
printf(&quot;Digest is: &quot;); <br>
for (i = 0; i &lt; md_len; i++) <br>
printf(&quot;%02x&quot;, md_value[i]); <br>
printf(&quot;\n&quot;); <br>
exit(0); <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_MD_meth_new</b>(3),
<b>openssl&minus;dgst</b>(1), <b>evp</b>(7),
<b><small>OSSL_PROVIDER</small></b> (3),
<b><small>OSSL_PARAM</small></b> (3), <b>property</b>(7),
&quot; <small>ALGORITHM FETCHING&quot;</small> in
<b>crypto</b>(7), <b>provider&minus;digest</b>(7),
<b>life_cycle&minus;digest</b>(7)</p>

<p style="margin-left:11%; margin-top: 1em">The full list
of digest algorithms are provided below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_blake2b512</b>(3),
<b>EVP_md2</b>(3), <b>EVP_md4</b>(3), <b>EVP_md5</b>(3),
<b>EVP_mdc2</b>(3), <b>EVP_ripemd160</b>(3),
<b>EVP_sha1</b>(3), <b>EVP_sha224</b>(3),
<b>EVP_sha3_224</b>(3), <b>EVP_sm3</b>(3),
<b>EVP_whirlpool</b>(3)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_MD_CTX_create()</b> and <b>EVP_MD_CTX_destroy()</b>
functions were renamed to <b>EVP_MD_CTX_new()</b> and
<b>EVP_MD_CTX_free()</b> in OpenSSL 1.1.0, respectively.</p>

<p style="margin-left:11%; margin-top: 1em">The link
between digests and signing algorithms was fixed in OpenSSL
1.0 and later, so now <b>EVP_sha1()</b> can be used with
<small>RSA</small> and <small>DSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_dss1()</b> function was removed in OpenSSL 1.1.0.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_MD_CTX_set_pkey_ctx()</b> function was added in
OpenSSL 1.1.1.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_Q_digest()</b>, <b>EVP_DigestInit_ex2()</b>,
<b>EVP_MD_fetch()</b>, <b>EVP_MD_free()</b>,
<b>EVP_MD_up_ref()</b>, <b>EVP_MD_get_params()</b>,
<b>EVP_MD_CTX_set_params()</b>,
<b>EVP_MD_CTX_get_params()</b>,
<b>EVP_MD_gettable_params()</b>,
<b>EVP_MD_gettable_ctx_params()</b>,
<b>EVP_MD_settable_ctx_params()</b>,
<b>EVP_MD_CTX_settable_params()</b> and
<b>EVP_MD_CTX_gettable_params()</b> functions were added in
OpenSSL 3.0.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_MD_type()</b>, <b>EVP_MD_nid()</b>,
<b>EVP_MD_name()</b>, <b>EVP_MD_pkey_type()</b>,
<b>EVP_MD_size()</b>, <b>EVP_MD_block_size()</b>,
<b>EVP_MD_flags()</b>, <b>EVP_MD_CTX_size()</b>,
<b>EVP_MD_CTX_block_size()</b>, <b>EVP_MD_CTX_type()</b>,
and <b>EVP_MD_CTX_md_data()</b> functions were renamed to
include &quot;get&quot; or &quot;get0&quot; in their names
in OpenSSL 3.0, respectively. The old names are kept as
non-deprecated alias macros.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_MD_CTX_md()</b> function was deprecated in OpenSSL
3.0; use <b>EVP_MD_CTX_get0_md()</b> instead.
<b>EVP_MD_CTX_update_fn()</b> and
<b>EVP_MD_CTX_set_update_fn()</b> were deprecated in OpenSSL
3.0.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2000&minus;2023 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
