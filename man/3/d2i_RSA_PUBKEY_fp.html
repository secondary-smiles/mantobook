<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:33 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>D2I_RSAPRIVATEKEY</title>

</head>
<body>
<h1>d2i_RSA_PUBKEY_fp</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">d2i_DSAPrivateKey,
d2i_DSAPrivateKey_bio, d2i_DSAPrivateKey_fp,
d2i_DSAPublicKey, d2i_DSA_PUBKEY, d2i_DSA_PUBKEY_bio,
d2i_DSA_PUBKEY_fp, d2i_DSAparams, d2i_RSAPrivateKey,
d2i_RSAPrivateKey_bio, d2i_RSAPrivateKey_fp,
d2i_RSAPublicKey, d2i_RSAPublicKey_bio, d2i_RSAPublicKey_fp,
d2i_RSA_PUBKEY, d2i_RSA_PUBKEY_bio, d2i_RSA_PUBKEY_fp,
d2i_DHparams, d2i_DHparams_bio, d2i_DHparams_fp,
d2i_ECPKParameters, d2i_ECParameters, d2i_ECPrivateKey,
d2i_ECPrivateKey_bio, d2i_ECPrivateKey_fp, d2i_EC_PUBKEY,
d2i_EC_PUBKEY_bio, d2i_EC_PUBKEY_fp, i2d_RSAPrivateKey,
i2d_RSAPrivateKey_bio, i2d_RSAPrivateKey_fp,
i2d_RSAPublicKey, i2d_RSAPublicKey_bio, i2d_RSAPublicKey_fp,
i2d_RSA_PUBKEY, i2d_RSA_PUBKEY_bio, i2d_RSA_PUBKEY_fp,
i2d_DHparams, i2d_DHparams_bio, i2d_DHparams_fp,
i2d_DSAPrivateKey, i2d_DSAPrivateKey_bio,
i2d_DSAPrivateKey_fp, i2d_DSAPublicKey, i2d_DSA_PUBKEY,
i2d_DSA_PUBKEY_bio, i2d_DSA_PUBKEY_fp, i2d_DSAparams,
i2d_ECPKParameters, i2d_ECParameters, i2d_ECPrivateKey,
i2d_ECPrivateKey_bio, i2d_ECPrivateKey_fp, i2d_EC_PUBKEY,
i2d_EC_PUBKEY_bio, i2d_EC_PUBKEY_fp &minus; DEPRECATED</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining
<b><small>OPENSSL_API_COMPAT</small></b> with a suitable
version value, see <b>openssl_user_macros</b>(7):</p>

<p style="margin-left:11%; margin-top: 1em">TYPE
*d2i_TYPEPrivateKey(TYPE **a, const unsigned char **ppin,
long length); <br>
TYPE *d2i_TYPEPrivateKey_bio(BIO *bp, TYPE **a); <br>
TYPE *d2i_TYPEPrivateKey_fp(FILE *fp, TYPE **a); <br>
TYPE *d2i_TYPEPublicKey(TYPE **a, const unsigned char
**ppin, long length); <br>
TYPE *d2i_TYPEPublicKey_bio(BIO *bp, TYPE **a); <br>
TYPE *d2i_TYPEPublicKey_fp(FILE *fp, TYPE **a); <br>
TYPE *d2i_TYPEparams(TYPE **a, const unsigned char **ppin,
long length); <br>
TYPE *d2i_TYPEparams_bio(BIO *bp, TYPE **a); <br>
TYPE *d2i_TYPEparams_fp(FILE *fp, TYPE **a); <br>
TYPE *d2i_TYPE_PUBKEY(TYPE **a, const unsigned char **ppin,
long length); <br>
TYPE *d2i_TYPE_PUBKEY_bio(BIO *bp, TYPE **a); <br>
TYPE *d2i_TYPE_PUBKEY_fp(FILE *fp, TYPE **a); <br>
int i2d_TYPEPrivateKey(const TYPE *a, unsigned char
**ppout); <br>
int i2d_TYPEPrivateKey(TYPE *a, unsigned char **ppout); <br>
int i2d_TYPEPrivateKey_fp(FILE *fp, const TYPE *a); <br>
int i2d_TYPEPrivateKey_fp(FILE *fp, TYPE *a); <br>
int i2d_TYPEPrivateKey_bio(BIO *bp, const TYPE *a); <br>
int i2d_TYPEPrivateKey_bio(BIO *bp, TYPE *a); <br>
int i2d_TYPEPublicKey(const TYPE *a, unsigned char **ppout);
<br>
int i2d_TYPEPublicKey(TYPE *a, unsigned char **ppout); <br>
int i2d_TYPEPublicKey_fp(FILE *fp, const TYPE *a); <br>
int i2d_TYPEPublicKey_fp(FILE *fp, TYPE *a); <br>
int i2d_TYPEPublicKey_bio(BIO *bp, const TYPE *a); <br>
int i2d_TYPEPublicKey_bio(BIO *bp, TYPE *a); <br>
int i2d_TYPEparams(const TYPE *a, unsigned char **ppout);
<br>
int i2d_TYPEparams(TYPE *a, unsigned char **ppout); <br>
int i2d_TYPEparams_fp(FILE *fp, const TYPE *a); <br>
int i2d_TYPEparams_fp(FILE *fp, TYPE *a); <br>
int i2d_TYPEparams_bio(BIO *bp, const TYPE *a); <br>
int i2d_TYPEparams_bio(BIO *bp, TYPE *a); <br>
int i2d_TYPE_PUBKEY(const TYPE *a, unsigned char **ppout);
<br>
int i2d_TYPE_PUBKEY(TYPE *a, unsigned char **ppout); <br>
int i2d_TYPE_PUBKEY_fp(FILE *fp, const TYPE *a); <br>
int i2d_TYPE_PUBKEY_fp(FILE *fp, TYPE *a); <br>
int i2d_TYPE_PUBKEY_bio(BIO *bp, const TYPE *a); <br>
int i2d_TYPE_PUBKEY_bio(BIO *bp, TYPE *a);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All functions
described here are deprecated. Please use
<b><small>OSSL_DECODER</small></b> (3) instead of the
<b>d2i</b> functions and <b><small>OSSL_ENCODER</small></b>
(3) instead of the <b>i2d</b> functions. See
&quot;Migration&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em">In the
description here, <b><i><small>TYPE</small></i></b> is used
a placeholder for any of the OpenSSL datatypes, such as
<b><small>RSA</small></b> . The function parameters
<i>ppin</i> and <i>ppout</i> are generally either both named
<i>pp</i> in the headers, or <i>in</i> and <i>out</i>.</p>

<p style="margin-left:11%; margin-top: 1em">All the
functions here behave the way that&rsquo;s described in
<b>d2i_X509</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that not all functions in the synopsis are available for all
key types. For example, there are no <b>d2i_RSAparams()</b>
or <b>i2d_RSAparams()</b>, because the PKCS#1
<b><small>RSA</small></b> structure doesn&rsquo;t include
any key parameters.</p>

<p style="margin-left:11%; margin-top: 1em"><b>d2i_</b>
<b><i><small>TYPE</small></i></b> <b>PrivateKey</b>() and
derivates thereof decode <small>DER</small> encoded
<b><i><small>TYPE</small></i></b> private key data organized
in a type specific structure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>d2i_</b>
<b><i><small>TYPE</small></i></b> <b>PublicKey</b>() and
derivates thereof decode <small>DER</small> encoded
<b><i><small>TYPE</small></i></b> public key data organized
in a type specific structure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>d2i_</b>
<b><i><small>TYPE</small></i></b> <b>params</b>() and
derivates thereof decode <small>DER</small> encoded
<b><i><small>TYPE</small></i></b> key parameters organized
in a type specific structure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>d2i_</b>
<b><i><small>TYPE</small></i></b> <b>_PUBKEY</b>() and
derivates thereof decode <small>DER</small> encoded
<b><i><small>TYPE</small></i></b> public key data organized
in a <b>SubjectPublicKeyInfo</b> structure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> <b>PrivateKey</b>() and
derivates thereof encode the private key
<b><i><small>TYPE</small></i></b> data into a type specific
<small>DER</small> encoded structure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> <b>PublicKey</b>() and
derivates thereof encode the public key
<b><i><small>TYPE</small></i></b> data into a type specific
<small>DER</small> encoded structure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> <b>params</b>() and
derivates thereof encode the
<b><i><small>TYPE</small></i></b> key parameters data into a
type specific <small>DER</small> encoded structure.</p>

<p style="margin-left:11%; margin-top: 1em"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> <b>_PUBKEY</b>() and
derivates thereof encode the public key
<b><i><small>TYPE</small></i></b> data into a
<small>DER</small> encoded <b>SubjectPublicKeyInfo</b>
structure.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
<b>d2i_RSAPrivateKey()</b> and <b>d2i_RSAPublicKey()</b>
expects the structure defined by PKCS#1. Similarly,
<b>i2d_RSAPrivateKey()</b> and <b>i2d_RSAPublicKey()</b>
produce <small>DER</small> encoded string organized
according to PKCS#1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Migration</b>
<br>
Migration from the diverse <b><i><small>TYPE</small></i></b>
s requires using corresponding new OpenSSL types. For all
<b><i><small>TYPE</small></i></b> s described here, the
corresponding new type is <b><small>EVP_PKEY</small></b> .
The rest of this section assumes that this has been done,
exactly how to do that is described elsewhere.</p>

<p style="margin-left:11%; margin-top: 1em">There are two
migration paths:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Replace b&lt;d2i_ <i><small>TYPE</small></i>
<b>PrivateKey()</b>&gt; with <b>d2i_PrivateKey</b>(3),
b&lt;d2i_ <i><small>TYPE</small></i> <b>PublicKey()</b>&gt;
with <b>d2i_PublicKey</b>(3), b&lt;d2i_
<i><small>TYPE</small></i> <b>params()</b>&gt; with
<b>d2i_KeyParams</b>(3), b&lt;d2i_
<i><small>TYPE</small></i> <b>_PUBKEY()</b>&gt; with
<b>d2i_PUBKEY</b>(3), b&lt;i2d_ <i><small>TYPE</small></i>
<b>PrivateKey()</b>&gt; with <b>i2d_PrivateKey</b>(3),
b&lt;i2d_ <i><small>TYPE</small></i> <b>PublicKey()</b>&gt;
with <b>i2d_PublicKey</b>(3), b&lt;i2d_
<i><small>TYPE</small></i> <b>params()</b>&gt; with
<b>i2d_KeyParams</b>(3), b&lt;i2d_
<i><small>TYPE</small></i> <b>_PUBKEY()</b>&gt; with
<b>i2d_PUBKEY</b>(3). A caveat is that
<b>i2d_PrivateKey</b>(3) may output a <small>DER</small>
encoded PKCS#8 outermost structure instead of the type
specific structure, and that <b>d2i_PrivateKey</b>(3)
recognises and unpacks a PKCS#8 structures.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Use <b><small>OSSL_DECODER</small></b> (3) and
<b><small>OSSL_ENCODER</small></b> (3). How to migrate is
described below. All those descriptions assume that the key
to be encoded is in the variable <i>pkey</i>.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><i>Migrating</i>
<b><i>i2d</i></b> <i>functions to</i>
<b><i><small>OSSL_ENCODER</small></i></b></p>

<p style="margin-left:11%; margin-top: 1em">The exact
<b><small>OSSL_ENCODER</small></b> (3) output is driven by
arguments rather than by function names. The sample code to
get <small>DER</small> encoded output in a type specific
structure is uniform, the only things that vary are the
selection of what part of the <b><small>EVP_PKEY</small></b>
should be output, and the structure. The <b>i2d</b>
functions names can therefore be translated into two
variables, <i>selection</i> and <i>structure</i> as follows:
<b><br>
i2d_</b> <b><i><small>TYPE</small></i></b>
<b>PrivateKey</b>() translates into:</p>

<p style="margin-left:17%;">int selection =
EVP_PKEY_PRIVATE_KEY; <br>
const char *structure = &quot;type&minus;specific&quot;;</p>

<p style="margin-left:11%;"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> <b>PublicKey</b>()
translates into:</p>

<p style="margin-left:17%;">int selection =
EVP_PKEY_PUBLIC_KEY; <br>
const char *structure = &quot;type&minus;specific&quot;;</p>

<p style="margin-left:11%;"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> <b>params</b>() translates
into:</p>

<p style="margin-left:17%;">int selection =
EVP_PKEY_PARAMETERS; <br>
const char *structure = &quot;type&minus;specific&quot;;</p>

<p style="margin-left:11%;"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> <b>_PUBKEY</b>()
translates into:</p>

<p style="margin-left:17%;">int selection =
EVP_PKEY_PUBLIC_KEY; <br>
const char *structure =
&quot;SubjectPublicKeyInfo&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">The following
sample code does the rest of the work:</p>

<p style="margin-left:11%; margin-top: 1em">unsigned char
*p = buffer; /* |buffer| is supplied by the caller */ <br>
size_t len = buffer_size; /* assumed be the size of |buffer|
*/ <br>
OSSL_ENCODER_CTX *ctx = <br>
OSSL_ENCODER_CTX_new_for_pkey(pkey, selection,
&quot;DER&quot;, structure, <br>
NULL, NULL); <br>
if (ctx == NULL) { <br>
/* fatal error handling */ <br>
} <br>
if (OSSL_ENCODER_CTX_get_num_encoders(ctx) == 0) { <br>
OSSL_ENCODER_CTX_free(ctx); <br>
/* non&minus;fatal error handling */ <br>
} <br>
if (!OSSL_ENCODER_to_data(ctx, &amp;p, &amp;len)) { <br>
OSSL_ENCODER_CTX_free(ctx); <br>
/* error handling */ <br>
} <br>
OSSL_ENCODER_CTX_free(ctx);</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The letters
<b>i</b> and <b>d</b> in <b>i2d_</b>
<b><i><small>TYPE</small></i></b> () stand for
&quot;internal&quot; (that is, an internal C structure) and
&quot; <small>DER&quot;</small> respectively. So <b>i2d_</b>
<b><i><small>TYPE</small></i></b> () converts from internal
to <small>DER.</small></p>

<p style="margin-left:11%; margin-top: 1em">The functions
can also understand <b><small>BER</small></b> forms.</p>

<p style="margin-left:11%; margin-top: 1em">The actual
<small>TYPE</small> structure passed to <b>i2d_</b>
<b><i><small>TYPE</small></i></b> () must be a valid
populated <b><i><small>TYPE</small></i></b> structure -- it
<b>cannot</b> simply be fed with an empty structure such as
that returned by <b>TYPE_new()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The encoded
data is in binary form and may contain embedded zeros.
Therefore, any <small>FILE</small> pointers or BIOs should
be opened in binary mode. Functions such as <b>strlen()</b>
will <b>not</b> return the correct length of the encoded
structure.</p>

<p style="margin-left:11%; margin-top: 1em">The ways that
<i>*ppin</i> and <i>*ppout</i> are incremented after the
operation can trap the unwary. See the
<b><small>WARNINGS</small></b> section in <b>d2i_X509</b>(3)
for some common errors. The reason for this-auto increment
behaviour is to reflect a typical usage of
<small>ASN1</small> functions: after one structure is
encoded or decoded another will be processed after it.</p>

<p style="margin-left:11%; margin-top: 1em">The following
points about the data types might be useful: <b><small><br>
DSA_PUBKEY</small></b></p>

<p style="margin-left:17%;">Represents a <small>DSA</small>
public key using a <b>SubjectPublicKeyInfo</b>
structure.</p>

<p style="margin-left:11%;"><b>DSAPublicKey</b>,
<b>DSAPrivateKey</b></p>

<p style="margin-left:17%;">Use a non-standard OpenSSL
format and should be avoided; use
<b><small>DSA_PUBKEY</small></b> ,
<b>PEM_write_PrivateKey</b>(3), or similar instead.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>d2i_</b>
<b><i><small>TYPE</small></i></b> (), <b>d2i_</b>
<b><i><small>TYPE</small></i></b> <b>_bio</b>() and
<b>d2i_</b> <b><i><small>TYPE</small></i></b> <b>_fp</b>()
return a valid <b><i><small>TYPE</small></i></b> structure
or <small>NULL</small> if an error occurs. If the
&quot;reuse&quot; capability has been used with a valid
structure being passed in via <i>a</i>, then the object is
freed in the event of error and <i>*a</i> is set to
<small>NULL.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> () returns the number of
bytes successfully encoded or a negative value if an error
occurs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>i2d_</b>
<b><i><small>TYPE</small></i></b> <b>_bio</b>() and
<b>i2d_</b> <b><i><small>TYPE</small></i></b> <b>_fp</b>()
return 1 for success and 0 if an error occurs.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>OSSL_ENCODER</small></b>
(3), <b><small>OSSL_DECODER</small></b> (3),
<b>d2i_PrivateKey</b>(3), <b>d2i_PublicKey</b>(3),
<b>d2i_KeyParams</b>(3), <b>d2i_PUBKEY</b>(3),
<b>i2d_PrivateKey</b>(3), <b>i2d_PublicKey</b>(3),
<b>i2d_KeyParams</b>(3), <b>i2d_PUBKEY</b>(3)</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2020&minus;2021 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
