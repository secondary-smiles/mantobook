<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:11 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::auto_ptr&lt; _Tp &gt;</title>

</head>
<body>
<h1>std::auto_ptr</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::auto_ptr&lt;
_Tp &gt; &minus; A simple smart pointer providing strict
ownership semantics.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;memory&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Tp <b>element_type</b>
<br>
The pointed-to type.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>auto_ptr</b>
(<b>auto_ptr</b> &amp;__a) throw () <br>
An auto_ptr can be constructed from another auto_ptr. <br>
template&lt;typename _Tp1 &gt; <b>auto_ptr</b>
(<b>auto_ptr</b>&lt; _Tp1 &gt; &amp;__a) throw () <br>
An auto_ptr can be constructed from another auto_ptr.
<b><br>
auto_ptr</b> (<b>auto_ptr_ref</b>&lt; <b>element_type</b>
&gt; __ref) throw () <br>
Automatic conversions. <b><br>
auto_ptr</b> (<b>element_type</b> *__p=0) throw () <br>
An auto_ptr is usually constructed from a raw pointer.
<b><br>
~auto_ptr</b> () <b><br>
element_type</b> * <b>get</b> () const throw () <br>
Bypassing the smart pointer. <br>
template&lt;typename _Tp1 &gt; <b>operator auto_ptr&lt; _Tp1
&gt;</b> () throw () <br>
template&lt;typename _Tp1 &gt; <b>operator auto_ptr_ref&lt;
_Tp1 &gt;</b> () throw () <b><br>
element_type</b> &amp; <b>operator*</b> () const throw ()
<br>
Smart pointer dereferencing. <b><br>
element_type</b> * <b>operator&minus;&gt;</b> () const throw
() <br>
Smart pointer dereferencing. <b><br>
auto_ptr</b> &amp; <b>operator=</b> (<b>auto_ptr</b>
&amp;__a) throw () <br>
auto_ptr assignment operator. <br>
template&lt;typename _Tp1 &gt; <b>auto_ptr</b> &amp;
<b>operator=</b> (<b>auto_ptr</b>&lt; _Tp1 &gt; &amp;__a)
throw () <br>
auto_ptr assignment operator. <b><br>
auto_ptr</b> &amp; <b>operator=</b> (<b>auto_ptr_ref</b>&lt;
<b>element_type</b> &gt; __ref) throw () <b><br>
element_type</b> * <b>release</b> () throw () <br>
Bypassing the smart pointer. <br>
void <b>reset</b> (<b>element_type</b> *__p=0) throw () <br>
Forcibly deletes the managed object.</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt;</b> <br>
class std::auto_ptr&lt; _Tp &gt;&quot;A simple smart pointer
providing strict ownership semantics.</p>

<p style="margin-left:11%; margin-top: 1em">The Standard
says:</p>

<p style="margin-left:11%; margin-top: 1em">An
<tt>auto_ptr</tt> owns the object it holds a pointer to.
Copying <br>
an <tt>auto_ptr</tt> copies the pointer and transfers
ownership to the <br>
destination. If more than one <tt>auto_ptr</tt> owns the
same object <br>
at the same time the behavior of the program is
undefined.</p>

<p style="margin-left:11%; margin-top: 1em">The uses of
<tt>auto_ptr</tt> include providing temporary <br>
exception-safety for dynamically allocated memory, passing
<br>
ownership of dynamically allocated memory to a function, and
<br>
returning dynamically allocated memory from a function.
<tt>auto_ptr</tt> does not meet the CopyConstructible and
Assignable <br>
requirements for Standard Library <tt>container</tt>
elements and thus <br>
instantiating a Standard Library container with an
<tt>auto_ptr</tt> results in undefined behavior.</p>

<p style="margin-left:11%; margin-top: 1em">Quoted from
[20.4.5]/3.</p>

<p style="margin-left:11%; margin-top: 1em">Good examples
of what can and cannot be done with auto_ptr can be found in
the libstdc++ testsuite.</p>


<p style="margin-left:11%; margin-top: 1em">_GLIBCXX_RESOLVE_LIB_DEFECTS
<br>
127.</p>

<p style="margin-left:17%;">auto_ptr&lt;&gt; conversion
issues These resolutions have all been incorporated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Deprecated</b></p>

<p style="margin-left:17%;">Deprecated in C++11, no longer
in the standard since C++17. Use <tt>unique_ptr</tt>
instead.</p>

<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; typedef _Tp std::auto_ptr&lt; _Tp
&gt;::element_type</b> <br>
The pointed-to type.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; std::auto_ptr&lt; _Tp &gt;::auto_ptr (element_type
* __p =</b> <tt>0</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
An auto_ptr is usually constructed from a raw pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer (defaults
to NULL).</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object pointed to by <i>__p</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; std::auto_ptr&lt; _Tp &gt;::auto_ptr (auto_ptr&lt;
_Tp &gt; &amp; __a)</b> <tt>[inline]</tt> <br>
An auto_ptr can be constructed from another auto_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> Another auto_ptr of
the same type.</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object previously owned by <i>__a</i>, which
has given up ownership.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Tp1 &gt; std::auto_ptr&lt;
_Tp &gt;::auto_ptr (auto_ptr&lt; _Tp1 &gt; &amp; __a)</b>
<tt>[inline]</tt> <br>
An auto_ptr can be constructed from another auto_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> Another auto_ptr of
a different but related type.</p>

<p style="margin-left:11%; margin-top: 1em">A
pointer-to-Tp1 must be convertible to a
pointer-to-Tp/element_type.</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object previously owned by <i>__a</i>, which
has given up ownership.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; std::auto_ptr&lt; _Tp &gt;::~auto_ptr ()</b>
<tt>[inline]</tt> <br>
When the auto_ptr goes out of scope, the object it owns is
deleted. If it no longer owns anything (i.e., <tt>get()</tt>
is <tt>NULL</tt>), then this has no effect.</p>

<p style="margin-left:11%; margin-top: 1em">The C++
standard says there is supposed to be an empty throw
specification here, but omitting it is standard conforming.
Its presence can be detected only if _Tp::~_Tp() throws, but
this is prohibited. [17.4.3.6]/2</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; std::auto_ptr&lt; _Tp &gt;::auto_ptr
(auto_ptr_ref&lt; element_type &gt; __ref)</b>
<tt>[inline]</tt> <br>
Automatic conversions. These operations are supposed to
convert an auto_ptr into and from an auto_ptr_ref
automatically as needed. This would allow constructs such
as</p>


<p style="margin-left:11%; margin-top: 1em">auto_ptr&lt;Derived&gt;
func_returning_auto_ptr(.....); <br>
... <br>
auto_ptr&lt;Base&gt; ptr =
func_returning_auto_ptr(.....);</p>

<p style="margin-left:11%; margin-top: 1em">But it
doesn&rsquo;t work, and won&rsquo;t be fixed. For further
details see
http://cplusplus.github.io/LWG/lwg-closed.html#463</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; element_type * std::auto_ptr&lt; _Tp &gt;::get ()
const</b> <tt>[inline]</tt> <br>
Bypassing the smart pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The raw pointer being
managed.</p>

<p style="margin-left:11%; margin-top: 1em">You can get a
copy of the pointer that this object owns, for situations
such as passing to a function which only accepts a raw
pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">This auto_ptr still owns the
memory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; element_type &amp; std::auto_ptr&lt; _Tp
&gt;::operator* () const</b> <tt>[inline]</tt> <br>
Smart pointer dereferencing. If this auto_ptr no longer owns
anything, then this operation will crash. (For a smart
pointer, <i>no longer owns anything</i> is the same as being
a null pointer, and you know what happens when you
dereference one of those...)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; element_type * std::auto_ptr&lt; _Tp
&gt;::operator&minus;&gt; () const</b> <tt>[inline]</tt>
<br>
Smart pointer dereferencing. This returns the pointer
itself, which the language then will automatically cause to
be dereferenced.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; auto_ptr &amp; std::auto_ptr&lt; _Tp
&gt;::operator= (auto_ptr&lt; _Tp &gt; &amp; __a)</b>
<tt>[inline]</tt> <br>
auto_ptr assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> Another auto_ptr of
the same type.</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object previously owned by <i>__a</i>, which
has given up ownership. The object that this one <i>used</i>
to own and track has been deleted.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::auto_ptr&lt; _Tp &gt;::reset()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Tp1 &gt; auto_ptr &amp;
std::auto_ptr&lt; _Tp &gt;::operator= (auto_ptr&lt; _Tp1
&gt; &amp; __a)</b> <tt>[inline]</tt> <br>
auto_ptr assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> Another auto_ptr of
a different but related type.</p>

<p style="margin-left:11%; margin-top: 1em">A
pointer-to-Tp1 must be convertible to a
pointer-to-Tp/element_type.</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object previously owned by <i>__a</i>, which
has given up ownership. The object that this one <i>used</i>
to own and track has been deleted.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::auto_ptr&lt; _Tp &gt;::reset()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; element_type * std::auto_ptr&lt; _Tp &gt;::release
()</b> <tt>[inline]</tt> <br>
Bypassing the smart pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The raw pointer being
managed.</p>

<p style="margin-left:11%; margin-top: 1em">You can get a
copy of the pointer that this object owns, for situations
such as passing to a function which only accepts a raw
pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">This auto_ptr no longer owns
the memory. When this object goes out of scope, nothing will
happen.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; void std::auto_ptr&lt; _Tp &gt;::reset
(element_type * __p =</b> <tt>0</tt><b>)</b>
<tt>[inline]</tt> <br>
Forcibly deletes the managed object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer (defaults
to NULL).</p>

<p style="margin-left:11%; margin-top: 1em">This object now
<i>owns</i> the object pointed to by <i>__p</i>. The
previous object has been deleted.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::auto_ptr&lt; _Tp &gt;::operator=()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
