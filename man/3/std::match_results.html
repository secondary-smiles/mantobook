<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:13 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::match_results&lt; _Bi_iter, _Alloc &gt;</title>

</head>
<body>
<h1>std::match_results</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::match_results&lt;
_Bi_iter, _Alloc &gt; &minus; The results of a match or
search operation.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;regex&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::vector&lt; _Tp, _Alloc &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public Types
<br>
28.10 Public Types</b></p>

<p style="margin-left:23%; margin-top: 1em">typedef
<b>sub_match</b>&lt; _Bi_iter &gt; <b>value_type</b> <br>
typedef const <b>value_type</b> &amp; <b>const_reference</b>
<br>
typedef <b>value_type</b> &amp; <b>reference</b> <br>
typedef _Base_type::const_iterator <b>const_iterator</b>
<br>
typedef const_iterator <b>iterator</b> <br>
typedef __iter_traits::difference_type
<b>difference_type</b> <br>
typedef <b>allocator_traits</b>&lt; _Alloc &gt;::size_type
<b>size_type</b> <br>
typedef _Alloc <b>allocator_type</b> <br>
typedef __iter_traits::value_type <b>char_type</b> <br>
typedef <b>std::basic_string</b>&lt; char_type &gt;
<b>string_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Out_iter
&gt; _Out_iter <b>format</b> (_Out_iter __out, const
<b>match_results</b>&lt; _Bi_iter, _Alloc &gt;::char_type
*__fmt_first, const <b>match_results</b>&lt; _Bi_iter,
_Alloc &gt;::char_type *__fmt_last, <b>match_flag_type</b>
__flags) const <br>
bool <b>ready</b> () const noexcept <br>
Indicates if the match_results is ready.</p>

<p style="margin-left:11%; margin-top: 1em"><b>28.10.1
Construction, Copying, and Destruction</b></p>


<p style="margin-left:23%; margin-top: 1em"><b>match_results</b>
() <br>
Constructs a default match_results container. <b><br>
match_results</b> (const _Alloc &amp;__a) noexcept <br>
Constructs a default match_results container. <b><br>
match_results</b> (const <b>match_results</b> &amp;)=default
<br>
Copy constructs a match_results. <b><br>
match_results</b> (<b>match_results</b> &amp;&amp;)
noexcept=default <br>
Move constructs a match_results. <b><br>
match_results</b> &amp; <b>operator=</b> (const
<b>match_results</b> &amp;)=default <br>
Assigns rhs to *this. <b><br>
match_results</b> &amp; <b>operator=</b>
(<b>match_results</b> &amp;&amp;)=default <br>
Move-assigns rhs to *this. <b><br>
~match_results</b> ()=default <br>
Destroys a match_results object. <b><br>
match_results</b> (const <b>match_results</b> &amp;__m,
const _Alloc &amp;__a) <br>
Constructs a default match_results container. <b><br>
match_results</b> (<b>match_results</b> &amp;&amp;__m, const
_Alloc &amp;__a)
noexcept(noexcept(<b>_Base_type</b>(<b>std::move</b>(__m),
__a))) <br>
Constructs a default match_results container.</p>

<p style="margin-left:11%; margin-top: 1em"><b>28.10.2
Size</b></p>

<p style="margin-left:23%; margin-top: 1em">size_type
<b>size</b> () const noexcept <br>
Gets the number of matches and submatches. <br>
size_type <b>max_size</b> () const noexcept <br>
Gets the number of matches and submatches. <br>
bool <b>empty</b> () const noexcept <br>
Indicates if the match_results contains no results.</p>

<p style="margin-left:11%; margin-top: 1em"><b>28.10.4
Element Access</b></p>


<p style="margin-left:23%; margin-top: 1em">difference_type
<b>length</b> (size_type __sub=0) const <br>
Gets the length of the indicated submatch. <br>
difference_type <b>position</b> (size_type __sub=0) const
<br>
Gets the offset of the beginning of the indicated submatch.
<b><br>
string_type str</b> (size_type __sub=0) const <br>
Gets the match or submatch converted to a string type.
<b><br>
const_reference operator[]</b> (size_type __sub) const <br>
Gets a sub_match reference for the match or submatch.
<b><br>
const_reference prefix</b> () const <br>
Gets a sub_match representing the match prefix. <b><br>
const_reference suffix</b> () const <br>
Gets a sub_match representing the match suffix. <br>
const_iterator <b>begin</b> () const noexcept <br>
Gets an iterator to the start of the sub_match collection.
<br>
const_iterator <b>cbegin</b> () const noexcept <br>
Gets an iterator to the start of the sub_match collection.
<br>
const_iterator <b>end</b> () const noexcept <br>
Gets an iterator to one-past-the-end of the collection. <br>
const_iterator <b>cend</b> () const noexcept <br>
Gets an iterator to one-past-the-end of the collection.</p>

<p style="margin-left:11%; margin-top: 1em"><b>28.10.5
Formatting</b> <br>
These functions perform formatted substitution of the
matched character sequences into their target. The format
specifiers and escape sequences accepted by these functions
are determined by their <tt>flags</tt> parameter as
documented above.</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_Out_iter &gt; _Out_iter <b>format</b> (_Out_iter __out,
const char_type *__fmt_first, const char_type *__fmt_last,
<b>match_flag_type</b>
__flags=<b>regex_constants::format_default</b>) const <br>
template&lt;typename _Out_iter , typename _St , typename _Sa
&gt; _Out_iter <b>format</b> (_Out_iter __out, const
<b>basic_string</b>&lt; char_type, _St, _Sa &gt; &amp;__fmt,
<b>match_flag_type</b>
__flags=<b>regex_constants::format_default</b>) const <br>
template&lt;typename _St , typename _Sa &gt;
<b>basic_string</b>&lt; char_type, _St, _Sa &gt;
<b>format</b> (const <b>basic_string</b>&lt; char_type, _St,
_Sa &gt; &amp;__fmt, <b>match_flag_type</b>
__flags=<b>regex_constants::format_default</b>) const
<b><br>
string_type format</b> (const char_type *__fmt,
<b>match_flag_type</b>
__flags=<b>regex_constants::format_default</b>) const</p>

<p style="margin-left:11%; margin-top: 1em"><b>28.10.6
Allocator</b></p>

<p style="margin-left:23%; margin-top: 1em">allocator_type
<b>get_allocator</b> () const noexcept <br>
Gets a copy of the allocator.</p>

<p style="margin-left:11%; margin-top: 1em"><b>28.10.7
Swap</b></p>

<p style="margin-left:23%; margin-top: 1em">void
<b>swap</b> (<b>match_results</b> &amp;__that) noexcept <br>
Swaps the contents of two match_results.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Private
Member Functions</b></p>

<p style="margin-left:17%;">constexpr iterator <b>begin</b>
() noexcept <br>
constexpr iterator <b>end</b> () noexcept <br>
constexpr <b>const_reference operator[]</b> (size_type __n)
const noexcept <br>
Subscript access to the data contained in the vector. <br>
constexpr <b>reference operator[]</b> (size_type __n)
noexcept <br>
Subscript access to the data contained in the vector. <br>
constexpr void <b>swap</b> (<b>vector</b> &amp;__x) noexcept
<br>
Swaps data with another vector.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename , typename
, typename &gt; class <b>regex_iterator</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Related
Functions</b> <br>
(Note that these are not member functions.)</p>

<p style="margin-left:17%;">template&lt;typename _Bi_iter ,
class _Alloc &gt; bool <b>operator!=</b> (const
<b>match_results</b>&lt; _Bi_iter, _Alloc &gt; &amp;__m1,
const <b>match_results</b>&lt; _Bi_iter, _Alloc &gt;
&amp;__m2) <br>
Compares two match_results for inequality. <br>
template&lt;typename _Bi_iter , typename _Alloc &gt; bool
<b>operator==</b> (const <b>match_results</b>&lt; _Bi_iter,
_Alloc &gt; &amp;__m1, const <b>match_results</b>&lt;
_Bi_iter, _Alloc &gt; &amp;__m2) <br>
Compares two match_results for equality. <br>
template&lt;typename _Bi_iter , typename _Alloc &gt; void
<b>swap</b> (<b>match_results</b>&lt; _Bi_iter, _Alloc &gt;
&amp;__lhs, <b>match_results</b>&lt; _Bi_iter, _Alloc &gt;
&amp;__rhs) noexcept <br>
Swaps two match results.</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter, typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;</b> <br>
class std::match_results&lt; _Bi_iter, _Alloc &gt;&quot;The
results of a match or search operation.</p>

<p style="margin-left:11%; margin-top: 1em">A collection of
character sequences representing the result of a regular
expression match. Storage for the collection is allocated
and freed as necessary by the member functions of class
template match_results.</p>

<p style="margin-left:11%; margin-top: 1em">This class
satisfies the Sequence requirements, with the exception that
only the operations defined for a const-qualified Sequence
are supported.</p>

<p style="margin-left:11%; margin-top: 1em">The sub_match
object stored at index 0 represents sub-expression 0, i.e.
the whole match. In this case the sub_match member matched
is always true. The sub_match object stored at index n
denotes what matched the marked sub-expression n within the
matched expression. If the sub-expression n participated in
a regular expression match then the sub_match member matched
evaluates to true, and members first and second denote the
range of characters [first, second) which formed that match.
Otherwise matched is false, and members first and second
point to the end of the sequence that was searched.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++11</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::match_results
()</b> <tt>[inline]</tt> <br>
Constructs a default match_results container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">size() returns 0 and str()
returns an empty string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::match_results
(const _Alloc &amp; __a)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Constructs a default match_results container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">size() returns 0 and str()
returns an empty string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::match_results
(const match_results&lt; _Bi_iter, _Alloc &gt; &amp;)</b>
<tt>[default]</tt> <br>
Copy constructs a match_results.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::match_results
(match_results&lt; _Bi_iter, _Alloc &gt; &amp;&amp;)</b>
<tt>[default]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Move constructs a match_results.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::~match_results
()</b> <tt>[default]</tt> <br>
Destroys a match_results object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::match_results
(const match_results&lt; _Bi_iter, _Alloc &gt; &amp; __m,
const _Alloc &amp; __a)</b> <tt>[inline]</tt> <br>
Constructs a default match_results container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">size() returns 0 and str()
returns an empty string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::match_results
(match_results&lt; _Bi_iter, _Alloc &gt; &amp;&amp; __m,
const _Alloc &amp; __a)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Constructs a default match_results container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">size() returns 0 and str()
returns an empty string.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_iterator std::match_results&lt; _Bi_iter, _Alloc
&gt;::begin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Gets an iterator to the start of the sub_match
collection.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::begin()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::cbegin()</b>, and <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::operator==()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_iterator std::match_results&lt; _Bi_iter, _Alloc
&gt;::cbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Gets an iterator to the start of the sub_match
collection.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_iterator std::match_results&lt; _Bi_iter, _Alloc
&gt;::cend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Gets an iterator to one-past-the-end of the collection.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; bool
std::match_results&lt; _Bi_iter, _Alloc &gt;::empty ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Indicates if the match_results contains no results.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Return
values</b></p>

<p style="margin-left:17%;"><i>true</i> The match_results
object is empty. <i><br>
false</i> The match_results object is not empty.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator==()</b>, <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::prefix()</b>, and <b>std::match_results&lt;
_Bi_iter, _Alloc &gt;::suffix()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_iterator std::match_results&lt; _Bi_iter, _Alloc
&gt;::end () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Gets an iterator to one-past-the-end of the collection.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::empty()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::end()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc &gt;::cend()</b>,
and <b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator==()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
template&lt;typename _Out_iter , typename _St , typename _Sa
&gt; _Out_iter std::match_results&lt; _Bi_iter, _Alloc
&gt;::format (_Out_iter __out, const basic_string&lt;
char_type, _St, _Sa &gt; &amp; __fmt, match_flag_type
__flags = regex_constants::format_default) const</b>
<tt>[inline]</tt> <b><br>
Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::basic_string&lt; _CharT, _Traits, _Alloc
&gt;::data()</b>, <b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::format()</b>, and <b>std::basic_string&lt; _CharT,
_Traits, _Alloc &gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
template&lt;typename _Out_iter &gt; _Out_iter
std::match_results&lt; _Bi_iter, _Alloc &gt;::format
(_Out_iter __out, const char_type * __fmt_first, const
char_type * __fmt_last, match_flag_type __flags =
regex_constants::format_default) const <br>
Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::format()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
template&lt;typename _St , typename _Sa &gt;
basic_string&lt; char_type, _St, _Sa &gt;
std::match_results&lt; _Bi_iter, _Alloc &gt;::format (const
basic_string&lt; char_type, _St, _Sa &gt; &amp; __fmt,
match_flag_type __flags = regex_constants::format_default)
const</b> <tt>[inline]</tt> <b><br>
Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::back_inserter()</b>, and <b>std::match_results&lt;
_Bi_iter, _Alloc &gt;::format()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; string_type
std::match_results&lt; _Bi_iter, _Alloc &gt;::format (const
char_type * __fmt, match_flag_type __flags =
regex_constants::format_default) const</b> <tt>[inline]</tt>
<b><br>
Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::back_inserter()</b>, and <b>std::match_results&lt;
_Bi_iter, _Alloc &gt;::format()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
allocator_type std::match_results&lt; _Bi_iter, _Alloc
&gt;::get_allocator () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Gets a copy of the allocator.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc
&gt;::get_allocator()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
difference_type std::match_results&lt; _Bi_iter, _Alloc
&gt;::length (size_type __sub =</b> <tt>0</tt><b>) const</b>
<tt>[inline]</tt> <br>
Gets the length of the indicated submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__sub</i> indicates the
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the length of the indicated submatch, or the length
of the entire match if <tt>__sub</tt> is zero (the
default).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; size_type
std::match_results&lt; _Bi_iter, _Alloc &gt;::max_size ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Gets the number of matches and submatches. The number of
matches for a given regular expression will be either 0 if
there was no match or mark_count() + 1 if a match was
successful. Some matches may be empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the number of matches
found.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::max_size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
match_results &amp; std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator= (const match_results&lt; _Bi_iter, _Alloc
&gt; &amp;)</b> <tt>[default]</tt> <br>
Assigns rhs to *this.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
match_results &amp; std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator= (match_results&lt; _Bi_iter, _Alloc &gt;
&amp;&amp;)</b> <tt>[default]</tt> <br>
Move-assigns rhs to *this.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_reference std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator[] (size_type __sub) const</b>
<tt>[inline]</tt> <br>
Gets a sub_match reference for the match or submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__sub</i> indicates the
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
gets a reference to the indicated submatch, or the entire
match if <tt>__sub</tt> is zero.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>__sub</tt> &gt;= size() then this function returns a
sub_match with a special value indicating no submatch.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::operator[]()</b>,
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::ready()</b>, and <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
difference_type std::match_results&lt; _Bi_iter, _Alloc
&gt;::position (size_type __sub =</b> <tt>0</tt><b>)
const</b> <tt>[inline]</tt> <br>
Gets the offset of the beginning of the indicated
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__sub</i> indicates the
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the offset from the beginning of the target sequence
to the beginning of the submatch, unless the value of
<tt>__sub</tt> is zero (the default), in which case this
function returns the offset from the beginning of the target
sequence to the beginning of the match.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::distance()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_reference std::match_results&lt; _Bi_iter, _Alloc
&gt;::prefix () const</b> <tt>[inline]</tt> <br>
Gets a sub_match representing the match prefix.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
gets a reference to a sub_match object representing the part
of the target range between the start of the target range
and the start of the match.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::empty()</b>, and <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::ready()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator==()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; bool
std::match_results&lt; _Bi_iter, _Alloc &gt;::ready ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Indicates if the match_results is ready.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Return
values</b></p>

<p style="margin-left:17%;"><i>true</i> The object has a
fully-established result state. <i><br>
false</i> The object is not ready.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::empty()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator==()</b>, <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::operator[]()</b>, <b>std::match_results&lt;
_Bi_iter, _Alloc &gt;::prefix()</b>, and
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::suffix()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; size_type
std::match_results&lt; _Bi_iter, _Alloc &gt;::size ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Gets the number of matches and submatches. The number of
matches for a given regular expression will be either 0 if
there was no match or mark_count() + 1 if a match was
successful. Some matches may be empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the number of matches
found.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::vector&lt; _Tp, _Alloc &gt;::empty()</b>, and
<b>std::vector&lt; _Tp, _Alloc &gt;::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator==()</b>, and <b>std::match_results&lt;
_Bi_iter, _Alloc &gt;::operator[]()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; string_type
std::match_results&lt; _Bi_iter, _Alloc &gt;::str (size_type
__sub =</b> <tt>0</tt><b>) const</b> <tt>[inline]</tt> <br>
Gets the match or submatch converted to a string type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__sub</i> indicates the
submatch.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
gets the submatch (or match, if <tt>__sub</tt> is zero)
extracted from the target range and converted to the
associated string type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt;
const_reference std::match_results&lt; _Bi_iter, _Alloc
&gt;::suffix () const</b> <tt>[inline]</tt> <br>
Gets a sub_match representing the match suffix.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">ready() == true</p>

<p style="margin-left:11%; margin-top: 1em">This function
gets a reference to a sub_match object representing the part
of the target range between the end of the match and the end
of the target range.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::empty()</b>, and <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::ready()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::operator==()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Bi_iter , typename _Alloc =
allocator&lt;sub_match&lt;_Bi_iter&gt; &gt;&gt; void
std::match_results&lt; _Bi_iter, _Alloc &gt;::swap
(match_results&lt; _Bi_iter, _Alloc &gt; &amp; __that)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Swaps the contents of two match_results.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::swap()</b>, <b>std::match_results&lt; _Bi_iter,
_Alloc &gt;::swap()</b>, and <b>std::vector&lt; _Tp, _Alloc
&gt;::swap()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::match_results&lt; _Bi_iter, _Alloc
&gt;::swap()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
