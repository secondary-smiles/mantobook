<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:14 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;</title>

</head>
<body>
<h1>std::unordered_map</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt; &minus; A standard
container composed of unique keys (containing at most one of
each key value) that associates values of another type with
the keys.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;unordered_map&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">using <b>insert_return_type</b>
= typename _Hashtable::insert_return_type <br>
using <b>node_type</b> = typename _Hashtable::node_type</p>

<p style="margin-left:23%; margin-top: 1em">typedef
_Hashtable::key_type <b>key_type</b> <br>
Public typedefs. <br>
typedef _Hashtable::value_type <b>value_type</b> <br>
Public typedefs. <br>
typedef _Hashtable::mapped_type <b>mapped_type</b> <br>
Public typedefs. <br>
typedef _Hashtable::hasher <b>hasher</b> <br>
Public typedefs. <br>
typedef _Hashtable::key_equal <b>key_equal</b> <br>
Public typedefs. <br>
typedef _Hashtable::allocator_type <b>allocator_type</b>
<br>
Public typedefs.</p>

<p style="margin-left:23%; margin-top: 1em">typedef
_Hashtable::pointer <b>pointer</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::const_pointer <b>const_pointer</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::reference <b>reference</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::const_reference <b>const_reference</b>
<br>
Iterator-related typedefs. <br>
typedef _Hashtable::iterator <b>iterator</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::const_iterator <b>const_iterator</b>
<br>
Iterator-related typedefs. <br>
typedef _Hashtable::local_iterator <b>local_iterator</b>
<br>
Iterator-related typedefs. <br>
typedef _Hashtable::const_local_iterator
<b>const_local_iterator</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::size_type <b>size_type</b> <br>
Iterator-related typedefs. <br>
typedef _Hashtable::difference_type <b>difference_type</b>
<br>
Iterator-related typedefs.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>unordered_map</b> ()=default
<br>
Default constructor. <br>
template&lt;typename _InputIterator &gt;
<b>unordered_map</b> (_InputIterator __first, _InputIterator
__last, <b>size_type</b> __n, const <b>allocator_type</b>
&amp;__a) <br>
template&lt;typename _InputIterator &gt;
<b>unordered_map</b> (_InputIterator __first, _InputIterator
__last, <b>size_type</b> __n, const <b>hasher</b> &amp;__hf,
const <b>allocator_type</b> &amp;__a) <br>
template&lt;typename _InputIterator &gt;
<b>unordered_map</b> (_InputIterator __first, _InputIterator
__last, <b>size_type</b> __n=0, const <b>hasher</b>
&amp;__hf=<b>hasher</b>(), const <b>key_equal</b>
&amp;__eql=<b>key_equal</b>(), const <b>allocator_type</b>
&amp;__a=<b>allocator_type</b>()) <br>
Builds an unordered_map from a range. <b><br>
unordered_map</b> (const <b>allocator_type</b> &amp;__a)
<br>
Creates an unordered_map with no elements. <b><br>
unordered_map</b> (const <b>unordered_map</b> &amp;)=default
<br>
Copy constructor. <b><br>
unordered_map</b> (const <b>unordered_map</b> &amp;__umap,
const <b>allocator_type</b> &amp;__a) <b><br>
unordered_map</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l, <b>size_type</b> __n, const
<b>allocator_type</b> &amp;__a) <b><br>
unordered_map</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l, <b>size_type</b> __n, const
<b>hasher</b> &amp;__hf, const <b>allocator_type</b>
&amp;__a) <b><br>
unordered_map</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l, <b>size_type</b> __n=0, const
<b>hasher</b> &amp;__hf=<b>hasher</b>(), const
<b>key_equal</b> &amp;__eql=<b>key_equal</b>(), const
<b>allocator_type</b> &amp;__a=<b>allocator_type</b>()) <br>
Builds an unordered_map from an initializer_list. <b><br>
unordered_map</b> (<b>size_type</b> __n, const
<b>allocator_type</b> &amp;__a) <b><br>
unordered_map</b> (<b>size_type</b> __n, const <b>hasher</b>
&amp;__hf, const <b>allocator_type</b> &amp;__a) <b><br>
unordered_map</b> (<b>size_type</b> __n, const <b>hasher</b>
&amp;__hf=<b>hasher</b>(), const <b>key_equal</b>
&amp;__eql=<b>key_equal</b>(), const <b>allocator_type</b>
&amp;__a=<b>allocator_type</b>()) <br>
Default constructor creates no elements. <b><br>
unordered_map</b> (<b>unordered_map</b> &amp;&amp;)=default
<br>
Move constructor. <b><br>
unordered_map</b> (<b>unordered_map</b> &amp;&amp;__umap,
const <b>allocator_type</b> &amp;__a)
noexcept(noexcept(_Hashtable(<b>std::move</b>(__umap._M_h),
__a))) <b><br>
iterator begin</b> () noexcept <b><br>
local_iterator begin</b> (<b>size_type</b> __n) <br>
Returns a read/write iterator pointing to the first bucket
element. <b><br>
size_type bucket</b> (const <b>key_type</b> &amp;__key)
const <b><br>
size_type bucket_count</b> () const noexcept <br>
Returns the number of buckets of the unordered_map. <b><br>
size_type bucket_size</b> (<b>size_type</b> __n) const <br>
void <b>clear</b> () noexcept <br>
template&lt;typename... _Args&gt; <b>std::pair</b>&lt;
<b>iterator</b>, bool &gt; <b>emplace</b> (_Args
&amp;&amp;... __args) <br>
Attempts to build and insert a std::pair into the
unordered_map. <br>
template&lt;typename... _Args&gt; <b>iterator
emplace_hint</b> (<b>const_iterator</b> __pos, _Args
&amp;&amp;... __args) <br>
Attempts to build and insert a std::pair into the
unordered_map. <br>
bool <b>empty</b> () const noexcept <br>
Returns true if the unordered_map is empty. <b><br>
iterator end</b> () noexcept <b><br>
local_iterator end</b> (<b>size_type</b> __n) <br>
Returns a read/write iterator pointing to one past the last
bucket elements. <b><br>
size_type erase</b> (const <b>key_type</b> &amp;__x) <br>
Erases elements according to the provided key. <b><br>
iterator erase</b> (<b>const_iterator</b> __first,
<b>const_iterator</b> __last) <br>
Erases a [__first,__last) range of elements from an
unordered_map. <br>
node_type <b>extract</b> (const <b>key_type</b> &amp;__key)
<br>
Extract a node. <br>
node_type <b>extract</b> (<b>const_iterator</b> __pos) <br>
Extract a node. <b><br>
allocator_type get_allocator</b> () const noexcept <br>
Returns the allocator object used by the unordered_map.
<b><br>
hasher hash_function</b> () const <br>
Returns the hash functor object with which the unordered_map
was constructed. <br>
template&lt;typename _InputIterator &gt; void <b>insert</b>
(_InputIterator __first, _InputIterator __last) <br>
A template function that attempts to insert a range of
elements. <b><br>
iterator insert</b> (<b>const_iterator</b>, node_type
&amp;&amp;__nh) <br>
Re-insert an extracted node. <br>
void <b>insert</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l) <br>
Attempts to insert a list of elements into the
unordered_map. <br>
insert_return_type <b>insert</b> (node_type &amp;&amp;__nh)
<br>
Re-insert an extracted node. <br>
template&lt;typename _Obj &gt; <b>pair</b>&lt;
<b>iterator</b>, bool &gt; <b>insert_or_assign</b> (const
<b>key_type</b> &amp;__k, _Obj &amp;&amp;__obj) <br>
Attempts to insert a std::pair into the unordered_map. <br>
template&lt;typename _Obj &gt; <b>iterator
insert_or_assign</b> (<b>const_iterator</b> __hint, const
<b>key_type</b> &amp;__k, _Obj &amp;&amp;__obj) <br>
Attempts to insert a std::pair into the unordered_map. <br>
template&lt;typename _Obj &gt; <b>iterator
insert_or_assign</b> (<b>const_iterator</b> __hint,
<b>key_type</b> &amp;&amp;__k, _Obj &amp;&amp;__obj) <br>
template&lt;typename _Obj &gt; <b>pair</b>&lt;
<b>iterator</b>, bool &gt; <b>insert_or_assign</b>
(<b>key_type</b> &amp;&amp;__k, _Obj &amp;&amp;__obj)
<b><br>
key_equal key_eq</b> () const <br>
Returns the key comparison object with which the
unordered_map was constructed. <br>
float <b>load_factor</b> () const noexcept <br>
Returns the average number of elements per bucket. <b><br>
size_type max_bucket_count</b> () const noexcept <br>
Returns the maximum number of buckets of the unordered_map.
<br>
float <b>max_load_factor</b> () const noexcept <br>
Returns a positive number that the unordered_map tries to
keep the load factor less than or equal to. <br>
void <b>max_load_factor</b> (float __z) <br>
Change the unordered_map maximum load factor. <b><br>
size_type max_size</b> () const noexcept <br>
Returns the maximum size of the unordered_map. <br>
template&lt;typename _H2 , typename _P2 &gt; void
<b>merge</b> (<b>unordered_map</b>&lt; _Key, _Tp, _H2, _P2,
_Alloc &gt; &amp;&amp;__source) <br>
template&lt;typename _H2 , typename _P2 &gt; void
<b>merge</b> (<b>unordered_map</b>&lt; _Key, _Tp, _H2, _P2,
_Alloc &gt; &amp;__source) <br>
template&lt;typename _H2 , typename _P2 &gt; void
<b>merge</b> (<b>unordered_multimap</b>&lt; _Key, _Tp, _H2,
_P2, _Alloc &gt; &amp;&amp;__source) <br>
template&lt;typename _H2 , typename _P2 &gt; void
<b>merge</b> (<b>unordered_multimap</b>&lt; _Key, _Tp, _H2,
_P2, _Alloc &gt; &amp;__source) <b><br>
unordered_map</b> &amp; <b>operator=</b> (const
<b>unordered_map</b> &amp;)=default <br>
Copy assignment operator. <b><br>
unordered_map</b> &amp; <b>operator=</b>
(<b>initializer_list</b>&lt; <b>value_type</b> &gt; __l)
<br>
Unordered_map list assignment operator. <b><br>
unordered_map</b> &amp; <b>operator=</b>
(<b>unordered_map</b> &amp;&amp;)=default <br>
Move assignment operator. <br>
void <b>rehash</b> (<b>size_type</b> __n) <br>
May rehash the unordered_map. <br>
void <b>reserve</b> (<b>size_type</b> __n) <br>
Prepare the unordered_map for a specified number of
elements. <b><br>
size_type size</b> () const noexcept <br>
Returns the size of the unordered_map. <br>
void <b>swap</b> (<b>unordered_map</b> &amp;__x)
noexcept(noexcept(_M_h.swap(__x._M_h))) <br>
Swaps data with another unordered_map. <br>
template&lt;typename... _Args&gt; <b>pair</b>&lt;
<b>iterator</b>, bool &gt; <b>try_emplace</b> (const
<b>key_type</b> &amp;__k, _Args &amp;&amp;... __args) <br>
Attempts to build and insert a std::pair into the
unordered_map. <br>
template&lt;typename... _Args&gt; <b>iterator
try_emplace</b> (<b>const_iterator</b> __hint, const
<b>key_type</b> &amp;__k, _Args &amp;&amp;... __args) <br>
Attempts to build and insert a std::pair into the
unordered_map. <br>
template&lt;typename... _Args&gt; <b>iterator
try_emplace</b> (<b>const_iterator</b> __hint,
<b>key_type</b> &amp;&amp;__k, _Args &amp;&amp;... __args)
<br>
template&lt;typename... _Args&gt; <b>pair</b>&lt;
<b>iterator</b>, bool &gt; <b>try_emplace</b>
(<b>key_type</b> &amp;&amp;__k, _Args &amp;&amp;...
__args)</p>


<p style="margin-left:23%; margin-top: 1em"><b>const_iterator
begin</b> () const noexcept <b><br>
const_iterator cbegin</b> () const noexcept</p>


<p style="margin-left:23%; margin-top: 1em"><b>const_iterator
end</b> () const noexcept <b><br>
const_iterator cend</b> () const noexcept</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
<b>iterator</b>, bool &gt; <b>insert</b> (const
<b>value_type</b> &amp;__x) <br>
Attempts to insert a std::pair into the unordered_map.
<b><br>
std::pair</b>&lt; <b>iterator</b>, bool &gt; <b>insert</b>
(<b>value_type</b> &amp;&amp;__x) <br>
Attempts to insert a std::pair into the unordered_map. <br>
template&lt;typename _Pair &gt; __enable_if_t&lt;
<b>is_constructible</b>&lt; <b>value_type</b>, _Pair
&amp;&amp; &gt;::value, <b>pair</b>&lt; <b>iterator</b>,
bool &gt; &gt; <b>insert</b> (_Pair &amp;&amp;__x) <br>
Attempts to insert a std::pair into the unordered_map.</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
insert</b> (<b>const_iterator</b> __hint, const
<b>value_type</b> &amp;__x) <br>
Attempts to insert a std::pair into the unordered_map.
<b><br>
iterator insert</b> (<b>const_iterator</b> __hint,
<b>value_type</b> &amp;&amp;__x) <br>
Attempts to insert a std::pair into the unordered_map. <br>
template&lt;typename _Pair &gt; __enable_if_t&lt;
<b>is_constructible</b>&lt; <b>value_type</b>, _Pair
&amp;&amp; &gt;::value, <b>iterator</b> &gt; <b>insert</b>
(<b>const_iterator</b> __hint, _Pair &amp;&amp;__x) <br>
Attempts to insert a std::pair into the unordered_map.</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
erase</b> (<b>const_iterator</b> __position) <br>
Erases an element from an unordered_map. <b><br>
iterator erase</b> (<b>iterator</b> __position) <br>
Erases an element from an unordered_map.</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
find</b> (const <b>key_type</b> &amp;__x) <br>
Tries to locate an element in an unordered_map. <br>
template&lt;typename _Kt &gt; auto <b>find</b> (const _Kt
&amp;__x) &minus;&gt; decltype(_M_h._M_find_tr(__x)) <br>
Tries to locate an element in an unordered_map. <b><br>
const_iterator find</b> (const <b>key_type</b> &amp;__x)
const <br>
Tries to locate an element in an unordered_map. <br>
template&lt;typename _Kt &gt; auto <b>find</b> (const _Kt
&amp;__x) const &minus;&gt; decltype(_M_h._M_find_tr(__x))
<br>
Tries to locate an element in an unordered_map.</p>

<p style="margin-left:23%; margin-top: 1em"><b>size_type
count</b> (const <b>key_type</b> &amp;__x) const <br>
Finds the number of elements. <br>
template&lt;typename _Kt &gt; auto <b>count</b> (const _Kt
&amp;__x) const &minus;&gt; decltype(_M_h._M_count_tr(__x))
<br>
Finds the number of elements.</p>

<p style="margin-left:23%; margin-top: 1em">bool
<b>contains</b> (const <b>key_type</b> &amp;__x) const <br>
Finds whether an element with the given key exists. <br>
template&lt;typename _Kt &gt; auto <b>contains</b> (const
_Kt &amp;__x) const &minus;&gt;
decltype(_M_h._M_find_tr(__x), void(), true) <br>
Finds whether an element with the given key exists.</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
<b>iterator</b>, <b>iterator</b> &gt; <b>equal_range</b>
(const <b>key_type</b> &amp;__x) <br>
Finds a subsequence matching given key. <br>
template&lt;typename _Kt &gt; auto <b>equal_range</b> (const
_Kt &amp;__x) &minus;&gt;
decltype(_M_h._M_equal_range_tr(__x)) <br>
Finds a subsequence matching given key. <b><br>
std::pair</b>&lt; <b>const_iterator</b>,
<b>const_iterator</b> &gt; <b>equal_range</b> (const
<b>key_type</b> &amp;__x) const <br>
Finds a subsequence matching given key. <br>
template&lt;typename _Kt &gt; auto <b>equal_range</b> (const
_Kt &amp;__x) const &minus;&gt;
decltype(_M_h._M_equal_range_tr(__x)) <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:23%; margin-top: 1em"><b>mapped_type</b>
&amp; <b>operator[]</b> (const <b>key_type</b> &amp;__k)
<br>
Subscript ( [] ) access to unordered_map data. <b><br>
mapped_type</b> &amp; <b>operator[]</b> (<b>key_type</b>
&amp;&amp;__k) <br>
Subscript ( [] ) access to unordered_map data.</p>


<p style="margin-left:23%; margin-top: 1em"><b>mapped_type</b>
&amp; <b>at</b> (const <b>key_type</b> &amp;__k) <br>
Access to unordered_map data. <br>
const <b>mapped_type</b> &amp; <b>at</b> (const
<b>key_type</b> &amp;__k) const <br>
Access to unordered_map data.</p>


<p style="margin-left:23%; margin-top: 1em"><b>const_local_iterator
begin</b> (<b>size_type</b> __n) const <br>
Returns a read-only (constant) iterator pointing to the
first bucket element. <b><br>
const_local_iterator cbegin</b> (<b>size_type</b> __n) const
<br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:23%; margin-top: 1em"><b>const_local_iterator
end</b> (<b>size_type</b> __n) const <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements. <b><br>
const_local_iterator cend</b> (<b>size_type</b> __n) const
<br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename _Key1 ,
typename _Tp1 , typename _Hash1 , typename _Pred1 , typename
_Alloc1 &gt; bool <b>operator==</b> (const
<b>unordered_map</b>&lt; _Key1, _Tp1, _Hash1, _Pred1,
_Alloc1 &gt; &amp;, const <b>unordered_map</b>&lt; _Key1,
_Tp1, _Hash1, _Pred1, _Alloc1 &gt; &amp;) <br>
template&lt;typename , typename , typename &gt; class
<b>std::_Hash_merge_helper</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key, typename _Tp, typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;</b>
<br>
class std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;&quot;A standard container composed of unique keys
(containing at most one of each key value) that associates
values of another type with the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++11</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_Key</i> Type of key
objects. <i><br>
_Tp</i> Type of mapped objects. <i><br>
_Hash</i> Hashing function object type, defaults to
hash&lt;_Value&gt;. <i><br>
_Pred</i> Predicate function object type, defaults to
equal_to&lt;_Value&gt;. <i><br>
_Alloc</i> Allocator type, defaults to
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Meets the
requirements of a <tt>container</tt>, and <tt>unordered
associative container</tt></p>

<p style="margin-left:11%; margin-top: 1em">The resulting
value type of the container is std::pair&lt;const _Key,
_Tp&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Base is
_Hashtable, dispatched at compile time via template alias
__umap_hashtable.</p>

<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::allocator_type std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::allocator_type</b>
<br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::const_iterator std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::const_iterator</b>
<br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::const_local_iterator
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::const_local_iterator</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::const_pointer std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::const_pointer</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::const_reference std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::const_reference</b>
<br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::difference_type std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::difference_type</b>
<br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::hasher std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::hasher</b> <br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::iterator std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::iterator</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::key_equal std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::key_equal</b> <br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::key_type std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::key_type</b> <br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::local_iterator std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::local_iterator</b>
<br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::mapped_type std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::mapped_type</b> <br>
Public typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::pointer std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::pointer</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::reference std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::reference</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::size_type std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::size_type</b> <br>
Iterator-related typedefs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
typedef _Hashtable::value_type std::unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt;::value_type</b> <br>
Public typedefs.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map ()</b> <tt>[default]</tt> <br>
Default constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (size_type __n, const hasher &amp; __hf
= hasher</b><tt>()</tt><b>, const key_equal &amp; __eql =
key_equal</b><tt>()</tt><b>, const allocator_type &amp; __a
= allocator_type</b><tt>()</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt> <br>
Default constructor creates no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> Minimal initial
number of buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _InputIterator &gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (_InputIterator __first, _InputIterator
__last, size_type __n =</b> <tt>0</tt><b>, const hasher
&amp; __hf = hasher</b><tt>()</tt><b>, const key_equal &amp;
__eql = key_equal</b><tt>()</tt><b>, const allocator_type
&amp; __a = allocator_type</b><tt>()</tt><b>)</b>
<tt>[inline]</tt> <br>
Builds an unordered_map from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__n</i> Minimal initial number of buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create an
unordered_map consisting of copies of the elements from
[__first,__last). This is linear in N (where N is
distance(__first,__last)).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (const unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt; &amp;)</b> <tt>[default]</tt> <br>
Copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt; &amp;&amp;)</b> <tt>[default]</tt> <br>
Move constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (const allocator_type &amp; __a)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt> <br>
Creates an unordered_map with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> An allocator
object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::unordered_map (initializer_list&lt; value_type &gt;
__l, size_type __n =</b> <tt>0</tt><b>, const hasher &amp;
__hf = hasher</b><tt>()</tt><b>, const key_equal &amp; __eql
= key_equal</b><tt>()</tt><b>, const allocator_type &amp;
__a = allocator_type</b><tt>()</tt><b>)</b>
<tt>[inline]</tt> <br>
Builds an unordered_map from an initializer_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list.
<i><br>
__n</i> Minimal initial number of buckets. <i><br>
__hf</i> A hash functor. <i><br>
__eql</i> A key equality functor. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create an
unordered_map consisting of copies of the elements in the
list. This is linear in N (where N is
<i>__l.size()</i>).</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
mapped_type &amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::at (const key_type &amp; __k)</b>
<tt>[inline]</tt> <br>
Access to unordered_map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A reference to the data whose
key is equal to <i>__k</i>, if such a data is present in the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If no
such data is present.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; const
mapped_type &amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::at (const key_type &amp; __k) const</b>
<tt>[inline]</tt> <br>
Access to unordered_map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A reference to the data whose
key is equal to <i>__k</i>, if such a data is present in the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If no
such data is present.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::begin () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::begin ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read/write iterator that points to the first
element in the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
local_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::begin (size_type __n)</b>
<tt>[inline]</tt> <br>
Returns a read/write iterator pointing to the first bucket
element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read/write local
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_local_iterator std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::begin (size_type __n) const</b>
<tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::bucket_count () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of buckets of the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::cbegin () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_local_iterator std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::cbegin (size_type __n) const</b>
<tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to the
first bucket element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::cend () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert_or_assign()</b>, and <b>std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::try_emplace()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_local_iterator std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::cend (size_type __n) const</b>
<tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; void
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::clear ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Erases all elements in an unordered_map. Note that this
function only erases the elements, and that if the elements
themselves are pointers, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Kt &gt; auto std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::contains (const _Kt
&amp; __x) const &minus;&gt; decltype(_M_h._M_find_tr(__x),
void(), true)</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds whether
an element with the given key exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of elements to
be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if there is any element
with the specified key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; bool
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::contains (const key_type &amp; __x) const</b>
<tt>[inline]</tt> <br>
Finds whether an element with the given key exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of elements to
be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if there is any element
with the specified key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Kt &gt; auto std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::count (const _Kt &amp;
__x) const &minus;&gt;
decltype(_M_h._M_count_tr(__x))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds the
number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to count.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Number of elements with
specified key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
only makes sense for unordered_multimap; for unordered_map
the result will either be 0 (not present) or 1
(present).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::count (const key_type &amp; __x) const</b>
<tt>[inline]</tt> <br>
Finds the number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to count.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Number of elements with
specified key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
only makes sense for unordered_multimap; for unordered_map
the result will either be 0 (not present) or 1
(present).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename... _Args&gt; std::pair&lt; iterator,
bool &gt; std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::emplace (_Args &amp;&amp;... __args)</b>
<tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__args</i> Arguments used to
generate a new pair instance (see std::piecewise_contruct
for passing arguments to each part of the pair
constructor).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to build and insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename... _Args&gt; iterator
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::emplace_hint (const_iterator __pos, _Args
&amp;&amp;... __args)</b> <tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__args</i> Arguments used to generate a new pair instance
(see std::piecewise_contruct for passing arguments to each
part of the pair constructor).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of the std::pair built from <i>__args</i>
(may or may not be that std::pair).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
emplace() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; bool
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::empty () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns true if the unordered_map is empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::end () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::end ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read/write iterator that points one past the last
element in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::extract()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
local_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::end (size_type __n)</b>
<tt>[inline]</tt> <br>
Returns a read/write iterator pointing to one past the last
bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read/write local
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_local_iterator std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::end (size_type __n) const</b>
<tt>[inline]</tt> <br>
Returns a read-only (constant) iterator pointing to one past
the last bucket elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The bucket
index.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A read-only local iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Kt &gt; auto std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range (const _Kt
&amp; __x) &minus;&gt;
decltype(_M_h._M_equal_range_tr(__x))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds a
subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for unordered_multimap.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Kt &gt; auto std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range (const _Kt
&amp; __x) const &minus;&gt;
decltype(_M_h._M_equal_range_tr(__x))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds a
subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for unordered_multimap.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::pair&lt; iterator, iterator &gt; std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::equal_range (const
key_type &amp; __x)</b> <tt>[inline]</tt> <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for unordered_multimap.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::pair&lt; const_iterator, const_iterator &gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::equal_range (const key_type &amp; __x) const</b>
<tt>[inline]</tt> <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for unordered_multimap.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::erase (const key_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Erases elements according to the provided key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of element to be
erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The number of elements
erased.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases all the elements located by the given key from an
unordered_map. For an unordered_map the result of this
function can only be 0 (not present) or 1 (present). Note
that this function only erases the element, and that if the
element is itself a pointer, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::erase (const_iterator __first, const_iterator
__last)</b> <tt>[inline]</tt> <br>
Erases a [__first,__last) range of elements from an
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the start of the range to be erased. <i><br>
__last</i> Iterator pointing to the end of the range to be
erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The iterator <i>__last</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases a sequence of elements from an unordered_map. Note
that this function only erases the elements, and that if the
element is itself a pointer, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::erase (const_iterator __position)</b>
<tt>[inline]</tt> <br>
Erases an element from an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
pointing to the element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element immediately following <i>__position</i> prior to the
element being erased. If no such element exists, end() is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases an element, pointed to by the given iterator, from an
unordered_map. Note that this function only erases the
element, and that if the element is itself a pointer, the
pointed-to memory is not touched in any way. Managing the
pointer is the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::erase (iterator __position)</b>
<tt>[inline]</tt> <br>
Erases an element from an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
pointing to the element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element immediately following <i>__position</i> prior to the
element being erased. If no such element exists, end() is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases an element, pointed to by the given iterator, from an
unordered_map. Note that this function only erases the
element, and that if the element is itself a pointer, the
pointed-to memory is not touched in any way. Managing the
pointer is the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
node_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::extract (const key_type &amp; __key)</b>
<tt>[inline]</tt> <br>
Extract a node.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
node_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::extract (const_iterator __pos)</b>
<tt>[inline]</tt> <br>
Extract a node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Kt &gt; auto std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::find (const _Kt &amp;
__x) &minus;&gt; decltype(_M_h._M_find_tr(__x))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Tries to locate
an element in an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Kt &gt; auto std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::find (const _Kt &amp;
__x) const &minus;&gt;
decltype(_M_h._M_find_tr(__x))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Tries to locate
an element in an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::find (const key_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Tries to locate an element in an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
const_iterator std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::find (const key_type &amp; __x)
const</b> <tt>[inline]</tt> <br>
Tries to locate an element in an unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key to be
located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after element. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
allocator_type std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::get_allocator () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the allocator object used by the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; hasher
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::hash_function () const</b> <tt>[inline]</tt> <br>
Returns the hash functor object with which the unordered_map
was constructed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _InputIterator &gt; void
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert (_InputIterator __first, _InputIterator
__last)</b> <tt>[inline]</tt> <br>
A template function that attempts to insert a range of
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the start of the range to be inserted. <i><br>
__last</i> Iterator pointing to the end of the range.</p>

<p style="margin-left:11%; margin-top: 1em">Complexity
similar to that of the range constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Pair &gt; __enable_if_t&lt;
is_constructible&lt; value_type, _Pair &amp;&amp;
&gt;::value, pair&lt; iterator, bool &gt; &gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert (_Pair &amp;&amp; __x)</b> <tt>[inline]</tt>
<br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Pair to be inserted
(see std::make_pair for easy creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::pair&lt; iterator, bool &gt; std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert (const
value_type &amp; __x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Pair to be inserted
(see std::make_pair for easy creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Pair &gt; __enable_if_t&lt;
is_constructible&lt; value_type, _Pair &amp;&amp;
&gt;::value, iterator &gt; std::unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt;::insert (const_iterator __hint,
_Pair &amp;&amp; __x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__x</i> Pair to be inserted (see std::make_pair for easy
creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::insert (const_iterator __hint, const value_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__x</i> Pair to be inserted (see std::make_pair for easy
creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::insert (const_iterator __hint, value_type
&amp;&amp; __x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__x</i> Pair to be inserted (see std::make_pair for easy
creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
iterator std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::insert (const_iterator, node_type &amp;&amp;
__nh)</b> <tt>[inline]</tt> <br>
Re-insert an extracted node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; void
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert (initializer_list&lt; value_type &gt; __l)</b>
<tt>[inline]</tt> <br>
Attempts to insert a list of elements into the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> A
std::initializer_list&lt;value_type&gt; of elements to be
inserted.</p>

<p style="margin-left:11%; margin-top: 1em">Complexity
similar to that of the range constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
insert_return_type std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::insert (node_type &amp;&amp; __nh)</b>
<tt>[inline]</tt> <br>
Re-insert an extracted node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
std::pair&lt; iterator, bool &gt; std::unordered_map&lt;
_Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert (value_type
&amp;&amp; __x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Pair to be inserted
(see std::make_pair for easy creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Obj &gt; pair&lt; iterator, bool &gt;
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert_or_assign (const key_type &amp; __k, _Obj
&amp;&amp; __obj)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> Key to use for
finding a possibly existing pair in the map. <i><br>
__obj</i> Argument used to generate the .second for a pair
instance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map. If the pair was
already in the unordered_map, the .second of the pair is
assigned from __obj.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::cend()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename _Obj &gt; iterator
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::insert_or_assign (const_iterator __hint, const
key_type &amp; __k, _Obj &amp;&amp; __obj)</b>
<tt>[inline]</tt> <br>
Attempts to insert a std::pair into the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__k</i> Key to use for finding a possibly existing pair in
the unordered_map. <i><br>
__obj</i> Argument used to generate the .second for a pair
instance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. <br>
If the pair was already in the unordered map, the .second of
the pair is assigned from __obj. Note that the first
parameter is only a hint and can potentially improve the
performance of the insertion process. A bad hint would cause
no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
key_equal std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::key_eq () const</b> <tt>[inline]</tt> <br>
Returns the key comparison object with which the
unordered_map was constructed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; float
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::load_factor () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the average number of elements per bucket.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::max_bucket_count () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the maximum number of buckets of the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; float
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::max_load_factor () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a positive number that the unordered_map tries to
keep the load factor less than or equal to.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; void
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::max_load_factor (float __z)</b> <tt>[inline]</tt> <br>
Change the unordered_map maximum load factor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__z</i> The new maximum load
factor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::max_size () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the maximum size of the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
unordered_map &amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator= (const unordered_map&lt; _Key,
_Tp, _Hash, _Pred, _Alloc &gt; &amp;)</b> <tt>[default]</tt>
<br>
Copy assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
unordered_map &amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator= (initializer_list&lt;
value_type &gt; __l)</b> <tt>[inline]</tt> <br>
Unordered_map list assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills an unordered_map with copies of the elements in the
initializer list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the unordered_map and that the
resulting unordered_map&rsquo;s size is the same as the
number of elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
unordered_map &amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator= (unordered_map&lt; _Key, _Tp,
_Hash, _Pred, _Alloc &gt; &amp;&amp;)</b> <tt>[default]</tt>
<br>
Move assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
mapped_type &amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator[] (const key_type &amp;
__k)</b> <tt>[inline]</tt> <br>
Subscript ( [] ) access to unordered_map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A reference to the data of the
(key,data) pair.</p>

<p style="margin-left:11%; margin-top: 1em">Allows for easy
lookup with the subscript ( [] )operator. Returns data
associated with the key specified in subscript. If the key
does not exist, a pair with that key is created using
default values, which is then returned.</p>

<p style="margin-left:11%; margin-top: 1em">Lookup requires
constant time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
mapped_type &amp; std::unordered_map&lt; _Key, _Tp, _Hash,
_Pred, _Alloc &gt;::operator[] (key_type &amp;&amp; __k)</b>
<tt>[inline]</tt> <br>
Subscript ( [] ) access to unordered_map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A reference to the data of the
(key,data) pair.</p>

<p style="margin-left:11%; margin-top: 1em">Allows for easy
lookup with the subscript ( [] )operator. Returns data
associated with the key specified in subscript. If the key
does not exist, a pair with that key is created using
default values, which is then returned.</p>

<p style="margin-left:11%; margin-top: 1em">Lookup requires
constant time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; void
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::rehash (size_type __n)</b> <tt>[inline]</tt> <br>
May rehash the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The new number of
buckets.</p>

<p style="margin-left:11%; margin-top: 1em">Rehash will
occur only if the new number of buckets respect the
unordered_map maximum load factor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; void
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::reserve (size_type __n)</b> <tt>[inline]</tt> <br>
Prepare the unordered_map for a specified number of
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> Number of elements
required.</p>

<p style="margin-left:11%; margin-top: 1em">Same as
rehash(ceil(n / max_load_factor())).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
size_type std::unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt;::size () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the size of the unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; void
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::swap (unordered_map&lt; _Key, _Tp, _Hash, _Pred,
_Alloc &gt; &amp; __x)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Swaps data with another unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> An unordered_map of
the same element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">This exchanges
the elements between two unordered_map in constant time.
Note that the global std::swap() function is specialized
such that std::swap(m1,m2) will feed to this function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename... _Args&gt; pair&lt; iterator, bool
&gt; std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::try_emplace (const key_type &amp; __k, _Args
&amp;&amp;... __args)</b> <tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> Key to use for
finding a possibly existing pair in the unordered_map.
<i><br>
__args</i> Arguments used to generate the .second for a new
pair instance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to build and insert a (key, value) pair into the
unordered_map. An unordered_map relies on unique keys and
thus a pair is only inserted if its first element (the key)
is not already present in the unordered_map. If a pair is
not inserted, this function has no effect.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::cend()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Hash = hash&lt;_Key&gt;,
typename _Pred = equal_to&lt;_Key&gt;, typename _Alloc =
allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;
template&lt;typename... _Args&gt; iterator
std::unordered_map&lt; _Key, _Tp, _Hash, _Pred, _Alloc
&gt;::try_emplace (const_iterator __hint, const key_type
&amp; __k, _Args &amp;&amp;... __args)</b> <tt>[inline]</tt>
<br>
Attempts to build and insert a std::pair into the
unordered_map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__k</i> Key to use for finding a possibly existing pair in
the unordered_map. <i><br>
__args</i> Arguments used to generate the .second for a new
pair instance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of the std::pair built from <i>__args</i>
(may or may not be that std::pair).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
emplace() does. However, if insertion did not take place,
this function has no effect. Note that the first parameter
is only a hint and can potentially improve the performance
of the insertion process. A bad hint would cause no gains in
efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires amortized constant time.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
