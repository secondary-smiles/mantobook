<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:01 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SD_PID_GET_OWNER_UID</title>

</head>
<body>
<h1>sd_peer_get_cgroup</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">sd_pid_get_owner_uid,
sd_pid_get_session, sd_pid_get_user_unit, sd_pid_get_unit,
sd_pid_get_machine_name, sd_pid_get_slice,
sd_pid_get_user_slice, sd_pid_get_cgroup,
sd_pidfd_get_owner_uid, sd_pidfd_get_session,
sd_pidfd_get_user_unit, sd_pidfd_get_unit,
sd_pidfd_get_machine_name, sd_pidfd_get_slice,
sd_pidfd_get_user_slice, sd_pidfd_get_cgroup,
sd_peer_get_owner_uid, sd_peer_get_session,
sd_peer_get_user_unit, sd_peer_get_unit,
sd_peer_get_machine_name, sd_peer_get_slice,
sd_peer_get_user_slice, sd_peer_get_cgroup &minus; Determine
the owner uid of the user unit or session, or the session,
user unit, system unit, container/VM or slice that a
specific PID or socket peer belongs to</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;systemd/sd&minus;login.h&gt;</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pid_get_owner_uid(pid_t&nbsp;</b><i>pid</i><b>,
uid_t&nbsp;*</b><i>uid</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pid_get_session(pid_t&nbsp;</b><i>pid</i><b>,
char&nbsp;**</b><i>session</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pid_get_user_unit(pid_t&nbsp;</b><i>pid</i><b>,
char&nbsp;**</b><i>unit</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pid_get_unit(pid_t&nbsp;</b><i>pid</i><b>,
char&nbsp;**</b><i>unit</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pid_get_machine_name(pid_t&nbsp;</b><i>pid</i><b>,
char&nbsp;**</b><i>name</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pid_get_slice(pid_t&nbsp;</b><i>pid</i><b>,
char&nbsp;**</b><i>slice</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pid_get_user_slice(pid_t&nbsp;</b><i>pid</i><b>,
char&nbsp;**</b><i>slice</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pid_get_cgroup(pid_t&nbsp;</b><i>pid</i><b>,
char&nbsp;**</b><i>cgroup</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pidfd_get_owner_uid(int&nbsp;</b><i>pidfd</i><b>,
uid_t&nbsp;*</b><i>uid</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pidfd_get_session(int&nbsp;</b><i>pidfd</i><b>,
char&nbsp;**</b><i>session</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pidfd_get_user_unit(int&nbsp;</b><i>pidfd</i><b>,
char&nbsp;**</b><i>unit</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pidfd_get_unit(int&nbsp;</b><i>pidfd</i><b>,
char&nbsp;**</b><i>unit</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pidfd_get_machine_name(int&nbsp;</b><i>pidfd</i><b>,
char&nbsp;**</b><i>name</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pidfd_get_slice(int&nbsp;</b><i>pidfd</i><b>,
char&nbsp;**</b><i>slice</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pidfd_get_user_slice(int&nbsp;</b><i>pidfd</i><b>,
char&nbsp;**</b><i>slice</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_pidfd_get_cgroup(int&nbsp;</b><i>pidfd</i><b>,
char&nbsp;**</b><i>cgroup</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_peer_get_owner_uid(int&nbsp;</b><i>fd</i><b>,
uid_t&nbsp;*</b><i>uid</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_peer_get_session(int&nbsp;</b><i>fd</i><b>,
char&nbsp;**</b><i>session</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_peer_get_user_unit(int&nbsp;</b><i>fd</i><b>,
char&nbsp;**</b><i>unit</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_peer_get_unit(int&nbsp;</b><i>fd</i><b>,
char&nbsp;**</b><i>unit</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_peer_get_machine_name(int&nbsp;</b><i>fd</i><b>,
char&nbsp;**</b><i>name</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_peer_get_slice(int&nbsp;</b><i>fd</i><b>,
char&nbsp;**</b><i>slice</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_peer_get_user_slice(int&nbsp;</b><i>fd</i><b>,
char&nbsp;**</b><i>slice</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="83%">


<p style="margin-top: 1em"><b>int
sd_peer_get_cgroup(int&nbsp;</b><i>fd</i><b>,
char&nbsp;**</b><i>cgroup</i><b>);</b></p> </td>
<td width="6%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>sd_pid_get_owner_uid()</b>
may be used to determine the Unix UID (user identifier)
which owns the login session or systemd user unit of a
process identified by the specified PID. For processes which
are not part of a login session and not managed by a user
manager, this function will fail with
<b>&minus;ENODATA</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>sd_pid_get_session()</b>
may be used to determine the login session identifier of a
process identified by the specified process identifier. The
session identifier is a short string, suitable for usage in
file system paths. Please note the login session may be
limited to a stub process or two. User processes may instead
be started from their systemd user manager, e.g. GUI
applications started using DBus activation, as well as
service processes which are shared between multiple logins
of the same user. For processes which are not part of a
login session, this function will fail with
<b>&minus;ENODATA</b>. The returned string needs to be freed
with the libc <b>free</b>(3) call after use.</p>


<p style="margin-left:11%; margin-top: 1em"><b>sd_pid_get_user_unit()</b>
may be used to determine the systemd user unit (i.e. user
service or scope unit) identifier of a process identified by
the specified PID. The unit name is a short string, suitable
for usage in file system paths. For processes which are not
managed by a user manager, this function will fail with
<b>&minus;ENODATA</b>. The returned string needs to be freed
with the libc <b>free</b>(3) call after use.</p>


<p style="margin-left:11%; margin-top: 1em"><b>sd_pid_get_unit()</b>
may be used to determine the systemd system unit (i.e.
system service or scope unit) identifier of a process
identified by the specified PID. The unit name is a short
string, suitable for usage in file system paths. Note that
not all processes are part of a system unit/service. For
processes not being part of a systemd system unit, this
function will fail with <b>&minus;ENODATA</b>. (More
specifically, this call will not work for kernel threads.)
The returned string needs to be freed with the libc
<b>free</b>(3) call after use.</p>


<p style="margin-left:11%; margin-top: 1em"><b>sd_pid_get_machine_name()</b>
may be used to determine the name of the VM or container is
a member of. The machine name is a short string, suitable
for usage in file system paths. The returned string needs to
be freed with the libc <b>free</b>(3) call after use. For
processes not part of a VM or container, this function fails
with <b>&minus;ENODATA</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>sd_pid_get_slice()</b>
may be used to determine the slice unit the process is a
member of. See <b>systemd.slice</b>(5) for details about
slices. The returned string needs to be freed with the libc
<b>free</b>(3) call after use.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
<b>sd_pid_get_user_slice()</b> returns the user slice (as
managed by the user's systemd instance) of a process.</p>


<p style="margin-left:11%; margin-top: 1em"><b>sd_pid_get_cgroup()</b>
returns the control group path of the specified process,
relative to the root of the hierarchy. Returns the path
without trailing slash, except for processes located in the
root control group, where &quot;/&quot; is returned. To find
the actual control group path in the file system, the
returned path needs to be prefixed with /sys/fs/cgroup/ (if
the unified control group setup is used), or
/sys/fs/cgroup/<i>HIERARCHY</i>/ (if the legacy
multi&minus;hierarchy control group setup is used).</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>pid</i> parameter of any of these functions is passed as
0, the operation is executed for the calling process.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>sd_pidfd_get_owner_uid()</b>,
<b>sd_pidfd_get_session()</b>,
<b>sd_pidfd_get_user_unit()</b>, <b>sd_pidfd_get_unit()</b>,
<b>sd_pidfd_get_machine_name()</b>,
<b>sd_pidfd_get_slice()</b>,
<b>sd_pidfd_get_user_slice()</b> and
<b>sd_pidfd_get_cgroup()</b> calls operate similarly to
their PID counterparts, but accept a <b>PIDFD</b> instead of
a <b>PID</b>, which means they are not subject to recycle
race conditions as the process is pinned by the file
descriptor during the whole duration of the invocation. Note
that these require a kernel that supports <b>PIDFD</b>. A
suitable file descriptor may be acquired via
<b>pidfd_open</b>(2).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>sd_peer_get_owner_uid()</b>,
<b>sd_peer_get_session()</b>,
<b>sd_peer_get_user_unit()</b>, <b>sd_peer_get_unit()</b>,
<b>sd_peer_get_machine_name()</b>,
<b>sd_peer_get_slice()</b>, <b>sd_peer_get_user_slice()</b>
and <b>sd_peer_get_cgroup()</b> calls operate similarly to
their PID counterparts, but accept a connected
<b>AF_UNIX</b> socket and retrieve information about the
connected peer process. Note that these fields are retrieved
via /proc/, and hence are not suitable for authorization
purposes, as they are subject to races.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On success,
these calls return 0 or a positive integer. On failure,
these calls return a negative errno&minus;style error
code.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Errors</b>
<br>
Returned errors may indicate the following problems:</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;ESRCH</b></p>

<p style="margin-left:17%;">The specified PID does not
refer to a running process.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;EBADF</b></p>

<p style="margin-left:17%;">The specified socket file
descriptor was invalid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;ENODATA</b></p>

<p style="margin-left:17%;">The given field is not
specified for the described process or peer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;EINVAL</b></p>

<p style="margin-left:17%;">An input parameter was invalid
(out of range, or <b>NULL</b>, where that is not
accepted).</p>


<p style="margin-left:11%; margin-top: 1em"><b>&minus;ENOMEM</b></p>

<p style="margin-left:17%;">Memory allocation failed.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These APIs are
implemented as a shared library, which can be compiled and
linked to with the <b>libsystemd&nbsp;pkg-config</b>(1)
file.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
login session identifier as returned by
<b>sd_pid_get_session()</b> is completely unrelated to the
process session identifier as returned by
<b>getsid</b>(2).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>systemd</b>(1),
<b>sd-login</b>(3), <b>sd_session_is_active</b>(3),
<b>getsid</b>(2), <b>systemd.slice</b>(5),
<b>systemd-machined.service</b>(8)</p>
<hr>
</body>
</html>
