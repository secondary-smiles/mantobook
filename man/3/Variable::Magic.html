<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:24 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Variable::Magic</title>

</head>
<body>
<h1>Variable::Magic</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Variable::Magic
&minus; Associate user&minus;defined magic to variables from
Perl.</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Version
0.63</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use
Variable::Magic qw&lt;wizard cast VMG_OP_INFO_NAME&gt;; <br>
{ # A variable tracer <br>
my $wiz = wizard( <br>
set =&gt; sub { print &quot;now set to ${$_[0]}!\n&quot; },
<br>
free =&gt; sub { print &quot;destroyed!\n&quot; }, <br>
); <br>
my $a = 1; <br>
cast $a, $wiz; <br>
$a = 2; # &quot;now set to 2!&quot; <br>
} # &quot;destroyed!&quot; <br>
{ # A hash with a default value <br>
my $wiz = wizard( <br>
data =&gt; sub { $_[1] }, <br>
fetch =&gt; sub { $_[2] = $_[1] unless exists
$_[0]&minus;&gt;{$_[2]}; () }, <br>
store =&gt; sub { print &quot;key $_[2] stored in
$_[&minus;1]\n&quot; }, <br>
copy_key =&gt; 1, <br>
op_info =&gt; VMG_OP_INFO_NAME, <br>
); <br>
my %h = (_default =&gt; 0, apple =&gt; 2); <br>
cast %h, $wiz, '_default'; <br>
print $h{banana}, &quot;\n&quot;; # &quot;0&quot; (there is
no 'banana' key in %h) <br>
$h{pear} = 1; # &quot;key pear stored in helem&quot; <br>
}</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Magic is
Perl&rsquo;s way of enhancing variables. This mechanism lets
the user add extra data to any variable and hook syntactical
operations (such as access, assignment or destruction) that
can be applied to it. With this module, you can add your own
magic to any variable without having to write a single line
of <small>XS.</small></p>

<p style="margin-left:11%; margin-top: 1em">You&rsquo;ll
realize that these magic variables look a lot like tied
variables. It is not surprising, as tied variables are
implemented as a special kind of magic, just like any
&rsquo;irregular&rsquo; Perl variable : scalars like $!, $(
or $^W, the %ENV and %SIG hashes, the @ISA array,
&quot;vec()&quot; and &quot;substr()&quot; lvalues,
threads::shared variables... They all share the same
underlying C <small>API,</small> and this module gives you
direct access to it.</p>

<p style="margin-left:11%; margin-top: 1em">Still, the
magic made available by this module differs from tieing and
overloading in several ways :</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="52%">


<p>Magic is not copied on assignment.</p></td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">You attach it
to variables, not values (as for blessed references).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="71%">


<p style="margin-top: 1em">Magic does not replace the
original semantics.</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Magic callbacks
usually get triggered before the original action takes
place, and cannot prevent it from happening. This also makes
catching individual events easier than with &quot;tie&quot;,
where you have to provide fallbacks methods for all actions
by usually inheriting from the correct &quot;Tie::Std*&quot;
class and overriding individual methods in your own
class.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="32%">


<p style="margin-top: 1em">Magic is multivalued.</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">You can safely
apply different kinds of magics to the same variable, and
each of them will be invoked successively.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">Magic is type-agnostic.</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The same magic
can be applied on scalars, arrays, hashes, subs or globs.
But the same hook (see below for a list) may trigger
differently depending on the type of the variable.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="51%">


<p style="margin-top: 1em">Magic is invisible at Perl
level.</p> </td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Magical and
non-magical variables cannot be distinguished with
&quot;ref&quot;, &quot;tied&quot; or another trick.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="37%">


<p style="margin-top: 1em">Magic is notably faster.</p></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Mainly because
perl&rsquo;s way of handling magic is lighter by nature, and
because there is no need for any method resolution. Also,
since you don&rsquo;t have to reimplement all the variable
semantics, you only pay for what you actually use.</p>

<p style="margin-left:11%; margin-top: 1em">The operations
that can be overloaded are :</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="5%">


<p style="margin-top: 1em"><i>get</i></p></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic is
invoked when the variable is evaluated. It is never called
for arrays and hashes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="5%">


<p style="margin-top: 1em"><i>set</i></p></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic is
called each time the value of the variable changes. It is
called for array subscripts and slices, but never for
hashes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="5%">


<p style="margin-top: 1em"><i>len</i></p></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic only
applies to arrays (though it used to also apply to scalars),
and is triggered when the &rsquo;size&rsquo; or the
&rsquo;length&rsquo; of the variable has to be known by
Perl. This is typically the magic involved when an array is
evaluated in scalar context, but also on array assignment
and loops (&quot;for&quot;, &quot;map&quot; or
&quot;grep&quot;). The length is returned from the callback
as an integer.</p>

<p style="margin-left:17%; margin-top: 1em">Starting from
perl 5.12, this magic is no longer called by the
&quot;length&quot; keyword, and starting from perl 5.17.4 it
is also no longer called for scalars in any situation,
making this magic only meaningful on arrays. You can use the
constants &quot;
<small>VMG_COMPAT_SCALAR_LENGTH_NOLEN&quot;</small> and
&quot; <small>VMG_COMPAT_SCALAR_NOLEN&quot;</small> to see
if this magic is available for scalars or not.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><i>clear</i></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic is
invoked when the variable is reset, such as when an array is
emptied. Please note that this is different from undefining
the variable, even though the magic is called when the
clearing is a result of the undefine (e.g. for an array, but
actually a bug prevent it to work before perl 5.9.5 &minus;
see the history).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em"><i>free</i></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic is
called when a variable is destroyed as the result of going
out of scope (but not when it is undefined). It behaves
roughly like Perl object destructors (i.e.
&quot;DESTROY&quot; methods), except that exceptions thrown
from inside a <i>free</i> callback will always be propagated
to the surrounding code.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em"><i>copy</i></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">When applied to
tied arrays and hashes, this magic fires when you try to
access or change their elements.</p>

<p style="margin-left:17%; margin-top: 1em">Starting from
perl 5.17.0, it can also be applied to closure prototypes,
in which case the magic will be called when the prototype is
cloned. The &quot;
<small>VMG_COMPAT_CODE_COPY_CLONE&quot;</small> constant is
true when your perl support this feature.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="5%">


<p style="margin-top: 1em"><i>dup</i></p></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic is
invoked when the variable is cloned across threads. It is
currently not available.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><i>local</i></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">When this magic
is set on a variable, all subsequent localizations of the
variable will trigger the callback. It is available on your
perl if and only if &quot;MGf_LOCAL&quot; is true.</p>

<p style="margin-left:11%; margin-top: 1em">The following
actions only apply to hashes and are available if and only
if &quot; <small>VMG_UVAR&quot;</small> is true. They are
referred to as <i>uvar</i> magics.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><i>fetch</i></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic is
invoked each time an element is fetched from the hash.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><i>store</i></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This one is
called when an element is stored into the hash.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><i>exists</i></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic
fires when a key is tested for existence in the hash.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><i>delete</i></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This magic is
triggered when a key is deleted in the hash, regardless of
whether the key actually exists in it.</p>

<p style="margin-left:11%; margin-top: 1em">You can refer
to the tests to have more insight of where the different
magics are invoked.</p>

<h2>FUNCTIONS
<a name="FUNCTIONS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&quot;wizard&quot;</b>
<br>
wizard( <br>
data =&gt; sub { ... }, <br>
get =&gt; sub { my ($ref, $data [, $op]) = @_; ... }, <br>
set =&gt; sub { my ($ref, $data [, $op]) = @_; ... }, <br>
len =&gt; sub { <br>
my ($ref, $data, $len [, $op]) = @_; ... ; return $newlen
<br>
}, <br>
clear =&gt; sub { my ($ref, $data [, $op]) = @_; ... }, <br>
free =&gt; sub { my ($ref, $data [, $op]) = @_, ... }, <br>
copy =&gt; sub { my ($ref, $data, $key, $elt [, $op]) = @_;
... }, <br>
local =&gt; sub { my ($ref, $data [, $op]) = @_; ... }, <br>
fetch =&gt; sub { my ($ref, $data, $key [, $op]) = @_; ...
}, <br>
store =&gt; sub { my ($ref, $data, $key [, $op]) = @_; ...
}, <br>
exists =&gt; sub { my ($ref, $data, $key [, $op]) = @_; ...
}, <br>
delete =&gt; sub { my ($ref, $data, $key [, $op]) = @_; ...
}, <br>
copy_key =&gt; $bool, <br>
op_info =&gt; [ 0 | VMG_OP_INFO_NAME | VMG_OP_INFO_OBJECT ],
<br>
)</p>

<p style="margin-left:11%; margin-top: 1em">This function
creates a &rsquo;wizard&rsquo;, an opaque object that holds
the magic information. It takes a list of keys / values as
argument, whose keys can be :</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em">&quot;data&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A code (or
string) reference to a private data constructor. It is
called in scalar context each time the magic is cast onto a
variable, with $_[0] being a reference to this variable and
@_[1 .. @_&minus;1] being all extra arguments that were
passed to &quot;cast&quot;. The scalar returned from this
call is then attached to the variable and can be retrieved
later with &quot;getdata&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">&quot;get&quot;,
&quot;set&quot;, &quot;len&quot;, &quot;clear&quot;,
&quot;free&quot;, &quot;copy&quot;, &quot;local&quot;,
&quot;fetch&quot;, &quot;store&quot;, &quot;exists&quot; and
&quot;delete&quot;</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Code (or
string) references to the respective magic callbacks. You
don&rsquo;t have to specify all of them : the magic
corresponding to undefined entries will simply not be
hooked.</p>

<p style="margin-left:17%; margin-top: 1em">When those
callbacks are executed, $_[0] is a reference to the magic
variable and $_[1] is the associated private data (or
&quot;undef&quot; when no private data constructor is
supplied with the wizard). Other arguments depend on which
kind of magic is involved :</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="11%"></td>
<td width="5%">


<p style="margin-top: 1em"><i>len</i></p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:29%; margin-top: 1em">$_[2] contains
the natural, non-magical length of the variable (which can
only be a scalar or an array as <i>len</i> magic is only
relevant for these types). The callback is expected to
return the new scalar or array length to use, or
&quot;undef&quot; to default to the normal length.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><i>copy</i></p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:29%; margin-top: 1em">When the
variable for which the magic is invoked is an array or an
hash, $_[2] is a either an alias or a copy of the current
key, and $_[3] is an alias to the current element (i.e. the
value). Since $_[2] might be a copy, it is useless to try to
change it or cast magic on it.</p>

<p style="margin-left:29%; margin-top: 1em">Starting from
perl 5.17.0, this magic can also be called for code
references. In this case, $_[2] is always &quot;undef&quot;
and $_[3] is a reference to the cloned anonymous
subroutine.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="11%"></td>
<td width="48%">


<p style="margin-top: 1em"><i>fetch</i>, <i>store</i>,
<i>exists</i> and <i>delete</i></p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:29%; margin-top: 1em">$_[2] is an
alias to the current key. Note that $_[2] may rightfully be
readonly if the key comes from a bareword, and as such it is
unsafe to assign to it. You can ask for a copy instead by
passing &quot;copy_key =&gt; 1&quot; to &quot;wizard&quot;
which, at the price of a small performance hit, allows you
to safely assign to $_[2] in order to e.g. redirect the
action to another key.</p>

<p style="margin-left:17%; margin-top: 1em">Finally, if
&quot;op_info =&gt; $num&quot; is also passed to
&quot;wizard&quot;, then one extra element is appended to
@_. Its nature depends on the value of $num :</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="11%"></td>
<td width="28%">



<p style="margin-top: 1em">&quot;VMG_OP_INFO_NAME&quot;</p> </td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:29%; margin-top: 1em">$_[&minus;1] is
the current op name.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="11%"></td>
<td width="31%">



<p style="margin-top: 1em">&quot;VMG_OP_INFO_OBJECT&quot;</p> </td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:29%; margin-top: 1em">$_[&minus;1] is
the &quot;B::OP&quot; object for the current op.</p>

<p style="margin-left:17%; margin-top: 1em">Both result in
a small performance hit, but just getting the name is
lighter than getting the op object.</p>

<p style="margin-left:17%; margin-top: 1em">These callbacks
are always executed in scalar context. The returned value is
coerced into a signed integer, which is then passed straight
to the perl magic <small>API.</small> However, note that
perl currently only cares about the return value of the
<i>len</i> magic callback and ignores all the others.
Starting with Variable::Magic 0.58, a reference returned
from a non&minus;<i>len</i> magic callback will not be
destroyed immediately but will be allowed to survive until
the end of the statement that triggered the magic. This lets
you use this return value as a token for triggering a
destructor after the original magic action takes place. You
can see an example of this technique in the cookbook.</p>

<p style="margin-left:11%; margin-top: 1em">Each callback
can be specified as :</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">a code reference, which will be
called as a subroutine.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>a string reference, where the string denotes which
subroutine is to be called when magic is triggered. If the
subroutine name is not fully qualified, then the current
package at the time the magic is invoked will be used
instead.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>a reference to &quot;undef&quot;, in which case a no-op
magic callback is installed instead of the default one. This
may especially be helpful for <i>local</i> magic, where an
empty callback prevents magic from being copied during
localization.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that
<i>free</i> magic is never called during global destruction,
as there is no way to ensure that the wizard object and the
callback were not destroyed before the variable.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
simple usage example :</p>

<p style="margin-left:11%; margin-top: 1em"># A simple
scalar tracer <br>
my $wiz = wizard( <br>
get =&gt; sub { print STDERR &quot;got ${$_[0]}\n&quot; },
<br>
set =&gt; sub { print STDERR &quot;set to ${$_[0]}\n&quot;
}, <br>
free =&gt; sub { print STDERR &quot;${$_[0]} was
deleted\n&quot; }, <br>
);</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;cast&quot;</b>
<br>
cast [$@%&amp;*]var, $wiz, @args</p>

<p style="margin-left:11%; margin-top: 1em">This function
associates $wiz magic to the supplied variable, without
overwriting any other kind of magic. It returns true on
success or when $wiz magic is already attached, and croaks
on error. When $wiz provides a data constructor, it is
called just before magic is cast onto the variable, and it
receives a reference to the target variable in $_[0] and the
content of @args in @_[1 .. @args]. Otherwise, @args is
ignored.</p>

<p style="margin-left:11%; margin-top: 1em"># Casts $wiz
onto $x, passing (\$x, '1') to the data constructor. <br>
my $x; <br>
cast $x, $wiz, 1;</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;var&quot; argument can be an array or hash value.
Magic for these scalars behaves like for any other, except
that it is dispelled when the entry is deleted from the
container. For example, if you want to call
&quot;POSIX::tzset&quot; each time the 'TZ' environment
variable is changed in %ENV, you can use :</p>

<p style="margin-left:11%; margin-top: 1em">use POSIX; <br>
cast $ENV{TZ}, wizard set =&gt; sub { POSIX::tzset(); ()
};</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
handle the possible deletion of the 'TZ' entry, you must
also specify <i>store</i> magic.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;getdata&quot;</b>
<br>
getdata [$@%&amp;*]var, $wiz</p>

<p style="margin-left:11%; margin-top: 1em">This accessor
fetches the private data associated with the magic $wiz in
the variable. It croaks when $wiz does not represent a valid
magic object, and returns an empty list if no such magic is
attached to the variable or when the wizard has no data
constructor.</p>

<p style="margin-left:11%; margin-top: 1em"># Get the data
attached to $wiz in $x, or undef if $wiz <br>
# did not attach any. <br>
my $data = getdata $x, $wiz;</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;dispell&quot;</b>
<br>
dispell [$@%&amp;*]variable, $wiz</p>

<p style="margin-left:11%; margin-top: 1em">The exact
opposite of &quot;cast&quot; : it dissociates $wiz magic
from the variable. This function returns true on success, 0
when no magic represented by $wiz could be found in the
variable, and croaks if the supplied wizard is invalid.</p>

<p style="margin-left:11%; margin-top: 1em"># Dispell now.
<br>
die 'no such magic in $x' unless dispell $x, $wiz;</p>

<h2>CONSTANTS
<a name="CONSTANTS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>&quot;MGf_COPY&quot;</b>
<br>
Evaluates to true if and only if the <i>copy</i> magic is
available. This is the case for perl 5.7.3 and greater,
which is ensured by the requirements of this module.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;MGf_DUP&quot;</b>
<br>
Evaluates to true if and only if the <i>dup</i> magic is
available. This is the case for perl 5.7.3 and greater,
which is ensured by the requirements of this module.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;MGf_LOCAL&quot;</b>
<br>
Evaluates to true if and only if the <i>local</i> magic is
available. This is the case for perl 5.9.3 and greater.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_UVAR&quot;</b>
<br>
When this constant is true, you can use the <i>fetch</i>,
<i>store</i>, <i>exists</i> and <i>delete</i> magics on
hashes. Initial &quot; <small>VMG_UVAR&quot;</small>
capability was introduced in perl 5.9.5, with a fully
functional implementation shipped with perl 5.10.0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_SCALAR_LENGTH_NOLEN&quot;</b>
<br>
True for perls that don&rsquo;t call <i>len</i> magic when
taking the &quot;length&quot; of a magical scalar.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_SCALAR_NOLEN&quot;</b>
<br>
True for perls that don&rsquo;t call <i>len</i> magic on
scalars. Implies &quot;
<small>VMG_COMPAT_SCALAR_LENGTH_NOLEN&quot;</small> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_ARRAY_PUSH_NOLEN&quot;</b>
<br>
True for perls that don&rsquo;t call <i>len</i> magic when
you push an element in a magical array. Starting from perl
5.11.0, this only refers to pushes in non-void context and
hence is false.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID&quot;</b>
<br>
True for perls that don&rsquo;t call <i>len</i> magic when
you push in void context an element in a magical array.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID&quot;</b>
<br>
True for perls that don&rsquo;t call <i>len</i> magic when
you unshift in void context an element in a magical
array.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_ARRAY_UNDEF_CLEAR&quot;</b>
<br>
True for perls that call <i>clear</i> magic when undefining
magical arrays.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_HASH_DELETE_NOUVAR_VOID&quot;</b>
<br>
True for perls that don&rsquo;t call <i>delete</i> magic
when you delete an element from a hash in void context.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_CODE_COPY_CLONE&quot;</b>
<br>
True for perls that call <i>copy</i> magic when a magical
closure prototype is cloned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_COMPAT_GLOB_GET&quot;</b>
<br>
True for perls that call <i>get</i> magic for operations on
globs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_PERL_PATCHLEVEL&quot;</b>
<br>
The perl patchlevel this module was built with, or 0 for
non-debugging perls.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_THREADSAFE&quot;</b>
<br>
True if and only if this module could have been built with
thread-safety features enabled.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_FORKSAFE&quot;</b>
<br>
True if and only if this module could have been built with
fork-safety features enabled. This is always true except on
Windows where it is false for perl 5.10.0 and below.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_OP_INFO_NAME&quot;</b>
<br>
Value to pass with &quot;op_info&quot; to get the current op
name in the magic callbacks.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;VMG_OP_INFO_OBJECT&quot;</b>
<br>
Value to pass with &quot;op_info&quot; to get a
&quot;B::OP&quot; object representing the current op in the
magic callbacks.</p>

<h2>COOKBOOK
<a name="COOKBOOK"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Associate an
object to any perl variable</b> <br>
This technique can be useful for passing user data through
limited APIs. It is similar to using inside-out objects, but
without the drawback of having to implement a complex
destructor.</p>

<p style="margin-left:11%; margin-top: 1em">{ <br>
package Magical::UserData; <br>
use Variable::Magic qw&lt;wizard cast getdata&gt;; <br>
my $wiz = wizard data =&gt; sub { \$_[1] }; <br>
sub ud (\[$@%*&amp;]) : lvalue { <br>
my ($var) = @_; <br>
my $data = &amp;getdata($var, $wiz); <br>
unless (defined $data) { <br>
$data = \(my $slot); <br>
&amp;cast($var, $wiz, $slot) <br>
or die &quot;Couldn't cast UserData magic onto the
variable&quot;; <br>
} <br>
$$data; <br>
} <br>
} <br>
{ <br>
BEGIN { *ud = \&amp;Magical::UserData::ud } <br>
my $cb; <br>
$cb = sub { print 'Hello, ', ud(&amp;$cb), &quot;!\n&quot;
}; <br>
ud(&amp;$cb) = 'world'; <br>
$cb&minus;&gt;(); # Hello, world! <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Recursively
cast magic on datastructures</b> <br>
&quot;cast&quot; can be called from any magical callback,
and in particular from &quot;data&quot;. This allows you to
recursively cast magic on datastructures :</p>

<p style="margin-left:11%; margin-top: 1em">my $wiz; <br>
$wiz = wizard data =&gt; sub { <br>
my ($var, $depth) = @_; <br>
$depth ||= 0; <br>
my $r = ref $var; <br>
if ($r eq 'ARRAY') { <br>
&amp;cast((ref() ? $_ : \$_), $wiz, $depth + 1) for @$var;
<br>
} elsif ($r eq 'HASH') { <br>
&amp;cast((ref() ? $_ : \$_), $wiz, $depth + 1) for values
%$var; <br>
} <br>
return $depth; <br>
}, <br>
free =&gt; sub { <br>
my ($var, $depth) = @_; <br>
my $r = ref $var; <br>
print &quot;free $r at depth $depth\n&quot;; <br>
(); <br>
}; <br>
{ <br>
my %h = ( <br>
a =&gt; [ 1, 2 ], <br>
b =&gt; { c =&gt; 3 } <br>
); <br>
cast %h, $wiz; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">When %h goes
out of scope, this prints something among the lines of :</p>

<p style="margin-left:11%; margin-top: 1em">free HASH at
depth 0 <br>
free HASH at depth 1 <br>
free SCALAR at depth 2 <br>
free ARRAY at depth 1 <br>
free SCALAR at depth 3 <br>
free SCALAR at depth 3</p>

<p style="margin-left:11%; margin-top: 1em">Of course, this
example does nothing with the values that are added after
the &quot;cast&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Delayed
magic actions</b> <br>
Starting with Variable::Magic 0.58, the return value of the
magic callbacks can be used to delay the action until after
the original action takes place :</p>

<p style="margin-left:11%; margin-top: 1em">my $delayed;
<br>
my $delayed_aux = wizard( <br>
data =&gt; sub { $_[1] }, <br>
free =&gt; sub { <br>
my ($target) = $_[1]; <br>
my $target_data = &amp;getdata($target, $delayed); <br>
local $target_data&minus;&gt;{guard} = 1; <br>
if (ref $target eq 'SCALAR') { <br>
my $orig = $$target; <br>
$$target =
$target_data&minus;&gt;{mangler}&minus;&gt;($orig); <br>
} <br>
return; <br>
}, <br>
); <br>
$delayed = wizard( <br>
data =&gt; sub { <br>
return +{ guard =&gt; 0, mangler =&gt; $_[1] }; <br>
}, <br>
set =&gt; sub { <br>
return if $_[1]&minus;&gt;{guard}; <br>
my $token; <br>
cast $token, $delayed_aux, $_[0]; <br>
return \$token; <br>
}, <br>
); <br>
my $x = 1; <br>
cast $x, $delayed =&gt; sub { $_[0] * 2 }; <br>
$x = 2; <br>
# $x is now 4 <br>
# But note that the delayed action only takes place at the
end of the <br>
# current statement : <br>
my @y = ($x = 5, $x); <br>
# $x is now 10, but @y is (5, 5)</p>

<h2>PERL MAGIC HISTORY
<a name="PERL MAGIC HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The places
where magic is invoked have changed a bit through perl
history. Here is a little list of the most recent ones.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>5.6.x</b></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><i>p14416</i> :
<i>copy</i> and <i>dup</i> magic.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>5.8.9</b></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><i>p28160</i> :
Integration of <i>p25854</i> (see below).</p>

<p style="margin-left:17%; margin-top: 1em"><i>p32542</i> :
Integration of <i>p31473</i> (see below).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>5.9.3</b></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><i>p25854</i> :
<i>len</i> magic is no longer called when pushing an element
into a magic array.</p>

<p style="margin-left:17%; margin-top: 1em"><i>p26569</i> :
<i>local</i> magic.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><b>5.9.5</b></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><i>p31064</i> :
Meaningful <i>uvar</i> magic.</p>

<p style="margin-left:17%; margin-top: 1em"><i>p31473</i> :
<i>clear</i> magic was not invoked when undefining an array.
The bug is fixed as of this version.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>5.10.0</b></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Since
&quot;PERL_MAGIC_uvar&quot; is uppercased,
&quot;hv_magic_check()&quot; triggers <i>copy</i> magic on
hash stores for (non-tied) hashes that also have <i>uvar</i>
magic.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>5.11.x</b></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"><i>p32969</i> :
<i>len</i> magic is no longer invoked when calling
&quot;length&quot; with a magical scalar.</p>

<p style="margin-left:17%; margin-top: 1em"><i>p34908</i> :
<i>len</i> magic is no longer called when pushing /
unshifting an element into a magical array in void context.
The &quot;push&quot; part was already covered by
<i>p25854</i>.</p>


<p style="margin-left:17%; margin-top: 1em"><i>g9cdcb38b</i>
: <i>len</i> magic is called again when pushing into a
magical array in non-void context.</p>

<h2>EXPORT
<a name="EXPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The functions
&quot;wizard&quot;, &quot;cast&quot;, &quot;getdata&quot;
and &quot;dispell&quot; are only exported on request. All of
them are exported by the tags ':funcs' and ':all'.</p>

<p style="margin-left:11%; margin-top: 1em">All the
constants are also only exported on request, either
individually or by the tags ':consts' and ':all'.</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In order to
hook hash operations with magic, you need at least perl
5.10.0 (see &quot; <small>VMG_UVAR&quot;</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
store a magic object in the private data slot, you will not
be able to recover the magic with &quot;getdata&quot;, since
magic is not copied by assignment. You can work around this
gotcha by storing a reference to the magic object
instead.</p>

<p style="margin-left:11%; margin-top: 1em">If you define a
wizard with <i>free</i> magic and cast it on itself, it
results in a memory cycle, so this destructor will not be
called when the wizard is freed.</p>

<h2>DEPENDENCIES
<a name="DEPENDENCIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perl 5.8.</p>

<p style="margin-left:11%; margin-top: 1em">A C compiler.
This module may happen to build with a C <small>++</small>
compiler as well, but don&rsquo;t rely on it, as no
guarantee is made in this regard.</p>

<p style="margin-left:11%; margin-top: 1em">Carp (core
since perl 5), XSLoader (since 5.6.0).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">perlguts and
perlapi for internal information about magic.</p>

<p style="margin-left:11%; margin-top: 1em">perltie and
overload for other ways of enhancing objects.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Vincent Pit
&quot;&lt;vpit at cpan.org&gt;&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You can contact
me by mail or on &quot;irc.perl.org&quot; (vincent).</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please report
any bugs or feature requests to
&quot;bug&minus;variable&minus;magic at rt.cpan.org&quot;,
or through the web interface at
&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Variable&minus;Magic&gt;.
I will be notified, and then you&rsquo;ll automatically be
notified of progress on your bug as I make changes.</p>

<h2>SUPPORT
<a name="SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You can find
documentation for this module with the perldoc command.</p>

<p style="margin-left:11%; margin-top: 1em">perldoc
Variable::Magic</p>

<h2>COPYRIGHT &amp; LICENSE
<a name="COPYRIGHT &amp; LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2022
Vincent Pit, all rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
