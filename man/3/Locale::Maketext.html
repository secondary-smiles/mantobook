<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:31 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Locale::Maketext</title>

</head>
<body>
<h1>Locale::Maketext</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Locale::Maketext
&minus; framework for localization</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">package
MyProgram; <br>
use strict; <br>
use MyProgram::L10N; <br>
# ...which inherits from Locale::Maketext <br>
my $lh = MyProgram::L10N&minus;&gt;get_handle() || die
&quot;What language?&quot;; <br>
... <br>
# And then any messages your program emits, like: <br>
warn $lh&minus;&gt;maketext( &quot;Can't open file [_1]:
[_2]\n&quot;, $f, $! ); <br>
...</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">It is a common
feature of applications (whether run directly, or via the
Web) for them to be &quot;localized&quot; -- i.e., for them
to a present an English interface to an English-speaker, a
German interface to a German-speaker, and so on for all
languages it&rsquo;s programmed with. Locale::Maketext is a
framework for software localization; it provides you with
the tools for organizing and accessing the bits of text and
text-processing code that you need for producing localized
applications.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
make sense of Maketext and how all its components fit
together, you should probably go read
Locale::Maketext::TPJ13, and <i>then</i> read the following
documentation.</p>

<p style="margin-left:11%; margin-top: 1em">You may also
want to read over the source for &quot;File::Findgrep&quot;
and its constituent modules -- they are a complete (if
small) example application that uses Maketext.</p>

<h2>QUICK OVERVIEW
<a name="QUICK OVERVIEW"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The basic
design of Locale::Maketext is object-oriented, and
Locale::Maketext is an abstract base class, from which you
derive a &quot;project class&quot;. The project class (with
a name like &quot;TkBocciBall::Localize&quot;, which you
then use in your module) is in turn the base class for all
the &quot;language classes&quot; for your project (with
names &quot;TkBocciBall::Localize::it&quot;,
&quot;TkBocciBall::Localize::en&quot;,
&quot;TkBocciBall::Localize::fr&quot;, etc.).</p>

<p style="margin-left:11%; margin-top: 1em">A language
class is a class containing a lexicon of phrases as class
data, and possibly also some methods that are of use in
interpreting phrases in the lexicon, or otherwise dealing
with text in that language.</p>

<p style="margin-left:11%; margin-top: 1em">An object
belonging to a language class is called a &quot;language
handle&quot;; it&rsquo;s typically a flyweight object.</p>

<p style="margin-left:11%; margin-top: 1em">The normal
course of action is to call:</p>

<p style="margin-left:11%; margin-top: 1em">use
TkBocciBall::Localize; # the localization project class <br>
$lh = TkBocciBall::Localize&minus;&gt;get_handle(); <br>
# Depending on the user's locale, etc., this will <br>
# make a language handle from among the classes available,
<br>
# and any defaults that you declare. <br>
die &quot;Couldn't make a language handle??&quot; unless
$lh;</p>

<p style="margin-left:11%; margin-top: 1em">From then on,
you use the &quot;maketext&quot; function to access entries
in whatever lexicon(s) belong to the language handle you
got. So, this:</p>

<p style="margin-left:11%; margin-top: 1em">print
$lh&minus;&gt;maketext(&quot;You won!&quot;),
&quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">...emits the
right text for this language. If the object in $lh belongs
to class &quot;TkBocciBall::Localize::fr&quot; and
%TkBocciBall::Localize::fr::Lexicon contains
&quot;(&quot;You won!&quot; =&gt; &quot;Tu as
gagne!&quot;)&quot;, then the above code happily tells the
user &quot;Tu as gagne!&quot;.</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Locale::Maketext
offers a variety of methods, which fall into three
categories:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Methods to do with constructing language handles.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>&quot;maketext&quot; and other methods to do with
accessing %Lexicon data for a given language handle.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Methods that you may find it handy to use, from routines
of yours that you put in %Lexicon entries.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">These are
covered in the following section.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Construction
Methods</b> <br>
These are to do with constructing a language handle:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">$lh =
YourProjClass&minus;&gt;get_handle( ...langtags... ) || die
&quot;lg-handle?&quot;;</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This tries
loading classes based on the language-tags you give (like
&quot;(&quot;en&minus;US&quot;, &quot;sk&quot;,
&quot;kon&quot;, &quot;es&minus;MX&quot;, &quot;ja&quot;,
&quot;i&minus;klingon&quot;)&quot;, and for the first class
that succeeds, returns
YourProjClass::<i>language</i>&minus;&gt;<b>new()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">If it runs thru
the entire given list of language-tags, and finds no classes
for those exact terms, it then tries
&quot;superordinate&quot; language classes. So if no
&quot;en-US&quot; class (i.e., YourProjClass::en_us) was
found, nor classes for anything else in that list, we then
try its superordinate, &quot;en&quot; (i.e.,
YourProjClass::en), and so on thru the other language-tags
in the given list: &quot;es&quot;. (The other language-tags
in our example list: happen to have no superordinates.)</p>

<p style="margin-left:17%; margin-top: 1em">If none of
those language-tags leads to loadable classes, we then try
classes derived from
YourProjClass&minus;&gt;<b>fallback_languages()</b> and then
if nothing comes of that, we use classes named by
YourProjClass&minus;&gt;<b>fallback_language_classes()</b>.
Then in the (probably quite unlikely) event that that fails,
we just return undef.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">$lh =
YourProjClass&minus;&gt;get_handle<b>()</b> || die
&quot;lg-handle?&quot;;</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">When
&quot;get_handle&quot; is called with an empty parameter
list, magic happens:</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;get_handle&quot; senses that it&rsquo;s running in
program that was invoked as a <small>CGI,</small> then it
tries to get language-tags out of the environment variable
&quot; <small>HTTP_ACCEPT_LANGUAGE&quot;,</small> and it
pretends that those were the languages passed as parameters
to &quot;get_handle&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Otherwise
(i.e., if not a <small>CGI</small> ), this tries various
OS-specific ways to get the language-tags for the current
locale/language, and then pretends that those were the
value(s) passed to &quot;get_handle&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Currently this
OS-specific stuff consists of looking in the environment
variables &quot; <small>LANG&quot;</small> and &quot;
<small>LANGUAGE&quot;</small> ; and on MSWin machines (where
those variables are typically unused), this also tries using
the module Win32::Locale to get a language-tag for whatever
language/locale is currently selected in the &quot;Regional
Settings&quot; (or &quot;International&quot;?) Control
Panel. I welcome further suggestions for making this do the
Right Thing under other operating systems that support
localization.</p>

<p style="margin-left:17%; margin-top: 1em">If you&rsquo;re
using localization in an application that keeps a
configuration file, you might consider something like this
in your project class:</p>

<p style="margin-left:17%; margin-top: 1em">sub
get_handle_via_config { <br>
my $class = $_[0]; <br>
my $chosen_language = $Config_settings{'language'}; <br>
my $lh; <br>
if($chosen_language) { <br>
$lh = $class&minus;&gt;get_handle($chosen_language) <br>
|| die &quot;No language handle for
\&quot;$chosen_language\&quot;&quot; <br>
. &quot; or the like&quot;; <br>
} else { <br>
# Config file missing, maybe? <br>
$lh = $class&minus;&gt;get_handle() <br>
|| die &quot;Can't get a language handle&quot;; <br>
} <br>
return $lh; <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p style="margin-top: 1em">$lh =
YourProjClass::langname&minus;&gt;<b>new()</b>;</p> </td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This constructs
a language handle. You usually <b>don&rsquo;t</b> call this
directly, but instead let &quot;get_handle&quot; find a
language class to &quot;use&quot; and to then call
&minus;&gt;new on.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="18%">



<p style="margin-top: 1em">$lh&minus;&gt;<b>init()</b>;</p> </td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This is called
by &minus;&gt;new to initialize newly-constructed language
handles. If you define an init method in your class,
remember that it&rsquo;s usually considered a good idea to
call $lh&minus;&gt;SUPER::init in it (presumably at the
beginning), so that all classes get a chance to initialize a
new object however they see fit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="54%">



<p style="margin-top: 1em">YourProjClass&minus;&gt;<b>fallback_languages()</b></p> </td>
<td width="29%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;get_handle&quot;
appends the return value of this to the end of whatever list
of languages you pass &quot;get_handle&quot;. Unless you
override this method, your project class will inherit
Locale::Maketext&rsquo;s &quot;fallback_languages&quot;,
which currently returns &quot;('i&minus;default', 'en',
'en&minus;US')&quot;. (&quot;i&minus;default&quot; is
defined in <small>RFC 2277</small> ).</p>

<p style="margin-left:17%; margin-top: 1em">This method (by
having it return the name of a language-tag that has an
existing language class) can be used for making sure that
&quot;get_handle&quot; will always manage to construct a
language handle (assuming your language classes are in an
appropriate @INC directory). Or you can use the next
method:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="65%">



<p style="margin-top: 1em">YourProjClass&minus;&gt;<b>fallback_language_classes()</b></p> </td>
<td width="18%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&quot;get_handle&quot;
appends the return value of this to the end of the list of
classes it will try using. Unless you override this method,
your project class will inherit Locale::Maketext&rsquo;s
&quot;fallback_language_classes&quot;, which currently
returns an empty list, &quot;()&quot;. By setting this to
some value (namely, the name of a loadable language class),
you can be sure that &quot;get_handle&quot; will always
manage to construct a language handle.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The
&quot;maketext&quot; Method</b> <br>
This is the most important method in Locale::Maketext:</p>

<p style="margin-left:11%; margin-top: 1em">$text =
$lh&minus;&gt;maketext(I&lt;key&gt;, ...parameters for this
phrase...);</p>

<p style="margin-left:11%; margin-top: 1em">This looks in
the %Lexicon of the language handle $lh and all its
superclasses, looking for an entry whose key is the string
<i>key</i>. Assuming such an entry is found, various things
then happen, depending on the value found:</p>

<p style="margin-left:11%; margin-top: 1em">If the value is
a scalarref, the scalar is dereferenced and returned (and
any parameters are ignored).</p>

<p style="margin-left:11%; margin-top: 1em">If the value is
a coderef, we return &amp;$value($lh, ...parameters...).</p>

<p style="margin-left:11%; margin-top: 1em">If the value is
a string that <i>doesn&rsquo;t</i> look like it&rsquo;s in
Bracket Notation, we return it (after replacing it with a
scalarref, in its %Lexicon).</p>

<p style="margin-left:11%; margin-top: 1em">If the value
<i>does</i> look like it&rsquo;s in Bracket Notation, then
we compile it into a sub, replace the string in the %Lexicon
with the new coderef, and then we return &amp;$new_sub($lh,
...parameters...).</p>

<p style="margin-left:11%; margin-top: 1em">Bracket
Notation is discussed in a later section. Note that trying
to compile a string into Bracket Notation can throw an
exception if the string is not syntactically valid (say, by
not balancing brackets right.)</p>

<p style="margin-left:11%; margin-top: 1em">Also, calling
&amp;$coderef($lh, ...parameters...) can throw any sort of
exception (if, say, code in that sub tries to divide by
zero). But a very common exception occurs when you have
Bracket Notation text that says to call a method
&quot;foo&quot;, but there is no such method. (E.g.,
&quot;You have [qua<b>tn</b>,_1,ball].&quot; will throw an
exception on trying to call
$lh&minus;&gt;qua<b>tn</b>($_[1],&rsquo;ball&rsquo;) -- you
presumably meant &quot;quant&quot;.) &quot;maketext&quot;
catches these exceptions, but only to make the error message
more readable, at which point it rethrows the exception.</p>

<p style="margin-left:11%; margin-top: 1em">An exception
<i>may</i> be thrown if <i>key</i> is not found in any of
$lh&rsquo;s %Lexicon hashes. What happens if a key is not
found, is discussed in a later section, &quot;Controlling
Lookup Failure&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
might find it useful in some cases to override the
&quot;maketext&quot; method with an &quot;after
method&quot;, if you want to translate encodings, or even
scripts:</p>

<p style="margin-left:11%; margin-top: 1em">package
YrProj::zh_cn; # Chinese with PRC&minus;style glyphs <br>
use base ('YrProj::zh_tw'); # Taiwan&minus;style <br>
sub maketext { <br>
my $self = shift(@_); <br>
my $value = $self&minus;&gt;maketext(@_); <br>
return Chineeze::taiwan2mainland($value); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Or you may want
to override it with something that traps any exceptions, if
that&rsquo;s critical to your program:</p>

<p style="margin-left:11%; margin-top: 1em">sub maketext {
<br>
my($lh, @stuff) = @_; <br>
my $out; <br>
eval { $out = $lh&minus;&gt;SUPER::maketext(@stuff) }; <br>
return $out unless $@; <br>
...otherwise deal with the exception... <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Other than
those two situations, I don&rsquo;t imagine that it&rsquo;s
useful to override the &quot;maketext&quot; method. (If you
run into a situation where it is useful, I&rsquo;d be
interested in hearing about it.) <br>
$lh&minus;&gt;fail_with <i>or</i> $lh&minus;&gt;fail_with(
<i><small>PARAM</small></i> ) <br>
$lh&minus;&gt;failure_handler_auto</p>

<p style="margin-left:17%;">These two methods are discussed
in the section &quot;Controlling Lookup Failure&quot;.</p>

<p style="margin-left:11%;">$lh&minus;&gt;denylist(@list)
&lt;or&gt; $lh&minus;&gt;blacklist(@list) <br>
$lh&minus;&gt;allowlist(@list) &lt;or&gt;
$lh&minus;&gt;whitelist(@list)</p>

<p style="margin-left:17%;">These methods are discussed in
the section &quot;Bracket Notation Security&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Utility
Methods</b> <br>
These are methods that you may find it handy to use,
generally from %Lexicon routines of yours (whether expressed
as Bracket Notation or not). <br>
$language&minus;&gt;quant($number, $singular) <br>
$language&minus;&gt;quant($number, $singular, $plural) <br>
$language&minus;&gt;quant($number, $singular, $plural,
$negative)</p>

<p style="margin-left:17%;">This is generally meant to be
called from inside Bracket Notation (which is discussed
later), as in</p>

<p style="margin-left:17%; margin-top: 1em">&quot;Your
search matched [quant,_1,document]!&quot;</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s for
<i>quantifying</i> a noun (i.e., saying how much of it there
is, while giving the correct form of it). The behavior of
this method is handy for English and a few other Western
European languages, and you should override it for languages
where it&rsquo;s not suitable. You can feel free to read the
source, but the current implementation is basically as this
pseudocode describes:</p>

<p style="margin-left:17%; margin-top: 1em">if $number is 0
and there's a $negative, <br>
return $negative; <br>
elsif $number is 1, <br>
return &quot;1 $singular&quot;; <br>
elsif there's a $plural, <br>
return &quot;$number $plural&quot;; <br>
else <br>
return &quot;$number &quot; . $singular . &quot;s&quot;;
<br>
# <br>
# ...except that we actually call numf to <br>
# stringify $number before returning it.</p>

<p style="margin-left:17%; margin-top: 1em">So for English
(with Bracket Notation) &quot;...[quant,_1,file]...&quot; is
fine (for 0 it returns &quot;0 files&quot;, for 1 it returns
&quot;1 file&quot;, and for more it returns &quot;2
files&quot;, etc.)</p>

<p style="margin-left:17%; margin-top: 1em">But for
&quot;directory&quot;, you&rsquo;d want
&quot;[quant,_1,directory,directories]&quot; so that our
elementary &quot;quant&quot; method doesn&rsquo;t think that
the plural of &quot;directory&quot; is
&quot;directorys&quot;. And you might find that the output
may sound better if you specify a negative form, as in:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;[quant,_1,file,files,No
files] matched your query.\n&quot;</p>

<p style="margin-left:17%; margin-top: 1em">Remember to
keep in mind verb agreement (or adjectives too, in other
languages), as in:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;[quant,_1,document]
were matched.\n&quot;</p>

<p style="margin-left:17%; margin-top: 1em">Because if _1
is one, you get &quot;1 document <b>were</b> matched&quot;.
An acceptable hack here is to do something like this:</p>


<p style="margin-left:17%; margin-top: 1em">&quot;[quant,_1,document
was, documents were] matched.\n&quot;</p>


<p style="margin-left:11%;">$language&minus;&gt;numf($number)</p>

<p style="margin-left:17%;">This returns the given number
formatted nicely according to this language&rsquo;s
conventions. Maketext&rsquo;s default method is mostly to
just take the normal string form of the number (applying
sprintf &quot;%G&quot; for only very large numbers), and
then to add commas as necessary. (Except that we apply
&quot;tr/,./.,/&quot; if
$language&minus;&gt;{&rsquo;numf_comma&rsquo;} is true;
that&rsquo;s a bit of a hack that&rsquo;s useful for
languages that express two million as &quot;2.000.000&quot;
and not as &quot;2,000,000&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">If you want
anything fancier, consider overriding this with something
that uses Number::Format, or does something else
entirely.</p>

<p style="margin-left:17%; margin-top: 1em">Note that numf
is called by quant for stringifying all quantifying
numbers.</p>


<p style="margin-left:11%;">$language&minus;&gt;numerate($number,
$singular, $plural, $negative)</p>

<p style="margin-left:17%;">This returns the given noun
form which is appropriate for the quantity $number according
to this language&rsquo;s conventions. &quot;numerate&quot;
is used internally by &quot;quant&quot; to quantify nouns.
Use it directly -- usually from bracket notation -- to avoid
&quot;quant&quot;&rsquo;s implicit call to &quot;numf&quot;
and output of a numeric quantity.</p>


<p style="margin-left:11%;">$language&minus;&gt;sprintf($format,
@items)</p>

<p style="margin-left:17%;">This is just a wrapper around
Perl&rsquo;s normal &quot;sprintf&quot; function. It&rsquo;s
provided so that you can use &quot;sprintf&quot; in Bracket
Notation:</p>

<p style="margin-left:17%; margin-top: 1em">&quot;Couldn't
access datanode [sprintf,%10x=~[%s~],_1,_2]!\n&quot;</p>


<p style="margin-left:17%; margin-top: 1em">returning...</p>

<p style="margin-left:17%; margin-top: 1em">Couldn't access
datanode Stuff=[thangamabob]!</p>


<p style="margin-left:11%;">$language&minus;&gt;<b>language_tag()</b></p>

<p style="margin-left:17%;">Currently this just takes the
last bit of &quot;ref($language)&quot;, turns underscores to
dashes, and returns it. So if $language is an object of
class Hee::HOO::Haw::en_us,
$language&minus;&gt;<b>language_tag()</b> returns
&quot;en-us&quot;. (Yes, the usual representation for that
language tag is &quot;en-US&quot;, but case is <i>never</i>
considered meaningful in language-tag comparison.)</p>

<p style="margin-left:17%; margin-top: 1em">You may
override this as you like; Maketext doesn&rsquo;t use it for
anything.</p>


<p style="margin-left:11%;">$language&minus;&gt;<b>encoding()</b></p>

<p style="margin-left:17%;">Currently this isn&rsquo;t used
for anything, but it&rsquo;s provided (with default value of
&quot;(ref($language) &amp;&amp;
$language&minus;&gt;{'encoding'})) or
&quot;iso&minus;8859&minus;1&quot;&quot; ) as a sort of
suggestion that it may be useful/necessary to associate
encodings with your language handles (whether on a per-class
or even per-handle basis.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Language
Handle Attributes and Internals</b> <br>
A language handle is a flyweight object -- i.e., it
doesn&rsquo;t (necessarily) carry any data of interest,
other than just being a member of whatever class it belongs
to.</p>

<p style="margin-left:11%; margin-top: 1em">A language
handle is implemented as a blessed hash. Subclasses of yours
can store whatever data you want in the hash. Currently the
only hash entry used by any crucial Maketext method is
&quot;fail&quot;, so feel free to use anything else as you
like.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Remember:
Don&rsquo;t be afraid to read the Maketext source if
there&rsquo;s any point on which this documentation is
unclear.</b> This documentation is vastly longer than the
module source itself.</p>

<h2>LANGUAGE CLASS HIERARCHIES
<a name="LANGUAGE CLASS HIERARCHIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These are
Locale::Maketext&rsquo;s assumptions about the class
hierarchy formed by all your language classes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You must have a project base class, which you load, and
which you then use as the first argument in the call to
YourProjClass&minus;&gt;get_handle(...). It should derive
(whether directly or indirectly) from Locale::Maketext. It
<b>doesn&rsquo;t matter</b> how you name this class,
although assuming this is the localization component of your
Super Mega Program, good names for your project class might
be SuperMegaProgram::Localization, SuperMegaProgram::L10N,
SuperMegaProgram::I18N, SuperMegaProgram::International, or
even SuperMegaProgram::Languages or
SuperMegaProgram::Messages.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Language classes are what
YourProjClass&minus;&gt;get_handle will try to load. It will
look for them by taking each language-tag (<b>skipping</b>
it if it doesn&rsquo;t look like a language-tag or
locale-tag!), turning it to all lowercase, turning dashes to
underscores, and appending it to YourProjClass .
&quot;::&quot;. So this:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">$lh =
YourProjClass&minus;&gt;get_handle( <br>
'en&minus;US', 'fr', 'kon', 'i&minus;klingon',
'i&minus;klingon&minus;romanized' <br>
);</p>

<p style="margin-left:17%; margin-top: 1em">will try
loading the classes YourProjClass::en_us (note lowercase!),
YourProjClass::fr, YourProjClass::kon,
YourProjClass::i_klingon and
YourProjClass::i_klingon_romanized. (And it&rsquo;ll stop at
the first one that actually loads.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">I assume that each language
class derives (directly or indirectly) from your project
class, and also defines its @ISA, its %Lexicon, or both. But
I anticipate no dire consequences if these assumptions do
not hold.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Language classes may derive from other language classes
(although they should have &quot;use
<i>Thatclassname</i>&quot; or &quot;use base
qw(<i>...classes...</i>)&quot;). They may derive from the
project class. They may derive from some other class
altogether. Or via multiple inheritance, it may derive from
any mixture of these.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>I foresee no problems with having multiple inheritance
in your hierarchy of language classes. (As usual, however,
Perl will complain bitterly if you have a cycle in the
hierarchy: i.e., if any class is its own ancestor.)</p></td></tr>
</table>

<h2>ENTRIES IN EACH LEXICON
<a name="ENTRIES IN EACH LEXICON"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A typical
%Lexicon entry is meant to signify a phrase, taking some
number (0 or more) of parameters. An entry is meant to be
accessed by via a string <i>key</i> in
$lh&minus;&gt;maketext(<i>key</i>, ...parameters...), which
should return a string that is generally meant for be used
for &quot;output&quot; to the user -- regardless of whether
this actually means printing to <small>STDOUT,</small>
writing to a file, or putting into a <small>GUI</small>
widget.</p>

<p style="margin-left:11%; margin-top: 1em">While the key
must be a string value (since that&rsquo;s a basic
restriction that Perl places on hash keys), the value in the
lexicon can currently be of several types: a defined scalar,
scalarref, or coderef. The use of these is explained above,
in the section &rsquo;The &quot;maketext&quot;
Method&rsquo;, and Bracket Notation for strings is discussed
in the next section.</p>

<p style="margin-left:11%; margin-top: 1em">While you can
use arbitrary unique IDs for lexicon keys (like
&quot;_min_larger_max_error&quot;), it is often useful for
if an entry&rsquo;s key is itself a valid value, like this
example error message:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Minimum
([_1]) is larger than maximum ([_2])!\n&quot;,</p>

<p style="margin-left:11%; margin-top: 1em">Compare this
code that uses an arbitrary <small>ID...</small></p>

<p style="margin-left:11%; margin-top: 1em">die
$lh&minus;&gt;maketext( &quot;_min_larger_max_error&quot;,
$min, $max ) <br>
if $min &gt; $max;</p>

<p style="margin-left:11%; margin-top: 1em">...to this code
that uses a key-as-value:</p>

<p style="margin-left:11%; margin-top: 1em">die
$lh&minus;&gt;maketext( <br>
&quot;Minimum ([_1]) is larger than maximum ([_2])!\n&quot;,
<br>
$min, $max <br>
) if $min &gt; $max;</p>

<p style="margin-left:11%; margin-top: 1em">The second is,
in short, more readable. In particular, it&rsquo;s obvious
that the number of parameters you&rsquo;re feeding to that
phrase (two) is the number of parameters that it
<i>wants</i> to be fed. (Since you see _1 and a _2 being
used in the key there.)</p>

<p style="margin-left:11%; margin-top: 1em">Also, once a
project is otherwise complete and you start to localize it,
you can scrape together all the various keys you use, and
pass it to a translator; and then the translator&rsquo;s
work will go faster if what he&rsquo;s presented is
this:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Minimum
([_1]) is larger than maximum ([_2])!\n&quot;, <br>
=&gt; &quot;&quot;, # fill in something here, Jacques!</p>

<p style="margin-left:11%; margin-top: 1em">rather than
this more cryptic mess:</p>


<p style="margin-left:11%; margin-top: 1em">&quot;_min_larger_max_error&quot;
<br>
=&gt; &quot;&quot;, # fill in something here, Jacques</p>

<p style="margin-left:11%; margin-top: 1em">I think that
keys as lexicon values makes the completed lexicon entries
more readable:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Minimum
([_1]) is larger than maximum ([_2])!\n&quot;, <br>
=&gt; &quot;Le minimum ([_1]) est plus grand que le maximum
([_2])!\n&quot;,</p>

<p style="margin-left:11%; margin-top: 1em">Also, having
valid values as keys becomes very useful if you set up an
_AUTO lexicon. _AUTO lexicons are discussed in a later
section.</p>

<p style="margin-left:11%; margin-top: 1em">I almost always
use keys that are themselves valid lexicon values. One
notable exception is when the value is quite long. For
example, to get the screenful of data that a command-line
program might return when given an unknown switch, I often
just use a brief, self-explanatory key such as
&quot;_USAGE_MESSAGE&quot;. At that point I then go and
immediately to define that lexicon entry in the
ProjectClass::L10N::en lexicon (since English is always my
&quot;project language&quot;):</p>


<p style="margin-left:11%; margin-top: 1em">'_USAGE_MESSAGE'
=&gt; &lt;&lt;'EOSTUFF', <br>
...long long message... <br>
EOSTUFF</p>

<p style="margin-left:11%; margin-top: 1em">and then I can
use it as:</p>

<p style="margin-left:11%; margin-top: 1em">getopt('oDI',
\%opts) or die $lh&minus;&gt;maketext('_USAGE_MESSAGE');</p>

<p style="margin-left:11%; margin-top: 1em">Incidentally,
note that each class&rsquo;s %Lexicon inherits-and-extends
the lexicons in its superclasses. This is not because these
are special hashes <i>per se</i>, but because you access
them via the &quot;maketext&quot; method, which looks for
entries across all the %Lexicon hashes in a language class
<i>and</i> all its ancestor classes. (This is because the
idea of &quot;class data&quot; isn&rsquo;t directly
implemented in Perl, but is instead left to individual
class-systems to implement as they see fit..)</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
may have things stored in a lexicon besides just phrases for
output: for example, if your program takes input from the
keyboard, asking a &quot;(Y/N)&quot; question, you probably
need to know what the equivalent of &quot;Y[es]/N[o]&quot;
is in whatever language. You probably also need to know what
the equivalents of the answers &quot;y&quot; and
&quot;n&quot; are. You can store that information in the
lexicon (say, under the keys &quot;~answer_y&quot; and
&quot;~answer_n&quot;, and the long forms as
&quot;~answer_yes&quot; and &quot;~answer_no&quot;, where
&quot;~&quot; is just an ad-hoc character meant to indicate
to programmers/translators that these are not phrases for
output).</p>

<p style="margin-left:11%; margin-top: 1em">Or instead of
storing this in the language class&rsquo;s lexicon, you can
(and, in some cases, really should) represent the same bit
of knowledge as code in a method in the language class.
(That leaves a tidy distinction between the lexicon as the
things we know how to <i>say</i>, and the rest of the things
in the lexicon class as things that we know how to
<i>do</i>.) Consider this example of a processor for
responses to French &quot;oui/non&quot; questions:</p>

<p style="margin-left:11%; margin-top: 1em">sub y_or_n {
<br>
return undef unless defined $_[1] and length $_[1]; <br>
my $answer = lc $_[1]; # smash case <br>
return 1 if $answer eq 'o' or $answer eq 'oui'; <br>
return 0 if $answer eq 'n' or $answer eq 'non'; <br>
return undef; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">...which
you&rsquo;d then call in a construct like this:</p>

<p style="margin-left:11%; margin-top: 1em">my $response;
<br>
until(defined $response) { <br>
print $lh&minus;&gt;maketext(&quot;Open the pod bay door
(y/n)? &quot;); <br>
$response = $lh&minus;&gt;y_or_n(
get_input_from_keyboard_somehow() ); <br>
} <br>
if($response) { $pod_bay_door&minus;&gt;open() } <br>
else { $pod_bay_door&minus;&gt;leave_closed() }</p>

<p style="margin-left:11%; margin-top: 1em">Other data
worth storing in a lexicon might be things like filenames
for language-targetted resources:</p>

<p style="margin-left:11%; margin-top: 1em">... <br>
&quot;_main_splash_png&quot; <br>
=&gt; &quot;/styles/en_us/main_splash.png&quot;, <br>
&quot;_main_splash_imagemap&quot; <br>
=&gt; &quot;/styles/en_us/main_splash.incl&quot;, <br>
&quot;_general_graphics_path&quot; <br>
=&gt; &quot;/styles/en_us/&quot;, <br>
&quot;_alert_sound&quot; <br>
=&gt; &quot;/styles/en_us/hey_there.wav&quot;, <br>
&quot;_forward_icon&quot; <br>
=&gt; &quot;left_arrow.png&quot;, <br>
&quot;_backward_icon&quot; <br>
=&gt; &quot;right_arrow.png&quot;, <br>
# In some other languages, left equals <br>
# BACKwards, and right is FOREwards. <br>
...</p>

<p style="margin-left:11%; margin-top: 1em">You might want
to do the same thing for expressing key bindings or the like
(since hardwiring &quot;q&quot; as the binding for the
function that quits a screen/menu/program is useful only if
your language happens to associate &quot;q&quot; with
&quot;quit&quot;!)</p>

<h2>BRACKET NOTATION
<a name="BRACKET NOTATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Bracket
Notation is a crucial feature of Locale::Maketext. I mean
Bracket Notation to provide a replacement for the use of
sprintf formatting. Everything you do with Bracket Notation
could be done with a sub block, but bracket notation is
meant to be much more concise.</p>

<p style="margin-left:11%; margin-top: 1em">Bracket
Notation is a like a miniature &quot;template&quot; system
(in the sense of Text::Template, not in the sense of C
<small>++</small> templates), where normal text is passed
thru basically as is, but text in special regions is
specially interpreted. In Bracket Notation, you use square
brackets (&quot;[...]&quot;), not curly braces
(&quot;{...}&quot;) to note sections that are specially
interpreted.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
here all the areas that are taken literally are underlined
with a &quot;^&quot;, and all the in-bracket special regions
are underlined with an X:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Minimum
([_1]) is larger than maximum ([_2])!\n&quot;, <br>
^^^^^^^^^ XX ^^^^^^^^^^^^^^^^^^^^^^^^^^ XX ^^^^</p>

<p style="margin-left:11%; margin-top: 1em">When that
string is compiled from bracket notation into a real Perl
sub, it&rsquo;s basically turned into:</p>

<p style="margin-left:11%; margin-top: 1em">sub { <br>
my $lh = $_[0]; <br>
my @params = @_; <br>
return join '', <br>
&quot;Minimum (&quot;, <br>
...some code here... <br>
&quot;) is larger than maximum (&quot;, <br>
...some code here... <br>
&quot;)!\n&quot;, <br>
} <br>
# to be called by $lh&minus;&gt;maketext(KEY, params...)</p>

<p style="margin-left:11%; margin-top: 1em">In other words,
text outside bracket groups is turned into string literals.
Text in brackets is rather more complex, and currently
follows these rules:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Bracket groups that are empty,
or which consist only of whitespace, are ignored. (Examples:
&quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns
and/or tabs and/or spaces between them.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Otherwise, each
group is taken to be a comma-separated group of items, and
each item is interpreted as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">An item that is
&quot;_<i>digits</i>&quot; or
&quot;_&minus;<i>digits</i>&quot; is interpreted as
$_[<i>value</i>]. I.e., &quot;_1&quot; becomes with $_[1],
and &quot;_&minus;3&quot; is interpreted as $_[&minus;3] (in
which case @_ should have at least three elements in it).
Note that $_[0] is the language handle, and is typically not
named directly.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>An item &quot;_*&quot; is interpreted to mean &quot;all
of @_ except $_[0]&quot;. I.e., @_[1..$#_]. Note that this
is an empty list in the case of calls like
$lh&minus;&gt;maketext(<i>key</i>) where there are no
parameters (except $_[0], the language handle).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Otherwise, each item is interpreted as a string
literal.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The group as a
whole is interpreted as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If the first item in a bracket
group looks like a method name, then that group is
interpreted like this:</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">$lh&minus;&gt;that_method_name(
<br>
...rest of items in this group... <br>
),</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If the first item in a bracket
group is &quot;*&quot;, it&rsquo;s taken as shorthand for
the so commonly called &quot;quant&quot; method. Similarly,
if the first item in a bracket group is &quot;#&quot;,
it&rsquo;s taken to be shorthand for &quot;numf&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If the first item in a bracket group is the
empty-string, or &quot;_*&quot; or
&quot;_<i>digits</i>&quot; or
&quot;_&minus;<i>digits</i>&quot;, then that group is
interpreted as just the interpolation of all its items:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">join('', <br>
...rest of items in this group... <br>
),</p>

<p style="margin-left:17%; margin-top: 1em">Examples:
&quot;[_1]&quot; and &quot;[,_1]&quot;, which are
synonymous; and
&quot;&quot;[,ID&minus;(,_4,&minus;,_2,)]&quot;&quot;, which
compiles as &quot;join &quot;&quot;, &quot;ID&minus;(&quot;,
$_[4], &quot;&minus;&quot;, $_[2], &quot;)&quot;&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Otherwise this bracket group is
invalid. For example, in the group
&quot;[!@#,whatever]&quot;, the first item &quot;!@#&quot;
is neither the empty-string, &quot;_<i>number</i>&quot;,
&quot;_&minus;<i>number</i>&quot;, &quot;_*&quot;, nor a
valid method name; and so Locale::Maketext will throw an
exception of you try compiling an expression containing this
bracket group.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note,
incidentally, that items in each group are comma-separated,
not &quot;/\s*,\s*/&quot;&minus;separated. That is, you
might expect that this bracket group:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Hoohah
[foo, _1 , bar ,baz]!&quot;</p>

<p style="margin-left:11%; margin-top: 1em">would compile
to this:</p>

<p style="margin-left:11%; margin-top: 1em">sub { <br>
my $lh = $_[0]; <br>
return join '', <br>
&quot;Hoohah &quot;, <br>
$lh&minus;&gt;foo( $_[1], &quot;bar&quot;, &quot;baz&quot;),
<br>
&quot;!&quot;, <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">But it actually
compiles as this:</p>

<p style="margin-left:11%; margin-top: 1em">sub { <br>
my $lh = $_[0]; <br>
return join '', <br>
&quot;Hoohah &quot;, <br>
$lh&minus;&gt;foo(&quot; _1 &quot;, &quot; bar &quot;,
&quot;baz&quot;), # note the &lt;space&gt; in &quot; bar
&quot; <br>
&quot;!&quot;, <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">In the notation
discussed so far, the characters &quot;[&quot; and
&quot;]&quot; are given special meaning, for opening and
closing bracket groups, and &quot;,&quot; has a special
meaning inside bracket groups, where it separates items in
the group. This begs the question of how you&rsquo;d express
a literal &quot;[&quot; or &quot;]&quot; in a Bracket
Notation string, and how you&rsquo;d express a literal comma
inside a bracket group. For this purpose I&rsquo;ve adopted
&quot;~&quot; (tilde) as an escape character: &quot;~[&quot;
means a literal &rsquo;[&rsquo; character anywhere in
Bracket Notation (i.e., regardless of whether you&rsquo;re
in a bracket group or not), and ditto for &quot;~]&quot;
meaning a literal &rsquo;]&rsquo;, and &quot;~,&quot;
meaning a literal comma. (Altho &quot;,&quot; means a
literal comma outside of bracket groups -- it&rsquo;s only
inside bracket groups that commas are special.)</p>

<p style="margin-left:11%; margin-top: 1em">And on the off
chance you need a literal tilde in a bracket expression, you
get it with &quot;~~&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Currently, an
unescaped &quot;~&quot; before a character other than a
bracket or a comma is taken to mean just a &quot;~&quot; and
that character. I.e., &quot;~X&quot; means the same as
&quot;~~X&quot; -- i.e., one literal tilde, and then one
literal &quot;X&quot;. However, by using &quot;~X&quot;, you
are assuming that no future version of Maketext will use
&quot;~X&quot; as a magic escape sequence. In practice this
is not a great problem, since first off you can just write
&quot;~~X&quot; and not worry about it; second off, I doubt
I&rsquo;ll add lots of new magic characters to bracket
notation; and third off, you aren&rsquo;t likely to want
literal &quot;~&quot; characters in your messages anyway,
since it&rsquo;s not a character with wide use in natural
language text.</p>

<p style="margin-left:11%; margin-top: 1em">Brackets must
be balanced -- every openbracket must have one matching
closebracket, and vice versa. So these are all
<b>invalid</b>:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;I ate
[quant,_1,rhubarb pie.&quot; <br>
&quot;I ate [quant,_1,rhubarb pie[.&quot; <br>
&quot;I ate quant,_1,rhubarb pie].&quot; <br>
&quot;I ate quant,_1,rhubarb pie[.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Currently,
bracket groups do not nest. That is, you <b>cannot</b>
say:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Foo
[bar,baz,[quux,quuux]]\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If you need a
notation that&rsquo;s that powerful, use normal Perl:</p>

<p style="margin-left:11%; margin-top: 1em">%Lexicon = (
<br>
... <br>
&quot;some_key&quot; =&gt; sub { <br>
my $lh = $_[0]; <br>
join '', <br>
&quot;Foo &quot;, <br>
$lh&minus;&gt;bar('baz', $lh&minus;&gt;quux('quuux')), <br>
&quot;\n&quot;, <br>
}, <br>
... <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Or write the
&quot;bar&quot; method so you don&rsquo;t need to pass it
the output from calling quux.</p>

<p style="margin-left:11%; margin-top: 1em">I do not
anticipate that you will need (or particularly want) to nest
bracket groups, but you are welcome to email me with
convincing (real-life) arguments to the contrary.</p>

<h2>BRACKET NOTATION SECURITY
<a name="BRACKET NOTATION SECURITY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Locale::Maketext
does not use any special syntax to differentiate bracket
notation methods from normal class or object methods. This
design makes it vulnerable to format string attacks whenever
it is used to process strings provided by untrusted
users.</p>


<p style="margin-left:11%; margin-top: 1em">Locale::Maketext
does support denylist and allowlist functionality to limit
which methods may be called as bracket notation methods.</p>

<p style="margin-left:11%; margin-top: 1em">By default,
Locale::Maketext denies all methods in the Locale::Maketext
namespace that begin with the &rsquo;_&rsquo; character, and
all methods which include Perl&rsquo;s namespace separator
characters.</p>

<p style="margin-left:11%; margin-top: 1em">The default
denylist for Locale::Maketext also prevents use of the
following methods in bracket notation:</p>

<p style="margin-left:11%; margin-top: 1em">denylist <br>
encoding <br>
fail_with <br>
failure_handler_auto <br>
fallback_language_classes <br>
fallback_languages <br>
get_handle <br>
init <br>
language_tag <br>
maketext <br>
new <br>
allowlist <br>
whitelist <br>
blacklist</p>

<p style="margin-left:11%; margin-top: 1em">This list can
be extended by either deny-listing additional &quot;known
bad&quot; methods, or allow-listing only &quot;known
good&quot; methods.</p>

<p style="margin-left:11%; margin-top: 1em">To prevent
specific methods from being called in bracket notation, use
the <b>denylist()</b> method:</p>

<p style="margin-left:11%; margin-top: 1em">my $lh =
MyProgram::L10N&minus;&gt;get_handle(); <br>
$lh&minus;&gt;denylist(qw{my_internal_method
my_other_method}); <br>
$lh&minus;&gt;maketext('[my_internal_method]'); # dies</p>

<p style="margin-left:11%; margin-top: 1em">To limit the
allowed bracked notation methods to a specific list, use the
<b>allowlist()</b> method:</p>

<p style="margin-left:11%; margin-top: 1em">my $lh =
MyProgram::L10N&minus;&gt;get_handle(); <br>
$lh&minus;&gt;allowlist('numerate', 'numf'); <br>
$lh&minus;&gt;maketext('[_1] [numerate, _1,shoe,shoes]',
12); # works <br>
$lh&minus;&gt;maketext('[my_internal_method]'); # dies</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>denylist()</b> and <b>allowlist()</b> methods extend
their internal lists whenever they are called. To reset the
denylist or allowlist, create a new maketext object.</p>

<p style="margin-left:11%; margin-top: 1em">my $lh =
MyProgram::L10N&minus;&gt;get_handle(); <br>
$lh&minus;&gt;denylist('numerate'); <br>
$lh&minus;&gt;denylist('numf'); <br>
$lh&minus;&gt;maketext('[_1] [numerate,_1,shoe,shoes]', 12);
# dies</p>

<p style="margin-left:11%; margin-top: 1em">For lexicons
that use an internal cache, translations which have already
been cached in their compiled form are not affected by
subsequent changes to the allowlist or denylist settings.
Lexicons that use an external cache will have their cache
cleared whenever the allowlist or denylist settings change.
The difference between the two types of caching is explained
in the &quot;Readonly Lexicons&quot; section.</p>

<p style="margin-left:11%; margin-top: 1em">Methods
disallowed by the denylist cannot be permitted by the
allowlist.</p>


<p style="margin-left:11%; margin-top: 1em"><small>NOTE:</small>
<b>denylist()</b> is the preferred method name to use
instead of the historical and non-inclusive method
<b>blacklist()</b>. <b>blacklist()</b> may be removed in a
future release of this package and so it&rsquo;s use should
be removed from usage.</p>


<p style="margin-left:11%; margin-top: 1em"><small>NOTE:</small>
<b>allowlist()</b> is the preferred method name to use
instead of the historical and non-inclusive method
<b>whitelist()</b>. <b>whitelist()</b> may be removed in a
future release of this package and so it&rsquo;s use should
be removed from usage.</p>

<h2>AUTO LEXICONS
<a name="AUTO LEXICONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If maketext
goes to look in an individual %Lexicon for an entry for
<i>key</i> (where <i>key</i> does not start with an
underscore), and sees none, <b>but does see</b> an entry of
&quot;_AUTO&quot; =&gt; <i>some_true_value</i>, then we
actually define $Lexicon{<i>key</i>} = <i>key</i> right then
and there, and then use that value as if it had been there
all along. This happens before we even look in any
superclass %Lexicons!</p>

<p style="margin-left:11%; margin-top: 1em">(This is meant
to be somewhat like the <small>AUTOLOAD</small> mechanism in
Perl&rsquo;s function call system -- or, looked at another
way, like the AutoLoader module.)</p>

<p style="margin-left:11%; margin-top: 1em">I can picture
all sorts of circumstances where you just do not want lookup
to be able to fail (since failing normally means that
maketext throws a &quot;die&quot;, although see the next
section for greater control over that). But here&rsquo;s one
circumstance where _AUTO lexicons are meant to be
<i>especially</i> useful:</p>

<p style="margin-left:11%; margin-top: 1em">As you&rsquo;re
writing an application, you decide as you go what messages
you need to emit. Normally you&rsquo;d go to write this:</p>

<p style="margin-left:11%; margin-top: 1em">if(&minus;e
$filename) { <br>
go_process_file($filename) <br>
} else { <br>
print qq{Couldn't find file &quot;$filename&quot;!\n}; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">but since you
anticipate localizing this, you write:</p>

<p style="margin-left:11%; margin-top: 1em">use
ThisProject::I18N; <br>
my $lh = ThisProject::I18N&minus;&gt;get_handle(); <br>
# For the moment, assume that things are set up so <br>
# that we load class ThisProject::I18N::en <br>
# and that that's the class that $lh belongs to. <br>
... <br>
if(&minus;e $filename) { <br>
go_process_file($filename) <br>
} else { <br>
print $lh&minus;&gt;maketext( <br>
qq{Couldn't find file &quot;[_1]&quot;!\n}, $filename <br>
); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now, right
after you&rsquo;ve just written the above lines, you&rsquo;d
normally have to go open the file ThisProject/I18N/en.pm,
and immediately add an entry:</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Couldn't
find file \&quot;[_1]\&quot;!\n&quot; <br>
=&gt; &quot;Couldn't find file
\&quot;[_1]\&quot;!\n&quot;,</p>

<p style="margin-left:11%; margin-top: 1em">But I consider
that somewhat of a distraction from the work of getting the
main code working -- to say nothing of the fact that I often
have to play with the program a few times before I can
decide exactly what wording I want in the messages (which in
this case would require me to go changing three lines of
code: the call to maketext with that key, and then the two
lines in ThisProject/I18N/en.pm).</p>

<p style="margin-left:11%; margin-top: 1em">However, if you
set &quot;_AUTO =&gt; 1&quot; in the %Lexicon in,
ThisProject/I18N/en.pm (assuming that English (en) is the
language that all your programmers will be using for this
project&rsquo;s internal message keys), then you don&rsquo;t
ever have to go adding lines like this</p>

<p style="margin-left:11%; margin-top: 1em">&quot;Couldn't
find file \&quot;[_1]\&quot;!\n&quot; <br>
=&gt; &quot;Couldn't find file
\&quot;[_1]\&quot;!\n&quot;,</p>

<p style="margin-left:11%; margin-top: 1em">to
ThisProject/I18N/en.pm, because if _AUTO is true there, then
just looking for an entry with the key &quot;Couldn&rsquo;t
find file \&quot;[_1]\&quot;!\n&quot; in that lexicon will
cause it to be added, with that value!</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
reason that keys that start with &quot;_&quot; are immune to
_AUTO isn&rsquo;t anything generally magical about the
underscore character -- I just wanted a way to have most
lexicon keys be autoable, except for possibly a few, and I
arbitrarily decided to use a leading underscore as a signal
to distinguish those few.</p>

<h2>READONLY LEXICONS
<a name="READONLY LEXICONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If your lexicon
is a tied hash the simple act of caching the compiled value
can be fatal.</p>

<p style="margin-left:11%; margin-top: 1em">For example a
GDBM_File <small>GDBM_READER</small> tied hash will die with
something like:</p>

<p style="margin-left:11%; margin-top: 1em">gdbm store
returned &minus;1, errno 2, key &quot;...&quot; at ...</p>

<p style="margin-left:11%; margin-top: 1em">All you need to
do is turn on caching outside of the lexicon hash itself
like so:</p>

<p style="margin-left:11%; margin-top: 1em">sub init { <br>
my ($lh) = @_; <br>
... <br>
$lh&minus;&gt;{'use_external_lex_cache'} = 1; <br>
... <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">And then
instead of storing the compiled value in the lexicon hash it
will store it in
$lh&minus;&gt;{&rsquo;_external_lex_cache&rsquo;}</p>

<h2>CONTROLLING LOOKUP FAILURE
<a name="CONTROLLING LOOKUP FAILURE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you call
$lh&minus;&gt;maketext(<i>key</i>, ...parameters...), and
there&rsquo;s no entry <i>key</i> in $lh&rsquo;s
class&rsquo;s %Lexicon, nor in the superclass %Lexicon hash,
<i>and</i> if we can&rsquo;t auto-make <i>key</i> (because
either it starts with a &quot;_&quot;, or because none of
its lexicons have &quot;_AUTO =&gt; 1,&quot;), then we have
failed to find a normal way to maketext <i>key</i>. What
then happens in these failure conditions, depends on the $lh
object&rsquo;s &quot;fail&quot; attribute.</p>

<p style="margin-left:11%; margin-top: 1em">If the language
handle has no &quot;fail&quot; attribute, maketext will
simply throw an exception (i.e., it calls &quot;die&quot;,
mentioning the <i>key</i> whose lookup failed, and naming
the line number where the calling
$lh&minus;&gt;maketext(<i>key</i>,...) was.</p>

<p style="margin-left:11%; margin-top: 1em">If the language
handle has a &quot;fail&quot; attribute whose value is a
coderef, then
$lh&minus;&gt;maketext(<i>key</i>,...params...) gives up and
calls:</p>

<p style="margin-left:11%; margin-top: 1em">return
$that_subref&minus;&gt;($lh, $key, @params);</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, the
&quot;fail&quot; attribute&rsquo;s value should be a string
denoting a method name, so that
$lh&minus;&gt;maketext(<i>key</i>,...params...) can give up
with:</p>

<p style="margin-left:11%; margin-top: 1em">return
$lh&minus;&gt;$that_method_name($phrase, @params);</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;fail&quot; attribute can be accessed with the
&quot;fail_with&quot; method:</p>

<p style="margin-left:11%; margin-top: 1em"># Set to a
coderef: <br>
$lh&minus;&gt;fail_with( \&amp;failure_handler ); <br>
# Set to a method name: <br>
$lh&minus;&gt;fail_with( 'failure_method' ); <br>
# Set to nothing (i.e., so failure throws a plain exception)
<br>
$lh&minus;&gt;fail_with( undef ); <br>
# Get the current value <br>
$handler = $lh&minus;&gt;fail_with();</p>

<p style="margin-left:11%; margin-top: 1em">Now, as to what
you may want to do with these handlers: Maybe you&rsquo;d
want to log what key failed for what class, and then die.
Maybe you don&rsquo;t like &quot;die&quot; and instead you
want to send the error message to <small>STDOUT</small> (or
wherever) and then merely &quot;exit()&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Or maybe you
don&rsquo;t want to &quot;die&quot; at all! Maybe you could
use a handler like this:</p>

<p style="margin-left:11%; margin-top: 1em"># Make all
lookups fall back onto an English value, <br>
# but only after we log it for later fingerpointing. <br>
my $lh_backup = ThisProject&minus;&gt;get_handle('en'); <br>
open(LEX_FAIL_LOG, &quot;&gt;&gt;wherever/lex.log&quot;) ||
die &quot;GNAARGH $!&quot;; <br>
sub lex_fail { <br>
my($failing_lh, $key, $params) = @_; <br>
print LEX_FAIL_LOG scalar(localtime), &quot;\t&quot;, <br>
ref($failing_lh), &quot;\t&quot;, $key, &quot;\n&quot;; <br>
return $lh_backup&minus;&gt;maketext($key,@params); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Some users have
expressed that they think this whole mechanism of having a
&quot;fail&quot; attribute at all, seems a rather pointless
complication. But I want Locale::Maketext to be usable for
software projects of <i>any</i> scale and type; and
different software projects have different ideas of what the
right thing is to do in failure conditions. I could simply
say that failure always throws an exception, and that if you
want to be careful, you&rsquo;ll just have to wrap every
call to $lh&minus;&gt;maketext in an eval&nbsp;{&nbsp;}.
However, I want programmers to reserve the right (via the
&quot;fail&quot; attribute) to treat lookup failure as
something other than an exception of the same level of
severity as a config file being unreadable, or some
essential resource being inaccessible.</p>

<p style="margin-left:11%; margin-top: 1em">One possibly
useful value for the &quot;fail&quot; attribute is the
method name &quot;failure_handler_auto&quot;. This is a
method defined in the class Locale::Maketext itself. You set
it with:</p>


<p style="margin-left:11%; margin-top: 1em">$lh&minus;&gt;fail_with('failure_handler_auto');</p>

<p style="margin-left:11%; margin-top: 1em">Then when you
call $lh&minus;&gt;maketext(<i>key</i>, ...parameters...)
and there&rsquo;s no <i>key</i> in any of those lexicons,
maketext gives up with</p>

<p style="margin-left:11%; margin-top: 1em">return
$lh&minus;&gt;failure_handler_auto($key, @params);</p>

<p style="margin-left:11%; margin-top: 1em">But
failure_handler_auto, instead of dying or anything, compiles
$key, caching it in</p>


<p style="margin-left:11%; margin-top: 1em">$lh&minus;&gt;{'failure_lex'}{$key}
= $compiled</p>

<p style="margin-left:11%; margin-top: 1em">and then calls
the compiled value, and returns that. (I.e., if $key looks
like bracket notation, $compiled is a sub, and we return
&amp;{$compiled}(@params); but if $key is just a plain
string, we just return that.)</p>

<p style="margin-left:11%; margin-top: 1em">The effect of
using &quot;failure_auto_handler&quot; is like an
<small>AUTO</small> lexicon, except that it 1) compiles $key
even if it starts with &quot;_&quot;, and 2) you have a
record in the new hashref
$lh&minus;&gt;{&rsquo;failure_lex&rsquo;} of all the keys
that have failed for this object. This should avoid your
program dying -- as long as your keys aren&rsquo;t actually
invalid as bracket code, and as long as they don&rsquo;t try
calling methods that don&rsquo;t exist.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;failure_auto_handler&quot;
may not be exactly what you want, but I hope it at least
shows you that maketext failure can be mitigated in any
number of very flexible ways. If you can formalize exactly
what you want, you should be able to express that as a
failure handler. You can even make it default for every
object of a given class, by setting it in that class&rsquo;s
init:</p>

<p style="margin-left:11%; margin-top: 1em">sub init { <br>
my $lh = $_[0]; # a newborn handle <br>
$lh&minus;&gt;SUPER::init(); <br>
$lh&minus;&gt;fail_with('my_clever_failure_handler'); <br>
return; <br>
} <br>
sub my_clever_failure_handler { <br>
...you clever things here... <br>
}</p>

<h2>HOW TO USE MAKETEXT
<a name="HOW TO USE MAKETEXT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Here is a brief
checklist on how to use Maketext to localize
applications:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Decide what system you&rsquo;ll
use for lexicon keys. If you insist, you can use opaque IDs
(if you&rsquo;re nostalgic for &quot;catgets&quot;), but I
have better suggestions in the section &quot;Entries in Each
Lexicon&quot;, above. Assuming you opt for meaningful keys
that double as values (like &quot;Minimum ([_1]) is larger
than maximum ([_2])!\n&quot;), you&rsquo;ll have to settle
on what language those should be in. For the sake of
argument, I&rsquo;ll call this English, specifically
American English, &quot;en-US&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Create a class for your localization project. This is
the name of the class that you&rsquo;ll use in the
idiom:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">use
Projname::L10N; <br>
my $lh = Projname::L10N&minus;&gt;get_handle(...) || die
&quot;Language?&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Assuming you
call your class Projname::L10N, create a class consisting
minimally of:</p>

<p style="margin-left:17%; margin-top: 1em">package
Projname::L10N; <br>
use base qw(Locale::Maketext); <br>
...any methods you might want all your languages to share...
<br>
# And, assuming you want the base class to be an _AUTO
lexicon, <br>
# as is discussed a few sections up: <br>
1;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Create a class for the language
your internal keys are in. Name the class after the
language-tag for that language, in lowercase, with dashes
changed to underscores. Assuming your project&rsquo;s first
language is <small>US</small> English, you should call this
Projname::L10N::en_us. It should consist minimally of:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">package
Projname::L10N::en_us; <br>
use base qw(Projname::L10N); <br>
%Lexicon = ( <br>
'_AUTO' =&gt; 1, <br>
); <br>
1;</p>

<p style="margin-left:17%; margin-top: 1em">(For the rest
of this section, I&rsquo;ll assume that this &quot;first
language class&quot; of Projname::L10N::en_us has _AUTO
lexicon.)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Go and write your program.
Everywhere in your program where you would say:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">print
&quot;Foobar $thing stuff\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">instead do it
thru maketext, using no variable interpolation in the
key:</p>

<p style="margin-left:17%; margin-top: 1em">print
$lh&minus;&gt;maketext(&quot;Foobar [_1] stuff\n&quot;,
$thing);</p>

<p style="margin-left:17%; margin-top: 1em">If you get
tired of constantly saying &quot;print
$lh&minus;&gt;maketext&quot;, consider making a functional
wrapper for it, like so:</p>

<p style="margin-left:17%; margin-top: 1em">use
Projname::L10N; <br>
our $lh; <br>
$lh = Projname::L10N&minus;&gt;get_handle(...) || die
&quot;Language?&quot;; <br>
sub pmt (@) { print( $lh&minus;&gt;maketext(@_)) } <br>
# &quot;pmt&quot; is short for &quot;Print MakeText&quot;
<br>
$Carp::Verbose = 1; <br>
# so if maketext fails, we see made the call to pmt</p>

<p style="margin-left:17%; margin-top: 1em">Besides whole
phrases meant for output, anything language-dependent should
be put into the class Projname::L10N::en_us, whether as
methods, or as lexicon entries -- this is discussed in the
section &quot;Entries in Each Lexicon&quot;, above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Once the program is otherwise
done, and once its localization for the first language works
right (via the data and methods in Projname::L10N::en_us),
you can get together the data for translation. If your first
language lexicon isn&rsquo;t an _AUTO lexicon, then you
already have all the messages explicitly in the lexicon (or
else you&rsquo;d be getting exceptions thrown when you call
$lh&minus;&gt;maketext to get messages that aren&rsquo;t in
there). But if you were (advisedly) lazy and are using an
_AUTO lexicon, then you&rsquo;ve got to make a list of all
the phrases that you&rsquo;ve so far been letting _AUTO
generate for you. There are very many ways to assemble such
a list. The most straightforward is to simply grep the
source for every occurrence of &quot;maketext&quot; (or
calls to wrappers around it, like the above &quot;pmt&quot;
function), and to log the following phrase.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>You may at this point want to consider whether your base
class (Projname::L10N), from which all lexicons inherit from
(Projname::L10N::en, Projname::L10N::es, etc.), should be an
_AUTO lexicon. It may be true that in theory, all needed
messages will be in each language class; but in the
presumably unlikely or &quot;impossible&quot; case of lookup
failure, you should consider whether your program should
throw an exception, emit text in English (or whatever your
project&rsquo;s first language is), or some more complex
solution as described in the section &quot;Controlling
Lookup Failure&quot;, above.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Submit all messages/phrases/etc. to translators.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">(You may, in
fact, want to start with localizing to <i>one</i> other
language at first, if you&rsquo;re not sure that
you&rsquo;ve properly abstracted the language-dependent
parts of your code.)</p>

<p style="margin-left:17%; margin-top: 1em">Translators may
request clarification of the situation in which a particular
phrase is found. For example, in English we are entirely
happy saying &quot;<i>n</i> files found&quot;, regardless of
whether we mean &quot;I looked for files, and found <i>n</i>
of them&quot; or the rather distinct situation of &quot;I
looked for something else (like lines in files), and along
the way I saw <i>n</i> files.&quot; This may involve
rethinking things that you thought quite clear: should
&quot;Edit&quot; on a toolbar be a noun
(&quot;editing&quot;) or a verb (&quot;to edit&quot;)? Is
there already a conventionalized way to express that menu
option, separate from the target language&rsquo;s normal
word for &quot;to edit&quot;?</p>

<p style="margin-left:17%; margin-top: 1em">In all cases
where the very common phenomenon of quantification (saying
&quot;<i>N</i> files&quot;, for <b>any</b> value of N) is
involved, each translator should make clear what
dependencies the number causes in the sentence. In many
cases, dependency is limited to words adjacent to the
number, in places where you might expect them (&quot;I found
the&minus;?PLURAL <i>N</i> empty&minus;?PLURAL
directory&minus;?PLURAL&quot;), but in some cases there are
unexpected dependencies (&quot;I found&minus;?PLURAL
...&quot;!) as well as long-distance dependencies &quot;The
<i>N</i> directory&minus;?PLURAL could not be
deleted&minus;?PLURAL&quot;!).</p>

<p style="margin-left:17%; margin-top: 1em">Remind the
translators to consider the case where N is 0: &quot;0 files
found&quot; isn&rsquo;t exactly natural-sounding in any
language, but it may be unacceptable in many -- or it may
condition special kinds of agreement (similar to English
&quot;I didN&rsquo;T find <small>ANY</small>
files&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">Remember to ask
your translators about numeral formatting in their language,
so that you can override the &quot;numf&quot; method as
appropriate. Typical variables in number formatting are:
what to use as a decimal point (comma? period?); what to use
as a thousands separator (space? nonbreaking space? comma?
period? small middot? prime? apostrophe?); and even whether
the so-called &quot;thousands separator&quot; is actually
for every third digit -- I&rsquo;ve heard reports of two
hundred thousand being expressible as &quot;2,00,000&quot;
for some Indian (Subcontinental) languages, besides the less
surprising &quot;200&nbsp;000&quot;, &quot;200.000&quot;,
&quot;200,000&quot;, and &quot;200&rsquo;000&quot;. Also,
using a set of numeral glyphs other than the usual
<small>ASCII &quot;0&quot;&minus;&quot;9&quot;</small> might
be appreciated, as via
&quot;tr/0&minus;9/\x{0966}&minus;\x{096F}/&quot; for
getting digits in Devanagari script (for Hindi, Konkani,
others).</p>

<p style="margin-left:17%; margin-top: 1em">The basic
&quot;quant&quot; method that Locale::Maketext provides
should be good for many languages. For some languages, it
might be useful to modify it (or its constituent
&quot;numerate&quot; method) to take a plural form in the
two-argument call to &quot;quant&quot; (as in
&quot;[quant,_1,files]&quot;) if it&rsquo;s all-around
easier to infer the singular form from the plural, than to
infer the plural form from the singular.</p>

<p style="margin-left:17%; margin-top: 1em">But for other
languages (as is discussed at length in
Locale::Maketext::TPJ13), simple
&quot;quant&quot;/&quot;numf&quot; is not enough. For the
particularly problematic Slavic languages, what you may need
is a method which you provide with the number, the citation
form of the noun to quantify, and the case and gender that
the sentence&rsquo;s syntax projects onto that noun slot.
The method would then be responsible for determining what
grammatical number that numeral projects onto its noun
phrase, and what case and gender it may override the normal
case and gender with; and then it would look up the noun in
a lexicon providing all needed inflected forms.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">You may also wish to discuss
with the translators the question of how to relate different
subforms of the same language tag, considering how this
reacts with &quot;get_handle&quot;&rsquo;s treatment of
these. For example, if a user accepts interfaces in
&quot;en, fr&quot;, and you have interfaces available in
&quot;en-US&quot; and &quot;fr&quot;, what should they get?
You may wish to resolve this by establishing that
&quot;en&quot; and &quot;en-US&quot; are effectively
synonymous, by having one class zero-derive from the
other.</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For some
languages this issue may never come up (Danish is rarely
expressed as &quot;da-DK&quot;, but instead is just
&quot;da&quot;). And for other languages, the whole concept
of a &quot;generic&quot; form may verge on being uselessly
vague, particularly for interfaces involving voice media in
forms of Arabic or Chinese.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Once you&rsquo;ve localized your
program/site/etc. for all desired languages, be sure to show
the result (whether live, or via screenshots) to the
translators. Once they approve, make every effort to have it
then checked by at least one other speaker of that language.
This holds true even when (or especially when) the
translation is done by one of your own programmers. Some
kinds of systems may be harder to find testers for than
others, depending on the amount of domain-specific jargon
and concepts involved -- it&rsquo;s easier to find people
who can tell you whether they approve of your translation
for &quot;delete this message&quot; in an email-via-Web
interface, than to find people who can give you an informed
opinion on your translation for &quot;attribute value&quot;
in an <small>XML</small> query tool&rsquo;s interface.</p></td></tr>
</table>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">I recommend
reading all of these:</p>


<p style="margin-left:11%; margin-top: 1em">Locale::Maketext::TPJ13
-- my <i>The Perl Journal</i> article about Maketext. It
explains many important concepts underlying
Locale::Maketext&rsquo;s design, and some insight into why
Maketext is better than the plain old approach of having
message catalogs that are just databases of sprintf
formats.</p>

<p style="margin-left:11%; margin-top: 1em">File::Findgrep
is a sample application/module that uses Locale::Maketext to
localize its messages. For a larger internationalized
system, see also Apache::MP3.</p>


<p style="margin-left:11%; margin-top: 1em">I18N::LangTags.</p>


<p style="margin-left:11%; margin-top: 1em">Win32::Locale.</p>

<p style="margin-left:11%; margin-top: 1em"><small>RFC
3066,</small> <i>Tags for the Identification of
Languages</i>, as at
&lt;http://sunsite.dk/RFC/rfc/rfc3066.html&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><small>RFC
2277, <i>IETF</i></small> <i>Policy on Character Sets and
Languages</i> is at
&lt;http://sunsite.dk/RFC/rfc/rfc2277.html&gt; -- much of it
is just things of interest to protocol designers, but it
explains some basic concepts, like the distinction between
locales and language-tags.</p>

<p style="margin-left:11%; margin-top: 1em">The manual for
<small>GNU</small> &quot;gettext&quot;. The gettext dist is
available in
&quot;&lt;ftp://prep.ai.mit.edu/pub/gnu/&gt;&quot; -- get a
recent gettext tarball and look in its &quot;doc/&quot;
directory, there&rsquo;s an easily browsable
<small>HTML</small> version in there. The gettext
documentation asks lots of questions worth thinking about,
even if some of their answers are sometimes wonky,
particularly where they start talking about
pluralization.</p>

<p style="margin-left:11%; margin-top: 1em">The
Locale/Maketext.pm source. Observe that the module is much
shorter than its documentation!</p>

<h2>COPYRIGHT AND DISCLAIMER
<a name="COPYRIGHT AND DISCLAIMER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1999&minus;2004 Sean M. Burke. All rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
distributed in the hope that it will be useful, but without
any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Sean M. Burke
&quot;sburke@cpan.org&quot;</p>
<hr>
</body>
</html>
