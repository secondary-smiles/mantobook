<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:45 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>overload</title>

</head>
<body>
<h1>overload</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">overload
&minus; Package for overloading Perl operations</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">package
SomeThing; <br>
use overload <br>
'+' =&gt; \&amp;myadd, <br>
'&minus;' =&gt; \&amp;mysub; <br>
# etc <br>
... <br>
package main; <br>
$a = SomeThing&minus;&gt;new( 57 ); <br>
$b = 5 + $a; <br>
... <br>
if (overload::Overloaded $b) {...} <br>
... <br>
$strval = overload::StrVal $b;</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This pragma
allows overloading of Perl&rsquo;s operators for a class. To
overload built-in functions, see &quot;Overriding Built-in
Functions&quot; in perlsub instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Fundamentals</b>
<i><br>
Declaration</i></p>

<p style="margin-left:11%; margin-top: 1em">Arguments of
the &quot;use overload&quot; directive are (key, value)
pairs. For the full set of legal keys, see
&quot;Overloadable Operations&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em">Operator
implementations (the values) can be subroutines, references
to subroutines, or anonymous subroutines &minus; in other
words, anything legal inside a &quot;&amp;{ ... }&quot;
call. Values specified as strings are interpreted as method
names. Thus</p>

<p style="margin-left:11%; margin-top: 1em">package Number;
<br>
use overload <br>
&quot;&minus;&quot; =&gt; &quot;minus&quot;, <br>
&quot;*=&quot; =&gt; \&amp;muas, <br>
'&quot;&quot;' =&gt; sub { ...; };</p>

<p style="margin-left:11%; margin-top: 1em">declares that
subtraction is to be implemented by method
&quot;minus()&quot; in the class &quot;Number&quot; (or one
of its base classes), and that the function
&quot;Number::muas()&quot; is to be used for the assignment
form of multiplication, &quot;*=&quot;. It also defines an
anonymous subroutine to implement stringification: this is
called whenever an object blessed into the package
&quot;Number&quot; is used in a string context (this
subroutine might, for example, return the number as a Roman
numeral).</p>

<p style="margin-left:11%; margin-top: 1em"><i>Calling
Conventions and Magic Autogeneration</i></p>

<p style="margin-left:11%; margin-top: 1em">The following
sample implementation of &quot;minus()&quot; (which assumes
that &quot;Number&quot; objects are simply blessed
references to scalars) illustrates the calling
conventions:</p>

<p style="margin-left:11%; margin-top: 1em">package Number;
<br>
sub minus { <br>
my ($self, $other, $swap) = @_; <br>
my $result = $$self &minus; $other; # * <br>
$result = &minus;$result if $swap; <br>
ref $result ? $result : bless \$result; <br>
} <br>
# * may recurse once &minus; see table below</p>

<p style="margin-left:11%; margin-top: 1em">Three arguments
are passed to all subroutines specified in the &quot;use
overload&quot; directive (with exceptions &minus; see below,
particularly &quot;nomethod&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">The first of
these is the operand providing the overloaded operator
implementation &minus; in this case, the object whose
&quot;minus()&quot; method is being called.</p>

<p style="margin-left:11%; margin-top: 1em">The second
argument is the other operand, or &quot;undef&quot; in the
case of a unary operator.</p>

<p style="margin-left:11%; margin-top: 1em">The third
argument is set to <small>TRUE</small> if (and only if) the
two operands have been swapped. Perl may do this to ensure
that the first argument ($self) is an object implementing
the overloaded operation, in line with general object
calling conventions. For example, if $x and $y are
&quot;Number&quot;s:</p>

<p style="margin-left:11%; margin-top: 1em">operation |
generates a call to <br>
============|====================== <br>
$x &minus; $y | minus($x, $y, '') <br>
$x &minus; 7 | minus($x, 7, '') <br>
7 &minus; $x | minus($x, 7, 1)</p>

<p style="margin-left:11%; margin-top: 1em">Perl may also
use &quot;minus()&quot; to implement other operators which
have not been specified in the &quot;use overload&quot;
directive, according to the rules for &quot;Magic
Autogeneration&quot; described later. For example, the
&quot;use overload&quot; above declared no subroutine for
any of the operators &quot;&minus;&minus;&quot;,
&quot;neg&quot; (the overload key for unary minus), or
&quot;&minus;=&quot;. Thus</p>

<p style="margin-left:11%; margin-top: 1em">operation |
generates a call to <br>
============|====================== <br>
&minus;$x | minus($x, 0, 1) <br>
$x&minus;&minus; | minus($x, 1, undef) <br>
$x &minus;= 3 | minus($x, 3, undef)</p>

<p style="margin-left:11%; margin-top: 1em">Note the
&quot;undef&quot;s: where autogeneration results in the
method for a standard operator which does not change either
of its operands, such as &quot;&minus;&quot;, being used to
implement an operator which changes the operand
(&quot;mutators&quot;: here, &quot;&minus;&minus;&quot; and
&quot;&minus;=&quot;), Perl passes undef as the third
argument. This still evaluates as <small>FALSE,</small>
consistent with the fact that the operands have not been
swapped, but gives the subroutine a chance to alter its
behaviour in these cases.</p>

<p style="margin-left:11%; margin-top: 1em">In all the
above examples, &quot;minus()&quot; is required only to
return the result of the subtraction: Perl takes care of the
assignment to $x. In fact, such methods should <i>not</i>
modify their operands, even if &quot;undef&quot; is passed
as the third argument (see &quot;Overloadable
Operations&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">The same is not
true of implementations of &quot;++&quot; and
&quot;&minus;&minus;&quot;: these are expected to modify
their operand. An appropriate implementation of
&quot;&minus;&minus;&quot; might look like</p>

<p style="margin-left:11%; margin-top: 1em">use overload
'&minus;&minus;' =&gt; &quot;decr&quot;, <br>
# ... <br>
sub decr { &minus;&minus;${$_[0]}; }</p>

<p style="margin-left:11%; margin-top: 1em">If the
&quot;bitwise&quot; feature is enabled (see feature), a
fifth <small>TRUE</small> argument is passed to subroutines
handling &quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot; and
&quot;~&quot;. This indicates that the caller is expecting
numeric behaviour. The fourth argument will be
&quot;undef&quot;, as that position ($_[3]) is reserved for
use by &quot;nomethod&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Mathemagic,
Mutators, and Copy Constructors</i></p>

<p style="margin-left:11%; margin-top: 1em">The term
&rsquo;mathemagic&rsquo; describes the overloaded
implementation of mathematical operators. Mathemagical
operations raise an issue. Consider the code:</p>

<p style="margin-left:11%; margin-top: 1em">$a = $b; <br>
&minus;&minus;$a;</p>

<p style="margin-left:11%; margin-top: 1em">If $a and $b
are scalars then after these statements</p>

<p style="margin-left:11%; margin-top: 1em">$a == $b
&minus; 1</p>

<p style="margin-left:11%; margin-top: 1em">An object,
however, is a reference to blessed data, so if $a and $b are
objects then the assignment &quot;$a = $b&quot; copies only
the reference, leaving $a and $b referring to the same
object data. One might therefore expect the operation
&quot;&minus;&minus;$a&quot; to decrement $b as well as $a.
However, this would not be consistent with how we expect the
mathematical operators to work.</p>

<p style="margin-left:11%; margin-top: 1em">Perl resolves
this dilemma by transparently calling a copy constructor
before calling a method defined to implement a mutator
(&quot;&minus;&minus;&quot;, &quot;+=&quot;, and so on.). In
the above example, when Perl reaches the decrement
statement, it makes a copy of the object data in $a and
assigns to $a a reference to the copied data. Only then does
it call &quot;decr()&quot;, which alters the copied data,
leaving $b unchanged. Thus the object metaphor is preserved
as far as possible, while mathemagical operations still work
according to the arithmetic metaphor.</p>

<p style="margin-left:11%; margin-top: 1em">Note: the
preceding paragraph describes what happens when Perl
autogenerates the copy constructor for an object based on a
scalar. For other cases, see &quot;Copy
Constructor&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Overloadable
Operations</b> <br>
The complete list of keys that can be specified in the
&quot;use overload&quot; directive are given, separated by
spaces, in the values of the hash %overload::ops:</p>

<p style="margin-left:11%; margin-top: 1em">with_assign
=&gt; '+ &minus; * / % ** &lt;&lt; &gt;&gt; x .', <br>
assign =&gt; '+= &minus;= *= /= %= **= &lt;&lt;= &gt;&gt;=
x= .=', <br>
num_comparison =&gt; '&lt; &lt;= &gt; &gt;= == !=', <br>
'3way_comparison'=&gt; '&lt;=&gt; cmp', <br>
str_comparison =&gt; 'lt le gt ge eq ne', <br>
binary =&gt; '&amp; &amp;= | |= ^ ^= &amp;. &amp;.= |. |.=
^. ^.=', <br>
unary =&gt; 'neg ! ~ ~.', <br>
mutators =&gt; '++ &minus;&minus;', <br>
func =&gt; 'atan2 cos sin exp abs log sqrt int', <br>
conversion =&gt; 'bool &quot;&quot; 0+ qr', <br>
iterators =&gt; '&lt;&gt;', <br>
filetest =&gt; '&minus;X', <br>
dereferencing =&gt; '${} @{} %{} &amp;{} *{}', <br>
matching =&gt; '~~', <br>
special =&gt; 'nomethod fallback ='</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
overloadable operators map one-to-one to these keys.
Exceptions, including additional overloadable operations not
apparent from this hash, are included in the notes which
follow. This list is subject to growth over time.</p>

<p style="margin-left:11%; margin-top: 1em">A warning is
issued if an attempt is made to register an operator not
found above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="6%"></td>
<td width="8%">


<p>&quot;not&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The operator
&quot;not&quot; is not a valid key for &quot;use
overload&quot;. However, if the operator &quot;!&quot; is
overloaded then the same implementation will be used for
&quot;not&quot; (since the two operators differ only in
precedence).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="8%">


<p style="margin-top: 1em">&quot;neg&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The key
&quot;neg&quot; is used for unary minus to disambiguate it
from binary &quot;&minus;&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="16%">


<p style="margin-top: 1em">&quot;++&quot;,
&quot;&minus;&minus;&quot;</p> </td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Assuming they
are to behave analogously to Perl&rsquo;s &quot;++&quot; and
&quot;&minus;&minus;&quot;, overloaded implementations of
these operators are required to mutate their operands.</p>

<p style="margin-left:18%; margin-top: 1em">No distinction
is made between prefix and postfix forms of the increment
and decrement operators: these differ only in the point at
which Perl calls the associated subroutine when evaluating
an expression.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="17%">


<p style="margin-top: 1em"><i>Assignments</i></p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">+= &minus;= *=
/= %= **= &lt;&lt;= &gt;&gt;= x= .= <br>
&amp;= |= ^= &amp;.= |.= ^.=</p>

<p style="margin-left:18%; margin-top: 1em">Simple
assignment is not overloadable (the '=' key is used for the
&quot;Copy Constructor&quot;). Perl does have a way to make
assignments to an object do whatever you want, but this
involves using <b>tie()</b>, not overload &minus; see
&quot;tie&quot; in perlfunc and the &quot;
<small>COOKBOOK&quot;</small> examples below.</p>

<p style="margin-left:18%; margin-top: 1em">The subroutine
for the assignment variant of an operator is required only
to return the result of the operation. It is permitted to
change the value of its operand (this is safe because Perl
calls the copy constructor first), but this is optional
since Perl assigns the returned value to the left-hand
operand anyway.</p>

<p style="margin-left:18%; margin-top: 1em">An object that
overloads an assignment operator does so only in respect of
assignments to that object. In other words, Perl never calls
the corresponding methods with the third argument (the
&quot;swap&quot; argument) set to <small>TRUE.</small> For
example, the operation</p>

<p style="margin-left:18%; margin-top: 1em">$a *= $b</p>

<p style="margin-left:18%; margin-top: 1em">cannot lead to
$b&rsquo;s implementation of &quot;*=&quot; being called,
even if $a is a scalar. (It can, however, generate a call to
$b&rsquo;s method for &quot;*&quot;).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="54%">


<p style="margin-top: 1em"><i>Non-mutators with a mutator
variant</i></p> </td>
<td width="28%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">+ &minus; * / %
** &lt;&lt; &gt;&gt; x . <br>
&amp; | ^ &amp;. |. ^.</p>

<p style="margin-left:18%; margin-top: 1em">As described
above, Perl may call methods for operators like
&quot;+&quot; and &quot;&amp;&quot; in the course of
implementing missing operations like &quot;++&quot;,
&quot;+=&quot;, and &quot;&amp;=&quot;. While these methods
may detect this usage by testing the definedness of the
third argument, they should in all cases avoid changing
their operands. This is because Perl does not call the copy
constructor before invoking these methods.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="8%">


<p style="margin-top: 1em">&quot;int&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Traditionally,
the Perl function &quot;int&quot; rounds to 0 (see
&quot;int&quot; in perlfunc), and so for floating-point-like
types one should follow the same semantic.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="74%">


<p style="margin-top: 1em"><i>String, numeric, boolean, and
regexp conversions</i></p></td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">&quot;&quot; 0+
bool</p>

<p style="margin-left:18%; margin-top: 1em">These
conversions are invoked according to context as necessary.
For example, the subroutine for '&quot;&quot;' (stringify)
may be used where the overloaded object is passed as an
argument to &quot;print&quot;, and that for 'bool' where it
is tested in the condition of a flow control statement (like
&quot;while&quot;) or the ternary &quot;?:&quot;
operation.</p>

<p style="margin-left:18%; margin-top: 1em">Of course, in
contexts like, for example, &quot;$obj + 1&quot;, Perl will
invoke $obj&rsquo;s implementation of &quot;+&quot; rather
than (in this example) converting $obj to a number using the
numify method '0+' (an exception to this is when no method
has been provided for '+' and &quot;fallback&quot; is set to
<small>TRUE</small> ).</p>

<p style="margin-left:18%; margin-top: 1em">The subroutines
for '&quot;&quot;', '0+', and 'bool' can return any
arbitrary Perl value. If the corresponding operation for
this value is overloaded too, the operation will be called
again with this value.</p>

<p style="margin-left:18%; margin-top: 1em">As a special
case if the overload returns the object itself then it will
be used directly. An overloaded conversion returning the
object is probably a bug, because you&rsquo;re likely to get
something that looks like
&quot;YourPackage=HASH(0x8172b34)&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">qr</p>

<p style="margin-left:18%; margin-top: 1em">The subroutine
for 'qr' is used wherever the object is interpolated into or
used as a regexp, including when it appears on the
<small>RHS</small> of a &quot;=~&quot; or &quot;!~&quot;
operator.</p>

<p style="margin-left:18%; margin-top: 1em">&quot;qr&quot;
must return a compiled regexp, or a ref to a compiled regexp
(such as &quot;qr//&quot; returns), and any further
overloading on the return value will be ignored.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="14%">


<p style="margin-top: 1em"><i>Iteration</i></p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">If
&quot;&lt;&gt;&quot; is overloaded then the same
implementation is used for both the <i>read-filehandle</i>
syntax &quot;&lt;$var&gt;&quot; and <i>globbing</i> syntax
&quot;&lt;${var}&gt;&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="16%">


<p style="margin-top: 1em"><i>File tests</i></p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The key
'&minus;X' is used to specify a subroutine to handle all the
filetest operators (&quot;&minus;f&quot;,
&quot;&minus;x&quot;, and so on: see &quot;&minus;X&quot; in
perlfunc for the full list); it is not possible to overload
any filetest operator individually. To distinguish them, the
letter following the &rsquo;&minus;&rsquo; is passed as the
second argument (that is, in the slot that for binary
operators is used to pass the second operand).</p>

<p style="margin-left:18%; margin-top: 1em">Calling an
overloaded filetest operator does not affect the stat value
associated with the special filehandle &quot;_&quot;. It
still refers to the result of the last &quot;stat&quot;,
&quot;lstat&quot; or unoverloaded filetest.</p>

<p style="margin-left:18%; margin-top: 1em">This overload
was introduced in Perl 5.12.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="13%">


<p style="margin-top: 1em"><i>Matching</i></p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">The key
&quot;~~&quot; allows you to override the smart matching
logic used by the &quot;~~&quot; operator and the switch
construct (&quot;given&quot;/&quot;when&quot;). See
&quot;Switch Statements&quot; in perlsyn and feature.</p>

<p style="margin-left:18%; margin-top: 1em">Unusually, the
overloaded implementation of the smart match operator does
not get full control of the smart match behaviour. In
particular, in the following code:</p>

<p style="margin-left:18%; margin-top: 1em">package Foo;
<br>
use overload '~~' =&gt; 'match'; <br>
my $obj = Foo&minus;&gt;new(); <br>
$obj ~~ [ 1,2,3 ];</p>

<p style="margin-left:18%; margin-top: 1em">the smart match
does <i>not</i> invoke the method call like this:</p>


<p style="margin-left:18%; margin-top: 1em">$obj&minus;&gt;match([1,2,3],0);</p>

<p style="margin-left:18%; margin-top: 1em">rather, the
smart match distributive rule takes precedence, so $obj is
smart matched against each array element in turn until a
match is found, so you may see between one and three of
these calls instead:</p>


<p style="margin-left:18%; margin-top: 1em">$obj&minus;&gt;match(1,0);
<br>
$obj&minus;&gt;match(2,0); <br>
$obj&minus;&gt;match(3,0);</p>

<p style="margin-left:18%; margin-top: 1em">Consult the
match table in &quot;Smartmatch Operator&quot; in perlop for
details of when overloading is invoked.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="20%">


<p style="margin-top: 1em"><i>Dereferencing</i></p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">${} @{} %{}
&amp;{} *{}</p>

<p style="margin-left:18%; margin-top: 1em">If these
operators are not explicitly overloaded then they work in
the normal way, yielding the underlying scalar, array, or
whatever stores the object data (or the appropriate error
message if the dereference operator doesn&rsquo;t match it).
Defining a catch-all 'nomethod' (see below) makes no
difference to this as the catch-all function will not be
called to implement a missing dereference operator.</p>

<p style="margin-left:18%; margin-top: 1em">If a
dereference operator is overloaded then it must return a
<i>reference</i> of the appropriate type (for example, the
subroutine for key '${}' should return a reference to a
scalar, not a scalar), or another object which overloads the
operator: that is, the subroutine only determines what is
dereferenced and the actual dereferencing is left to Perl.
As a special case, if the subroutine returns the object
itself then it will not be called again &minus; avoiding
infinite recursion.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="6%"></td>
<td width="11%">


<p style="margin-top: 1em"><i>Special</i></p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">nomethod
fallback =</p>

<p style="margin-left:18%; margin-top: 1em">See
&quot;Special Keys for &quot;use overload&quot;&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Magic
Autogeneration</b> <br>
If a method for an operation is not found then Perl tries to
autogenerate a substitute implementation from the operations
that have been defined.</p>

<p style="margin-left:11%; margin-top: 1em">Note: the
behaviour described in this section can be disabled by
setting &quot;fallback&quot; to <small>FALSE</small> (see
&quot;fallback&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">In the
following tables, numbers indicate priority. For example,
the table below states that, if no implementation for '!'
has been defined then Perl will implement it using 'bool'
(that is, by inverting the value returned by the method for
'bool'); if boolean conversion is also unimplemented then
Perl will use '0+' or, failing that, '&quot;&quot;'.</p>

<p style="margin-left:11%; margin-top: 1em">operator | can
be autogenerated from <br>
| <br>
| 0+ &quot;&quot; bool . x <br>
=========|========================== <br>
0+ | 1 2 <br>
&quot;&quot; | 1 2 <br>
bool | 1 2 <br>
int | 1 2 3 <br>
! | 2 3 1 <br>
qr | 2 1 3 <br>
. | 2 1 3 <br>
x | 2 1 3 <br>
.= | 3 2 4 1 <br>
x= | 3 2 4 1 <br>
&lt;&gt; | 2 1 3 <br>
&minus;X | 2 1 3</p>

<p style="margin-left:11%; margin-top: 1em">Note: The
iterator ('&lt;&gt;') and file test ('&minus;X') operators
work as normal: if the operand is not a blessed glob or
<small>IO</small> reference then it is converted to a string
(using the method for '&quot;&quot;', '0+', or 'bool') to be
interpreted as a glob or filename.</p>

<p style="margin-left:11%; margin-top: 1em">operator | can
be autogenerated from <br>
| <br>
| &lt; &lt;=&gt; neg &minus;= &minus; <br>
=========|========================== <br>
neg | 1 <br>
&minus;= | 1 <br>
&minus;&minus; | 1 2 <br>
abs | a1 a2 b1 b2 [*] <br>
&lt; | 1 <br>
&lt;= | 1 <br>
&gt; | 1 <br>
&gt;= | 1 <br>
== | 1 <br>
!= | 1 <br>
* one from [a1, a2] and one from [b1, b2]</p>

<p style="margin-left:11%; margin-top: 1em">Just as numeric
comparisons can be autogenerated from the method for
'&lt;=&gt;', string comparisons can be autogenerated from
that for 'cmp':</p>

<p style="margin-left:11%; margin-top: 1em">operators | can
be autogenerated from <br>
====================|=========================== <br>
lt gt le ge eq ne | cmp</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
autogeneration for keys '+=' and '++' is analogous to
'&minus;=' and '&minus;&minus;' above:</p>

<p style="margin-left:11%; margin-top: 1em">operator | can
be autogenerated from <br>
| <br>
| += + <br>
=========|========================== <br>
+= | 1 <br>
++ | 1 2</p>

<p style="margin-left:11%; margin-top: 1em">And other
assignment variations are analogous to '+=' and '&minus;='
(and similar to '.=' and 'x=' above):</p>

<p style="margin-left:11%; margin-top: 1em">operator || *=
/= %= **= &lt;&lt;= &gt;&gt;= &amp;= ^= |= &amp;.= ^.= |.=
<br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;||&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
autogenerated from || * / % ** &lt;&lt; &gt;&gt; &amp; ^ |
&amp;. ^. |.</p>

<p style="margin-left:11%; margin-top: 1em">Note also that
the copy constructor (key '=') may be autogenerated, but
only for objects based on scalars. See &quot;Copy
Constructor&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Minimal Set
of Overloaded Operations</i></p>

<p style="margin-left:11%; margin-top: 1em">Since some
operations can be automatically generated from others, there
is a minimal set of operations that need to be overloaded in
order to have the complete set of overloaded operations at
one&rsquo;s disposal. Of course, the autogenerated
operations may not do exactly what the user expects. The
minimal set is:</p>

<p style="margin-left:11%; margin-top: 1em">+ &minus; * / %
** &lt;&lt; &gt;&gt; x <br>
&lt;=&gt; cmp <br>
&amp; | ^ ~ &amp;. |. ^. ~. <br>
atan2 cos sin exp log sqrt int <br>
&quot;&quot; 0+ bool <br>
~~</p>

<p style="margin-left:11%; margin-top: 1em">Of the
conversions, only one of string, boolean or numeric is
needed because each can be generated from either of the
other two.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Special Keys
for &quot;use overload&quot;</b> <i><br>
&quot;nomethod&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">The 'nomethod'
key is used to specify a catch-all function to be called for
any operator that is not individually overloaded. The
specified function will be passed four parameters. The first
three arguments coincide with those that would have been
passed to the corresponding method if it had been defined.
The fourth argument is the &quot;use overload&quot; key for
that missing method. If the &quot;bitwise&quot; feature is
enabled (see feature), a fifth <small>TRUE</small> argument
is passed to subroutines handling &quot;&amp;&quot;,
&quot;|&quot;, &quot;^&quot; and &quot;~&quot; to indicate
that the caller is expecting numeric behaviour.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
$a is an object blessed into a package declaring</p>

<p style="margin-left:11%; margin-top: 1em">use overload
'nomethod' =&gt; 'catch_all', # ...</p>

<p style="margin-left:11%; margin-top: 1em">then the
operation</p>

<p style="margin-left:11%; margin-top: 1em">3 + $a</p>

<p style="margin-left:11%; margin-top: 1em">could (unless a
method is specifically declared for the key '+') result in a
call</p>

<p style="margin-left:11%; margin-top: 1em">catch_all($a,
3, 1, '+')</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;How
Perl Chooses an Operator Implementation&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;fallback&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">The value
assigned to the key 'fallback' tells Perl how hard it should
try to find an alternative way to implement a missing
operator.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p style="margin-top: 1em">defined, but
<small>FALSE</small></p> </td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">use overload
&quot;fallback&quot; =&gt; 0, # ... ;</p>

<p style="margin-left:17%; margin-top: 1em">This disables
&quot;Magic Autogeneration&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">&quot;undef&quot;</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">In the default
case where no value is explicitly assigned to
&quot;fallback&quot;, magic autogeneration is enabled.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em"><small>TRUE</small></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The same as for
&quot;undef&quot;, but if a missing operator cannot be
autogenerated then, instead of issuing an error message,
Perl is allowed to revert to what it would have done for
that operator if there had been no &quot;use overload&quot;
directive.</p>

<p style="margin-left:17%; margin-top: 1em">Note: in most
cases, particularly the &quot;Copy Constructor&quot;, this
is unlikely to be appropriate behaviour.</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;How
Perl Chooses an Operator Implementation&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Copy
Constructor</i></p>

<p style="margin-left:11%; margin-top: 1em">As mentioned
above, this operation is called when a mutator is applied to
a reference that shares its object with some other
reference. For example, if $b is mathemagical, and '++' is
overloaded with 'incr', and '=' is overloaded with 'clone',
then the code</p>

<p style="margin-left:11%; margin-top: 1em">$a = $b; <br>
# ... (other code which does not modify $a or $b) ... <br>
++$b;</p>

<p style="margin-left:11%; margin-top: 1em">would be
executed in a manner equivalent to</p>

<p style="margin-left:11%; margin-top: 1em">$a = $b; <br>
# ... <br>
$b = $b&minus;&gt;clone(undef, &quot;&quot;); <br>
$b&minus;&gt;incr(undef, &quot;&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">Note:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The subroutine for '=' does not
overload the Perl assignment operator: it is used only to
allow mutators to work as described here. (See
&quot;Assignments&quot; above.)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>As for other operations, the subroutine implementing
&rsquo;=&rsquo; is passed three arguments, though the last
two are always &quot;undef&quot; and ''.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The copy constructor is called only before a call to a
function declared to implement a mutator, for example, if
&quot;++$b;&quot; in the code above is effected via a method
declared for key '++' (or &rsquo;nomethod&rsquo;, passed
'++' as the fourth argument) or, by autogeneration, '+='. It
is not called if the increment operation is effected by a
call to the method for '+' since, in the equivalent
code,</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">$a = $b; <br>
$b = $b + 1;</p>

<p style="margin-left:17%; margin-top: 1em">the data
referred to by $a is unchanged by the assignment to $b of a
reference to new object data.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The copy constructor is not
called if Perl determines that it is unnecessary because
there is no other reference to the data being modified.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>If 'fallback' is undefined or <small>TRUE</small> then a
copy constructor can be autogenerated, but only for objects
based on scalars. In other cases it needs to be defined
explicitly. Where an object&rsquo;s data is stored as, for
example, an array of scalars, the following might be
appropriate:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">use overload
'=' =&gt; sub { bless [ @{$_[0]} ] }, # ...</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">If 'fallback' is
<small>TRUE</small> and no copy constructor is defined then,
for objects not based on scalars, Perl may silently fall
back on simple assignment &minus; that is, assignment of the
object reference. In effect, this disables the copy
constructor mechanism since no new copy of the object data
is created. This is almost certainly not what you want. (It
is, however, consistent: for example, Perl&rsquo;s fallback
for the &quot;++&quot; operator is to increment the
reference itself.)</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>How Perl
Chooses an Operator Implementation</b> <br>
Which is checked first, &quot;nomethod&quot; or
&quot;fallback&quot;? If the two operands of an operator are
of different types and both overload the operator, which
implementation is used? The following are the precedence
rules:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">If the first operand has
declared a subroutine to overload the operator then use that
implementation.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Otherwise, if fallback is <small>TRUE</small> or
undefined for the first operand then see if the rules for
autogeneration allows another of its operators to be used
instead.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Unless the operator is an assignment (&quot;+=&quot;,
&quot;&minus;=&quot;, etc.), repeat step (1) in respect of
the second operand.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Repeat Step (2) in respect of the second operand.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the first operand has a &quot;nomethod&quot; method
then use that.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If the second operand has a &quot;nomethod&quot; method
then use that.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>7.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If &quot;fallback&quot; is <small>TRUE</small> for both
operands then perform the usual operation for the operator,
treating the operands as numbers, strings, or booleans as
appropriate for the operator (see note).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>8.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Nothing worked &minus; die.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Where there is
only one operand (or only one operand with overloading) the
checks in respect of the other operand above are
skipped.</p>

<p style="margin-left:11%; margin-top: 1em">There are
exceptions to the above rules for dereference operations
(which, if Step 1 fails, always fall back to the normal,
built-in implementations &minus; see Dereferencing), and for
&quot;~~&quot; (which has its own set of rules &minus; see
&quot;Matching&quot; under &quot;Overloadable
Operations&quot; above).</p>

<p style="margin-left:11%; margin-top: 1em">Note on Step 7:
some operators have a different semantic depending on the
type of their operands. As there is no way to instruct Perl
to treat the operands as, e.g., numbers instead of strings,
the result here may not be what you expect. See &quot;
<small>BUGS AND PITFALLS&quot;</small> .</p>

<p style="margin-left:11%; margin-top: 1em"><b>Losing
Overloading</b> <br>
The restriction for the comparison operation is that even
if, for example, &quot;cmp&quot; should return a blessed
reference, the autogenerated &quot;lt&quot; function will
produce only a standard logical value based on the numerical
value of the result of &quot;cmp&quot;. In particular, a
working numeric conversion is needed in this case (possibly
expressed in terms of other conversions).</p>

<p style="margin-left:11%; margin-top: 1em">Similarly,
&quot;.=&quot; and &quot;x=&quot; operators lose their
mathemagical properties if the string conversion
substitution is applied.</p>

<p style="margin-left:11%; margin-top: 1em">When you
<b>chop()</b> a mathemagical object it is promoted to a
string and its mathemagical properties are lost. The same
can happen with other operations as well.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Inheritance
and Overloading</b> <br>
Overloading respects inheritance via the @ISA hierarchy.
Inheritance interacts with overloading in two ways. <br>
Method names in the &quot;use overload&quot; directive</p>

<p style="margin-left:17%;">If &quot;value&quot; in</p>

<p style="margin-left:17%; margin-top: 1em">use overload
key =&gt; value;</p>

<p style="margin-left:17%; margin-top: 1em">is a string, it
is interpreted as a method name &minus; which may (in the
usual way) be inherited from another class.</p>

<p style="margin-left:11%;">Overloading of an operation is
inherited by derived classes</p>

<p style="margin-left:17%;">Any class derived from an
overloaded class is also overloaded and inherits its
operator implementations. If the same operator is overloaded
in more than one ancestor then the implementation is
determined by the usual inheritance rules.</p>

<p style="margin-left:17%; margin-top: 1em">For example, if
&quot;A&quot; inherits from &quot;B&quot; and &quot;C&quot;
(in that order), &quot;B&quot; overloads &quot;+&quot; with
&quot;\&amp;D::plus_sub&quot;, and &quot;C&quot; overloads
&quot;+&quot; by &quot;plus_meth&quot;, then the subroutine
&quot;D::plus_sub&quot; will be called to implement
operation &quot;+&quot; for an object in package
&quot;A&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Note that in
Perl version prior to 5.18 inheritance of the
&quot;fallback&quot; key was not governed by the above
rules. The value of &quot;fallback&quot; in the first
overloaded ancestor was used. This was fixed in 5.18 to
follow the usual rules of inheritance.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Run-time
Overloading</b> <br>
Since all &quot;use&quot; directives are executed at
compile-time, the only way to change overloading during
run-time is to</p>

<p style="margin-left:11%; margin-top: 1em">eval 'use
overload &quot;+&quot; =&gt; \&amp;addmethod';</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use</p>

<p style="margin-left:11%; margin-top: 1em">eval 'no
overload &quot;+&quot;, &quot;&minus;&minus;&quot;,
&quot;&lt;=&quot;';</p>

<p style="margin-left:11%; margin-top: 1em">though the use
of these constructs during run-time is questionable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Functions</b> <br>
Package &quot;overload.pm&quot; provides the following
public functions: <br>
overload::StrVal(arg)</p>

<p style="margin-left:18%;">Gives the string value of
&quot;arg&quot; as in the absence of stringify overloading.
If you are using this to get the address of a reference
(useful for checking if two references point to the same
thing) then you may be better off using
&quot;builtin::refaddr()&quot; or
&quot;Scalar::Util::refaddr()&quot;, which are faster.</p>

<p style="margin-left:11%;">overload::Overloaded(arg)</p>

<p style="margin-left:18%;">Returns true if &quot;arg&quot;
is subject to overloading of some operations.</p>

<p style="margin-left:11%;">overload::Method(obj,op)</p>

<p style="margin-left:18%;">Returns &quot;undef&quot; or a
reference to the method that implements &quot;op&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">Such a method
always takes three arguments, which will be enforced if it
is an <small>XS</small> method.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Overloading
Constants</b> <br>
For some applications, the Perl parser mangles constants too
much. It is possible to hook into this process via
&quot;overload::constant()&quot; and
&quot;overload::remove_constant()&quot; functions.</p>

<p style="margin-left:11%; margin-top: 1em">These functions
take a hash as an argument. The recognized keys of this hash
are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>integer</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload integer constants,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>float</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload floating point constants,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>binary</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload octal and hexadecimal constants,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>q</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload &quot;q&quot;&minus;quoted strings, constant
pieces of &quot;qq&quot;&minus; and
&quot;qx&quot;&minus;quoted strings and here-documents,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="11%">


<p>qr</p></td>
<td width="1%"></td>
<td width="77%">


<p>to overload constant pieces of regular expressions.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
corresponding values are references to functions which take
three arguments: the first one is the <i>initial</i> string
form of the constant, the second one is how Perl interprets
this constant, the third one is how the constant is used.
Note that the initial string form does not contain string
delimiters, and has backslashes in backslash-delimiter
combinations stripped (thus the value of delimiter is not
relevant for processing of this string). The return value of
this function is how this constant is going to be
interpreted by Perl. The third argument is undefined unless
for overloaded &quot;q&quot;&minus; and
&quot;qr&quot;&minus; constants, it is &quot;q&quot; in
single-quote context (comes from strings, regular
expressions, and single-quote <small>HERE</small>
documents), it is &quot;tr&quot; for arguments of
&quot;tr&quot;/&quot;y&quot; operators, it is &quot;s&quot;
for right-hand side of &quot;s&quot;&minus;operator, and it
is &quot;qq&quot; otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Since an
expression &quot;ab$cd,,&quot; is just a shortcut for 'ab' .
$cd . ',,', it is expected that overloaded constant strings
are equipped with reasonable overloaded catenation operator,
otherwise absurd results will result. Similarly, negative
numbers are considered as negations of positive
constants.</p>

<p style="margin-left:11%; margin-top: 1em">Note that it is
probably meaningless to call the functions
<b>overload::constant()</b> and
<b>overload::remove_constant()</b> from anywhere but
<b>import()</b> and <b>unimport()</b> methods. From these
methods they may be called as</p>

<p style="margin-left:11%; margin-top: 1em">sub import {
<br>
shift; <br>
return unless @_; <br>
die &quot;unknown import: @_&quot; unless @_ == 1 and $_[0]
eq ':constant'; <br>
overload::constant integer =&gt; sub
{Math::BigInt&minus;&gt;new(shift)}; <br>
}</p>

<h2>IMPLEMENTATION
<a name="IMPLEMENTATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">What follows is
subject to change <small>RSN.</small></p>

<p style="margin-left:11%; margin-top: 1em">The table of
methods for all operations is cached in magic for the symbol
table hash for the package. The cache is invalidated during
processing of &quot;use overload&quot;, &quot;no
overload&quot;, new function definitions, and changes in
@ISA.</p>

<p style="margin-left:11%; margin-top: 1em">(Every SVish
thing has a magic queue, and magic is an entry in that
queue. This is how a single variable may participate in
multiple forms of magic simultaneously. For instance,
environment variables regularly have two forms at once:
their %ENV magic and their taint magic. However, the magic
which implements overloading is applied to the stashes,
which are rarely used directly, thus should not slow down
Perl.)</p>

<p style="margin-left:11%; margin-top: 1em">If a package
uses overload, it carries a special flag. This flag is also
set when new functions are defined or @ISA is modified.
There will be a slight speed penalty on the very first
operation thereafter that supports overloading, while the
overload tables are updated. If there is no overloading
present, the flag is turned off. Thus the only speed penalty
thereafter is the checking of this flag.</p>

<p style="margin-left:11%; margin-top: 1em">It is expected
that arguments to methods that are not explicitly supposed
to be changed are constant (but this is not enforced).</p>

<h2>COOKBOOK
<a name="COOKBOOK"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please add
examples to what follows!</p>

<p style="margin-left:11%; margin-top: 1em"><b>Two-face
Scalars</b> <br>
Put this in <i>two_face.pm</i> in your Perl library
directory:</p>

<p style="margin-left:11%; margin-top: 1em">package
two_face; # Scalars with separate string and <br>
# numeric values. <br>
sub new { my $p = shift; bless [@_], $p } <br>
use overload '&quot;&quot;' =&gt; \&amp;str, '0+' =&gt;
\&amp;num, fallback =&gt; 1; <br>
sub num {shift&minus;&gt;[1]} <br>
sub str {shift&minus;&gt;[0]}</p>

<p style="margin-left:11%; margin-top: 1em">Use it as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">require
two_face; <br>
my $seven = two_face&minus;&gt;new(&quot;vii&quot;, 7); <br>
printf &quot;seven=$seven, seven=%d, eight=%d\n&quot;,
$seven, $seven+1; <br>
print &quot;seven contains 'i'\n&quot; if $seven =~ /i/;</p>

<p style="margin-left:11%; margin-top: 1em">(The second
line creates a scalar which has both a string value, and a
numeric value.) This prints:</p>

<p style="margin-left:11%; margin-top: 1em">seven=vii,
seven=7, eight=8 <br>
seven contains 'i'</p>

<p style="margin-left:11%; margin-top: 1em"><b>Two-face
References</b> <br>
Suppose you want to create an object which is accessible as
both an array reference and a hash reference.</p>

<p style="margin-left:11%; margin-top: 1em">package
two_refs; <br>
use overload '%{}' =&gt; \&amp;gethash, '@{}' =&gt; sub { $
{shift()} }; <br>
sub new { <br>
my $p = shift; <br>
bless \ [@_], $p; <br>
} <br>
sub gethash { <br>
my %h; <br>
my $self = shift; <br>
tie %h, ref $self, $self; <br>
\%h; <br>
} <br>
sub TIEHASH { my $p = shift; bless \ shift, $p } <br>
my %fields; <br>
my $i = 0; <br>
$fields{$_} = $i++ foreach qw{zero one two three}; <br>
sub STORE { <br>
my $self = ${shift()}; <br>
my $key = $fields{shift()}; <br>
defined $key or die &quot;Out of band access&quot;; <br>
$$self&minus;&gt;[$key] = shift; <br>
} <br>
sub FETCH { <br>
my $self = ${shift()}; <br>
my $key = $fields{shift()}; <br>
defined $key or die &quot;Out of band access&quot;; <br>
$$self&minus;&gt;[$key]; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now one can
access an object using both the array and hash syntax:</p>

<p style="margin-left:11%; margin-top: 1em">my $bar =
two_refs&minus;&gt;new(3,4,5,6); <br>
$bar&minus;&gt;[2] = 11; <br>
$bar&minus;&gt;{two} == 11 or die 'bad hash fetch';</p>

<p style="margin-left:11%; margin-top: 1em">Note several
important features of this example. First of all, the
<i>actual</i> type of $bar is a scalar reference, and we do
not overload the scalar dereference. Thus we can get the
<i>actual</i> non-overloaded contents of $bar by just using
$$bar (what we do in functions which overload dereference).
Similarly, the object returned by the
<b><small>TIEHASH</small> ()</b> method is a scalar
reference.</p>

<p style="margin-left:11%; margin-top: 1em">Second, we
create a new tied hash each time the hash syntax is used.
This allows us not to worry about a possibility of a
reference loop, which would lead to a memory leak.</p>

<p style="margin-left:11%; margin-top: 1em">Both these
problems can be cured. Say, if we want to overload hash
dereference on a reference to an object which is
<i>implemented</i> as a hash itself, the only problem one
has to circumvent is how to access this <i>actual</i> hash
(as opposed to the <i>virtual</i> hash exhibited by the
overloaded dereference operator). Here is one possible
fetching routine:</p>

<p style="margin-left:11%; margin-top: 1em">sub access_hash
{ <br>
my ($self, $key) = (shift, shift); <br>
my $class = ref $self; <br>
bless $self, 'overload::dummy'; # Disable overloading of %{}
<br>
my $out = $self&minus;&gt;{$key}; <br>
bless $self, $class; # Restore overloading <br>
$out; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">To remove
creation of the tied hash on each access, one may an extra
level of indirection which allows a non-circular structure
of references:</p>

<p style="margin-left:11%; margin-top: 1em">package
two_refs1; <br>
use overload '%{}' =&gt; sub { ${shift()}&minus;&gt;[1] },
<br>
'@{}' =&gt; sub { ${shift()}&minus;&gt;[0] }; <br>
sub new { <br>
my $p = shift; <br>
my $a = [@_]; <br>
my %h; <br>
tie %h, $p, $a; <br>
bless \ [$a, \%h], $p; <br>
} <br>
sub gethash { <br>
my %h; <br>
my $self = shift; <br>
tie %h, ref $self, $self; <br>
\%h; <br>
} <br>
sub TIEHASH { my $p = shift; bless \ shift, $p } <br>
my %fields; <br>
my $i = 0; <br>
$fields{$_} = $i++ foreach qw{zero one two three}; <br>
sub STORE { <br>
my $a = ${shift()}; <br>
my $key = $fields{shift()}; <br>
defined $key or die &quot;Out of band access&quot;; <br>
$a&minus;&gt;[$key] = shift; <br>
} <br>
sub FETCH { <br>
my $a = ${shift()}; <br>
my $key = $fields{shift()}; <br>
defined $key or die &quot;Out of band access&quot;; <br>
$a&minus;&gt;[$key]; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now if $baz is
overloaded like this, then $baz is a reference to a
reference to the intermediate array, which keeps a reference
to an actual array, and the access hash. The <b>tie()</b>ing
object for the access hash is a reference to a reference to
the actual array, so</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">There are no loops of
references.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Both &quot;objects&quot; which are blessed into the
class &quot;two_refs1&quot; are references to a reference to
an array, thus references to a <i>scalar</i>. Thus the
accessor expression &quot;$$foo&minus;&gt;[$ind]&quot;
involves no overloaded operations.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Symbolic
Calculator</b> <br>
Put this in <i>symbolic.pm</i> in your Perl library
directory:</p>

<p style="margin-left:11%; margin-top: 1em">package
symbolic; # Primitive symbolic calculator <br>
use overload nomethod =&gt; \&amp;wrap; <br>
sub new { shift; bless ['n', @_] } <br>
sub wrap { <br>
my ($obj, $other, $inv, $meth) = @_; <br>
($obj, $other) = ($other, $obj) if $inv; <br>
bless [$meth, $obj, $other]; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This module is
very unusual as overloaded modules go: it does not provide
any usual overloaded operators, instead it provides an
implementation for &quot;nomethod&quot;. In this example the
&quot;nomethod&quot; subroutine returns an object which
encapsulates operations done over the objects:
&quot;symbolic&minus;&gt;new(3)&quot; contains &quot;['n',
3]&quot;, &quot;2 + symbolic&minus;&gt;new(3)&quot; contains
&quot;['+', 2, ['n', 3]]&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of the script which &quot;calculates&quot; the side
of circumscribed octagon using the above package:</p>

<p style="margin-left:11%; margin-top: 1em">require
symbolic; <br>
my $iter = 1; # 2**($iter+2) = 8 <br>
my $side = symbolic&minus;&gt;new(1); <br>
my $cnt = $iter; <br>
while ($cnt&minus;&minus;) { <br>
$side = (sqrt(1 + $side**2) &minus; 1)/$side; <br>
} <br>
print &quot;OK\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">The value of
$side is</p>

<p style="margin-left:11%; margin-top: 1em">['/',
['&minus;', ['sqrt', ['+', 1, ['**', ['n', 1], 2]], <br>
undef], 1], ['n', 1]]</p>

<p style="margin-left:11%; margin-top: 1em">Note that while
we obtained this value using a nice little script, there is
no simple way to <i>use</i> this value. In fact this value
may be inspected in debugger (see perldebug), but only if
&quot;bareStringify&quot; <b>O</b>ption is set, and not via
&quot;p&quot; command.</p>

<p style="margin-left:11%; margin-top: 1em">If one attempts
to print this value, then the overloaded operator
&quot;&quot; will be called, which will call
&quot;nomethod&quot; operator. The result of this operator
will be stringified again, but this result is again of type
&quot;symbolic&quot;, which will lead to an infinite
loop.</p>

<p style="margin-left:11%; margin-top: 1em">Add a
pretty-printer method to the module <i>symbolic.pm</i>:</p>

<p style="margin-left:11%; margin-top: 1em">sub pretty {
<br>
my ($meth, $a, $b) = @{+shift}; <br>
$a = 'u' unless defined $a; <br>
$b = 'u' unless defined $b; <br>
$a = $a&minus;&gt;pretty if ref $a; <br>
$b = $b&minus;&gt;pretty if ref $b; <br>
&quot;[$meth $a $b]&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now one can
finish the script by</p>

<p style="margin-left:11%; margin-top: 1em">print
&quot;side = &quot;, $side&minus;&gt;pretty,
&quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">The method
&quot;pretty&quot; is doing object-to-string conversion, so
it is natural to overload the operator &quot;&quot; using
this method. However, inside such a method it is not
necessary to pretty-print the <i>components</i> $a and $b of
an object. In the above subroutine &quot;[$meth $a $b]&quot;
is a catenation of some strings and components $a and $b. If
these components use overloading, the catenation operator
will look for an overloaded operator &quot;.&quot;; if not
present, it will look for an overloaded operator
&quot;&quot;. Thus it is enough to use</p>

<p style="margin-left:11%; margin-top: 1em">use overload
nomethod =&gt; \&amp;wrap, '&quot;&quot;' =&gt; \&amp;str;
<br>
sub str { <br>
my ($meth, $a, $b) = @{+shift}; <br>
$a = 'u' unless defined $a; <br>
$b = 'u' unless defined $b; <br>
&quot;[$meth $a $b]&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Now one can
change the last line of the script to</p>

<p style="margin-left:11%; margin-top: 1em">print
&quot;side = $side\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">which
outputs</p>

<p style="margin-left:11%; margin-top: 1em">side = [/
[&minus; [sqrt [+ 1 [** [n 1 u] 2]] u] 1] [n 1 u]]</p>

<p style="margin-left:11%; margin-top: 1em">and one can
inspect the value in debugger using all the possible
methods.</p>

<p style="margin-left:11%; margin-top: 1em">Something is
still amiss: consider the loop variable $cnt of the script.
It was a number, not an object. We cannot make this value of
type &quot;symbolic&quot;, since then the loop will not
terminate.</p>

<p style="margin-left:11%; margin-top: 1em">Indeed, to
terminate the cycle, the $cnt should become false. However,
the operator &quot;bool&quot; for checking falsity is
overloaded (this time via overloaded &quot;&quot;), and
returns a long string, thus any object of type
&quot;symbolic&quot; is true. To overcome this, we need a
way to compare an object to 0. In fact, it is easier to
write a numeric conversion routine.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
text of <i>symbolic.pm</i> with such a routine added (and
slightly modified <b>str()</b>):</p>

<p style="margin-left:11%; margin-top: 1em">package
symbolic; # Primitive symbolic calculator <br>
use overload <br>
nomethod =&gt; \&amp;wrap, '&quot;&quot;' =&gt; \&amp;str,
'0+' =&gt; \&amp;num; <br>
sub new { shift; bless ['n', @_] } <br>
sub wrap { <br>
my ($obj, $other, $inv, $meth) = @_; <br>
($obj, $other) = ($other, $obj) if $inv; <br>
bless [$meth, $obj, $other]; <br>
} <br>
sub str { <br>
my ($meth, $a, $b) = @{+shift}; <br>
$a = 'u' unless defined $a; <br>
if (defined $b) { <br>
&quot;[$meth $a $b]&quot;; <br>
} else { <br>
&quot;[$meth $a]&quot;; <br>
} <br>
} <br>
my %subr = ( n =&gt; sub {$_[0]}, <br>
sqrt =&gt; sub {sqrt $_[0]}, <br>
'&minus;' =&gt; sub {shift() &minus; shift()}, <br>
'+' =&gt; sub {shift() + shift()}, <br>
'/' =&gt; sub {shift() / shift()}, <br>
'*' =&gt; sub {shift() * shift()}, <br>
'**' =&gt; sub {shift() ** shift()}, <br>
); <br>
sub num { <br>
my ($meth, $a, $b) = @{+shift}; <br>
my $subr = $subr{$meth} <br>
or die &quot;Do not know how to ($meth) in symbolic&quot;;
<br>
$a = $a&minus;&gt;num if ref $a eq __PACKAGE__; <br>
$b = $b&minus;&gt;num if ref $b eq __PACKAGE__; <br>
$subr&minus;&gt;($a,$b); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">All the work of
numeric conversion is done in %subr and <b>num()</b>. Of
course, %subr is not complete, it contains only operators
used in the example below. Here is the extra-credit
question: why do we need an explicit recursion in
<b>num()</b>? (Answer is at the end of this section.)</p>

<p style="margin-left:11%; margin-top: 1em">Use this module
like this:</p>

<p style="margin-left:11%; margin-top: 1em">require
symbolic; <br>
my $iter = symbolic&minus;&gt;new(2); # 16&minus;gon <br>
my $side = symbolic&minus;&gt;new(1); <br>
my $cnt = $iter; <br>
while ($cnt) { <br>
$cnt = $cnt &minus; 1; # Mutator '&minus;&minus;' not
implemented <br>
$side = (sqrt(1 + $side**2) &minus; 1)/$side; <br>
} <br>
printf &quot;%s=%f\n&quot;, $side, $side; <br>
printf &quot;pi=%f\n&quot;, $side*(2**($iter+2));</p>

<p style="margin-left:11%; margin-top: 1em">It prints
(without so many line breaks)</p>

<p style="margin-left:11%; margin-top: 1em">[/ [&minus;
[sqrt [+ 1 [** [/ [&minus; [sqrt [+ 1 [** [n 1] 2]]] 1] <br>
[n 1]] 2]]] 1] <br>
[/ [&minus; [sqrt [+ 1 [** [n 1] 2]]] 1] [n 1]]]=0.198912
<br>
pi=3.182598</p>

<p style="margin-left:11%; margin-top: 1em">The above
module is very primitive. It does not implement mutator
methods (&quot;++&quot;, &quot;&minus;=&quot; and so on),
does not do deep copying (not required without mutators!),
and implements only those arithmetic operations which are
used in the example.</p>

<p style="margin-left:11%; margin-top: 1em">To implement
most arithmetic operations is easy; one should just use the
tables of operations, and change the code which fills %subr
to</p>

<p style="margin-left:11%; margin-top: 1em">my %subr = (
'n' =&gt; sub {$_[0]} ); <br>
foreach my $op (split &quot; &quot;,
$overload::ops{with_assign}) { <br>
$subr{$op} = $subr{&quot;$op=&quot;} = eval &quot;sub
{shift() $op shift()}&quot;; <br>
} <br>
my @bins = qw(binary 3way_comparison num_comparison
str_comparison); <br>
foreach my $op (split &quot; &quot;, &quot;@overload::ops{
@bins }&quot;) { <br>
$subr{$op} = eval &quot;sub {shift() $op shift()}&quot;;
<br>
} <br>
foreach my $op (split &quot; &quot;,
&quot;@overload::ops{qw(unary func)}&quot;) { <br>
print &quot;defining '$op'\n&quot;; <br>
$subr{$op} = eval &quot;sub {$op shift()}&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Since
subroutines implementing assignment operators are not
required to modify their operands (see &quot;Overloadable
Operations&quot; above), we do not need anything special to
make &quot;+=&quot; and friends work, besides adding these
operators to %subr and defining a copy constructor (needed
since Perl has no way to know that the implementation of
'+=' does not mutate the argument &minus; see &quot;Copy
Constructor&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">To implement a
copy constructor, add &quot;'=' =&gt; \&amp;cpy&quot; to
&quot;use overload&quot; line, and code (this code assumes
that mutators change things one level deep only, so
recursive copying is not needed):</p>

<p style="margin-left:11%; margin-top: 1em">sub cpy { <br>
my $self = shift; <br>
bless [@$self], ref $self; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">To make
&quot;++&quot; and &quot;&minus;&minus;&quot; work, we need
to implement actual mutators, either directly, or in
&quot;nomethod&quot;. We continue to do things inside
&quot;nomethod&quot;, thus add</p>

<p style="margin-left:11%; margin-top: 1em">if ($meth eq
'++' or $meth eq '&minus;&minus;') { <br>
@$obj = ($meth, (bless [@$obj]), 1); # Avoid circular
reference <br>
return $obj; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">after the first
line of <b>wrap()</b>. This is not a most effective
implementation, one may consider</p>

<p style="margin-left:11%; margin-top: 1em">sub inc { $_[0]
= bless ['++', shift, 1]; }</p>

<p style="margin-left:11%; margin-top: 1em">instead.</p>

<p style="margin-left:11%; margin-top: 1em">As a final
remark, note that one can fill %subr by</p>

<p style="margin-left:11%; margin-top: 1em">my %subr = (
'n' =&gt; sub {$_[0]} ); <br>
foreach my $op (split &quot; &quot;,
$overload::ops{with_assign}) { <br>
$subr{$op} = $subr{&quot;$op=&quot;} = eval &quot;sub
{shift() $op shift()}&quot;; <br>
} <br>
my @bins = qw(binary 3way_comparison num_comparison
str_comparison); <br>
foreach my $op (split &quot; &quot;, &quot;@overload::ops{
@bins }&quot;) { <br>
$subr{$op} = eval &quot;sub {shift() $op shift()}&quot;;
<br>
} <br>
foreach my $op (split &quot; &quot;,
&quot;@overload::ops{qw(unary func)}&quot;) { <br>
$subr{$op} = eval &quot;sub {$op shift()}&quot;; <br>
} <br>
$subr{'++'} = $subr{'+'}; <br>
$subr{'&minus;&minus;'} = $subr{'&minus;'};</p>

<p style="margin-left:11%; margin-top: 1em">This finishes
implementation of a primitive symbolic calculator in 50
lines of Perl code. Since the numeric values of
subexpressions are not cached, the calculator is very
slow.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
answer for the exercise: In the case of <b>str()</b>, we
need no explicit recursion since the overloaded
&quot;.&quot;&minus;operator will fall back to an existing
overloaded operator &quot;&quot;. Overloaded arithmetic
operators <i>do not</i> fall back to numeric conversion if
&quot;fallback&quot; is not explicitly requested. Thus
without an explicit recursion <b>num()</b> would convert
&quot;['+', $a, $b]&quot; to &quot;$a + $b&quot;, which
would just rebuild the argument of <b>num()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">If you wonder
why defaults for conversion are different for <b>str()</b>
and <b>num()</b>, note how easy it was to write the symbolic
calculator. This simplicity is due to an appropriate choice
of defaults. One extra note: due to the explicit recursion
<b>num()</b> is more fragile than <b>sym()</b>: we need to
explicitly check for the type of $a and $b. If components $a
and $b happen to be of some related type, this may lead to
problems.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Really</i>
<b>Symbolic Calculator</b> <br>
One may wonder why we call the above calculator symbolic.
The reason is that the actual calculation of the value of
expression is postponed until the value is <i>used</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To see it in
action, add a method</p>

<p style="margin-left:11%; margin-top: 1em">sub STORE {
<br>
my $obj = shift; <br>
$#$obj = 1; <br>
@$obj&minus;&gt;[0,1] = ('=', shift); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">to the package
&quot;symbolic&quot;. After this change one can do</p>

<p style="margin-left:11%; margin-top: 1em">my $a =
symbolic&minus;&gt;new(3); <br>
my $b = symbolic&minus;&gt;new(4); <br>
my $c = sqrt($a**2 + $b**2);</p>

<p style="margin-left:11%; margin-top: 1em">and the numeric
value of $c becomes 5. However, after calling</p>


<p style="margin-left:11%; margin-top: 1em">$a&minus;&gt;STORE(12);
$b&minus;&gt;STORE(5);</p>

<p style="margin-left:11%; margin-top: 1em">the numeric
value of $c becomes 13. There is no doubt now that the
module symbolic provides a <i>symbolic</i> calculator
indeed.</p>

<p style="margin-left:11%; margin-top: 1em">To hide the
rough edges under the hood, provide a <b>tie()</b>d
interface to the package &quot;symbolic&quot;. Add
methods</p>

<p style="margin-left:11%; margin-top: 1em">sub TIESCALAR {
my $pack = shift; $pack&minus;&gt;new(@_) } <br>
sub FETCH { shift } <br>
sub nop { } # Around a bug</p>

<p style="margin-left:11%; margin-top: 1em">(the bug, fixed
in Perl 5.14, is described in &quot;
<small>BUGS&quot;</small> ). One can use this new interface
as</p>

<p style="margin-left:11%; margin-top: 1em">tie $a,
'symbolic', 3; <br>
tie $b, 'symbolic', 4; <br>
$a&minus;&gt;nop; $b&minus;&gt;nop; # Around a bug <br>
my $c = sqrt($a**2 + $b**2);</p>

<p style="margin-left:11%; margin-top: 1em">Now numeric
value of $c is 5. After &quot;$a = 12; $b = 5&quot; the
numeric value of $c becomes 13. To insulate the user of the
module add a method</p>

<p style="margin-left:11%; margin-top: 1em">sub vars { my
$p = shift; tie($_, $p), $_&minus;&gt;nop foreach @_; }</p>

<p style="margin-left:11%; margin-top: 1em">Now</p>

<p style="margin-left:11%; margin-top: 1em">my ($a, $b);
<br>
symbolic&minus;&gt;vars($a, $b); <br>
my $c = sqrt($a**2 + $b**2); <br>
$a = 3; $b = 4; <br>
printf &quot;c5 %s=%f\n&quot;, $c, $c; <br>
$a = 12; $b = 5; <br>
printf &quot;c13 %s=%f\n&quot;, $c, $c;</p>

<p style="margin-left:11%; margin-top: 1em">shows that the
numeric value of $c follows changes to the values of $a and
$b.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Ilya
Zakharevich
&lt;<i>ilya@math.mps.ohio&minus;state.edu</i>&gt;.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
&quot;overloading&quot; pragma can be used to enable or
disable overloaded operations within a lexical scope &minus;
see overloading.</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When Perl is
run with the <b>&minus;Do</b> switch or its equivalent,
overloading induces diagnostic messages.</p>

<p style="margin-left:11%; margin-top: 1em">Using the
&quot;m&quot; command of Perl debugger (see perldebug) one
can deduce which operations are overloaded (and which
ancestor triggers this overloading). Say, if &quot;eq&quot;
is overloaded, then the method &quot;(eq&quot; is shown by
debugger. The method &quot;()&quot; corresponds to the
&quot;fallback&quot; key (in fact a presence of this method
shows that this package has overloading enabled, and it is
what is used by the &quot;Overloaded&quot; function of
module &quot;overload&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">The module
might issue the following warnings: <br>
Odd number of arguments for overload::constant</p>

<p style="margin-left:17%;">(W) The call to
overload::constant contained an odd number of arguments. The
arguments should come in pairs.</p>

<p style="margin-left:11%;">&rsquo;%s&rsquo; is not an
overloadable type</p>

<p style="margin-left:17%;">(W) You tried to overload a
constant type the overload package is unaware of.</p>

<p style="margin-left:11%;">&rsquo;%s&rsquo; is not a code
reference</p>

<p style="margin-left:17%;">(W) The second (fourth, sixth,
...) argument of overload::constant needs to be a code
reference. Either an anonymous subroutine, or a reference to
a subroutine.</p>

<p style="margin-left:11%;">overload arg &rsquo;%s&rsquo;
is invalid</p>

<p style="margin-left:17%;">(W) &quot;use overload&quot;
was passed an argument it did not recognize. Did you mistype
an operator?</p>

<h2>BUGS AND PITFALLS
<a name="BUGS AND PITFALLS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">A pitfall when fallback is
<small>TRUE</small> and Perl resorts to a built-in
implementation of an operator is that some operators have
more than one semantic, for example &quot;|&quot;:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">use overload
'0+' =&gt; sub { $_[0]&minus;&gt;{n}; }, <br>
fallback =&gt; 1; <br>
my $x = bless { n =&gt; 4 }, &quot;main&quot;; <br>
my $y = bless { n =&gt; 8 }, &quot;main&quot;; <br>
print $x | $y, &quot;\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">You might
expect this to output &quot;12&quot;. In fact, it prints
&quot;&lt;&quot;: the <small>ASCII</small> result of
treating &quot;|&quot; as a bitwise string operator &minus;
that is, the result of treating the operands as the strings
&quot;4&quot; and &quot;8&quot; rather than numbers. The
fact that numify (&quot;0+&quot;) is implemented but
stringify (&quot;&quot;) isn&rsquo;t makes no difference
since the latter is simply autogenerated from the
former.</p>

<p style="margin-left:17%; margin-top: 1em">The only way to
change this is to provide your own subroutine for '|'.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Magic autogeneration increases
the potential for inadvertently creating self-referential
structures. Currently Perl will not free self-referential
structures until cycles are explicitly broken. For
example,</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">use overload
'+' =&gt; 'add'; <br>
sub add { bless [ \$_[0], \$_[1] ] };</p>

<p style="margin-left:17%; margin-top: 1em">is asking for
trouble, since</p>

<p style="margin-left:17%; margin-top: 1em">$obj += $y;</p>

<p style="margin-left:17%; margin-top: 1em">will
effectively become</p>

<p style="margin-left:17%; margin-top: 1em">$obj =
add($obj, $y, undef);</p>

<p style="margin-left:17%; margin-top: 1em">with the same
result as</p>

<p style="margin-left:17%; margin-top: 1em">$obj = [\$obj,
\$foo];</p>

<p style="margin-left:17%; margin-top: 1em">Even if no
<i>explicit</i> assignment-variants of operators are present
in the script, they may be generated by the optimizer. For
example,</p>

<p style="margin-left:17%; margin-top: 1em">&quot;obj =
$obj\n&quot;</p>

<p style="margin-left:17%; margin-top: 1em">may be
optimized to</p>

<p style="margin-left:17%; margin-top: 1em">my $tmp = 'obj
= ' . $obj; $tmp .= &quot;\n&quot;;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">The symbol table is filled with
names looking like line-noise.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>This bug was fixed in Perl 5.18, but may still trip you
up if you are using older versions:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">For the purpose
of inheritance every overloaded package behaves as if
&quot;fallback&quot; is present (possibly undefined). This
may create interesting effects if some package is not
overloaded, but inherits from two overloaded packages.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Before Perl 5.14, the relation
between overloading and <b>tie()</b>ing was broken.
Overloading was triggered or not based on the
<i>previous</i> class of the <b>tie()</b>d variable.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This happened
because the presence of overloading was checked too early,
before any <b>tie()</b>d access was attempted. If the class
of the value <b><small>FETCH</small> ()</b>ed from the tied
variable does not change, a simple workaround for code that
is to run on older Perl versions is to access the value (via
&quot;() = $foo&quot; or some such) immediately after
<b>tie()</b>ing, so that after this call the <i>previous</i>
class coincides with the current one.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Barewords are not covered by
overloaded string constants.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>The range operator &quot;..&quot; cannot be
overloaded.</p> </td></tr>
 </table>
<hr>
</body>
</html>
