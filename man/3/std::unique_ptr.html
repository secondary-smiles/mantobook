<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:14 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::unique_ptr&lt; _Tp, _Dp &gt;</title>

</head>
<body>
<h1>std::unique_ptr</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::unique_ptr&lt;
_Tp, _Dp &gt; &minus; A move-only smart pointer that manages
unique ownership of a resource.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;memory&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">using <b>deleter_type</b> = _Dp
<br>
using <b>element_type</b> = _Tp <br>
using <b>pointer</b> = typename __uniq_ptr_impl&lt; _Tp, _Dp
&gt;::pointer</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Del =
_Dp, typename = _DeleterConstraint&lt;_Del&gt;&gt; constexpr
<b>unique_ptr</b> () noexcept <br>
Default constructor, creates a unique_ptr that owns
nothing.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p>template&lt;typename _Up , typename = _Require&lt;</p></td>
<td width="69%"></td>
<td width="8%"></td>
<td width="15%">


<p>is_convertible&lt;_Up*, _Tp*&gt;, is_same&lt;_Dp,
default_delete&lt;_Tp&gt;&gt;&gt;&gt; <b>unique_ptr</b>
(<b>auto_ptr</b>&lt; _Up &gt; &amp;&amp;__u) noexcept</p></td></tr>
</table>

<p style="margin-left:17%;">Converting constructor from
<tt>auto_ptr</tt>. <b><br>
unique_ptr</b> (const <b>unique_ptr</b> &amp;)=delete <br>
template&lt;typename _Del = _Dp, typename =
_DeleterConstraint&lt;_Del&gt;&gt; constexpr
<b>unique_ptr</b> (nullptr_t) noexcept <br>
Creates a unique_ptr that owns nothing. <br>
template&lt;typename _Del = _Dp, typename =
_DeleterConstraint&lt;_Del&gt;&gt; constexpr
<b>unique_ptr</b> (pointer __p) noexcept <br>
template&lt;typename _Del = deleter_type, typename =
_Require&lt;is_move_constructible&lt;_Del&gt;&gt;&gt;
constexpr <b>unique_ptr</b> (pointer __p,
__enable_if_t&lt;!<b>is_lvalue_reference</b>&lt; _Del
&gt;::value, _Del &amp;&amp; &gt; __d) noexcept <br>
template&lt;typename _Del = deleter_type, typename =
_Require&lt;is_copy_constructible&lt;_Del&gt;&gt;&gt;
constexpr <b>unique_ptr</b> (pointer __p, const deleter_type
&amp;__d) noexcept <br>
template&lt;typename _Del = deleter_type, typename _DelUnref
= typename remove_reference&lt;_Del&gt;::type&gt; constexpr
<b>unique_ptr</b> (pointer, __enable_if_t&lt;
<b>is_lvalue_reference</b>&lt; _Del &gt;::value, _DelUnref
&amp;&amp; &gt;)=delete <b><br>
unique_ptr</b> (<b>unique_ptr</b> &amp;&amp;)=default <br>
Move constructor.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>template&lt;typename _Up , typename _Ep , typename =
_Require&lt; __safe_conversion_up&lt;_Up, _Ep&gt;,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>__conditional_t&lt;is_reference&lt;_Dp&gt;::value,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>is_same&lt;_Ep, _Dp&gt;,</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%"></td>
<td width="92%">


<p>is_convertible&lt;_Ep, _Dp&gt;&gt;&gt;&gt; constexpr
<b>unique_ptr</b> (<b>unique_ptr</b>&lt; _Up, _Ep &gt;
&amp;&amp;__u) noexcept</p></td></tr>
</table>

<p style="margin-left:17%;">Converting constructor from
another type. <b><br>
~unique_ptr</b> () noexcept <br>
Destructor, invokes the deleter if the stored pointer is not
null. <br>
constexpr pointer <b>get</b> () const noexcept <br>
Return the stored pointer. <br>
constexpr const deleter_type &amp; <b>get_deleter</b> ()
const noexcept <br>
Return a reference to the stored deleter. <br>
constexpr deleter_type &amp; <b>get_deleter</b> () noexcept
<br>
Return a reference to the stored deleter. <br>
constexpr <b>operator bool</b> () const noexcept <br>
Return <tt>true</tt> if the stored pointer is not null. <br>
constexpr <b>add_lvalue_reference</b>&lt; element_type
&gt;::type <b>operator*</b> () const
noexcept(noexcept(*<b>std::declval</b>&lt; pointer &gt;()))
<br>
Dereference the stored pointer. <br>
constexpr pointer <b>operator&minus;&gt;</b> () const
noexcept <br>
Return the stored pointer. <b><br>
unique_ptr</b> &amp; <b>operator=</b> (const
<b>unique_ptr</b> &amp;)=delete <br>
constexpr <b>unique_ptr</b> &amp; <b>operator=</b>
(nullptr_t) noexcept <br>
Reset the unique_ptr to empty, invoking the deleter if
necessary. <b><br>
unique_ptr</b> &amp; <b>operator=</b> (<b>unique_ptr</b>
&amp;&amp;)=default <br>
Move assignment operator. <br>
template&lt;typename _Up , typename _Ep &gt; constexpr
<b>enable_if</b>&lt; __and_&lt; __safe_conversion_up&lt;
_Up, _Ep &gt;, <b>is_assignable</b>&lt; deleter_type &amp;,
_Ep &amp;&amp; &gt; &gt;::value, <b>unique_ptr</b> &amp;
&gt;::type <b>operator=</b> (<b>unique_ptr</b>&lt; _Up, _Ep
&gt; &amp;&amp;__u) noexcept <br>
Assignment from another type. <br>
constexpr pointer <b>release</b> () noexcept <br>
Release ownership of any stored pointer. <br>
constexpr void <b>reset</b> (pointer __p=pointer()) noexcept
<br>
Replace the stored pointer. <br>
constexpr void <b>swap</b> (<b>unique_ptr</b> &amp;__u)
noexcept <br>
Exchange the pointer and deleter with another object.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Related
Functions</b> <br>
(Note that these are not member functions.)</p>

<p style="margin-left:17%;">template&lt;typename _Tp ,
typename... _Args&gt; constexpr __detail::__unique_ptr_t&lt;
_Tp &gt; <b>make_unique</b> (_Args &amp;&amp;... __args)
<br>
template&lt;typename _Tp , typename... _Args&gt;
__detail::__invalid_make_unique_t&lt; _Tp &gt;
<b>make_unique</b> (_Args &amp;&amp;...)=delete <br>
template&lt;typename _Tp &gt; constexpr
__detail::__unique_ptr_array_t&lt; _Tp &gt;
<b>make_unique</b> (size_t __num) <br>
template&lt;typename _Tp &gt; constexpr
__detail::__unique_ptr_t&lt; _Tp &gt;
<b>make_unique_for_overwrite</b> () <br>
template&lt;typename _Tp , typename... _Args&gt;
__detail::__invalid_make_unique_t&lt; _Tp &gt;
<b>make_unique_for_overwrite</b> (_Args
&amp;&amp;...)=delete <br>
template&lt;typename _Tp &gt; constexpr
__detail::__unique_ptr_array_t&lt; _Tp &gt;
<b>make_unique_for_overwrite</b> (size_t __num) <br>
template&lt;typename _CharT , typename _Traits , typename
_Tp , typename _Dp &gt; <b>basic_ostream</b>&lt; _CharT,
_Traits &gt; &amp; <b>operator&lt;&lt;</b>
(<b>basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;__os,
const <b>unique_ptr</b>&lt; _Tp, _Dp &gt; &amp;__p) <br>
Stream output operator for unique_ptr. <br>
template&lt;typename _Tp , typename _Dp &gt; constexpr
<b>enable_if</b>&lt; __is_swappable&lt; _Dp &gt;::value
&gt;::type <b>swap</b> (<b>unique_ptr</b>&lt; _Tp, _Dp &gt;
&amp;__x, <b>unique_ptr</b>&lt; _Tp, _Dp &gt; &amp;__y)
noexcept</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;</b> <br>
class std::unique_ptr&lt; _Tp, _Dp &gt;&quot;A move-only
smart pointer that manages unique ownership of a
resource.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++11</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
template&lt;typename _Del = _Dp, typename =
_DeleterConstraint&lt;_Del&gt;&gt; constexpr
std::unique_ptr&lt; _Tp, _Dp &gt;::unique_ptr ()</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Default constructor, creates a unique_ptr that owns
nothing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
template&lt;typename _Del = _Dp, typename =
_DeleterConstraint&lt;_Del&gt;&gt; constexpr
std::unique_ptr&lt; _Tp, _Dp &gt;::unique_ptr (pointer
__p)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Takes ownership of a pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer to an
object of <tt>element_type</tt></p>

<p style="margin-left:11%; margin-top: 1em">The deleter
will be value-initialized.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
template&lt;typename _Del = deleter_type, typename =
_Require&lt;is_copy_constructible&lt;_Del&gt;&gt;&gt;
constexpr std::unique_ptr&lt; _Tp, _Dp &gt;::unique_ptr
(pointer __p, const deleter_type &amp; __d)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Takes ownership of a pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer to an
object of <tt>element_type</tt> <i><br>
__d</i> A reference to a deleter.</p>

<p style="margin-left:11%; margin-top: 1em">The deleter
will be initialized with <tt>__d</tt></p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
template&lt;typename _Del = deleter_type, typename =
_Require&lt;is_move_constructible&lt;_Del&gt;&gt;&gt;
constexpr std::unique_ptr&lt; _Tp, _Dp &gt;::unique_ptr
(pointer __p, __enable_if_t&lt;!is_lvalue_reference&lt; _Del
&gt;::value, _Del &amp;&amp; &gt; __d)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Takes ownership of a pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer to an
object of <tt>element_type</tt> <i><br>
__d</i> An rvalue reference to a (non-reference)
deleter.</p>

<p style="margin-left:11%; margin-top: 1em">The deleter
will be initialized with <tt>std::move(__d)</tt></p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
template&lt;typename _Del = _Dp, typename =
_DeleterConstraint&lt;_Del&gt;&gt; constexpr
std::unique_ptr&lt; _Tp, _Dp &gt;::unique_ptr
(nullptr_t)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Creates a unique_ptr that owns nothing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
std::unique_ptr&lt; _Tp, _Dp &gt;::unique_ptr
(unique_ptr&lt; _Tp, _Dp &gt; &amp;&amp;)</b>
<tt>[default]</tt> <br>
Move constructor.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>template&lt;typename _Tp , typename _Dp =
default_delete&lt;_Tp&gt;&gt; template&lt;typename _Up ,
typename _Ep , typename = _Require&lt;
__safe_conversion_up&lt;_Up, _Ep&gt;,</b></p></td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">



<p><b>__conditional_t&lt;is_reference&lt;_Dp&gt;::value,</b></p> </td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>is_same&lt;_Ep, _Dp&gt;,</b></p></td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">
</td></tr>
<tr valign="top" align="left">
<td width="5%"></td>
<td width="3%"></td>
<td width="92%">


<p><b>is_convertible&lt;_Ep, _Dp&gt;&gt;&gt;&gt; constexpr
std::unique_ptr&lt; _Tp, _Dp &gt;::unique_ptr
(unique_ptr&lt; _Up, _Ep &gt; &amp;&amp; __u)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt></p> </td></tr>
</table>

<p style="margin-left:11%;">Converting constructor from
another type. Requires that the pointer owned by
<tt>__u</tt> is convertible to the type of pointer owned by
this object, <tt>__u</tt> does not own an array, and
<tt>__u</tt> has a compatible deleter type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp &gt; template&lt;typename _Up , typename
&gt; std::unique_ptr&lt; _Tp, _Dp &gt;::unique_ptr
(auto_ptr&lt; _Up &gt; &amp;&amp; __u)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Converting constructor from <tt>auto_ptr</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
std::unique_ptr&lt; _Tp, _Dp &gt;::~unique_ptr ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Destructor, invokes the deleter if the stored pointer is not
null.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::get_deleter()</b>, and
<b>std::move()</b>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
pointer std::unique_ptr&lt; _Tp, _Dp &gt;::get () const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Return the stored pointer.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::unique_ptr&lt; _Tp, _Dp
&gt;::make_unique_for_overwrite()</b>,
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::operator bool()</b>,
<b>std::unique_ptr&lt; _Tp[], _Dp &gt;::operator bool()</b>,
<b>std::operator!=()</b>, <b>std::unique_ptr&lt; _Tp, _Dp
&gt;::operator*()</b>, <b>std::unique_ptr&lt; _Tp, _Dp
&gt;::operator&minus;&gt;()</b>, <b>std::operator&lt;()</b>,
<b>std::operator==()</b>, <b>std::operator&gt;()</b>, and
<b>std::unique_ptr&lt; _Tp[], _Dp
&gt;::operator[]()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
const deleter_type &amp; std::unique_ptr&lt; _Tp, _Dp
&gt;::get_deleter () const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Return a reference to the stored deleter.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
deleter_type &amp; std::unique_ptr&lt; _Tp, _Dp
&gt;::get_deleter ()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Return a reference to the stored deleter.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::unique_ptr&lt; _Tp[], _Dp &gt;::~unique_ptr()</b>,
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::~unique_ptr()</b>,
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::operator=()</b>, and
<b>std::unique_ptr&lt; _Tp[], _Dp &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
std::unique_ptr&lt; _Tp, _Dp &gt;::operator bool ()
const</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Return <tt>true</tt> if the stored pointer is not null.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::get()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
add_lvalue_reference&lt; element_type &gt;::type
std::unique_ptr&lt; _Tp, _Dp &gt;::operator* () const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Dereference the stored pointer.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::get()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
pointer std::unique_ptr&lt; _Tp, _Dp
&gt;::operator&minus;&gt; () const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Return the stored pointer.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::get()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
unique_ptr &amp; std::unique_ptr&lt; _Tp, _Dp
&gt;::operator= (nullptr_t)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Reset the unique_ptr to empty, invoking the deleter if
necessary.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::reset()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
unique_ptr &amp; std::unique_ptr&lt; _Tp, _Dp
&gt;::operator= (unique_ptr&lt; _Tp, _Dp &gt;
&amp;&amp;)</b> <tt>[default]</tt> <br>
Move assignment operator. Invokes the deleter if this object
owns a pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt;
template&lt;typename _Up , typename _Ep &gt; constexpr
enable_if&lt; __and_&lt; __safe_conversion_up&lt; _Up, _Ep
&gt;, is_assignable&lt; deleter_type &amp;, _Ep &amp;&amp;
&gt; &gt;::value, unique_ptr &amp; &gt;::type
std::unique_ptr&lt; _Tp, _Dp &gt;::operator= (unique_ptr&lt;
_Up, _Ep &gt; &amp;&amp; __u)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Assignment from another type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__u</i> The object to
transfer ownership from, which owns a convertible pointer to
a non-array object.</p>

<p style="margin-left:11%; margin-top: 1em">Invokes the
deleter if this object owns a pointer.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::get_deleter()</b>, and
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::reset()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
pointer std::unique_ptr&lt; _Tp, _Dp &gt;::release ()</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Release ownership of any stored pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
void std::unique_ptr&lt; _Tp, _Dp &gt;::reset (pointer __p
=</b> <tt>pointer()</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Replace the stored pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> The new pointer to
store.</p>

<p style="margin-left:11%; margin-top: 1em">The deleter
will be invoked if a pointer is already owned.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::unique_ptr&lt; _Tp, _Dp &gt;::operator=()</b>, and
<b>std::unique_ptr&lt; _Tp[], _Dp &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Dp = default_delete&lt;_Tp&gt;&gt; constexpr
void std::unique_ptr&lt; _Tp, _Dp &gt;::swap (unique_ptr&lt;
_Tp, _Dp &gt; &amp; __u)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Exchange the pointer and deleter with another object.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
