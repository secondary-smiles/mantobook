<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:13 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::list&lt; _Tp, _Alloc &gt;</title>

</head>
<body>
<h1>std::list</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">std::list&lt;
_Tp, _Alloc &gt; &minus; A standard container with linear
time access to elements, and fixed time insertion/deletion
at any point in the sequence.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;list&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::_List_base&lt; _Tp, _Alloc &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Alloc
<b>allocator_type</b> <br>
typedef <b>_List_const_iterator</b>&lt; _Tp &gt;
<b>const_iterator</b> <br>
typedef _Tp_alloc_traits::const_pointer <b>const_pointer</b>
<br>
typedef _Tp_alloc_traits::const_reference
<b>const_reference</b> <br>
typedef <b>std::reverse_iterator</b>&lt;
<b>const_iterator</b> &gt; <b>const_reverse_iterator</b>
<br>
typedef ptrdiff_t <b>difference_type</b> <br>
typedef <b>_List_iterator</b>&lt; _Tp &gt; <b>iterator</b>
<br>
typedef _Tp_alloc_traits::pointer <b>pointer</b> <br>
typedef _Tp_alloc_traits::reference <b>reference</b> <br>
typedef <b>std::reverse_iterator</b>&lt; <b>iterator</b>
&gt; <b>reverse_iterator</b> <br>
typedef size_t <b>size_type</b> <br>
typedef _Tp <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>list</b> ()=default <br>
Creates a list with no elements. <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>list</b>
(_InputIterator __first, _InputIterator __last, const
allocator_type &amp;__a=allocator_type()) <br>
Builds a list from a range. <b><br>
list</b> (const allocator_type &amp;__a) noexcept <br>
Creates a list with no elements. <b><br>
list</b> (const <b>list</b> &amp;__x) <br>
List copy constructor. <b><br>
list</b> (const <b>list</b> &amp;__x, const
__type_identity_t&lt; allocator_type &gt; &amp;__a) <b><br>
list</b> (<b>initializer_list</b>&lt; value_type &gt; __l,
const allocator_type &amp;__a=allocator_type()) <br>
Builds a list from an initializer_list. <b><br>
list</b> (<b>list</b> &amp;&amp;)=default <br>
List move constructor. <b><br>
list</b> (<b>list</b> &amp;&amp;__x, const
__type_identity_t&lt; allocator_type &gt; &amp;__a)
noexcept(_Node_alloc_traits::_S_always_equal()) <b><br>
list</b> (size_type __n, const allocator_type
&amp;__a=allocator_type()) <br>
Creates a list with default constructed elements. <b><br>
list</b> (size_type __n, const value_type &amp;__value,
const allocator_type &amp;__a=allocator_type()) <br>
Creates a list with copies of an exemplar element. <b><br>
~list</b> ()=default <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; void
<b>assign</b> (_InputIterator __first, _InputIterator
__last) <br>
Assigns a range to a list. <br>
void <b>assign</b> (<b>initializer_list</b>&lt; value_type
&gt; __l) <br>
Assigns an initializer_list to a list. <br>
void <b>assign</b> (size_type __n, const value_type
&amp;__val) <br>
Assigns a given value to a list. <br>
const_reference <b>back</b> () const noexcept <br>
reference <b>back</b> () noexcept <b><br>
const_iterator begin</b> () const noexcept <b><br>
iterator begin</b> () noexcept <b><br>
const_iterator cbegin</b> () const noexcept <b><br>
const_iterator cend</b> () const noexcept <br>
void <b>clear</b> () noexcept <b><br>
const_reverse_iterator crbegin</b> () const noexcept <b><br>
const_reverse_iterator crend</b> () const noexcept <br>
template&lt;typename... _Args&gt; <b>iterator emplace</b>
(<b>const_iterator</b> __position, _Args &amp;&amp;...
__args) <br>
Constructs object in list before specified iterator. <br>
template&lt;typename... _Args&gt; reference
<b>emplace_back</b> (_Args &amp;&amp;... __args) <br>
template&lt;typename... _Args&gt; reference
<b>emplace_front</b> (_Args &amp;&amp;... __args) <br>
bool <b>empty</b> () const noexcept <b><br>
const_iterator end</b> () const noexcept <b><br>
iterator end</b> () noexcept <b><br>
iterator erase</b> (<b>const_iterator</b> __first,
<b>const_iterator</b> __last) noexcept <br>
Remove a range of elements. <b><br>
iterator erase</b> (<b>const_iterator</b> __position)
noexcept <br>
Remove element at given position. <br>
const_reference <b>front</b> () const noexcept <br>
reference <b>front</b> () noexcept <br>
allocator_type <b>get_allocator</b> () const noexcept <br>
Get a copy of the memory allocation object. <b><br>
iterator insert</b> (<b>const_iterator</b> __p,
<b>initializer_list</b>&lt; value_type &gt; __l) <br>
Inserts the contents of an initializer_list into list before
specified const_iterator. <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>iterator
insert</b> (<b>const_iterator</b> __position, _InputIterator
__first, _InputIterator __last) <br>
Inserts a range into the list. <b><br>
iterator insert</b> (<b>const_iterator</b> __position, const
value_type &amp;__x) <br>
Inserts given value into list before specified iterator.
<b><br>
iterator insert</b> (<b>const_iterator</b> __position,
size_type __n, const value_type &amp;__x) <br>
Inserts a number of copies of given data into the list.
<b><br>
iterator insert</b> (<b>const_iterator</b> __position,
value_type &amp;&amp;__x) <br>
Inserts given rvalue into list before specified iterator.
<br>
size_type <b>max_size</b> () const noexcept <br>
void <b>merge</b> (<b>list</b> &amp;&amp;__x) <br>
Merge sorted lists. <br>
template&lt;typename _StrictWeakOrdering &gt; void
<b>merge</b> (<b>list</b> &amp;&amp;__x, _StrictWeakOrdering
__comp) <br>
Merge sorted lists according to comparison function. <br>
void <b>merge</b> (<b>list</b> &amp;__x) <br>
template&lt;typename _StrictWeakOrdering &gt; void
<b>merge</b> (<b>list</b> &amp;__x, _StrictWeakOrdering
__comp) <b><br>
list</b> &amp; <b>operator=</b> (const <b>list</b> &amp;__x)
<br>
List assignment operator. <b><br>
list</b> &amp; <b>operator=</b> (<b>initializer_list</b>&lt;
value_type &gt; __l) <br>
List initializer list assignment operator. <b><br>
list</b> &amp; <b>operator=</b> (<b>list</b> &amp;&amp;__x)
noexcept(_Node_alloc_traits::_S_nothrow_move()) <br>
List move assignment operator. <br>
void <b>pop_back</b> () noexcept <br>
Removes last element. <br>
void <b>pop_front</b> () noexcept <br>
Removes first element. <br>
void <b>push_back</b> (const value_type &amp;__x) <br>
Add data to the end of the list. <br>
void <b>push_back</b> (value_type &amp;&amp;__x) <br>
void <b>push_front</b> (const value_type &amp;__x) <br>
Add data to the front of the list. <br>
void <b>push_front</b> (value_type &amp;&amp;__x) <b><br>
const_reverse_iterator rbegin</b> () const noexcept <b><br>
reverse_iterator rbegin</b> () noexcept <br>
__remove_return_type <b>remove</b> (const _Tp &amp;__value)
<br>
Remove all elements equal to value. <br>
template&lt;typename _Predicate &gt; __remove_return_type
<b>remove_if</b> (_Predicate) <br>
Remove all elements satisfying a predicate. <b><br>
const_reverse_iterator rend</b> () const noexcept <b><br>
reverse_iterator rend</b> () noexcept <br>
void <b>resize</b> (size_type __new_size) <br>
Resizes the list to the specified number of elements. <br>
void <b>resize</b> (size_type __new_size, const value_type
&amp;__x) <br>
Resizes the list to the specified number of elements. <br>
void <b>reverse</b> () noexcept <br>
Reverse the elements in list. <br>
size_type <b>size</b> () const noexcept <br>
void <b>sort</b> () <br>
Sort the elements. <br>
template&lt;typename _StrictWeakOrdering &gt; void
<b>sort</b> (_StrictWeakOrdering) <br>
Sort the elements according to comparison function. <br>
void <b>splice</b> (<b>const_iterator</b> __position,
<b>list</b> &amp;&amp;__x) noexcept <br>
Insert contents of another list. <br>
void <b>splice</b> (<b>const_iterator</b> __position,
<b>list</b> &amp;&amp;__x, <b>const_iterator</b> __first,
<b>const_iterator</b> __last) noexcept <br>
Insert range from another list. <br>
void <b>splice</b> (<b>const_iterator</b> __position,
<b>list</b> &amp;&amp;__x, <b>const_iterator</b> __i)
noexcept <br>
Insert element from another list. <br>
void <b>splice</b> (<b>const_iterator</b> __position,
<b>list</b> &amp;__x) noexcept <br>
void <b>splice</b> (<b>const_iterator</b> __position,
<b>list</b> &amp;__x, <b>const_iterator</b> __first,
<b>const_iterator</b> __last) noexcept <br>
Insert range from another list. <br>
void <b>splice</b> (<b>const_iterator</b> __position,
<b>list</b> &amp;__x, <b>const_iterator</b> __i) noexcept
<br>
Insert element from another list. <br>
void <b>swap</b> (<b>list</b> &amp;__x) noexcept <br>
Swaps data with another list. <br>
__remove_return_type <b>unique</b> () <br>
Remove consecutive duplicate elements. <br>
template&lt;typename _BinaryPredicate &gt;
__remove_return_type <b>unique</b> (_BinaryPredicate) <br>
Remove consecutive elements satisfying a predicate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Types</b></p>

<p style="margin-left:17%;">typedef <b>_List_node</b>&lt;
_Tp &gt; <b>_Node</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;">template&lt;typename
_InputIterator &gt; void <b>_M_assign_dispatch</b>
(_InputIterator __first, _InputIterator __last,
__false_type) <br>
template&lt;typename _Integer &gt; void
<b>_M_assign_dispatch</b> (_Integer __n, _Integer __val,
__true_type) <br>
void <b>_M_check_equal_allocators</b> (const <b>list</b>
&amp;__x) noexcept <br>
void <b>_M_clear</b> () noexcept <br>
template&lt;typename... _Args&gt; <b>_Node</b> *
<b>_M_create_node</b> (_Args &amp;&amp;... __args) <br>
void <b>_M_dec_size</b> (size_t) <br>
void <b>_M_default_append</b> (size_type __n) <br>
void <b>_M_default_initialize</b> (size_type __n) <br>
size_t <b>_M_distance</b> (const void *, const void *) const
<br>
void <b>_M_erase</b> (<b>iterator</b> __position) noexcept
<br>
void <b>_M_fill_assign</b> (size_type __n, const value_type
&amp;__val) <br>
void <b>_M_fill_initialize</b> (size_type __n, const
value_type &amp;__x) <br>
_Node_alloc_traits::pointer <b>_M_get_node</b> () <br>
const _Node_alloc_type &amp; <b>_M_get_Node_allocator</b> ()
const noexcept <br>
_Node_alloc_type &amp; <b>_M_get_Node_allocator</b> ()
noexcept <br>
size_t <b>_M_get_size</b> () const <br>
void <b>_M_inc_size</b> (size_t) <br>
void <b>_M_init</b> () noexcept <br>
template&lt;typename _InputIterator &gt; void
<b>_M_initialize_dispatch</b> (_InputIterator __first,
_InputIterator __last, __false_type) <br>
template&lt;typename _Integer &gt; void
<b>_M_initialize_dispatch</b> (_Integer __n, _Integer __x,
__true_type) <br>
template&lt;typename... _Args&gt; void <b>_M_insert</b>
(<b>iterator</b> __position, _Args &amp;&amp;... __args)
<br>
void <b>_M_move_assign</b> (<b>list</b> &amp;&amp;__x,
<b>false_type</b>) <br>
void <b>_M_move_assign</b> (<b>list</b> &amp;&amp;__x,
<b>true_type</b>) noexcept <br>
void <b>_M_move_nodes</b> (<b>_List_base</b> &amp;&amp;__x)
<br>
size_t <b>_M_node_count</b> () const <br>
void <b>_M_put_node</b> (typename
_Node_alloc_traits::pointer __p) noexcept <b><br>
const_iterator _M_resize_pos</b> (size_type &amp;__new_size)
const <br>
void <b>_M_set_size</b> (size_t) <br>
void <b>_M_transfer</b> (<b>iterator</b> __position,
<b>iterator</b> __first, <b>iterator</b> __last)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Protected Member Functions</b></p>

<p style="margin-left:17%;">static size_t
<b>_S_distance</b> (const <b>__detail::_List_node_base</b>
*__first, const <b>__detail::_List_node_base</b> *__last)
<br>
static size_t <b>_S_distance</b> (<b>const_iterator</b>,
<b>const_iterator</b>)</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Attributes</b></p>

<p style="margin-left:17%;">_List_impl <b>_M_impl</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;</b>
<br>
class std::list&lt; _Tp, _Alloc &gt;&quot;A standard
container with linear time access to elements, and fixed
time insertion/deletion at any point in the sequence.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_Tp</i> Type of element.
<i><br>
_Alloc</i> Allocator type, defaults to
allocator&lt;_Tp&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Meets the
requirements of a <tt>container</tt>, a <tt>reversible
container</tt>, and a <tt>sequence</tt>, including the
<tt>optional sequence requirements</tt> with the exception
of <tt>at</tt> and <tt>operator</tt>[].</p>

<p style="margin-left:11%; margin-top: 1em">This is a
<i>doubly linked</i> list. Traversal up and down the list
requires linear time, but adding and removing elements (or
<i>nodes</i>) is done in constant time, regardless of where
the change takes place. Unlike std::vector and std::deque,
random-access iterators are not provided, so subscripting (
[] ) access is not allowed. For algorithms which only need
sequential access, this lack makes no difference.</p>

<p style="margin-left:11%; margin-top: 1em">Also unlike the
other standard containers, std::list provides specialized
algorithms unique to linked lists, such as splicing,
sorting, and in-place reversal.</p>

<p style="margin-left:11%; margin-top: 1em">A couple points
on memory allocation for list&lt;Tp&gt;:</p>

<p style="margin-left:11%; margin-top: 1em">First, we never
actually allocate a Tp, we allocate
List_node&lt;Tp&gt;&rsquo;s and trust [20.1.5]/4 to DTRT.
This is to ensure that after elements from
list&lt;X,Alloc1&gt; are spliced into list&lt;X,Alloc2&gt;,
destroying the memory of the second list is a valid
operation, i.e., Alloc1 giveth and Alloc2 taketh away.</p>

<p style="margin-left:11%; margin-top: 1em">Second, a list
conceptually represented as</p>

<p style="margin-left:11%; margin-top: 1em">A
&lt;&minus;&minus;&minus;&gt; B
&lt;&minus;&minus;&minus;&gt; C
&lt;&minus;&minus;&minus;&gt; D</p>

<p style="margin-left:11%; margin-top: 1em">is actually
circular; a link exists between A and D. The list class
holds (as its only data member) a private list::iterator
pointing to <i>D</i>, not to <i>A!</i> To get to the head of
the list, we start at the tail and move forward by one. When
this member iterator&rsquo;s next/previous pointers refer to
itself, the list is empty.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::list ()</b>
<tt>[default]</tt> <br>
Creates a list with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::list (const allocator_type
&amp; __a)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Creates a list with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> An allocator
object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::list (size_type __n, const
allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
Creates a list with default constructed elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The number of
elements to initially create. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">This
constructor fills the list with <i>__n</i> default
constructed elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::list (size_type __n, const
value_type &amp; __value, const allocator_type &amp; __a
=</b> <tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt>
<br>
Creates a list with copies of an exemplar element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The number of
elements to initially create. <i><br>
__value</i> An element to copy. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">This
constructor fills the list with <i>__n</i> copies of
<i>__value</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::list (const list&lt; _Tp,
_Alloc &gt; &amp; __x)</b> <tt>[inline]</tt> <br>
List copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A list of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">The
newly-created list uses a copy of the allocation object used
by <i>__x</i> (unless the allocator traits dictate a
different object).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::list&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::list (list&lt; _Tp, _Alloc
&gt; &amp;&amp;)</b> <tt>[default]</tt> <br>
List move constructor. The newly-created list contains the
exact contents of the moved instance. The contents of the
moved instance are a valid, but unspecified list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::list (initializer_list&lt;
value_type &gt; __l, const allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds a list from an initializer_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list
of value_type. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create a list
consisting of copies of the elements in the initializer_list
<i>__l</i>. This is linear in __l.size().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::list (_InputIterator
__first, _InputIterator __last, const allocator_type &amp;
__a =</b> <tt>allocator_type()</tt><b>)</b>
<tt>[inline]</tt> <br>
Builds a list from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create a list
consisting of copies of the elements from
[<i>__first</i>,<i>__last</i>). This is linear in N (where N
is distance(<i>__first</i>,<i>__last</i>)).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::list&lt; _Tp, _Alloc &gt;::~list ()</b>
<tt>[default]</tt> <br>
No explicit dtor needed as the _Base dtor takes care of
things. The _Base dtor only erases the elements, and note
that if the elements themselves are pointers, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename... _Args&gt; _Node * std::list&lt; _Tp,
_Alloc &gt;::_M_create_node (_Args &amp;&amp;... __args)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <b><br>
Parameters</b></p>

<p style="margin-left:17%;"><i>__args</i> An instance of
user data.</p>

<p style="margin-left:11%; margin-top: 1em">Allocates space
for a new node and constructs a copy of <i>__args</i> in
it.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::assign (_InputIterator
__first, _InputIterator __last)</b> <tt>[inline]</tt> <br>
Assigns a range to a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a list with copies of the elements in the range
[<i>__first</i>,<i>__last</i>).</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the list and that the
resulting list&rsquo;s size is the same as the number of
elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::assign (initializer_list&lt;
value_type &gt; __l)</b> <tt>[inline]</tt> <br>
Assigns an initializer_list to a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list
of value_type.</p>

<p style="margin-left:11%; margin-top: 1em">Replace the
contents of the list with copies of the elements in the
initializer_list <i>__l</i>. This is linear in
__l.size().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::assign (size_type __n, const
value_type &amp; __val)</b> <tt>[inline]</tt> <br>
Assigns a given value to a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> Number of elements
to be assigned. <i><br>
__val</i> Value to be assigned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a list with <i>__n</i> copies of the given value. Note
that the assignment completely changes the list and that the
resulting list&rsquo;s size is the same as the number of
elements assigned.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::list&lt; _Tp, _Alloc &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::list&lt; _Tp, _Alloc &gt;::back ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reference to the data at the
last element of the list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::list&lt; _Tp, _Alloc &gt;::back ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reference to the data at the last
element of the list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::list&lt; _Tp, _Alloc &gt;::begin ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the list. Iteration is done in ordinary
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::list&lt; _Tp, _Alloc &gt;::begin ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points to the first
element in the list. Iteration is done in ordinary element
order.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::list&lt; _Tp, _Alloc &gt;::list()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::crend()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::front()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::insert()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::merge()</b>,
<b>std::operator&lt;()</b>, <b>std::list&lt; _Tp, _Alloc
&gt;::operator=()</b>, <b>std::operator==()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::pop_front()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::push_front()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::remove()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::remove_if()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::rend()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::splice()</b>, and
<b>std::list&lt; _Tp, _Alloc &gt;::unique()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::list&lt; _Tp, _Alloc &gt;::cbegin ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the list. Iteration is done in ordinary
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::list&lt; _Tp, _Alloc &gt;::cend ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the list. Iteration is done in ordinary
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::clear ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Erases all the elements. Note that this function only erases
the elements, and that if the elements themselves are
pointers, the pointed-to memory is not touched in any way.
Managing the pointer is the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::list&lt; _Tp, _Alloc
&gt;::crbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last element in the list. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::list&lt; _Tp, _Alloc &gt;::crend
() const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Returns a read-only (constant) reverse iterator that points
to one before the first element in the list. Iteration is
done in reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename... _Args&gt;
list&lt; _Tp, _Alloc &gt;::iterator list::emplace
(const_iterator __position, _Args &amp;&amp;... __args)</b>
<br>
Constructs object in list before specified iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the list. <i><br>
__args</i> Arguments.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert an object of type T constructed with
T(std::forward&lt;Args&gt;(args)...) before the specified
location. Due to the nature of a list this operation can be
done in constant time, and does not invalidate iterators and
references.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::list&lt; _Tp, _Alloc &gt;::insert()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; bool
std::list&lt; _Tp, _Alloc &gt;::empty () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns true if the list is empty. (Thus begin() would equal
end().)</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::list&lt; _Tp, _Alloc &gt;::insert()</b>, and
<b>std::list&lt; _Tp, _Alloc &gt;::splice()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::list&lt; _Tp, _Alloc &gt;::end ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the list. Iteration is done in ordinary
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::list&lt; _Tp, _Alloc &gt;::end ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points one past the last
element in the list. Iteration is done in ordinary element
order.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::list&lt; _Tp, _Alloc &gt;::list()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::back()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::crbegin()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::merge()</b>,
<b>std::operator&lt;()</b>, <b>std::list&lt; _Tp, _Alloc
&gt;::operator=()</b>, <b>std::operator==()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::push_back()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::rbegin()</b>, and
<b>std::list&lt; _Tp, _Alloc &gt;::splice()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::list&lt; _Tp, _Alloc &gt;::erase
(const_iterator __first, const_iterator __last)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Remove a range of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the first element to be erased. <i><br>
__last</i> Iterator pointing to one past the last element to
be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element pointed to by <i>last</i> prior to erasing (or
end()).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will erase the elements in the range [first,last) and
shorten the list accordingly.</p>

<p style="margin-left:11%; margin-top: 1em">This operation
is linear time in the size of the range and only invalidates
iterators/references to the element being removed. The user
is also cautioned that this function only erases the
elements, and that if the elements themselves are pointers,
the pointed-to memory is not touched in any way. Managing
the pointer is the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::erase()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; list&lt; _Tp, _Alloc
&gt;::iterator list::erase (const_iterator __position)</b>
<tt>[noexcept]</tt> <br>
Remove element at given position.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> Iterator
pointing to element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
next element (or end()).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will erase the element at the given position and thus
shorten the list by one.</p>

<p style="margin-left:11%; margin-top: 1em">Due to the
nature of a list this operation can be done in constant
time, and only invalidates iterators/references to the
element being removed. The user is also cautioned that this
function only erases the element, and that if the element is
itself a pointer, the pointed-to memory is not touched in
any way. Managing the pointer is the user&rsquo;s
responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::list&lt; _Tp, _Alloc &gt;::erase()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::list&lt; _Tp, _Alloc &gt;::front ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reference to the data at the
first element of the list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::list&lt; _Tp, _Alloc &gt;::front ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reference to the data at the first
element of the list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
allocator_type std::list&lt; _Tp, _Alloc &gt;::get_allocator
() const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Get a copy of the memory allocation object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::list&lt; _Tp, _Alloc &gt;::insert
(const_iterator __p, initializer_list&lt; value_type &gt;
__l)</b> <tt>[inline]</tt> <br>
Inserts the contents of an initializer_list into list before
specified const_iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A const_iterator
into the list. <i><br>
__l</i> An initializer_list of value_type.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
first element inserted (or __position).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert copies of the data in the initializer_list
<i>l</i> into the list before the location specified by
<i>p</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This operation
is linear in the number of elements inserted and does not
invalidate iterators and references.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::insert()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename
_InputIterator , typename &gt; list&lt; _Tp, _Alloc
&gt;::iterator list::insert (const_iterator __position,
_InputIterator __first, _InputIterator __last)</b> <br>
Inserts a range into the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the list. <i><br>
__first</i> An input iterator. <i><br>
__last</i> An input iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
first element inserted (or __position).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert copies of the data in the range
[<i>first</i>,<i>last</i>) into the list before the location
specified by <i>position</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This operation
is linear in the number of elements inserted and does not
invalidate iterators and references.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::list&lt; _Tp, _Alloc &gt;::empty()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; list&lt; _Tp, _Alloc
&gt;::iterator list::insert (const_iterator __position,
const value_type &amp; __x)</b> <br>
Inserts given value into list before specified iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the list. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a copy of the given value before the specified
location. Due to the nature of a list this operation can be
done in constant time, and does not invalidate iterators and
references.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::list&lt; _Tp, _Alloc &gt;::insert()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; list&lt; _Tp, _Alloc
&gt;::iterator list::insert (const_iterator __position,
size_type __n, const value_type &amp; __x)</b> <br>
Inserts a number of copies of given data into the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the list. <i><br>
__n</i> Number of elements to be inserted. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
first element inserted (or __position).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a specified number of copies of the given data
before the location specified by <i>position</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This operation
is linear in the number of elements inserted and does not
invalidate iterators and references.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::list&lt; _Tp, _Alloc &gt;::insert
(const_iterator __position, value_type &amp;&amp; __x)</b>
<tt>[inline]</tt> <br>
Inserts given rvalue into list before specified
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the list. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a copy of the given rvalue before the specified
location. Due to the nature of a list this operation can be
done in constant time, and does not invalidate iterators and
references.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::emplace()</b>, and
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
size_type std::list&lt; _Tp, _Alloc &gt;::max_size ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the size() of the largest possible list.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_cxx::__alloc_traits&lt; _Alloc, typename
&gt;::max_size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void list::merge (list&lt; _Tp,
_Alloc &gt; &amp;&amp; __x)</b> <br>
Merge sorted lists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Sorted list to
merge.</p>

<p style="margin-left:11%; margin-top: 1em">Assumes that
both <i>__x</i> and this list are sorted according to
operator&lt;(). Merges elements of <i>__x</i> into this list
in sorted order, leaving <i>__x</i> empty when complete.
Elements in this list precede elements in <i>__x</i> that
are equal.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>, <b>std::list&lt; _Tp, _Alloc
&gt;::begin()</b>, <b>std::begin()</b>, <b>std::list&lt;
_Tp, _Alloc &gt;::end()</b>, and <b>std::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename
_StrictWeakOrdering &gt; void list::merge (list&lt; _Tp,
_Alloc &gt; &amp;&amp; __x, _StrictWeakOrdering __comp)</b>
<br>
Merge sorted lists according to comparison function.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_StrictWeakOrdering</i>
Comparison function defining sort order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Sorted list to
merge. <i><br>
__comp</i> Comparison functor.</p>

<p style="margin-left:11%; margin-top: 1em">Assumes that
both <i>__x</i> and this list are sorted according to
StrictWeakOrdering. Merges elements of <i>__x</i> into this
list in sorted order, leaving <i>__x</i> empty when
complete. Elements in this list precede elements in
<i>__x</i> that are equivalent according to
StrictWeakOrdering().</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>, <b>std::list&lt; _Tp, _Alloc
&gt;::begin()</b>, <b>std::begin()</b>, <b>std::list&lt;
_Tp, _Alloc &gt;::end()</b>, and <b>std::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; list&lt; _Tp, _Alloc &gt; &amp;
list::operator= (const list&lt; _Tp, _Alloc &gt; &amp;
__x)</b> <br>
List assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A list of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">All the
elements of <i>__x</i> are copied.</p>

<p style="margin-left:11%; margin-top: 1em">Whether the
allocator is copied depends on the allocator traits.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>, <b>std::list&lt; _Tp, _Alloc
&gt;::begin()</b>, and <b>std::list&lt; _Tp, _Alloc
&gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; list
&amp; std::list&lt; _Tp, _Alloc &gt;::operator=
(initializer_list&lt; value_type &gt; __l)</b>
<tt>[inline]</tt> <br>
List initializer list assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list
of value_type.</p>

<p style="margin-left:11%; margin-top: 1em">Replace the
contents of the list with copies of the elements in the
initializer_list <i>__l</i>. This is linear in l.size().</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::assign()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; list
&amp; std::list&lt; _Tp, _Alloc &gt;::operator= (list&lt;
_Tp, _Alloc &gt; &amp;&amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
List move assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A list of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">The contents of
<i>__x</i> are moved into this list (without copying).</p>

<p style="margin-left:11%; margin-top: 1em">Afterwards
<i>__x</i> is a valid, but unspecified list</p>

<p style="margin-left:11%; margin-top: 1em">Whether the
allocator is moved depends on the allocator traits.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::pop_back ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Removes last element. This is a typical stack operation. It
shrinks the list by one. Due to the nature of a list this
operation can be done in constant time, and only invalidates
iterators/references to the element being removed.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
data is returned, and if the last element&rsquo;s data is
needed, it should be retrieved before pop_back() is
called.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::pop_front ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Removes first element. This is a typical stack operation. It
shrinks the list by one. Due to the nature of a list this
operation can be done in constant time, and only invalidates
iterators/references to the element being removed.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
data is returned, and if the first element&rsquo;s data is
needed, it should be retrieved before pop_front() is
called.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::push_back (const value_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Add data to the end of the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Data to be
added.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical stack operation. The function creates an element at
the end of the list and assigns the given data to it. Due to
the nature of a list this operation can be done in constant
time, and does not invalidate iterators and references.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::push_front (const value_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Add data to the front of the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Data to be
added.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical stack operation. The function creates an element at
the front of the list and assigns the given data to it. Due
to the nature of a list this operation can be done in
constant time, and does not invalidate iterators and
references.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::list&lt; _Tp, _Alloc
&gt;::rbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last element in the list. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reverse_iterator std::list&lt; _Tp, _Alloc &gt;::rbegin
()</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to the
last element in the list. Iteration is done in reverse
element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; list&lt; _Tp, _Alloc
&gt;::__remove_return_type list::remove (const _Tp &amp;
__value)</b> <br>
Remove all elements equal to value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__value</i> The value to
remove.</p>

<p style="margin-left:11%; margin-top: 1em">Removes every
element in the list equal to <i>value</i>. Remaining
elements stay in list order. Note that this function only
erases the elements, and that if the elements themselves are
pointers, the pointed-to memory is not touched in any way.
Managing the pointer is the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>,
<b>std::begin()</b>, <b>std::end()</b>, <b>std::list&lt;
_Tp, _Alloc &gt;::size()</b>, and <b>std::list&lt; _Tp,
_Alloc &gt;::splice()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename _Predicate
&gt; list&lt; _Tp, _Alloc &gt;::__remove_return_type
list::remove_if (_Predicate __pred)</b> <br>
Remove all elements satisfying a predicate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_Predicate</i> Unary
predicate function or object.</p>

<p style="margin-left:11%; margin-top: 1em">Removes every
element in the list for which the predicate returns true.
Remaining elements stay in list order. Note that this
function only erases the elements, and that if the elements
themselves are pointers, the pointed-to memory is not
touched in any way. Managing the pointer is the user&rsquo;s
responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>,
<b>std::begin()</b>, <b>std::end()</b>, <b>std::list&lt;
_Tp, _Alloc &gt;::size()</b>, and <b>std::list&lt; _Tp,
_Alloc &gt;::splice()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::list&lt; _Tp, _Alloc &gt;::rend
() const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Returns a read-only (constant) reverse iterator that points
to one before the first element in the list. Iteration is
done in reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reverse_iterator std::list&lt; _Tp, _Alloc &gt;::rend ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to one
before the first element in the list. Iteration is done in
reverse element order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void list::resize (size_type
__new_size)</b> <br>
Resizes the list to the specified number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__new_size</i> Number of
elements the list should contain.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will resize the list to the specified number of elements. If
the number is smaller than the list&rsquo;s current size the
list is truncated, otherwise default constructed elements
are appended.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void list::resize (size_type
__new_size, const value_type &amp; __x)</b> <br>
Resizes the list to the specified number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__new_size</i> Number of
elements the list should contain. <i><br>
__x</i> Data with which new elements should be
populated.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will resize the list to the specified number of elements. If
the number is smaller than the list&rsquo;s current size the
list is truncated, otherwise the list is extended and new
elements are populated with given data.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::reverse ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Reverse the elements in list. Reverse the order of elements
in the list in linear time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
size_type std::list&lt; _Tp, _Alloc &gt;::size () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of elements in the list.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::operator==()</b>, <b>std::list&lt; _Tp, _Alloc
&gt;::remove()</b>, <b>std::list&lt; _Tp, _Alloc
&gt;::remove_if()</b>, and <b>std::list&lt; _Tp, _Alloc
&gt;::unique()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void list::sort</b> <br>
Sort the elements. Sorts the elements of this list in NlogN
time. Equivalent elements remain in list order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::begin()</b>, <b>std::empty()</b>, and
<b>std::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename
_StrictWeakOrdering &gt; void list::sort
(_StrictWeakOrdering __comp)</b> <br>
Sort the elements according to comparison function. Sorts
the elements of this list in NlogN time. Equivalent elements
remain in list order.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::begin()</b>, <b>std::empty()</b>, and
<b>std::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::splice (const_iterator
__position, list&lt; _Tp, _Alloc &gt; &amp;&amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Insert contents of another list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> Iterator
referencing the element to insert before. <i><br>
__x</i> Source list.</p>

<p style="margin-left:11%; margin-top: 1em">The elements of
<i>__x</i> are inserted in constant time in front of the
element referenced by <i>__position</i>. <i>__x</i> becomes
an empty list.</p>

<p style="margin-left:11%; margin-top: 1em">Requires this
!= <i>__x</i>.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::empty()</b>, and
<b>std::list&lt; _Tp, _Alloc &gt;::end()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::list&lt; _Tp, _Alloc &gt;::remove()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::remove_if()</b>,
<b>std::list&lt; _Tp, _Alloc &gt;::splice()</b>, and
<b>std::list&lt; _Tp, _Alloc &gt;::unique()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::splice (const_iterator
__position, list&lt; _Tp, _Alloc &gt; &amp;&amp; __x,
const_iterator __first, const_iterator __last)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Insert range from another list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i>
Const_iterator referencing the element to insert before.
<i><br>
__x</i> Source list. <i><br>
__first</i> Const_iterator referencing the start of range in
x. <i><br>
__last</i> Const_iterator referencing the end of range in
x.</p>

<p style="margin-left:11%; margin-top: 1em">Removes
elements in the range [__first,__last) and inserts them
before <i>__position</i> in constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Undefined if
<i>__position</i> is in [__first,__last).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::splice (const_iterator
__position, list&lt; _Tp, _Alloc &gt; &amp;&amp; __x,
const_iterator __i)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Insert element from another list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i>
Const_iterator referencing the element to insert before.
<i><br>
__x</i> Source list. <i><br>
__i</i> Const_iterator referencing the element to move.</p>

<p style="margin-left:11%; margin-top: 1em">Removes the
element in list <i>__x</i> referenced by <i>__i</i> and
inserts it into the current list before
<i>__position</i>.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::splice (const_iterator
__position, list&lt; _Tp, _Alloc &gt; &amp; __x,
const_iterator __first, const_iterator __last)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Insert range from another list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i>
Const_iterator referencing the element to insert before.
<i><br>
__x</i> Source list. <i><br>
__first</i> Const_iterator referencing the start of range in
x. <i><br>
__last</i> Const_iterator referencing the end of range in
x.</p>

<p style="margin-left:11%; margin-top: 1em">Removes
elements in the range [__first,__last) and inserts them
before <i>__position</i> in constant time.</p>

<p style="margin-left:11%; margin-top: 1em">Undefined if
<i>__position</i> is in [__first,__last).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>, and <b>std::list&lt; _Tp, _Alloc
&gt;::splice()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::splice (const_iterator
__position, list&lt; _Tp, _Alloc &gt; &amp; __x,
const_iterator __i)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Insert element from another list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i>
Const_iterator referencing the element to insert before.
<i><br>
__x</i> Source list. <i><br>
__i</i> Const_iterator referencing the element to move.</p>

<p style="margin-left:11%; margin-top: 1em">Removes the
element in list <i>__x</i> referenced by <i>__i</i> and
inserts it into the current list before
<i>__position</i>.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>, and <b>std::list&lt; _Tp, _Alloc
&gt;::splice()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::list&lt; _Tp, _Alloc &gt;::swap (list&lt; _Tp, _Alloc
&gt; &amp; __x)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Swaps data with another list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A list of the same
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">This exchanges
the elements between two lists in constant time. Note that
the global std::swap() function is specialized such that
std::swap(l1,l2) will feed to this function.</p>

<p style="margin-left:11%; margin-top: 1em">Whether the
allocators are swapped depends on the allocator traits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; list&lt; _Tp, _Alloc
&gt;::__remove_return_type list::unique</b> <br>
Remove consecutive duplicate elements. For each consecutive
set of elements with the same value, remove all but the
first one. Remaining elements stay in list order. Note that
this function only erases the elements, and that if the
elements themselves are pointers, the pointed-to memory is
not touched in any way. Managing the pointer is the
user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>,
<b>std::begin()</b>, <b>std::end()</b>, <b>std::list&lt;
_Tp, _Alloc &gt;::size()</b>, and <b>std::list&lt; _Tp,
_Alloc &gt;::splice()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename
_BinaryPredicate &gt; list&lt; _Tp, _Alloc
&gt;::__remove_return_type list::unique (_BinaryPredicate
__binary_pred)</b> <br>
Remove consecutive elements satisfying a predicate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_BinaryPredicate</i> Binary
predicate function or object.</p>

<p style="margin-left:11%; margin-top: 1em">For each
consecutive set of elements [first,last) that satisfy
predicate(first,i) where i is an iterator in [first,last),
remove all but the first one. Remaining elements stay in
list order. Note that this function only erases the
elements, and that if the elements themselves are pointers,
the pointed-to memory is not touched in any way. Managing
the pointer is the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::list&lt; _Tp, _Alloc &gt;::begin()</b>,
<b>std::begin()</b>, <b>std::end()</b>, <b>std::list&lt;
_Tp, _Alloc &gt;::size()</b>, and <b>std::list&lt; _Tp,
_Alloc &gt;::splice()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
