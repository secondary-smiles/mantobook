<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:35 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_Recv</title>

</head>
<body>
<h1>MPI_Recv</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_Recv</b>
&minus; Performs a standard-mode blocking receive.</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Recv(void *<i>buf</i>, int <i>count</i>,
MPI_Datatype <i>datatype</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>int <i>source</i>, int <i>tag</i>, MPI_Comm <i>comm</i>,
MPI_Status <i>*status</i>)</p></td></tr>
</table>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_RECV(<i>BUF, COUNT, DATATYPE, SOURCE, TAG, COMM, STATUS,
IERROR</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>&lt;type&gt;</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>BUF</i>(*)</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>COUNT, DATATYPE, SOURCE, TAG, COMM</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>STATUS(MPI_STATUS_SIZE), IERROR</i></p></td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_Recv(<i>buf</i>, <i>count</i>, <i>datatype</i>,
<i>source</i>, <i>tag</i>, <i>comm</i>, <i>status</i>,
<i>ierror</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(*), DIMENSION(..) :: <i>buf</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, INTENT(IN) :: <i>count</i>, <i>source</i>,
<i>tag</i></p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Datatype), INTENT(IN) :: <i>datatype</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Comm), INTENT(IN) :: <i>comm</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Status) :: <i>status</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
void Comm::Recv(void* <i>buf</i>, int <i>count</i>, const
Datatype&amp; <i>datatype</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>int <i>source</i>, int <i>tag</i>, Status&amp;
<i>status</i>) const</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">void
Comm::Recv(void* <i>buf</i>, int <i>count</i>, const
Datatype&amp; <i>datatype</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>int <i>source</i>, int <i>tag</i>) const</p></td></tr>
</table>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">count</p></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">Maximum number of elements to
receive (integer).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>datatype</p></td>
<td width="3%"></td>
<td width="74%">


<p>Datatype of each receive buffer entry (handle).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>source</p></td>
<td width="3%"></td>
<td width="74%">


<p>Rank of source (integer).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>tag</p></td>
<td width="3%"></td>
<td width="74%">


<p>Message tag (integer).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>comm</p></td>
<td width="3%"></td>
<td width="74%">


<p>Communicator (handle).</p></td></tr>
</table>

<h2>OUTPUT PARAMETERS
<a name="OUTPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em">buf</p></td>
<td width="6%"></td>
<td width="66%">


<p style="margin-top: 1em">Initial address of receive
buffer (choice).</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>status</p></td>
<td width="6%"></td>
<td width="66%">


<p>Status object (status).</p></td>
<td width="8%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>IERROR</p></td>
<td width="6%"></td>
<td width="66%">


<p>Fortran only: Error status (integer).</p></td>
<td width="8%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This basic
receive operation, MPI_Recv, is blocking: it returns only
after the receive buffer contains the newly received
message. A receive can complete before the matching send has
completed (of course, it can complete only after the
matching send has started).</p>

<p style="margin-left:11%; margin-top: 1em">The blocking
semantics of this call are described in Section 3.4 of the
MPI-1 Standard, &quot;Communication Modes.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">The receive
buffer contains a number (defined by the value of
<i>count</i>) of consecutive elements. The first element in
the set of elements is located at <i>address_buf</i>. The
type of each of these elements is specified by
<i>datatype</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The length of
the received message must be less than or equal to the
length of the receive buffer. An MPI_ERR_TRUNCATE is
returned upon the overflow condition.</p>

<p style="margin-left:11%; margin-top: 1em">If a message
that is shorter than the length of the receive buffer
arrives, then only those locations corresponding to the
(shorter) received message are modified.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>count</i> argument indicates the maximum number of
entries of type <i>datatype</i> that can be received in a
message. Once a message is received, use the MPI_Get_count
function to determine the actual number of entries within
that message.</p>

<p style="margin-left:11%; margin-top: 1em">To receive
messages of unknown length, use the MPI_Probe function. (For
more information about MPI_Probe and MPI_Cancel, see their
respective man pages; also, see Section 3.8 of the MPI-1
Standard, &quot;Probe and Cancel.&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">A message can
be received by a receive operation only if it is addressed
to the receiving process, and if its source, tag, and
communicator (comm) values match the source, tag, and comm
values specified by the receive operation. The receive
operation may specify a wildcard value for source and/or
tag, indicating that any source and/or tag are acceptable.
The wildcard value for source is source = MPI_ANY_SOURCE.
The wildcard value for tag is tag = MPI_ANY_TAG. There is no
wildcard value for comm. The scope of these wildcards is
limited to the proceses in the group of the specified
communicator.</p>

<p style="margin-left:11%; margin-top: 1em">The message tag
is specified by the tag argument of the receive
operation.</p>

<p style="margin-left:11%; margin-top: 1em">The argument
source, if different from MPI_ANY_SOURCE, is specified as a
rank within the process group associated with that same
communicator (remote process group, for intercommunicators).
Thus, the range of valid values for the source argument is
{0,...,n-1} {MPI_ANY_SOURCE}, where n is the number of
processes in this group.</p>

<p style="margin-left:11%; margin-top: 1em">Note the
asymmetry between send and receive operations: A receive
operation may accept messages from an arbitrary sender; on
the other hand, a send operation must specify a unique
receiver. This matches a &quot;push&quot; communication
mechanism, where data transfer is effected by the sender
(rather than a &quot;pull&quot; mechanism, where data
transfer is effected by the receiver).</p>

<p style="margin-left:11%; margin-top: 1em">Source =
destination is allowed, that is, a process can send a
message to itself. However, it is not recommended for a
process to send messages to itself using the blocking send
and receive operations described above, since this may lead
to deadlock. See Section 3.5 of the MPI-1 Standard,
&quot;Semantics of Point-to-Point Communication.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">If your
application does not need to examine the <i>status</i>
field, you can save resources by using the predefined
constant MPI_STATUS_IGNORE as a special value for the
<i>status</i> argument.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Irecv <br>
 MPI_Probe</p>
<hr>
</body>
</html>
