<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:47 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Encode</title>

</head>
<body>
<h1>Encode</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Encode &minus;
character encodings in Perl</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use Encode
qw(decode encode); <br>
$characters = decode('UTF&minus;8', $octets,
Encode::FB_CROAK); <br>
$octets = encode('UTF&minus;8', $characters,
Encode::FB_CROAK);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Table of
Contents</b> <br>
Encode consists of a collection of modules whose details are
too extensive to fit in one document. This one itself
explains the top-level APIs and general topics at a glance.
For other topics and more details, see the documentation for
these modules: <br>
Encode::Alias &minus; Alias definitions to encodings <br>
Encode::Encoding &minus; Encode Implementation Base Class
<br>
Encode::Supported &minus; List of Supported Encodings <br>
Encode::CN &minus; Simplified Chinese Encodings <br>
Encode::JP &minus; Japanese Encodings <br>
Encode::KR &minus; Korean Encodings <br>
Encode::TW &minus; Traditional Chinese Encodings</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
&quot;Encode&quot; module provides the interface between
Perl strings and the rest of the system. Perl strings are
sequences of <i>characters</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The repertoire
of characters that Perl can represent is a superset of those
defined by the Unicode Consortium. On most platforms the
ordinal values of a character as returned by
&quot;ord(<i>S</i>)&quot; is the <i>Unicode codepoint</i>
for that character. The exceptions are platforms where the
legacy encoding is some variant of <small>EBCDIC</small>
rather than a superset of <small>ASCII</small> ; see
perlebcdic.</p>

<p style="margin-left:11%; margin-top: 1em">During recent
history, data is moved around a computer in 8&minus;bit
chunks, often called &quot;bytes&quot; but also known as
&quot;octets&quot; in standards documents. Perl is widely
used to manipulate data of many types: not only strings of
characters representing human or computer languages, but
also &quot;binary&quot; data, being the machine&rsquo;s
representation of numbers, pixels in an image, or just about
anything.</p>

<p style="margin-left:11%; margin-top: 1em">When Perl is
processing &quot;binary data&quot;, the programmer wants
Perl to process &quot;sequences of bytes&quot;. This is not
a problem for Perl: because a byte has 256 possible values,
it easily fits in Perl&rsquo;s much larger &quot;logical
character&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This document
mostly explains the <i>how</i>. perlunitut and perlunifaq
explain the <i>why</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>TERMINOLOGY</small></b>
<i><br>
character</i></p>

<p style="margin-left:11%; margin-top: 1em">A character in
the range 0 .. 2**32&minus;1 (or more); what Perl&rsquo;s
strings are made of.</p>


<p style="margin-left:11%; margin-top: 1em"><i>byte</i></p>

<p style="margin-left:11%; margin-top: 1em">A character in
the range 0..255; a special case of a Perl character.</p>


<p style="margin-left:11%; margin-top: 1em"><i>octet</i></p>

<p style="margin-left:11%; margin-top: 1em">8 bits of data,
with ordinal values 0..255; term for bytes passed to or from
a non-Perl context, such as a disk file, standard I/O
stream, database, command-line argument, environment
variable, socket etc.</p>

<h2>THE PERL ENCODING API
<a name="THE PERL ENCODING API"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Basic
methods</b> <i><br>
encode</i></p>

<p style="margin-left:11%; margin-top: 1em">$octets =
encode(ENCODING, STRING[, CHECK])</p>

<p style="margin-left:11%; margin-top: 1em">Encodes the
scalar value <i><small>STRING</small></i> from Perl&rsquo;s
internal form into <i><small>ENCODING</small></i> and
returns a sequence of octets. <i><small>ENCODING</small></i>
can be either a canonical name or an alias. For encoding
names and aliases, see &quot;Defining Aliases&quot;. For
<small>CHECK,</small> see &quot;Handling Malformed
Data&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CAVEAT</small></b>
: the input scalar <i><small>STRING</small></i> might be
modified in-place depending on what is set in
<small>CHECK.</small> See &quot;
<small>LEAVE_SRC&quot;</small> if you want your inputs to be
left unchanged.</p>

<p style="margin-left:11%; margin-top: 1em">For example, to
convert a string from Perl&rsquo;s internal format into
<small>ISO&minus;8859&minus;1,</small> also known as
Latin1:</p>

<p style="margin-left:11%; margin-top: 1em">$octets =
encode(&quot;iso&minus;8859&minus;1&quot;, $string);</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CAVEAT</small></b>
: When you run &quot;$octets =
encode(&quot;UTF&minus;8&quot;, $string)&quot;, then $octets
<i>might not be equal to</i> $string. Though both contain
the same data, the <small>UTF8</small> flag for $octets is
<i>always</i> off. When you encode anything, the
<small>UTF8</small> flag on the result is always off, even
when it contains a completely valid
<small>UTF&minus;8</small> string. See &quot;The
<small>UTF8</small> flag&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em">If the $string
is &quot;undef&quot;, then &quot;undef&quot; is
returned.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;str2bytes&quot;
may be used as an alias for &quot;encode&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>decode</i></p>

<p style="margin-left:11%; margin-top: 1em">$string =
decode(ENCODING, OCTETS[, CHECK])</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the string that results from decoding the scalar
value <i><small>OCTETS</small></i> , assumed to be a
sequence of octets in <i><small>ENCODING</small></i> , into
Perl&rsquo;s internal form. As with <b>encode()</b>,
<i><small>ENCODING</small></i> can be either a canonical
name or an alias. For encoding names and aliases, see
&quot;Defining Aliases&quot;; for
<i><small>CHECK</small></i> , see &quot;Handling Malformed
Data&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CAVEAT</small></b>
: the input scalar <i><small>OCTETS</small></i> might be
modified in-place depending on what is set in
<small>CHECK.</small> See &quot;
<small>LEAVE_SRC&quot;</small> if you want your inputs to be
left unchanged.</p>

<p style="margin-left:11%; margin-top: 1em">For example, to
convert <small>ISO&minus;8859&minus;1</small> data into a
string in Perl&rsquo;s internal format:</p>

<p style="margin-left:11%; margin-top: 1em">$string =
decode(&quot;iso&minus;8859&minus;1&quot;, $octets);</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CAVEAT</small></b>
: When you run &quot;$string =
decode(&quot;UTF&minus;8&quot;, $octets)&quot;, then $string
<i>might not be equal to</i> $octets. Though both contain
the same data, the <small>UTF8</small> flag for $string is
on. See &quot;The <small>UTF8</small> flag&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em">If the $string
is &quot;undef&quot;, then &quot;undef&quot; is
returned.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;bytes2str&quot;
may be used as an alias for &quot;decode&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>find_encoding</i></p>

<p style="margin-left:11%; margin-top: 1em">[$obj =]
find_encoding(ENCODING)</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
<i>encoding object</i> corresponding to
<i><small>ENCODING</small></i> . Returns &quot;undef&quot;
if no matching <i><small>ENCODING</small></i> is find. The
returned object is what does the actual encoding or
decoding.</p>

<p style="margin-left:11%; margin-top: 1em">$string =
decode($name, $bytes);</p>

<p style="margin-left:11%; margin-top: 1em">is in fact</p>

<p style="margin-left:11%; margin-top: 1em">$string = do {
<br>
$obj = find_encoding($name); <br>
croak qq(encoding &quot;$name&quot; not found) unless ref
$obj; <br>
$obj&minus;&gt;decode($bytes); <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">with more error
checking.</p>

<p style="margin-left:11%; margin-top: 1em">You can
therefore save time by reusing this object as follows;</p>

<p style="margin-left:11%; margin-top: 1em">my $enc =
find_encoding(&quot;iso&minus;8859&minus;1&quot;); <br>
while(&lt;&gt;) { <br>
my $string = $enc&minus;&gt;decode($_); <br>
... # now do something with $string; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Besides
&quot;decode&quot; and &quot;encode&quot;, other methods are
available as well. For instance, &quot;name()&quot; returns
the canonical name of the encoding object.</p>


<p style="margin-left:11%; margin-top: 1em">find_encoding(&quot;latin1&quot;)&minus;&gt;name;
# iso&minus;8859&minus;1</p>

<p style="margin-left:11%; margin-top: 1em">See
Encode::Encoding for details.</p>


<p style="margin-left:11%; margin-top: 1em"><i>find_mime_encoding</i></p>

<p style="margin-left:11%; margin-top: 1em">[$obj =]
find_mime_encoding(MIME_ENCODING)</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
<i>encoding object</i> corresponding to
<i><small>MIME_ENCODING</small></i> . Acts same as
&quot;find_encoding()&quot; but &quot;mime_name()&quot; of
returned object must match to
<i><small>MIME_ENCODING</small></i> . So as opposite of
&quot;find_encoding()&quot; canonical names and aliases are
not used when searching for object.</p>


<p style="margin-left:11%; margin-top: 1em">find_mime_encoding(&quot;utf8&quot;);
# returns undef because &quot;utf8&quot; is not valid
I&lt;MIME_ENCODING&gt; <br>
find_mime_encoding(&quot;utf&minus;8&quot;); # returns
encode object &quot;utf&minus;8&minus;strict&quot; <br>
find_mime_encoding(&quot;UTF&minus;8&quot;); # same as
&quot;utf&minus;8&quot; because I&lt;MIME_ENCODING&gt; is
case insensitive <br>
find_mime_encoding(&quot;utf&minus;8&minus;strict&quot;);
returns undef because &quot;utf&minus;8&minus;strict&quot;
is not valid I&lt;MIME_ENCODING&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><i>from_to</i></p>

<p style="margin-left:11%; margin-top: 1em">[$length =]
from_to($octets, FROM_ENC, TO_ENC [, CHECK])</p>

<p style="margin-left:11%; margin-top: 1em">Converts
<i>in-place</i> data between two encodings. The data in
$octets must be encoded as octets and <i>not</i> as
characters in Perl&rsquo;s internal format. For example, to
convert <small>ISO&minus;8859&minus;1</small> data into
Microsoft&rsquo;s <small>CP1250</small> encoding:</p>


<p style="margin-left:11%; margin-top: 1em">from_to($octets,
&quot;iso&minus;8859&minus;1&quot;, &quot;cp1250&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">and to convert
it back:</p>


<p style="margin-left:11%; margin-top: 1em">from_to($octets,
&quot;cp1250&quot;, &quot;iso&minus;8859&minus;1&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">Because the
conversion happens in place, the data to be converted cannot
be a string constant: it must be a scalar variable.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;from_to()&quot;
returns the length of the converted string in octets on
success, and &quot;undef&quot; on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CAVEAT</small></b>
: The following operations may look the same, but are
not:</p>

<p style="margin-left:11%; margin-top: 1em">from_to($data,
&quot;iso&minus;8859&minus;1&quot;,
&quot;UTF&minus;8&quot;); #1 <br>
$data = decode(&quot;iso&minus;8859&minus;1&quot;, $data);
#2</p>

<p style="margin-left:11%; margin-top: 1em">Both #1 and #2
make $data consist of a completely valid
<small>UTF&minus;8</small> string, but only #2 turns the
<small>UTF8</small> flag on. #1 is equivalent to:</p>

<p style="margin-left:11%; margin-top: 1em">$data =
encode(&quot;UTF&minus;8&quot;,
decode(&quot;iso&minus;8859&minus;1&quot;, $data));</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;The
<small>UTF8</small> flag&quot; below.</p>

<p style="margin-left:11%; margin-top: 1em">Also note
that:</p>


<p style="margin-left:11%; margin-top: 1em">from_to($octets,
$from, $to, $check);</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to:</p>

<p style="margin-left:11%; margin-top: 1em">$octets =
encode($to, decode($from, $octets), $check);</p>

<p style="margin-left:11%; margin-top: 1em">Yes, it does
<i>not</i> respect the $check during decoding. It is
deliberately done that way. If you need minute control, use
&quot;decode&quot; followed by &quot;encode&quot; as
follows:</p>

<p style="margin-left:11%; margin-top: 1em">$octets =
encode($to, decode($from, $octets, $check_from),
$check_to);</p>


<p style="margin-left:11%; margin-top: 1em"><i>encode_utf8</i></p>

<p style="margin-left:11%; margin-top: 1em">$octets =
encode_utf8($string);</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WARNING</small></b>
: This function can produce invalid
<small>UTF&minus;8</small> ! Do not use it for data
exchange. Unless you want Perl&rsquo;s older &quot;lax&quot;
mode, prefer &quot;$octets = encode(&quot;UTF&minus;8&quot;,
$string)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Equivalent to
&quot;$octets = encode(&quot;utf8&quot;, $string)&quot;. The
characters in $string are encoded in Perl&rsquo;s internal
format, and the result is returned as a sequence of octets.
Because all possible characters in Perl have a (loose, not
strict) utf8 representation, this function cannot fail.</p>


<p style="margin-left:11%; margin-top: 1em"><i>decode_utf8</i></p>

<p style="margin-left:11%; margin-top: 1em">$string =
decode_utf8($octets [, CHECK]);</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>WARNING</small></b>
: This function accepts invalid <small>UTF&minus;8</small> !
Do not use it for data exchange. Unless you want
Perl&rsquo;s older &quot;lax&quot; mode, prefer
&quot;$string = decode(&quot;UTF&minus;8&quot;, $octets [,
CHECK])&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Equivalent to
&quot;$string = decode(&quot;utf8&quot;, $octets [,
CHECK])&quot;. The sequence of octets represented by $octets
is decoded from (loose, not strict) utf8 into a sequence of
logical characters. Because not all sequences of octets are
valid not strict utf8, it is quite possible for this
function to fail. For <small>CHECK,</small> see
&quot;Handling Malformed Data&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CAVEAT</small></b>
: the input <i>$octets</i> might be modified in-place
depending on what is set in <small>CHECK.</small> See &quot;
<small>LEAVE_SRC&quot;</small> if you want your inputs to be
left unchanged.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Listing
available encodings</b> <br>
use Encode; <br>
@list = Encode&minus;&gt;encodings();</p>

<p style="margin-left:11%; margin-top: 1em">Returns a list
of canonical names of available encodings that have already
been loaded. To get a list of all available encodings
including those that have not yet been loaded, say:</p>

<p style="margin-left:11%; margin-top: 1em">@all_encodings
= Encode&minus;&gt;encodings(&quot;:all&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">Or you can give
the name of a specific module:</p>

<p style="margin-left:11%; margin-top: 1em">@with_jp =
Encode&minus;&gt;encodings(&quot;Encode::JP&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">When
&quot;&quot;::&quot;&quot; is not in the name,
&quot;&quot;Encode::&quot;&quot; is assumed.</p>

<p style="margin-left:11%; margin-top: 1em">@ebcdic =
Encode&minus;&gt;encodings(&quot;EBCDIC&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">To find out in
detail which encodings are supported by this package, see
Encode::Supported.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Defining
Aliases</b> <br>
To add a new alias to a given encoding, use:</p>

<p style="margin-left:11%; margin-top: 1em">use Encode;
<br>
use Encode::Alias; <br>
define_alias(NEWNAME =&gt; ENCODING);</p>

<p style="margin-left:11%; margin-top: 1em">After that,
<i><small>NEWNAME</small></i> can be used as an alias for
<i><small>ENCODING</small></i> .
<i><small>ENCODING</small></i> may be either the name of an
encoding or an <i>encoding object</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Before you do
that, first make sure the alias is nonexistent using
&quot;resolve_alias()&quot;, which returns the canonical
name thereof. For example:</p>


<p style="margin-left:11%; margin-top: 1em">Encode::resolve_alias(&quot;latin1&quot;)
eq &quot;iso&minus;8859&minus;1&quot; # true <br>
Encode::resolve_alias(&quot;iso&minus;8859&minus;12&quot;) #
false; nonexistent <br>
Encode::resolve_alias($name) eq $name # true if $name is
canonical</p>


<p style="margin-left:11%; margin-top: 1em">&quot;resolve_alias()&quot;
does not need &quot;use Encode::Alias&quot;; it can be
imported via &quot;use Encode qw(resolve_alias)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">See
Encode::Alias for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Finding
<small>IANA</small> Character Set Registry names</b> <br>
The canonical name of a given encoding does not necessarily
agree with <small>IANA</small> Character Set Registry,
commonly seen as &quot;Content&minus;Type: text/plain;
charset=<i>WHATEVER</i>&quot;. For most cases, the canonical
name works, but sometimes it does not, most notably with
&quot;utf&minus;8&minus;strict&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">As of
&quot;Encode&quot; version 2.21, a new method
&quot;mime_name()&quot; is therefore added.</p>

<p style="margin-left:11%; margin-top: 1em">use Encode;
<br>
my $enc = find_encoding(&quot;UTF&minus;8&quot;); <br>
warn $enc&minus;&gt;name; # utf&minus;8&minus;strict <br>
warn $enc&minus;&gt;mime_name; # UTF&minus;8</p>

<p style="margin-left:11%; margin-top: 1em">See also:
Encode::Encoding</p>

<h2>Encoding via PerlIO
<a name="Encoding via PerlIO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If your perl
supports &quot;PerlIO&quot; (which is the default), you can
use a &quot;PerlIO&quot; layer to decode and encode directly
via a filehandle. The following two examples are fully
identical in functionality:</p>

<p style="margin-left:11%; margin-top: 1em">### Version 1
via PerlIO <br>
open(INPUT, &quot;&lt; :encoding(shiftjis)&quot;, $infile)
<br>
|| die &quot;Can't open &lt; $infile for reading: $!&quot;;
<br>
open(OUTPUT, &quot;&gt; :encoding(euc&minus;jp)&quot;,
$outfile) <br>
|| die &quot;Can't open &gt; $output for writing: $!&quot;;
<br>
while (&lt;INPUT&gt;) { # auto decodes $_ <br>
print OUTPUT; # auto encodes $_ <br>
} <br>
close(INPUT) || die &quot;can't close $infile: $!&quot;;
<br>
close(OUTPUT) || die &quot;can't close $outfile: $!&quot;;
<br>
### Version 2 via from_to() <br>
open(INPUT, &quot;&lt; :raw&quot;, $infile) <br>
|| die &quot;Can't open &lt; $infile for reading: $!&quot;;
<br>
open(OUTPUT, &quot;&gt; :raw&quot;, $outfile) <br>
|| die &quot;Can't open &gt; $output for writing: $!&quot;;
<br>
while (&lt;INPUT&gt;) { <br>
from_to($_, &quot;shiftjis&quot;, &quot;euc&minus;jp&quot;,
1); # switch encoding <br>
print OUTPUT; # emit raw (but properly encoded) data <br>
} <br>
close(INPUT) || die &quot;can't close $infile: $!&quot;;
<br>
close(OUTPUT) || die &quot;can't close $outfile:
$!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">In the first
version above, you let the appropriate encoding layer handle
the conversion. In the second, you explicitly translate from
one encoding to the other.</p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately,
it may be that encodings are not
&quot;PerlIO&quot;&minus;savvy. You can check to see whether
your encoding is supported by &quot;PerlIO&quot; by invoking
the &quot;perlio_ok&quot; method on it:</p>


<p style="margin-left:11%; margin-top: 1em">Encode::perlio_ok(&quot;hz&quot;);
# false <br>

find_encoding(&quot;euc&minus;cn&quot;)&minus;&gt;perlio_ok;
# true wherever PerlIO is available <br>
use Encode qw(perlio_ok); # imported upon request <br>
perlio_ok(&quot;euc&minus;jp&quot;)</p>

<p style="margin-left:11%; margin-top: 1em">Fortunately,
all encodings that come with &quot;Encode&quot; core are
&quot;PerlIO&quot;&minus;savvy except for &quot;hz&quot; and
&quot;ISO&minus;2022&minus;kr&quot;. For the gory details,
see Encode::Encoding and Encode::PerlIO.</p>

<h2>Handling Malformed Data
<a name="Handling Malformed Data"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The optional
<i><small>CHECK</small></i> argument tells
&quot;Encode&quot; what to do when encountering malformed
data. Without <i><small>CHECK</small></i> ,
&quot;Encode::FB_DEFAULT&quot; (== 0) is assumed.</p>

<p style="margin-left:11%; margin-top: 1em">As of version
2.12, &quot;Encode&quot; supports coderef values for
&quot;CHECK&quot;; see below.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE:</small></b>
Not all encodings support this feature. Some encodings
ignore the <i><small>CHECK</small></i> argument. For
example, Encode::Unicode ignores <i><small>CHECK</small></i>
and it always croaks on error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>List of</b>
<i><small>CHECK</small></i> <b>values</b> <i><small><br>
FB_DEFAULT</small></i></p>

<p style="margin-left:11%; margin-top: 1em">I&lt;CHECK&gt;
= Encode::FB_DEFAULT ( == 0)</p>

<p style="margin-left:11%; margin-top: 1em">If
<i><small>CHECK</small></i> is 0, encoding and decoding
replace any malformed character with a <i>substitution
character</i>. When you encode,
<i><small>SUBCHAR</small></i> is used. When you decode, the
Unicode <small>REPLACEMENT CHARACTER,</small> code point
U+FFFD, is used. If the data is supposed to be
<small>UTF&minus;8,</small> an optional lexical warning of
warning category &quot;utf8&quot; is given.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>FB_CROAK</small></i></p>

<p style="margin-left:11%; margin-top: 1em">I&lt;CHECK&gt;
= Encode::FB_CROAK ( == 1)</p>

<p style="margin-left:11%; margin-top: 1em">If
<i><small>CHECK</small></i> is 1, methods immediately die
with an error message. Therefore, when
<i><small>CHECK</small></i> is 1, you should trap exceptions
with &quot;eval{}&quot;, unless you really want to let it
&quot;die&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>FB_QUIET</small></i></p>

<p style="margin-left:11%; margin-top: 1em">I&lt;CHECK&gt;
= Encode::FB_QUIET</p>

<p style="margin-left:11%; margin-top: 1em">If
<i><small>CHECK</small></i> is set to
&quot;Encode::FB_QUIET&quot;, encoding and decoding
immediately return the portion of the data that has been
processed so far when an error occurs. The data argument is
overwritten with everything after that point; that is, the
unprocessed portion of the data. This is handy when you have
to call &quot;decode&quot; repeatedly in the case where your
source data may contain partial multi-byte character
sequences, (that is, you are reading with a fixed-width
buffer). Here&rsquo;s some sample code to do exactly
that:</p>

<p style="margin-left:11%; margin-top: 1em">my($buffer,
$string) = (&quot;&quot;, &quot;&quot;); <br>
while (read($fh, $buffer, 256, length($buffer))) { <br>
$string .= decode($encoding, $buffer, Encode::FB_QUIET);
<br>
# $buffer now contains the unprocessed partial character
<br>
}</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>FB_WARN</small></i></p>

<p style="margin-left:11%; margin-top: 1em">I&lt;CHECK&gt;
= Encode::FB_WARN</p>

<p style="margin-left:11%; margin-top: 1em">This is the
same as &quot;FB_QUIET&quot; above, except that instead of
being silent on errors, it issues a warning. This is handy
for when you are debugging.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CAVEAT</small></b>
: All warnings from Encode module are reported,
independently of pragma warnings settings. If you want to
follow settings of lexical warnings configured by pragma
warnings then append also check value
&quot;ENCODE::ONLY_PRAGMA_WARNINGS&quot;. This value is
available since Encode version 2.99.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>FB_PERLQQ
FB_HTMLCREF FB_XMLCREF</small></i> <br>
perlqq mode ( <i><small>CHECK</small></i> =
Encode::FB_PERLQQ) <small><br>
HTML</small> charref mode ( <i><small>CHECK</small></i> =
Encode::FB_HTMLCREF) <small><br>
XML</small> charref mode ( <i><small>CHECK</small></i> =
Encode::FB_XMLCREF)</p>

<p style="margin-left:11%; margin-top: 1em">For encodings
that are implemented by the &quot;Encode::XS&quot; module,
&quot;CHECK&quot; &quot;==&quot;
&quot;Encode::FB_PERLQQ&quot; puts &quot;encode&quot; and
&quot;decode&quot; into &quot;perlqq&quot; fallback
mode.</p>

<p style="margin-left:11%; margin-top: 1em">When you
decode, &quot;\x<i>HH</i>&quot; is inserted for a malformed
character, where <i><small>HH</small></i> is the hex
representation of the octet that could not be decoded to
utf8. When you encode, &quot;\x{<i>HHHH</i>}&quot; will be
inserted, where <i><small>HHHH</small></i> is the Unicode
code point (in any number of hex digits) of the character
that cannot be found in the character repertoire of the
encoding.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>HTML/XML</small> character reference modes are about
the same. In place of &quot;\x{<i>HHHH</i>}&quot;,
<small>HTML</small> uses &quot;&amp;#<i>NNN</i>;&quot; where
<i><small>NNN</small></i> is a decimal number, and
<small>XML</small> uses &quot;&amp;#x<i>HHHH</i>;&quot;
where <i><small>HHHH</small></i> is the hexadecimal
number.</p>

<p style="margin-left:11%; margin-top: 1em">In
&quot;Encode&quot; 2.10 or later, &quot;LEAVE_SRC&quot; is
also implied.</p>

<p style="margin-left:11%; margin-top: 1em"><i>The
bitmask</i></p>

<p style="margin-left:11%; margin-top: 1em">These modes are
all actually set via a bitmask. Here is how the
&quot;FB_<i>XXX</i>&quot; constants are laid out. You can
import the &quot;FB_<i>XXX</i>&quot; constants via &quot;use
Encode qw(:fallbacks)&quot;, and you can import the generic
bitmask constants via &quot;use Encode
qw(:fallback_all)&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">FB_DEFAULT
FB_CROAK FB_QUIET FB_WARN FB_PERLQQ <br>
DIE_ON_ERR 0x0001 X <br>
WARN_ON_ERR 0x0002 X <br>
RETURN_ON_ERR 0x0004 X X <br>
LEAVE_SRC 0x0008 X <br>
PERLQQ 0x0100 X <br>
HTMLCREF 0x0200 <br>
XMLCREF 0x0400</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>LEAVE_SRC</small></i></p>


<p style="margin-left:11%; margin-top: 1em">Encode::LEAVE_SRC</p>

<p style="margin-left:11%; margin-top: 1em">If the
&quot;Encode::LEAVE_SRC&quot; bit is <i>not</i> set but
<i><small>CHECK</small></i> is set, then the source string
to <b>encode()</b> or <b>decode()</b> will be overwritten in
place. If you&rsquo;re not interested in this, then
bitwise-OR it with the bitmask.</p>

<p style="margin-left:11%; margin-top: 1em"><b>coderef for
<small>CHECK</small></b> <br>
As of &quot;Encode&quot; 2.12, &quot;CHECK&quot; can also be
a code reference which takes the ordinal value of the
unmapped character as an argument and returns octets that
represent the fallback character. For instance:</p>

<p style="margin-left:11%; margin-top: 1em">$ascii =
encode(&quot;ascii&quot;, $utf8, sub{ sprintf
&quot;&lt;U+%04X&gt;&quot;, shift });</p>

<p style="margin-left:11%; margin-top: 1em">Acts like
&quot;FB_PERLQQ&quot; but U+ <i><small>XXXX</small></i> is
used instead of &quot;\x{<i>XXXX</i>}&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Fallback for
&quot;decode&quot; must return decoded string (sequence of
characters) and takes a list of ordinal values as its
arguments. So for example if you wish to decode octets as
<small>UTF&minus;8,</small> and use
<small>ISO&minus;8859&minus;15</small> as a fallback for
bytes that are not valid <small>UTF&minus;8,</small> you
could write</p>

<p style="margin-left:11%; margin-top: 1em">$str = decode
'UTF&minus;8', $octets, sub { <br>
my $tmp = join '', map chr, @_; <br>
return decode 'ISO&minus;8859&minus;15', $tmp; <br>
};</p>

<h2>Defining Encodings
<a name="Defining Encodings"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To define a new
encoding, use:</p>

<p style="margin-left:11%; margin-top: 1em">use Encode
qw(define_encoding); <br>
define_encoding($object, CANONICAL_NAME [, alias...]);</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>CANONICAL_NAME</small></i>
will be associated with <i>$object</i>. The object should
provide the interface described in Encode::Encoding. If more
than two arguments are provided, additional arguments are
considered aliases for <i>$object</i>.</p>

<p style="margin-left:11%; margin-top: 1em">See
Encode::Encoding for details.</p>

<h2>The UTF8 flag
<a name="The UTF8 flag"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Before the
introduction of Unicode support in Perl, The &quot;eq&quot;
operator just compared the strings represented by two
scalars. Beginning with Perl 5.8, &quot;eq&quot; compares
two strings with simultaneous consideration of <i>the
<small>UTF8</small> flag</i>. To explain why we made it so,
I quote from page 402 of <i>Programming Perl, 3rd ed.</i>
<br>
Goal #1:</p>

<p style="margin-left:14%;">Old byte-oriented programs
should not spontaneously break on the old byte-oriented data
they used to work on.</p>

<p style="margin-left:11%;">Goal #2:</p>

<p style="margin-left:14%;">Old byte-oriented programs
should magically start working on the new character-oriented
data when appropriate.</p>

<p style="margin-left:11%;">Goal #3:</p>

<p style="margin-left:14%;">Programs should run just as
fast in the new character-oriented mode as in the old
byte-oriented mode.</p>

<p style="margin-left:11%;">Goal #4:</p>

<p style="margin-left:14%;">Perl should remain one
language, rather than forking into a byte-oriented Perl and
a character-oriented Perl.</p>

<p style="margin-left:11%; margin-top: 1em">When
<i>Programming Perl, 3rd ed.</i> was written, not even Perl
5.6.0 had been born yet, many features documented in the
book remained unimplemented for a long time. Perl 5.8
corrected much of this, and the introduction of the
<small>UTF8</small> flag is one of them. You can think of
there being two fundamentally different kinds of strings and
string-operations in Perl: one a byte-oriented mode for when
the internal <small>UTF8</small> flag is off, and the other
a character-oriented mode for when the internal
<small>UTF8</small> flag is on.</p>

<p style="margin-left:11%; margin-top: 1em">This
<small>UTF8</small> flag is not visible in Perl scripts,
exactly for the same reason you cannot (or rather, you
<i>don&rsquo;t have to</i>) see whether a scalar contains a
string, an integer, or a floating-point number. But you can
still peek and poke these if you will. See the next
section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Messing with
Perl&rsquo;s Internals</b> <br>
The following <small>API</small> uses parts of Perl&rsquo;s
internals in the current implementation. As such, they are
efficient but may change in a future release.</p>


<p style="margin-left:11%; margin-top: 1em"><i>is_utf8</i></p>

<p style="margin-left:11%; margin-top: 1em">is_utf8(STRING
[, CHECK])</p>

<p style="margin-left:11%; margin-top: 1em">[
<small>INTERNAL</small> ] Tests whether the
<small>UTF8</small> flag is turned on in the
<i><small>STRING</small></i> . If
<i><small>CHECK</small></i> is true, also checks whether
<i><small>STRING</small></i> contains well-formed
<small>UTF&minus;8.</small> Returns true if successful,
false otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Typically only
necessary for debugging and testing. Don&rsquo;t use this
flag as a marker to distinguish character and binary data,
that should be decided for each variable when you write your
code.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>CAVEAT</small></b>
: If <i><small>STRING</small></i> has <small>UTF8</small>
flag set, it does <b><small>NOT</small></b> mean that
<i><small>STRING</small></i> is <small>UTF&minus;8</small>
encoded and vice-versa.</p>

<p style="margin-left:11%; margin-top: 1em">As of Perl
5.8.1, utf8 also has the &quot;utf8::is_utf8&quot;
function.</p>


<p style="margin-left:11%; margin-top: 1em"><i>_utf8_on</i></p>


<p style="margin-left:11%; margin-top: 1em">_utf8_on(STRING)</p>

<p style="margin-left:11%; margin-top: 1em">[
<small>INTERNAL</small> ] Turns the
<i><small>STRING</small></i> &rsquo;s internal
<small>UTF8</small> flag <b>on</b>. The
<i><small>STRING</small></i> is <i>not</i> checked for
containing only well-formed <small>UTF&minus;8.</small> Do
not use this unless you <i>know with absolute certainty</i>
that the <small>STRING</small> holds only well-formed
<small>UTF&minus;8.</small> Returns the previous state of
the <small>UTF8</small> flag (so please don&rsquo;t treat
the return value as indicating success or failure), or
&quot;undef&quot; if <i><small>STRING</small></i> is not a
string.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
: For security reasons, this function does not work on
tainted values.</p>


<p style="margin-left:11%; margin-top: 1em"><i>_utf8_off</i></p>


<p style="margin-left:11%; margin-top: 1em">_utf8_off(STRING)</p>

<p style="margin-left:11%; margin-top: 1em">[
<small>INTERNAL</small> ] Turns the
<i><small>STRING</small></i> &rsquo;s internal
<small>UTF8</small> flag <b>off</b>. Do not use frivolously.
Returns the previous state of the <small>UTF8</small> flag,
or &quot;undef&quot; if <i><small>STRING</small></i> is not
a string. Do not treat the return value as indicative of
success or failure, because that isn&rsquo;t what it means:
it is only the previous setting.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>NOTE</small></b>
: For security reasons, this function does not work on
tainted values.</p>

<h2>UTF&minus;8 vs. utf8 vs. UTF8
<a name="UTF&minus;8 vs. utf8 vs. UTF8"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">....We now view
strings not as sequences of bytes, but as sequences <br>
of numbers in the range 0 .. 2**32&minus;1 (or in the case
of 64&minus;bit <br>
computers, 0 .. 2**64&minus;1) &minus;&minus; Programming
Perl, 3rd ed.</p>

<p style="margin-left:11%; margin-top: 1em">That has
historically been Perl&rsquo;s notion of
<small>UTF&minus;8,</small> as that is how
<small>UTF&minus;8</small> was first conceived by Ken
Thompson when he invented it. However, thanks to later
revisions to the applicable standards, official
<small>UTF&minus;8</small> is now rather stricter than that.
For example, its range is much narrower (0 .. 0x10_FFFF to
cover only 21 bits instead of 32 or 64 bits) and some
sequences are not allowed, like those used in surrogate
pairs, the 31 non-character code points 0xFDD0 .. 0xFDEF,
the last two code points in <i>any</i> plane (0x
<i><small>XX</small></i> _FFFE and 0x
<i><small>XX</small></i> _FFFF), all non-shortest encodings,
etc.</p>

<p style="margin-left:11%; margin-top: 1em">The former
default in which Perl would always use a loose
interpretation of <small>UTF&minus;8</small> has now been
overruled:</p>

<p style="margin-left:11%; margin-top: 1em">From: Larry
Wall &lt;larry@wall.org&gt; <br>
Date: December 04, 2004 11:51:58 JST <br>
To: perl&minus;unicode@perl.org <br>
Subject: Re: Make Encode.pm support the real UTF&minus;8
<br>
Message&minus;Id: &lt;20041204025158.GA28754@wall.org&gt;
<br>
On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
<br>
: I've no problem with 'utf8' being perl's unrestricted uft8
encoding, <br>
: but &quot;UTF&minus;8&quot; is the name of the standard
and should give the <br>
: corresponding behaviour. <br>
For what it's worth, that's how I've always kept them
straight in my <br>
head. <br>
Also for what it's worth, Perl 6 will mostly default to
strict but <br>
make it easy to switch back to lax. <br>
Larry</p>

<p style="margin-left:11%; margin-top: 1em">Got that? As of
Perl 5.8.7, <b>&quot; <small>UTF&minus;8&quot;</small></b>
means <small>UTF&minus;8</small> in its current sense, which
is conservative and strict and security-conscious, whereas
<b>&quot;utf8&quot;</b> means <small>UTF&minus;8</small> in
its former sense, which was liberal and loose and lax.
&quot;Encode&quot; version 2.10 or later thus groks this
subtle but critically important distinction between
&quot;UTF&minus;8&quot; and &quot;utf8&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">encode(&quot;utf8&quot;,
&quot;\x{FFFF_FFFF}&quot;, 1); # okay <br>
encode(&quot;UTF&minus;8&quot;, &quot;\x{FFFF_FFFF}&quot;,
1); # croaks</p>

<p style="margin-left:11%; margin-top: 1em">This
distinction is also important for decoding. In the
following, $s stores character U+200000, which exceeds
<small>UTF&minus;8</small> &rsquo;s allowed range. $s thus
stores an invalid Unicode code point:</p>

<p style="margin-left:11%; margin-top: 1em">$s =
decode(&quot;utf8&quot;,
&quot;\xf8\x88\x80\x80\x80&quot;);</p>


<p style="margin-left:11%; margin-top: 1em">&quot;UTF&minus;8&quot;,
by contrast, will either coerce the input to something
valid:</p>

<p style="margin-left:11%; margin-top: 1em">$s =
decode(&quot;UTF&minus;8&quot;,
&quot;\xf8\x88\x80\x80\x80&quot;); # U+FFFD</p>

<p style="margin-left:11%; margin-top: 1em">.. or
croak:</p>


<p style="margin-left:11%; margin-top: 1em">decode(&quot;UTF&minus;8&quot;,
&quot;\xf8\x88\x80\x80\x80&quot;, FB_CROAK|LEAVE_SRC);</p>

<p style="margin-left:11%; margin-top: 1em">In the
&quot;Encode&quot; module, &quot;UTF&minus;8&quot; is
actually a canonical name for
&quot;utf&minus;8&minus;strict&quot;. That hyphen between
the &quot;UTF&quot; and the &quot;8&quot; is critical;
without it, &quot;Encode&quot; goes &quot;liberal&quot; and
(perhaps overly&minus;)permissive:</p>


<p style="margin-left:11%; margin-top: 1em">find_encoding(&quot;UTF&minus;8&quot;)&minus;&gt;name
# is 'utf&minus;8&minus;strict' <br>
find_encoding(&quot;utf&minus;8&quot;)&minus;&gt;name #
ditto. names are case insensitive <br>
find_encoding(&quot;utf_8&quot;)&minus;&gt;name # ditto.
&quot;_&quot; are treated as &quot;&minus;&quot; <br>
find_encoding(&quot;UTF8&quot;)&minus;&gt;name # is
'utf8'.</p>

<p style="margin-left:11%; margin-top: 1em">Perl&rsquo;s
internal <small>UTF8</small> flag is called &quot;
<small>UTF8&quot;,</small> without a hyphen. It indicates
whether a string is internally encoded as &quot;utf8&quot;,
also without a hyphen.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Encode::Encoding,
Encode::Supported, Encode::PerlIO, encoding, perlebcdic,
&quot;open&quot; in perlfunc, perlunicode, perluniintro,
perlunifaq, perlunitut utf8, the Perl Unicode Mailing List
&lt;http://lists.perl.org/list/perl&minus;unicode.html&gt;</p>

<h2>MAINTAINER
<a name="MAINTAINER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This project
was originated by the late Nick Ing-Simmons and later
maintained by Dan Kogai <i>&lt;dankogai@cpan.org&gt;</i>.
See <small>AUTHORS</small> for a full list of people
involved. For any questions, send mail to
<i>&lt;perl&minus;unicode@perl.org&gt;</i> so that we can
all share.</p>

<p style="margin-left:11%; margin-top: 1em">While Dan Kogai
retains the copyright as a maintainer, credit should go to
all those involved. See <small>AUTHORS</small> for a list of
those who submitted code to the project.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2002&minus;2014 Dan Kogai
<i>&lt;dankogai@cpan.org&gt;</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
