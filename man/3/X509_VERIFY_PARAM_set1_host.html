<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:30 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>X509_VERIFY_PARAM_SET_FLAGS</title>

</head>
<body>
<h1>X509_VERIFY_PARAM_set1_host</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">X509_VERIFY_PARAM_set_flags,
X509_VERIFY_PARAM_clear_flags, X509_VERIFY_PARAM_get_flags,
X509_VERIFY_PARAM_set_purpose,
X509_VERIFY_PARAM_get_inh_flags,
X509_VERIFY_PARAM_set_inh_flags,
X509_VERIFY_PARAM_set_trust, X509_VERIFY_PARAM_set_depth,
X509_VERIFY_PARAM_get_depth,
X509_VERIFY_PARAM_set_auth_level,
X509_VERIFY_PARAM_get_auth_level,
X509_VERIFY_PARAM_set_time, X509_VERIFY_PARAM_get_time,
X509_VERIFY_PARAM_add0_policy,
X509_VERIFY_PARAM_set1_policies,
X509_VERIFY_PARAM_get0_host, X509_VERIFY_PARAM_set1_host,
X509_VERIFY_PARAM_add1_host,
X509_VERIFY_PARAM_set_hostflags,
X509_VERIFY_PARAM_get_hostflags,
X509_VERIFY_PARAM_get0_peername,
X509_VERIFY_PARAM_get0_email, X509_VERIFY_PARAM_set1_email,
X509_VERIFY_PARAM_set1_ip, X509_VERIFY_PARAM_get1_ip_asc,
X509_VERIFY_PARAM_set1_ip_asc &minus; X509 verification
parameters</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/x509_vfy.h&gt; <br>
int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param,
<br>
unsigned long flags); <br>
int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param,
<br>
unsigned long flags); <br>
unsigned long X509_VERIFY_PARAM_get_flags(const
X509_VERIFY_PARAM *param); <br>
int X509_VERIFY_PARAM_set_inh_flags(X509_VERIFY_PARAM
*param, <br>
uint32_t flags); <br>
uint32_t X509_VERIFY_PARAM_get_inh_flags(const
X509_VERIFY_PARAM *param); <br>
int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param,
int purpose); <br>
int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param,
int trust); <br>
void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param,
time_t t); <br>
time_t X509_VERIFY_PARAM_get_time(const X509_VERIFY_PARAM
*param); <br>
int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param,
<br>
ASN1_OBJECT *policy); <br>
int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM
*param, <br>
STACK_OF(ASN1_OBJECT) *policies); <br>
void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param,
int depth); <br>
int X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM
*param); <br>
void X509_VERIFY_PARAM_set_auth_level(X509_VERIFY_PARAM
*param, <br>
int auth_level); <br>
int X509_VERIFY_PARAM_get_auth_level(const X509_VERIFY_PARAM
*param); <br>
char *X509_VERIFY_PARAM_get0_host(X509_VERIFY_PARAM *param,
int n); <br>
int X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,
<br>
const char *name, size_t namelen); <br>
int X509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,
<br>
const char *name, size_t namelen); <br>
void X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM
*param, <br>
unsigned int flags); <br>
unsigned int X509_VERIFY_PARAM_get_hostflags(const
X509_VERIFY_PARAM *param); <br>
char *X509_VERIFY_PARAM_get0_peername(const
X509_VERIFY_PARAM *param); <br>
char *X509_VERIFY_PARAM_get0_email(X509_VERIFY_PARAM
*param); <br>
int X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,
<br>
const char *email, size_t emaillen); <br>
char *X509_VERIFY_PARAM_get1_ip_asc(X509_VERIFY_PARAM
*param); <br>
int X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param, <br>
const unsigned char *ip, size_t iplen); <br>
int X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param,
const char *ipasc);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These functions
manipulate the <b>X509_VERIFY_PARAM</b> structure associated
with a certificate verification operation.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_VERIFY_PARAM_set_flags()</b> function sets the flags
in <b>param</b> by oring it with <b>flags</b>. See &quot;
<small>VERIFICATION FLAGS&quot;</small> for a complete
description of values the <b>flags</b> parameter can
take.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get_flags()</b>
returns the flags in <b>param</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get_inh_flags()</b>
returns the inheritance flags in <b>param</b> which
specifies how verification flags are copied from one
structure to another.
<b>X509_VERIFY_PARAM_set_inh_flags()</b> sets the
inheritance flags. See the <b><small>INHERITANCE
FLAGS</small></b> section for a description of these
bits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_clear_flags()</b>
clears the flags <b>flags</b> in <b>param</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set_purpose()</b>
sets the verification purpose in <b>param</b> to
<b>purpose</b>. This determines the acceptable purpose of
the certificate chain, for example
<b>X509_PURPOSE_SSL_CLIENT</b>. The purpose requirement is
cleared if <b>purpose</b> is 0.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set_trust()</b>
sets the trust setting in <b>param</b> to <b>trust</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set_time()</b>
sets the verification time in <b>param</b> to <b>t</b>.
Normally the current time is used.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_add0_policy()</b>
enables policy checking (it is disabled by default) and adds
<b>policy</b> to the acceptable policy set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set1_policies()</b>
enables policy checking (it is disabled by default) and sets
the acceptable policy set to <b>policies</b>. Any existing
policy set is cleared. The <b>policies</b> parameter can be
<b><small>NULL</small></b> to clear an existing policy
set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set_depth()</b>
sets the maximum verification depth to <b>depth</b>. That is
the maximum number of intermediate <small>CA</small>
certificates that can appear in a chain. A maximal depth
chain contains 2 more certificates than the limit, since
neither the end-entity certificate nor the trust-anchor
count against this limit. Thus a <b>depth</b> limit of 0
only allows the end-entity certificate to be signed directly
by the trust anchor, while with a <b>depth</b> limit of 1
there can be one intermediate <small>CA</small> certificate
between the trust anchor and the end-entity certificate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set_auth_level()</b>
sets the authentication security level to <b>auth_level</b>.
The authentication security level determines the acceptable
signature and public key strength when verifying certificate
chains. For a certificate chain to validate, the public keys
of all the certificates must meet the specified security
level. The signature algorithm security level is not
enforced for the chain&rsquo;s <i>trust anchor</i>
certificate, which is either directly trusted or validated
by means other than its signature. See
<b>SSL_CTX_set_security_level</b>(3) for the definitions of
the available levels. The default security level is
&minus;1, or &quot;not set&quot;. At security level 0 or
lower all algorithms are acceptable. Security level 1
requires at least 80&minus;bit&minus;equivalent security and
is broadly interoperable, though it will, for example,
reject <small>MD5</small> signatures or <small>RSA</small>
keys shorter than 1024 bits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get0_host()</b>
returns the <b>n</b>th expected <small>DNS</small> hostname
that has been set using <b>X509_VERIFY_PARAM_set1_host()</b>
or <b>X509_VERIFY_PARAM_add1_host()</b>. To obtain all names
start with <b>n</b> = 0 and increment <b>n</b> as long as no
<small>NULL</small> pointer is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set1_host()</b>
sets the expected <small>DNS</small> hostname to <b>name</b>
clearing any previously specified hostname. If <b>name</b>
is <small>NULL,</small> or empty the list of hostnames is
cleared, and name checks are not performed on the peer
certificate. If <b>name</b> is NUL-terminated,
<b>namelen</b> may be zero, otherwise <b>namelen</b> must be
set to the length of <b>name</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When a hostname
is specified, certificate verification automatically invokes
<b>X509_check_host</b>(3) with flags equal to the
<b>flags</b> argument given to
<b>X509_VERIFY_PARAM_set_hostflags()</b> (default zero).
Applications are strongly advised to use this interface in
preference to explicitly calling <b>X509_check_host</b>(3),
hostname checks may be out of scope with the
<b><small>DANE&minus;EE</small></b> (3) certificate usage,
and the internal check will be suppressed as appropriate
when <small>DANE</small> verification is enabled.</p>

<p style="margin-left:11%; margin-top: 1em">When the
subject CommonName will not be ignored, whether as a result
of the <b>X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT</b> host
flag, or because no <small>DNS</small> subject alternative
names are present in the certificate, any <small>DNS</small>
name constraints in issuer certificates apply to the subject
CommonName as well as the subject alternative name
extension.</p>

<p style="margin-left:11%; margin-top: 1em">When the
subject CommonName will be ignored, whether as a result of
the <b>X509_CHECK_FLAG_NEVER_CHECK_SUBJECT</b> host flag, or
because some <small>DNS</small> subject alternative names
are present in the certificate, <small>DNS</small> name
constraints in issuer certificates will not be applied to
the subject <small>DN.</small> As described in
<b>X509_check_host</b>(3) the
<b>X509_CHECK_FLAG_NEVER_CHECK_SUBJECT</b> flag takes
precedence over the
<b>X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT</b> flag.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get_hostflags()</b>
returns any host flags previously set via a call to
<b>X509_VERIFY_PARAM_set_hostflags()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_add1_host()</b>
adds <b>name</b> as an additional reference identifier that
can match the peer&rsquo;s certificate. Any previous names
set via <b>X509_VERIFY_PARAM_set1_host()</b> or
<b>X509_VERIFY_PARAM_add1_host()</b> are retained, no change
is made if <b>name</b> is <small>NULL</small> or empty. When
multiple names are configured, the peer is considered
verified when any name matches.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get0_peername()</b>
returns the <small>DNS</small> hostname or subject
CommonName from the peer certificate that matched one of the
reference identifiers. When wildcard matching is not
disabled, or when a reference identifier specifies a parent
domain (starts with &quot;.&quot;) rather than a hostname,
the peer name may be a wildcard name or a sub-domain of the
reference identifier respectively. The return string is
allocated by the library and is no longer valid once the
associated <b>param</b> argument is freed. Applications must
not free the return value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get0_email()</b>
returns the expected <small>RFC822</small> email
address.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set1_email()</b>
sets the expected <small>RFC822</small> email address to
<b>email</b>. If <b>email</b> is NUL-terminated,
<b>emaillen</b> may be zero, otherwise <b>emaillen</b> must
be set to the length of <b>email</b>. When an email address
is specified, certificate verification automatically invokes
<b>X509_check_email</b>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get1_ip_asc()</b>
returns the expected <small>IP</small> address as a string.
The caller is responsible for freeing it.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set1_ip()</b>
sets the expected <small>IP</small> address to <b>ip</b>.
The <b>ip</b> argument is in binary format, in network
byte-order and <b>iplen</b> must be set to 4 for IPv4 and 16
for IPv6. When an <small>IP</small> address is specified,
certificate verification automatically invokes
<b>X509_check_ip</b>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set1_ip_asc()</b>
sets the expected <small>IP</small> address to <b>ipasc</b>.
The <b>ipasc</b> argument is a NUL-terminal
<small>ASCII</small> string: dotted decimal quad for IPv4
and colon-separated hexadecimal for IPv6. The condensed
&quot;::&quot; notation is supported for IPv6 addresses.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set_flags()</b>,
<b>X509_VERIFY_PARAM_clear_flags()</b>,
<b>X509_VERIFY_PARAM_set_inh_flags()</b>,
<b>X509_VERIFY_PARAM_set_purpose()</b>,
<b>X509_VERIFY_PARAM_set_trust()</b>,
<b>X509_VERIFY_PARAM_add0_policy()
X509_VERIFY_PARAM_set1_policies()</b>,
<b>X509_VERIFY_PARAM_set1_host()</b>,
<b>X509_VERIFY_PARAM_add1_host()</b>,
<b>X509_VERIFY_PARAM_set1_email()</b>,
<b>X509_VERIFY_PARAM_set1_ip()</b> and
<b>X509_VERIFY_PARAM_set1_ip_asc()</b> return 1 for success
and 0 for failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get0_host()</b>,
<b>X509_VERIFY_PARAM_get0_email()</b>, and
<b>X509_VERIFY_PARAM_get1_ip_asc()</b>, return the string
pointers pecified above or <small>NULL</small> if the
respective value has not been set or on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get_flags()</b>
returns the current verification flags.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get_hostflags()</b>
returns any current host flags.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get_inh_flags()</b>
returns the current inheritance flags.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_set_time()</b>
and <b>X509_VERIFY_PARAM_set_depth()</b> do not return
values.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get_depth()</b>
returns the current verification depth.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_VERIFY_PARAM_get_auth_level()</b>
returns the current authentication security level.</p>

<h2>VERIFICATION FLAGS
<a name="VERIFICATION FLAGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
verification flags consists of zero or more of the following
flags ored together.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_V_FLAG_CRL_CHECK</b>
enables <small>CRL</small> checking for the certificate
chain leaf certificate. An error occurs if a suitable
<small>CRL</small> cannot be found.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_V_FLAG_CRL_CHECK_ALL</b>
enables <small>CRL</small> checking for the entire
certificate chain.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_V_FLAG_IGNORE_CRITICAL</b>
disables critical extension checking. By default any
unhandled critical extensions in certificates or (if
checked) CRLs result in a fatal error. If this flag is set
unhandled critical extensions are ignored.
<b><small>WARNING</small></b> setting this option for
anything other than debugging purposes can be a security
risk. Finer control over which extensions are supported can
be performed in the verification callback.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_V_FLAG_X509_STRICT</b> flag disables workarounds for
some broken certificates and makes the verification strictly
apply <b>X509</b> rules.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_V_FLAG_ALLOW_PROXY_CERTS</b>
enables proxy certificate verification.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_V_FLAG_POLICY_CHECK</b>
enables certificate policy checking, by default no policy
checking is performed. Additional information is sent to the
verification callback relating to policy checking.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_V_FLAG_EXPLICIT_POLICY</b>,
<b>X509_V_FLAG_INHIBIT_ANY</b> and
<b>X509_V_FLAG_INHIBIT_MAP</b> set the <b>require explicit
policy</b>, <b>inhibit any policy</b> and <b>inhibit policy
mapping</b> flags respectively as defined in
<b><small>RFC3280</small></b> . Policy checking is
automatically enabled if any of these flags are set.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>X509_V_FLAG_NOTIFY_POLICY</b> is set and the policy
checking is successful a special status code is set to the
verification callback. This permits it to examine the valid
policy tree and perform additional checks or simply log it
for debugging purposes.</p>

<p style="margin-left:11%; margin-top: 1em">By default some
additional features such as indirect CRLs and CRLs signed by
different keys are disabled. If
<b>X509_V_FLAG_EXTENDED_CRL_SUPPORT</b> is set they are
enabled.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>X509_V_FLAG_USE_DELTAS</b> is set delta CRLs (if present)
are used to determine certificate status. If not set deltas
are ignored.</p>


<p style="margin-left:11%; margin-top: 1em"><b>X509_V_FLAG_CHECK_SS_SIGNATURE</b>
requests checking the signature of the last certificate in a
chain if the certificate is supposedly self-signed. This is
prohibited and will result in an error if it is a
non-conforming <small>CA</small> certificate with key usage
restrictions not including the <i>keyCertSign</i> bit. By
default this check is disabled because it doesn&rsquo;t add
any additional security but in some cases applications might
want to check the signature anyway. A side effect of not
checking the self-signature of such a certificate is that
disabled or unsupported message digests used for the
signature are not treated as fatal errors.</p>

<p style="margin-left:11%; margin-top: 1em">When
<b>X509_V_FLAG_TRUSTED_FIRST</b> is set, which is always the
case since OpenSSL 1.1.0, construction of the certificate
chain in <b>X509_verify_cert</b>(3) searches the trust store
for issuer certificates before searching the provided
untrusted certificates. Local issuer certificates are often
more likely to satisfy local security requirements and lead
to a locally trusted root. This is especially important when
some certificates in the trust store have explicit trust
settings (see &quot; <small>TRUST SETTINGS&quot;</small> in
<b>openssl&minus;x509</b>(1)).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_V_FLAG_NO_ALT_CHAINS</b> flag could have been used
before OpenSSL 1.1.0 to suppress checking for alternative
chains. By default, unless <b>X509_V_FLAG_TRUSTED_FIRST</b>
is set, when building a certificate chain, if the first
certificate chain found is not trusted, then OpenSSL will
attempt to replace untrusted certificates supplied by the
peer with certificates from the trust store to see if an
alternative chain can be found that is trusted. As of
OpenSSL 1.1.0, with <b>X509_V_FLAG_TRUSTED_FIRST</b> always
set, this option has no effect.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_V_FLAG_PARTIAL_CHAIN</b> flag causes non-self-signed
certificates in the trust store to be treated as trust
anchors, in the same way as self-signed root
<small>CA</small> certificates. This makes it possible to
trust self-issued certificates as well as certificates
issued by an intermediate <small>CA</small> without having
to trust their ancestor root <small>CA.</small> With OpenSSL
1.1.0 and later and <b>X509_V_FLAG_PARTIAL_CHAIN</b> set,
chain construction stops as soon as the first certificate
contained in the trust store is added to the chain, whether
that certificate is a self-signed &quot;root&quot;
certificate or a not self-signed &quot;intermediate&quot; or
self-issued certificate. Thus, when an intermediate
certificate is found in the trust store, the verified chain
passed to callbacks may be shorter than it otherwise would
be without the <b>X509_V_FLAG_PARTIAL_CHAIN</b> flag.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_V_FLAG_NO_CHECK_TIME</b> flag suppresses checking
the validity period of certificates and CRLs against the
current time. If <b>X509_VERIFY_PARAM_set_time()</b> is used
to specify a verification time, the check is not
suppressed.</p>

<h2>INHERITANCE FLAGS
<a name="INHERITANCE FLAGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These flags
specify how parameters are &quot;inherited&quot; from one
structure to another.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>X509_VP_FLAG_ONCE</b> is set then the current setting is
zeroed after the next call.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>X509_VP_FLAG_LOCKED</b> is set then no values are copied.
This overrides all of the following flags.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>X509_VP_FLAG_DEFAULT</b> is set then anything set in the
source is copied to the destination. Effectively the values
in &quot;to&quot; become default values which will be used
only if nothing new is set in &quot;from&quot;. This is the
default.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>X509_VP_FLAG_OVERWRITE</b> is set then all value are
copied across whether they are set or not. Flags is still
Ored though.</p>

<p style="margin-left:11%; margin-top: 1em">If
<b>X509_VP_FLAG_RESET_FLAGS</b> is set then the flags value
is copied instead of ORed.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The above
functions should be used to manipulate verification
parameters instead of functions which work in specific
structures such as <b>X509_STORE_CTX_set_flags()</b> which
are likely to be deprecated in a future release.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Delta
<small>CRL</small> checking is currently primitive. Only a
single delta can be used and (partly due to limitations of
<b>X509_STORE</b>) constructed CRLs are not maintained.</p>

<p style="margin-left:11%; margin-top: 1em">If CRLs
checking is enable CRLs are expected to be available in the
corresponding <b>X509_STORE</b> structure. No attempt is
made to download CRLs from the <small>CRL</small>
distribution points extension.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Enable
<small>CRL</small> checking when performing certificate
verification during <small>SSL</small> connections
associated with an <b><small>SSL_CTX</small></b> structure
<b>ctx</b>:</p>


<p style="margin-left:11%; margin-top: 1em">X509_VERIFY_PARAM
*param; <br>
param = X509_VERIFY_PARAM_new(); <br>
X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);
<br>
SSL_CTX_set1_param(ctx, param); <br>
X509_VERIFY_PARAM_free(param);</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>X509_verify_cert</b>(3),
<b>X509_check_host</b>(3), <b>X509_check_email</b>(3),
<b>X509_check_ip</b>(3), <b>openssl&minus;x509</b>(1)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>X509_V_FLAG_NO_ALT_CHAINS</b> flag was added in OpenSSL
1.1.0. The flag <b>X509_V_FLAG_CB_ISSUER_CHECK</b> was
deprecated in OpenSSL 1.1.0 and has no effect.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_VERIFY_PARAM_get_hostflags()</b> function was added
in OpenSSL 1.1.0i.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_VERIFY_PARAM_get0_host()</b>,
<b>X509_VERIFY_PARAM_get0_email()</b>, and
<b>X509_VERIFY_PARAM_get1_ip_asc()</b> functions were added
in OpenSSL 3.0.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2009&minus;2023 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
