<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:23 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>JSON::PP</title>

</head>
<body>
<h1>JSON::PP</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">JSON::PP
&minus; JSON::XS compatible pure&minus;Perl module.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use JSON::PP;
<br>
# exported functions, they croak on error <br>
# and expect/generate UTF&minus;8 <br>
$utf8_encoded_json_text = encode_json
$perl_hash_or_arrayref; <br>
$perl_hash_or_arrayref = decode_json
$utf8_encoded_json_text; <br>
# OO&minus;interface <br>
$json =
JSON::PP&minus;&gt;new&minus;&gt;ascii&minus;&gt;pretty&minus;&gt;allow_nonref;
<br>
$pretty_printed_json_text = $json&minus;&gt;encode(
$perl_scalar ); <br>
$perl_scalar = $json&minus;&gt;decode( $json_text ); <br>
# Note that JSON version 2.0 and above will automatically
use <br>
# JSON::XS or JSON::PP, so you should be able to just: <br>
use JSON;</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>JSON::PP</small>
is a pure perl <small>JSON</small> decoder/encoder, and
(almost) compatible to much faster <small>JSON::XS</small>
written by Marc Lehmann in C. <small>JSON::PP</small> works
as a fallback module when you use <small>JSON</small> module
without having installed <small>JSON::XS.</small></p>

<p style="margin-left:11%; margin-top: 1em">Because of this
fallback feature of <small>JSON</small> .pm,
<small>JSON::PP</small> tries not to be more
JavaScript-friendly than <small>JSON::XS</small> (i.e. not
to escape extra characters such as U+2028 and U+2029, etc),
in order for you not to lose such JavaScript-friendliness
silently when you use <small>JSON</small> .pm and install
<small>JSON::XS</small> for speed or by accident. If you
need JavaScript-friendly RFC7159&minus;compliant pure perl
module, try JSON::Tiny, which is derived from Mojolicious
web framework and is also smaller and faster than
<small>JSON::PP.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small>JSON::PP</small>
has been in the Perl core since Perl 5.14, mainly for
<small>CPAN</small> toolchain modules to parse
<small>META</small> .json.</p>

<h2>FUNCTIONAL INTERFACE
<a name="FUNCTIONAL INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section is
taken from <small>JSON::XS</small> almost verbatim.
&quot;encode_json&quot; and &quot;decode_json&quot; are
exported by default.</p>


<p style="margin-left:11%; margin-top: 1em"><b>encode_json</b>
<br>
$json_text = encode_json $perl_scalar</p>

<p style="margin-left:11%; margin-top: 1em">Converts the
given Perl data structure to a <small>UTF&minus;8</small>
encoded, binary string (that is, the string contains octets
only). Croaks on error.</p>

<p style="margin-left:11%; margin-top: 1em">This function
call is functionally identical to:</p>

<p style="margin-left:11%; margin-top: 1em">$json_text =
JSON::PP&minus;&gt;new&minus;&gt;utf8&minus;&gt;encode($perl_scalar)</p>

<p style="margin-left:11%; margin-top: 1em">Except being
faster.</p>


<p style="margin-left:11%; margin-top: 1em"><b>decode_json</b>
<br>
$perl_scalar = decode_json $json_text</p>

<p style="margin-left:11%; margin-top: 1em">The opposite of
&quot;encode_json&quot;: expects an
<small>UTF&minus;8</small> (binary) string and tries to
parse that as an <small>UTF&minus;8</small> encoded
<small>JSON</small> text, returning the resulting reference.
Croaks on error.</p>

<p style="margin-left:11%; margin-top: 1em">This function
call is functionally identical to:</p>

<p style="margin-left:11%; margin-top: 1em">$perl_scalar =
JSON::PP&minus;&gt;new&minus;&gt;utf8&minus;&gt;decode($json_text)</p>

<p style="margin-left:11%; margin-top: 1em">Except being
faster.</p>


<p style="margin-left:11%; margin-top: 1em"><b>JSON::PP::is_bool</b>
<br>
$is_boolean = JSON::PP::is_bool($scalar)</p>

<p style="margin-left:11%; margin-top: 1em">Returns true if
the passed scalar represents either JSON::PP::true or
JSON::PP::false, two constants that act like 1 and 0
respectively and are also used to represent
<small>JSON</small> &quot;true&quot; and &quot;false&quot;
in Perl strings.</p>

<p style="margin-left:11%; margin-top: 1em">See
<small>MAPPING</small> , below, for more information on how
<small>JSON</small> values are mapped to Perl.</p>

<h2>OBJECT-ORIENTED INTERFACE
<a name="OBJECT-ORIENTED INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section is
also taken from <small>JSON::XS.</small></p>

<p style="margin-left:11%; margin-top: 1em">The object
oriented interface lets you configure your own encoding or
decoding style, within the limits of supported formats.</p>

<p style="margin-left:11%; margin-top: 1em"><b>new</b> <br>
$json = JSON::PP&minus;&gt;new</p>

<p style="margin-left:11%; margin-top: 1em">Creates a new
<small>JSON::PP</small> object that can be used to de/encode
<small>JSON</small> strings. All boolean flags described
below are by default <i>disabled</i> (with the exception of
&quot;allow_nonref&quot;, which defaults to <i>enabled</i>
since version 4.0).</p>

<p style="margin-left:11%; margin-top: 1em">The mutators
for flags all return the <small>JSON::PP</small> object
again and thus calls can be chained:</p>

<p style="margin-left:11%; margin-top: 1em">my $json =
JSON::PP&minus;&gt;new&minus;&gt;utf8&minus;&gt;space_after&minus;&gt;encode({a
=&gt; [1,2]}) <br>
=&gt; {&quot;a&quot;: [1, 2]}</p>

<p style="margin-left:11%; margin-top: 1em"><b>ascii</b>
<br>
$json = $json&minus;&gt;ascii([$enable]) <br>
$enabled = $json&minus;&gt;get_ascii</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method will
not generate characters outside the code range 0..127 (which
is <small>ASCII</small> ). Any Unicode characters outside
that range will be escaped using either a single \uXXXX (
<small>BMP</small> characters) or a double \uHHHH\uLLLLL
escape sequence, as per <small>RFC4627.</small> The
resulting encoded <small>JSON</small> text can be treated as
a native Unicode string, an ascii-encoded,
latin1&minus;encoded or <small>UTF&minus;8</small> encoded
string, or any other superset of <small>ASCII.</small></p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, then the &quot;encode&quot; method will not escape
Unicode characters unless required by the
<small>JSON</small> syntax or other flags. This results in a
faster and more compact format.</p>

<p style="margin-left:11%; margin-top: 1em">See also the
section <i><small>ENCODING/CODESET FLAG NOTES</small></i>
later in this document.</p>

<p style="margin-left:11%; margin-top: 1em">The main use
for this flag is to produce <small>JSON</small> texts that
can be transmitted over a 7&minus;bit channel, as the
encoded <small>JSON</small> texts will not contain any 8 bit
characters.</p>


<p style="margin-left:11%; margin-top: 1em">JSON::PP&minus;&gt;new&minus;&gt;ascii(1)&minus;&gt;encode([chr
0x10401]) <br>
=&gt; [&quot;\ud801\udc01&quot;]</p>

<p style="margin-left:11%; margin-top: 1em"><b>latin1</b>
<br>
$json = $json&minus;&gt;latin1([$enable]) <br>
$enabled = $json&minus;&gt;get_latin1</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method will
encode the resulting <small>JSON</small> text as latin1 (or
iso&minus;8859&minus;1), escaping any characters outside the
code range 0..255. The resulting string can be treated as a
latin1&minus;encoded <small>JSON</small> text or a native
Unicode string. The &quot;decode&quot; method will not be
affected in any way by this flag, as &quot;decode&quot; by
default expects Unicode, which is a strict superset of
latin1.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, then the &quot;encode&quot; method will not escape
Unicode characters unless required by the
<small>JSON</small> syntax or other flags.</p>

<p style="margin-left:11%; margin-top: 1em">See also the
section <i><small>ENCODING/CODESET FLAG NOTES</small></i>
later in this document.</p>

<p style="margin-left:11%; margin-top: 1em">The main use
for this flag is efficiently encoding binary data as
<small>JSON</small> text, as most octets will not be
escaped, resulting in a smaller encoded size. The
disadvantage is that the resulting <small>JSON</small> text
is encoded in latin1 (and must correctly be treated as such
when storing and transferring), a rare encoding for
<small>JSON.</small> It is therefore most useful when you
want to store data structures known to contain binary data
efficiently in files or databases, not when talking to other
<small>JSON</small> encoders/decoders.</p>


<p style="margin-left:11%; margin-top: 1em">JSON::PP&minus;&gt;new&minus;&gt;latin1&minus;&gt;encode
([&quot;\x{89}\x{abc}&quot;] <br>
=&gt; [&quot;\x{89}\\u0abc&quot;] # (perl syntax, U+abc
escaped, U+89 not)</p>

<p style="margin-left:11%; margin-top: 1em"><b>utf8</b>
<br>
$json = $json&minus;&gt;utf8([$enable]) <br>
$enabled = $json&minus;&gt;get_utf8</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method will
encode the <small>JSON</small> result into
<small>UTF&minus;8,</small> as required by many protocols,
while the &quot;decode&quot; method expects to be handled an
UTF&minus;8&minus;encoded string. Please note that
UTF&minus;8&minus;encoded strings do not contain any
characters outside the range 0..255, they are thus useful
for bytewise/binary I/O. In future versions, enabling this
option might enable autodetection of the
<small>UTF&minus;16</small> and <small>UTF&minus;32</small>
encoding families, as described in
<small>RFC4627.</small></p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, then the &quot;encode&quot; method will return the
<small>JSON</small> string as a (non-encoded) Unicode
string, while &quot;decode&quot; expects thus a Unicode
string. Any decoding or encoding (e.g. to
<small>UTF&minus;8</small> or <small>UTF&minus;16</small> )
needs to be done yourself, e.g. using the Encode module.</p>

<p style="margin-left:11%; margin-top: 1em">See also the
section <i><small>ENCODING/CODESET FLAG NOTES</small></i>
later in this document.</p>

<p style="margin-left:11%; margin-top: 1em">Example, output
UTF&minus;16BE&minus;encoded <small>JSON:</small></p>

<p style="margin-left:11%; margin-top: 1em">use Encode;
<br>
$jsontext = encode &quot;UTF&minus;16BE&quot;,
JSON::PP&minus;&gt;new&minus;&gt;encode ($object);</p>

<p style="margin-left:11%; margin-top: 1em">Example, decode
UTF&minus;32LE&minus;encoded <small>JSON:</small></p>

<p style="margin-left:11%; margin-top: 1em">use Encode;
<br>
$object = JSON::PP&minus;&gt;new&minus;&gt;decode (decode
&quot;UTF&minus;32LE&quot;, $jsontext);</p>

<p style="margin-left:11%; margin-top: 1em"><b>pretty</b>
<br>
$json = $json&minus;&gt;pretty([$enable])</p>

<p style="margin-left:11%; margin-top: 1em">This enables
(or disables) all of the &quot;indent&quot;,
&quot;space_before&quot; and &quot;space_after&quot; (and in
the future possibly more) flags in one call to generate the
most readable (or most compact) form possible.</p>

<p style="margin-left:11%; margin-top: 1em"><b>indent</b>
<br>
$json = $json&minus;&gt;indent([$enable]) <br>
$enabled = $json&minus;&gt;get_indent</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method will
use a multiline format as output, putting every array member
or object/hash key-value pair into its own line, indenting
them properly.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, no newlines or indenting will be produced, and the
resulting <small>JSON</small> text is guaranteed not to
contain any &quot;newlines&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">This setting
has no effect when decoding <small>JSON</small> texts.</p>

<p style="margin-left:11%; margin-top: 1em">The default
indent space length is three. You can use
&quot;indent_length&quot; to change the length.</p>


<p style="margin-left:11%; margin-top: 1em"><b>space_before</b>
<br>
$json = $json&minus;&gt;space_before([$enable]) <br>
$enabled = $json&minus;&gt;get_space_before</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method will
add an extra optional space before the &quot;:&quot;
separating keys from values in <small>JSON</small>
objects.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, then the &quot;encode&quot; method will not add any
extra space at those places.</p>

<p style="margin-left:11%; margin-top: 1em">This setting
has no effect when decoding <small>JSON</small> texts. You
will also most likely combine this setting with
&quot;space_after&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Example,
space_before enabled, space_after and indent disabled:</p>


<p style="margin-left:11%; margin-top: 1em">{&quot;key&quot;
:&quot;value&quot;}</p>


<p style="margin-left:11%; margin-top: 1em"><b>space_after</b>
<br>
$json = $json&minus;&gt;space_after([$enable]) <br>
$enabled = $json&minus;&gt;get_space_after</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method will
add an extra optional space after the &quot;:&quot;
separating keys from values in <small>JSON</small> objects
and extra whitespace after the &quot;,&quot; separating
key-value pairs and array members.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, then the &quot;encode&quot; method will not add any
extra space at those places.</p>

<p style="margin-left:11%; margin-top: 1em">This setting
has no effect when decoding <small>JSON</small> texts.</p>

<p style="margin-left:11%; margin-top: 1em">Example,
space_before and indent disabled, space_after enabled:</p>


<p style="margin-left:11%; margin-top: 1em">{&quot;key&quot;:
&quot;value&quot;}</p>

<p style="margin-left:11%; margin-top: 1em"><b>relaxed</b>
<br>
$json = $json&minus;&gt;relaxed([$enable]) <br>
$enabled = $json&minus;&gt;get_relaxed</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;decode&quot; will accept some
extensions to normal <small>JSON</small> syntax (see below).
&quot;encode&quot; will not be affected in anyway. <i>Be
aware that this option makes you accept invalid
<small>JSON</small> texts as if they were valid!</i>. I
suggest only to use this option to parse
application-specific files written by humans (configuration
files, resource files etc.)</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false (the default), then &quot;decode&quot; will only
accept valid <small>JSON</small> texts.</p>

<p style="margin-left:11%; margin-top: 1em">Currently
accepted extensions are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="49%">


<p>list items can have an end-comma</p></td>
<td width="34%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><small>JSON</small>
<i>separates</i> array elements and key-value pairs with
commas. This can be annoying if you write
<small>JSON</small> texts manually and want to be able to
quickly append elements, so this extension accepts comma at
the end of such items not just between them:</p>

<p style="margin-left:17%; margin-top: 1em">[ <br>
1, <br>
2, &lt;&minus; this comma not normally allowed <br>
] <br>
{ <br>
&quot;k1&quot;: &quot;v1&quot;, <br>
&quot;k2&quot;: &quot;v2&quot;, &lt;&minus; this comma not
normally allowed <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="37%">


<p style="margin-top: 1em">shell-style
&rsquo;#&rsquo;&minus;comments</p> </td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Whenever
<small>JSON</small> allows whitespace, shell-style comments
are additionally allowed. They are terminated by the first
carriage-return or line-feed character, after which more
white-space and comments are allowed.</p>

<p style="margin-left:17%; margin-top: 1em">[ <br>
1, # this comment not allowed in JSON <br>
# neither this one... <br>
]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">C&minus;style multiple-line
&rsquo;/* */&rsquo;&minus;comments ( <small>JSON::PP</small>
only)</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Whenever
<small>JSON</small> allows whitespace, C&minus;style
multiple-line comments are additionally allowed. Everything
between &quot;/*&quot; and &quot;*/&quot; is a comment,
after which more white-space and comments are allowed.</p>

<p style="margin-left:17%; margin-top: 1em">[ <br>
1, /* this comment not allowed in JSON */ <br>
/* neither this one... */ <br>
]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="74%">


<p style="margin-top: 1em">C <small>++</small> &minus;style
one-line &rsquo;//&rsquo;&minus;comments (
<small>JSON::PP</small> only)</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Whenever
<small>JSON</small> allows whitespace, C <small>++</small>
&minus;style one-line comments are additionally allowed.
They are terminated by the first carriage-return or
line-feed character, after which more white-space and
comments are allowed.</p>

<p style="margin-left:17%; margin-top: 1em">[ <br>
1, // this comment not allowed in JSON <br>
// neither this one... <br>
]</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="60%">


<p style="margin-top: 1em">literal <small>ASCII TAB</small>
characters in strings</p></td>
<td width="23%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Literal
<small>ASCII TAB</small> characters are now allowed in
strings (and treated as &quot;\t&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">[ <br>
&quot;Hello\tWorld&quot;, <br>
&quot;Hello&lt;TAB&gt;World&quot;, # literal &lt;TAB&gt;
would not normally be allowed <br>
]</p>


<p style="margin-left:11%; margin-top: 1em"><b>canonical</b>
<br>
$json = $json&minus;&gt;canonical([$enable]) <br>
$enabled = $json&minus;&gt;get_canonical</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method will
output <small>JSON</small> objects by sorting their keys.
This is adding a comparatively high overhead.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, then the &quot;encode&quot; method will output
key-value pairs in the order Perl stores them (which will
likely change between runs of the same script, and can
change even within the same run from 5.18 onwards).</p>

<p style="margin-left:11%; margin-top: 1em">This option is
useful if you want the same data structure to be encoded as
the same <small>JSON</small> text (given the same overall
settings). If it is disabled, the same hash might be encoded
differently even if contains the same data, as key-value
pairs have no inherent ordering in Perl.</p>

<p style="margin-left:11%; margin-top: 1em">This setting
has no effect when decoding <small>JSON</small> texts.</p>

<p style="margin-left:11%; margin-top: 1em">This setting
has currently no effect on tied hashes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>allow_nonref</b>
<br>
$json = $json&minus;&gt;allow_nonref([$enable]) <br>
$enabled = $json&minus;&gt;get_allow_nonref</p>

<p style="margin-left:11%; margin-top: 1em">Unlike other
boolean options, this opotion is enabled by default
beginning with version 4.0.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method can
convert a non-reference into its corresponding string,
number or null <small>JSON</small> value, which is an
extension to <small>RFC4627.</small> Likewise,
&quot;decode&quot; will accept those <small>JSON</small>
values instead of croaking.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, then the &quot;encode&quot; method will croak if it
isn&rsquo;t passed an arrayref or hashref, as
<small>JSON</small> texts must either be an object or array.
Likewise, &quot;decode&quot; will croak if given something
that is not a <small>JSON</small> object or array.</p>

<p style="margin-left:11%; margin-top: 1em">Example, encode
a Perl scalar as <small>JSON</small> value without enabled
&quot;allow_nonref&quot;, resulting in an error:</p>


<p style="margin-left:11%; margin-top: 1em">JSON::PP&minus;&gt;new&minus;&gt;allow_nonref(0)&minus;&gt;encode
(&quot;Hello, World!&quot;) <br>
=&gt; hash&minus; or arrayref expected...</p>


<p style="margin-left:11%; margin-top: 1em"><b>allow_unknown</b>
<br>
$json = $json&minus;&gt;allow_unknown([$enable]) <br>
$enabled = $json&minus;&gt;get_allow_unknown</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;encode&quot; will <i>not</i>
throw an exception when it encounters values it cannot
represent in <small>JSON</small> (for example, filehandles)
but instead will encode a <small>JSON</small>
&quot;null&quot; value. Note that blessed objects are not
included here and are handled separately by
c&lt;allow_blessed&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false (the default), then &quot;encode&quot; will throw an
exception when it encounters anything it cannot encode as
<small>JSON.</small></p>

<p style="margin-left:11%; margin-top: 1em">This option
does not affect &quot;decode&quot; in any way, and it is
recommended to leave it off unless you know your
communications partner.</p>


<p style="margin-left:11%; margin-top: 1em"><b>allow_blessed</b>
<br>
$json = $json&minus;&gt;allow_blessed([$enable]) <br>
$enabled = $json&minus;&gt;get_allow_blessed</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>OBJECT SERIALISATION&quot;</small> for details.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then the &quot;encode&quot; method will
not barf when it encounters a blessed reference that it
cannot convert otherwise. Instead, a <small>JSON</small>
&quot;null&quot; value is encoded instead of the object.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false (the default), then &quot;encode&quot; will throw an
exception when it encounters a blessed object that it cannot
convert otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">This setting
has no effect on &quot;decode&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>convert_blessed</b>
<br>
$json = $json&minus;&gt;convert_blessed([$enable]) <br>
$enabled = $json&minus;&gt;get_convert_blessed</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>OBJECT SERIALISATION&quot;</small> for details.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;encode&quot;, upon
encountering a blessed object, will check for the
availability of the &quot;TO_JSON&quot; method on the
object&rsquo;s class. If found, it will be called in scalar
context and the resulting scalar will be encoded instead of
the object.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;TO_JSON&quot; method may safely call die if it wants.
If &quot;TO_JSON&quot; returns other blessed objects, those
will be handled in the same way. &quot;TO_JSON&quot; must
take care of not causing an endless recursion cycle (==
crash) in this case. The name of &quot;TO_JSON&quot; was
chosen because other methods called by the Perl core (== not
by the user of the object) are usually in upper case letters
and to avoid collisions with any &quot;to_json&quot;
function or method.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false (the default), then &quot;encode&quot; will not
consider this type of conversion.</p>

<p style="margin-left:11%; margin-top: 1em">This setting
has no effect on &quot;decode&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>allow_tags</b>
<br>
$json = $json&minus;&gt;allow_tags([$enable]) <br>
$enabled = $json&minus;&gt;get_allow_tags</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>OBJECT SERIALISATION&quot;</small> for details.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;encode&quot;, upon
encountering a blessed object, will check for the
availability of the &quot;FREEZE&quot; method on the
object&rsquo;s class. If found, it will be used to serialise
the object into a nonstandard tagged <small>JSON</small>
value (that <small>JSON</small> decoders cannot decode).</p>

<p style="margin-left:11%; margin-top: 1em">It also causes
&quot;decode&quot; to parse such tagged <small>JSON</small>
values and deserialise them via a call to the
&quot;THAW&quot; method.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false (the default), then &quot;encode&quot; will not
consider this type of conversion, and tagged
<small>JSON</small> values will cause a parse error in
&quot;decode&quot;, as if tags were not part of the
grammar.</p>


<p style="margin-left:11%; margin-top: 1em"><b>boolean_values</b>
<br>
$json&minus;&gt;boolean_values([$false, $true]) <br>
($false, $true) = $json&minus;&gt;get_boolean_values</p>

<p style="margin-left:11%; margin-top: 1em">By default,
<small>JSON</small> booleans will be decoded as overloaded
$JSON::PP::false and $JSON::PP::true objects.</p>

<p style="margin-left:11%; margin-top: 1em">With this
method you can specify your own boolean values for decoding
&minus; on decode, <small>JSON</small> &quot;false&quot;
will be decoded as a copy of $false, and <small>JSON</small>
&quot;true&quot; will be decoded as $true (&quot;copy&quot;
here is the same thing as assigning a value to another
variable, i.e. &quot;$copy = $false&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">This is useful
when you want to pass a decoded data structure directly to
other serialisers like <small>YAML,</small>
Data::MessagePack and so on.</p>

<p style="margin-left:11%; margin-top: 1em">Note that this
works only when you &quot;decode&quot;. You can set
incompatible boolean objects (like boolean), but when you
&quot;encode&quot; a data structure with such boolean
objects, you still need to enable
&quot;convert_blessed&quot; (and add a &quot;TO_JSON&quot;
method if necessary).</p>

<p style="margin-left:11%; margin-top: 1em">Calling this
method without any arguments will reset the booleans to
their default values.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;get_boolean_values&quot;
will return both $false and $true values, or the empty list
when they are set to the default.</p>


<p style="margin-left:11%; margin-top: 1em"><b>filter_json_object</b>
<br>
$json = $json&minus;&gt;filter_json_object([$coderef])</p>

<p style="margin-left:11%; margin-top: 1em">When $coderef
is specified, it will be called from &quot;decode&quot; each
time it decodes a <small>JSON</small> object. The only
argument is a reference to the newly-created hash. If the
code references returns a single scalar (which need not be a
reference), this value (or rather a copy of it) is inserted
into the deserialised data structure. If it returns an empty
list ( <small>NOTE:</small> <i>not</i> &quot;undef&quot;,
which is a valid scalar), the original deserialised hash
will be inserted. This setting can slow down decoding
considerably.</p>

<p style="margin-left:11%; margin-top: 1em">When $coderef
is omitted or undefined, any existing callback will be
removed and &quot;decode&quot; will not change the
deserialised hash in any way.</p>

<p style="margin-left:11%; margin-top: 1em">Example,
convert all <small>JSON</small> objects into the integer
5:</p>

<p style="margin-left:11%; margin-top: 1em">my $js =
JSON::PP&minus;&gt;new&minus;&gt;filter_json_object(sub { 5
}); <br>
# returns [5] <br>
$js&minus;&gt;decode('[{}]'); <br>
# returns 5 <br>
$js&minus;&gt;decode('{&quot;a&quot;:1,
&quot;b&quot;:2}');</p>


<p style="margin-left:11%; margin-top: 1em"><b>filter_json_single_key_object</b>
<br>
$json = $json&minus;&gt;filter_json_single_key_object($key
[=&gt; $coderef])</p>

<p style="margin-left:11%; margin-top: 1em">Works remotely
similar to &quot;filter_json_object&quot;, but is only
called for <small>JSON</small> objects having a single key
named $key.</p>

<p style="margin-left:11%; margin-top: 1em">This $coderef
is called before the one specified via
&quot;filter_json_object&quot;, if any. It gets passed the
single value in the <small>JSON</small> object. If it
returns a single value, it will be inserted into the data
structure. If it returns nothing (not even &quot;undef&quot;
but the empty list), the callback from
&quot;filter_json_object&quot; will be called next, as if no
single-key callback were specified.</p>

<p style="margin-left:11%; margin-top: 1em">If $coderef is
omitted or undefined, the corresponding callback will be
disabled. There can only ever be one callback for a given
key.</p>

<p style="margin-left:11%; margin-top: 1em">As this
callback gets called less often then the
&quot;filter_json_object&quot; one, decoding speed will not
usually suffer as much. Therefore, single-key objects make
excellent targets to serialise Perl objects into, especially
as single-key <small>JSON</small> objects are as close to
the type-tagged value concept as <small>JSON</small> gets
(it&rsquo;s basically an <small>ID/VALUE</small> tuple). Of
course, <small>JSON</small> does not support this in any
way, so you need to make sure your data never looks like a
serialised Perl hash.</p>

<p style="margin-left:11%; margin-top: 1em">Typical names
for the single object key are
&quot;__class_whatever__&quot;, or
&quot;$__dollars_are_rarely_used__$&quot; or
&quot;}ugly_brace_placement&quot;, or even things like
&quot;__class_md5sum(classname)__&quot;, to reduce the risk
of clashing with real hashes.</p>

<p style="margin-left:11%; margin-top: 1em">Example, decode
<small>JSON</small> objects of the form &quot;{
&quot;__widget__&quot; =&gt; &lt;id&gt; }&quot; into the
corresponding $WIDGET{&lt;id&gt;} object:</p>

<p style="margin-left:11%; margin-top: 1em"># return
whatever is in $WIDGET{5}: <br>
JSON::PP <br>
&minus;&gt;new <br>
&minus;&gt;filter_json_single_key_object (__widget__ =&gt;
sub { <br>
$WIDGET{ $_[0] } <br>
}) <br>
&minus;&gt;decode ('{&quot;__widget__&quot;: 5') <br>
# this can be used with a TO_JSON method in some
&quot;widget&quot; class <br>
# for serialisation to json: <br>
sub WidgetBase::TO_JSON { <br>
my ($self) = @_; <br>
unless ($self&minus;&gt;{id}) { <br>
$self&minus;&gt;{id} = ..get..some..id..; <br>
$WIDGET{$self&minus;&gt;{id}} = $self; <br>
} <br>
{ __widget__ =&gt; $self&minus;&gt;{id} } <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>shrink</b>
<br>
$json = $json&minus;&gt;shrink([$enable]) <br>
$enabled = $json&minus;&gt;get_shrink</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), the string returned by &quot;encode&quot;
will be shrunk (i.e. downgraded if possible).</p>

<p style="margin-left:11%; margin-top: 1em">The actual
definition of what shrink does might change in future
versions, but it will always try to save space at the
expense of time.</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false, then <small>JSON::PP</small> does nothing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>max_depth</b>
<br>
$json = $json&minus;&gt;max_depth([$maximum_nesting_depth])
<br>
$max_depth = $json&minus;&gt;get_max_depth</p>

<p style="margin-left:11%; margin-top: 1em">Sets the
maximum nesting level (default 512) accepted while encoding
or decoding. If a higher nesting level is detected in
<small>JSON</small> text or a Perl data structure, then the
encoder and decoder will stop and croak at that point.</p>

<p style="margin-left:11%; margin-top: 1em">Nesting level
is defined by number of hash&minus; or arrayrefs that the
encoder needs to traverse to reach a given point or the
number of &quot;{&quot; or &quot;[&quot; characters without
their matching closing parenthesis crossed to reach a given
character in a string.</p>

<p style="margin-left:11%; margin-top: 1em">Setting the
maximum depth to one disallows any nesting, so that ensures
that the object is only a single hash/object or array.</p>

<p style="margin-left:11%; margin-top: 1em">If no argument
is given, the highest possible setting will be used, which
is rarely useful.</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>SECURITY CONSIDERATIONS&quot;</small> in
<small>JSON::XS</small> for more info on why this is
useful.</p>


<p style="margin-left:11%; margin-top: 1em"><b>max_size</b>
<br>
$json = $json&minus;&gt;max_size([$maximum_string_size])
<br>
$max_size = $json&minus;&gt;get_max_size</p>

<p style="margin-left:11%; margin-top: 1em">Set the maximum
length a <small>JSON</small> text may have (in bytes) where
decoding is being attempted. The default is 0, meaning no
limit. When &quot;decode&quot; is called on a string that is
longer then this many bytes, it will not attempt to decode
the string but throw an exception. This setting has no
effect on &quot;encode&quot; (yet).</p>

<p style="margin-left:11%; margin-top: 1em">If no argument
is given, the limit check will be deactivated (same as when
0 is specified).</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>SECURITY CONSIDERATIONS&quot;</small> in
<small>JSON::XS</small> for more info on why this is
useful.</p>

<p style="margin-left:11%; margin-top: 1em"><b>encode</b>
<br>
$json_text = $json&minus;&gt;encode($perl_scalar)</p>

<p style="margin-left:11%; margin-top: 1em">Converts the
given Perl value or data structure to its
<small>JSON</small> representation. Croaks on error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>decode</b>
<br>
$perl_scalar = $json&minus;&gt;decode($json_text)</p>

<p style="margin-left:11%; margin-top: 1em">The opposite of
&quot;encode&quot;: expects a <small>JSON</small> text and
tries to parse it, returning the resulting simple scalar or
reference. Croaks on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>decode_prefix</b>
<br>
($perl_scalar, $characters) =
$json&minus;&gt;decode_prefix($json_text)</p>

<p style="margin-left:11%; margin-top: 1em">This works like
the &quot;decode&quot; method, but instead of raising an
exception when there is trailing garbage after the first
<small>JSON</small> object, it will silently stop parsing
there and return the number of characters consumed so
far.</p>

<p style="margin-left:11%; margin-top: 1em">This is useful
if your <small>JSON</small> texts are not delimited by an
outer protocol and you need to know where the
<small>JSON</small> text ends.</p>


<p style="margin-left:11%; margin-top: 1em">JSON::PP&minus;&gt;new&minus;&gt;decode_prefix
(&quot;[1] the tail&quot;) <br>
=&gt; ([1], 3)</p>

<h2>FLAGS FOR JSON::PP ONLY
<a name="FLAGS FOR JSON::PP ONLY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
flags and properties are for <small>JSON::PP</small> only.
If you use any of these, you can&rsquo;t make your
application run faster by replacing <small>JSON::PP</small>
with <small>JSON::XS.</small> If you need these and also
speed boost, you might want to try Cpanel::JSON::XS, a fork
of <small>JSON::XS</small> by Reini Urban, which supports
some of these (with a different set of incompatibilities).
Most of these historical flags are only kept for backward
compatibility, and should not be used in a new
application.</p>


<p style="margin-left:11%; margin-top: 1em"><b>allow_singlequote</b>
<br>
$json = $json&minus;&gt;allow_singlequote([$enable]) <br>
$enabled = $json&minus;&gt;get_allow_singlequote</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;decode&quot; will accept
invalid <small>JSON</small> texts that contain strings that
begin and end with single quotation marks.
&quot;encode&quot; will not be affected in any way. <i>Be
aware that this option makes you accept invalid
<small>JSON</small> texts as if they were valid!</i>. I
suggest only to use this option to parse
application-specific files written by humans (configuration
files, resource files etc.)</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false (the default), then &quot;decode&quot; will only
accept valid <small>JSON</small> texts.</p>


<p style="margin-left:11%; margin-top: 1em">$json&minus;&gt;allow_singlequote&minus;&gt;decode(qq|{&quot;foo&quot;:'bar'}|);
<br>

$json&minus;&gt;allow_singlequote&minus;&gt;decode(qq|{'foo':&quot;bar&quot;}|);
<br>

$json&minus;&gt;allow_singlequote&minus;&gt;decode(qq|{'foo':'bar'}|);</p>


<p style="margin-left:11%; margin-top: 1em"><b>allow_barekey</b>
<br>
$json = $json&minus;&gt;allow_barekey([$enable]) <br>
$enabled = $json&minus;&gt;get_allow_barekey</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;decode&quot; will accept
invalid <small>JSON</small> texts that contain
<small>JSON</small> objects whose names don&rsquo;t begin
and end with quotation marks. &quot;encode&quot; will not be
affected in any way. <i>Be aware that this option makes you
accept invalid <small>JSON</small> texts as if they were
valid!</i>. I suggest only to use this option to parse
application-specific files written by humans (configuration
files, resource files etc.)</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false (the default), then &quot;decode&quot; will only
accept valid <small>JSON</small> texts.</p>


<p style="margin-left:11%; margin-top: 1em">$json&minus;&gt;allow_barekey&minus;&gt;decode(qq|{foo:&quot;bar&quot;}|);</p>


<p style="margin-left:11%; margin-top: 1em"><b>allow_bignum</b>
<br>
$json = $json&minus;&gt;allow_bignum([$enable]) <br>
$enabled = $json&minus;&gt;get_allow_bignum</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;decode&quot; will convert big
integers Perl cannot handle as integer into Math::BigInt
objects and convert floating numbers into Math::BigFloat
objects. &quot;encode&quot; will convert
&quot;Math::BigInt&quot; and &quot;Math::BigFloat&quot;
objects into <small>JSON</small> numbers.</p>


<p style="margin-left:11%; margin-top: 1em">$json&minus;&gt;allow_nonref&minus;&gt;allow_bignum;
<br>
$bigfloat =
$json&minus;&gt;decode('2.000000000000000000000000001');
<br>
print $json&minus;&gt;encode($bigfloat); <br>
# =&gt; 2.000000000000000000000000001</p>

<p style="margin-left:11%; margin-top: 1em">See also
<small>MAPPING</small> .</p>

<p style="margin-left:11%; margin-top: 1em"><b>loose</b>
<br>
$json = $json&minus;&gt;loose([$enable]) <br>
$enabled = $json&minus;&gt;get_loose</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;decode&quot; will accept
invalid <small>JSON</small> texts that contain unescaped
[\x00&minus;\x1f\x22\x5c] characters. &quot;encode&quot;
will not be affected in any way. <i>Be aware that this
option makes you accept invalid <small>JSON</small> texts as
if they were valid!</i>. I suggest only to use this option
to parse application-specific files written by humans
(configuration files, resource files etc.)</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
false (the default), then &quot;decode&quot; will only
accept valid <small>JSON</small> texts.</p>


<p style="margin-left:11%; margin-top: 1em">$json&minus;&gt;loose&minus;&gt;decode(qq|[&quot;abc
<br>
def&quot;]|);</p>


<p style="margin-left:11%; margin-top: 1em"><b>escape_slash</b>
<br>
$json = $json&minus;&gt;escape_slash([$enable]) <br>
$enabled = $json&minus;&gt;get_escape_slash</p>

<p style="margin-left:11%; margin-top: 1em">If $enable is
true (or missing), then &quot;encode&quot; will explicitly
escape <i>slash</i> (solidus; &quot;U+002F&quot;) characters
to reduce the risk of <small>XSS</small> (cross site
scripting) that may be caused by &quot;&lt;/script&gt;&quot;
in a <small>JSON</small> text, with the cost of bloating the
size of <small>JSON</small> texts.</p>

<p style="margin-left:11%; margin-top: 1em">This option may
be useful when you embed <small>JSON</small> in
<small>HTML,</small> but embedding arbitrary
<small>JSON</small> in <small>HTML</small> (by some
<small>HTML</small> template toolkit or by string
interpolation) is risky in general. You must escape
necessary characters in correct order, depending on the
context.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;decode&quot;
will not be affected in any way.</p>


<p style="margin-left:11%; margin-top: 1em"><b>indent_length</b>
<br>
$json = $json&minus;&gt;indent_length($number_of_spaces)
<br>
$length = $json&minus;&gt;get_indent_length</p>

<p style="margin-left:11%; margin-top: 1em">This option is
only useful when you also enable &quot;indent&quot; or
&quot;pretty&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><small>JSON::XS</small>
indents with three spaces when you &quot;encode&quot; (if
requested by &quot;indent&quot; or &quot;pretty&quot;), and
the number cannot be changed. <small>JSON::PP</small> allows
you to change/get the number of indent spaces with these
mutator/accessor. The default number of spaces is three (the
same as <small>JSON::XS</small> ), and the acceptable range
is from 0 (no indentation; it&rsquo;d be better to disable
indentation by indent(0)) to 15.</p>

<p style="margin-left:11%; margin-top: 1em"><b>sort_by</b>
<br>
$json = $json&minus;&gt;sort_by($code_ref) <br>
$json = $json&minus;&gt;sort_by($subroutine_name)</p>

<p style="margin-left:11%; margin-top: 1em">If you just
want to sort keys (names) in <small>JSON</small> objects
when you &quot;encode&quot;, enable &quot;canonical&quot;
option (see above) that allows you to sort object keys
alphabetically.</p>

<p style="margin-left:11%; margin-top: 1em">If you do need
to sort non-alphabetically for whatever reasons, you can
give a code reference (or a subroutine name) to
&quot;sort_by&quot;, then the argument will be passed to
Perl&rsquo;s &quot;sort&quot; built-in function.</p>

<p style="margin-left:11%; margin-top: 1em">As the sorting
is done in the <small>JSON::PP</small> scope, you usually
need to prepend &quot;JSON::PP::&quot; to the subroutine
name, and the special variables $a and $b used in the
subrontine used by &quot;sort&quot; function.</p>

<p style="margin-left:11%; margin-top: 1em">Example:</p>

<p style="margin-left:11%; margin-top: 1em">my %ORDER = (id
=&gt; 1, class =&gt; 2, name =&gt; 3); <br>
$json&minus;&gt;sort_by(sub { <br>
($ORDER{$JSON::PP::a} // 999) &lt;=&gt;
($ORDER{$JSON::PP::b} // 999) <br>
or $JSON::PP::a cmp $JSON::PP::b <br>
}); <br>
print $json&minus;&gt;encode([ <br>
{name =&gt; 'CPAN', id =&gt; 1, href =&gt;
'http://cpan.org'} <br>
]); <br>
#
[{&quot;id&quot;:1,&quot;name&quot;:&quot;CPAN&quot;,&quot;href&quot;:&quot;http://cpan.org&quot;}]</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;sort_by&quot; affects all the plain hashes in the data
structure. If you need finer control, &quot;tie&quot;
necessary hashes with a module that implements ordered hash
(such as Hash::Ordered and Tie::IxHash).
&quot;canonical&quot; and &quot;sort_by&quot; don&rsquo;t
affect the key order in &quot;tie&quot;d hashes.</p>

<p style="margin-left:11%; margin-top: 1em">use
Hash::Ordered; <br>
tie my %hash, 'Hash::Ordered', <br>
(name =&gt; 'CPAN', id =&gt; 1, href =&gt;
'http://cpan.org'); <br>
print $json&minus;&gt;encode([\%hash]); <br>
#
[{&quot;name&quot;:&quot;CPAN&quot;,&quot;id&quot;:1,&quot;href&quot;:&quot;http://cpan.org&quot;}]
# order is kept</p>

<h2>INCREMENTAL PARSING
<a name="INCREMENTAL PARSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section is
also taken from <small>JSON::XS.</small></p>

<p style="margin-left:11%; margin-top: 1em">In some cases,
there is the need for incremental parsing of
<small>JSON</small> texts. While this module always has to
keep both <small>JSON</small> text and resulting Perl data
structure in memory at one time, it does allow you to parse
a <small>JSON</small> stream incrementally. It does so by
accumulating text until it has a full <small>JSON</small>
object, which it then can decode. This process is similar to
using &quot;decode_prefix&quot; to see if a full
<small>JSON</small> object is available, but is much more
efficient (and can be implemented with a minimum of method
calls).</p>


<p style="margin-left:11%; margin-top: 1em"><small>JSON::PP</small>
will only attempt to parse the <small>JSON</small> text once
it is sure it has enough text to get a decisive result,
using a very simple but truly incremental parser. This means
that it sometimes won&rsquo;t stop as early as the full
parser, for example, it doesn&rsquo;t detect mismatched
parentheses. The only thing it guarantees is that it starts
decoding as soon as a syntactically valid
<small>JSON</small> text has been seen. This means you need
to set resource limits (e.g. &quot;max_size&quot;) to ensure
the parser will stop parsing in the presence if syntax
errors.</p>

<p style="margin-left:11%; margin-top: 1em">The following
methods implement this incremental parser.</p>


<p style="margin-left:11%; margin-top: 1em"><b>incr_parse</b>
<br>
$json&minus;&gt;incr_parse( [$string] ) # void context <br>
$obj_or_undef = $json&minus;&gt;incr_parse( [$string] ) #
scalar context <br>
@obj_or_empty = $json&minus;&gt;incr_parse( [$string] ) #
list context</p>

<p style="margin-left:11%; margin-top: 1em">This is the
central parsing function. It can both append new text and
extract objects from the stream accumulated so far (both of
these functions are optional).</p>

<p style="margin-left:11%; margin-top: 1em">If $string is
given, then this string is appended to the already existing
<small>JSON</small> fragment stored in the $json object.</p>

<p style="margin-left:11%; margin-top: 1em">After that, if
the function is called in void context, it will simply
return without doing anything further. This can be used to
add more text in as many chunks as you want.</p>

<p style="margin-left:11%; margin-top: 1em">If the method
is called in scalar context, then it will try to extract
exactly <i>one</i> <small>JSON</small> object. If that is
successful, it will return this object, otherwise it will
return &quot;undef&quot;. If there is a parse error, this
method will croak just as &quot;decode&quot; would do (one
can then use &quot;incr_skip&quot; to skip the erroneous
part). This is the most common way of using the method.</p>

<p style="margin-left:11%; margin-top: 1em">And finally, in
list context, it will try to extract as many objects from
the stream as it can find and return them, or the empty list
otherwise. For this to work, there must be no separators
(other than whitespace) between the <small>JSON</small>
objects or arrays, instead they must be concatenated
back-to-back. If an error occurs, an exception will be
raised as in the scalar context case. Note that in this
case, any previously-parsed <small>JSON</small> texts will
be lost.</p>

<p style="margin-left:11%; margin-top: 1em">Example: Parse
some <small>JSON</small> arrays/objects in a given string
and return them.</p>

<p style="margin-left:11%; margin-top: 1em">my @objs =
JSON::PP&minus;&gt;new&minus;&gt;incr_parse
(&quot;[5][7][1,2]&quot;);</p>


<p style="margin-left:11%; margin-top: 1em"><b>incr_text</b>
<br>
$lvalue_string = $json&minus;&gt;incr_text</p>

<p style="margin-left:11%; margin-top: 1em">This method
returns the currently stored <small>JSON</small> fragment as
an lvalue, that is, you can manipulate it. This <i>only</i>
works when a preceding call to &quot;incr_parse&quot; in
<i>scalar context</i> successfully returned an object. Under
all other circumstances you must not call this function (I
mean it. although in simple tests it might actually work, it
<i>will</i> fail under real world conditions). As a special
exception, you can also call this method before having
parsed anything.</p>

<p style="margin-left:11%; margin-top: 1em">That means you
can only use this function to look at or manipulate text
before or after complete <small>JSON</small> objects, not
while the parser is in the middle of parsing a
<small>JSON</small> object.</p>

<p style="margin-left:11%; margin-top: 1em">This function
is useful in two cases: a) finding the trailing text after a
<small>JSON</small> object or b) parsing multiple
<small>JSON</small> objects separated by non-JSON text (such
as commas).</p>


<p style="margin-left:11%; margin-top: 1em"><b>incr_skip</b>
<br>
$json&minus;&gt;incr_skip</p>

<p style="margin-left:11%; margin-top: 1em">This will reset
the state of the incremental parser and will remove the
parsed text from the input buffer so far. This is useful
after &quot;incr_parse&quot; died, in which case the input
buffer and incremental parser state is left unchanged, to
skip the text parsed so far and to reset the parse
state.</p>

<p style="margin-left:11%; margin-top: 1em">The difference
to &quot;incr_reset&quot; is that only text until the parse
error occurred is removed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>incr_reset</b>
<br>
$json&minus;&gt;incr_reset</p>

<p style="margin-left:11%; margin-top: 1em">This completely
resets the incremental parser, that is, after this call, it
will be as if the parser had never parsed anything.</p>

<p style="margin-left:11%; margin-top: 1em">This is useful
if you want to repeatedly parse <small>JSON</small> objects
and want to ignore any trailing data, which means you have
to reset the parser after each successful decode.</p>

<h2>MAPPING
<a name="MAPPING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Most of this
section is also taken from <small>JSON::XS.</small></p>

<p style="margin-left:11%; margin-top: 1em">This section
describes how <small>JSON::PP</small> maps Perl values to
<small>JSON</small> values and vice versa. These mappings
are designed to &quot;do the right thing&quot; in most
circumstances automatically, preserving round-tripping
characteristics (what you put in comes out as something
equivalent).</p>

<p style="margin-left:11%; margin-top: 1em">For the more
enlightened: note that in the following descriptions,
lowercase <i>perl</i> refers to the Perl interpreter, while
uppercase <i>Perl</i> refers to the abstract Perl language
itself.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>JSON</small>
&minus;&gt; <small>PERL</small></b> <br>
object</p>

<p style="margin-left:17%;">A <small>JSON</small> object
becomes a reference to a hash in Perl. No ordering of object
keys is preserved ( <small>JSON</small> does not preserve
object key ordering itself).</p>

<p style="margin-left:11%;">array</p>

<p style="margin-left:17%;">A <small>JSON</small> array
becomes a reference to an array in Perl.</p>

<p style="margin-left:11%;">string</p>

<p style="margin-left:17%;">A <small>JSON</small> string
becomes a string scalar in Perl &minus; Unicode codepoints
in <small>JSON</small> are represented by the same
codepoints in the Perl string, so no manual decoding is
necessary.</p>

<p style="margin-left:11%;">number</p>

<p style="margin-left:17%;">A <small>JSON</small> number
becomes either an integer, numeric (floating point) or
string scalar in perl, depending on its range and any
fractional parts. On the Perl level, there is no difference
between those as Perl handles all the conversion details,
but an integer may take slightly less memory and might
represent more values exactly than floating point
numbers.</p>

<p style="margin-left:17%; margin-top: 1em">If the number
consists of digits only, <small>JSON::PP</small> will try to
represent it as an integer value. If that fails, it will try
to represent it as a numeric (floating point) value if that
is possible without loss of precision. Otherwise it will
preserve the number as a string value (in which case you
lose roundtripping ability, as the <small>JSON</small>
number will be re-encoded to a <small>JSON</small>
string).</p>

<p style="margin-left:17%; margin-top: 1em">Numbers
containing a fractional or exponential part will always be
represented as numeric (floating point) values, possibly at
a loss of precision (in which case you might lose perfect
roundtripping ability, but the <small>JSON</small> number
will still be re-encoded as a <small>JSON</small>
number).</p>

<p style="margin-left:17%; margin-top: 1em">Note that
precision is not accuracy &minus; binary floating point
values cannot represent most decimal fractions exactly, and
when converting from and to floating point,
<small>JSON::PP</small> only guarantees precision up to but
not including the least significant bit.</p>

<p style="margin-left:17%; margin-top: 1em">When
&quot;allow_bignum&quot; is enabled, big integer values and
any numeric values will be converted into Math::BigInt and
Math::BigFloat objects respectively, without becoming string
scalars or losing precision.</p>

<p style="margin-left:11%;">true, false</p>

<p style="margin-left:17%;">These <small>JSON</small> atoms
become &quot;JSON::PP::true&quot; and
&quot;JSON::PP::false&quot;, respectively. They are
overloaded to act almost exactly like the numbers 1 and 0.
You can check whether a scalar is a <small>JSON</small>
boolean by using the &quot;JSON::PP::is_bool&quot;
function.</p>

<p style="margin-left:11%;">null</p>

<p style="margin-left:17%;">A <small>JSON</small> null atom
becomes &quot;undef&quot; in Perl.</p>

<p style="margin-left:11%;">shell-style comments (&quot;#
<i>text</i>&quot;)</p>

<p style="margin-left:17%;">As a nonstandard extension to
the <small>JSON</small> syntax that is enabled by the
&quot;relaxed&quot; setting, shell-style comments are
allowed. They can start anywhere outside strings and go till
the end of the line.</p>

<p style="margin-left:11%;">tagged values
(&quot;(<i>tag</i>)<i>value</i>&quot;).</p>

<p style="margin-left:17%;">Another nonstandard extension
to the <small>JSON</small> syntax, enabled with the
&quot;allow_tags&quot; setting, are tagged values. In this
implementation, the <i>tag</i> must be a perl package/class
name encoded as a <small>JSON</small> string, and the
<i>value</i> must be a <small>JSON</small> array encoding
optional constructor arguments.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>OBJECT SERIALISATION&quot;</small> , below, for
details.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>PERL</small>
&minus;&gt; <small>JSON</small></b> <br>
The mapping from Perl to <small>JSON</small> is slightly
more difficult, as Perl is a truly typeless language, so we
can only guess which <small>JSON</small> type is meant by a
Perl value. <br>
hash references</p>

<p style="margin-left:17%;">Perl hash references become
<small>JSON</small> objects. As there is no inherent
ordering in hash keys (or <small>JSON</small> objects), they
will usually be encoded in a pseudo-random order.
<small>JSON::PP</small> can optionally sort the hash keys
(determined by the <i>canonical</i> flag and/or
<i>sort_by</i> property), so the same data structure will
serialise to the same <small>JSON</small> text (given same
settings and version of <small>JSON::PP</small> ), but this
incurs a runtime overhead and is only rarely useful, e.g.
when you want to compare some <small>JSON</small> text
against another for equality.</p>

<p style="margin-left:11%;">array references</p>

<p style="margin-left:17%;">Perl array references become
<small>JSON</small> arrays.</p>

<p style="margin-left:11%;">other references</p>

<p style="margin-left:17%;">Other unblessed references are
generally not allowed and will cause an exception to be
thrown, except for references to the integers 0 and 1, which
get turned into &quot;false&quot; and &quot;true&quot; atoms
in <small>JSON.</small> You can also use
&quot;JSON::PP::false&quot; and &quot;JSON::PP::true&quot;
to improve readability.</p>

<p style="margin-left:17%; margin-top: 1em">to_json [\0,
JSON::PP::true] # yields [false,true]</p>

<p style="margin-left:11%;">JSON::PP::true,
JSON::PP::false</p>

<p style="margin-left:17%;">These special values become
<small>JSON</small> true and <small>JSON</small> false
values, respectively. You can also use &quot;\1&quot; and
&quot;\0&quot; directly if you want.</p>

<p style="margin-left:11%;">JSON::PP::null</p>

<p style="margin-left:17%;">This special value becomes
<small>JSON</small> null.</p>

<p style="margin-left:11%;">blessed objects</p>

<p style="margin-left:17%;">Blessed objects are not
directly representable in <small>JSON,</small> but
&quot;JSON::PP&quot; allows various ways of handling
objects. See &quot; <small>OBJECT
SERIALISATION&quot;</small> , below, for details.</p>

<p style="margin-left:11%;">simple scalars</p>

<p style="margin-left:17%;">Simple Perl scalars (any scalar
that is not a reference) are the most difficult objects to
encode: <small>JSON::PP</small> will encode undefined
scalars as <small>JSON</small> &quot;null&quot; values,
scalars that have last been used in a string context before
encoding as <small>JSON</small> strings, and anything else
as number value:</p>

<p style="margin-left:17%; margin-top: 1em"># dump as
number <br>
encode_json [2] # yields [2] <br>
encode_json [&minus;3.0e17] # yields [&minus;3e+17] <br>
my $value = 5; encode_json [$value] # yields [5] <br>
# used as string, so dump as string <br>
print $value; <br>
encode_json [$value] # yields [&quot;5&quot;] <br>
# undef becomes null <br>
encode_json [undef] # yields [null]</p>

<p style="margin-left:17%; margin-top: 1em">You can force
the type to be a <small>JSON</small> string by stringifying
it:</p>

<p style="margin-left:17%; margin-top: 1em">my $x = 3.1; #
some variable containing a number <br>
&quot;$x&quot;; # stringified <br>
$x .= &quot;&quot;; # another, more awkward way to stringify
<br>
print $x; # perl does it for you, too, quite often <br>
# (but for older perls)</p>

<p style="margin-left:17%; margin-top: 1em">You can force
the type to be a <small>JSON</small> number by numifying
it:</p>

<p style="margin-left:17%; margin-top: 1em">my $x =
&quot;3&quot;; # some variable containing a string <br>
$x += 0; # numify it, ensuring it will be dumped as a number
<br>
$x *= 1; # same thing, the choice is yours.</p>

<p style="margin-left:17%; margin-top: 1em">You can not
currently force the type in other, less obscure, ways.</p>

<p style="margin-left:17%; margin-top: 1em">Since version
2.91_01, <small>JSON::PP</small> uses a different number
detection logic that converts a scalar that is possible to
turn into a number safely. The new logic is slightly faster,
and tends to help people who use older perl or who want to
encode complicated data structure. However, this may results
in a different <small>JSON</small> text from the one
<small>JSON::XS</small> encodes (and thus may break tests
that compare entire <small>JSON</small> texts). If you do
need the previous behavior for compatibility or for finer
control, set <small>PERL_JSON_PP_USE_B</small> environmental
variable to true before you &quot;use&quot;
<small>JSON::PP</small> (or <small>JSON</small> .pm).</p>

<p style="margin-left:17%; margin-top: 1em">Note that
numerical precision has the same meaning as under Perl (so
binary to decimal conversion follows the same rules as in
Perl, which can differ to other languages). Also, your perl
interpreter might expose extensions to the floating point
numbers of your platform, such as infinities or NaN&rsquo;s
&minus; these cannot be represented in <small>JSON,</small>
and it is an error to pass those in.</p>


<p style="margin-left:17%; margin-top: 1em"><small>JSON::PP</small>
(and <small>JSON::XS</small> ) trusts what you pass to
&quot;encode&quot; method (or &quot;encode_json&quot;
function) is a clean, validated data structure with values
that can be represented as valid <small>JSON</small> values
only, because it&rsquo;s not from an external data source
(as opposed to <small>JSON</small> texts you pass to
&quot;decode&quot; or &quot;decode_json&quot;, which
<small>JSON::PP</small> considers tainted and doesn&rsquo;t
trust). As <small>JSON::PP</small> doesn&rsquo;t know
exactly what you and consumers of your <small>JSON</small>
texts want the unexpected values to be (you may want to
convert them into null, or to stringify them with or without
normalisation (string representation of infinities/NaN may
vary depending on platforms), or to croak without
conversion), you&rsquo;re advised to do what you and your
consumers need before you encode, and also not to numify
values that may start with values that look like a number
(including infinities/NaN), without validating.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>OBJECT
SERIALISATION</small></b> <br>
As <small>JSON</small> cannot directly represent Perl
objects, you have to choose between a pure
<small>JSON</small> representation (without the ability to
deserialise the object automatically again), and a
nonstandard extension to the <small>JSON</small> syntax,
tagged values.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>SERIALISATION</small></i></p>

<p style="margin-left:11%; margin-top: 1em">What happens
when &quot;JSON::PP&quot; encounters a Perl object depends
on the &quot;allow_blessed&quot;,
&quot;convert_blessed&quot;, &quot;allow_tags&quot; and
&quot;allow_bignum&quot; settings, which are used in this
order: <br>
1. &quot;allow_tags&quot; is enabled and the object has a
&quot;FREEZE&quot; method.</p>

<p style="margin-left:17%;">In this case,
&quot;JSON::PP&quot; creates a tagged <small>JSON</small>
value, using a nonstandard extension to the
<small>JSON</small> syntax.</p>

<p style="margin-left:17%; margin-top: 1em">This works by
invoking the &quot;FREEZE&quot; method on the object, with
the first argument being the object to serialise, and the
second argument being the constant string &quot;JSON&quot;
to distinguish it from other serialisers.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;FREEZE&quot; method can return any number of values
(i.e. zero or more). These values and the paclkage/classname
of the object will then be encoded as a tagged
<small>JSON</small> value in the following format:</p>


<p style="margin-left:17%; margin-top: 1em">(&quot;classname&quot;)[FREEZE
return values...]</p>

<p style="margin-left:17%; margin-top: 1em">e.g.:</p>


<p style="margin-left:17%; margin-top: 1em">(&quot;URI&quot;)[&quot;http://www.google.com/&quot;]
<br>
(&quot;MyDate&quot;)[2013,10,29] <br>
(&quot;ImageData::JPEG&quot;)[&quot;Z3...VlCg==&quot;]</p>

<p style="margin-left:17%; margin-top: 1em">For example,
the hypothetical &quot;My::Object&quot; &quot;FREEZE&quot;
method might use the objects &quot;type&quot; and
&quot;id&quot; members to encode the object:</p>

<p style="margin-left:17%; margin-top: 1em">sub
My::Object::FREEZE { <br>
my ($self, $serialiser) = @_; <br>
($self&minus;&gt;{type}, $self&minus;&gt;{id}) <br>
}</p>

<p style="margin-left:11%;">2. &quot;convert_blessed&quot;
is enabled and the object has a &quot;TO_JSON&quot;
method.</p>

<p style="margin-left:17%;">In this case, the
&quot;TO_JSON&quot; method of the object is invoked in
scalar context. It must return a single scalar that can be
directly encoded into <small>JSON.</small> This scalar
replaces the object in the <small>JSON</small> text.</p>

<p style="margin-left:17%; margin-top: 1em">For example,
the following &quot;TO_JSON&quot; method will convert all
<small>URI</small> objects to <small>JSON</small> strings
when serialised. The fact that these values originally were
<small>URI</small> objects is lost.</p>

<p style="margin-left:17%; margin-top: 1em">sub
URI::TO_JSON { <br>
my ($uri) = @_; <br>
$uri&minus;&gt;as_string <br>
}</p>

<p style="margin-left:11%;">3. &quot;allow_bignum&quot; is
enabled and the object is a &quot;Math::BigInt&quot; or <br>
&quot;Math::BigFloat&quot;.</p>

<p style="margin-left:17%;">The object will be serialised
as a <small>JSON</small> number value.</p>

<p style="margin-left:11%;">4. &quot;allow_blessed&quot; is
enabled.</p>

<p style="margin-left:17%;">The object will be serialised
as a <small>JSON</small> null value.</p>

<p style="margin-left:11%;">5. none of the above</p>

<p style="margin-left:17%;">If none of the settings are
enabled or the respective methods are missing,
&quot;JSON::PP&quot; throws an exception.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>DESERIALISATION</small></i></p>

<p style="margin-left:11%; margin-top: 1em">For
deserialisation there are only two cases to consider: either
nonstandard tagging was used, in which case
&quot;allow_tags&quot; decides, or objects cannot be
automatically be deserialised, in which case you can use
postprocessing or the &quot;filter_json_object&quot; or
&quot;filter_json_single_key_object&quot; callbacks to get
some real objects our of your <small>JSON.</small></p>

<p style="margin-left:11%; margin-top: 1em">This section
only considers the tagged value case: a tagged
<small>JSON</small> object is encountered during decoding
and &quot;allow_tags&quot; is disabled, a parse error will
result (as if tagged values were not part of the
grammar).</p>

<p style="margin-left:11%; margin-top: 1em">If
&quot;allow_tags&quot; is enabled, &quot;JSON::PP&quot; will
look up the &quot;THAW&quot; method of the package/classname
used during serialisation (it will not attempt to load the
package as a Perl module). If there is no such method, the
decoding will fail with an error.</p>

<p style="margin-left:11%; margin-top: 1em">Otherwise, the
&quot;THAW&quot; method is invoked with the classname as
first argument, the constant string &quot;JSON&quot; as
second argument, and all the values from the
<small>JSON</small> array (the values originally returned by
the &quot;FREEZE&quot; method) as remaining arguments.</p>

<p style="margin-left:11%; margin-top: 1em">The method must
then return the object. While technically you can return any
Perl scalar, you might have to enable the
&quot;allow_nonref&quot; setting to make that work in all
cases, so better return an actual blessed reference.</p>

<p style="margin-left:11%; margin-top: 1em">As an example,
let&rsquo;s implement a &quot;THAW&quot; function that
regenerates the &quot;My::Object&quot; from the
&quot;FREEZE&quot; example earlier:</p>

<p style="margin-left:11%; margin-top: 1em">sub
My::Object::THAW { <br>
my ($class, $serialiser, $type, $id) = @_; <br>
$class&minus;&gt;new (type =&gt; $type, id =&gt; $id) <br>
}</p>

<h2>ENCODING/CODESET FLAG NOTES
<a name="ENCODING/CODESET FLAG NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section is
taken from <small>JSON::XS.</small></p>

<p style="margin-left:11%; margin-top: 1em">The interested
reader might have seen a number of flags that signify
encodings or codesets &minus; &quot;utf8&quot;,
&quot;latin1&quot; and &quot;ascii&quot;. There seems to be
some confusion on what these do, so here is a short
comparison:</p>


<p style="margin-left:11%; margin-top: 1em">&quot;utf8&quot;
controls whether the <small>JSON</small> text created by
&quot;encode&quot; (and expected by &quot;decode&quot;) is
<small>UTF&minus;8</small> encoded or not, while
&quot;latin1&quot; and &quot;ascii&quot; only control
whether &quot;encode&quot; escapes character values outside
their respective codeset range. Neither of these flags
conflict with each other, although some combinations make
less sense than others.</p>

<p style="margin-left:11%; margin-top: 1em">Care has been
taken to make all flags symmetrical with respect to
&quot;encode&quot; and &quot;decode&quot;, that is, texts
encoded with any combination of these flag values will be
correctly decoded when the same flags are used &minus; in
general, if you use different flag settings while encoding
vs. when decoding you likely have a bug somewhere.</p>

<p style="margin-left:11%; margin-top: 1em">Below comes a
verbose discussion of these flags. Note that a
&quot;codeset&quot; is simply an abstract set of
character-codepoint pairs, while an encoding takes those
codepoint numbers and <i>encodes</i> them, in our case into
octets. Unicode is (among other things) a codeset,
<small>UTF&minus;8</small> is an encoding, and
<small>ISO&minus;8859&minus;1</small> (= latin 1) and
<small>ASCII</small> are both codesets <i>and</i> encodings
at the same time, which can be confusing. <br>
&quot;utf8&quot; flag disabled</p>

<p style="margin-left:17%;">When &quot;utf8&quot; is
disabled (the default), then
&quot;encode&quot;/&quot;decode&quot; generate and expect
Unicode strings, that is, characters with high ordinal
Unicode values (&gt; 255) will be encoded as such
characters, and likewise such characters are decoded as-is,
no changes to them will be done, except
&quot;(re&minus;)interpreting&quot; them as Unicode
codepoints or Unicode characters, respectively (to Perl,
these are the same thing in strings unless you do
funny/weird/dumb stuff).</p>

<p style="margin-left:17%; margin-top: 1em">This is useful
when you want to do the encoding yourself (e.g. when you
want to have <small>UTF&minus;16</small> encoded
<small>JSON</small> texts) or when some other layer does the
encoding for you (for example, when printing to a terminal
using a filehandle that transparently encodes to
<small>UTF&minus;8</small> you certainly do
<small>NOT</small> want to <small>UTF&minus;8</small> encode
your data first and have Perl encode it another time).</p>

<p style="margin-left:11%;">&quot;utf8&quot; flag
enabled</p>

<p style="margin-left:17%;">If the
&quot;utf8&quot;&minus;flag is enabled,
&quot;encode&quot;/&quot;decode&quot; will encode all
characters using the corresponding
<small>UTF&minus;8</small> multi-byte sequence, and will
expect your input strings to be encoded as
<small>UTF&minus;8,</small> that is, no
&quot;character&quot; of the input string must have any
value &gt; 255, as <small>UTF&minus;8</small> does not allow
that.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;utf8&quot; flag therefore switches between two modes:
disabled means you will get a Unicode string in Perl,
enabled means you get an <small>UTF&minus;8</small> encoded
octet/binary string in Perl.</p>

<p style="margin-left:11%;">&quot;latin1&quot; or
&quot;ascii&quot; flags enabled</p>

<p style="margin-left:17%;">With &quot;latin1&quot; (or
&quot;ascii&quot;) enabled, &quot;encode&quot; will escape
characters with ordinal values &gt; 255 (&gt; 127 with
&quot;ascii&quot;) and encode the remaining characters as
specified by the &quot;utf8&quot; flag.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;utf8&quot; is disabled, then the result is also
correctly encoded in those character sets (as both are
proper subsets of Unicode, meaning that a Unicode string
with all character values &lt; 256 is the same thing as a
<small>ISO&minus;8859&minus;1</small> string, and a Unicode
string with all character values &lt; 128 is the same thing
as an <small>ASCII</small> string in Perl).</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;utf8&quot; is enabled, you still get a correct
UTF&minus;8&minus;encoded string, regardless of these flags,
just some more characters will be escaped using
&quot;\uXXXX&quot; then before.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
<small>ISO&minus;8859&minus;1&minus;</small> <i>encoded</i>
strings are not compatible with <small>UTF&minus;8</small>
encoding, while ASCII-encoded strings are. That is because
the <small>ISO&minus;8859&minus;1</small> encoding is
<small>NOT</small> a subset of <small>UTF&minus;8</small>
(despite the <small>ISO&minus;8859&minus;1</small>
<i>codeset</i> being a subset of Unicode), while
<small>ASCII</small> is.</p>

<p style="margin-left:17%; margin-top: 1em">Surprisingly,
&quot;decode&quot; will ignore these flags and so treat all
input values as governed by the &quot;utf8&quot; flag. If it
is disabled, this allows you to decode
<small>ISO&minus;8859&minus;1&minus;</small> and
ASCII-encoded strings, as both strict subsets of Unicode. If
it is enabled, you can correctly decode
<small>UTF&minus;8</small> encoded strings.</p>

<p style="margin-left:17%; margin-top: 1em">So neither
&quot;latin1&quot; nor &quot;ascii&quot; are incompatible
with the &quot;utf8&quot; flag &minus; they only govern when
the <small>JSON</small> output engine escapes a character or
not.</p>

<p style="margin-left:17%; margin-top: 1em">The main use
for &quot;latin1&quot; is to relatively efficiently store
binary data as <small>JSON,</small> at the expense of
breaking compatibility with most <small>JSON</small>
decoders.</p>

<p style="margin-left:17%; margin-top: 1em">The main use
for &quot;ascii&quot; is to force the output to not contain
characters with values &gt; 127, which means you can
interpret the resulting string as <small>UTF&minus;8,
ISO&minus;8859&minus;1, ASCII, KOI8&minus;R</small> or most
about any character set and 8&minus;bit&minus;encoding, and
still get the same data structure back. This is useful when
your channel for <small>JSON</small> transfer is not
8&minus;bit clean or the encoding might be mangled in
between (e.g. in mail), and works because
<small>ASCII</small> is a proper subset of most 8&minus;bit
and multibyte encodings in use in the world.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please report
bugs on a specific behavior of this module to
<small>RT</small> or GitHub issues (preferred):</p>


<p style="margin-left:11%; margin-top: 1em">&lt;https://github.com/makamaka/JSON&minus;PP/issues&gt;</p>


<p style="margin-left:11%; margin-top: 1em">&lt;https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON&minus;PP&gt;</p>

<p style="margin-left:11%; margin-top: 1em">As for new
features and requests to change common behaviors, please ask
the author of <small>JSON::XS</small> (Marc Lehmann,
&lt;schmorp[at]schmorp.de&gt;) first, by email (important!),
to keep compatibility among <small>JSON</small> .pm
backends.</p>

<p style="margin-left:11%; margin-top: 1em">Generally
speaking, if you need something special for you, you are
advised to create a new module, maybe based on JSON::Tiny,
which is smaller and written in a much cleaner way than this
module.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>json_pp</i> command line utility for quick
experiments.</p>


<p style="margin-left:11%; margin-top: 1em"><small>JSON::XS</small>
, Cpanel::JSON::XS, and JSON::Tiny for faster alternatives.
<small>JSON</small> and JSON::MaybeXS for easy
migration.</p>


<p style="margin-left:11%; margin-top: 1em">JSON::PP::Compat5005
and JSON::PP::Compat5006 for older perl users.</p>


<p style="margin-left:11%; margin-top: 1em"><small>RFC4627</small>
(&lt;http://www.ietf.org/rfc/rfc4627.txt&gt;)</p>


<p style="margin-left:11%; margin-top: 1em"><small>RFC7159</small>
(&lt;http://www.ietf.org/rfc/rfc7159.txt&gt;)</p>


<p style="margin-left:11%; margin-top: 1em"><small>RFC8259</small>
(&lt;http://www.ietf.org/rfc/rfc8259.txt&gt;)</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Makamaka
Hannyaharamitu, &lt;makamaka[at]cpan.org&gt;</p>

<h2>CURRENT MAINTAINER
<a name="CURRENT MAINTAINER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Kenichi
Ishigaki, &lt;ishigaki[at]cpan.org&gt;</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2007&minus;2016 by Makamaka Hannyaharamitu</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
documentation is taken from <small>JSON::XS</small> by Marc
Lehmann</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
