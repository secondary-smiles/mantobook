<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:43 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XML::LibXML::Node</title>

</head>
<body>
<h1>XML::LibXML::Node</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XML::LibXML::Node
&minus; Abstract Base Class of XML::LibXML Nodes</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use
XML::LibXML; <br>
$name = $node&minus;&gt;nodeName; <br>
$node&minus;&gt;setNodeName( $newName ); <br>
$bool = $node&minus;&gt;isSameNode( $other_node ); <br>
$bool = $node&minus;&gt;isEqual( $other_node ); <br>
$num = $node&minus;&gt;unique_key; <br>
$content = $node&minus;&gt;nodeValue; <br>
$content = $node&minus;&gt;textContent; <br>
$type = $node&minus;&gt;nodeType; <br>
$node&minus;&gt;unbindNode(); <br>
$childnode = $node&minus;&gt;removeChild( $childnode ); <br>
$oldnode = $node&minus;&gt;replaceChild( $newNode, $oldNode
); <br>
$node&minus;&gt;replaceNode($newNode); <br>
$childnode = $node&minus;&gt;appendChild( $childnode ); <br>
$childnode = $node&minus;&gt;addChild( $childnode ); <br>
$node = $parent&minus;&gt;addNewChild( $nsURI, $name ); <br>
$node&minus;&gt;addSibling($newNode); <br>
$newnode =$node&minus;&gt;cloneNode( $deep ); <br>
$parentnode = $node&minus;&gt;parentNode; <br>
$nextnode = $node&minus;&gt;nextSibling(); <br>
$nextnode = $node&minus;&gt;nextNonBlankSibling(); <br>
$prevnode = $node&minus;&gt;previousSibling(); <br>
$prevnode = $node&minus;&gt;previousNonBlankSibling(); <br>
$boolean = $node&minus;&gt;hasChildNodes(); <br>
$childnode = $node&minus;&gt;firstChild; <br>
$childnode = $node&minus;&gt;lastChild; <br>
$documentnode = $node&minus;&gt;ownerDocument; <br>
$node = $node&minus;&gt;getOwner; <br>
$node&minus;&gt;setOwnerDocument( $doc ); <br>
$node&minus;&gt;insertBefore( $newNode, $refNode ); <br>
$node&minus;&gt;insertAfter( $newNode, $refNode ); <br>
@nodes = $node&minus;&gt;findnodes( $xpath_expression );
<br>
$result = $node&minus;&gt;find( $xpath ); <br>
print $node&minus;&gt;findvalue( $xpath ); <br>
$bool = $node&minus;&gt;exists( $xpath_expression ); <br>
@childnodes = $node&minus;&gt;childNodes(); <br>
@childnodes = $node&minus;&gt;nonBlankChildNodes(); <br>
$xmlstring = $node&minus;&gt;toString($format,$docencoding);
<br>
$c14nstring = $node&minus;&gt;toStringC14N(); <br>
$c14nstring = $node&minus;&gt;toStringC14N($with_comments,
$xpath_expression , $xpath_context); <br>
$c14nstring = $node&minus;&gt;toStringC14N_v1_1(); <br>
$c14nstring =
$node&minus;&gt;toStringC14N_v1_1($with_comments,
$xpath_expression , $xpath_context); <br>
$ec14nstring = $node&minus;&gt;toStringEC14N(); <br>
$ec14nstring = $node&minus;&gt;toStringEC14N($with_comments,
$xpath_expression, $inclusive_prefix_list); <br>
$ec14nstring = $node&minus;&gt;toStringEC14N($with_comments,
$xpath_expression, $xpath_context, $inclusive_prefix_list);
<br>
$str = $doc&minus;&gt;serialize($format); <br>
$localname = $node&minus;&gt;localname; <br>
$nameprefix = $node&minus;&gt;prefix; <br>
$uri = $node&minus;&gt;namespaceURI(); <br>
$boolean = $node&minus;&gt;hasAttributes(); <br>
@attributelist = $node&minus;&gt;attributes(); <br>
$URI = $node&minus;&gt;lookupNamespaceURI( $prefix ); <br>
$prefix = $node&minus;&gt;lookupNamespacePrefix( $URI );
<br>
$node&minus;&gt;normalize; <br>
@nslist = $node&minus;&gt;getNamespaces; <br>
$node&minus;&gt;removeChildNodes(); <br>
$strURI = $node&minus;&gt;baseURI(); <br>
$node&minus;&gt;setBaseURI($strURI); <br>
$node&minus;&gt;nodePath(); <br>
$lineno = $node&minus;&gt;line_number();</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">XML::LibXML::Node
defines functions that are common to all Node Types. An
XML::LibXML::Node should never be created standalone, but as
an instance of a high level class such as
XML::LibXML::Element or XML::LibXML::Text. The class itself
should provide only common functionality. In XML::LibXML
each node is part either of a document or a
document-fragment. Because of this there is no node without
a parent. This may causes confusion with &quot;unbound&quot;
nodes.</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Many functions
listed here are extensively documented in the
<small>DOM</small> Level 3 specification
(&lt;http://www.w3.org/TR/DOM&minus;Level&minus;3&minus;Core/&gt;).
Please refer to the specification for extensive
documentation. <br>
nodeName</p>

<p style="margin-left:17%;">$name =
$node&minus;&gt;nodeName;</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
node&rsquo;s name. This function is aware of namespaces and
returns the full name of the current node
(&quot;prefix:localname&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">Since 1.62 this
function also returns the correct <small>DOM</small> names
for node types with constant names, namely: #text,
#cdata&minus;section, #comment, #document,
#document&minus;fragment.</p>

<p style="margin-left:11%;">setNodeName</p>

<p style="margin-left:17%;">$node&minus;&gt;setNodeName(
$newName );</p>

<p style="margin-left:17%; margin-top: 1em">In very limited
situations, it is useful to change a nodes name. In the
<small>DOM</small> specification this should throw an error.
This Function is aware of namespaces.</p>

<p style="margin-left:11%;">isSameNode</p>

<p style="margin-left:17%;">$bool =
$node&minus;&gt;isSameNode( $other_node );</p>

<p style="margin-left:17%; margin-top: 1em">returns
<small>TRUE</small> (1) if the given nodes refer to the same
node structure, otherwise <small>FALSE</small> (0) is
returned.</p>

<p style="margin-left:11%;">isEqual</p>

<p style="margin-left:17%;">$bool =
$node&minus;&gt;isEqual( $other_node );</p>

<p style="margin-left:17%; margin-top: 1em">deprecated
version of <b>isSameNode()</b>.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>NOTE</small></i>
isEqual will change behaviour to follow the
<small>DOM</small> specification</p>

<p style="margin-left:11%;">unique_key</p>

<p style="margin-left:17%;">$num =
$node&minus;&gt;unique_key;</p>

<p style="margin-left:17%; margin-top: 1em">This function
is not specified for any <small>DOM</small> level. It
returns a key guaranteed to be unique for this node, and to
always be the same value for this node. In other words, two
node objects return the same key if and only if isSameNode
indicates that they are the same node.</p>

<p style="margin-left:17%; margin-top: 1em">The returned
key value is useful as a key in hashes.</p>

<p style="margin-left:11%;">nodeValue</p>

<p style="margin-left:17%;">$content =
$node&minus;&gt;nodeValue;</p>

<p style="margin-left:17%; margin-top: 1em">If the node has
any content (such as stored in a &quot;text node&quot;) it
can get requested through this function.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>NOTE:</small></i>
Element Nodes have no content per definition. To get the
text value of an Element use <b>textContent()</b>
instead!</p>

<p style="margin-left:11%;">textContent</p>

<p style="margin-left:17%;">$content =
$node&minus;&gt;textContent;</p>

<p style="margin-left:17%; margin-top: 1em">this function
returns the content of all text nodes in the descendants of
the given node as specified in <small>DOM.</small></p>

<p style="margin-left:11%;">nodeType</p>

<p style="margin-left:17%;">$type =
$node&minus;&gt;nodeType;</p>

<p style="margin-left:17%; margin-top: 1em">Return a
numeric value representing the node type of this node. The
module XML::LibXML by default exports constants for the node
types (see the <small>EXPORT</small> section in the
XML::LibXML manual page).</p>

<p style="margin-left:11%;">unbindNode</p>


<p style="margin-left:17%;">$node&minus;&gt;unbindNode();</p>

<p style="margin-left:17%; margin-top: 1em">Unbinds the
Node from its siblings and Parent, but not from the Document
it belongs to. If the node is not inserted into the
<small>DOM</small> afterwards, it will be lost after the
program terminates. From a low level view, the unbound node
is stripped from the context it is and inserted into a
(hidden) document-fragment.</p>

<p style="margin-left:11%;">removeChild</p>

<p style="margin-left:17%;">$childnode =
$node&minus;&gt;removeChild( $childnode );</p>

<p style="margin-left:17%; margin-top: 1em">This will
unbind the Child Node from its parent $node. The function
returns the unbound node. If $childnode is not a child of
the given Node the function will fail.</p>

<p style="margin-left:11%;">replaceChild</p>

<p style="margin-left:17%;">$oldnode =
$node&minus;&gt;replaceChild( $newNode, $oldNode );</p>

<p style="margin-left:17%; margin-top: 1em">Replaces the
$oldNode with the $newNode. The $oldNode will be unbound
from the Node. This function differs from the <small>DOM
L2</small> specification, in the case, if the new node is
not part of the document, the node will be imported
first.</p>

<p style="margin-left:11%;">replaceNode</p>


<p style="margin-left:17%;">$node&minus;&gt;replaceNode($newNode);</p>

<p style="margin-left:17%; margin-top: 1em">This function
is very similar to <b>replaceChild()</b>, but it replaces
the node itself rather than a childnode. This is useful if a
node found by any XPath function, should be replaced.</p>

<p style="margin-left:11%;">appendChild</p>

<p style="margin-left:17%;">$childnode =
$node&minus;&gt;appendChild( $childnode );</p>

<p style="margin-left:17%; margin-top: 1em">The function
will add the $childnode to the end of $node&rsquo;s
children. The function should fail, if the new childnode is
already a child of $node. This function differs from the
<small>DOM L2</small> specification, in the case, if the new
node is not part of the document, the node will be imported
first.</p>

<p style="margin-left:11%;">addChild</p>

<p style="margin-left:17%;">$childnode =
$node&minus;&gt;addChild( $childnode );</p>

<p style="margin-left:17%; margin-top: 1em">As an
alternative to <b>appendChild()</b> one can use the
<b>addChild()</b> function. This function is a bit faster,
because it avoids all <small>DOM</small> conformity checks.
Therefore this function is quite useful if one builds
<small>XML</small> documents in memory where the order and
ownership (&quot;ownerDocument&quot;) is assured.</p>


<p style="margin-left:17%; margin-top: 1em"><b>addChild()</b>
uses libxml2&rsquo;s own <b>xmlAddChild()</b> function. Thus
it has to be used with extra care: If a text node is added
to a node and the node itself or its last childnode is as
well a text node, the node to add will be merged with the
one already available. The current node will be removed from
memory after this action. Because perl is not aware of this
action, the perl instance is still available. XML::LibXML
will catch the loss of a node and refuse to run any function
called on that node.</p>

<p style="margin-left:17%; margin-top: 1em">my $t1 =
$doc&minus;&gt;createTextNode( &quot;foo&quot; ); <br>
my $t2 = $doc&minus;&gt;createTextNode( &quot;bar&quot; );
<br>
$t1&minus;&gt;addChild( $t2 ); # is OK <br>
my $val = $t2&minus;&gt;nodeValue(); # will fail, script
dies</p>

<p style="margin-left:17%; margin-top: 1em">Also
<b>addChild()</b> will not check if the added node belongs
to the same document as the node it will be added to. This
could lead to inconsistent documents and in more worse cases
even to memory violations, if one does not keep track of
this issue.</p>

<p style="margin-left:17%; margin-top: 1em">Although this
sounds like a lot of trouble, <b>addChild()</b> is useful if
a document is built from a stream, such as happens sometimes
in <small>SAX</small> handlers or filters.</p>

<p style="margin-left:17%; margin-top: 1em">If you are not
sure about the source of your nodes, you better stay with
<b>appendChild()</b>, because this function is more user
friendly in the sense of being more error tolerant.</p>

<p style="margin-left:11%;">addNewChild</p>

<p style="margin-left:17%;">$node =
$parent&minus;&gt;addNewChild( $nsURI, $name );</p>

<p style="margin-left:17%; margin-top: 1em">Similar to
&quot;addChild()&quot;, this function uses low level libxml2
functionality to provide faster interface for
<small>DOM</small> building. <b><i>addNewChild()</i></b>
uses &quot;xmlNewChild()&quot; to create a new node on a
given parent element.</p>


<p style="margin-left:17%; margin-top: 1em"><b>addNewChild()</b>
has two parameters $nsURI and $name, where $nsURI is an
(optional) namespace <small>URI.</small> $name is the fully
qualified element name; <b>addNewChild()</b> will determine
the correct prefix if necessary.</p>

<p style="margin-left:17%; margin-top: 1em">The function
returns the newly created node.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is very useful for <small>DOM</small> building, where a
created node can be directly associated with its parent.
<i><small>NOTE</small></i> this function is not part of the
<small>DOM</small> specification and its use will limit your
code to XML::LibXML.</p>

<p style="margin-left:11%;">addSibling</p>


<p style="margin-left:17%;">$node&minus;&gt;addSibling($newNode);</p>


<p style="margin-left:17%; margin-top: 1em"><b>addSibling()</b>
allows adding an additional node to the end of a nodelist,
defined by the given node.</p>

<p style="margin-left:11%;">cloneNode</p>

<p style="margin-left:17%;">$newnode
=$node&minus;&gt;cloneNode( $deep );</p>


<p style="margin-left:17%; margin-top: 1em"><i>cloneNode</i>
creates a copy of $node. When $deep is set to 1 (true) the
function will copy all child nodes as well. If $deep is 0
only the current node will be copied. Note that in case of
element, attributes are copied even if $deep is 0.</p>

<p style="margin-left:17%; margin-top: 1em">Note that the
behavior of this function for $deep=0 has changed in 1.62 in
order to be consistent with the <small>DOM</small> spec (in
older versions attributes and namespace information was not
copied for elements).</p>

<p style="margin-left:11%;">parentNode</p>

<p style="margin-left:17%;">$parentnode =
$node&minus;&gt;parentNode;</p>

<p style="margin-left:17%; margin-top: 1em">Returns simply
the Parent Node of the current node.</p>

<p style="margin-left:11%;">nextSibling</p>

<p style="margin-left:17%;">$nextnode =
$node&minus;&gt;nextSibling();</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
next sibling if any .</p>

<p style="margin-left:11%;">nextNonBlankSibling</p>

<p style="margin-left:17%;">$nextnode =
$node&minus;&gt;nextNonBlankSibling();</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
next non-blank sibling if any (a node is blank if it is a
Text or <small>CDATA</small> node consisting of whitespace
only). This method is not defined by <small>DOM.</small></p>

<p style="margin-left:11%;">previousSibling</p>

<p style="margin-left:17%;">$prevnode =
$node&minus;&gt;previousSibling();</p>

<p style="margin-left:17%; margin-top: 1em">Analogous to
<i>getNextSibling</i> the function returns the previous
sibling if any.</p>

<p style="margin-left:11%;">previousNonBlankSibling</p>

<p style="margin-left:17%;">$prevnode =
$node&minus;&gt;previousNonBlankSibling();</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
previous non-blank sibling if any (a node is blank if it is
a Text or <small>CDATA</small> node consisting of whitespace
only). This method is not defined by <small>DOM.</small></p>

<p style="margin-left:11%;">hasChildNodes</p>

<p style="margin-left:17%;">$boolean =
$node&minus;&gt;hasChildNodes();</p>

<p style="margin-left:17%; margin-top: 1em">If the current
node has child nodes this function returns
<small>TRUE</small> (1), otherwise it returns
<small>FALSE</small> (0, not undef).</p>

<p style="margin-left:11%;">firstChild</p>

<p style="margin-left:17%;">$childnode =
$node&minus;&gt;firstChild;</p>

<p style="margin-left:17%; margin-top: 1em">If a node has
child nodes this function will return the first node in the
child list.</p>

<p style="margin-left:11%;">lastChild</p>

<p style="margin-left:17%;">$childnode =
$node&minus;&gt;lastChild;</p>

<p style="margin-left:17%; margin-top: 1em">If the $node
has child nodes this function returns the last child
node.</p>

<p style="margin-left:11%;">ownerDocument</p>

<p style="margin-left:17%;">$documentnode =
$node&minus;&gt;ownerDocument;</p>

<p style="margin-left:17%; margin-top: 1em">Through this
function it is always possible to access the document the
current node is bound to.</p>

<p style="margin-left:11%;">getOwner</p>

<p style="margin-left:17%;">$node =
$node&minus;&gt;getOwner;</p>

<p style="margin-left:17%; margin-top: 1em">This function
returns the node the current node is associated with. In
most cases this will be a document node or a document
fragment node.</p>

<p style="margin-left:11%;">setOwnerDocument</p>


<p style="margin-left:17%;">$node&minus;&gt;setOwnerDocument(
$doc );</p>

<p style="margin-left:17%; margin-top: 1em">This function
binds a node to another <small>DOM.</small> This method
unbinds the node first, if it is already bound to another
document.</p>

<p style="margin-left:17%; margin-top: 1em">This function
is the opposite calling of XML::LibXML::Document&rsquo;s
<b>adoptNode()</b> function. Because of this it has the same
limitations with Entity References as
<b>adoptNode()</b>.</p>

<p style="margin-left:11%;">insertBefore</p>

<p style="margin-left:17%;">$node&minus;&gt;insertBefore(
$newNode, $refNode );</p>

<p style="margin-left:17%; margin-top: 1em">The method
inserts $newNode before $refNode. If $refNode is undefined,
the newNode will be set as the new last child of the parent
node. This function differs from the <small>DOM L2</small>
specification, in the case, if the new node is not part of
the document, the node will be imported first,
automatically.</p>

<p style="margin-left:17%; margin-top: 1em">$refNode has to
be passed to the function even if it is undefined:</p>


<p style="margin-left:17%; margin-top: 1em">$node&minus;&gt;insertBefore(
$newNode, undef ); # the same as
$node&minus;&gt;appendChild( $newNode ); <br>
$node&minus;&gt;insertBefore( $newNode ); # wrong</p>

<p style="margin-left:17%; margin-top: 1em">Note, that the
reference node has to be a direct child of the node the
function is called on. Also, $newChild is not allowed to be
an ancestor of the new parent node.</p>

<p style="margin-left:11%;">insertAfter</p>

<p style="margin-left:17%;">$node&minus;&gt;insertAfter(
$newNode, $refNode );</p>

<p style="margin-left:17%; margin-top: 1em">The method
inserts $newNode after $refNode. If $refNode is undefined,
the newNode will be set as the new last child of the parent
node.</p>

<p style="margin-left:17%; margin-top: 1em">Note, that
$refNode has to be passed explicitly even if it is
undef.</p>

<p style="margin-left:11%;">findnodes</p>

<p style="margin-left:17%;">@nodes =
$node&minus;&gt;findnodes( $xpath_expression );</p>


<p style="margin-left:17%; margin-top: 1em"><i>findnodes</i>
evaluates the xpath expression (XPath 1.0) on the current
node and returns the resulting node set as an array. In
scalar context, returns an XML::LibXML::NodeList object.</p>

<p style="margin-left:17%; margin-top: 1em">The xpath
expression can be passed either as a string, or as a
XML::LibXML::XPathExpression object.</p>

<p style="margin-left:17%; margin-top: 1em"><i><small>NOTE
ON NAMESPACES AND XPATH</small></i> :</p>

<p style="margin-left:17%; margin-top: 1em">A common
mistake about XPath is to assume that node tests consisting
of an element name with no prefix match elements in the
default namespace. This assumption is wrong &minus; by XPath
specification, such node tests can only match elements that
are in no (i.e. null) namespace.</p>

<p style="margin-left:17%; margin-top: 1em">So, for
example, one cannot match the root element of an
<small>XHTML</small> document with
&quot;$node&minus;&gt;find('/html')&quot; since '/html'
would only match if the root element
&quot;&lt;html&gt;&quot; had no namespace, but all
<small>XHTML</small> elements belong to the namespace
http://www.w3.org/1999/xhtml. (Note that
&quot;xmlns=&quot;...&quot;&quot; namespace declarations can
also be specified in a <small>DTD,</small> which makes the
situation even worse, since the <small>XML</small> document
looks as if there was no default namespace).</p>

<p style="margin-left:17%; margin-top: 1em">There are
several possible ways to deal with namespaces in XPath:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>The recommended way is to use the
XML::LibXML::XPathContext module to define an explicit
context for XPath evaluation, in which a document
independent prefix-to-namespace mapping can be defined. For
example:</p> </td></tr>
</table>

<p style="margin-left:23%; margin-top: 1em">my $xpc =
XML::LibXML::XPathContext&minus;&gt;new; <br>
$xpc&minus;&gt;registerNs('x',
'http://www.w3.org/1999/xhtml'); <br>
$xpc&minus;&gt;find('/x:html',$node);</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p style="margin-top: 1em">Another possibility is to use
prefixes declared in the queried document (if known). If the
document declares a prefix for the namespace in question
(and the context node is in the scope of the declaration),
&quot;XML::LibXML&quot; allows you to use the prefix in the
XPath expression, e.g.:</p></td></tr>
</table>


<p style="margin-left:23%; margin-top: 1em">$node&minus;&gt;find('/x:html');</p>

<p style="margin-left:17%; margin-top: 1em">See also
XML::LibXML::XPathContext&minus;&gt;findnodes.</p>

<p style="margin-left:11%;">find</p>

<p style="margin-left:17%;">$result = $node&minus;&gt;find(
$xpath );</p>

<p style="margin-left:17%; margin-top: 1em"><i>find</i>
evaluates the XPath 1.0 expression using the current node as
the context of the expression, and returns the result
depending on what type of result the XPath expression had.
For example, the XPath &quot;1 * 3 + 52&quot; results in a
XML::LibXML::Number object being returned. Other expressions
might return an XML::LibXML::Boolean object, or an
XML::LibXML::Literal object (a string). Each of those
objects uses Perl&rsquo;s overload feature to &quot;do the
right thing&quot; in different contexts.</p>

<p style="margin-left:17%; margin-top: 1em">The xpath
expression can be passed either as a string, or as a
XML::LibXML::XPathExpression object.</p>

<p style="margin-left:17%; margin-top: 1em">See also
XML::LibXML::XPathContext&minus;&gt;find.</p>

<p style="margin-left:11%;">findvalue</p>

<p style="margin-left:17%;">print
$node&minus;&gt;findvalue( $xpath );</p>


<p style="margin-left:17%; margin-top: 1em"><i>findvalue</i>
is exactly equivalent to:</p>


<p style="margin-left:17%; margin-top: 1em">$node&minus;&gt;find(
$xpath )&minus;&gt;to_literal;</p>

<p style="margin-left:17%; margin-top: 1em">That is, it
returns the literal value of the results. This enables you
to ensure that you get a string back from your search,
allowing certain shortcuts. This could be used as the
equivalent of <small>XSLT</small> &rsquo;s
&lt;xsl:value&minus;of
select=&quot;some_xpath&quot;/&gt;.</p>

<p style="margin-left:17%; margin-top: 1em">See also
XML::LibXML::XPathContext&minus;&gt;findvalue.</p>

<p style="margin-left:17%; margin-top: 1em">The xpath
expression can be passed either as a string, or as a
XML::LibXML::XPathExpression object.</p>

<p style="margin-left:11%;">exists</p>

<p style="margin-left:17%;">$bool = $node&minus;&gt;exists(
$xpath_expression );</p>

<p style="margin-left:17%; margin-top: 1em">This method
behaves like <i>findnodes</i>, except that it only returns a
boolean value (1 if the expression matches a node, 0
otherwise) and may be faster than <i>findnodes</i>, because
the XPath evaluation may stop early on the first match (this
is true for libxml2 &gt;= 2.6.27).</p>

<p style="margin-left:17%; margin-top: 1em">For XPath
expressions that do not return node-set, the method returns
true if the returned value is a non-zero number or a
non-empty string.</p>

<p style="margin-left:11%;">childNodes</p>

<p style="margin-left:17%;">@childnodes =
$node&minus;&gt;childNodes();</p>


<p style="margin-left:17%; margin-top: 1em"><i>childNodes</i>
implements a more intuitive interface to the childnodes of
the current node. It enables you to pass all children
directly to a &quot;map&quot; or &quot;grep&quot;. If this
function is called in scalar context, a
XML::LibXML::NodeList object will be returned.</p>

<p style="margin-left:11%;">nonBlankChildNodes</p>

<p style="margin-left:17%;">@childnodes =
$node&minus;&gt;nonBlankChildNodes();</p>

<p style="margin-left:17%; margin-top: 1em">This is like
<i>childNodes</i>, but returns only non-blank nodes (where a
node is blank if it is a Text or <small>CDATA</small> node
consisting of whitespace only). This method is not defined
by <small>DOM.</small></p>

<p style="margin-left:11%;">toString</p>

<p style="margin-left:17%;">$xmlstring =
$node&minus;&gt;toString($format,$docencoding);</p>

<p style="margin-left:17%; margin-top: 1em">This method is
similar to the method &quot;toString&quot; of a
XML::LibXML::Document but for a single node. It returns a
string consisting of <small>XML</small> serialization of the
given node and all its descendants. Unlike
&quot;XML::LibXML::Document::toString&quot;, in this case
the resulting string is by default a character string (
<small>UTF&minus;8</small> encoded with <small>UTF8</small>
flag on). An optional flag $format controls indentation, as
in &quot;XML::LibXML::Document::toString&quot;. If the
second optional $docencoding flag is true, the result will
be a byte string in the document encoding (see
&quot;XML::LibXML::Document::actualEncoding&quot;).</p>

<p style="margin-left:11%;">toStringC14N</p>

<p style="margin-left:17%;">$c14nstring =
$node&minus;&gt;toStringC14N(); <br>
$c14nstring = $node&minus;&gt;toStringC14N($with_comments,
$xpath_expression , $xpath_context);</p>

<p style="margin-left:17%; margin-top: 1em">The function is
similar to <b>toString()</b>. Instead of simply serializing
the document tree, it transforms it as it is specified in
the <small>XML&minus;C14N</small> Specification (see
&lt;http://www.w3.org/TR/xml&minus;c14n&gt;). Such
transformation is known as canonization.</p>

<p style="margin-left:17%; margin-top: 1em">If
$with_comments is 0 or not defined, the result-document will
not contain any comments that exist in the original
document. To include comments into the canonized document,
$with_comments has to be set to 1.</p>

<p style="margin-left:17%; margin-top: 1em">The parameter
$xpath_expression defines the nodeset of nodes that should
be visible in the resulting document. This can be used to
filter out some nodes. One has to note, that only the nodes
that are part of the nodeset, will be included into the
result-document. Their child-nodes will not exist in the
resulting document, unless they are part of the nodeset
defined by the xpath expression.</p>

<p style="margin-left:17%; margin-top: 1em">If
$xpath_expression is omitted or empty, <b>toStringC14N()</b>
will include all nodes in the given sub-tree, using the
following XPath expressions: with comments</p>

<p style="margin-left:17%; margin-top: 1em">(. | .//node()
| .//@* | .//namespace::*)</p>

<p style="margin-left:17%; margin-top: 1em">and without
comments</p>

<p style="margin-left:17%; margin-top: 1em">(. | .//node()
| .//@* | .//namespace::*)[not(self::comment())]</p>

<p style="margin-left:17%; margin-top: 1em">An optional
parameter $xpath_context can be used to pass an
XML::LibXML::XPathContext object defining the context for
evaluation of $xpath_expression. This is useful for mapping
namespace prefixes used in the XPath expression to namespace
URIs. Note, however, that $node will be used as the context
node for the evaluation, not the context node of
$xpath_context!</p>

<p style="margin-left:11%;">toStringC14N_v1_1</p>

<p style="margin-left:17%;">$c14nstring =
$node&minus;&gt;toStringC14N_v1_1(); <br>
$c14nstring =
$node&minus;&gt;toStringC14N_v1_1($with_comments,
$xpath_expression , $xpath_context);</p>

<p style="margin-left:17%; margin-top: 1em">This function
behaves like <b>toStringC14N()</b> except that it uses the
&quot; <small>XML_C14N_1_1&quot;</small> constant for
canonicalising using the &quot;C14N 1.1 spec&quot;.</p>

<p style="margin-left:11%;">toStringEC14N</p>

<p style="margin-left:17%;">$ec14nstring =
$node&minus;&gt;toStringEC14N(); <br>
$ec14nstring = $node&minus;&gt;toStringEC14N($with_comments,
$xpath_expression, $inclusive_prefix_list); <br>
$ec14nstring = $node&minus;&gt;toStringEC14N($with_comments,
$xpath_expression, $xpath_context,
$inclusive_prefix_list);</p>

<p style="margin-left:17%; margin-top: 1em">The function is
similar to <b>toStringC14N()</b> but follows the
<small>XML&minus;EXC&minus;C14N</small> Specification (see
&lt;http://www.w3.org/TR/xml&minus;exc&minus;c14n&gt;) for
exclusive canonization of <small>XML.</small></p>

<p style="margin-left:17%; margin-top: 1em">The arguments
$with_comments, $xpath_expression, $xpath_context are as in
<b>toStringC14N()</b>. An <small>ARRAY</small> reference can
be passed as the last argument $inclusive_prefix_list,
listing namespace prefixes that are to be handled in the
manner described by the Canonical <small>XML</small>
Recommendation (i.e. preserved in the output even if the
namespace is not used). C.f. the spec for details.</p>

<p style="margin-left:11%;">serialize</p>

<p style="margin-left:17%;">$str =
$doc&minus;&gt;serialize($format);</p>

<p style="margin-left:17%; margin-top: 1em">An alias for
<b>toString()</b>. This function was name added to be more
consistent with libxml2.</p>

<p style="margin-left:11%;">serialize_c14n</p>

<p style="margin-left:17%;">An alias for
<b>toStringC14N()</b>.</p>

<p style="margin-left:11%;">serialize_exc_c14n</p>

<p style="margin-left:17%;">An alias for
<b>toStringEC14N()</b>.</p>

<p style="margin-left:11%;">localname</p>

<p style="margin-left:17%;">$localname =
$node&minus;&gt;localname;</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
local name of a tag. This is the part behind the colon.</p>

<p style="margin-left:11%;">prefix</p>

<p style="margin-left:17%;">$nameprefix =
$node&minus;&gt;prefix;</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
prefix of a tag. This is the part before the colon.</p>

<p style="margin-left:11%;">namespaceURI</p>

<p style="margin-left:17%;">$uri =
$node&minus;&gt;namespaceURI();</p>

<p style="margin-left:17%; margin-top: 1em">returns the
<small>URI</small> of the current namespace.</p>

<p style="margin-left:11%;">hasAttributes</p>

<p style="margin-left:17%;">$boolean =
$node&minus;&gt;hasAttributes();</p>

<p style="margin-left:17%; margin-top: 1em">returns 1 (
<small>TRUE</small> ) if the current node has any attributes
set, otherwise 0 ( <small>FALSE</small> ) is returned.</p>

<p style="margin-left:11%;">attributes</p>

<p style="margin-left:17%;">@attributelist =
$node&minus;&gt;attributes();</p>

<p style="margin-left:17%; margin-top: 1em">This function
returns all attributes and namespace declarations assigned
to the given node.</p>

<p style="margin-left:17%; margin-top: 1em">Because
XML::LibXML does not implement namespace declarations and
attributes the same way, it is required to test what kind of
node is handled while accessing the functions result.</p>

<p style="margin-left:17%; margin-top: 1em">If this
function is called in array context the attribute nodes are
returned as an array. In scalar context, the function will
return a XML::LibXML::NamedNodeMap object.</p>

<p style="margin-left:11%;">lookupNamespaceURI</p>

<p style="margin-left:17%;">$URI =
$node&minus;&gt;lookupNamespaceURI( $prefix );</p>

<p style="margin-left:17%; margin-top: 1em">Find a
namespace <small>URI</small> by its prefix starting at the
current node.</p>

<p style="margin-left:11%;">lookupNamespacePrefix</p>

<p style="margin-left:17%;">$prefix =
$node&minus;&gt;lookupNamespacePrefix( $URI );</p>

<p style="margin-left:17%; margin-top: 1em">Find a
namespace prefix by its <small>URI</small> starting at the
current node.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>NOTE</small></i>
Only the namespace URIs are meant to be unique. The prefix
is only document related. Also the document might have more
than a single prefix defined for a namespace.</p>

<p style="margin-left:11%;">normalize</p>

<p style="margin-left:17%;">$node&minus;&gt;normalize;</p>

<p style="margin-left:17%; margin-top: 1em">This function
normalizes adjacent text nodes. This function is not as
strict as libxml2&rsquo;s <b>xmlTextMerge()</b> function,
since it will not free a node that is still referenced by
the perl layer.</p>

<p style="margin-left:11%;">getNamespaces</p>

<p style="margin-left:17%;">@nslist =
$node&minus;&gt;getNamespaces;</p>

<p style="margin-left:17%; margin-top: 1em">If a node has
any namespaces defined, this function will return these
namespaces. Note, that this will not return all namespaces
that are in scope, but only the ones declared explicitly for
that node.</p>

<p style="margin-left:17%; margin-top: 1em">Although
getNamespaces is available for all nodes, it only makes
sense if used with element nodes.</p>

<p style="margin-left:11%;">removeChildNodes</p>


<p style="margin-left:17%;">$node&minus;&gt;removeChildNodes();</p>

<p style="margin-left:17%; margin-top: 1em">This function
is not specified for any <small>DOM</small> level: It
removes all childnodes from a node in a single step. Other
than the libxml2 function itself (xmlFreeNodeList), this
function will not immediately remove the nodes from the
memory. This saves one from getting memory violations, if
there are nodes still referred to from the Perl level.</p>

<p style="margin-left:11%;">baseURI ()</p>

<p style="margin-left:17%;">$strURI =
$node&minus;&gt;baseURI();</p>

<p style="margin-left:17%; margin-top: 1em">Searches for
the base <small>URL</small> of the node. The method should
work on both <small>XML</small> and <small>HTML</small>
documents even if base mechanisms for these are completely
different. It returns the base as defined in <small>RFC
2396</small> sections &quot;5.1.1. Base <small>URI</small>
within Document Content&quot; and &quot;5.1.2. Base
<small>URI</small> from the Encapsulating Entity&quot;.
However it does not return the document base (5.1.3), use
method &quot;URI&quot; of &quot;XML::LibXML::Document&quot;
for this.</p>

<p style="margin-left:11%;">setBaseURI ($strURI)</p>


<p style="margin-left:17%;">$node&minus;&gt;setBaseURI($strURI);</p>

<p style="margin-left:17%; margin-top: 1em">This method
only does something useful for an element node in an
<small>XML</small> document. It sets the xml:base attribute
on the node to $strURI, which effectively sets the base
<small>URI</small> of the node to the same value.</p>

<p style="margin-left:17%; margin-top: 1em">Note: For
<small>HTML</small> documents this behaves as if the
document was <small>XML</small> which may not be desired,
since it does not effectively set the base
<small>URI</small> of the node. See <small>RFC 2396</small>
appendix D for an example of how base <small>URI</small> can
be specified in <small>HTML.</small></p>

<p style="margin-left:11%;">nodePath</p>


<p style="margin-left:17%;">$node&minus;&gt;nodePath();</p>

<p style="margin-left:17%; margin-top: 1em">This function
is not specified for any <small>DOM</small> level: It
returns a canonical structure based XPath for a given
node.</p>

<p style="margin-left:11%;">line_number</p>

<p style="margin-left:17%;">$lineno =
$node&minus;&gt;line_number();</p>

<p style="margin-left:17%; margin-top: 1em">This function
returns the line number where the tag was found during
parsing. If a node is added to the document the line number
is 0. Problems may occur, if a node from one document is
passed to another one.</p>


<p style="margin-left:17%; margin-top: 1em"><small>IMPORTANT:</small>
Due to limitations in the libxml2 library line numbers
greater than 65535 will be returned as 65535. Please see
&lt;http://bugzilla.gnome.org/show_bug.cgi?id=325533&gt; for
more details.</p>

<p style="margin-left:17%; margin-top: 1em">Note:
<b>line_number()</b> is special to XML::LibXML and not part
of the <small>DOM</small> specification.</p>

<p style="margin-left:17%; margin-top: 1em">If the
line_numbers flag of the parser was not activated before
parsing, <b>line_number()</b> will always return 0.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Matt Sergeant,
Christian Glahn, Petr Pajas</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">2.0208</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">2001&minus;2007,
AxKit.com Ltd.</p>


<p style="margin-left:11%; margin-top: 1em">2002&minus;2006,
Christian Glahn.</p>


<p style="margin-left:11%; margin-top: 1em">2006&minus;2009,
Petr Pajas.</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
