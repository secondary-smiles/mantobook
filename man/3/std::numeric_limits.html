<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:13 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::numeric_limits&lt; _Tp &gt;</title>

</head>
<body>
<h1>std::numeric_limits</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::numeric_limits&lt;
_Tp &gt; &minus; Properties of fundamental types.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::__numeric_limits_base</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Inherited by
std::numeric_limits&lt; const _Tp &gt;,
std::numeric_limits&lt; const volatile _Tp &gt;, and
std::numeric_limits&lt; volatile _Tp &gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Public Member Functions</b></p>

<p style="margin-left:17%;">static constexpr _Tp
<b>denorm_min</b> () noexcept <br>
static constexpr _Tp <b>epsilon</b> () noexcept <br>
static constexpr _Tp <b>infinity</b> () noexcept <br>
static constexpr _Tp <b>lowest</b> () noexcept <br>
static constexpr _Tp <b>max</b> () noexcept <br>
static constexpr _Tp <b>min</b> () noexcept <br>
static constexpr _Tp <b>quiet_NaN</b> () noexcept <br>
static constexpr _Tp <b>round_error</b> () noexcept <br>
static constexpr _Tp <b>signaling_NaN</b> () noexcept</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Public Attributes</b></p>

<p style="margin-left:17%;">static constexpr int
<b>digits</b> <br>
static constexpr int <b>digits10</b> <br>
static constexpr <b>float_denorm_style has_denorm</b> <br>
static constexpr bool <b>has_denorm_loss</b> <br>
static constexpr bool <b>has_infinity</b> <br>
static constexpr bool <b>has_quiet_NaN</b> <br>
static constexpr bool <b>has_signaling_NaN</b> <br>
static constexpr bool <b>is_bounded</b> <br>
static constexpr bool <b>is_exact</b> <br>
static constexpr bool <b>is_iec559</b> <br>
static constexpr bool <b>is_integer</b> <br>
static constexpr bool <b>is_modulo</b> <br>
static constexpr bool <b>is_signed</b> <br>
static constexpr bool <b>is_specialized</b> <br>
static constexpr int <b>max_digits10</b> <br>
static constexpr int <b>max_exponent</b> <br>
static constexpr int <b>max_exponent10</b> <br>
static constexpr int <b>min_exponent</b> <br>
static constexpr int <b>min_exponent10</b> <br>
static constexpr int <b>radix</b> <br>
static constexpr <b>float_round_style round_style</b> <br>
static constexpr bool <b>tinyness_before</b> <br>
static constexpr bool <b>traps</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt;</b> <br>
struct std::numeric_limits&lt; _Tp &gt;&quot;Properties of
fundamental types.</p>

<p style="margin-left:11%; margin-top: 1em">This class
allows a program to obtain information about the
representation of a fundamental type on a given platform.
For non-fundamental types, the functions will return 0 and
the data members will all be <tt>false</tt>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::denorm_min ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The minimum positive denormalized value. For types where
<tt>has_denorm</tt> is false, this is the minimum positive
normalized value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::epsilon ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The <i>machine epsilon:</i> the difference between 1 and the
least value greater than 1 that is representable.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::generate_canonical()</b>,
<b>std::binomial_distribution&lt; _IntType
&gt;::operator()()</b>, <b>std::poisson_distribution&lt;
_IntType &gt;::operator()()</b>, and
<b>std::operator&lt;&lt;()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::infinity ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The representation of positive infinity, if
<tt>has_infinity</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::lowest ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
A finite value x such that there is no other finite value y
where y &lt; x.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::normal_distribution&lt; _RealType &gt;::min()</b>,
<b>std::cauchy_distribution&lt; _RealType &gt;::min()</b>,
<b>std::student_t_distribution&lt; _RealType
&gt;::min()</b>, and <b>std::extreme_value_distribution&lt;
_RealType &gt;::min()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::max ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The maximum finite value.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::normal_distribution&lt; _RealType &gt;::max()</b>,
<b>std::lognormal_distribution&lt; _RealType
&gt;::max()</b>, <b>std::gamma_distribution&lt; _RealType
&gt;::max()</b>, <b>std::chi_squared_distribution&lt;
_RealType &gt;::max()</b>, <b>std::cauchy_distribution&lt;
_RealType &gt;::max()</b>, <b>std::fisher_f_distribution&lt;
_RealType &gt;::max()</b>,
<b>std::student_t_distribution&lt; _RealType
&gt;::max()</b>, <b>std::bernoulli_distribution::max()</b>,
<b>std::geometric_distribution&lt; _IntType &gt;::max()</b>,
<b>std::negative_binomial_distribution&lt; _IntType
&gt;::max()</b>, <b>std::poisson_distribution&lt; _IntType
&gt;::max()</b>, <b>std::exponential_distribution&lt;
_RealType &gt;::max()</b>, <b>std::weibull_distribution&lt;
_RealType &gt;::max()</b>,
<b>std::extreme_value_distribution&lt; _RealType
&gt;::max()</b>, <b>std::tr2::dynamic_bitset&lt; _WordT,
_Alloc &gt;::max_size()</b>,
<b>std::independent_bits_engine&lt; _RandomNumberEngine,
__w, _UIntType &gt;::operator()()</b>,
<b>std::binomial_distribution&lt; _IntType
&gt;::operator()()</b>, <b>std::poisson_distribution&lt;
_IntType &gt;::operator()()</b>, and
<b>std::operator&lt;&lt;()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::min ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The minimum finite value, or for floating types with
denormalization, the minimum positive normalized value.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::bernoulli_distribution::min()</b>, and
<b>std::independent_bits_engine&lt; _RandomNumberEngine,
__w, _UIntType &gt;::operator()()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::quiet_NaN ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The representation of a quiet Not a Number, if
<tt>has_quiet_NaN</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::round_error ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The maximum rounding error measurement (see LIA-1).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; static constexpr _Tp std::numeric_limits&lt; _Tp
&gt;::signaling_NaN ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
The representation of a signaling Not a Number, if
<tt>has_signaling_NaN</tt>.</p>

<h2>Member Data Documentation
<a name="Member Data Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>constexpr
int std::__numeric_limits_base::digits</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
The number of <tt>radix</tt> digits that be represented
without change: for integer types, the number of non-sign
bits in the mantissa; for floating types, the number of
<tt>radix</tt> digits in the mantissa.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
int std::__numeric_limits_base::digits10</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
The number of base 10 digits that can be represented without
change.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
float_denorm_style
std::__numeric_limits_base::has_denorm</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
See std::float_denorm_style for more information.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::has_denorm_loss</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if loss of accuracy is detected as a denormalization
loss, rather than as an inexact result.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::has_infinity</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if the type has a representation for positive
infinity.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::has_quiet_NaN</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if the type has a representation for a quiet
(non-signaling) Not a Number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::has_signaling_NaN</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if the type has a representation for a signaling Not a
Number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::is_bounded</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if the set of values representable by the type is
finite. All built-in types are bounded, this member would be
false for arbitrary precision types.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::is_exact</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if the type uses an exact representation. All integer
types are exact, but not all exact types are integer. For
example, rational and fixed-exponent representations are
exact but not integer.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::is_iec559</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if-and-only-if the type adheres to the IEC 559
standard, also known as IEEE 754. (Only makes sense for
floating point types.)</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::is_integer</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if the type is integer.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::is_modulo</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if the type is <i>modulo</i>. A type is modulo if, for
any operation involving +, -, or * on values of that type
whose result would fall outside the range [min(),max()], the
value returned differs from the true value by an integer
multiple of max() - min() + 1. On most machines, this is
false for floating types, true for unsigned integers, and
true for signed integers. See PR22200 about signed
integers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::is_signed</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if the type is signed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::is_specialized</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
This will be true for all fundamental types (which have
specializations), and false for everything else.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
int std::__numeric_limits_base::max_digits10</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
The number of base 10 digits required to ensure that values
which differ are always differentiated.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
int std::__numeric_limits_base::max_exponent</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
The maximum positive integer such that <tt>radix</tt> raised
to the power of (one less than that integer) is a
representable finite floating point number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
int std::__numeric_limits_base::max_exponent10</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
The maximum positive integer such that 10 raised to that
power is in the range of representable finite floating point
numbers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
int std::__numeric_limits_base::min_exponent</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
The minimum negative integer such that <tt>radix</tt> raised
to the power of (one less than that integer) is a normalized
floating point number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
int std::__numeric_limits_base::min_exponent10</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
The minimum negative integer such that 10 raised to that
power is in the range of normalized floating point
numbers.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
int std::__numeric_limits_base::radix</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
For integer types, specifies the base of the representation.
For floating types, specifies the base of the exponent
representation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
float_round_style
std::__numeric_limits_base::round_style</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
See std::float_round_style for more information. This is
only meaningful for floating types; integer types will all
be round_toward_zero.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::tinyness_before</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if tininess is detected before rounding. (see IEC
559)</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
bool std::__numeric_limits_base::traps</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[inherited]</tt> <br>
True if trapping is implemented for this type.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
