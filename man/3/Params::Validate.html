<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:46 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Params::Validate</title>

</head>
<body>
<h1>Params::Validate</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Params::Validate
&minus; Validate method/function parameters</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">version
1.31</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use
Params::Validate qw(:all); <br>
# takes named params (hash or hashref) <br>
sub foo { <br>
validate( <br>
@_, { <br>
foo =&gt; 1, # mandatory <br>
bar =&gt; 0, # optional <br>
} <br>
); <br>
} <br>
# takes positional params <br>
sub bar { <br>
# first two are mandatory, third is optional <br>
validate_pos( @_, 1, 1, 0 ); <br>
} <br>
sub foo2 { <br>
validate( <br>
@_, { <br>
foo =&gt; <br>
# specify a type <br>
{ type =&gt; ARRAYREF }, <br>
bar =&gt; <br>
# specify an interface <br>
{ can =&gt; [ 'print', 'flush', 'frobnicate' ] }, <br>
baz =&gt; { <br>
type =&gt; SCALAR, # a scalar ... <br>
# ... that is a plain integer ... <br>
regex =&gt; qr/^\d+$/, <br>
callbacks =&gt; { # ... and smaller than 90 <br>
'less than 90' =&gt; sub { shift() &lt; 90 }, <br>
}, <br>
} <br>
} <br>
); <br>
} <br>
sub callback_with_custom_error { <br>
validate( <br>
@_, <br>
{ <br>
foo =&gt; { <br>
callbacks =&gt; { <br>
'is an integer' =&gt; sub { <br>
return 1 if $_[0] =~ /^&minus;?[1&minus;9][0&minus;9]*$/;
<br>
die &quot;$_[0] is not a valid integer value&quot;; <br>
}, <br>
}, <br>
} <br>
} <br>
); <br>
} <br>
sub with_defaults { <br>
my %p = validate( <br>
@_, { <br>
# required <br>
foo =&gt; 1, <br>
# $p{bar} will be 99 if bar is not given. bar is now <br>
# optional. <br>
bar =&gt; { default =&gt; 99 } <br>
} <br>
); <br>
} <br>
sub pos_with_defaults { <br>
my @p = validate_pos( @_, 1, { default =&gt; 99 } ); <br>
} <br>
sub sets_options_on_call { <br>
my %p = validate_with( <br>
params =&gt; \@_, <br>
spec =&gt; { foo =&gt; { type =&gt; SCALAR, default =&gt; 2
} }, <br>
normalize_keys =&gt; sub { $_[0] =~ s/^&minus;//; lc $_[0]
}, <br>
); <br>
}</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>I would
recommend you consider using Params::ValidationCompiler
instead. That module, despite being pure Perl, is</b>
<b><i>significantly</i></b> <b>faster than this one, at the
cost of having to adopt a type system such as Specio,
Type::Tiny, or the one shipped with Moose</b>.</p>

<p style="margin-left:11%; margin-top: 1em">This module
allows you to validate method or function call parameters to
an arbitrary level of specificity. At the simplest level, it
is capable of validating the required parameters were given
and that no unspecified additional parameters were passed
in.</p>

<p style="margin-left:11%; margin-top: 1em">It is also
capable of determining that a parameter is of a specific
type, that it is an object of a certain class hierarchy,
that it possesses certain methods, or applying validation
callbacks to arguments.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>EXPORT</small></b>
<br>
The module always exports the &quot;validate()&quot; and
&quot;validate_pos()&quot; functions.</p>

<p style="margin-left:11%; margin-top: 1em">It also has an
additional function available for export,
&quot;validate_with&quot;, which can be used to validate any
type of parameters, and set various options on a
per-invocation basis.</p>

<p style="margin-left:11%; margin-top: 1em">In addition, it
can export the following constants, which are used as part
of the type checking. These are &quot;SCALAR&quot;,
&quot;ARRAYREF&quot;, &quot;HASHREF&quot;,
&quot;CODEREF&quot;, &quot;GLOB&quot;, &quot;GLOBREF&quot;,
and &quot;SCALARREF&quot;, &quot;UNDEF&quot;,
&quot;OBJECT&quot;, &quot;BOOLEAN&quot;, and
&quot;HANDLE&quot;. These are explained in the section on
Type Validation.</p>

<p style="margin-left:11%; margin-top: 1em">The constants
are available via the export tag &quot;:types&quot;. There
is also an &quot;:all&quot; tag which includes all of the
constants as well as the &quot;validation_options()&quot;
function.</p>

<h2>PARAMETER VALIDATION
<a name="PARAMETER VALIDATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The validation
mechanisms provided by this module can handle both named or
positional parameters. For the most part, the same features
are available for each. The biggest difference is the way
that the validation specification is given to the relevant
subroutine. The other difference is in the error messages
produced when validation checks fail.</p>

<p style="margin-left:11%; margin-top: 1em">When handling
named parameters, the module will accept either a hash or a
hash reference.</p>

<p style="margin-left:11%; margin-top: 1em">Subroutines
expecting named parameters should call the
&quot;validate()&quot; subroutine like this:</p>

<p style="margin-left:11%; margin-top: 1em">validate( <br>
@_, { <br>
parameter1 =&gt; validation spec, <br>
parameter2 =&gt; validation spec, <br>
... <br>
} <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">Subroutines
expecting positional parameters should call the
&quot;validate_pos()&quot; subroutine like this:</p>

<p style="margin-left:11%; margin-top: 1em">validate_pos(
@_, { validation spec }, { validation spec } );</p>


<p style="margin-left:11%; margin-top: 1em"><b>Mandatory/Optional
Parameters</b> <br>
If you just want to specify that some parameters are
mandatory and others are optional, this can be done very
simply.</p>

<p style="margin-left:11%; margin-top: 1em">For a
subroutine expecting named parameters, you would do
this:</p>

<p style="margin-left:11%; margin-top: 1em">validate( @_, {
foo =&gt; 1, bar =&gt; 1, baz =&gt; 0 } );</p>

<p style="margin-left:11%; margin-top: 1em">This says that
the &quot;foo&quot; and &quot;bar&quot; parameters are
mandatory and that the &quot;baz&quot; parameter is
optional. The presence of any other parameters will cause an
error.</p>

<p style="margin-left:11%; margin-top: 1em">For a
subroutine expecting positional parameters, you would do
this:</p>

<p style="margin-left:11%; margin-top: 1em">validate_pos(
@_, 1, 1, 0, 0 );</p>

<p style="margin-left:11%; margin-top: 1em">This says that
you expect at least 2 and no more than 4 parameters. If you
have a subroutine that has a minimum number of parameters
but can take any maximum number, you can do this:</p>

<p style="margin-left:11%; margin-top: 1em">validate_pos(
@_, 1, 1, (0) x (@_ &minus; 2) );</p>

<p style="margin-left:11%; margin-top: 1em">This will
always be valid as long as at least two parameters are
given. A similar construct could be used for the more
complex validation parameters described further on.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that this:</p>

<p style="margin-left:11%; margin-top: 1em">validate_pos(
@_, 1, 1, 0, 1, 1 );</p>

<p style="margin-left:11%; margin-top: 1em">makes
absolutely no sense, so don&rsquo;t do it. Any zeros must
come at the end of the validation specification.</p>

<p style="margin-left:11%; margin-top: 1em">In addition, if
you specify that a parameter can have a default, then it is
considered optional.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Type
Validation</b> <br>
This module supports the following simple types, which can
be exported as constants:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p><small>SCALAR</small></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A scalar which
is not a reference, such as 10 or 'hello'. A parameter that
is undefined is <b>not</b> treated as a scalar. If you want
to allow undefined values, you will have to specify
&quot;SCALAR | UNDEF&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="12%">


<p style="margin-top: 1em"><small>ARRAYREF</small></p></td>
<td width="71%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">An array
reference such as &quot;[1, 2, 3]&quot; or
&quot;\@foo&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>HASHREF</small></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A hash
reference such as &quot;{ a =&gt; 1, b =&gt; 2 }&quot; or
&quot;\%bar&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>CODEREF</small></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A subroutine
reference such as &quot;\&amp;foo_sub&quot; or &quot;sub {
print &quot;hello&quot; }&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em"><small>GLOB</small></p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This one is a
bit tricky. A glob would be something like *FOO, but not
&quot;\*FOO&quot;, which is a glob reference. It should be
noted that this trick:</p>

<p style="margin-left:17%; margin-top: 1em">my $fh = do {
local *FH; };</p>

<p style="margin-left:17%; margin-top: 1em">makes $fh a
glob, not a glob reference. On the other hand, the return
value from &quot;Symbol::gensym&quot; is a glob reference.
Either can be used as a file or directory handle.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>GLOBREF</small></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A glob
reference such as &quot;\*FOO&quot;. See the
<small>GLOB</small> entry above for more details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em"><small>SCALARREF</small></p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A reference to
a scalar such as &quot;\$x&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em"><small>UNDEF</small></p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">An undefined
value</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><small>OBJECT</small></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A blessed
reference.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em"><small>BOOLEAN</small></p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This is a
special option, and is just a shortcut for &quot;UNDEF |
SCALAR&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em"><small>HANDLE</small></p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option is
also special, and is just a shortcut for &quot;GLOB |
GLOBREF&quot;. However, it seems likely that most people
interested in either globs or glob references are likely to
really be interested in whether the parameter in question
could be a valid file or directory handle.</p>

<p style="margin-left:11%; margin-top: 1em">To specify that
a parameter must be of a given type when using named
parameters, do this:</p>

<p style="margin-left:11%; margin-top: 1em">validate( <br>
@_, { <br>
foo =&gt; { type =&gt; SCALAR }, <br>
bar =&gt; { type =&gt; HASHREF } <br>
} <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">If a parameter
can be of more than one type, just use the bitwise or
(&quot;|&quot;) operator to combine them.</p>

<p style="margin-left:11%; margin-top: 1em">validate( @_, {
foo =&gt; { type =&gt; GLOB | GLOBREF } );</p>

<p style="margin-left:11%; margin-top: 1em">For positional
parameters, this can be specified as follows:</p>

<p style="margin-left:11%; margin-top: 1em">validate_pos(
@_, { type =&gt; SCALAR | ARRAYREF }, { type =&gt; CODEREF }
);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Interface
Validation</b> <br>
To specify that a parameter is expected to have a certain
set of methods, we can do the following:</p>

<p style="margin-left:11%; margin-top: 1em">validate( <br>
@_, { <br>
foo =&gt; <br>
# just has to be able to &minus;&gt;bar <br>
{ can =&gt; 'bar' } <br>
} <br>
); <br>
... or ... <br>
validate( <br>
@_, { <br>
foo =&gt; <br>
# must be able to &minus;&gt;bar and &minus;&gt;print <br>
{ can =&gt; [qw( bar print )] } <br>
} <br>
);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Class
Validation</b> <br>
A word of warning. When constructing your external
interfaces, it is probably better to specify what methods
you expect an object to have rather than what class it
should be of (or a child of). This will make your
<small>API</small> much more flexible.</p>

<p style="margin-left:11%; margin-top: 1em">With that said,
if you want to validate that an incoming parameter belongs
to a class (or child class) or classes, do:</p>

<p style="margin-left:11%; margin-top: 1em">validate( <br>
@_, <br>
{ foo =&gt; { isa =&gt; 'My::Frobnicator' } } <br>
); <br>
... or ... <br>
validate( <br>
@_, <br>
# must be both, not either! <br>
{ foo =&gt; { isa =&gt; [qw( My::Frobnicator IO::Handle )] }
} <br>
);</p>

<p style="margin-left:11%; margin-top: 1em"><b>Regex
Validation</b> <br>
If you want to specify that a given parameter must match a
specific regular expression, this can be done with
&quot;regex&quot; spec key. For example:</p>

<p style="margin-left:11%; margin-top: 1em">validate( <br>
@_, <br>
{ foo =&gt; { regex =&gt; qr/^\d+$/ } } <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">The value of
the &quot;regex&quot; key may be either a string or a
pre-compiled regex created via &quot;qr&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If the value
being checked against a regex is undefined, the regex is
explicitly checked against the empty string (&rsquo;&rsquo;)
instead, in order to avoid &quot;Use of uninitialized
value&quot; warnings.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;Regexp::Common&quot; module on <small>CPAN</small> is
an excellent source of regular expressions suitable for
validating input.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Callback
Validation</b> <br>
If none of the above are enough, it is possible to pass in
one or more callbacks to validate the parameter. The
callback will be given the <b>value</b> of the parameter as
its first argument. Its second argument will be all the
parameters, as a reference to either a hash or array.
Callbacks are specified as hash reference. The key is an id
for the callback (used in error messages) and the value is a
subroutine reference, such as:</p>

<p style="margin-left:11%; margin-top: 1em">validate( <br>
@_, <br>
{ <br>
foo =&gt; { <br>
callbacks =&gt; { <br>
'smaller than a breadbox' =&gt; sub { shift() &lt; $breadbox
}, <br>
'green or blue' =&gt; sub { <br>
return 1 if $_[0] eq 'green' || $_[0] eq 'blue'; <br>
die &quot;$_[0] is not green or blue!&quot;; <br>
} <br>
} <br>
} <br>
} <br>
); <br>
validate( <br>
@_, { <br>
foo =&gt; { <br>
callbacks =&gt; { <br>
'bigger than baz' =&gt; sub { $_[0] &gt;
$_[1]&minus;&gt;{baz} } <br>
} <br>
} <br>
} <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">The callback
should return a true value if the value is valid. If not, it
can return false or die. If you return false, a generic
error message will be thrown by
&quot;Params::Validate&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If your
callback dies instead you can provide a custom error
message. If the callback dies with a plain string, this
string will be appended to an exception message generated by
&quot;Params::Validate&quot;. If the callback dies with a
reference (blessed or not), then this will be rethrown as-is
by &quot;Params::Validate&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Untainting</b>
<br>
If you want values untainted, set the &quot;untaint&quot;
key in a spec hashref to a true value, like this:</p>

<p style="margin-left:11%; margin-top: 1em">my %p =
validate( <br>
@_, { <br>
foo =&gt; { type =&gt; SCALAR, untaint =&gt; 1 }, <br>
bar =&gt; { type =&gt; ARRAYREF } <br>
} <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">This will
untaint the &quot;foo&quot; parameter if the parameters are
valid.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
untainting is only done if <i>all parameters</i> are valid.
Also, only the return values are untainted, not the original
values passed into the validation function.</p>

<p style="margin-left:11%; margin-top: 1em">Asking for
untainting of a reference value will not do anything, as
&quot;Params::Validate&quot; will only attempt to untaint
the reference itself.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Mandatory/Optional
Revisited</b> <br>
If you want to specify something such as type or interface,
plus the fact that a parameter can be optional, do this:</p>

<p style="margin-left:11%; margin-top: 1em">validate( <br>
@_, { <br>
foo =&gt; { type =&gt; SCALAR }, <br>
bar =&gt; { type =&gt; ARRAYREF, optional =&gt; 1 } <br>
} <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">or this for
positional parameters:</p>

<p style="margin-left:11%; margin-top: 1em">validate_pos(
<br>
@_, <br>
{ type =&gt; SCALAR }, <br>
{ type =&gt; ARRAYREF, optional =&gt; 1 } <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">By default,
parameters are assumed to be mandatory unless specified as
optional.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Dependencies</b>
<br>
It also possible to specify that a given optional parameter
depends on the presence of one or more other optional
parameters.</p>

<p style="margin-left:11%; margin-top: 1em">validate( <br>
@_, { <br>
cc_number =&gt; { <br>
type =&gt; SCALAR, <br>
optional =&gt; 1, <br>
depends =&gt; [ 'cc_expiration', 'cc_holder_name' ], <br>
}, <br>
cc_expiration =&gt; { type =&gt; SCALAR, optional =&gt; 1 },
<br>
cc_holder_name =&gt; { type =&gt; SCALAR, optional =&gt; 1
}, <br>
} <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">In this case,
&quot;cc_number&quot;, &quot;cc_expiration&quot;, and
&quot;cc_holder_name&quot; are all optional. However, if
&quot;cc_number&quot; is provided, then
&quot;cc_expiration&quot; and &quot;cc_holder_name&quot;
must be provided as well.</p>

<p style="margin-left:11%; margin-top: 1em">This allows you
to group together sets of parameters that all must be
provided together.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;validate_pos()&quot; version of dependencies is
slightly different, in that you can only depend on one other
parameter. Also, if for example, the second parameter 2
depends on the fourth parameter, then it implies a
dependency on the third parameter as well. This is because
if the fourth parameter is required, then the user must also
provide a third parameter so that there can be four
parameters in total.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Params::Validate&quot;
will die if you try to depend on a parameter not declared as
part of your parameter specification.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Specifying
defaults</b> <br>
If the &quot;validate()&quot; or &quot;validate_pos()&quot;
functions are called in a list context, they will return a
hash or containing the original parameters plus defaults as
indicated by the validation spec.</p>

<p style="margin-left:11%; margin-top: 1em">If the function
is not called in a list context, providing a default in the
validation spec still indicates that the parameter is
optional.</p>

<p style="margin-left:11%; margin-top: 1em">The hash or
array returned from the function will always be a copy of
the original parameters, in order to leave @_ untouched for
the calling function.</p>

<p style="margin-left:11%; margin-top: 1em">Simple examples
of defaults would be:</p>

<p style="margin-left:11%; margin-top: 1em">my %p =
validate( @_, { foo =&gt; 1, bar =&gt; { default =&gt; 99 }
} ); <br>
my @p = validate_pos( @_, 1, { default =&gt; 99 } );</p>

<p style="margin-left:11%; margin-top: 1em">In scalar
context, a hash reference or array reference will be
returned, as appropriate.</p>

<h2>USAGE NOTES
<a name="USAGE NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Validation
failure</b> <br>
By default, when validation fails
&quot;Params::Validate&quot; calls
&quot;Carp::confess()&quot;. This can be overridden by
setting the &quot;on_fail&quot; option, which is described
in the &quot; <small>GLOBAL&quot; OPTIONS</small>
section.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Method
calls</b> <br>
When using this module to validate the parameters passed to
a method call, you will probably want to remove the
class/object from the parameter list <b>before</b> calling
&quot;validate()&quot; or &quot;validate_pos()&quot;. If
your method expects named parameters, then this is necessary
for the &quot;validate()&quot; function to actually work,
otherwise @_ will not be usable as a hash, because it will
first have your object (or class) <b>followed</b> by a set
of keys and values.</p>

<p style="margin-left:11%; margin-top: 1em">Thus the
idiomatic usage of &quot;validate()&quot; in a method call
will look something like this:</p>

<p style="margin-left:11%; margin-top: 1em">sub method {
<br>
my $self = shift; <br>
my %params = validate( <br>
@_, { <br>
foo =&gt; 1, <br>
bar =&gt; { type =&gt; ARRAYREF }, <br>
} <br>
); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em"><b>Speeding Up
Validation</b> <br>
In most cases, the validation spec will remain the same for
each call to a subroutine. In that case, you can speed up
validation by defining the validation spec just once, rather
than on each call to the subroutine:</p>

<p style="margin-left:11%; margin-top: 1em">my %spec = (
... ); <br>
sub foo { <br>
my %params = validate( @_, \%spec ); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">You can also
use the &quot;state&quot; feature to do this:</p>

<p style="margin-left:11%; margin-top: 1em">use feature
'state'; <br>
sub foo { <br>
state $spec = { ... }; <br>
my %params = validate( @_, $spec ); <br>
}</p>

<h2>&quot;GLOBAL&quot; OPTIONS
<a name="&quot;GLOBAL&quot; OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Because the
<small>API</small> for the &quot;validate()&quot; and
&quot;validate_pos()&quot; functions does not make it
possible to specify any options other than the validation
spec, it is possible to set some options as
pseudo&minus;&rsquo;globals&rsquo;. These allow you to
specify such things as whether or not the validation of
named parameters should be case sensitive, for one
example.</p>

<p style="margin-left:11%; margin-top: 1em">These options
are called pseudo&minus;&rsquo;globals&rsquo; because these
settings are <b>only applied to calls originating from the
package that set the options</b>.</p>

<p style="margin-left:11%; margin-top: 1em">In other words,
if I am in package &quot;Foo&quot; and I call
&quot;validation_options()&quot;, those options are only in
effect when I call &quot;validate()&quot; from package
&quot;Foo&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">While this is
quite different from how most other modules operate, I feel
that this is necessary in able to make it possible for one
module/application to use Params::Validate while still using
other modules that also use Params::Validate, perhaps with
different options set.</p>

<p style="margin-left:11%; margin-top: 1em">The downside to
this is that if you are writing an app with a standard
calling style for all functions, and your app has ten
modules, <b>each module must include a call to
&quot;validation_options()&quot;</b>. You could of course
write a module that all your modules use which uses various
trickery to do this when imported.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Options</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="41%">


<p style="margin-top: 1em">normalize_keys =&gt;
$callback</p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option is
only relevant when dealing with named parameters.</p>

<p style="margin-left:17%; margin-top: 1em">This callback
will be used to transform the hash keys of both the
parameters and the parameter spec when
&quot;validate()&quot; or &quot;validate_with()&quot; are
called.</p>

<p style="margin-left:17%; margin-top: 1em">Any alterations
made by this callback will be reflected in the parameter
hash that is returned by the validation function. For
example:</p>

<p style="margin-left:17%; margin-top: 1em">sub foo { <br>
return validate_with( <br>
params =&gt; \@_, <br>
spec =&gt; { foo =&gt; { type =&gt; SCALAR } }, <br>
normalize_keys =&gt; <br>
sub { my $k = shift; $k =~ s/^&minus;//; return uc $k },
<br>
); <br>
} <br>
%p = foo( foo =&gt; 20 ); <br>
# $p{FOO} is now 20 <br>
%p = foo( &minus;fOo =&gt; 50 ); <br>
# $p{FOO} is now 50</p>

<p style="margin-left:17%; margin-top: 1em">The callback
must return a defined value.</p>

<p style="margin-left:17%; margin-top: 1em">If a callback
is given then the deprecated &quot;ignore_case&quot; and
&quot;strip_leading&quot; options are ignored.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">allow_extra =&gt; $boolean</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If true, then
the validation routine will allow extra parameters not named
in the validation specification. In the case of positional
parameters, this allows an unlimited number of maximum
parameters (though a minimum may still be set). Defaults to
false.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="31%">


<p style="margin-top: 1em">on_fail =&gt; $callback</p></td>
<td width="52%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If given, this
callback will be called whenever a validation check fails.
It will be called with a single parameter, which will be a
string describing the failure. This is useful if you wish to
have this module throw exceptions as objects rather than as
strings, for example.</p>

<p style="margin-left:17%; margin-top: 1em">This callback
is expected to &quot;die()&quot; internally. If it does not,
the validation will proceed onwards, with unpredictable
results.</p>

<p style="margin-left:17%; margin-top: 1em">The default is
to simply use the Carp module&rsquo;s &quot;confess()&quot;
function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="32%">


<p style="margin-top: 1em">stack_skip =&gt; $number</p></td>
<td width="51%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This tells
Params::Validate how many stack frames to skip when finding
a subroutine name to use in error messages. By default, it
looks one frame back, at the immediate caller to
&quot;validate()&quot; or &quot;validate_pos()&quot;. If
this option is set, then the given number of frames are
skipped instead.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="35%">


<p style="margin-top: 1em">ignore_case =&gt; $boolean</p></td>
<td width="48%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><small>DEPRECATED</small></p>

<p style="margin-left:17%; margin-top: 1em">This is only
relevant when dealing with named parameters. If it is true,
then the validation code will ignore the case of parameter
names. Defaults to false.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="43%">


<p style="margin-top: 1em">strip_leading =&gt;
$characters</p> </td>
<td width="40%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><small>DEPRECATED</small></p>

<p style="margin-left:17%; margin-top: 1em">This too is
only relevant when dealing with named parameters. If this is
given then any parameters starting with these characters
will be considered equivalent to parameters without them
entirely. For example, if this is specified as
&rsquo;&minus;&rsquo;, then &quot;&minus;foo&quot; and
&quot;foo&quot; would be considered identical.</p>

<h2>PER-INVOCATION OPTIONS
<a name="PER-INVOCATION OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
&quot;validate_with()&quot; function can be used to set the
options listed above on a per-invocation basis. For
example:</p>

<p style="margin-left:11%; margin-top: 1em">my %p =
validate_with( <br>
params =&gt; \@_, <br>
spec =&gt; { <br>
foo =&gt; { type =&gt; SCALAR }, <br>
bar =&gt; { default =&gt; 10 } <br>
}, <br>
allow_extra =&gt; 1, <br>
);</p>

<p style="margin-left:11%; margin-top: 1em">In addition to
the options listed above, it is also possible to set the
option &quot;called&quot;, which should be a string. This
string will be used in any error messages caused by a
failure to meet the validation spec.</p>

<p style="margin-left:11%; margin-top: 1em">This subroutine
will validate named parameters as a hash if the
&quot;spec&quot; parameter is a hash reference. If it is an
array reference, the parameters are assumed to be
positional.</p>

<p style="margin-left:11%; margin-top: 1em">my %p =
validate_with( <br>
params =&gt; \@_, <br>
spec =&gt; { <br>
foo =&gt; { type =&gt; SCALAR }, <br>
bar =&gt; { default =&gt; 10 } <br>
}, <br>
allow_extra =&gt; 1, <br>
called =&gt; 'The Quux::Baz class constructor', <br>
); <br>
my @p = validate_with( <br>
params =&gt; \@_, <br>
spec =&gt; [ <br>
{ type =&gt; SCALAR }, <br>
{ default =&gt; 10 } <br>
], <br>
allow_extra =&gt; 1, <br>
called =&gt; 'The Quux::Baz class constructor', <br>
);</p>

<h2>DISABLING VALIDATION
<a name="DISABLING VALIDATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If the
environment variable &quot;PERL_NO_VALIDATION&quot; is set
to something true, then validation is turned off. This may
be useful if you only want to use this module during
development but don&rsquo;t want the speed hit during
production.</p>

<p style="margin-left:11%; margin-top: 1em">The only error
that will be caught will be when an odd number of parameters
are passed into a function/method that expects a hash.</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
selectively turn validation on and off at runtime, you can
directly set the $Params::Validate::NO_VALIDATION global
variable. It is <b>strongly</b> recommended that you
<b>localize</b> any changes to this variable, because other
modules you are using may expect validation to be on when
they execute. For example:</p>

<p style="margin-left:11%; margin-top: 1em">{ <br>
local $Params::Validate::NO_VALIDATION = 1; <br>
# no error <br>
foo( bar =&gt; 2 ); <br>
} <br>
# error <br>
foo( bar =&gt; 2 ); <br>
sub foo { <br>
my %p = validate( @_, { foo =&gt; 1 } ); <br>
...; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">But if you want
to shoot yourself in the foot and just turn it off, go
ahead!</p>

<h2>SPECIFYING AN IMPLEMENTATION
<a name="SPECIFYING AN IMPLEMENTATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module
ships with two equivalent implementations, one in
<small>XS</small> and one in pure Perl. By default, it will
try to load the <small>XS</small> version and fall back to
the pure Perl implementation as needed. If you want to
request a specific version, you can set the
&quot;PARAMS_VALIDATE_IMPLEMENTATION&quot; environment
variable to either &quot;XS&quot; or &quot;PP&quot;. If the
implementation you ask for cannot be loaded, then this
module will die when loaded.</p>

<h2>TAINT MODE
<a name="TAINT MODE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>XS</small> implementation of this module has some
problems Under taint mode with versions of Perl before 5.14.
If validation <i>fails</i>, then instead of getting the
expected error message you&rsquo;ll get a message like
&quot;Insecure dependency in eval_sv&quot;. This can be
worked around by either untainting the arguments yourself,
using the pure Perl implementation, or upgrading your
Perl.</p>

<h2>LIMITATIONS
<a name="LIMITATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Right now there
is no way (short of a callback) to specify that something
must be of one of a list of classes, or that it must possess
one of a list of methods. If this is desired, it can be
added in the future.</p>

<p style="margin-left:11%; margin-top: 1em">Ideally, there
would be only one validation function. If someone figures
out how to do this, please let me know.</p>

<h2>SUPPORT
<a name="SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Bugs may be
submitted at
&lt;https://github.com/houseabsolute/Params&minus;Validate/issues&gt;.</p>

<h2>SOURCE
<a name="SOURCE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The source code
repository for Params-Validate can be found at
&lt;https://github.com/houseabsolute/Params&minus;Validate&gt;.</p>

<h2>DONATIONS
<a name="DONATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;d
like to thank me for the work I&rsquo;ve done on this
module, please consider making a &quot;donation&quot; to me
via PayPal. I spend a lot of free time creating free
software, and would appreciate any support you&rsquo;d care
to offer.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that <b>I am not suggesting that you must do this</b> in
order for me to continue working on this particular
software. I will continue to do so, inasmuch as I have in
the past, for as long as it interests me.</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, a
donation made in this way will probably not make me work on
this software much more, unless I get so many donations that
I can consider working on free software full time
(let&rsquo;s all have a chuckle at that together).</p>

<p style="margin-left:11%; margin-top: 1em">To donate, log
into PayPal and send money to autarch@urth.org, or use the
button at
&lt;https://houseabsolute.com/foss&minus;donations/&gt;.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="51%">


<p style="margin-top: 1em">Dave Rolsky
&lt;autarch@urth.org&gt;</p> </td>
<td width="32%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="51%">


<p>Ilya Martynov &lt;ilya@martynov.org&gt;</p></td>
<td width="32%">
</td></tr>
</table>

<h2>CONTRIBUTORS
<a name="CONTRIBUTORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p style="margin-top: 1em">Andy Grundman
&lt;andyg@activestate.com&gt;</p> </td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>Diab Jerius &lt;djerius@cfa.harvard.edu&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>E. Choroba &lt;choroba@matfyz.cz&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>Graham Knop &lt;haarg@haarg.org&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>Ivan Bessarabov &lt;ivan@bessarabov.ru&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>J.R. Mash &lt;jmash.code@gmail.com&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>Karen Etheridge &lt;ether@cpan.org&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>Noel Maddy &lt;zhtwnpanta@gmail.com&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>Olivier Mengue &lt;dolmen@cpan.org&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>Tony Cook &lt;tony@develop&minus;help.com&gt;</p></td>
<td width="26%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="57%">


<p>Vincent Pit &lt;perl@profvince.com&gt;</p></td>
<td width="26%">
</td></tr>
</table>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This software
is Copyright (c) 2001 &minus; 2022 by Dave Rolsky and Ilya
Martynov.</p>

<p style="margin-left:11%; margin-top: 1em">This is free
software, licensed under:</p>

<p style="margin-left:11%; margin-top: 1em">The Artistic
License 2.0 (GPL Compatible)</p>

<p style="margin-left:11%; margin-top: 1em">The full text
of the license can be found in the
<i><small>LICENSE</small></i> file included with this
distribution.</p>
<hr>
</body>
</html>
