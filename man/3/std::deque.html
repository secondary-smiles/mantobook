<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:11 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::deque&lt; _Tp, _Alloc &gt;</title>

</head>
<body>
<h1>std::deque</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">std::deque&lt;
_Tp, _Alloc &gt; &minus; A standard container using
fixed-size memory allocation and constant-time manipulation
of elements at either end.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;deque&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::_Deque_base&lt; _Tp, _Alloc &gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Alloc
<b>allocator_type</b> <br>
typedef <b>_Base::const_iterator const_iterator</b> <br>
typedef _Alloc_traits::const_pointer <b>const_pointer</b>
<br>
typedef _Alloc_traits::const_reference
<b>const_reference</b> <br>
typedef <b>std::reverse_iterator</b>&lt;
<b>const_iterator</b> &gt; <b>const_reverse_iterator</b>
<br>
typedef ptrdiff_t <b>difference_type</b> <br>
typedef <b>_Base::iterator iterator</b> <br>
typedef _Alloc_traits::pointer <b>pointer</b> <br>
typedef _Alloc_traits::reference <b>reference</b> <br>
typedef <b>std::reverse_iterator</b>&lt; <b>iterator</b>
&gt; <b>reverse_iterator</b> <br>
typedef size_t <b>size_type</b> <br>
typedef _Tp <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>deque</b> ()=default <br>
Creates a deque with no elements. <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
<b>deque</b> (_InputIterator __first, _InputIterator __last,
const allocator_type &amp;__a=allocator_type()) <br>
Builds a deque from a range. <b><br>
deque</b> (const allocator_type &amp;__a) <br>
Creates a deque with no elements. <b><br>
deque</b> (const <b>deque</b> &amp;__x) <br>
Deque copy constructor. <b><br>
deque</b> (const <b>deque</b> &amp;__x, const
__type_identity_t&lt; allocator_type &gt; &amp;__a) <br>
Copy constructor with alternative allocator. <b><br>
deque</b> (<b>deque</b> &amp;&amp;)=default <br>
Deque move constructor. <b><br>
deque</b> (<b>deque</b> &amp;&amp;__x, const
__type_identity_t&lt; allocator_type &gt; &amp;__a) <br>
Move constructor with alternative allocator. <b><br>
deque</b> (<b>initializer_list</b>&lt; value_type &gt; __l,
const allocator_type &amp;__a=allocator_type()) <br>
Builds a deque from an initializer list. <b><br>
deque</b> (size_type __n, const allocator_type
&amp;__a=allocator_type()) <br>
Creates a deque with default constructed elements. <b><br>
deque</b> (size_type __n, const value_type &amp;__value,
const allocator_type &amp;__a=allocator_type()) <br>
Creates a deque with copies of an exemplar element. <b><br>
~deque</b> () <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; void
<b>assign</b> (_InputIterator __first, _InputIterator
__last) <br>
Assigns a range to a deque. <br>
void <b>assign</b> (<b>initializer_list</b>&lt; value_type
&gt; __l) <br>
Assigns an initializer list to a deque. <br>
void <b>assign</b> (size_type __n, const value_type
&amp;__val) <br>
Assigns a given value to a deque. <br>
reference <b>at</b> (size_type __n) <br>
Provides access to the data contained in the deque. <br>
const_reference <b>at</b> (size_type __n) const <br>
Provides access to the data contained in the deque. <br>
const_reference <b>back</b> () const noexcept <br>
reference <b>back</b> () noexcept <b><br>
const_iterator begin</b> () const noexcept <b><br>
iterator begin</b> () noexcept <b><br>
const_iterator cbegin</b> () const noexcept <b><br>
const_iterator cend</b> () const noexcept <br>
void <b>clear</b> () noexcept <b><br>
const_reverse_iterator crbegin</b> () const noexcept <b><br>
const_reverse_iterator crend</b> () const noexcept <br>
template&lt;typename... _Args&gt; <b>iterator emplace</b>
(<b>const_iterator</b> __position, _Args &amp;&amp;...
__args) <br>
Inserts an object in deque before specified iterator. <br>
template&lt;typename... _Args&gt; reference
<b>emplace_back</b> (_Args &amp;&amp;... __args) <br>
template&lt;typename... _Args&gt; reference
<b>emplace_front</b> (_Args &amp;&amp;... __args) <br>
bool <b>empty</b> () const noexcept <b><br>
const_iterator end</b> () const noexcept <b><br>
iterator end</b> () noexcept <b><br>
iterator erase</b> (<b>const_iterator</b> __first,
<b>const_iterator</b> __last) <br>
Remove a range of elements. <b><br>
iterator erase</b> (<b>const_iterator</b> __position) <br>
Remove element at given position. <br>
const_reference <b>front</b> () const noexcept <br>
reference <b>front</b> () noexcept <br>
allocator_type <b>get_allocator</b> () const noexcept <br>
Get a copy of the memory allocation object. <b><br>
iterator insert</b> (<b>const_iterator</b> __p,
<b>initializer_list</b>&lt; value_type &gt; __l) <br>
Inserts an initializer list into the deque. <br>
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>iterator
insert</b> (<b>const_iterator</b> __position, _InputIterator
__first, _InputIterator __last) <br>
Inserts a range into the deque. <b><br>
iterator insert</b> (<b>const_iterator</b> __position, const
value_type &amp;__x) <br>
Inserts given value into deque before specified iterator.
<b><br>
iterator insert</b> (<b>const_iterator</b> __position,
size_type __n, const value_type &amp;__x) <br>
Inserts a number of copies of given data into the deque.
<b><br>
iterator insert</b> (<b>const_iterator</b> __position,
value_type &amp;&amp;__x) <br>
Inserts given rvalue into deque before specified iterator.
<br>
size_type <b>max_size</b> () const noexcept <b><br>
deque</b> &amp; <b>operator=</b> (const <b>deque</b>
&amp;__x) <br>
Deque assignment operator. <b><br>
deque</b> &amp; <b>operator=</b> (<b>deque</b>
&amp;&amp;__x) noexcept(_Alloc_traits::_S_always_equal())
<br>
Deque move assignment operator. <b><br>
deque</b> &amp; <b>operator=</b>
(<b>initializer_list</b>&lt; value_type &gt; __l) <br>
Assigns an initializer list to a deque. <br>
const_reference <b>operator[]</b> (size_type __n) const
noexcept <br>
Subscript access to the data contained in the deque. <br>
reference <b>operator[]</b> (size_type __n) noexcept <br>
Subscript access to the data contained in the deque. <br>
void <b>pop_back</b> () noexcept <br>
Removes last element. <br>
void <b>pop_front</b> () noexcept <br>
Removes first element. <br>
void <b>push_back</b> (const value_type &amp;__x) <br>
Add data to the end of the deque. <br>
void <b>push_back</b> (value_type &amp;&amp;__x) <br>
void <b>push_front</b> (const value_type &amp;__x) <br>
Add data to the front of the deque. <br>
void <b>push_front</b> (value_type &amp;&amp;__x) <b><br>
const_reverse_iterator rbegin</b> () const noexcept <b><br>
reverse_iterator rbegin</b> () noexcept <b><br>
const_reverse_iterator rend</b> () const noexcept <b><br>
reverse_iterator rend</b> () noexcept <br>
void <b>resize</b> (size_type __new_size) <br>
Resizes the deque to the specified number of elements. <br>
void <b>resize</b> (size_type __new_size, const value_type
&amp;__x) <br>
Resizes the deque to the specified number of elements. <br>
void <b>shrink_to_fit</b> () noexcept <br>
size_type <b>size</b> () const noexcept <br>
void <b>swap</b> (<b>deque</b> &amp;__x) noexcept <br>
Swaps data with another deque.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Types</b></p>

<p style="margin-left:17%;">enum {
<b>_S_initial_map_size</b> } <br>
typedef <b>__gnu_cxx::__alloc_traits</b>&lt; _Map_alloc_type
&gt; <b>_Map_alloc_traits</b> <br>
typedef _Alloc_traits::template rebind&lt; _Ptr &gt;::other
<b>_Map_alloc_type</b> <br>
typedef _Alloc_traits::pointer <b>_Ptr</b> <br>
typedef _Alloc_traits::const_pointer <b>_Ptr_const</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;">template&lt;typename
_ForwardIterator &gt; void <b>_M_assign_aux</b>
(_ForwardIterator __first, _ForwardIterator __last,
<b>std::forward_iterator_tag</b>) <br>
template&lt;typename _InputIterator &gt; void
<b>_M_assign_aux</b> (_InputIterator __first, _InputIterator
__last, <b>std::input_iterator_tag</b>) <br>
void <b>_M_deallocate_map</b> (_Map_pointer __p, size_t __n)
noexcept <br>
void <b>_M_default_append</b> (size_type __n) <br>
void <b>_M_default_initialize</b> () <br>
template&lt;typename _Alloc1 &gt; void
<b>_M_destroy_data</b> (<b>iterator</b> __first,
<b>iterator</b> __last, const _Alloc1 &amp;) <br>
void <b>_M_destroy_data</b> (<b>iterator</b> __first,
<b>iterator</b> __last, const <b>std::allocator</b>&lt; _Tp
&gt; &amp;) <br>
void <b>_M_destroy_data_aux</b> (<b>iterator</b> __first,
<b>iterator</b> __last) <b><br>
iterator _M_erase</b> (<b>iterator</b> __first,
<b>iterator</b> __last) <b><br>
iterator _M_erase</b> (<b>iterator</b> __pos) <br>
void <b>_M_erase_at_begin</b> (<b>iterator</b> __pos) <br>
void <b>_M_erase_at_end</b> (<b>iterator</b> __pos) <br>
void <b>_M_fill_assign</b> (size_type __n, const value_type
&amp;__val) <br>
void <b>_M_fill_initialize</b> (const value_type
&amp;__value) <br>
Fills the deque with copies of value. <br>
void <b>_M_fill_insert</b> (<b>iterator</b> __pos, size_type
__n, const value_type &amp;__x) <br>
_Map_alloc_type <b>_M_get_map_allocator</b> () const
noexcept <br>
template&lt;typename... _Args&gt; <b>iterator
_M_insert_aux</b> (<b>iterator</b> __pos, _Args
&amp;&amp;... __args) <br>
template&lt;typename _ForwardIterator &gt; void
<b>_M_insert_aux</b> (<b>iterator</b> __pos,
_ForwardIterator __first, _ForwardIterator __last, size_type
__n) <br>
void <b>_M_insert_aux</b> (<b>iterator</b> __pos, size_type
__n, const value_type &amp;__x) <br>
void <b>_M_move_assign1</b> (<b>deque</b> &amp;&amp;__x,
<b>false_type</b>) <br>
void <b>_M_move_assign1</b> (<b>deque</b> &amp;&amp;__x,
<b>true_type</b>) noexcept <br>
void <b>_M_move_assign2</b> (<b>deque</b> &amp;&amp;__x,
<b>false_type</b>) <br>
void <b>_M_move_assign2</b> (<b>deque</b> &amp;&amp;__x,
<b>true_type</b>) <br>
void <b>_M_range_check</b> (size_type __n) const <br>
Safety check used only from at(). <br>
template&lt;typename _ForwardIterator &gt; void
<b>_M_range_insert_aux</b> (<b>iterator</b> __pos,
_ForwardIterator __first, _ForwardIterator __last,
<b>std::forward_iterator_tag</b>) <br>
template&lt;typename _InputIterator &gt; void
<b>_M_range_insert_aux</b> (<b>iterator</b> __pos,
_InputIterator __first, _InputIterator __last,
<b>std::input_iterator_tag</b>) <br>
template&lt;typename... _Args&gt; void <b>_M_replace_map</b>
(_Args &amp;&amp;... __args) <br>
bool <b>_M_shrink_to_fit</b> ()</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_InputIterator &gt; void <b>_M_range_initialize</b>
(_InputIterator __first, _InputIterator __last,
<b>std::input_iterator_tag</b>) <br>
Fills the deque with whatever is in [first,last). <br>
template&lt;typename _ForwardIterator &gt; void
<b>_M_range_initialize</b> (_ForwardIterator __first,
_ForwardIterator __last, <b>std::forward_iterator_tag</b>)
<br>
Fills the deque with whatever is in [first,last).</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename...
_Args&gt; void <b>_M_push_back_aux</b> (_Args &amp;&amp;...
__args) <br>
Helper functions for push_* and pop_*. <br>
template&lt;typename... _Args&gt; void
<b>_M_push_front_aux</b> (_Args &amp;&amp;... __args) <br>
Helper functions for push_* and pop_*. <br>
void <b>_M_pop_back_aux</b> () <br>
Helper functions for push_* and pop_*. <br>
void <b>_M_pop_front_aux</b> () <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:23%; margin-top: 1em"><b>iterator
_M_reserve_elements_at_front</b> (size_type __n) <br>
Memory-handling helpers for the previous internal insert
functions. <b><br>
iterator _M_reserve_elements_at_back</b> (size_type __n)
<br>
Memory-handling helpers for the previous internal insert
functions. <br>
void <b>_M_new_elements_at_front</b> (size_type
__new_elements) <br>
Memory-handling helpers for the previous internal insert
functions. <br>
void <b>_M_new_elements_at_back</b> (size_type
__new_elements) <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:23%; margin-top: 1em">void
<b>_M_reserve_map_at_back</b> (size_type __nodes_to_add=1)
<br>
Memory-handling helpers for the major map. <br>
void <b>_M_reserve_map_at_front</b> (size_type
__nodes_to_add=1) <br>
Memory-handling helpers for the major map. <br>
void <b>_M_reallocate_map</b> (size_type __nodes_to_add,
bool __add_at_front) <br>
Memory-handling helpers for the major map.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Protected Member Functions</b></p>

<p style="margin-left:17%;">static size_t
<b>_S_check_init_len</b> (size_t __n, const allocator_type
&amp;__a) <br>
static size_type <b>_S_max_size</b> (const _Tp_alloc_type
&amp;__a) noexcept</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;</b>
<br>
class std::deque&lt; _Tp, _Alloc &gt;&quot;A standard
container using fixed-size memory allocation and
constant-time manipulation of elements at either end.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_Tp</i> Type of element.
<i><br>
_Alloc</i> Allocator type, defaults to
allocator&lt;_Tp&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Meets the
requirements of a <tt>container</tt>, a <tt>reversible
container</tt>, and a <tt>sequence</tt>, including the
<tt>optional sequence requirements</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">In previous
HP/SGI versions of deque, there was an extra template
parameter so users could control the node size. This
extension turned out to violate the C++ standard (it can be
detected using template template parameters), and it was
removed.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
how a deque&lt;Tp&gt; manages memory. Each deque has 4
members:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p>Tp** _M_map</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p>size_t _M_map_size</p></td>
<td width="43%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="43%">


<p>iterator _M_start, _M_finish</p></td>
<td width="43%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">map_size is at
least 8. map is an array of map_size
pointers-to-<i>nodes</i>. (The name map has nothing to do
with the std::map class, and <b>nodes</b> should not be
confused with std::list&rsquo;s usage of <i>node</i>.)</p>

<p style="margin-left:11%; margin-top: 1em">A <i>node</i>
has no specific type name as such, but it is referred to as
<i>node</i> in this file. It is a simple array-of-Tp. If Tp
is very large, there will be one Tp element per node (i.e.,
an <i>array</i> of one). For non-huge Tp&rsquo;s, node size
is inversely related to Tp size: the larger the Tp, the
fewer Tp&rsquo;s will fit in a node. The goal here is to
keep the total size of a node relatively small and constant
over different Tp&rsquo;s, to improve allocator
efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">Not every
pointer in the map array will point to a node. If the
initial number of elements in the deque is small, the
/middle/ map pointers will be valid, and the ones at the
edges will be unused. This same situation will arise as the
map grows: available map pointers, if any, will be on the
ends. As new nodes are created, only a subset of the
map&rsquo;s pointers need to be copied <i>outward</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Class
invariants:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="48%">


<p style="margin-top: 1em">For any nonsingular iterator
i:</p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%"></td>
<td width="2%"></td>
<td width="83%">


<p style="margin-top: 1em">i.node points to a member of the
map array. (Yes, you read that correctly: i.node does not
actually point to a node.) The member of the map array is
what actually points to the node.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>i.first == *(i.node) (This points to the node (first Tp
element).)</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>i.last == i.first + node_size</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">


<p>i.cur is a pointer in the range [i.first, i.last). NOTE:
the implication of this is that i.cur is always a
dereferenceable pointer, even if i is a past-the-end
iterator.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="83%">
</td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">Start and
Finish are always nonsingular iterators. NOTE: this means
that an empty deque must have one node, a deque with &lt;N
elements (where N is the node buffer size) must have one
node, a deque with N through (2N-1) elements must have two
nodes, etc.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p style="margin-top: 1em">For every node other than
start.node and finish.node, every element in the node is an
initialized object. If start.node == finish.node, then
[start.cur, finish.cur) are initialized objects, and the
elements outside that range are uninitialized storage.
Otherwise, [start.cur, start.last) and [finish.first,
finish.cur) are initialized objects, and [start.first,
start.cur) and [finish.cur, finish.last) are uninitialized
storage.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>[map, map + map_size) is a valid, non-empty range.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>[start.node, finish.node] is a valid range contained
within [map, map + map_size).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>A pointer in the range [map, map + map_size) points to
an allocated node if and only if the pointer is in the range
[start.node, finish.node].</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
the magic: nothing in deque is <b>aware</b> of the
discontiguous storage!</p>

<p style="margin-left:11%; margin-top: 1em">The memory
setup and layout occurs in the parent, _Base, and the
iterator class is entirely responsible for <i>leaping</i>
from one node to the next. All the implementation routines
for deque itself work only through the start and finish
iterators. This keeps the routines simple and sane, and we
can use other standard algorithms as well.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque ()</b>
<tt>[default]</tt> <br>
Creates a deque with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (const allocator_type
&amp; __a)</b> <tt>[inline]</tt><b>,</b> <tt>[explicit]</tt>
<br>
Creates a deque with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__a</i> An allocator
object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (size_type __n, const
allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
Creates a deque with default constructed elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The number of
elements to initially create. <i><br>
__a</i> An allocator.</p>

<p style="margin-left:11%; margin-top: 1em">This
constructor fills the deque with <i>n</i> default
constructed elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (size_type __n, const
value_type &amp; __value, const allocator_type &amp; __a
=</b> <tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt>
<br>
Creates a deque with copies of an exemplar element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The number of
elements to initially create. <i><br>
__value</i> An element to copy. <i><br>
__a</i> An allocator.</p>

<p style="margin-left:11%; margin-top: 1em">This
constructor fills the deque with <i>__n</i> copies of
<i>__value</i>.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_fill_initialize()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (const deque&lt; _Tp,
_Alloc &gt; &amp; __x)</b> <tt>[inline]</tt> <br>
Deque copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">The
newly-created deque uses a copy of the allocator object used
by <i>__x</i> (unless the allocator traits dictate a
different object).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::deque&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (deque&lt; _Tp,
_Alloc &gt; &amp;&amp;)</b> <tt>[default]</tt> <br>
Deque move constructor. The newly-created deque contains the
exact contents of the moved instance. The contents of the
moved instance are a valid, but unspecified deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (const deque&lt; _Tp,
_Alloc &gt; &amp; __x, const __type_identity_t&lt;
allocator_type &gt; &amp; __a)</b> <tt>[inline]</tt> <br>
Copy constructor with alternative allocator.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::deque&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (deque&lt; _Tp,
_Alloc &gt; &amp;&amp; __x, const __type_identity_t&lt;
allocator_type &gt; &amp; __a)</b> <tt>[inline]</tt> <br>
Move constructor with alternative allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (initializer_list&lt;
value_type &gt; __l, const allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds a deque from an initializer list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list.
<i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create a deque
consisting of copies of the elements in the initializer_list
<i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This will call
the element type&rsquo;s copy constructor N times (where N
is __l.size()) and do no memory reallocation.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_range_initialize()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::deque (_InputIterator
__first, _InputIterator __last, const allocator_type &amp;
__a =</b> <tt>allocator_type()</tt><b>)</b>
<tt>[inline]</tt> <br>
Builds a deque from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create a deque
consisting of copies of the elements from [__first,
__last).</p>

<p style="margin-left:11%; margin-top: 1em">If the
iterators are forward, bidirectional, or random-access, then
this will call the elements&rsquo; copy constructor N times
(where N is distance(__first,__last)) and do no memory
reallocation. But if only input iterators are used, then
this will do at most 2N calls to the copy constructor, and
logN memory reallocations.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__iterator_category()</b>, and <b>std::deque&lt;
_Tp, _Alloc &gt;::_M_range_initialize()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
std::deque&lt; _Tp, _Alloc &gt;::~deque ()</b>
<tt>[inline]</tt> <br>
The dtor only erases the elements, and note that if the
elements themselves are pointers, the pointed-to memory is
not touched in any way. Managing the pointer is the
user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::deque&lt; _Tp, _Alloc &gt;::end()</b>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void deque::_M_fill_initialize
(const value_type &amp; __value)</b> <tt>[protected]</tt>
<br>
Fills the deque with copies of value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__value</i> Initial
value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Nothing.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">_M_start and _M_finish have
already been initialized, but none of the deque&rsquo;s
elements have yet been constructed.</p>

<p style="margin-left:11%; margin-top: 1em">This function
is called only when the user provides an explicit size (with
or without an explicit exemplar value).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::_Destroy()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::deque()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void
deque::_M_new_elements_at_back (size_type
__new_elements)</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_back()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void
deque::_M_new_elements_at_front (size_type
__new_elements)</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_front()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void deque::_M_pop_back_aux</b>
<tt>[protected]</tt> <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::pop_back()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void deque::_M_pop_front_aux</b>
<tt>[protected]</tt> <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::pop_front()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename... _Args&gt;
void deque::_M_push_back_aux (_Args &amp;&amp;...
__args)</b> <tt>[protected]</tt> <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::push_back()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename... _Args&gt;
void deque::_M_push_front_aux (_Args &amp;&amp;...
__args)</b> <tt>[protected]</tt> <br>
Helper functions for push_* and pop_*.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::push_front()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::_M_range_check (size_type
__n) const</b> <tt>[inline]</tt><b>,</b>
<tt>[protected]</tt> <br>
Safety check used only from at().</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::at()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename
_ForwardIterator &gt; void deque::_M_range_initialize
(_ForwardIterator __first, _ForwardIterator __last,
std::forward_iterator_tag)</b> <tt>[protected]</tt> <br>
Fills the deque with whatever is in [first,last).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Nothing.</p>

<p style="margin-left:11%; margin-top: 1em">If the
iterators are actually forward iterators (or better), then
the memory layout can be done all at once. Else we move
forward using push_back on each value from the iterator.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::_Destroy()</b>, <b>std::advance()</b>, and
<b>std::distance()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename
_InputIterator &gt; void deque::_M_range_initialize
(_InputIterator __first, _InputIterator __last,
std::input_iterator_tag)</b> <tt>[protected]</tt> <br>
Fills the deque with whatever is in [first,last).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Nothing.</p>

<p style="margin-left:11%; margin-top: 1em">If the
iterators are actually forward iterators (or better), then
the memory layout can be done all at once. Else we move
forward using push_back on each value from the iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::deque()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; void deque::_M_reallocate_map
(size_type __nodes_to_add, bool __add_at_front)</b>
<tt>[protected]</tt> <br>
Memory-handling helpers for the major map. Makes sure the
_M_map has space for new nodes. Does not actually add the
nodes. Can invalidate _M_map pointers. (And consequently,
deque iterators.)</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::max()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_map_at_back()</b>, and <b>std::deque&lt;
_Tp, _Alloc &gt;::_M_reserve_map_at_front()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_back (size_type __n)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_back()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc
&gt;::_M_reserve_elements_at_front (size_type __n)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the previous internal insert
functions.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_new_elements_at_front()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::_M_reserve_map_at_back
(size_type __nodes_to_add =</b> <tt>1</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the major map. Makes sure the
_M_map has space for new nodes. Does not actually add the
nodes. Can invalidate _M_map pointers. (And consequently,
deque iterators.)</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_reallocate_map()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::_M_reserve_map_at_front
(size_type __nodes_to_add =</b> <tt>1</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[protected]</tt> <br>
Memory-handling helpers for the major map. Makes sure the
_M_map has space for new nodes. Does not actually add the
nodes. Can invalidate _M_map pointers. (And consequently,
deque iterators.)</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_reallocate_map()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::assign (_InputIterator
__first, _InputIterator __last)</b> <tt>[inline]</tt> <br>
Assigns a range to a deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a deque with copies of the elements in the range
[__first,__last).</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the deque and that the
resulting deque&rsquo;s size is the same as the number of
elements assigned.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__iterator_category()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::assign
(initializer_list&lt; value_type &gt; __l)</b>
<tt>[inline]</tt> <br>
Assigns an initializer list to a deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a deque with copies of the elements in the
initializer_list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the deque and that the
resulting deque&rsquo;s size is the same as the number of
elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::assign (size_type __n,
const value_type &amp; __val)</b> <tt>[inline]</tt> <br>
Assigns a given value to a deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> Number of elements
to be assigned. <i><br>
__val</i> Value to be assigned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a deque with <i>n</i> copies of the given value. Note
that the assignment completely changes the deque and that
the resulting deque&rsquo;s size is the same as the number
of elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::deque&lt; _Tp, _Alloc &gt;::at (size_type
__n)</b> <tt>[inline]</tt> <br>
Provides access to the data contained in the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read/write reference to
data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__n</i> is an invalid index.</p>

<p style="margin-left:11%; margin-top: 1em">This function
provides for safer data access. The parameter is first
checked that it is in the range of the deque. The function
throws out_of_range if the check fails.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_range_check()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::deque&lt; _Tp, _Alloc &gt;::at
(size_type __n) const</b> <tt>[inline]</tt> <br>
Provides access to the data contained in the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) reference
to data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__n</i> is an invalid index.</p>

<p style="margin-left:11%; margin-top: 1em">This function
provides for safer data access. The parameter is first
checked that it is in the range of the deque. The function
throws out_of_range if the check fails.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_range_check()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::deque&lt; _Tp, _Alloc &gt;::back ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reference to the data at the
last element of the deque.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::deque&lt; _Tp, _Alloc &gt;::back ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reference to the data at the last
element of the deque.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::deque&lt; _Tp, _Alloc &gt;::begin ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the deque. Iteration is done in ordinary
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::begin ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points to the first
element in the deque. Iteration is done in ordinary element
order.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::deque()</b>,
<b>std::deque&lt; _Tp, _Alloc &gt;::~deque()</b>,
<b>std::deque&lt; _Tp, _Alloc &gt;::clear()</b>,
<b>std::deque&lt; _Tp, _Alloc &gt;::front()</b>,
<b>std::deque&lt; _Tp, _Alloc &gt;::insert()</b>,
<b>std::operator&lt;()</b>, <b>std::deque&lt; _Tp, _Alloc
&gt;::operator=()</b>, and <b>std::operator==()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::deque&lt; _Tp, _Alloc &gt;::cbegin ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first element in the deque. Iteration is done in ordinary
element order.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::insert()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::deque&lt; _Tp, _Alloc &gt;::cend ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the deque. Iteration is done in ordinary
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::clear ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Erases all the elements. Note that this function only erases
the elements, and that if the elements themselves are
pointers, the pointed-to memory is not touched in any way.
Managing the pointer is the user&rsquo;s responsibility.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::deque&lt; _Tp, _Alloc
&gt;::crbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last element in the deque. Iteration is done in
reverse element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::deque&lt; _Tp, _Alloc
&gt;::crend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to one before the first element in the deque. Iteration is
done in reverse element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; template&lt;typename... _Args&gt;
deque&lt; _Tp, _Alloc &gt;::iterator deque::emplace
(const_iterator __position, _Args &amp;&amp;... __args)</b>
<br>
Inserts an object in deque before specified iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the deque. <i><br>
__args</i> Arguments.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert an object of type T constructed with
T(std::forward&lt;Args&gt;(args)...) before the specified
location.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::insert()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; bool
std::deque&lt; _Tp, _Alloc &gt;::empty () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns true if the deque is empty. (Thus begin() would
equal end().)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_iterator std::deque&lt; _Tp, _Alloc &gt;::end ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last element in the deque. Iteration is done in ordinary
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::end ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points one past the last
element in the deque. Iteration is done in ordinary element
order.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::deque()</b>,
<b>std::deque&lt; _Tp, _Alloc &gt;::~deque()</b>,
<b>std::deque&lt; _Tp, _Alloc &gt;::back()</b>,
<b>std::operator&lt;()</b>, <b>std::deque&lt; _Tp, _Alloc
&gt;::operator=()</b>, and <b>std::operator==()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::erase
(const_iterator __first, const_iterator __last)</b>
<tt>[inline]</tt> <br>
Remove a range of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the first element to be erased. <i><br>
__last</i> Iterator pointing to one past the last element to
be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element pointed to by <i>last</i> prior to erasing (or
end()).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will erase the elements in the range [__first,__last) and
shorten the deque accordingly.</p>

<p style="margin-left:11%; margin-top: 1em">The user is
cautioned that this function only erases the elements, and
that if the elements themselves are pointers, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::erase
(const_iterator __position)</b> <tt>[inline]</tt> <br>
Remove element at given position.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> Iterator
pointing to element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
next element (or end()).</p>

<p style="margin-left:11%; margin-top: 1em">This function
will erase the element at the given position and thus
shorten the deque by one.</p>

<p style="margin-left:11%; margin-top: 1em">The user is
cautioned that this function only erases the element, and
that if the element is itself a pointer, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::deque&lt; _Tp, _Alloc &gt;::front ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read-only (constant) reference to the data at the
first element of the deque.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::deque&lt; _Tp, _Alloc &gt;::front ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reference to the data at the first
element of the deque.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::begin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
allocator_type std::deque&lt; _Tp, _Alloc
&gt;::get_allocator () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Get a copy of the memory allocation object.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::insert
(const_iterator __p, initializer_list&lt; value_type &gt;
__l)</b> <tt>[inline]</tt> <br>
Inserts an initializer list into the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> An iterator into the
deque. <i><br>
__l</i> An initializer_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert copies of the data in the initializer_list
<i>__l</i> into the deque before the location specified by
<i>__p</i>. This is known as <i>list insert</i>.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::deque&lt; _Tp, _Alloc &gt;::cbegin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
template&lt;typename _InputIterator , typename =
std::_RequireInputIter&lt;_InputIterator&gt;&gt; iterator
std::deque&lt; _Tp, _Alloc &gt;::insert (const_iterator
__position, _InputIterator __first, _InputIterator
__last)</b> <tt>[inline]</tt> <br>
Inserts a range into the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the deque. <i><br>
__first</i> An input iterator. <i><br>
__last</i> An input iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert copies of the data in the range [__first,__last)
into the deque before the location specified by
<i>__position</i>. This is known as <i>range insert</i>.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__iterator_category()</b>, <b>std::deque&lt; _Tp,
_Alloc &gt;::begin()</b>, and <b>std::deque&lt; _Tp, _Alloc
&gt;::cbegin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; deque&lt; _Tp, _Alloc
&gt;::iterator deque::insert (const_iterator __position,
const value_type &amp; __x)</b> <br>
Inserts given value into deque before specified
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the deque. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a copy of the given value before the specified
location.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::insert
(const_iterator __position, size_type __n, const value_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Inserts a number of copies of given data into the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the deque. <i><br>
__n</i> Number of elements to be inserted. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a specified number of copies of the given data
before the location specified by <i>__position</i>.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::begin()</b>, and
<b>std::deque&lt; _Tp, _Alloc &gt;::cbegin()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
iterator std::deque&lt; _Tp, _Alloc &gt;::insert
(const_iterator __position, value_type &amp;&amp; __x)</b>
<tt>[inline]</tt> <br>
Inserts given rvalue into deque before specified
iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> A
const_iterator into the deque. <i><br>
__x</i> Data to be inserted.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
inserted data.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will insert a copy of the given rvalue before the specified
location.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::emplace()</b>, and
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
size_type std::deque&lt; _Tp, _Alloc &gt;::max_size ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the size() of the largest possible deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc &gt; deque&lt; _Tp, _Alloc &gt; &amp;
deque::operator= (const deque&lt; _Tp, _Alloc &gt; &amp;
__x)</b> <br>
Deque assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">All the
elements of <i>x</i> are copied.</p>

<p style="margin-left:11%; margin-top: 1em">The
newly-created deque uses a copy of the allocator object used
by <i>__x</i> (unless the allocator traits dictate a
different object).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>, <b>std::deque&lt; _Tp, _Alloc
&gt;::begin()</b>, <b>std::deque&lt; _Tp, _Alloc
&gt;::end()</b>, <b>std::deque&lt; _Tp, _Alloc
&gt;::get_allocator()</b>, <b>std::deque&lt; _Tp, _Alloc
&gt;::size()</b>, and <b>std::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; deque
&amp; std::deque&lt; _Tp, _Alloc &gt;::operator= (deque&lt;
_Tp, _Alloc &gt; &amp;&amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Deque move assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of identical
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">The contents of
<i>__x</i> are moved into this deque (without copying, if
the allocators permit it). <i>__x</i> is a valid, but
unspecified deque.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; deque
&amp; std::deque&lt; _Tp, _Alloc &gt;::operator=
(initializer_list&lt; value_type &gt; __l)</b>
<tt>[inline]</tt> <br>
Assigns an initializer list to a deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a deque with copies of the elements in the
initializer_list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the deque and that the
resulting deque&rsquo;s size is the same as the number of
elements assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reference std::deque&lt; _Tp, _Alloc &gt;::operator[]
(size_type __n) const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Subscript access to the data contained in the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) reference
to data.</p>

<p style="margin-left:11%; margin-top: 1em">This operator
allows for easy, array-style, data access. Note that data
access with this operator is unchecked and out_of_range
lookups are not defined. (For checked lookups see at().)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reference std::deque&lt; _Tp, _Alloc &gt;::operator[]
(size_type __n)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Subscript access to the data contained in the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__n</i> The index of the
element for which data should be accessed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read/write reference to
data.</p>

<p style="margin-left:11%; margin-top: 1em">This operator
allows for easy, array-style, data access. Note that data
access with this operator is unchecked and out_of_range
lookups are not defined. (For checked lookups see at().)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::pop_back ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Removes last element. This is a typical stack operation. It
shrinks the deque by one.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
data is returned, and if the last element&rsquo;s data is
needed, it should be retrieved before pop_back() is
called.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_pop_back_aux()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::pop_front ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Removes first element. This is a typical stack operation. It
shrinks the deque by one.</p>

<p style="margin-left:11%; margin-top: 1em">Note that no
data is returned, and if the first element&rsquo;s data is
needed, it should be retrieved before pop_front() is
called.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_pop_front_aux()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::push_back (const value_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Add data to the end of the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Data to be
added.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical stack operation. The function creates an element at
the end of the deque and assigns the given data to it. Due
to the nature of a deque this operation can be done in
constant time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_push_back_aux()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::push_front (const
value_type &amp; __x)</b> <tt>[inline]</tt> <br>
Add data to the front of the deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Data to be
added.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
typical stack operation. The function creates an element at
the front of the deque and assigns the given data to it. Due
to the nature of a deque this operation can be done in
constant time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc
&gt;::_M_push_front_aux()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::deque&lt; _Tp, _Alloc
&gt;::rbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last element in the deque. Iteration is done in
reverse element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reverse_iterator std::deque&lt; _Tp, _Alloc &gt;::rbegin
()</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to the
last element in the deque. Iteration is done in reverse
element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
const_reverse_iterator std::deque&lt; _Tp, _Alloc &gt;::rend
() const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Returns a read-only (constant) reverse iterator that points
to one before the first element in the deque. Iteration is
done in reverse element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
reverse_iterator std::deque&lt; _Tp, _Alloc &gt;::rend
()</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to one
before the first element in the deque. Iteration is done in
reverse element order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::resize (size_type
__new_size)</b> <tt>[inline]</tt> <br>
Resizes the deque to the specified number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__new_size</i> Number of
elements the deque should contain.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will resize the deque to the specified number of elements.
If the number is smaller than the deque&rsquo;s current size
the deque is truncated, otherwise default constructed
elements are appended.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::resize (size_type
__new_size, const value_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Resizes the deque to the specified number of elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__new_size</i> Number of
elements the deque should contain. <i><br>
__x</i> Data with which new elements should be
populated.</p>

<p style="margin-left:11%; margin-top: 1em">This function
will resize the deque to the specified number of elements.
If the number is smaller than the deque&rsquo;s current size
the deque is truncated, otherwise the deque is extended and
new elements are populated with given data.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::deque&lt; _Tp, _Alloc &gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::shrink_to_fit ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
A non-binding request to reduce memory use.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
size_type std::deque&lt; _Tp, _Alloc &gt;::size () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of elements in the deque.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::deque&lt; _Tp, _Alloc &gt;::_M_range_check()</b>,
<b>std::deque&lt; _Tp, _Alloc &gt;::operator=()</b>,
<b>std::operator==()</b>, and <b>std::deque&lt; _Tp, _Alloc
&gt;::resize()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , typename _Alloc = std::allocator&lt;_Tp&gt;&gt; void
std::deque&lt; _Tp, _Alloc &gt;::swap (deque&lt; _Tp, _Alloc
&gt; &amp; __x)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Swaps data with another deque.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A deque of the same
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">This exchanges
the elements between two deques in constant time. (Four
pointers, so it should be quite fast.) Note that the global
std::swap() function is specialized such that
std::swap(d1,d2) will feed to this function.</p>

<p style="margin-left:11%; margin-top: 1em">Whether the
allocators are swapped depends on the allocator traits.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
