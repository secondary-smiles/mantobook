<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:22 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IPC::Open2</title>

</head>
<body>
<h1>IPC::Open2</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">IPC::Open2
&minus; open a process for both reading and writing using
open2()</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use IPC::Open2;
<br>
my $pid = open2(my $chld_out, my $chld_in, <br>
'some', 'cmd', 'and', 'args'); <br>
# or passing the command through the shell <br>
my $pid = open2(my $chld_out, my $chld_in, 'some cmd and
args'); <br>
# read from parent STDIN and write to already open handle
<br>
open my $outfile, '&gt;', 'outfile.txt' or die &quot;open
failed: $!&quot;; <br>
my $pid = open2($outfile, '&lt;&amp;STDIN', 'some', 'cmd',
'and', 'args'); <br>
# read from already open handle and write to parent STDOUT
<br>
open my $infile, '&lt;', 'infile.txt' or die &quot;open
failed: $!&quot;; <br>
my $pid = open2('&gt;&amp;STDOUT', $infile, 'some', 'cmd',
'and', 'args'); <br>
# reap zombie and retrieve exit status <br>
waitpid( $pid, 0 ); <br>
my $child_exit_status = $? &gt;&gt; 8;</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>open2()</b> function runs the given command and connects
$chld_out for reading and $chld_in for writing. It&rsquo;s
what you think should work when you try</p>

<p style="margin-left:11%; margin-top: 1em">my $pid =
open(my $fh, &quot;|cmd args|&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">The $chld_in
filehandle will have autoflush turned on.</p>

<p style="margin-left:11%; margin-top: 1em">If $chld_out is
a string (that is, a bareword filehandle rather than a glob
or a reference) and it begins with &quot;&gt;&amp;&quot;,
then the child will send output directly to that file
handle. If $chld_in is a string that begins with
&quot;&lt;&amp;&quot;, then $chld_in will be closed in the
parent, and the child will read from it directly. In both
cases, there will be a <b>dup</b>(2) instead of a
<b>pipe</b>(2) made.</p>

<p style="margin-left:11%; margin-top: 1em">If either
reader or writer is the empty string or undefined, this will
be replaced by an autogenerated filehandle. If so, you must
pass a valid lvalue in the parameter slot so it can be
overwritten in the caller, or an exception will be
raised.</p>

<p style="margin-left:11%; margin-top: 1em"><b>open2()</b>
returns the process <small>ID</small> of the child process.
It doesn&rsquo;t return on failure: it just raises an
exception matching &quot;/^open2:/&quot;. However,
&quot;exec&quot; failures in the child are not detected.
You&rsquo;ll have to trap <small>SIGPIPE</small>
yourself.</p>

<p style="margin-left:11%; margin-top: 1em"><b>open2()</b>
does not wait for and reap the child process after it exits.
Except for short programs where it&rsquo;s acceptable to let
the operating system take care of this, you need to do this
yourself. This is normally as simple as calling
&quot;waitpid $pid, 0&quot; when you&rsquo;re done with the
process. Failing to do this can result in an accumulation of
defunct or &quot;zombie&quot; processes. See
&quot;waitpid&quot; in perlfunc for more information.</p>

<p style="margin-left:11%; margin-top: 1em">This whole
affair is quite dangerous, as you may block forever. It
assumes it&rsquo;s going to talk to something like
<b>bc</b>(1), both writing to it and reading from it. This
is presumably safe because you &quot;know&quot; that
commands like <b>bc</b>(1) will read a line at a time and
output a line at a time. Programs like <b>sort</b>(1) that
read their entire input stream first, however, are quite apt
to cause deadlock.</p>

<p style="margin-left:11%; margin-top: 1em">The big problem
with this approach is that if you don&rsquo;t have control
over source code being run in the child process, you
can&rsquo;t control what it does with pipe buffering. Thus
you can&rsquo;t just open a pipe to &quot;cat &minus;v&quot;
and continually read and write a line from it.</p>

<p style="margin-left:11%; margin-top: 1em">The IO::Pty and
Expect modules from <small>CPAN</small> can help with this,
as they provide a real tty (well, a pseudo-tty, actually),
which gets you back to line buffering in the invoked command
again.</p>

<h2>WARNING
<a name="WARNING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The order of
arguments differs from that of <b>open3()</b>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See IPC::Open3
for an alternative that handles <small>STDERR</small> as
well. This function is really just a wrapper around
<b>open3()</b>.</p>
<hr>
</body>
</html>
