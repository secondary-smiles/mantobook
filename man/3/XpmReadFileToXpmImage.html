<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:44 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XpmRead</title>

</head>
<body>
<h1>XpmReadFileToXpmImage</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">XpmRead &minus;
read an XPM file</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="86%">


<p style="margin-top: 1em"><b>int
XpmReadFileToImage(Display *</b><i>display</i><b>, char
*</b><i>filename</i><b>,</b></p> </td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>XImage
**</b><i>image_return</i><b>, XImage
**</b><i>shapeimage_return</i><b>, <br>
XpmAttributes *</b><i>attributes</i><b>);</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
XpmReadFileToPixmap(Display *</b><i>display</i><b>,
Drawable</b> <i>d</i><b>, char
*</b><i>filename</i><b>,</b></p> </td></tr>
</table>

<p style="margin-left:22%;"><b>Pixmap
*</b><i>pixmap_return</i><b>, Pixmap
*</b><i>shapemask_return</i><b>, <br>
XpmAttributes *</b><i>attributes</i><b>);</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int
XpmReadFileToXpmImage(char *</b><i>filename</i><b>, XpmImage
*</b><i>image</i><b>,</b></p> </td></tr>
</table>

<p style="margin-left:22%;"><b>XpmInfo
*</b><i>info</i><b>);</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int XpmReadFileToBuffer(char
*</b><i>filename</i><b>, char
**</b><i>buffer_return</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int XpmReadFileToData(char
*</b><i>filename</i><b>, char
***</b><i>data_return</i><b>);</b></p> </td></tr>
</table>

<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><i>display</i></b></p>

<p style="margin-left:22%;">Specifies the connection to the
X server.</p>

<p style="margin-left:11%;"><i>filename</i></p>

<p style="margin-left:22%;">Specifies the file name to
use.</p>

<p style="margin-left:11%;"><i>image_return</i></p>

<p style="margin-left:22%;">Returns the image which is
created.</p>

<p style="margin-left:11%;"><i>shapeimage_return</i></p>

<p style="margin-left:22%;">Returns the shape mask image
which is created if the color None is used.</p>

<p style="margin-left:11%;"><i>attributes</i></p>

<p style="margin-left:22%;">Specifies the location of a
structure to get and store information (or NULL).</p>

<p style="margin-left:11%;"><i>buffer_return</i></p>

<p style="margin-left:22%;">Returns the buffer created.</p>

<p style="margin-left:11%;"><i>data_return</i></p>

<p style="margin-left:22%;">Returns the data array
created.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>image</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>Specifies the image structure location.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>info</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>Specifies the location of a structure to store possible
information (or NULL).</p></td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>XpmReadFileToImage</b>
<br>
The <b>XpmReadFileToImage</b>() function reads in a file in
the XPM format. If the file cannot be opened it returns
<b>XpmOpenFailed</b>. If the file can be opened but does not
contain valid XPM data, it returns <b>XpmFileInvalid</b>. If
insufficient working storage is allocated, it returns
<b>XpmNoMemory</b>. If the passed XpmAttributes structure
pointer is not NULL, <b>XpmReadFileToImage</b>() looks for
the following attributes: XpmVisual, XpmColormap, XpmDepth,
XpmColorSymbols, XpmExactColors, XpmCloseness,
XpmRGBCloseness, XpmAllocCloseColors, XpmReturnPixels,
XpmReturnAllocPixels, XpmAllocColor, XpmFreeColors,
XpmColorClosure, XpmReturnExtensions, XpmReturnColorTable,
XpmBitmapFormat, sets the XpmSize, the XpmCharsPerPixel, and
possibly the XpmHotspot attributes when returning. As a
backward compatibility feature, <b>XpmReadFileToImage</b>()
also looks for the XpmReturnInfos attributes. As specified
in the table (page 12), if the data related to the
attributes XpmReturnExtensions, XpmReturnColorTable, and
XpmReturnInfos cannot be returned as requested because of
insufficient memory storage, <b>XpmReadFileToImage</b>()
will change the valuemask to mention this and will try to
continue. So the caller should check on this before
accessing this data.</p>

<p style="margin-left:11%; margin-top: 1em">Note: The
valuemask of the passed XpmAttributes must be set to some
valid value, at least zero, otherwise unpredictable errors
can occur.</p>


<p style="margin-left:11%; margin-top: 1em"><b>XpmReadFileToImage</b>()
allocates colors, as read from the file or possibly
overridden as specified in the XpmColorSymbols attributes.
The colors are allocated using the color settings for the
visual specified by the XpmColorKey attribute, which has the
value XPM_MONO, XPM_GRAY4, XPM_GRAY, or XPM_COLOR. If the
XpmColorKey attribute is not set it is determined by
examining the type of visual. If no default value exists for
the specified visual, it first looks for other defaults
nearer to the monochrome visual type and secondly nearer to
the color visual type. If the color which is found is not
valid (cannot be parsed), it looks for another default one
according to the same algorithm. If allocating a color
fails, and the closeness attribute is set, it tries to find
a color already in the colormap that is closest to the
desired color, and uses that. If the alloc_close_colors
attribute is set to False, the found close color is not
allocated but it is used anyway. This is especially useful
for applications which use a private colormap containing
read/write cells and have complete control over the
colormap. On the other hand, since in such a case there is
no guarantee that the color pixel will not change any time,
this should be avoided when using the default colormap. If
no color can be found that is within closeness of the Red,
Green, and Blue components of the desired color, it reverts
to trying other default values as explained above. For finer
control over the closeness requirements of a particular
icon, the red_closeness, green_closeness, and blue_closeness
attributes may be used instead of the more general closeness
attribute.</p>

<p style="margin-left:11%; margin-top: 1em">The RGB
components are integers within the range 0 (black) to 65535
(white). A closeness of less than 10000, for example, will
cause only quite close colors to be matched, while a
closeness of more than 50000 will allow quite dissimilar
colors to match. Specifying a closeness of more than 65535
will allow any color to match, thus forcing the icon to be
drawn in color no matter how bad the colormap is. The value
40000 seems to be about right for many situations requiring
reasonable but not perfect matches. With this setting the
color must only be within the same general area of the RGB
cube as the desired color. If the exactColors attribute is
set it then returns <b>XpmColorError</b>, otherwise it
creates the images and returns <b>XpmSuccess</b>. If no
color is found, and no close color exists or is wanted, and
all visuals have been exhausted, <b>XpmColorFailed</b> is
returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>XpmReadFileToImage</b>()
returns the created image to <i>image_return</i> if not NULL
and possibly the created shapemask to
<i>shapeimage_return</i> if not NULL and the color None is
used. If required it stores into the XpmAttributes structure
the list of the used pixels. When the image depth is one,
the image format is either as specified by the bitmap_format
attribute if set or ZPixmap. When the depth is different
from one the image format is always ZPixmap. When finished
the caller must free the images using
<b>XDestroyImage</b>(3), the allocated colors using
<b>XFreeColors</b>(3) or the application equivalent function
when the standard Xlib functions are not used, and possibly
the data returned into the XpmAttributes using
<b>XpmFreeAttributes</b>(3). In addition, on systems which
support such features <b>XpmReadFileToImage</b>() deals with
compressed files by forking an uncompress or gzip process
and reading from the piped result. It assumes that the
specified file is compressed if the given file name ends by
&acirc;.Z&acirc; or &acirc;.gz&acirc;. In case the file name
does not end so, <b>XpmReadFileToImage</b>() looks for the
given file name assuming it is not a compressed file. And if
instead of a file name NULL is passed to
<b>XpmReadFileToImage</b>(), it reads from the standard
input.</p>


<p style="margin-left:11%; margin-top: 1em"><b>XpmReadFileToPixmap</b>
<br>
The <b>XpmReadFileToPixmap</b>() function creates X images
using <b>XpmReadFileToImage</b>() and thus returns the same
errors. In addition on success it then creates the related
pixmaps, using <b>XPutImage</b>(3), which are returned to
<i>pixmap_return</i> and <i>shapemask_return</i> if not
NULL, and finally destroys the created images using
<b>XDestroyImage</b>(3). When finished the caller must free
the pixmaps using <b>XFreePixmap</b>(3), the allocated
colors using <b>XFreeColors</b>(3) or the application
equivalent function when the standard Xlib functions are not
used, and possibly the data returned into the XpmAttributes
using <b>XpmFreeAttributes</b>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b>XpmReadFileToBuffer
<br>
XpmReadFileToBuffer</b>() allocates and fills a buffer from
a file. <b>XpmReadFileToBuffer</b>() returns
<b>XpmOpenFailed</b> if it cannot open the file, returns
<b>XpmNoMemory</b> if insufficient working storage is
allocated, and <b>XpmSuccess</b> otherwise. The allocated
buffer returned by <b>XpmReadFileToBuffer</b>() should be
freed with <b>XpmFree</b>(3) when done.</p>

<p style="margin-left:11%; margin-top: 1em">As a
convenience, the <b>XpmReadFileToBuffer</b>() and
<b>XpmWriteFileFromBuffer</b>(3) are provided to copy a file
to a buffer and to write a file from a buffer. Thus for
instance one may decide to use <b>XpmReadFileToBuffer</b>(),
<b>XpmCreatePixmapFromBuffer</b>(3), and <b>XpmFree</b>(3)
instead of <b>XpmReadFileToPixmap</b>(). On some systems
this may lead to a performance improvement, since the
parsing will be performed in memory, but it uses more
memory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>XpmReadFileToData
<br>
XpmReadFileToData</b>() returns <b>XpmOpenFailed</b> if it
cannot open the file, <b>XpmNoMemory</b> if insufficient
working storage is allocated, <b>XpmFileInvalid</b> if this
is not a valid XPM file, and <b>XpmSuccess</b> otherwise.
The allocated data returned by <b>XpmReadFileToData</b>()
should be freed with <b>XpmFree</b>(3) when done.</p>


<p style="margin-left:11%; margin-top: 1em"><b>XpmReadFileToXpmImage</b>
<br>
The <b>XpmReadFileToXpmImage</b>() function reads in a file
in the XPM format. If the file cannot be opened it returns
<b>XpmOpenFailed</b>. If the file can be opened but does not
contain valid XPM data, it returns <b>XpmFileInvalid</b>. If
insufficient working storage is allocated, it returns
<b>XpmNoMemory</b>. On success it fills in the given
XpmImage structure and returns <b>XpmSuccess</b>.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>XpmCreateBuffer</b>(3),
<b>XpmCreateData</b>(3), <b>XpmCreateImage</b>(3),
<b>XpmCreatePixmap</b>(3), <b>XpmCreateXpmImage</b>(3),
<b>XpmFreeAttributes</b>(3), <b>XpmWrite</b>(3)</p>
<hr>
</body>
</html>
