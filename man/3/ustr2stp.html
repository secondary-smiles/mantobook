<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:24 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>string_copying</title>

</head>
<body>
<h1>ustr2stp</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">stpcpy, strcpy,
strcat, stpecpy, strlcpy, strlcat, stpncpy, strncpy,
zustr2ustp, zustr2stp, strncat, ustpcpy, ustr2stp &minus;
copying strings and character sequences</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Strings</b>
<br>
// Chain-copy a string. <b><br>
char *stpcpy(char *restrict</b> <i>dst</i><b>, const char
*restrict</b> <i>src</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">//
Copy/catenate a string. <b><br>
char *strcpy(char *restrict</b> <i>dst</i><b>, const char
*restrict</b> <i>src</i><b>); <br>
char *strcat(char *restrict</b> <i>dst</i><b>, const char
*restrict</b> <i>src</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">// Chain-copy a
string with truncation. <b><br>
char *stpecpy(char *</b><i>dst</i><b>, char</b>
<i>end</i><b>[0], const char *restrict</b>
<i>src</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">//
Copy/catenate a string with truncation. <b><br>
size_t strlcpy(char</b> <i>dst</i><b>[restrict
.</b><i>sz</i><b>], const char *restrict</b> <i>src</i><b>,
<br>
size_t</b> <i>sz</i><b>); <br>
size_t strlcat(char</b> <i>dst</i><b>[restrict
.</b><i>sz</i><b>], const char *restrict</b> <i>src</i><b>,
<br>
size_t</b> <i>sz</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Null-padded
character sequences</b> <br>
// Zero a fixed-width buffer, and <br>
// copy a string into a character sequence with truncation.
<b><br>
char *stpncpy(char</b> <i>dst</i><b>[restrict
.</b><i>sz</i><b>], const char *restrict</b> <i>src</i><b>,
<br>
size_t</b> <i>sz</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">// Zero a
fixed-width buffer, and <br>
// copy a string into a character sequence with truncation.
<b><br>
char *strncpy(char</b> <i>dest</i><b>[restrict
.</b><i>sz</i><b>], const char *restrict</b> <i>src</i><b>,
<br>
size_t</b> <i>sz</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">// Chain-copy a
null-padded character sequence into a character sequence.
<b><br>
char *zustr2ustp(char *restrict</b> <i>dst</i><b>, const
char</b> <i>src</i><b>[restrict .</b><i>sz</i><b>], <br>
size_t</b> <i>sz</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">// Chain-copy a
null-padded character sequence into a string. <b><br>
char *zustr2stp(char *restrict</b> <i>dst</i><b>, const
char</b> <i>src</i><b>[restrict .</b><i>sz</i><b>], <br>
size_t</b> <i>sz</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">// Catenate a
null-padded character sequence into a string. <b><br>
char *strncat(char *restrict</b> <i>dst</i><b>, const
char</b> <i>src</i><b>[restrict .</b><i>sz</i><b>], <br>
size_t</b> <i>sz</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Measured
character sequences</b> <br>
// Chain-copy a measured character sequence. <b><br>
char *ustpcpy(char *restrict</b> <i>dst</i><b>, const
char</b> <i>src</i><b>[restrict .</b><i>len</i><b>], <br>
size_t</b> <i>len</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">// Chain-copy a
measured character sequence into a string. <b><br>
char *ustr2stp(char *restrict</b> <i>dst</i><b>, const
char</b> <i>src</i><b>[restrict .</b><i>len</i><b>], <br>
size_t</b> <i>len</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Terms (and
abbreviations)</b> <i><br>
string</i> (<i>str</i>)</p>

<p style="margin-left:22%;">is a sequence of zero or more
non-null characters followed by a null byte.</p>

<p style="margin-left:11%;"><i>character sequence</i></p>

<p style="margin-left:22%;">is a sequence of zero or more
non-null characters. A program should never use a character
sequence where a string is required. However, with
appropriate care, a string can be used in the place of a
character sequence. <i><br>
null-padded character sequence</i> (<i>zustr</i>)</p>

<p style="margin-left:32%;">Character sequences can be
contained in fixed-width buffers, which contain padding null
bytes after the character sequence, to fill the rest of the
buffer without affecting the character sequence; however,
those padding null bytes are not part of the character
sequence.</p>

<p style="margin-left:22%;"><i>measured character
sequence</i> (<i>ustr</i>)</p>

<p style="margin-left:32%;">Character sequence delimited by
its length. It may be a slice of a larger character
sequence, or even of a string.</p>

<p style="margin-left:11%;"><i>length</i> (<i>len</i>)</p>

<p style="margin-left:22%;">is the number of non-null
characters in a string or character sequence. It is the
return value of <i>strlen(str)</i> and of <i>strnlen(ustr,
sz)</i>.</p>

<p style="margin-left:11%;"><i>size</i> (<i>sz</i>)</p>

<p style="margin-left:22%;">refers to the entire buffer
where the string or character sequence is contained.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>end</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>is the name of a pointer to one past the last element of
a buffer. It is equivalent to <i>&amp;str[sz]</i>. It is
used as a sentinel value, to be able to truncate strings or
character sequences instead of overrunning the containing
buffer.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><i>copy</i></p></td>
<td width="5%"></td>
<td width="78%">


<p>This term is used when the writing starts at the first
element pointed to by <i>dst</i>.</p></td></tr>
</table>

<p style="margin-left:11%;"><i>catenate</i></p>

<p style="margin-left:22%;">This term is used when a
function first finds the terminating null byte in
<i>dst</i>, and then starts writing at that position.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><i>chain</i></p></td>
<td width="4%"></td>
<td width="78%">


<p>This term is used when it&rsquo;s the programmer who
provides a pointer to the terminating null byte in the
string <i>dst</i> (or one after the last character in a
character sequence), and the function starts writing at that
location. The function returns a pointer to the new location
of the terminating null byte (or one after the last
character in a character sequence) after the call, so that
the programmer can use it to chain such calls.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Copy,
catenate, and chain-copy</b> <br>
Originally, there was a distinction between functions that
copy and those that catenate. However, newer functions that
copy while allowing chaining cover both use cases with a
single API. They are also algorithmically faster, since they
don&rsquo;t need to search for the terminating null byte of
the existing string. However, functions that catenate have a
much simpler use, so if performance is not important, it can
make sense to use them for improving readability.</p>

<p style="margin-left:11%; margin-top: 1em">The pointer
returned by functions that allow chaining is a byproduct of
the copy operation, so it has no performance costs.
Functions that return such a pointer, and thus can be
chained, have names of the form *<b>stp</b>*(), since
it&rsquo;s common to name the pointer just <i>p</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Chain-copying
functions that truncate should accept a pointer to the end
of the destination buffer, and have names of the form
*<b>stpe</b>*(). This allows not having to recalculate the
remaining size after each call.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Truncate or
not?</b> <br>
The first thing to note is that programmers should be
careful with buffers, so they always have the correct size,
and truncation is not necessary.</p>

<p style="margin-left:11%; margin-top: 1em">In most cases,
truncation is not desired, and it is simpler to just do the
copy. Simpler code is safer code. Programming against
programming mistakes by adding more code just adds more
points where mistakes can be made.</p>

<p style="margin-left:11%; margin-top: 1em">Nowadays,
compilers can detect most programmer errors with features
like compiler warnings, static analyzers, and
<b>_FORTIFY_SOURCE</b> (see <b>ftm</b>(7)). Keeping the code
simple helps these overflow-detection features be more
precise.</p>

<p style="margin-left:11%; margin-top: 1em">When validating
user input, however, it makes sense to truncate. Remember to
check the return value of such function calls.</p>

<p style="margin-left:11%; margin-top: 1em">Functions that
truncate:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em"><b>stpecpy</b>(3) is the most
efficient string copy function that performs truncation. It
only requires to check for truncation once after all chained
calls.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>strlcpy</b>(3bsd) and <b>strlcat</b>(3bsd) are
designed to crash if the input string is invalid
(doesn&rsquo;t contain a terminating null byte).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><b>stpncpy</b>(3) and <b>strncpy</b>(3) also truncate,
but they don&rsquo;t write strings, but rather null-padded
character sequences.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Null-padded
character sequences</b> <br>
For historic reasons, some standard APIs, such as
<b>utmpx</b>(5), use null-padded character sequences in
fixed-width buffers. To interface with them, specialized
functions need to be used.</p>

<p style="margin-left:11%; margin-top: 1em">To copy strings
into them, use <b>stpncpy</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">To copy from an
unterminated string within a fixed-width buffer into a
string, ignoring any trailing null bytes in the source
fixed-width buffer, you should use <b>zustr2stp</b>(3) or
<b>strncat</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">To copy from an
unterminated string within a fixed-width buffer into a
character sequence, ignoring any trailing null bytes in the
source fixed-width buffer, you should use
<b>zustr2ustp</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Measured
character sequences</b> <br>
The simplest character sequence copying function is
<b>mempcpy</b>(3). It requires always knowing the length of
your character sequences, for which structures can be used.
It makes the code much faster, since you always know the
length of your character sequences, and can do the minimal
copies and length measurements. <b>mempcpy</b>(3) copies
character sequences, so you need to explicitly set the
terminating null byte if you need a string.</p>

<p style="margin-left:11%; margin-top: 1em">However, for
keeping type safety, it&rsquo;s good to add a wrapper that
uses <i>char&nbsp;*</i> instead of <i>void&nbsp;*</i>:
<b>ustpcpy</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">In programs
that make considerable use of strings or character
sequences, and need the best performance, using overlapping
character sequences can make a big difference. It allows
holding subsequences of a larger character sequence. while
not duplicating memory nor using time to do a copy.</p>

<p style="margin-left:11%; margin-top: 1em">However, this
is delicate, since it requires using character sequences. C
library APIs use strings, so programs that use character
sequences will have to take care of differentiating strings
from character sequences.</p>

<p style="margin-left:11%; margin-top: 1em">To copy a
measured character sequence, use <b>ustpcpy</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">To copy a
measured character sequence into a string, use
<b>ustr2stp</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">Because these
functions ask for the length, and a string is by nature
composed of a character sequence of the same length plus a
terminating null byte, a string is also accepted as
input.</p>

<p style="margin-left:11%; margin-top: 1em"><b>String vs
character sequence</b> <br>
Some functions only operate on strings. Those require that
the input <i>src</i> is a string, and guarantee an output
string (even when truncation occurs). Functions that
catenate also require that <i>dst</i> holds a string before
the call. List of functions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="43%">


<p style="margin-top: 1em"><b>stpcpy</b>(3)</p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="43%">


<p><b>strcpy</b>(3), <b>strcat</b>(3)</p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="43%">


<p><b>stpecpy</b>(3)</p></td>
<td width="42%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="43%">


<p><b>strlcpy</b>(3bsd), <b>strlcat</b>(3bsd)</p></td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Other functions
require an input string, but create a character sequence as
output. These functions have confusing names, and have a
long history of misuse. List of functions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="16%">


<p style="margin-top: 1em"><b>stpncpy</b>(3)</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="16%">


<p><b>strncpy</b>(3)</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Other functions
operate on an input character sequence, and create an output
string. Functions that catenate also require that <i>dst</i>
holds a string before the call. <b>strncat</b>(3) has an
even more misleading name than the functions above. List of
functions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="19%">


<p style="margin-top: 1em"><b>zustr2stp</b>(3)</p></td>
<td width="66%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="19%">


<p><b>strncat</b>(3)</p></td>
<td width="66%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="19%">


<p><b>ustr2stp</b>(3)</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Other functions
operate on an input character sequence to create an output
character sequence. List of functions:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="19%">


<p style="margin-top: 1em"><b>ustpcpy</b>(3)</p></td>
<td width="66%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="19%">


<p><b>zustr2stp</b>(3)</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Functions
<br>
stpcpy</b>(3)</p>

<p style="margin-left:22%;">This function copies the input
string into a destination string. The programmer is
responsible for allocating a buffer large enough. It returns
a pointer suitable for chaining.</p>

<p style="margin-left:11%;"><b>strcpy</b>(3) <b><br>
strcat</b>(3)</p>

<p style="margin-left:22%;">These functions copy and
catenate the input string into a destination string. The
programmer is responsible for allocating a buffer large
enough. The return value is useless.</p>


<p style="margin-left:22%; margin-top: 1em"><b>stpcpy</b>(3)
is a faster alternative to these functions.</p>

<p style="margin-left:11%;"><b>stpecpy</b>(3)</p>

<p style="margin-left:22%;">This function copies the input
string into a destination string. If the destination buffer,
limited by a pointer to its end, isn&rsquo;t large enough to
hold the copy, the resulting string is truncated (but it is
guaranteed to be null-terminated). It returns a pointer
suitable for chaining. Truncation needs to be detected only
once after the last chained call.</p>

<p style="margin-left:22%; margin-top: 1em">This function
is not provided by any library; See EXAMPLES for a reference
implementation.</p>

<p style="margin-left:11%;"><b>strlcpy</b>(3bsd) <b><br>
strlcat</b>(3bsd)</p>

<p style="margin-left:22%;">These functions copy and
catenate the input string into a destination string. If the
destination buffer, limited by its size, isn&rsquo;t large
enough to hold the copy, the resulting string is truncated
(but it is guaranteed to be null-terminated). They return
the length of the total string they tried to create. These
functions force a SIGSEGV if the <i>src</i> pointer is not a
string.</p>


<p style="margin-left:22%; margin-top: 1em"><b>stpecpy</b>(3)
is a simpler alternative to these functions.</p>

<p style="margin-left:11%;"><b>stpncpy</b>(3)</p>

<p style="margin-left:22%;">This function copies the input
string into a destination null-padded character sequence in
a fixed-width buffer. If the destination buffer, limited by
its size, isn&rsquo;t large enough to hold the copy, the
resulting character sequence is truncated. Since it creates
a character sequence, it doesn&rsquo;t need to write a
terminating null byte. It&rsquo;s impossible to distinguish
truncation by the result of the call, from a character
sequence that just fits the destination buffer; truncation
should be detected by comparing the length of the input
string with the size of the destination buffer.</p>

<p style="margin-left:11%;"><b>strncpy</b>(3)</p>

<p style="margin-left:22%;">This function is identical to
<b>stpncpy</b>(3) except for the useless return value.</p>


<p style="margin-left:22%; margin-top: 1em"><b>stpncpy</b>(3)
is a more useful alternative to this function.</p>

<p style="margin-left:11%;"><b>zustr2ustp</b>(3)</p>

<p style="margin-left:22%;">This function copies the input
character sequence contained in a null-padded wixed-width
buffer, into a destination character sequence. The
programmer is responsible for allocating a buffer large
enough. It returns a pointer suitable for chaining.</p>

<p style="margin-left:22%; margin-top: 1em">A truncating
version of this function doesn&rsquo;t exist, since the size
of the original character sequence is always known, so it
wouldn&rsquo;t be very useful.</p>

<p style="margin-left:22%; margin-top: 1em">This function
is not provided by any library; See EXAMPLES for a reference
implementation.</p>

<p style="margin-left:11%;"><b>zustr2stp</b>(3)</p>

<p style="margin-left:22%;">This function copies the input
character sequence contained in a null-padded wixed-width
buffer, into a destination string. The programmer is
responsible for allocating a buffer large enough. It returns
a pointer suitable for chaining.</p>

<p style="margin-left:22%; margin-top: 1em">A truncating
version of this function doesn&rsquo;t exist, since the size
of the original character sequence is always known, so it
wouldn&rsquo;t be very useful.</p>

<p style="margin-left:22%; margin-top: 1em">This function
is not provided by any library; See EXAMPLES for a reference
implementation.</p>

<p style="margin-left:11%;"><b>strncat</b>(3)</p>

<p style="margin-left:22%;">Do not confuse this function
with <b>strncpy</b>(3); they are not related at all.</p>

<p style="margin-left:22%; margin-top: 1em">This function
catenates the input character sequence contained in a
null-padded wixed-width buffer, into a destination string.
The programmer is responsible for allocating a buffer large
enough. The return value is useless.</p>


<p style="margin-left:22%; margin-top: 1em"><b>zustr2stp</b>(3)
is a faster alternative to this function.</p>

<p style="margin-left:11%;"><b>ustpcpy</b>(3)</p>

<p style="margin-left:22%;">This function copies the input
character sequence, limited by its length, into a
destination character sequence. The programmer is
responsible for allocating a buffer large enough. It returns
a pointer suitable for chaining.</p>

<p style="margin-left:11%;"><b>ustr2stp</b>(3)</p>

<p style="margin-left:22%;">This function copies the input
character sequence, limited by its length, into a
destination string. The programmer is responsible for
allocating a buffer large enough. It returns a pointer
suitable for chaining.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
functions return a pointer to the terminating null byte in
the destination string.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="19%">


<p><b>stpcpy</b>(3)</p></td>
<td width="66%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="19%">


<p><b>ustr2stp</b>(3)</p></td>
<td width="66%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="19%">


<p><b>zustr2stp</b>(3)</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
function returns a pointer to the terminating null byte in
the destination string, except when truncation occurs; if
truncation occurs, it returns a pointer to the end of the
destination buffer.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="16%">


<p style="margin-top: 1em"><b>stpecpy</b>(3)</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
function returns a pointer to one after the last character
in the destination character sequence; if truncation occurs,
that pointer is equivalent to a pointer to the end of the
destination buffer.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="16%">


<p style="margin-top: 1em"><b>stpncpy</b>(3)</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
functions return a pointer to one after the last character
in the destination character sequence.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="20%">


<p style="margin-top: 1em"><b>zustr2ustp</b>(3)</p></td>
<td width="65%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="20%">


<p><b>ustpcpy</b>(3)</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
functions return the length of the total string that they
tried to create (as if truncation didn&rsquo;t occur).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="43%">


<p style="margin-top: 1em"><b>strlcpy</b>(3bsd),
<b>strlcat</b>(3bsd)</p> </td>
<td width="42%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The following
functions return the <i>dst</i> pointer, which is
useless.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="31%">


<p style="margin-top: 1em"><b>strcpy</b>(3),
<b>strcat</b>(3)</p> </td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="31%">


<p><b>strncpy</b>(3)</p></td>
<td width="54%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="31%">


<p><b>strncat</b>(3)</p></td>
<td width="54%">
</td></tr>
</table>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Linux
kernel has an internal function for copying strings, which
is similar to <b>stpecpy</b>(3), except that it can&rsquo;t
be chained: <b><br>
strscpy</b>(9)</p>

<p style="margin-left:22%;">This function copies the input
string into a destination string. If the destination buffer,
limited by its size, isn&rsquo;t large enough to hold the
copy, the resulting string is truncated (but it is
guaranteed to be null-terminated). It returns the length of
the destination string, or <b>&minus;E2BIG</b> on
truncation.</p>


<p style="margin-left:22%; margin-top: 1em"><b>stpecpy</b>(3)
is a simpler and faster alternative to this function.</p>

<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Don&rsquo;t mix
chain calls to truncating and non-truncating functions. It
is conceptually wrong unless you know that the first part of
a copy will always fit. Anyway, the performance difference
will probably be negligible, so it will probably be more
clear if you use consistent semantics: either truncating or
non-truncating. Calling a non-truncating function after a
truncating one is necessarily wrong.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All catenation
functions share the same performance problem:
<a href="https://www.joelonsoftware.com/2001/12/11/back-to-basics/">Shlemiel
the&Acirc;&nbsp;painter</a>.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
are examples of correct use of each of these functions.
<b><br>
stpcpy</b>(3)</p>

<p style="margin-left:22%;">p = buf; <br>
p = stpcpy(p, &quot;Hello &quot;); <br>
p = stpcpy(p, &quot;world&quot;); <br>
p = stpcpy(p, &quot;!&quot;); <br>
len = p &minus; buf; <br>
puts(buf);</p>

<p style="margin-left:11%;"><b>strcpy</b>(3) <b><br>
strcat</b>(3)</p>

<p style="margin-left:22%;">strcpy(buf, &quot;Hello
&quot;); <br>
strcat(buf, &quot;world&quot;); <br>
strcat(buf, &quot;!&quot;); <br>
len = strlen(buf); <br>
puts(buf);</p>

<p style="margin-left:11%;"><b>stpecpy</b>(3)</p>

<p style="margin-left:22%;">end = buf + sizeof(buf); <br>
p = buf; <br>
p = stpecpy(p, end, &quot;Hello &quot;); <br>
p = stpecpy(p, end, &quot;world&quot;); <br>
p = stpecpy(p, end, &quot;!&quot;); <br>
if (p == end) { <br>
p&minus;&minus;; <br>
goto toolong; <br>
} <br>
len = p &minus; buf; <br>
puts(buf);</p>

<p style="margin-left:11%;"><b>strlcpy</b>(3bsd) <b><br>
strlcat</b>(3bsd)</p>

<p style="margin-left:22%;">if (strlcpy(buf, &quot;Hello
&quot;, sizeof(buf)) &gt;= sizeof(buf)) <br>
goto toolong; <br>
if (strlcat(buf, &quot;world&quot;, sizeof(buf)) &gt;=
sizeof(buf)) <br>
goto toolong; <br>
len = strlcat(buf, &quot;!&quot;, sizeof(buf)); <br>
if (len &gt;= sizeof(buf)) <br>
goto toolong; <br>
puts(buf);</p>

<p style="margin-left:11%;"><b>strscpy</b>(9)</p>

<p style="margin-left:22%;">len = strscpy(buf, &quot;Hello
world!&quot;, sizeof(buf)); <br>
if (len == &minus;E2BIG) <br>
goto toolong; <br>
puts(buf);</p>

<p style="margin-left:11%;"><b>stpncpy</b>(3)</p>

<p style="margin-left:22%;">p = stpncpy(buf, &quot;Hello
world!&quot;, sizeof(buf)); <br>
if (sizeof(buf) &lt; strlen(&quot;Hello world!&quot;)) <br>
goto toolong; <br>
len = p &minus; buf; <br>
for (size_t i = 0; i &lt; sizeof(buf); i++) <br>
putchar(buf[i]);</p>

<p style="margin-left:11%;"><b>strncpy</b>(3)</p>

<p style="margin-left:22%;">strncpy(buf, &quot;Hello
world!&quot;, sizeof(buf)); <br>
if (sizeof(buf) &lt; strlen(&quot;Hello world!&quot;)) <br>
goto toolong; <br>
len = strnlen(buf, sizeof(buf)); <br>
for (size_t i = 0; i &lt; sizeof(buf); i++) <br>
putchar(buf[i]);</p>

<p style="margin-left:11%;"><b>zustr2ustp</b>(3)</p>

<p style="margin-left:22%;">p = buf; <br>
p = zustr2ustp(p, &quot;Hello &quot;, 6); <br>
p = zustr2ustp(p, &quot;world&quot;, 42); // Padding null
bytes ignored. <br>
p = zustr2ustp(p, &quot;!&quot;, 1); <br>
len = p &minus; buf; <br>
printf(&quot;%.*s\n&quot;, (int) len, buf);</p>

<p style="margin-left:11%;"><b>zustr2stp</b>(3)</p>

<p style="margin-left:22%;">p = buf; <br>
p = zustr2stp(p, &quot;Hello &quot;, 6); <br>
p = zustr2stp(p, &quot;world&quot;, 42); // Padding null
bytes ignored. <br>
p = zustr2stp(p, &quot;!&quot;, 1); <br>
len = p &minus; buf; <br>
puts(buf);</p>

<p style="margin-left:11%;"><b>strncat</b>(3)</p>

<p style="margin-left:22%;">buf[0] = '\0'; // There&rsquo;s
no &rsquo;cpy&rsquo; function to this &rsquo;cat&rsquo;.
<br>
strncat(buf, &quot;Hello &quot;, 6); <br>
strncat(buf, &quot;world&quot;, 42); // Padding null bytes
ignored. <br>
strncat(buf, &quot;!&quot;, 1); <br>
len = strlen(buf); <br>
puts(buf);</p>

<p style="margin-left:11%;"><b>ustpcpy</b>(3)</p>

<p style="margin-left:22%;">p = buf; <br>
p = ustpcpy(p, &quot;Hello &quot;, 6); <br>
p = ustpcpy(p, &quot;world&quot;, 5); <br>
p = ustpcpy(p, &quot;!&quot;, 1); <br>
len = p &minus; buf; <br>
printf(&quot;%.*s\n&quot;, (int) len, buf);</p>

<p style="margin-left:11%;"><b>ustr2stp</b>(3)</p>

<p style="margin-left:22%;">p = buf; <br>
p = ustr2stp(p, &quot;Hello &quot;, 6); <br>
p = ustr2stp(p, &quot;world&quot;, 5); <br>
p = ustr2stp(p, &quot;!&quot;, 1); <br>
len = p &minus; buf; <br>
puts(buf);</p>


<p style="margin-left:11%; margin-top: 1em"><b>Implementations</b>
<br>
Here are reference implementations for functions not
provided by libc.</p>

<p style="margin-left:17%; margin-top: 1em">/* This code is
in the public domain. */</p>

<p style="margin-left:17%; margin-top: 1em">char * <i><br>
stpecpy</i>(char *dst, char end[0], const char *restrict
src) <br>
{ <br>
char *p;</p>

<p style="margin-left:17%; margin-top: 1em">if (dst ==
NULL) <br>
return NULL; <br>
if (dst == end) <br>
return end;</p>

<p style="margin-left:17%; margin-top: 1em">p =
memccpy(dst, src, '\0', end &minus; dst); <br>
if (p != NULL) <br>
return p &minus; 1;</p>

<p style="margin-left:17%; margin-top: 1em">/* truncation
detected */ <br>
end[&minus;1] = '\0'; <br>
return end; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">char * <i><br>
zustr2ustp</i>(char *restrict dst, const char *restrict src,
size_t sz) <br>
{ <br>
return ustpcpy(dst, src, strnlen(src, sz)); <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">char * <i><br>
zustr2stp</i>(char *restrict dst, const char *restrict src,
size_t sz) <br>
{ <br>
char *p;</p>

<p style="margin-left:17%; margin-top: 1em">p =
zustr2ustp(dst, src, sz); <br>
*p = '\0';</p>

<p style="margin-left:17%; margin-top: 1em">return p; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">char * <i><br>
ustpcpy</i>(char *restrict dst, const char *restrict src,
size_t len) <br>
{ <br>
return mempcpy(dst, src, len); <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">char * <i><br>
ustr2stp</i>(char *restrict dst, const char *restrict src,
size_t len) <br>
{ <br>
char *p;</p>

<p style="margin-left:17%; margin-top: 1em">p =
ustpcpy(dst, src, len); <br>
*p = '\0';</p>

<p style="margin-left:17%; margin-top: 1em">return p; <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>bzero</b>(3),
<b>memcpy</b>(3), <b>memccpy</b>(3), <b>mempcpy</b>(3),
<b>stpcpy</b>(3), <b>strlcpy</b>(3bsd), <b>strncat</b>(3),
<b>stpncpy</b>(3), <b>string</b>(3)</p>
<hr>
</body>
</html>
