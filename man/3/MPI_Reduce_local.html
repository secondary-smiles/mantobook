<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:35 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_Reduce_local</title>

</head>
<body>
<h1>MPI_Reduce_local</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_Reduce_local</b>
&minus; Perform a local reduction</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_Reduce_local(const void *<i>inbuf</i>, void
*<i>inoutbuf</i>, int <i>count</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>MPI_Datatype <i>datatype</i>, MPI_Op <i>op</i>)</p></td></tr>
</table>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_REDUCE_LOCAL(<i>INBUF, INOUTBUF, COUNT, DATATYPE, OP,
IERROR</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>&lt;type&gt;</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>INBUF(*), INOUTBUF(*)</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p><i>COUNT, DATATYPE, OP, IERROR</i></p></td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_Reduce_local(<i>inbuf</i>, <i>inoutbuf</i>,
<i>count</i>, <i>datatype</i>, <i>op</i>, <i>ierror</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(*), DIMENSION(..), INTENT(IN) :: <i>inbuf</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(*), DIMENSION(..) :: <i>inoutbuf</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, INTENT(IN) :: <i>count</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Datatype), INTENT(IN) :: <i>datatype</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Op), INTENT(IN) :: <i>op</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
void MPI::Op::Reduce_local(const void* <i>inbuf</i>, void*
<i>inoutbuf</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>int <i>count</i>, const MPI::Datatype&amp;
<i>datatype</i>, const MPI::Op&amp; <i>op</i>) const</p></td></tr>
</table>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">inbuf</p></td>
<td width="3%"></td>
<td width="72%">


<p style="margin-top: 1em">Address of input buffer
(choice).</p> </td>
<td width="2%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>count</p></td>
<td width="3%"></td>
<td width="72%">


<p>Number of elements in input buffer (integer).</p></td>
<td width="2%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>datatype</p></td>
<td width="3%"></td>
<td width="72%">


<p>Data type of elements of input buffer (handle).</p></td>
<td width="2%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>op</p></td>
<td width="3%"></td>
<td width="72%">


<p>Reduce operation (handle).</p></td>
<td width="2%">
</td></tr>
</table>

<h2>OUTPUT PARAMETERS
<a name="OUTPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">inoutbuf</p></td>
<td width="3%"></td>
<td width="57%">


<p style="margin-top: 1em">Address of in/out buffer
(choice).</p> </td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>IERROR</p></td>
<td width="3%"></td>
<td width="57%">


<p>Fortran only: Error status (integer).</p></td>
<td width="17%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The global
reduce functions (MPI_Reduce_local, MPI_Op_create,
MPI_Op_free, MPI_Allreduce, MPI_Reduce_local_scatter,
MPI_Scan) perform a global reduce operation (such as sum,
max, logical AND, etc.) across all the members of a group.
The reduction operation can be either one of a predefined
list of operations, or a user-defined operation. The global
reduction functions come in several flavors: a reduce that
returns the result of the reduction at one node, an
all-reduce that returns this result at all nodes, and a scan
(parallel prefix) operation. In addition, a reduce-scatter
operation combines the functionality of a reduce and a
scatter operation.</p>


<p style="margin-left:11%; margin-top: 1em">MPI_Reduce_local
combines the elements provided in the input and input/output
buffers of the local process, using the operation op, and
returns the combined value in the inout/output buffer. The
input buffer is defined by the arguments inbuf, count, and
datatype; the output buffer is defined by the arguments
inoutbuf, count, and datatype; both have the same number of
elements, with the same type. The routine is a local call.
The process can provide one element, or a sequence of
elements, in which case the combine operation is executed
element-wise on each entry of the sequence. For example, if
the operation is MPI_MAX and the input buffer contains two
elements that are floating-point numbers (count = 2 and
datatype = MPI_FLOAT), then inoutbuf(1) = global max
(inbuf(1)) and inoutbuf(2) = global max(inbuf(2)).</p>

<h2>USE OF IN-PLACE OPTION
<a name="USE OF IN-PLACE OPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The use of
MPI_IN_PLACE is disallowed with MPI_Reduce_local.</p>

<h2>PREDEFINED REDUCE OPERATIONS
<a name="PREDEFINED REDUCE OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The set of
predefined operations provided by MPI is listed below
(Predefined Reduce Operations). That section also enumerates
the datatypes each operation can be applied to. In addition,
users may define their own operations that can be overloaded
to operate on several datatypes, either basic or derived.
This is further explained in the description of the
user-defined operations (see the man pages for MPI_Op_create
and MPI_Op_free).</p>

<p style="margin-left:11%; margin-top: 1em">The operation
op is always assumed to be associative. All predefined
operations are also assumed to be commutative. Users may
define operations that are assumed to be associative, but
not commutative. The &lsquo;&lsquo;canonical&rsquo;&rsquo;
evaluation order of a reduction is determined by the ranks
of the processes in the group. However, the implementation
can take advantage of associativity, or associativity and
commutativity, in order to change the order of evaluation.
This may change the result of the reduction for operations
that are not strictly associative and commutative, such as
floating point addition.</p>

<p style="margin-left:11%; margin-top: 1em">Predefined
operators work only with the MPI types listed below
(Predefined Reduce Operations, and the section MINLOC and
MAXLOC, below). User-defined operators may operate on
general, derived datatypes. In this case, each argument that
the reduce operation is applied to is one element described
by such a datatype, which may contain several basic values.
This is further explained in Section 4.9.4 of the MPI
Standard, &quot;User-Defined Operations.&quot;</p>

<p style="margin-left:11%; margin-top: 1em">The following
predefined operations are supplied for MPI_Reduce_local and
related functions MPI_Allreduce, MPI_Reduce_scatter, and
MPI_Scan. These operations are invoked by placing the
following in op:</p>

<p style="margin-left:11%; margin-top: 1em">Name Meaning
<br>
--------- --------------------</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_MAX maximum</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_MIN minimum</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_SUM sum</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_PROD product</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_LAND logical and</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_BAND bit-wise and</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_LOR logical or</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_BOR bit-wise or</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_LXOR logical xor</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_BXOR bit-wise xor</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_MAXLOC max value and location</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_MINLOC min value and location</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The two
operations MPI_MINLOC and MPI_MAXLOC are discussed
separately below (MINLOC and MAXLOC). For the other
predefined operations, we enumerate below the allowed
combinations of op and datatype arguments. First, define
groups of MPI basic datatypes in the following way:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>C integer: MPI_INT, MPI_LONG, MPI_SHORT,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_UNSIGNED_SHORT, MPI_UNSIGNED,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_UNSIGNED_LONG</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Fortran integer: MPI_INTEGER</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Floating-point: MPI_FLOAT, MPI_DOUBLE, MPI_REAL,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>MPI_DOUBLE_PRECISION, MPI_LONG_DOUBLE</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Logical: MPI_LOGICAL</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Complex: MPI_COMPLEX</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>Byte: MPI_BYTE</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Now, the valid
datatypes for each option is specified below.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>Op</p></td>
<td width="31%"></td>
<td width="8%"></td>
<td width="46%">


<p>Allowed Types</p></td></tr>
</table>

<p style="margin-left:11%;">----------------
---------------------------</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>MPI_MAX, MPI_MIN</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="46%">


<p>C integer, Fortran integer,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="46%">


<p>floating-point</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>MPI_SUM, MPI_PROD</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="46%">


<p>C integer, Fortran integer,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="46%">


<p>floating-point, complex</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>MPI_LAND, MPI_LOR,</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="46%">


<p>C integer, logical</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>MPI_LXOR</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">


<p>MPI_BAND, MPI_BOR,</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%">
</td>
<td width="46%">


<p>C integer, Fortran integer, byte</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>MPI_BXOR</p></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="46%">
</td></tr>
</table>

<h2>MINLOC AND MAXLOC
<a name="MINLOC AND MAXLOC"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The operator
MPI_MINLOC is used to compute a global minimum and also an
index attached to the minimum value. MPI_MAXLOC similarly
computes a global maximum and index. One application of
these is to compute a global minimum (maximum) and the rank
of the process containing this value.</p>

<p style="margin-left:11%; margin-top: 1em">The operation
that defines MPI_MAXLOC is</p>

<p style="margin-left:11%; margin-top: 1em">( u ) ( v ) ( w
) <br>
( ) o ( ) = ( ) <br>
( i ) ( j ) ( k )</p>

<p style="margin-left:11%; margin-top: 1em">where</p>

<p style="margin-left:11%; margin-top: 1em">w = max(u,
v)</p>

<p style="margin-left:11%; margin-top: 1em">and</p>

<p style="margin-left:11%; margin-top: 1em">( i if u &gt; v
<br>
( <br>
k = ( min(i, j) if u = v <br>
( <br>
( j if u &lt; v)</p>

<p style="margin-left:11%; margin-top: 1em">MPI_MINLOC is
defined similarly:</p>

<p style="margin-left:11%; margin-top: 1em">( u ) ( v ) ( w
) <br>
( ) o ( ) = ( ) <br>
( i ) ( j ) ( k )</p>

<p style="margin-left:11%; margin-top: 1em">where</p>

<p style="margin-left:11%; margin-top: 1em">w = min(u,
v)</p>

<p style="margin-left:11%; margin-top: 1em">and</p>

<p style="margin-left:11%; margin-top: 1em">( i if u &lt; v
<br>
( <br>
k = ( min(i, j) if u = v <br>
( <br>
( j if u &gt; v)</p>

<p style="margin-left:11%; margin-top: 1em">Both operations
are associative and commutative. Note that if MPI_MAXLOC is
applied to reduce a sequence of pairs (u(0), 0), (u(1),
1),&nbsp;..., (u(n-1), n-1), then the value returned is (u ,
r), where u= max(i) u(i) and r is the index of the first
global maximum in the sequence. Thus, if each process
supplies a value and its rank within the group, then a
reduce operation with op = MPI_MAXLOC will return the
maximum value and the rank of the first process with that
value. Similarly, MPI_MINLOC can be used to return a minimum
and its index. More generally, MPI_MINLOC computes a
lexicographic minimum, where elements are ordered according
to the first component of each pair, and ties are resolved
according to the second component.</p>

<p style="margin-left:11%; margin-top: 1em">The reduce
operation is defined to operate on arguments that consist of
a pair: value and index. For both Fortran and C, types are
provided to describe the pair. The potentially mixed-type
nature of such arguments is a problem in Fortran. The
problem is circumvented, for Fortran, by having the
MPI-provided type consist of a pair of the same type as
value, and coercing the index to this type also. In C, the
MPI-provided pair type has distinct types and the index is
an int.</p>

<p style="margin-left:11%; margin-top: 1em">In order to use
MPI_MINLOC and MPI_MAXLOC in a reduce operation, one must
provide a datatype argument that represents a pair (value
and index). MPI provides nine such predefined datatypes. The
operations MPI_MAXLOC and MPI_MINLOC can be used with each
of the following datatypes:</p>

<p style="margin-left:11%; margin-top: 1em">Fortran: <br>
Name Description <br>
MPI_2REAL pair of REALs <br>
MPI_2DOUBLE_PRECISION pair of DOUBLE-PRECISION variables
<br>
MPI_2INTEGER pair of INTEGERs</p>

<p style="margin-left:11%; margin-top: 1em">C:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">


<p>Name</p><td width="17%"></td>
<td width="-9%"></td>
<td width="23%"></td>
<td width="7%"></td>
<td width="8%">
</td>
<td width="54%">


<p>Description</p></td></tr>
</table>

<p style="margin-left:11%;">MPI_FLOAT_INT float and int
<br>
MPI_DOUBLE_INT double and int <br>
MPI_LONG_INT long and int <br>
MPI_2INT pair of ints <br>
MPI_SHORT_INT short and int <br>
MPI_LONG_DOUBLE_INT long double and int</p>

<p style="margin-left:11%; margin-top: 1em">The data type
MPI_2REAL is equivalent to: <br>
MPI_TYPE_CONTIGUOUS(2, MPI_REAL, MPI_2REAL)</p>

<p style="margin-left:11%; margin-top: 1em">Similar
statements apply for MPI_2INTEGER, MPI_2DOUBLE_PRECISION,
and MPI_2INT.</p>

<p style="margin-left:11%; margin-top: 1em">The datatype
MPI_FLOAT_INT is as if defined by the following sequence of
instructions.</p>

<p style="margin-left:11%; margin-top: 1em">type[0] =
MPI_FLOAT <br>
type[1] = MPI_INT <br>
disp[0] = 0 <br>
disp[1] = sizeof(float) <br>
block[0] = 1 <br>
block[1] = 1 <br>
MPI_TYPE_STRUCT(2, block, disp, type, MPI_FLOAT_INT)</p>

<p style="margin-left:11%; margin-top: 1em">Similar
statements apply for MPI_LONG_INT and MPI_DOUBLE_INT.</p>

<p style="margin-left:11%; margin-top: 1em">All MPI objects
(e.g., MPI_Datatype, MPI_Comm) are of type INTEGER in
Fortran.</p>

<h2>NOTES ON COLLECTIVE OPERATIONS
<a name="NOTES ON COLLECTIVE OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The reduction
operators ( <i>MPI_Op</i> ) do not return an error value. As
a result, if the functions detect an error, all they can do
is either call <i>MPI_Abort</i> or silently skip the
problem. Thus, if you change the error handler from
<i>MPI_ERRORS_ARE_FATAL</i> to something else, for example,
<i>MPI_ERRORS_RETURN</i> , then no error may be
indicated.</p>

<p style="margin-left:11%; margin-top: 1em">The reason for
this is the performance problems in ensuring that all
collective routines return the same error value.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job,
except for I/O function errors. The error handler may be
changed with MPI_Comm_set_errhandler; the predefined error
handler MPI_ERRORS_RETURN may be used to cause error values
to be returned. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_Allreduce
<br>
MPI_Reduce <br>
MPI_Reduce_scatter <br>
MPI_Scan <br>
MPI_Op_create <br>
 MPI_Op_free</p>
<hr>
</body>
</html>
