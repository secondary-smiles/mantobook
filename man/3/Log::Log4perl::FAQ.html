<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:32 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FAQ</title>

</head>
<body>
<h1>Log::Log4perl::FAQ</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Log::Log4perl::FAQ
&minus; Frequently Asked Questions on Log::Log4perl</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This
<small>FAQ</small> shows a wide variety of commonly
encountered logging tasks and how to solve them in the most
elegant way with Log::Log4perl. Most of the time, this will
be just a matter of smartly configuring your Log::Log4perl
configuration files.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why use
Log::Log4perl instead of any other logging module on
<small>CPAN</small> ?</b> <br>
That&rsquo;s a good question. There&rsquo;s dozens of
logging modules on <small>CPAN.</small> When it comes to
logging, people typically think: &quot;Aha. Writing out
debug and error messages. Debug is lower than error. Easy.
I&rsquo;m gonna write my own.&quot; Writing a logging module
is like a rite of passage for every Perl programmer, just
like writing your own templating system.</p>

<p style="margin-left:11%; margin-top: 1em">Of course,
after getting the basics right, features need to be added.
You&rsquo;d like to write a timestamp with every message.
Then timestamps with microseconds. Then messages need to be
written to both the screen and a log file.</p>

<p style="margin-left:11%; margin-top: 1em">And, as your
application grows in size you might wonder: Why
doesn&rsquo;t my logging system scale along with it? You
would like to switch on logging in selected parts of the
application, and not all across the board, because this
kills performance. This is when people turn to
Log::Log4perl, because it handles all of that.</p>

<p style="margin-left:11%; margin-top: 1em">Avoid this
costly switch.</p>

<p style="margin-left:11%; margin-top: 1em">Use
&quot;Log::Log4perl&quot; right from the start.
&quot;Log::Log4perl&quot;&rsquo;s &quot;:easy&quot; mode
supports easy logging in simple scripts:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init($DEBUG); <br>
DEBUG &quot;A low&minus;level message&quot;; <br>
ERROR &quot;Won't make it until level gets increased to
ERROR&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">And when your
application inevitably grows, your logging system grows with
it without you having to change any code.</p>

<p style="margin-left:11%; margin-top: 1em">Please,
don&rsquo;t re-invent logging. &quot;Log::Log4perl&quot; is
here, it&rsquo;s easy to use, it scales, and covers many
areas you haven&rsquo;t thought of yet, but will enter
soon.</p>


<p style="margin-left:11%; margin-top: 1em"><b>What&rsquo;s
the easiest way to use Log4perl?</b> <br>
If you just want to get all the comfort of logging, without
much overhead, use <i>Stealth Loggers</i>. If you use
Log::Log4perl in &quot;:easy&quot; mode like</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy);</p>

<p style="margin-left:11%; margin-top: 1em">you&rsquo;ll
have the following functions available in the current
package:</p>


<p style="margin-left:11%; margin-top: 1em">DEBUG(&quot;message&quot;);
<br>
INFO(&quot;message&quot;); <br>
WARN(&quot;message&quot;); <br>
ERROR(&quot;message&quot;); <br>
FATAL(&quot;message&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">Just make sure
that every package of your code where you&rsquo;re using
them in pulls in &quot;use Log::Log4perl qw(:easy)&quot;
first, then you&rsquo;re set. Every stealth logger&rsquo;s
category will be equivalent to the name of the package
it&rsquo;s located in.</p>

<p style="margin-left:11%; margin-top: 1em">These stealth
loggers will be absolutely silent until you initialize
Log::Log4perl in your main program with either</p>

<p style="margin-left:11%; margin-top: 1em"># Define any
Log4perl behavior <br>
Log::Log4perl&minus;&gt;init(&quot;foo.conf&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">(using a
full-blown Log4perl config file) or the super-easy
method</p>

<p style="margin-left:11%; margin-top: 1em"># Just log to
STDERR <br>
Log::Log4perl&minus;&gt;easy_init($DEBUG);</p>

<p style="margin-left:11%; margin-top: 1em">or the
parameter-style method with a complexity somewhat in
between:</p>

<p style="margin-left:11%; margin-top: 1em"># Append to a
log file <br>
Log::Log4perl&minus;&gt;easy_init( { level =&gt; $DEBUG,
<br>
file =&gt; &quot;&gt;&gt;test.log&quot; } );</p>

<p style="margin-left:11%; margin-top: 1em">For more info,
please check out &quot;Stealth Loggers&quot; in
Log::Log4perl.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
simply log all my <small>ERROR</small> messages to a
file?</b> <br>
After pulling in the &quot;Log::Log4perl&quot; module, just
initialize its behavior by passing in a configuration to its
&quot;init&quot; method as a string reference. Then, obtain
a logger instance and write out a message with its
&quot;error()&quot; method:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(get_logger); <br>
# Define configuration <br>
my $conf = q( <br>
log4perl.logger = ERROR, FileApp <br>
log4perl.appender.FileApp = Log::Log4perl::Appender::File
<br>
log4perl.appender.FileApp.filename = test.log <br>
log4perl.appender.FileApp.layout = PatternLayout <br>
log4perl.appender.FileApp.layout.ConversionPattern = %d&gt;
%m%n <br>
); <br>
# Initialize logging behavior <br>
Log::Log4perl&minus;&gt;init( \$conf ); <br>
# Obtain a logger instance <br>
my $logger = get_logger(&quot;Bar::Twix&quot;); <br>
$logger&minus;&gt;error(&quot;Oh my, a dreadful
error!&quot;); <br>
$logger&minus;&gt;warn(&quot;Oh my, a dreadful
warning!&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">This will
append something like</p>

<p style="margin-left:11%; margin-top: 1em">2002/10/29
20:11:55&gt; Oh my, a dreadful error!</p>

<p style="margin-left:11%; margin-top: 1em">to the log file
&quot;test.log&quot;. How does this all work?</p>

<p style="margin-left:11%; margin-top: 1em">While the
Log::Log4perl &quot;init()&quot; method typically takes the
name of a configuration file as its input parameter like
in</p>


<p style="margin-left:11%; margin-top: 1em">Log::Log4perl&minus;&gt;init(
&quot;/path/mylog.conf&quot; );</p>

<p style="margin-left:11%; margin-top: 1em">the example
above shows how to pass in a configuration as text in a
scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">The
configuration as shown defines a logger of the root
category, which has an appender of type
&quot;Log::Log4perl::Appender::File&quot; attached. The
line</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= ERROR, FileApp</p>

<p style="margin-left:11%; margin-top: 1em">doesn&rsquo;t
list a category, defining a root logger. Compare that
with</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger.Bar.Twix
= ERROR, FileApp</p>

<p style="margin-left:11%; margin-top: 1em">which would
define a logger for the category &quot;Bar::Twix&quot;,
showing probably different behavior. &quot;FileApp&quot; on
the right side of the assignment is an arbitrarily defined
variable name, which is only used to somehow reference an
appender defined later on.</p>

<p style="margin-left:11%; margin-top: 1em">Appender
settings in the configuration are defined as follows:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.FileApp
= Log::Log4perl::Appender::File <br>
log4perl.appender.FileApp.filename = test.log</p>

<p style="margin-left:11%; margin-top: 1em">It selects the
file appender of the &quot;Log::Log4perl::Appender&quot;
hierarchy, which will append to the file
&quot;test.log&quot; if it already exists. If we wanted to
overwrite a potentially existing file, we would have to
explicitly set the appropriate
&quot;Log::Log4perl::Appender::File&quot; parameter
&quot;mode&quot;:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.FileApp
= Log::Log4perl::Appender::File <br>
log4perl.appender.FileApp.filename = test.log <br>
log4perl.appender.FileApp.mode = write</p>

<p style="margin-left:11%; margin-top: 1em">Also, the
configuration defines a PatternLayout format, adding the
nicely formatted current date and time, an arrow (&gt;) and
a space before the messages, which is then followed by a
newline:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.FileApp.layout
= PatternLayout <br>
log4perl.appender.FileApp.layout.ConversionPattern = %d&gt;
%m%n</p>

<p style="margin-left:11%; margin-top: 1em">Obtaining a
logger instance and actually logging something is typically
done in a different system part as the Log::Log4perl
initialisation section, but in this example, it&rsquo;s just
done right after init for the sake of compactness:</p>

<p style="margin-left:11%; margin-top: 1em"># Obtain a
logger instance <br>
my $logger = get_logger(&quot;Bar::Twix&quot;); <br>
$logger&minus;&gt;error(&quot;Oh my, a dreadful
error!&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">This retrieves
an instance of the logger of the category
&quot;Bar::Twix&quot;, which, as all other categories,
inherits behavior from the root logger if no other loggers
are defined in the initialization section.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;error()&quot; method fires up a message, which the
root logger catches. Its priority is equal to or higher than
the root logger&rsquo;s priority ( <small>ERROR</small> ),
which causes the root logger to forward it to its attached
appender. By contrast, the following</p>


<p style="margin-left:11%; margin-top: 1em">$logger&minus;&gt;warn(&quot;Oh
my, a dreadful warning!&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">doesn&rsquo;t
make it through, because the root logger sports a higher
setting ( <small>ERROR</small> and up) than the
<small>WARN</small> priority of the message.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
install Log::Log4perl on Microsoft Windows?</b> <br>
You can install Log::Log4perl using the <small>CPAN</small>
client.</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively
you can install it using</p>

<p style="margin-left:11%; margin-top: 1em">ppm install
Log&minus;Log4perl</p>

<p style="margin-left:11%; margin-top: 1em">if you&rsquo;re
using ActiveState perl.</p>

<p style="margin-left:11%; margin-top: 1em">That&rsquo;s
it! Afterwards, just create a Perl script like</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init($DEBUG); <br>
my $logger = get_logger(&quot;Twix::Bar&quot;); <br>
$logger&minus;&gt;debug(&quot;Watch me!&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">and run it. It
should print something like</p>

<p style="margin-left:11%; margin-top: 1em">2002/11/06
01:22:05 Watch me!</p>

<p style="margin-left:11%; margin-top: 1em">If you find
that something doesn&rsquo;t work, please let us know at
log4perl&minus;devel@lists.sourceforge.net -- we&rsquo;ll
appreciate it. Have fun!</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
include global (thread-specific) data in my log
messages?</b> <br>
Say, you&rsquo;re writing a web application and want all
your log messages to include the current client&rsquo;s
<small>IP</small> address. Most certainly, you don&rsquo;t
want to include it in each and every log message like in</p>


<p style="margin-left:11%; margin-top: 1em">$logger&minus;&gt;debug(
$r&minus;&gt;connection&minus;&gt;remote_ip, <br>
&quot; Retrieving user data from DB&quot; );</p>

<p style="margin-left:11%; margin-top: 1em">do you?
Instead, you want to set it in a global data structure and
have Log::Log4perl include it automatically via a
PatternLayout setting in the configuration file:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.FileApp.layout.ConversionPattern
= %X{ip} %m%n</p>

<p style="margin-left:11%; margin-top: 1em">The conversion
specifier %X{ip} references an entry under the key
&quot;ip&quot; in the global &quot;MDC&quot; (mapped
diagnostic context) table, which you&rsquo;ve set once
via</p>


<p style="margin-left:11%; margin-top: 1em">Log::Log4perl::MDC&minus;&gt;put(&quot;ip&quot;,
$r&minus;&gt;connection&minus;&gt;remote_ip);</p>

<p style="margin-left:11%; margin-top: 1em">at the start of
the request handler. Note that this is a <i>static</i>
(class) method, there&rsquo;s no logger object involved. You
can use this method with as many key/value pairs as you like
as long as you reference them under different names.</p>

<p style="margin-left:11%; margin-top: 1em">The mappings
are stored in a global hash table within Log::Log4perl.
Luckily, because the thread model in 5.8.0 doesn&rsquo;t
share global variables between threads unless they&rsquo;re
explicitly marked as such, there&rsquo;s no problem with
multi-threaded environments.</p>

<p style="margin-left:11%; margin-top: 1em">For more
details on the <small>MDC,</small> please refer to
&quot;Mapped Diagnostic Context ( <small>MDC</small> )&quot;
in Log::Log4perl and Log::Log4perl::MDC.</p>

<p style="margin-left:11%; margin-top: 1em"><b>My
application is already logging to a file. How can I
duplicate all messages to also go to the screen?</b> <br>
Assuming that you already have a Log4perl configuration file
like</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= DEBUG, FileApp <br>
log4perl.appender.FileApp = Log::Log4perl::Appender::File
<br>
log4perl.appender.FileApp.filename = test.log <br>
log4perl.appender.FileApp.layout = PatternLayout <br>
log4perl.appender.FileApp.layout.ConversionPattern = %d&gt;
%m%n</p>

<p style="margin-left:11%; margin-top: 1em">and log
statements all over your code, it&rsquo;s very easy with
Log4perl to have the same messages both printed to the
logfile and the screen. No reason to change your code, of
course, just add another appender to the configuration file
and you&rsquo;re done:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= DEBUG, FileApp, ScreenApp <br>
log4perl.appender.FileApp = Log::Log4perl::Appender::File
<br>
log4perl.appender.FileApp.filename = test.log <br>
log4perl.appender.FileApp.layout = PatternLayout <br>
log4perl.appender.FileApp.layout.ConversionPattern = %d&gt;
%m%n <br>
log4perl.appender.ScreenApp =
Log::Log4perl::Appender::Screen <br>
log4perl.appender.ScreenApp.stderr = 0 <br>
log4perl.appender.ScreenApp.layout = PatternLayout <br>
log4perl.appender.ScreenApp.layout.ConversionPattern =
%d&gt; %m%n</p>

<p style="margin-left:11%; margin-top: 1em">The
configuration file above is assuming that both appenders are
active in the same logger hierarchy, in this case the
&quot;root&quot; category. But even if you&rsquo;ve got file
loggers defined in several parts of your system, belonging
to different logger categories, each logging to different
files, you can gobble up all logged messages by defining a
root logger with a screen appender, which would duplicate
messages from all your file loggers to the screen due to
Log4perl&rsquo;s appender inheritance. Check</p>


<p style="margin-left:11%; margin-top: 1em">http://www.perl.com/pub/a/2002/09/11/log4perl.html</p>

<p style="margin-left:11%; margin-top: 1em">for details.
Have fun!</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
make sure my application logs a message when it dies
unexpectedly?</b> <br>
Whenever you encounter a fatal error in your application,
instead of saying something like</p>

<p style="margin-left:11%; margin-top: 1em">open FILE,
&quot;&lt;blah&quot; or die &quot;Can't open blah
&minus;&minus; bailing out!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">just use
Log::Log4perl&rsquo;s fatal functions instead:</p>

<p style="margin-left:11%; margin-top: 1em">my $log =
get_logger(&quot;Some::Package&quot;); <br>
open FILE, &quot;&lt;blah&quot; or
$log&minus;&gt;logdie(&quot;Can't open blah &minus;&minus;
bailing out!&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">This will both
log the message with priority <small>FATAL</small> according
to your current Log::Log4perl configuration and then call
Perl&rsquo;s &quot;die()&quot; afterwards to terminate the
program. It works the same with stealth loggers (see
&quot;Stealth Loggers&quot; in Log::Log4perl), all you need
to do is call</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
open FILE, &quot;&lt;blah&quot; or LOGDIE &quot;Can't open
blah &minus;&minus; bailing out!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">What can you do
if you&rsquo;re using some library which doesn&rsquo;t use
Log::Log4perl and calls &quot;die()&quot; internally if
something goes wrong? Use a $SIG{__DIE__} pseudo signal
handler</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(get_logger); <br>
$SIG{__DIE__} = sub { <br>
if($^S) { <br>
# We're in an eval {} and don't want log <br>
# this message but catch it later <br>
return; <br>
} <br>
local $Log::Log4perl::caller_depth = <br>
$Log::Log4perl::caller_depth + 1; <br>
my $logger = get_logger(&quot;&quot;); <br>
$logger&minus;&gt;fatal(@_); <br>
die @_; # Now terminate really <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">This will catch
every &quot;die()&quot;&minus;Exception of your application
or the modules it uses. In case you want to It will fetch a
root logger and pass on the &quot;die()&quot;&minus;Message
to it. If you make sure you&rsquo;ve configured with a root
logger like this:</p>


<p style="margin-left:11%; margin-top: 1em">Log::Log4perl&minus;&gt;init(\q{
<br>
log4perl.category = FATAL, Logfile <br>
log4perl.appender.Logfile = Log::Log4perl::Appender::File
<br>
log4perl.appender.Logfile.filename = fatal_errors.log <br>
log4perl.appender.Logfile.layout = \ <br>
Log::Log4perl::Layout::PatternLayout <br>
log4perl.appender.Logfile.layout.ConversionPattern =
%F{1}&minus;%L (%M)&gt; %m%n <br>
});</p>

<p style="margin-left:11%; margin-top: 1em">then all
&quot;die()&quot; messages will be routed to a file
properly. The line</p>

<p style="margin-left:11%; margin-top: 1em">local
$Log::Log4perl::caller_depth = <br>
$Log::Log4perl::caller_depth + 1;</p>

<p style="margin-left:11%; margin-top: 1em">in the pseudo
signal handler above merits a more detailed explanation.
With the setup above, if a module calls &quot;die()&quot; in
one of its functions, the fatal message will be logged in
the signal handler and not in the original function -- which
will cause the %F, %L and %M placeholders in the pattern
layout to be replaced by the filename, the line number and
the function/method name of the signal handler, not the
error-throwing module. To adjust this, Log::Log4perl has the
$caller_depth variable, which defaults to 0, but can be set
to positive integer values to offset the caller level.
Increasing it by one will cause it to log the calling
function&rsquo;s parameters, not the ones of the signal
handler. See &quot;Using Log::Log4perl from wrapper
classes&quot; in Log::Log4perl for more details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
hook up the <small>LWP</small> library with
Log::Log4perl?</b> <br>
Or, to put it more generally: How can you utilize a
third-party library&rsquo;s embedded logging and debug
statements in Log::Log4perl? How can you make them print to
configurable appenders, turn them on and off, just as if
they were regular Log::Log4perl logging statements?</p>

<p style="margin-left:11%; margin-top: 1em">The easiest
solution is to map the third-party library logging
statements to Log::Log4perl&rsquo;s stealth loggers via a
typeglob assignment.</p>

<p style="margin-left:11%; margin-top: 1em">As an example,
let&rsquo;s take <small>LWP,</small> one of the most popular
Perl modules, which makes handling <small>WWW</small>
requests and responses a breeze. Internally,
<small>LWP</small> uses its own logging and debugging
system, utilizing the following calls inside the
<small>LWP</small> code (from the LWP::Debug man page):</p>

<p style="margin-left:11%; margin-top: 1em"># Function
tracing <br>
LWP::Debug::trace('send()'); <br>
# High&minus;granular state in functions <br>
LWP::Debug::debug('url ok'); <br>
# Data going over the wire <br>
LWP::Debug::conns(&quot;read $n bytes: $data&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">First,
let&rsquo;s assign Log::Log4perl priorities to these
functions: I&rsquo;d suggest that &quot;debug()&quot;
messages have priority &quot;INFO&quot;, &quot;trace()&quot;
uses &quot;DEBUG&quot; and &quot;conns()&quot; also logs
with &quot;DEBUG&quot; -- although your mileage may
certainly vary.</p>

<p style="margin-left:11%; margin-top: 1em">Now, in order
to transparently hook up LWP::Debug with Log::Log4perl, all
we have to do is say</p>

<p style="margin-left:11%; margin-top: 1em">package
LWP::Debug; <br>
use Log::Log4perl qw(:easy); <br>
*trace = *INFO; <br>
*conns = *DEBUG; <br>
*debug = *DEBUG; <br>
package main; <br>
# ... go on with your regular program ...</p>

<p style="margin-left:11%; margin-top: 1em">at the
beginning of our program. In this way, every time the, say,
&quot;LWP::UserAgent&quot; module calls
&quot;LWP::Debug::trace()&quot;, it will implicitly call
<b><small>INFO</small> ()</b>, which is the
&quot;info()&quot; method of a stealth logger defined for
the Log::Log4perl category &quot;LWP::Debug&quot;. Is this
cool or what?</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
complete program:</p>

<p style="margin-left:11%; margin-top: 1em">use
LWP::UserAgent; <br>
use HTTP::Request::Common; <br>
use Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init( <br>
{ category =&gt; &quot;LWP::Debug&quot;, <br>
level =&gt; $DEBUG, <br>
layout =&gt; &quot;%r %p %M&minus;%L %m%n&quot;, <br>
}); <br>
package LWP::Debug; <br>
use Log::Log4perl qw(:easy); <br>
*trace = *INFO; <br>
*conns = *DEBUG; <br>
*debug = *DEBUG; <br>
package main; <br>
my $ua = LWP::UserAgent&minus;&gt;new(); <br>
my $resp = $ua&minus;&gt;request(GET
&quot;http://amazon.com&quot;); <br>
if($resp&minus;&gt;is_success()) { <br>
print &quot;Success: Received &quot;, <br>
length($resp&minus;&gt;content()), &quot;\n&quot;; <br>
} else { <br>
print &quot;Error: &quot;, $resp&minus;&gt;code(),
&quot;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This will
generate the following output on <small>STDERR:</small></p>

<p style="margin-left:11%; margin-top: 1em">174 INFO
LWP::UserAgent::new&minus;164 () <br>
208 INFO LWP::UserAgent::request&minus;436 () <br>
211 INFO LWP::UserAgent::send_request&minus;294 GET
http://amazon.com <br>
212 DEBUG LWP::UserAgent::_need_proxy&minus;1123 Not proxied
<br>
405 INFO LWP::Protocol::http::request&minus;122 () <br>
859 DEBUG LWP::Protocol::collect&minus;206 read 233 bytes
<br>
863 DEBUG LWP::UserAgent::request&minus;443 Simple response:
Found <br>
869 INFO LWP::UserAgent::request&minus;436 () <br>
871 INFO LWP::UserAgent::send_request&minus;294 <br>
GET http://www.amazon.com:80/exec/obidos/gateway_redirect
<br>
872 DEBUG LWP::UserAgent::_need_proxy&minus;1123 Not proxied
<br>
873 INFO LWP::Protocol::http::request&minus;122 () <br>
1016 DEBUG LWP::UserAgent::request&minus;443 Simple
response: Found <br>
1020 INFO LWP::UserAgent::request&minus;436 () <br>
1022 INFO LWP::UserAgent::send_request&minus;294 <br>
GET http://www.amazon.com/exec/obidos/subst/home/home.html/
<br>
1023 DEBUG LWP::UserAgent::_need_proxy&minus;1123 Not
proxied <br>
1024 INFO LWP::Protocol::http::request&minus;122 () <br>
1382 DEBUG LWP::Protocol::collect&minus;206 read 632 bytes
<br>
... <br>
2605 DEBUG LWP::Protocol::collect&minus;206 read 77 bytes
<br>
2607 DEBUG LWP::UserAgent::request&minus;443 Simple
response: OK <br>
Success: Received 42584</p>

<p style="margin-left:11%; margin-top: 1em">Of course, in
this way, the embedded logging and debug statements within
<small>LWP</small> can be utilized in any Log::Log4perl way
you can think of. You can have them sent to different
appenders, block them based on the category and everything
else Log::Log4perl has to offer.</p>

<p style="margin-left:11%; margin-top: 1em">Only drawback
of this method: Steering logging behavior via category is
always based on the &quot;LWP::Debug&quot; package. Although
the logging statements reflect the package name of the
issuing module properly, the stealth loggers in
&quot;LWP::Debug&quot; are all of the category
&quot;LWP::Debug&quot;. This implies that you can&rsquo;t
control the logging behavior based on the package
that&rsquo;s <i>initiating</i> a log request (e.g.
LWP::UserAgent) but only based on the package that&rsquo;s
actually <i>executing</i> the logging statement,
&quot;LWP::Debug&quot; in this case.</p>

<p style="margin-left:11%; margin-top: 1em">To work around
this conundrum, we need to write a wrapper function and
plant it into the &quot;LWP::Debug&quot; package. It will
determine the caller and create a logger bound to a category
with the same name as the caller&rsquo;s package:</p>

<p style="margin-left:11%; margin-top: 1em">package
LWP::Debug; <br>
use Log::Log4perl qw(:levels get_logger); <br>
sub l4p_wrapper { <br>
my($prio, @message) = @_; <br>
$Log::Log4perl::caller_depth += 2; <br>
get_logger(scalar caller(1))&minus;&gt;log($prio, @message);
<br>
$Log::Log4perl::caller_depth &minus;= 2; <br>
} <br>
no warnings 'redefine'; <br>
*trace = sub { l4p_wrapper($INFO, @_); }; <br>
*debug = *conns = sub { l4p_wrapper($DEBUG, @_); }; <br>
package main; <br>
# ... go on with your main program ...</p>

<p style="margin-left:11%; margin-top: 1em">This is less
performant than the previous approach, because every log
request will request a reference to a logger first, then
call the wrapper, which will in turn call the appropriate
log function.</p>

<p style="margin-left:11%; margin-top: 1em">This hierarchy
shift has to be compensated for by increasing
$Log::Log4perl::caller_depth by 2 before calling the log
function and decreasing it by 2 right afterwards. Also, the
&quot;l4p_wrapper&quot; function shown above calls caller(1)
which determines the name of the package <i>two</i> levels
down the calling hierarchy (and therefore compensates for
both the wrapper function and the anonymous subroutine
calling it).</p>

<p style="margin-left:11%; margin-top: 1em">&quot;no
warnings 'redefine'&quot; suppresses a warning Perl would
generate otherwise upon redefining
&quot;LWP::Debug&quot;&rsquo;s &quot;trace()&quot;,
&quot;debug()&quot; and &quot;conns()&quot; functions. In
case you use a perl prior to 5.6.x, you need to manipulate
$^W instead.</p>

<p style="margin-left:11%; margin-top: 1em">To make things
easy for you when dealing with <small>LWP,</small>
Log::Log4perl 0.47 introduces
&quot;Log::Log4perl&minus;&gt;infiltrate_lwp()&quot; which
does exactly the above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>What if I
need dynamic values in a static Log4perl configuration
file?</b> <br>
Say, your application uses Log::Log4perl for logging and
therefore comes with a Log4perl configuration file,
specifying the logging behavior. But, you also want it to
take command line parameters to set values like the name of
the log file. How can you have both a static Log4perl
configuration file and a dynamic command line interface?</p>

<p style="margin-left:11%; margin-top: 1em">As of
Log::Log4perl 0.28, every value in the configuration file
can be specified as a <i>Perl hook</i>. So, instead of
saying</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Logfile.filename
= test.log</p>

<p style="margin-left:11%; margin-top: 1em">you could just
as well have a Perl subroutine deliver the value
dynamically:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Logfile.filename
= sub { logfile(); };</p>

<p style="margin-left:11%; margin-top: 1em">given that
&quot;logfile()&quot; is a valid function in your
&quot;main&quot; package returning a string containing the
path to the log file.</p>

<p style="margin-left:11%; margin-top: 1em">Or, think about
using the value of an environment variable:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.DBI.user
= sub { $ENV{USERNAME} };</p>

<p style="margin-left:11%; margin-top: 1em">When
&quot;Log::Log4perl&minus;&gt;init()&quot; parses the
configuration file, it will notice the assignment above
because of its &quot;sub {...}&quot; pattern and treat it in
a special way: It will evaluate the subroutine (which can
contain arbitrary Perl code) and take its return value as
the right side of the assignment.</p>

<p style="margin-left:11%; margin-top: 1em">A typical
application would be called like this on the command
line:</p>

<p style="margin-left:11%; margin-top: 1em">app # log file
is &quot;test.log&quot; <br>
app &minus;l mylog.txt # log file is
&quot;mylog.txt&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
some sample code implementing the command line interface
above:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(get_logger); <br>
use Getopt::Std; <br>
getopt('l:', \our %OPTS); <br>
my $conf = q( <br>
log4perl.category.Bar.Twix = WARN, Logfile <br>
log4perl.appender.Logfile = Log::Log4perl::Appender::File
<br>
log4perl.appender.Logfile.filename = sub { logfile(); };
<br>
log4perl.appender.Logfile.layout = SimpleLayout <br>
); <br>
Log::Log4perl::init(\$conf); <br>
my $logger = get_logger(&quot;Bar::Twix&quot;); <br>
$logger&minus;&gt;error(&quot;Blah&quot;); <br>
########################################### <br>
sub logfile { <br>
########################################### <br>
if(exists $OPTS{l}) { <br>
return $OPTS{l}; <br>
} else { <br>
return &quot;test.log&quot;; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Every Perl hook
may contain arbitrary perl code, just make sure to fully
qualify eventual variable names (e.g. %main::OPTS instead of
%OPTS).</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>SECURITY
NOTE</small></b> : this feature means arbitrary perl code
can be embedded in the config file. In the rare case where
the people who have access to your config file are different
from the people who write your code and shouldn&rsquo;t have
execute rights, you might want to call</p>


<p style="margin-left:11%; margin-top: 1em">$Log::Log4perl::Config&minus;&gt;allow_code(0);</p>

<p style="margin-left:11%; margin-top: 1em">before you call
<b>init()</b>. This will prevent Log::Log4perl from
executing <i>any</i> Perl code in the config file (including
code for custom conversion specifiers (see &quot;Custom
cspecs&quot; in Log::Log4perl::Layout::PatternLayout).</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
roll over my logfiles automatically at midnight?</b> <br>
Long-running applications tend to produce ever-increasing
logfiles. For backup and cleanup purposes, however, it is
often desirable to move the current logfile to a different
location from time to time and start writing a new one.</p>

<p style="margin-left:11%; margin-top: 1em">This is a
non-trivial task, because it has to happen in sync with the
logging system in order not to lose any messages in the
process.</p>

<p style="margin-left:11%; margin-top: 1em">Luckily,
<i>Mark Pfeiffer</i>&rsquo;s
&quot;Log::Dispatch::FileRotate&quot; appender works well
with Log::Log4perl to rotate your logfiles in a variety of
ways.</p>

<p style="margin-left:11%; margin-top: 1em">Note, however,
that having the application deal with rotating a log file is
not cheap. Among other things, it requires locking the log
file with every write to avoid race conditions. There are
good reasons to use external rotators like
&quot;newsyslog&quot; instead. See the entry &quot;How can I
rotate a logfile with newsyslog?&quot; in the
<small>FAQ</small> for more information on how to configure
it.</p>

<p style="margin-left:11%; margin-top: 1em">When using
&quot;Log::Dispatch::FileRotate&quot;, all you have to do is
specify it in your Log::Log4perl configuration file and your
logfiles will be rotated automatically.</p>

<p style="margin-left:11%; margin-top: 1em">You can choose
between rolling based on a maximum size (&quot;roll if
greater than 10 <small>MB&quot;</small> ) or based on a date
pattern (&quot;roll everyday at midnight&quot;). In both
cases, &quot;Log::Dispatch::FileRotate&quot; allows you to
define a number &quot;max&quot; of saved files to keep
around until it starts overwriting the oldest ones. If you
set the &quot;max&quot; parameter to 2 and the name of your
logfile is &quot;test.log&quot;,
&quot;Log::Dispatch::FileRotate&quot; will move
&quot;test.log&quot; to &quot;test.log.1&quot; on the first
rollover. On the second rollover, it will move
&quot;test.log.1&quot; to &quot;test.log.2&quot; and then
&quot;test.log&quot; to &quot;test.log.1&quot;. On the third
rollover, it will move &quot;test.log.1&quot; to
&quot;test.log.2&quot; (therefore discarding the old
&quot;test.log.2&quot;) and &quot;test.log&quot; to
&quot;test.log.1&quot;. And so forth. This way,
there&rsquo;s always going to be a maximum of 2 saved log
files around.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s an
example of a Log::Log4perl configuration file, defining a
daily rollover at midnight (date pattern
&quot;yyyy&minus;MM&minus;dd&quot;), keeping a maximum of 5
saved logfiles around:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.category
= WARN, Logfile <br>
log4perl.appender.Logfile = Log::Dispatch::FileRotate <br>
log4perl.appender.Logfile.filename = test.log <br>
log4perl.appender.Logfile.max = 5 <br>
log4perl.appender.Logfile.DatePattern =
yyyy&minus;MM&minus;dd <br>
log4perl.appender.Logfile.TZ = PST <br>
log4perl.appender.Logfile.layout = \ <br>
Log::Log4perl::Layout::PatternLayout <br>
log4perl.appender.Logfile.layout.ConversionPattern = %d %m
%n</p>

<p style="margin-left:11%; margin-top: 1em">Please see the
&quot;Log::Dispatch::FileRotate&quot; documentation for
details. &quot;Log::Dispatch::FileRotate&quot; is available
on <small>CPAN.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>What&rsquo;s
the easiest way to turn off all logging, even with a lengthy
Log4perl configuration file?</b> <br>
In addition to category-based levels and appender
thresholds, Log::Log4perl supports system-wide logging
thresholds. This is the minimum level the system will
require of any logging events in order for them to make it
through to any configured appenders.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
putting the line</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.threshold
= ERROR</p>

<p style="margin-left:11%; margin-top: 1em">anywhere in
your configuration file will limit any output to any
appender to events with priority of <small>ERROR</small> or
higher ( <small>ERROR</small> or <small>FATAL</small> that
is).</p>

<p style="margin-left:11%; margin-top: 1em">However, in
order to suppress all logging entirely, you need to use a
priority that&rsquo;s higher than <small>FATAL:</small> It
is simply called &quot;OFF&quot;, and it is never used by
any logger. By definition, it is higher than the highest
defined logger level.</p>

<p style="margin-left:11%; margin-top: 1em">Therefore, if
you keep the line</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.threshold
= OFF</p>

<p style="margin-left:11%; margin-top: 1em">somewhere in
your Log::Log4perl configuration, the system will be quiet
as a graveyard. If you deactivate the line (e.g. by
commenting it out), the system will, upon config reload,
snap back to normal operation, providing logging messages
according to the rest of the configuration file again.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
log <small>DEBUG</small> and above to the screen and
<small>INFO</small> and above to a file?</b> <br>
You need one logger with two appenders attached to it:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= DEBUG, Screen, File <br>
log4perl.appender.Screen = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Screen.layout = SimpleLayout <br>
log4perl.appender.File = Log::Log4perl::Appender::File <br>
log4perl.appender.File.filename = test.log <br>
log4perl.appender.File.layout = SimpleLayout <br>
log4perl.appender.Screen.Threshold = INFO</p>

<p style="margin-left:11%; margin-top: 1em">Since the file
logger isn&rsquo;t supposed to get any messages with a
priority less than <small>INFO,</small> the appender&rsquo;s
&quot;Threshold&quot; setting blocks those out, although the
logger forwards them.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s a
common mistake to think you can define two loggers for this,
but it won&rsquo;t work unless those two loggers have
different categories. If you wanted to log all
<small>DEBUG</small> and above messages from the Foo::Bar
module to a file and all <small>INFO</small> and above
messages from the Quack::Schmack module to the screen, then
you could have defined two loggers with different levels
&quot;log4perl.logger.Foo.Bar&quot; (level
<small>INFO</small> ) and
&quot;log4perl.logger.Quack.Schmack&quot; (level
<small>DEBUG</small> ) and assigned the file appender to the
former and the screen appender to the latter. But what we
wanted to accomplish was to route all messages, regardless
of which module (or category) they came from, to both
appenders. The only way to accomplish this is to define the
root logger with the lower level ( <small>DEBUG</small> ),
assign both appenders to it, and block unwanted messages at
the file appender (&quot;Threshold&quot; set to
<small>INFO</small> ).</p>

<p style="margin-left:11%; margin-top: 1em"><b>I keep
getting duplicate log messages! What&rsquo;s wrong?</b> <br>
Having several settings for related categories in the
Log4perl configuration file sometimes leads to a phenomenon
called &quot;message duplication&quot;. It can be very
confusing at first, but if thought through properly, it
turns out that Log4perl behaves as advertised. But,
don&rsquo;t despair, of course there&rsquo;s a number of
ways to avoid message duplication in your logs.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
sample Log4perl configuration file that produces the
phenomenon:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger.Cat
= ERROR, Screen <br>
log4perl.logger.Cat.Subcat = WARN, Screen <br>
log4perl.appender.Screen = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Screen.layout = SimpleLayout</p>

<p style="margin-left:11%; margin-top: 1em">It defines two
loggers, one for category &quot;Cat&quot; and one for
&quot;Cat::Subcat&quot;, which is obviously a subcategory of
&quot;Cat&quot;. The parent logger has a priority setting of
<small>ERROR,</small> the child is set to the lower
&quot;WARN&quot; level.</p>

<p style="margin-left:11%; margin-top: 1em">Now imagine the
following code in your program:</p>

<p style="margin-left:11%; margin-top: 1em">my $logger =
get_logger(&quot;Cat.Subcat&quot;); <br>
$logger&minus;&gt;warn(&quot;Warning!&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">What do you
think will happen? An unexperienced Log4perl user might
think: &quot;Well, the message is being sent with level
<small>WARN,</small> so the &quot;Cat::Subcat&quot; logger
will accept it and forward it to the attached
&quot;Screen&quot; appender. Then, the message will
percolate up the logger hierarchy, find the &quot;Cat&quot;
logger, which will suppress the message because of its
<small>ERROR</small> setting.&quot; But, perhaps
surprisingly, what you&rsquo;ll get with the code snippet
above is not one but two log messages written to the
screen:</p>

<p style="margin-left:11%; margin-top: 1em">WARN &minus;
Warning! <br>
WARN &minus; Warning!</p>

<p style="margin-left:11%; margin-top: 1em">What happened?
The culprit is that once the logger &quot;Cat::Subcat&quot;
decides to fire, it will forward the message
<i>unconditionally</i> to all directly or indirectly
attached appenders. The &quot;Cat&quot; logger will never be
asked if it wants the message or not -- the message will
just be pushed through to the appender attached to
&quot;Cat&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">One way to
prevent the message from bubbling up the logger hierarchy is
to set the &quot;additivity&quot; flag of the subordinate
logger to 0:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger.Cat
= ERROR, Screen <br>
log4perl.logger.Cat.Subcat = WARN, Screen <br>
log4perl.additivity.Cat.Subcat = 0 <br>
log4perl.appender.Screen = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Screen.layout = SimpleLayout</p>

<p style="margin-left:11%; margin-top: 1em">The message
will now be accepted by the &quot;Cat::Subcat&quot; logger,
forwarded to its appender, but then &quot;Cat::Subcat&quot;
will suppress any further action. While this setting avoids
duplicate messages as seen before, it is often not the
desired behavior. Messages percolating up the hierarchy are
a useful Log4perl feature.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
defining <i>different</i> appenders for the two loggers, one
other option is to define an appender threshold for the
higher-level appender. Typically it is set to be equal to
the logger&rsquo;s level setting:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger.Cat
= ERROR, Screen1 <br>
log4perl.logger.Cat.Subcat = WARN, Screen2 <br>
log4perl.appender.Screen1 = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Screen1.layout = SimpleLayout <br>
log4perl.appender.Screen1.Threshold = ERROR <br>
log4perl.appender.Screen2 = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Screen2.layout = SimpleLayout</p>

<p style="margin-left:11%; margin-top: 1em">Since the
&quot;Screen1&quot; appender now blocks every message with a
priority less than <small>ERROR,</small> even if the logger
in charge lets it through, the message percolating up the
hierarchy is being blocked at the last minute and <i>not</i>
appended to &quot;Screen1&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">So far,
we&rsquo;ve been operating well within the boundaries of the
Log4j standard, which Log4perl adheres to. However, if you
would really, really like to use a single appender and keep
the message percolation intact without having to deal with
message duplication, there&rsquo;s a non-standard solution
for you:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger.Cat
= ERROR, Screen <br>
log4perl.logger.Cat.Subcat = WARN, Screen <br>
log4perl.appender.Screen = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Screen.layout = SimpleLayout <br>
log4perl.oneMessagePerAppender = 1</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;oneMessagePerAppender&quot; flag will suppress
duplicate messages to the same appender. Again, that&rsquo;s
non-standard. But way cool :).</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
configure Log::Log4perl to send me email if something
happens?</b> <br>
Some incidents require immediate action. You can&rsquo;t
wait until someone checks the log files, you need to get
notified on your pager right away.</p>

<p style="margin-left:11%; margin-top: 1em">The easiest way
to do that is by using the
&quot;Log::Dispatch::Email::MailSend&quot; module as an
appender. It comes with the &quot;Log::Dispatch&quot; bundle
and allows you to specify recipient and subject of outgoing
emails in the Log4perl configuration file:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.category
= FATAL, Mailer <br>
log4perl.appender.Mailer = Log::Dispatch::Email::MailSend
<br>
log4perl.appender.Mailer.to = drone@pageme.net <br>
log4perl.appender.Mailer.subject = Something's broken! <br>
log4perl.appender.Mailer.layout = SimpleLayout</p>

<p style="margin-left:11%; margin-top: 1em">The message of
every log incident this appender gets will then be forwarded
to the given email address. Check the
&quot;Log::Dispatch::Email::MailSend&quot; documentation for
details. And please make sure there&rsquo;s not a flood of
email messages sent out by your application, filling up the
recipient&rsquo;s inbox.</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s
one caveat you need to know about: The
&quot;Log::Dispatch::Email&quot; hierarchy of appenders
turns on <i>buffering</i> by default. This means that the
appender will not send out messages right away but wait
until a certain threshold has been reached. If you&rsquo;d
rather have your alerts sent out immediately, use</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Mailer.buffered
= 0</p>

<p style="margin-left:11%; margin-top: 1em">to turn
buffering off.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
write my own appender?</b> <br>
First off, Log::Log4perl comes with a set of standard
appenders. Then, there&rsquo;s a lot of
Log4perl&minus;compatible appenders already available on
<small>CPAN:</small> Just run a search for
&quot;Log::Dispatch&quot; on http://search.cpan.org and
chances are that what you&rsquo;re looking for has already
been developed, debugged and been used successfully in
production -- no need for you to reinvent the wheel.</p>

<p style="margin-left:11%; margin-top: 1em">Also,
Log::Log4perl ships with a nifty database appender named
Log::Log4perl::Appender::DBI -- check it out if talking to
databases is your desire.</p>

<p style="margin-left:11%; margin-top: 1em">But if
you&rsquo;re up for a truly exotic task, you might have to
write an appender yourself. That&rsquo;s very easy -- it
takes no longer than a couple of minutes.</p>

<p style="margin-left:11%; margin-top: 1em">Say, we wanted
to create an appender of the class
&quot;ColorScreenAppender&quot;, which logs messages to the
screen in a configurable color. Just create a new class in
&quot;ColorScreenAppender.pm&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">package
ColorScreenAppender;</p>

<p style="margin-left:11%; margin-top: 1em">Now let&rsquo;s
assume that your Log::Log4perl configuration file
&quot;test.conf&quot; looks like this:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= INFO, ColorApp <br>
log4perl.appender.ColorApp=ColorScreenAppender <br>
log4perl.appender.ColorApp.color=blue <br>
log4perl.appender.ColorApp.layout = PatternLayout <br>
log4perl.appender.ColorApp.layout.ConversionPattern=%d %m
%n</p>

<p style="margin-left:11%; margin-top: 1em">This will cause
Log::Log4perl on &quot;init()&quot; to look for a class
ColorScreenAppender and call its constructor <b>new()</b>.
Let&rsquo;s add <b>new()</b> to ColorScreenAppender.pm:</p>

<p style="margin-left:11%; margin-top: 1em">sub new { <br>
my($class, %options) = @_; <br>
my $self = { %options }; <br>
bless $self, $class; <br>
return $self; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">To initialize
this appender, Log::Log4perl will call and pass all
attributes of the appender as defined in the configuration
file to the constructor as name/value pairs (in this case
just one):</p>


<p style="margin-left:11%; margin-top: 1em">ColorScreenAppender&minus;&gt;new(color
=&gt; &quot;blue&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>new()</b> method listed above stores the contents of the
%options hash in the object&rsquo;s instance data hash
(referred to by $self). That&rsquo;s all for initializing a
new appender with Log::Log4perl.</p>

<p style="margin-left:11%; margin-top: 1em">Second,
ColorScreenAppender needs to expose a &quot;log()&quot;
method, which will be called by Log::Log4perl every time it
thinks the appender should fire. Along with the object
reference (as usual in Perl&rsquo;s object world),
<b>log()</b> will receive a list of name/value pairs, of
which only the one under the key &quot;message&quot; shall
be of interest for now since it is the message string to be
logged. At this point, Log::Log4perl has already taken care
of joining the message to be a single string.</p>

<p style="margin-left:11%; margin-top: 1em">For our special
appender ColorScreenAppender, we&rsquo;re using the
Term::ANSIColor module to colorize the output:</p>

<p style="margin-left:11%; margin-top: 1em">use
Term::ANSIColor; <br>
sub log { <br>
my($self, %params) = @_; <br>
print colored($params{message}, <br>
$self&minus;&gt;{color}); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The color (as
configured in the Log::Log4perl configuration file) is
available as $self&minus;&gt;{color} in the appender object.
Don&rsquo;t forget to return</p>

<p style="margin-left:11%; margin-top: 1em">1;</p>

<p style="margin-left:11%; margin-top: 1em">at the end of
ColorScreenAppender.pm and you&rsquo;re done. Install the
new appender somewhere where perl can find it and try it
with a test script like</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;init(&quot;test.conf&quot;); <br>
ERROR(&quot;blah&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">to see the new
colored output. Is this cool or what?</p>

<p style="margin-left:11%; margin-top: 1em">And it gets
even better: You can write dynamically generated appender
classes using the &quot;Class::Prototyped&quot; module.
Here&rsquo;s an example of an appender prepending every
outgoing message with a configurable number of bullets:</p>

<p style="margin-left:11%; margin-top: 1em">use
Class::Prototyped; <br>
my $class = Class::Prototyped&minus;&gt;newPackage( <br>
&quot;MyAppenders::Bulletizer&quot;, <br>
bullets =&gt; 1, <br>
log =&gt; sub { <br>
my($self, %params) = @_; <br>
print &quot;*&quot; x $self&minus;&gt;bullets(), <br>
$params{message}; <br>
}, <br>
); <br>
use Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;init(\ q{ <br>
log4perl.logger = INFO, Bully <br>
log4perl.appender.Bully=MyAppenders::Bulletizer <br>
log4perl.appender.Bully.bullets=3 <br>
log4perl.appender.Bully.layout = PatternLayout <br>
log4perl.appender.Bully.layout.ConversionPattern=%m %n <br>
}); <br>
# ... prints: &quot;***Boo!\n&quot;; <br>
INFO &quot;Boo!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
drill down on references before logging them?</b> <br>
If you&rsquo;ve got a reference to a nested structure or
object, then you probably don&rsquo;t want to log it as
&quot;HASH(0x81141d4)&quot; but rather dump it as something
like</p>

<p style="margin-left:11%; margin-top: 1em">$VAR1 = { <br>
'a' =&gt; 'b', <br>
'd' =&gt; 'e' <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">via a module
like Data::Dumper. While it&rsquo;s syntactically correct to
say</p>


<p style="margin-left:11%; margin-top: 1em">$logger&minus;&gt;debug(Data::Dumper::Dumper($ref));</p>

<p style="margin-left:11%; margin-top: 1em">this call
imposes a huge performance penalty on your application if
the message is suppressed by Log::Log4perl, because
Data::Dumper will perform its expensive operations in any
case, because it doesn&rsquo;t know that its output will be
thrown away immediately.</p>

<p style="margin-left:11%; margin-top: 1em">As of
Log::Log4perl 0.28, there&rsquo;s a better way: Use the
message output filter format as in</p>


<p style="margin-left:11%; margin-top: 1em">$logger&minus;&gt;debug(
{filter =&gt; \&amp;Data::Dumper::Dumper, <br>
value =&gt; $ref} );</p>

<p style="margin-left:11%; margin-top: 1em">and
Log::Log4perl won&rsquo;t call the filter function unless
the message really gets written out to an appender. Just
make sure to pass the whole slew as a reference to a hash
specifying a filter function (as a sub reference) under the
key &quot;filter&quot; and the value to be passed to the
filter function in &quot;value&quot;). When it comes to
logging, Log::Log4perl will call the filter function, pass
the &quot;value&quot; as an argument and log the return
value. Saves you serious cycles.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
collect all <small>FATAL</small> messages in an extra log
file?</b> <br>
Suppose you have employed Log4perl all over your system and
you&rsquo;ve already activated logging in various
subsystems. On top of that, without disrupting any other
settings, how can you collect all <small>FATAL</small>
messages all over the system and send them to a separate log
file?</p>

<p style="margin-left:11%; margin-top: 1em">If you define a
root logger like this:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= FATAL, File <br>
log4perl.appender.File = Log::Log4perl::Appender::File <br>
log4perl.appender.File.filename = /tmp/fatal.txt <br>
log4perl.appender.File.layout = PatternLayout <br>
log4perl.appender.File.layout.ConversionPattern= %d %m %n
<br>
# !!! Something's missing ...</p>

<p style="margin-left:11%; margin-top: 1em">you&rsquo;ll be
surprised to not only receive all <small>FATAL</small>
messages issued anywhere in the system, but also everything
else -- gazillions of <small>ERROR, WARN, INFO</small> and
even <small>DEBUG</small> messages will end up in your
fatal.txt logfile! Reason for this is Log4perl&rsquo;s (or
better: Log4j&rsquo;s) appender additivity. Once a
lower-level logger decides to fire, the message is going to
be forwarded to all appenders upstream -- without further
priority checks with their attached loggers.</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s a
way to prevent this, however: If your appender defines a
minimum threshold, only messages of this priority or higher
are going to be logged. So, just add</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.File.Threshold
= FATAL</p>

<p style="margin-left:11%; margin-top: 1em">to the
configuration above, and you&rsquo;ll get what you wanted in
the first place: An overall system <small>FATAL</small>
message collector.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
bundle several log messages into one?</b> <br>
Would you like to tally the messages arriving at your
appender and dump out a summary once they&rsquo;re exceeding
a certain threshold? So that something like</p>


<p style="margin-left:11%; margin-top: 1em">$logger&minus;&gt;error(&quot;Blah&quot;);
<br>
$logger&minus;&gt;error(&quot;Blah&quot;); <br>
$logger&minus;&gt;error(&quot;Blah&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">won&rsquo;t be
logged as</p>

<p style="margin-left:11%; margin-top: 1em">Blah <br>
Blah <br>
Blah</p>

<p style="margin-left:11%; margin-top: 1em">but as</p>

<p style="margin-left:11%; margin-top: 1em">[3] Blah</p>

<p style="margin-left:11%; margin-top: 1em">instead? If
you&rsquo;d like to hold off on logging a message until it
has been sent a couple of times, you can roll that out by
creating a buffered appender.</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
define a new appender like</p>

<p style="margin-left:11%; margin-top: 1em">package
TallyAppender; <br>
sub new { <br>
my($class, %options) = @_; <br>
my $self = { maxcount =&gt; 5, <br>
%options <br>
}; <br>
bless $self, $class; <br>
$self&minus;&gt;{last_message} = &quot;&quot;; <br>
$self&minus;&gt;{last_message_count} = 0; <br>
return $self; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">with two
additional instance variables &quot;last_message&quot; and
&quot;last_message_count&quot;, storing the content of the
last message sent and a counter of how many times this has
happened. Also, it features a configuration parameter
&quot;maxcount&quot; which defaults to 5 in the snippet
above but can be set in the Log4perl configuration file like
this:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= INFO, A <br>
log4perl.appender.A=TallyAppender <br>
log4perl.appender.A.maxcount = 3</p>

<p style="margin-left:11%; margin-top: 1em">The main
tallying logic lies in the appender&rsquo;s &quot;log&quot;
method, which is called every time Log4perl thinks a message
needs to get logged by our appender:</p>

<p style="margin-left:11%; margin-top: 1em">sub log { <br>
my($self, %params) = @_; <br>
# Message changed? Print buffer. <br>
if($self&minus;&gt;{last_message} and <br>
$params{message} ne $self&minus;&gt;{last_message}) { <br>
print &quot;[$self&minus;&gt;{last_message_count}]: &quot; .
<br>
&quot;$self&minus;&gt;{last_message}&quot;; <br>
$self&minus;&gt;{last_message_count} = 1; <br>
$self&minus;&gt;{last_message} = $params{message}; <br>
return; <br>
} <br>
$self&minus;&gt;{last_message_count}++; <br>
$self&minus;&gt;{last_message} = $params{message}; <br>
# Threshold exceeded? Print, reset counter <br>
if($self&minus;&gt;{last_message_count} &gt;= <br>
$self&minus;&gt;{maxcount}) { <br>
print &quot;[$self&minus;&gt;{last_message_count}]: &quot; .
<br>
&quot;$params{message}&quot;; <br>
$self&minus;&gt;{last_message_count} = 0; <br>
$self&minus;&gt;{last_message} = &quot;&quot;; <br>
return; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">We basically
just check if the oncoming message in $param{message} is
equal to what we&rsquo;ve saved before in the
&quot;last_message&quot; instance variable. If so,
we&rsquo;re increasing &quot;last_message_count&quot;. We
print the message in two cases: If the new message is
different than the buffered one, because then we need to
dump the old stuff and store the new. Or, if the counter
exceeds the threshold, as defined by the
&quot;maxcount&quot; configuration parameter.</p>

<p style="margin-left:11%; margin-top: 1em">Please note
that the appender always gets the fully rendered message and
just compares it as a whole -- so if there&rsquo;s a
date/timestamp in there, that might confuse your logic. You
can work around this by specifying %m %n as a layout and add
the date later on in the appender. Or, make the comparison
smart enough to omit the date.</p>

<p style="margin-left:11%; margin-top: 1em">At last,
don&rsquo;t forget what happens if the program is being shut
down. If there&rsquo;s still messages in the buffer, they
should be printed out at that point. That&rsquo;s easy to do
in the appender&rsquo;s <small>DESTROY</small> method, which
gets called at object destruction time:</p>

<p style="margin-left:11%; margin-top: 1em">sub DESTROY {
<br>
my($self) = @_; <br>
if($self&minus;&gt;{last_message_count}) { <br>
print &quot;[$self&minus;&gt;{last_message_count}]: &quot; .
<br>
&quot;$self&minus;&gt;{last_message}&quot;; <br>
return; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This will
ensure that none of the buffered messages are lost. Happy
buffering!</p>

<p style="margin-left:11%; margin-top: 1em"><b>I want to
log <small>ERROR</small> and <small>WARN</small> messages to
different files! How can I do that?</b> <br>
Let&rsquo;s assume you wanted to have each logging statement
written to a different file, based on the statement&rsquo;s
priority. Messages with priority &quot;WARN&quot; are
supposed to go to &quot;/tmp/app.warn&quot;, events
prioritized as &quot;ERROR&quot; should end up in
&quot;/tmp/app.error&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Now, if you
define two appenders &quot;AppWarn&quot; and
&quot;AppError&quot; and assign them both to the root
logger, messages bubbling up from any loggers below will be
logged by both appenders because of Log4perl&rsquo;s message
propagation feature. If you limit their exposure via the
appender threshold mechanism and set
&quot;AppWarn&quot;&rsquo;s threshold to &quot;WARN&quot;
and &quot;AppError&quot;&rsquo;s to &quot;ERROR&quot;,
you&rsquo;ll still get &quot;ERROR&quot; messages in
&quot;AppWarn&quot;, because &quot;AppWarn&quot;&rsquo;s
&quot;WARN&quot; setting will just filter out messages with
a <i>lower</i> priority than &quot;WARN&quot; --
&quot;ERROR&quot; is higher and will be allowed to pass
through.</p>

<p style="margin-left:11%; margin-top: 1em">What we need
for this is a Log4perl <i>Custom Filter</i>, available with
Log::Log4perl 0.30.</p>

<p style="margin-left:11%; margin-top: 1em">Both appenders
need to verify that the priority of the oncoming messages
exactly <i>matches</i> the priority the appender is supposed
to log messages of. To accomplish this task, let&rsquo;s
define two custom filters, &quot;MatchError&quot; and
&quot;MatchWarn&quot;, which, when attached to their
appenders, will limit messages passed on to them to those
matching a given priority:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= WARN, AppWarn, AppError <br>
# Filter to match level ERROR <br>
log4perl.filter.MatchError =
Log::Log4perl::Filter::LevelMatch <br>
log4perl.filter.MatchError.LevelToMatch = ERROR <br>
log4perl.filter.MatchError.AcceptOnMatch = true <br>
# Filter to match level WARN <br>
log4perl.filter.MatchWarn =
Log::Log4perl::Filter::LevelMatch <br>
log4perl.filter.MatchWarn.LevelToMatch = WARN <br>
log4perl.filter.MatchWarn.AcceptOnMatch = true <br>
# Error appender <br>
log4perl.appender.AppError = Log::Log4perl::Appender::File
<br>
log4perl.appender.AppError.filename = /tmp/app.err <br>
log4perl.appender.AppError.layout = SimpleLayout <br>
log4perl.appender.AppError.Filter = MatchError <br>
# Warning appender <br>
log4perl.appender.AppWarn = Log::Log4perl::Appender::File
<br>
log4perl.appender.AppWarn.filename = /tmp/app.warn <br>
log4perl.appender.AppWarn.layout = SimpleLayout <br>
log4perl.appender.AppWarn.Filter = MatchWarn</p>

<p style="margin-left:11%; margin-top: 1em">The appenders
&quot;AppWarn&quot; and &quot;AppError&quot; defined above
are logging to &quot;/tmp/app.warn&quot; and
&quot;/tmp/app.err&quot; respectively and have the custom
filters &quot;MatchWarn&quot; and &quot;MatchError&quot;
attached. This setup will direct all <small>WARN</small>
messages, issued anywhere in the system, to /tmp/app.warn
(and <small>ERROR</small> messages to /tmp/app.error) --
without any overlaps.</p>

<p style="margin-left:11%; margin-top: 1em"><b>On our
server farm, Log::Log4perl configuration files differ
slightly from host to host. Can I roll them all into
one?</b> <br>
You sure can, because Log::Log4perl allows you to specify
attribute values dynamically. Let&rsquo;s say that one of
your appenders expects the host&rsquo;s <small>IP</small>
address as one of its attributes. Now, you could certainly
roll out different configuration files for every host and
specify the value like</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.MyAppender
= Log::Log4perl::Appender::SomeAppender <br>
log4perl.appender.MyAppender.ip = 10.0.0.127</p>

<p style="margin-left:11%; margin-top: 1em">but
that&rsquo;s a maintenance nightmare. Instead, you can have
Log::Log4perl figure out the <small>IP</small> address at
configuration time and set the appender&rsquo;s value
correctly:</p>

<p style="margin-left:11%; margin-top: 1em"># Set the IP
address dynamically <br>
log4perl.appender.MyAppender =
Log::Log4perl::Appender::SomeAppender <br>
log4perl.appender.MyAppender.ip = sub { \ <br>
use Sys::Hostname; \ <br>
use Socket; \ <br>
return inet_ntoa(scalar gethostbyname hostname); \ <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If
Log::Log4perl detects that an attribute value starts with
something like &quot;sub {...&quot;, it will interpret it as
a perl subroutine which is to be executed once at
configuration time (not runtime!) and its return value is to
be used as the attribute value. This comes in handy for
rolling out applications where Log::Log4perl configuration
files show small host-specific differences, because you can
deploy the unmodified application distribution on all
instances of the server farm.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Log4perl
doesn&rsquo;t interpret my backslashes correctly!</b> <br>
If you&rsquo;re using Log4perl&rsquo;s feature to specify
the configuration as a string in your program (as opposed to
a separate configuration file), chances are that
you&rsquo;ve written it like this:</p>

<p style="margin-left:11%; margin-top: 1em"># *** WRONG!
*** <br>
Log::Log4perl&minus;&gt;init( \ &lt;&lt;END_HERE); <br>
log4perl.logger = WARN, A1 <br>
log4perl.appender.A1 = Log::Log4perl::Appender::Screen <br>
log4perl.appender.A1.layout = \ <br>
Log::Log4perl::Layout::PatternLayout <br>
log4perl.appender.A1.layout.ConversionPattern = %m%n <br>
END_HERE <br>
# *** WRONG! ***</p>

<p style="margin-left:11%; margin-top: 1em">and
you&rsquo;re getting the following error message:</p>

<p style="margin-left:11%; margin-top: 1em">Layout not
specified for appender A1 at .../Config.pm line 342.</p>

<p style="margin-left:11%; margin-top: 1em">What&rsquo;s
wrong? The problem is that you&rsquo;re using a
here-document with substitution enabled
(&quot;&lt;&lt;END_HERE&quot;) and that Perl won&rsquo;t
interpret backslashes at line-ends as continuation
characters but will essentially throw them out. So, in the
code above, the layout line will look like</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.A1.layout
=</p>

<p style="margin-left:11%; margin-top: 1em">to
Log::Log4perl which causes it to report an error. To
interpret the backslash at the end of the line correctly as
a line-continuation character, use the non-interpreting mode
of the here-document like in</p>

<p style="margin-left:11%; margin-top: 1em"># *** RIGHT!
*** <br>
Log::Log4perl&minus;&gt;init( \ &lt;&lt;'END_HERE'); <br>
log4perl.logger = WARN, A1 <br>
log4perl.appender.A1 = Log::Log4perl::Appender::Screen <br>
log4perl.appender.A1.layout = \ <br>
Log::Log4perl::Layout::PatternLayout <br>
log4perl.appender.A1.layout.ConversionPattern = %m%n <br>
END_HERE <br>
# *** RIGHT! ***</p>

<p style="margin-left:11%; margin-top: 1em">(note the
single quotes around 'END_HERE') or use &quot;q{...}&quot;
instead of a here-document and Perl will treat the
backslashes at line-end as intended.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I want to
suppress certain messages based on their content!</b> <br>
Let&rsquo;s assume you&rsquo;ve plastered all your functions
with Log4perl statements like</p>

<p style="margin-left:11%; margin-top: 1em">sub some_func {
<br>
INFO(&quot;Begin of function&quot;); <br>
# ... Stuff happens here ... <br>
INFO(&quot;End of function&quot;); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">to issue two
log messages, one at the beginning and one at the end of
each function. Now you want to suppress the message at the
beginning and only keep the one at the end, what can you do?
You can&rsquo;t use the category mechanism, because both
messages are issued from the same package.</p>


<p style="margin-left:11%; margin-top: 1em">Log::Log4perl&rsquo;s
custom filters (0.30 or better) provide an interface for the
Log4perl user to step in right before a message gets logged
and decide if it should be written out or suppressed, based
on the message content or other parameters:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log::Log4perl::init( \ &lt;&lt;'EOT' ); <br>
log4perl.logger = INFO, A1 <br>
log4perl.appender.A1 = Log::Log4perl::Appender::Screen <br>
log4perl.appender.A1.layout = \ <br>
Log::Log4perl::Layout::PatternLayout <br>
log4perl.appender.A1.layout.ConversionPattern = %m%n <br>
log4perl.filter.M1 = Log::Log4perl::Filter::StringMatch <br>
log4perl.filter.M1.StringToMatch = Begin <br>
log4perl.filter.M1.AcceptOnMatch = false <br>
log4perl.appender.A1.Filter = M1 <br>
EOT</p>

<p style="margin-left:11%; margin-top: 1em">The last four
statements in the configuration above are defining a custom
filter &quot;M1&quot; of type
&quot;Log::Log4perl::Filter::StringMatch&quot;, which comes
with Log4perl right out of the box and allows you to define
a text pattern to match (as a perl regular expression) and a
flag &quot;AcceptOnMatch&quot; indicating if a match is
supposed to suppress the message or let it pass through.</p>

<p style="margin-left:11%; margin-top: 1em">The last line
then assigns this filter to the &quot;A1&quot; appender,
which will call it every time it receives a message to be
logged and throw all messages out <i>not</i> matching the
regular expression &quot;Begin&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Instead of
using the standard
&quot;Log::Log4perl::Filter::StringMatch&quot; filter, you
can define your own, simply using a perl subroutine:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.filter.ExcludeBegin
= sub { !/Begin/ } <br>
log4perl.appender.A1.Filter = ExcludeBegin</p>

<p style="margin-left:11%; margin-top: 1em">For details on
custom filters, check Log::Log4perl::Filter.</p>

<p style="margin-left:11%; margin-top: 1em"><b>My new
module uses Log4perl -- but what happens if the calling
program didn&rsquo;t configure it?</b> <br>
If a Perl module uses Log::Log4perl, it will typically rely
on the calling program to initialize it. If it is using
Log::Log4perl in &quot;:easy&quot; mode, like in</p>

<p style="margin-left:11%; margin-top: 1em">package MyMod;
<br>
use Log::Log4perl qw(:easy); <br>
sub foo { <br>
DEBUG(&quot;In foo&quot;); <br>
} <br>
1;</p>

<p style="margin-left:11%; margin-top: 1em">and the calling
program doesn&rsquo;t initialize Log::Log4perl at all (e.g.
because it has no clue that it&rsquo;s available),
Log::Log4perl will silently ignore all logging messages.
However, if the module is using Log::Log4perl in regular
mode like in</p>

<p style="margin-left:11%; margin-top: 1em">package MyMod;
<br>
use Log::Log4perl qw(get_logger); <br>
sub foo { <br>
my $logger = get_logger(&quot;&quot;); <br>
$logger&minus;&gt;debug(&quot;blah&quot;); <br>
} <br>
1;</p>

<p style="margin-left:11%; margin-top: 1em">and the main
program is just using the module like in</p>

<p style="margin-left:11%; margin-top: 1em">use MyMode;
<br>
MyMode::foo();</p>

<p style="margin-left:11%; margin-top: 1em">then
Log::Log4perl will also ignore all logging messages but
issue a warning like</p>

<p style="margin-left:11%; margin-top: 1em">Log4perl: Seems
like no initialization happened. <br>
Forgot to call init()?</p>

<p style="margin-left:11%; margin-top: 1em">(only once!) to
remind novice users to not forget to initialize the logging
system before using it. However, if you want to suppress
this message, just add the &quot;:nowarn&quot; target to the
module&rsquo;s &quot;use Log::Log4perl&quot; call:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(get_logger :nowarn);</p>

<p style="margin-left:11%; margin-top: 1em">This will have
Log::Log4perl silently ignore all logging statements if no
initialization has taken place. If, instead of using
<b>init()</b>, you&rsquo;re using Log4perl&rsquo;s
<small>API</small> to define loggers and appenders, the same
notification happens if no call to <b>add_appenders()</b> is
made, i.e. no appenders are defined.</p>

<p style="margin-left:11%; margin-top: 1em">If the module
wants to figure out if some other program part has already
initialized Log::Log4perl, it can do so by calling</p>


<p style="margin-left:11%; margin-top: 1em">Log::Log4perl::initialized()</p>

<p style="margin-left:11%; margin-top: 1em">which will
return a true value in case Log::Log4perl has been
initialized and a false value if not.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
synchronize access to an appender?</b> <br>
If you&rsquo;re using the same instance of an appender in
multiple processes, and each process is passing on messages
to the appender in parallel, you might end up with
overlapping log entries.</p>

<p style="margin-left:11%; margin-top: 1em">Typical
scenarios include a file appender that you create in the
main program, and which will then be shared between the
parent and a forked child process. Or two separate
processes, each initializing a Log4perl file appender on the
same logfile.</p>

<p style="margin-left:11%; margin-top: 1em">Log::Log4perl
won&rsquo;t synchronize access to the shared logfile by
default. Depending on your operating system&rsquo;s flush
mechanism, buffer size and the size of your messages,
there&rsquo;s a small chance of an overlap.</p>

<p style="margin-left:11%; margin-top: 1em">The easiest way
to prevent overlapping messages in logfiles written to by
multiple processes is setting the file appender&rsquo;s
&quot;syswrite&quot; flag along with a file write mode of
&quot;append&quot;. This makes sure that
&quot;Log::Log4perl::Appender::File&quot; uses
&quot;syswrite()&quot; (which is guaranteed to run
uninterrupted) instead of &quot;print()&quot; which might
buffer the message or get interrupted by the
<small>OS</small> while it is writing. And in
&quot;append&quot; mode, the <small>OS</small> kernel
ensures that multiple processes share one end-of-file
marker, ensuring that each process writes to the <i>real</i>
end of the file. (The value of &quot;append&quot; for the
&quot;mode&quot; parameter is the default setting in
Log4perl&rsquo;s file appender so you don&rsquo;t have to
set it explicitly.)</p>

<p style="margin-left:11%; margin-top: 1em"># Guarantees
atomic writes <br>
log4perl.category.Bar.Twix = WARN, Logfile <br>
log4perl.appender.Logfile = Log::Log4perl::Appender::File
<br>
log4perl.appender.Logfile.mode = append <br>
log4perl.appender.Logfile.syswrite = 1 <br>
log4perl.appender.Logfile.filename = test.log <br>
log4perl.appender.Logfile.layout = SimpleLayout</p>

<p style="margin-left:11%; margin-top: 1em">Another
guaranteed way of having messages separated with any kind of
appender is putting a Log::Log4perl::Appender::Synchronized
composite appender in between Log::Log4perl and the real
appender. It will make sure to let messages pass through
this virtual gate one by one only.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s a
sample configuration to synchronize access to a file
appender:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.category.Bar.Twix
= WARN, Syncer <br>
log4perl.appender.Logfile = Log::Log4perl::Appender::File
<br>
log4perl.appender.Logfile.autoflush = 1 <br>
log4perl.appender.Logfile.filename = test.log <br>
log4perl.appender.Logfile.layout = SimpleLayout <br>
log4perl.appender.Syncer =
Log::Log4perl::Appender::Synchronized <br>
log4perl.appender.Syncer.appender = Logfile</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Log::Log4perl::Appender::Synchronized&quot;
uses the &quot;IPC::Shareable&quot; module and its
semaphores, which will slow down writing the log messages,
but ensures sequential access featuring atomic checks. Check
Log::Log4perl::Appender::Synchronized for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Can I use
Log::Log4perl with log4j&rsquo;s Chainsaw?</b> <br>
Yes, Log::Log4perl can be configured to send its events to
log4j&rsquo;s graphical log <small>UI</small>
<i>Chainsaw</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
how it works:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Get Guido Carls&rsquo; &lt;gcarls@cpan.org&gt;
Log::Log4perl extension
&quot;Log::Log4perl::Layout::XMLLayout&quot; from
<small>CPAN</small> and install it:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">perl
&minus;MCPAN &minus;eshell <br>
cpan&gt; install Log::Log4perl::Layout::XMLLayout</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Install and start Chainsaw,
which is part of the &quot;log4j&quot; distribution now (see
http://jakarta.apache.org/log4j ). Create a configuration
file like</p></td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">&lt;log4j:configuration
debug=&quot;true&quot;&gt; <br>
&lt;plugin name=&quot;XMLSocketReceiver&quot; <br>

class=&quot;org.apache.log4j.net.XMLSocketReceiver&quot;&gt;
<br>
&lt;param name=&quot;decoder&quot;
value=&quot;org.apache.log4j.xml.XMLDecoder&quot;/&gt; <br>
&lt;param name=&quot;Port&quot; value=&quot;4445&quot;/&gt;
<br>
&lt;/plugin&gt; <br>
&lt;root&gt; &lt;level value=&quot;debug&quot;/&gt;
&lt;/root&gt; <br>
&lt;/log4j:configuration&gt;</p>

<p style="margin-left:17%; margin-top: 1em">and name it
e.g. &quot;config.xml&quot;. Then start Chainsaw like</p>

<p style="margin-left:17%; margin-top: 1em">java
&minus;Dlog4j.debug=true
&minus;Dlog4j.configuration=config.xml \ <br>
&minus;classpath
&quot;.:log4j&minus;1.3alpha.jar:log4j&minus;chainsaw&minus;1.3alpha.jar&quot;
\ <br>
org.apache.log4j.chainsaw.LogUI</p>

<p style="margin-left:17%; margin-top: 1em">and watch the
<small>GUI</small> coming up.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Configure Log::Log4perl to use a
socket appender with an XMLLayout, pointing to the host/port
where Chainsaw (as configured above) is waiting with its
XMLSocketReceiver:</p> </td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">use
Log::Log4perl qw(get_logger); <br>
use Log::Log4perl::Layout::XMLLayout; <br>
my $conf = q( <br>
log4perl.category.Bar.Twix = WARN, Appender <br>
log4perl.appender.Appender = Log::Log4perl::Appender::Socket
<br>
log4perl.appender.Appender.PeerAddr = localhost <br>
log4perl.appender.Appender.PeerPort = 4445 <br>
log4perl.appender.Appender.layout =
Log::Log4perl::Layout::XMLLayout <br>
); <br>
Log::Log4perl::init(\$conf); <br>
# Nasty hack to suppress encoding header <br>
my $app =
Log::Log4perl::appenders&minus;&gt;{&quot;Appender&quot;};
<br>
$app&minus;&gt;layout()&minus;&gt;{enc_set} = 1; <br>
my $logger = get_logger(&quot;Bar.Twix&quot;); <br>
$logger&minus;&gt;error(&quot;One&quot;);</p>

<p style="margin-left:17%; margin-top: 1em">The nasty hack
shown in the code snippet above is currently (October 2003)
necessary, because Chainsaw expects <small>XML</small>
messages to arrive in a format like</p>


<p style="margin-left:17%; margin-top: 1em">&lt;log4j:event
logger=&quot;Bar.Twix&quot; <br>
timestamp=&quot;1066794904310&quot; <br>
level=&quot;ERROR&quot; <br>
thread=&quot;10567&quot;&gt; <br>

&lt;log4j:message&gt;&lt;![CDATA[Two]]&gt;&lt;/log4j:message&gt;
<br>
&lt;log4j:NDC&gt;&lt;![CDATA[undef]]&gt;&lt;/log4j:NDC&gt;
<br>
&lt;log4j:locationInfo class=&quot;main&quot; <br>
method=&quot;main&quot; <br>
file=&quot;./t&quot; <br>
line=&quot;32&quot;&gt; <br>
&lt;/log4j:locationInfo&gt; <br>
&lt;/log4j:event&gt;</p>

<p style="margin-left:17%; margin-top: 1em">without a
preceding</p>

<p style="margin-left:17%; margin-top: 1em">&lt;?xml
version = &quot;1.0&quot; encoding =
&quot;iso8859&minus;1&quot;?&gt;</p>

<p style="margin-left:17%; margin-top: 1em">which
Log::Log4perl::Layout::XMLLayout applies to the first event
sent over the socket.</p>

<p style="margin-left:11%; margin-top: 1em">See figure 1
for a screenshot of Chainsaw in action, receiving events
from the Perl script shown above.</p>

<p style="margin-left:11%; margin-top: 1em">Many thanks to
Chainsaw&rsquo;s Scott Deboy
&lt;sdeboy@comotivsystems.com&gt; for his support!</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
run Log::Log4perl under mod_perl?</b> <br>
In persistent environments it&rsquo;s important to play by
the rules outlined in section &quot;Initialize once and only
once&quot; in Log::Log4perl. If you haven&rsquo;t read this
yet, please go ahead and read it right now. It&rsquo;s very
important.</p>

<p style="margin-left:11%; margin-top: 1em">And no matter
if you use a startup handler to <b>init()</b> Log::Log4perl
or use the <b>init_once()</b> strategy (added in 0.42),
either way you&rsquo;re very likely to have unsynchronized
writes to logfiles.</p>

<p style="margin-left:11%; margin-top: 1em">If
Log::Log4perl is configured with a log file appender, and it
is initialized via the Apache startup handler, the file
handle created initially will be shared among all Apache
processes. Similarly, with the <b>init_once()</b> approach:
although every process has a separate L4p configuration,
processes are gonna share the appender file <i>names</i>
instead, effectively opening several different file handles
on the same file.</p>

<p style="margin-left:11%; margin-top: 1em">Now, having
several appenders using the same file handle or having
several appenders logging to the same file unsynchronized,
this might result in overlapping messages. Sometimes, this
is acceptable. If it&rsquo;s not, here&rsquo;s two
strategies:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Use the
Log::Log4perl::Appender::Synchronized appender to connect to
your file appenders. Here&rsquo;s the writeup:
http://log4perl.sourceforge.net/releases/Log&minus;Log4perl/docs/html/Log/Log4perl/FAQ.html#23804</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Use a different logfile for every process like in</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">#log4perl.conf
<br>
... <br>
log4perl.appender.A1.filename = sub {
&quot;mylog.$$.log&quot; }</p>

<p style="margin-left:11%; margin-top: 1em"><b>My program
already uses warn() and die(). How can I switch to
Log4perl?</b> <br>
If your program already uses Perl&rsquo;s &quot;warn()&quot;
function to spew out error messages and you&rsquo;d like to
channel those into the Log4perl world, just define a
&quot;__WARN__&quot; handler where your program or module
resides:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
$SIG{__WARN__} = sub { <br>
local $Log::Log4perl::caller_depth = <br>
$Log::Log4perl::caller_depth + 1; <br>
WARN @_; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">Why the
&quot;local&quot; setting of $Log::Log4perl::caller_depth?
If you leave that out, &quot;PatternLayout&quot; conversion
specifiers like %M or %F (printing the current
function/method and source filename) will refer to where the
__WARN__ handler resides, not the environment Perl&rsquo;s
&quot;warn()&quot; function was issued from. Increasing
&quot;caller_depth&quot; adjusts for this offset. Having it
&quot;local&quot;, makes sure the level gets set back after
the handler exits.</p>

<p style="margin-left:11%; margin-top: 1em">Once done, if
your program does something like</p>

<p style="margin-left:11%; margin-top: 1em">sub some_func {
<br>
warn &quot;Here's a warning&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">you&rsquo;ll
get (depending on your Log::Log4perl configuration)
something like</p>

<p style="margin-left:11%; margin-top: 1em">2004/02/19
20:41:02&minus;main::some_func: Here's a warning at ./t line
25.</p>

<p style="margin-left:11%; margin-top: 1em">in the
appropriate appender instead of having a screen full of
<small>STDERR</small> messages. It also works with the
&quot;Carp&quot; module and its &quot;carp()&quot; and
&quot;cluck()&quot; functions.</p>

<p style="margin-left:11%; margin-top: 1em">If, on the
other hand, catching &quot;die()&quot; and friends is
required, a &quot;__DIE__&quot; handler is appropriate:</p>

<p style="margin-left:11%; margin-top: 1em">$SIG{__DIE__} =
sub { <br>
if($^S) { <br>
# We're in an eval {} and don't want log <br>
# this message but catch it later <br>
return; <br>
} <br>
local $Log::Log4perl::caller_depth = <br>
$Log::Log4perl::caller_depth + 1; <br>
LOGDIE @_; <br>
};</p>

<p style="margin-left:11%; margin-top: 1em">This will call
Log4perl&rsquo;s &quot;LOGDIE()&quot; function, which will
log a fatal error and then call <b>die()</b> internally,
causing the program to exit. Works equally well with
&quot;Carp&quot;&rsquo;s &quot;croak()&quot; and
&quot;confess()&quot; functions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Some module
prints messages to <small>STDERR.</small> How can I funnel
them to Log::Log4perl?</b> <br>
If a module you&rsquo;re using doesn&rsquo;t use
Log::Log4perl but prints logging messages to
<small>STDERR</small> instead, like</p>


<p style="margin-left:11%; margin-top: 1em">########################################
<br>
package IgnorantModule; <br>
######################################## <br>
sub some_method { <br>
print STDERR &quot;Parbleu! An error!\n&quot;; <br>
} <br>
1;</p>

<p style="margin-left:11%; margin-top: 1em">there&rsquo;s
still a way to capture these messages and funnel them into
Log::Log4perl, even without touching the module. What you
need is a trapper module like</p>


<p style="margin-left:11%; margin-top: 1em">########################################
<br>
package Trapper; <br>
######################################## <br>
use Log::Log4perl qw(:easy); <br>
sub TIEHANDLE { <br>
my $class = shift; <br>
bless [], $class; <br>
} <br>
sub PRINT { <br>
my $self = shift; <br>
$Log::Log4perl::caller_depth++; <br>
DEBUG @_; <br>
$Log::Log4perl::caller_depth&minus;&minus;; <br>
} <br>
1;</p>

<p style="margin-left:11%; margin-top: 1em">and a
&quot;tie&quot; command in the main program to tie
<small>STDERR</small> to the trapper module along with
regular Log::Log4perl initialization:</p>


<p style="margin-left:11%; margin-top: 1em">########################################
<br>
package main; <br>
######################################## <br>
use Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init( <br>
{level =&gt; $DEBUG, <br>
file =&gt; 'stdout', # make sure not to use stderr here!
<br>
layout =&gt; &quot;%d %M: %m%n&quot;, <br>
}); <br>
tie *STDERR, &quot;Trapper&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">Make sure not
to use <small>STDERR</small> as Log::Log4perl&rsquo;s file
appender here (which would be the default in
&quot;:easy&quot; mode), because it would end up in an
endless recursion.</p>

<p style="margin-left:11%; margin-top: 1em">Now,
calling</p>


<p style="margin-left:11%; margin-top: 1em">IgnorantModule::some_method();</p>

<p style="margin-left:11%; margin-top: 1em">will result in
the desired output</p>

<p style="margin-left:11%; margin-top: 1em">2004/05/06
11:13:04 IgnorantModule::some_method: Parbleu! An error!</p>

<p style="margin-left:11%; margin-top: 1em"><b>How come
<small>PAR</small> (Perl Archive Toolkit) creates
executables which then can&rsquo;t find their Log::Log4perl
appenders?</b> <br>
If not instructed otherwise, &quot;Log::Log4perl&quot;
dynamically pulls in appender classes found in its
configuration. If you specify</p>


<p style="margin-left:11%; margin-top: 1em">#!/usr/bin/perl
<br>
# mytest.pl <br>
use Log::Log4perl qw(get_logger); <br>
my $conf = q( <br>
log4perl.category.Bar.Twix = WARN, Logfile <br>
log4perl.appender.Logfile = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Logfile.layout = SimpleLayout <br>
); <br>
Log::Log4perl::init(\$conf); <br>
my $logger = get_logger(&quot;Bar::Twix&quot;); <br>
$logger&minus;&gt;error(&quot;Blah&quot;);</p>

<p style="margin-left:11%; margin-top: 1em">then
&quot;Log::Log4perl::Appender::Screen&quot; will be pulled
in while the program runs, not at compile time. If you have
<small>PAR</small> compile the script above to an executable
binary via</p>

<p style="margin-left:11%; margin-top: 1em">pp &minus;o
mytest mytest.pl</p>

<p style="margin-left:11%; margin-top: 1em">and then run
&quot;mytest&quot; on a machine without having Log::Log4perl
installed, you&rsquo;ll get an error message like</p>

<p style="margin-left:11%; margin-top: 1em">ERROR: can't
load appenderclass 'Log::Log4perl::Appender::Screen' <br>
Can't locate Log/Log4perl/Appender/Screen.pm in @INC ...</p>

<p style="margin-left:11%; margin-top: 1em">Why? At compile
time, &quot;pp&quot; didn&rsquo;t realize that
&quot;Log::Log4perl::Appender::Screen&quot; would be needed
later on and didn&rsquo;t wrap it into the executable
created. To avoid this, either say &quot;use
Log::Log4perl::Appender::Screen&quot; in the script
explicitly or compile it with</p>

<p style="margin-left:11%; margin-top: 1em">pp &minus;o
mytest &minus;M Log::Log4perl::Appender::Screen
mytest.pl</p>

<p style="margin-left:11%; margin-top: 1em">to make sure
the appender class gets included.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
access a custom appender defined in the configuration?</b>
<br>
Any appender defined in the configuration file or somewhere
in the code can be accessed later via
&quot;Log::Log4perl&minus;&gt;appender_by_name(&quot;appender_name&quot;)&quot;,
which returns a reference of the appender object.</p>

<p style="margin-left:11%; margin-top: 1em">Once
you&rsquo;ve got a hold of the object, it can be queried or
modified to your liking. For example, see the custom
&quot;IndentAppender&quot; defined below: After calling
&quot;init()&quot; to define the Log4perl settings, the
appender object is retrieved to call its
&quot;indent_more()&quot; and &quot;indent_less()&quot;
methods to control indentation of messages:</p>

<p style="margin-left:11%; margin-top: 1em">package
IndentAppender; <br>
sub new { <br>
bless { indent =&gt; 0 }, $_[0]; <br>
} <br>
sub indent_more { $_[0]&minus;&gt;{indent}++ } <br>
sub indent_less { $_[0]&minus;&gt;{indent}&minus;&minus; }
<br>
sub log { <br>
my($self, %params) = @_; <br>
print &quot; &quot; x $self&minus;&gt;{indent},
$params{message}; <br>
} <br>
package main; <br>
use Log::Log4perl qw(:easy); <br>
my $conf = q( <br>
log4perl.category = DEBUG, Indented <br>
log4perl.appender.Indented = IndentAppender <br>
log4perl.appender.Indented.layout =
Log::Log4perl::Layout::SimpleLayout <br>
); <br>
Log::Log4perl::init(\$conf); <br>
my $appender =
Log::Log4perl&minus;&gt;appender_by_name(&quot;Indented&quot;);
<br>
DEBUG &quot;No identation&quot;; <br>
$appender&minus;&gt;indent_more(); <br>
DEBUG &quot;One more&quot;; <br>
$appender&minus;&gt;indent_more(); <br>
DEBUG &quot;Two more&quot;; <br>
$appender&minus;&gt;indent_less(); <br>
DEBUG &quot;One less&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">As you would
expect, this will print</p>

<p style="margin-left:11%; margin-top: 1em">DEBUG &minus;
No identation <br>
DEBUG &minus; One more <br>
DEBUG &minus; Two more <br>
DEBUG &minus; One less</p>

<p style="margin-left:11%; margin-top: 1em">because the
very appender used by Log4perl is modified dynamically at
runtime.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I
don&rsquo;t know if Log::Log4perl is installed. How can I
prepare my script?</b> <br>
In case your script needs to be prepared for environments
that may or may not have Log::Log4perl installed,
there&rsquo;s a trick.</p>

<p style="margin-left:11%; margin-top: 1em">If you put the
following <small>BEGIN</small> blocks at the top of the
program, you&rsquo;ll be able to use the
<b><small>DEBUG</small> ()</b>, <b><small>INFO</small>
()</b>, etc. macros in Log::Log4perl&rsquo;s
&quot;:easy&quot; mode. If Log::Log4perl is installed in the
target environment, the regular Log::Log4perl rules apply.
If not, all of <b><small>DEBUG</small> ()</b>,
<b><small>INFO</small> ()</b>, etc. are &quot;stubbed&quot;
out, i.e. they turn into no-ops:</p>

<p style="margin-left:11%; margin-top: 1em">use warnings;
<br>
use strict; <br>
BEGIN { <br>
eval { require Log::Log4perl; }; <br>
if($@) { <br>
print &quot;Log::Log4perl not installed &minus;
stubbing.\n&quot;; <br>
no strict qw(refs); <br>
*{&quot;main::$_&quot;} = sub { } for qw(DEBUG INFO WARN
ERROR FATAL); <br>
} else { <br>
no warnings; <br>
print &quot;Log::Log4perl installed &minus; life is
good.\n&quot;; <br>
require Log::Log4perl::Level; <br>
Log::Log4perl::Level&minus;&gt;import(__PACKAGE__); <br>
Log::Log4perl&minus;&gt;import(qw(:easy)); <br>
Log::Log4perl&minus;&gt;easy_init($main::DEBUG); <br>
} <br>
} <br>
# The regular script begins ... <br>
DEBUG &quot;Hey now!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">This snippet
will first probe for Log::Log4perl, and if it can&rsquo;t be
found, it will alias <b><small>DEBUG</small> ()</b>,
<b><small>INFO</small> ()</b>, with empty subroutines via
typeglobs. If Log::Log4perl is available, its level
constants are first imported ($DEBUG, $INFO, etc.) and then
&quot;easy_init()&quot; gets called to initialize the
logging system.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Can file
appenders create files with different permissions?</b> <br>
Typically, when &quot;Log::Log4perl::Appender::File&quot;
creates a new file, its permissions are set to
&quot;rw&minus;r&minus;&minus;r&minus;&minus;&quot;. Why?
Because your environment&rsquo;s <i>umask</i> most likely
defaults to 0022, that&rsquo;s the standard setting.</p>

<p style="margin-left:11%; margin-top: 1em">What&rsquo;s a
<i>umask</i>, you&rsquo;re asking? It&rsquo;s a template
that&rsquo;s applied to the permissions of all newly created
files. While calls like &quot;open(FILE,
&quot;&gt;foo&quot;)&quot; will always try to create files
in &quot;rw&minus;rw&minus;rw&minus; &quot; mode, the system
will apply the current <i>umask</i> template to determine
the final permission setting. <i>umask</i> is a bit mask
that&rsquo;s inverted and then applied to the requested
permission setting, using a bitwise <small>AND:</small></p>


<p style="margin-left:11%; margin-top: 1em">$request_permission
&amp;~ $umask</p>

<p style="margin-left:11%; margin-top: 1em">So, a
<i>umask</i> setting of 0000 (the leading 0 simply indicates
an octal value) will create files in
&quot;rw&minus;rw&minus;rw&minus;&quot; mode, a setting of
0277 will use
&quot;r&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&quot;,
and the standard 0022 will use
&quot;rw&minus;r&minus;&minus;r&minus;&minus;&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">As an example,
if you want your log files to be created with
&quot;rw&minus;r&minus;&minus;rw&minus;&quot; permissions,
use a <i>umask</i> of 0020 before calling
Log::Log4perl&minus;&gt;<b>init()</b>:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl; <br>
umask 0020; <br>
# Creates log.out in rw&minus;r&minus;&minus;rw mode <br>
Log::Log4perl&minus;&gt;init(\ q{ <br>
log4perl.logger = WARN, File <br>
log4perl.appender.File = Log::Log4perl::Appender::File <br>
log4perl.appender.File.filename = log.out <br>
log4perl.appender.File.layout = SimpleLayout <br>
});</p>

<p style="margin-left:11%; margin-top: 1em"><b>Using
Log4perl in an <small>END</small> block causes a
problem!</b> <br>
It&rsquo;s not easy to get to this error, but if you write
something like</p>

<p style="margin-left:11%; margin-top: 1em">END {
Log::Log4perl::get_logger()&minus;&gt;debug(&quot;Hey
there.&quot;); } <br>
use Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init($DEBUG);</p>

<p style="margin-left:11%; margin-top: 1em">it won&rsquo;t
work. The reason is that &quot;Log::Log4perl&quot; defines
an <small>END</small> block that cleans up all loggers. And
perl will run <small>END</small> blocks in the reverse order
as they&rsquo;re encountered in the compile phase, so in the
scenario above, the <small>END</small> block will run
<i>after</i> Log4perl has cleaned up its loggers.</p>

<p style="margin-left:11%; margin-top: 1em">Placing
<small>END</small> blocks using Log4perl <i>after</i> a
&quot;use Log::Log4perl&quot; statement fixes the
problem:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init($DEBUG); <br>
END { Log::Log4perl::get_logger()&minus;&gt;debug(&quot;Hey
there.&quot;); }</p>

<p style="margin-left:11%; margin-top: 1em">In this
scenario, the shown <small>END</small> block is executed
<i>before</i> Log4perl cleans up and the debug message will
be processed properly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Help! My
appender is throwing a &quot;Wide character in print&quot;
warning!</b> <br>
This warning shows up when Unicode strings are printed
without precautions. The warning goes away if the
complaining appender is set to utf&minus;8 mode:</p>

<p style="margin-left:11%; margin-top: 1em"># Either in the
log4perl configuration file: <br>
log4perl.appender.Logfile.filename = test.log <br>
log4perl.appender.Logfile.utf8 = 1 <br>
# Or, in easy mode: <br>
Log::Log4perl&minus;&gt;easy_init( { <br>
level =&gt; $DEBUG, <br>
file =&gt; &quot;:utf8&gt; test.log&quot; <br>
} );</p>

<p style="margin-left:11%; margin-top: 1em">If the
complaining appender is a screen appender, set its
&quot;utf8&quot; option:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Screen.stderr
= 1 <br>
log4perl.appender.Screen.utf8 = 1</p>

<p style="margin-left:11%; margin-top: 1em">Alternatively,
&quot;binmode&quot; does the trick:</p>

<p style="margin-left:11%; margin-top: 1em"># Either STDOUT
... <br>
binmode(STDOUT, &quot;:utf8); <br>
# ... or STDERR. <br>
binmode(STDERR, &quot;:utf8);</p>

<p style="margin-left:11%; margin-top: 1em">Some background
on this: Perl&rsquo;s strings are either byte strings or
Unicode strings. &quot;Mike&quot; is a byte string.
&quot;\x{30DE}\x{30A4}\x{30AF}&quot; is a Unicode string.
Unicode strings are marked specially and are
<small>UTF&minus;8</small> encoded internally.</p>

<p style="margin-left:11%; margin-top: 1em">If you print a
byte string to <small>STDOUT,</small> all is well, because
<small>STDOUT</small> is by default set to byte mode.
However, if you print a Unicode string to
<small>STDOUT</small> without precautions, &quot;perl&quot;
will try to transform the Unicode string back to a byte
string before printing it out. This is troublesome if the
Unicode string contains &rsquo;wide&rsquo; characters which
can&rsquo;t be represented in Latin&minus;1.</p>

<p style="margin-left:11%; margin-top: 1em">For example, if
you create a Unicode string with three japanese Katakana
characters as in</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;le
'print &quot;\x{30DE}\x{30A4}\x{30AF}&quot;'</p>


<p style="margin-left:11%; margin-top: 1em">(coincidentally
pronounced Ma-i-ku, the japanese pronunciation of
&quot;Mike&quot;), <small>STDOUT</small> is in byte mode and
the warning</p>

<p style="margin-left:11%; margin-top: 1em">Wide character
in print at ./script.pl line 14.</p>

<p style="margin-left:11%; margin-top: 1em">appears.
Setting <small>STDOUT</small> to <small>UTF&minus;8</small>
mode as in</p>

<p style="margin-left:11%; margin-top: 1em">perl &minus;le
'binmode(STDOUT, &quot;:utf8&quot;); print
&quot;\x{30DE}\x{30A4}\x{30AF}&quot;'</p>

<p style="margin-left:11%; margin-top: 1em">will silently
print the Unicode string to <small>STDOUT</small> in
<small>UTF&minus;8.</small> To see the characters printed,
you&rsquo;ll need a <small>UTF&minus;8</small> terminal with
a font including japanese Katakana characters.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
send errors to the screen, and debug messages to a file?</b>
<br>
Let&rsquo;s assume you want to maintain a detailed
<small>DEBUG</small> output in a file and only messages of
level <small>ERROR</small> and higher should be printed on
the screen. Often times, developers come up with something
like this:</p>

<p style="margin-left:11%; margin-top: 1em"># Wrong!!! <br>
log4perl.logger = DEBUG, FileApp <br>
log4perl.logger = ERROR, ScreenApp <br>
# Wrong!!!</p>

<p style="margin-left:11%; margin-top: 1em">This
won&rsquo;t work, however. Logger definitions aren&rsquo;t
additive, and the second statement will overwrite the first
one. Log4perl versions below 1.04 were silently accepting
this, leaving people confused why it wouldn&rsquo;t work as
expected. As of 1.04, this will throw a <i>fatal error</i>
to notify the user of the problem.</p>

<p style="margin-left:11%; margin-top: 1em">What you want
to do instead, is this:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.logger
= DEBUG, FileApp, ScreenApp <br>
log4perl.appender.FileApp = Log::Log4perl::Appender::File
<br>
log4perl.appender.FileApp.filename = test.log <br>
log4perl.appender.FileApp.layout = SimpleLayout <br>
log4perl.appender.ScreenApp =
Log::Log4perl::Appender::Screen <br>
log4perl.appender.ScreenApp.stderr = 0 <br>
log4perl.appender.ScreenApp.layout = SimpleLayout <br>
### limiting output to ERROR messages <br>
log4perl.appender.ScreenApp.Threshold = ERROR <br>
###</p>

<p style="margin-left:11%; margin-top: 1em">Note that
without the second appender&rsquo;s &quot;Threshold&quot;
setting, both appenders would receive all messages
prioritized <small>DEBUG</small> and higher. With the
threshold set to <small>ERROR,</small> the second appender
will filter the messages as required.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Where should
I put my logfiles?</b> <br>
Your log files may go anywhere you want them, but the
effective user id of the calling process must have write
access.</p>

<p style="margin-left:11%; margin-top: 1em">If the log file
doesn&rsquo;t exist at program start, Log4perl&rsquo;s file
appender will create it. For this, it needs write access to
the directory where the new file will be located in. If the
log file already exists at startup, the process simply needs
write access to the file. Note that it will need write
access to the file&rsquo;s directory if you&rsquo;re
encountering situations where the logfile gets recreated,
e.g. during log rotation.</p>

<p style="margin-left:11%; margin-top: 1em">If
Log::Log4perl is used by a web server application (e.g. in a
<small>CGI</small> script or mod_perl), then the
webserver&rsquo;s user (usually &quot;nobody&quot; or
&quot;www&quot;) must have the permissions mentioned
above.</p>

<p style="margin-left:11%; margin-top: 1em">To prepare your
web server to use log4perl, we&rsquo;d recommend:</p>

<p style="margin-left:11%; margin-top: 1em">webserver:~$ su
&minus; <br>
webserver:~# mkdir /var/log/cgiapps <br>
webserver:~# chown nobody:root /var/log/cgiapps/ <br>
webserver:~# chown nobody:root &minus;R /var/log/cgiapps/
<br>
webserver:~# chmod 02755 &minus;R /var/log/cgiapps/</p>

<p style="margin-left:11%; margin-top: 1em">Then set your
/etc/log4perl.conf file to include:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.FileAppndr1.filename
= <br>
/var/log/cgiapps/&lt;app&minus;name&gt;.log</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can my
file appender deal with disappearing log files?</b> <br>
The file appender that comes with Log4perl,
Log::Log4perl::Appender::File, will open a specified log
file at initialization time and will keep writing to it via
a file handle.</p>

<p style="margin-left:11%; margin-top: 1em">In case the
associated file goes way, messages written by a long-running
process will still be written to the file handle. In case
the file has been moved to a different location on the same
file system, the writer will keep writing to it under the
new filename. In case the file has been removed from the
file system, the log messages will end up in nowhere land.
This is not a bug in Log4perl, this is how Unix works. There
is no error message in this case, because the writer has no
idea that the file handle is not associated with a visible
file.</p>

<p style="margin-left:11%; margin-top: 1em">To prevent the
loss of log messages when log files disappear, the file
appender&rsquo;s &quot;recreate&quot; option needs to be set
to a true value:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Logfile.recreate
= 1</p>

<p style="margin-left:11%; margin-top: 1em">This will
instruct the file appender to check in regular intervals
(default: 30 seconds) if the log file is still there. If it
finds out that the file is missing, it will recreate it.</p>

<p style="margin-left:11%; margin-top: 1em">Continuously
checking if the log file still exists is fairly expensive.
For this reason it is only performed every 30 seconds. To
change this interval, the option
&quot;recreate_check_interval&quot; can be set to the number
of seconds between checks. In the extreme case where the
check should be performed before every write, it can even be
set to 0:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Logfile.recreate
= 1 <br>
log4perl.appender.Logfile.recreate_check_interval = 0</p>

<p style="margin-left:11%; margin-top: 1em">To avoid having
to check the file system so frequently, a signal handler can
be set up:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Logfile.recreate
= 1 <br>
log4perl.appender.Logfile.recreate_check_signal = USR1</p>

<p style="margin-left:11%; margin-top: 1em">This will
install a signal handler which will recreate a missing log
file immediately when it receives the defined signal.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
<b>init_and_watch()</b> method for Log4perl&rsquo;s
initialization can also be instructed to install a signal
handler, usually using the <small>HUP</small> signal. Make
sure to use a different signal if you&rsquo;re using both of
them at the same time.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
rotate a logfile with newsyslog?</b> <br>
Here&rsquo;s a few things that need to be taken care of when
using the popular log file rotating utility
&quot;newsyslog&quot; (http://www.courtesan.com/newsyslog)
with Log4perl&rsquo;s file appender in long-running
processes.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
with a newsyslog configuration like</p>

<p style="margin-left:11%; margin-top: 1em">#
newsyslog.conf <br>
/tmp/test.log 666 12 5 * B</p>

<p style="margin-left:11%; margin-top: 1em">and a call
to</p>

<p style="margin-left:11%; margin-top: 1em"># newsyslog
&minus;f /path/to/newsyslog.conf</p>


<p style="margin-left:11%; margin-top: 1em">&quot;newsyslog&quot;
will take action if &quot;/tmp/test.log&quot; is larger than
the specified 5K in size. It will move the current log file
&quot;/tmp/test.log&quot; to &quot;/tmp/test.log.0&quot; and
create a new and empty &quot;/tmp/test.log&quot; with the
specified permissions (this is why &quot;newsyslog&quot;
needs to run as root). An already existing
&quot;/tmp/test.log.0&quot; would be moved to
&quot;/tmp/test.log.1&quot;, &quot;/tmp/test.log.1&quot; to
&quot;/tmp/test.log.2&quot;, and so forth, for every one of
a max number of 12 archived logfiles that have been
configured in &quot;newsyslog.conf&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Although a new
file has been created, from Log4perl&rsquo;s
appender&rsquo;s point of view, this situation is identical
to the one described in the previous <small>FAQ</small>
entry, labeled &quot;How can my file appender deal with
disappearing log files&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">To make sure
that log messages are written to the new log file and not to
an archived one or end up in nowhere land, the
appender&rsquo;s &quot;recreate&quot; and
&quot;recreate_check_interval&quot; have to be configured to
deal with the &rsquo;disappearing&rsquo; log file.</p>

<p style="margin-left:11%; margin-top: 1em">The situation
gets interesting when &quot;newsyslog&quot;&rsquo;s option
to compress archived log files is enabled. This causes the
original log file not to be moved, but to disappear. If the
file appender isn&rsquo;t configured to recreate the logfile
in this situation, log messages will actually be lost
without warning. This also applies for the short time frame
of &quot;recreate_check_interval&quot; seconds in between
the recreator&rsquo;s file checks.</p>

<p style="margin-left:11%; margin-top: 1em">To make sure
that no messages get lost, one option is to set the interval
to</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Logfile.recreate_check_interval
= 0</p>

<p style="margin-left:11%; margin-top: 1em">However, this
is fairly expensive. A better approach is to define a signal
handler:</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Logfile.recreate
= 1 <br>
log4perl.appender.Logfile.recreate_check_signal = USR1 <br>
log4perl.appender.Logfile.recreate_pid_write =
/tmp/myappid</p>

<p style="margin-left:11%; margin-top: 1em">As a service
for &quot;newsyslog&quot; users, Log4perl&rsquo;s file
appender writes the current process <small>ID</small> to a
<small>PID</small> file specified by the
&quot;recreate_pid_write&quot; option. &quot;newsyslog&quot;
then needs to be configured as in</p>

<p style="margin-left:11%; margin-top: 1em">#
newsyslog.conf configuration for compressing archive files
and <br>
# sending a signal to the Log4perl&minus;enabled application
<br>
/tmp/test.log 666 12 5 * B /tmp/myappid 30</p>

<p style="margin-left:11%; margin-top: 1em">to send the
defined signal (30, which is <small>USR1</small> on FreeBSD)
to the application process at rotation time. Note that the
signal number is different on Linux, where
<small>USR1</small> denotes as 10. Check &quot;man
signal&quot; for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can a
process under user id A log to a file under user id B?</b>
<br>
This scenario often occurs in configurations where processes
run under various user IDs but need to write to a log file
under a fixed, but different user id.</p>

<p style="margin-left:11%; margin-top: 1em">With a
traditional file appender, the log file will probably be
created under one user&rsquo;s id and appended to under a
different user&rsquo;s id. With a typical umask of 0002, the
file will be created with &minus;rw&minus;rw&minus;r--
permissions. If a user who&rsquo;s not in the first
user&rsquo;s group subsequently appends to the log file, it
will fail because of a permission problem.</p>

<p style="margin-left:11%; margin-top: 1em">Two potential
solutions come to mind:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Creating the file with a umask
of 0000 will allow all users to append to the log file.
Log4perl&rsquo;s file appender
&quot;Log::Log4perl::Appender::File&quot; has an
&quot;umask&quot; option that can be set to support
this:</p> </td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em">log4perl.appender.File
= Log::Log4perl::Appender::File <br>
log4perl.appender.File.umask = sub { 0000 };</p>

<p style="margin-left:17%; margin-top: 1em">This way, the
log file will be created with
&minus;rw&minus;rw&minus;rw&minus; permissions and therefore
has world write permissions. This might open up the logfile
for unwanted manipulations by arbitrary users, though.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Running the process under an
effective user id of &quot;root&quot; will allow it to write
to the log file, no matter who started the process. However,
this is not a good idea, because of security concerns.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Luckily, under
Unix, there&rsquo;s the syslog daemon which runs as root and
takes log requests from user processes over a socket and
writes them to log files as configured in
&quot;/etc/syslog.conf&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">By modifying
&quot;/etc/syslog.conf&quot; and HUPing the syslog daemon,
you can configure new log files:</p>

<p style="margin-left:11%; margin-top: 1em">#
/etc/syslog.conf <br>
... <br>
user.* /some/path/file.log</p>

<p style="margin-left:11%; margin-top: 1em">Using the
&quot;Log::Dispatch::Syslog&quot; appender, which comes with
the &quot;Log::Log4perl&quot; distribution, you can then
send messages via syslog:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;init(\&lt;&lt;EOT); <br>
log4perl.logger = DEBUG, app <br>
log4perl.appender.app=Log::Dispatch::Syslog <br>
log4perl.appender.app.Facility=user <br>
log4perl.appender.app.layout=SimpleLayout <br>
EOT <br>
# Writes to /some/path/file.log <br>
ERROR &quot;Message!&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">This way, the
syslog daemon will solve the permission problem.</p>

<p style="margin-left:11%; margin-top: 1em">Note that while
it is possible to use <b>syslog()</b> without Log4perl
(syslog supports log levels, too), traditional syslog setups
have a significant drawback.</p>

<p style="margin-left:11%; margin-top: 1em">Without
Log4perl&rsquo;s ability to activate logging in only
specific parts of a system, complex systems will trigger log
events all over the place and slow down execution to a crawl
at high debug levels.</p>


<p style="margin-left:11%; margin-top: 1em">Remote-controlling
logging in the hierarchical parts of an application via
Log4perl&rsquo;s categories is one of its most distinguished
features. It allows for enabling high debug levels in
specified areas without noticeable performance impact.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I want to
use <small>UTC</small> instead of the local time!</b> <br>
If a layout defines a date, Log::Log4perl uses local time to
populate it. If you want <small>UTC</small> instead, set</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.utcDateTimes
= 1</p>

<p style="margin-left:11%; margin-top: 1em">in your
configuration. Alternatively, you can set</p>


<p style="margin-left:11%; margin-top: 1em">$Log::Log4perl::DateFormat::GMTIME
= 1;</p>

<p style="margin-left:11%; margin-top: 1em">in your program
before the first log statement.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Can Log4perl
intercept messages written to a filehandle?</b> <br>
You have a function that prints to a filehandle. You want to
tie into that filehandle and forward all arriving messages
to a Log4perl logger.</p>

<p style="margin-left:11%; margin-top: 1em">First,
let&rsquo;s write a package that ties a file handle and
forwards it to a Log4perl logger:</p>

<p style="margin-left:11%; margin-top: 1em">package
FileHandleLogger; <br>
use Log::Log4perl qw(:levels get_logger); <br>
sub TIEHANDLE { <br>
my($class, %options) = @_; <br>
my $self = { <br>
level =&gt; $DEBUG, <br>
category =&gt; '', <br>
%options <br>
}; <br>
$self&minus;&gt;{logger} =
get_logger($self&minus;&gt;{category}), <br>
bless $self, $class; <br>
} <br>
sub PRINT { <br>
my($self, @rest) = @_; <br>
$Log::Log4perl::caller_depth++; <br>

$self&minus;&gt;{logger}&minus;&gt;log($self&minus;&gt;{level},
@rest); <br>
$Log::Log4perl::caller_depth&minus;&minus;; <br>
} <br>
sub PRINTF { <br>
my($self, $fmt, @rest) = @_; <br>
$Log::Log4perl::caller_depth++; <br>
$self&minus;&gt;PRINT(sprintf($fmt, @rest)); <br>
$Log::Log4perl::caller_depth&minus;&minus;; <br>
} <br>
1;</p>

<p style="margin-left:11%; margin-top: 1em">Now, if you
have a function like</p>

<p style="margin-left:11%; margin-top: 1em">sub
function_printing_to_fh { <br>
my($fh) = @_; <br>
printf $fh &quot;Hi there!\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">which takes a
filehandle and prints something to it, it can be used with
Log4perl:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
usa FileHandleLogger; <br>
Log::Log4perl&minus;&gt;easy_init($DEBUG); <br>
tie *SOMEHANDLE, 'FileHandleLogger' or <br>
die &quot;tie failed ($!)&quot;; <br>
function_printing_to_fh(*SOMEHANDLE); <br>
# prints &quot;2007/03/22 21:43:30 Hi there!&quot;</p>

<p style="margin-left:11%; margin-top: 1em">If you want,
you can even specify a different log level or category:</p>

<p style="margin-left:11%; margin-top: 1em">tie
*SOMEHANDLE, 'FileHandleLogger', <br>
level =&gt; $INFO, category =&gt; &quot;Foo::Bar&quot; or
die &quot;tie failed ($!)&quot;;</p>

<p style="margin-left:11%; margin-top: 1em"><b>I want
multiline messages rendered line-by-line!</b> <br>
With the standard &quot;PatternLayout&quot;, if you send a
multiline message to an appender as in</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log</p>

<p style="margin-left:11%; margin-top: 1em">it gets
rendered this way:</p>

<p style="margin-left:11%; margin-top: 1em">2007/04/04
23:23:39 multi <br>
line <br>
message</p>

<p style="margin-left:11%; margin-top: 1em">If you want
each line to be rendered separately according to the layout
use
&quot;Log::Log4perl::Layout::PatternLayout::Multiline&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;init(\&lt;&lt;EOT); <br>
log4perl.category = DEBUG, Screen <br>
log4perl.appender.Screen = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Screen.layout = \\ <br>
Log::Log4perl::Layout::PatternLayout::Multiline <br>
log4perl.appender.Screen.layout.ConversionPattern = %d %m %n
<br>
EOT <br>
DEBUG &quot;some\nmultiline\nmessage&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">and
you&rsquo;ll get</p>

<p style="margin-left:11%; margin-top: 1em">2007/04/04
23:23:39 some <br>
2007/04/04 23:23:39 multiline <br>
2007/04/04 23:23:39 message</p>

<p style="margin-left:11%; margin-top: 1em">instead.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I&rsquo;m on
Windows and I&rsquo;m getting all these
&rsquo;redefined&rsquo; messages!</b> <br>
If you&rsquo;re on Windows and are getting warning messages
like</p>

<p style="margin-left:11%; margin-top: 1em">Constant
subroutine Log::Log4perl::_INTERNAL_DEBUG redefined at <br>
C:/Programme/Perl/lib/constant.pm line 103. <br>
Subroutine import redefined at <br>
C:/Programme/Perl/site/lib/Log/Log4Perl.pm line 69. <br>
Subroutine initialized redefined at <br>
C:/Programme/Perl/site/lib/Log/Log4Perl.pm line 207.</p>

<p style="margin-left:11%; margin-top: 1em">then chances
are that you&rsquo;re using &rsquo;Log::Log4Perl&rsquo;
(wrong uppercase P) instead of the correct
&rsquo;Log::Log4perl&rsquo;. Perl on Windows doesn&rsquo;t
handle this error well and spits out a slew of confusing
warning messages. But now you know, just use the correct
module name and you&rsquo;ll be fine.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Log4perl
complains that no initialization happened during
shutdown!</b> <br>
If you&rsquo;re using Log4perl log commands in
<small>DESTROY</small> methods of your objects, you might
see confusing messages like</p>

<p style="margin-left:11%; margin-top: 1em">Log4perl: Seems
like no initialization happened. Forgot to call init()? <br>
Use of uninitialized value in subroutine entry at <br>
/home/y/lib/perl5/site_perl/5.6.1/Log/Log4perl.pm line 134
during global <br>
destruction. (in cleanup) Undefined subroutine &amp;main::
called at <br>
/home/y/lib/perl5/site_perl/5.6.1/Log/Log4perl.pm line 134
during global <br>
destruction.</p>

<p style="margin-left:11%; margin-top: 1em">when the
program shuts down. What&rsquo;s going on?</p>

<p style="margin-left:11%; margin-top: 1em">This phenomenon
happens if you have circular references in your objects,
which perl can&rsquo;t clean up when an object goes out of
scope but waits until global destruction instead. At this
time, however, Log4perl has already shut down, so you
can&rsquo;t use it anymore.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
here&rsquo;s a simple class which uses a logger in its
<small>DESTROY</small> method:</p>

<p style="margin-left:11%; margin-top: 1em">package A; <br>
use Log::Log4perl qw(:easy); <br>
sub new { bless {}, shift } <br>
sub DESTROY { DEBUG &quot;Waaah!&quot;; }</p>

<p style="margin-left:11%; margin-top: 1em">Now, if the
main program creates a self-referencing object, like in</p>

<p style="margin-left:11%; margin-top: 1em">package main;
<br>
use Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init($DEBUG); <br>
my $a = A&minus;&gt;new(); <br>
$a&minus;&gt;{selfref} = $a;</p>

<p style="margin-left:11%; margin-top: 1em">then
you&rsquo;ll see the error message shown above during global
destruction. How to tackle this problem?</p>

<p style="margin-left:11%; margin-top: 1em">First, you
should clean up your circular references before global
destruction. They will not only cause objects to be
destroyed in an order that&rsquo;s hard to predict, but also
eat up memory until the program shuts down.</p>

<p style="margin-left:11%; margin-top: 1em">So, the program
above could easily be fixed by putting</p>


<p style="margin-left:11%; margin-top: 1em">$a&minus;&gt;{selfref}
= undef;</p>

<p style="margin-left:11%; margin-top: 1em">at the end or
in an <small>END</small> handler. If that&rsquo;s hard to
do, use weak references:</p>

<p style="margin-left:11%; margin-top: 1em">package main;
<br>
use Scalar::Util qw(weaken); <br>
use Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init($DEBUG); <br>
my $a = A&minus;&gt;new(); <br>
$a&minus;&gt;{selfref} = weaken $a;</p>

<p style="margin-left:11%; margin-top: 1em">This allows
perl to clean up the circular reference when the object goes
out of scope, and doesn&rsquo;t wait until global
destruction.</p>

<p style="margin-left:11%; margin-top: 1em"><b>How can I
access <small>POE</small> heap values from Log4perl&rsquo;s
layout?</b> <small><br>
POE</small> is a framework for creating multitasked
applications running in a single process and a single
thread. <small>POE</small> &rsquo;s threads equivalents are
&rsquo;sessions&rsquo; and since they run
quasi-simultaneously, you can&rsquo;t use Log4perl&rsquo;s
global <small>NDC/MDC</small> to hold session-specific
data.</p>

<p style="margin-left:11%; margin-top: 1em">However,
<small>POE</small> already maintains a data store for every
session. It is called &rsquo;heap&rsquo; and is just a hash
storing session-specific data in key-value pairs. To access
this per-session heap data from a Log4perl layout, define a
custom cspec and reference it with the newly defined pattern
in the layout:</p>

<p style="margin-left:11%; margin-top: 1em">use strict;
<br>
use POE; <br>
use Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;init( \ q{ <br>
log4perl.logger = DEBUG, Screen <br>
log4perl.appender.Screen = Log::Log4perl::Appender::Screen
<br>
log4perl.appender.Screen.layout = PatternLayout <br>
log4perl.appender.Screen.layout.ConversionPattern = %U %m%n
<br>
log4perl.PatternLayout.cspec.U = \ <br>
sub {
POE::Kernel&minus;&gt;get_active_session&minus;&gt;get_heap()&minus;&gt;{
user } } <br>
} ); <br>
for (qw( Huey Lewey Dewey )) { <br>
POE::Session&minus;&gt;create( <br>
inline_states =&gt; { <br>
_start =&gt; sub { <br>
$_[HEAP]&minus;&gt;{user} = $_; <br>
POE::Kernel&minus;&gt;yield('hello'); <br>
}, <br>
hello =&gt; sub { <br>
DEBUG &quot;I'm here now&quot;; <br>
} <br>
} <br>
); <br>
} <br>
POE::Kernel&minus;&gt;run(); <br>
exit;</p>

<p style="margin-left:11%; margin-top: 1em">The code
snippet above defines a new layout placeholder (called
&rsquo;cspec&rsquo; in Log4perl) %U which calls a
subroutine, retrieves the active session, gets its heap and
looks up the entry specified (&rsquo;user&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">Starting with
Log::Log4perl 1.20, cspecs also support parameters in curly
braces, so you can say</p>


<p style="margin-left:11%; margin-top: 1em">log4perl.appender.Screen.layout.ConversionPattern
= %U{user} %U{id} %m%n <br>
log4perl.PatternLayout.cspec.U = \ <br>
sub { POE::Kernel&minus;&gt;get_active_session&minus;&gt; \
<br>
get_heap()&minus;&gt;{ $_[0]&minus;&gt;{curlies} } }</p>

<p style="margin-left:11%; margin-top: 1em">and print the
<small>POE</small> session heap entries &rsquo;user&rsquo;
and &rsquo;id&rsquo; with every logged message. For more
details on cpecs, read the PatternLayout manual.</p>

<p style="margin-left:11%; margin-top: 1em"><b>I want to
print something unconditionally!</b> <br>
Sometimes it&rsquo;s a script that&rsquo;s supposed to log
messages regardless if Log4perl has been initialized or not.
Or there&rsquo;s a logging statement that&rsquo;s not going
to be suppressed under any circumstances -- many people want
to have the final word, make the executive decision, because
it seems like the only logical choice.</p>

<p style="margin-left:11%; margin-top: 1em">But think about
it: First off, if a messages is supposed to be printed,
where is it supposed to end up at? <small>STDOUT</small> ?
<small>STDERR</small> ? And are you sure you want to set in
stone that this message needs to be printed, while someone
else might find it annoying and wants to get rid of it?</p>

<p style="margin-left:11%; margin-top: 1em">The truth is,
there&rsquo;s always going to be someone who wants to log a
messages at all cost, but also another person who wants to
suppress it with equal vigilance. There&rsquo;s no good way
to serve these two conflicting desires, someone will always
want to win at the cost of leaving the other party
disappointed.</p>

<p style="margin-left:11%; margin-top: 1em">So, the best
Log4perl offers is the <small>ALWAYS</small> level for a
message that even fires if the system log level is set to
$OFF:</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw(:easy); <br>
Log::Log4perl&minus;&gt;easy_init( $OFF ); <br>
ALWAYS &quot;This gets logged always. Well, almost
always&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">The logger
won&rsquo;t fire, though, if Log4perl hasn&rsquo;t been
initialized or if someone defines a custom log hurdle
that&rsquo;s higher than $OFF.</p>

<p style="margin-left:11%; margin-top: 1em">Bottom line:
Leave the setting of the logging level to the initial Perl
script -- let their owners decided what they want, no matter
how tempting it may be to decide it for them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Why
doesn&rsquo;t my <small>END</small> handler remove my log
file on Win32?</b> <br>
If you have code like</p>

<p style="margin-left:11%; margin-top: 1em">use
Log::Log4perl qw( :easy ); <br>
Log::Log4perl&minus;&gt;easy_init( { level =&gt; $DEBUG,
file =&gt; &quot;my.log&quot; } ); <br>
END { unlink &quot;my.log&quot; or die };</p>

<p style="margin-left:11%; margin-top: 1em">then you might
be in for a surprise when you&rsquo;re running it on
Windows, because the &quot;unlink()&quot; call in the
<small>END</small> handler will complain that the file is
still in use.</p>

<p style="margin-left:11%; margin-top: 1em">What happens in
Perl if you have something like</p>

<p style="margin-left:11%; margin-top: 1em">END { print
&quot;first end in main\n&quot;; } <br>
use Module; <br>
END { print &quot;second end in main\n&quot;; }</p>

<p style="margin-left:11%; margin-top: 1em">and</p>

<p style="margin-left:11%; margin-top: 1em">package Module;
<br>
END { print &quot;end in module\n&quot;; } <br>
1;</p>

<p style="margin-left:11%; margin-top: 1em">is that you
get</p>

<p style="margin-left:11%; margin-top: 1em">second end in
main <br>
end in module <br>
first end in main</p>

<p style="margin-left:11%; margin-top: 1em">because perl
stacks the <small>END</small> handlers in reverse order in
which it encounters them in the compile phase.</p>

<p style="margin-left:11%; margin-top: 1em">Log4perl
defines an <small>END</small> handler that cleans up
left-over appenders (e.g. file appenders which still hold
files open), because those appenders have circular
references and therefore aren&rsquo;t cleaned up
otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">Now if you
define an <small>END</small> handler after &quot;use
Log::Log4perl&quot;, it&rsquo;ll trigger before Log4perl
gets a chance to clean up, which isn&rsquo;t a problem on
Unix where you can delete a file even if some process has a
handle to it open, but it&rsquo;s a problem on Win32, where
the <small>OS</small> won&rsquo;t let you do that.</p>

<p style="margin-left:11%; margin-top: 1em">The solution is
easy, just place the <small>END</small> handler
<i>before</i> Log4perl gets loaded, like in</p>

<p style="margin-left:11%; margin-top: 1em">END { unlink
&quot;my.log&quot; or die }; <br>
use Log::Log4perl qw( :easy ); <br>
Log::Log4perl&minus;&gt;easy_init( { level =&gt; $DEBUG,
file =&gt; &quot;my.log&quot; } );</p>

<p style="margin-left:11%; margin-top: 1em">which will call
the <small>END</small> handlers in the intended order.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Log::Log4perl</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2002&minus;2013 by Mike Schilli &lt;m@perlmeister.com&gt;
and Kevin Goess &lt;cpan@goess.org&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please
contribute patches to the project on Github:</p>


<p style="margin-left:11%; margin-top: 1em">http://github.com/mschilli/log4perl</p>

<p style="margin-left:11%; margin-top: 1em">Send bug
reports or requests for enhancements to the authors via
our</p>

<p style="margin-left:11%; margin-top: 1em"><small>MAILING
LIST</small> (questions, bug reports, suggestions/patches):
log4perl&minus;devel@lists.sourceforge.net</p>

<p style="margin-left:11%; margin-top: 1em">Authors (please
contact them via the list above, not directly): Mike Schilli
&lt;m@perlmeister.com&gt;, Kevin Goess
&lt;cpan@goess.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Contributors
(in alphabetical order): Ateeq Altaf, Cory Bennett, Jens
Berthold, Jeremy Bopp, Hutton Davidson, Chris R. Donnelly,
Matisse Enzer, Hugh Esco, Anthony Foiani, James FitzGibbon,
Carl Franks, Dennis Gregorovic, Andy Grundman, Paul
Harrington, Alexander Hartmaier David Hull, Robert Jacobson,
Jason Kohles, Jeff Macdonald, Markus Peter, Brett Rann,
Peter Rabbitson, Erik Selberg, Aaron Straup Cope, Lars
Thegler, David Viner, Mac Yang.</p>
<hr>
</body>
</html>
