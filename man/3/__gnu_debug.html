<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:12 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__gnu_debug</title>

</head>
<body>
<h1>__gnu_debug</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">__gnu_debug
&minus; GNU debug classes for public use.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">class <b>_After_nth_from</b>
<br>
struct <b>_BeforeBeginHelper</b> <br>
class <b>_Equal_to</b> <br>
class <b>_Not_equal_to</b> <br>
class <b>_Safe_container</b> <br>
Safe class dealing with some allocator dependent operations.
<br>
class <b>_Safe_forward_list</b> <br>
Special iterators swap and invalidation for forward_list
because of the before_begin iterator. <br>
class <b>_Safe_iterator</b> <br>
Safe iterator wrapper. <br>
class <b>_Safe_iterator_base</b> <br>
Basic functionality for a <i>safe</i> iterator. <br>
class <b>_Safe_local_iterator</b> <br>
Safe iterator wrapper. <br>
class <b>_Safe_local_iterator_base</b> <br>
Basic functionality for a <i>safe</i> iterator. <br>
class <b>_Safe_node_sequence</b> <br>
Like _Safe_sequence but with a special _M_invalidate_all
implementation not invalidating past-the-end iterators. Used
by node based sequence. <br>
class <b>_Safe_sequence</b> <br>
Base class for constructing a <i>safe</i> sequence type that
tracks iterators that reference it. <br>
class <b>_Safe_sequence_base</b> <br>
Base class that supports tracking of iterators that
reference a sequence. <br>
class <b>_Safe_unordered_container</b> <br>
Base class for constructing a <i>safe</i> unordered
container type that tracks iterators that reference it. <br>
class <b>_Safe_unordered_container_base</b> <br>
Base class that supports tracking of local iterators that
reference an unordered container. <br>
class <b>_Safe_vector</b> <br>
Base class for Debug Mode vector. <br>
struct <b>_Sequence_traits</b> <br>
class <b>basic_string</b> <br>
Class std::basic_string with safety/checking/debug
instrumentation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Typedefs</b></p>

<p style="margin-left:17%;">typedef <b>basic_string</b>&lt;
char &gt; <b>string</b> <br>
typedef <b>basic_string</b>&lt; char16_t &gt;
<b>u16string</b> <br>
A string of <tt>char16_t</tt>. <br>
typedef <b>basic_string</b>&lt; char32_t &gt;
<b>u32string</b> <br>
A string of <tt>char32_t</tt>. <br>
typedef <b>basic_string</b>&lt; wchar_t &gt;
<b>wstring</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Enumerations</b></p>

<p style="margin-left:17%;">enum <b>_Debug_msg_id</b> {
<b>__msg_valid_range</b>, <b>__msg_insert_singular</b>,
<b>__msg_insert_different</b>, <b>__msg_erase_bad</b>,
<b>__msg_erase_different</b>, <b>__msg_subscript_oob</b>,
<b>__msg_empty</b>, <b>__msg_unpartitioned</b>,
<b>__msg_unpartitioned_pred</b>, <b>__msg_unsorted</b>,
<b>__msg_unsorted_pred</b>, <b>__msg_not_heap</b>,
<b>__msg_not_heap_pred</b>, <b>__msg_bad_bitset_write</b>,
<b>__msg_bad_bitset_read</b>, <b>__msg_bad_bitset_flip</b>,
<b>__msg_self_splice</b>, <b>__msg_splice_alloc</b>,
<b>__msg_splice_bad</b>, <b>__msg_splice_other</b>,
<b>__msg_splice_overlap</b>, <b>__msg_init_singular</b>,
<b>__msg_init_copy_singular</b>,
<b>__msg_init_const_singular</b>,
<b>__msg_copy_singular</b>, <b>__msg_bad_deref</b>,
<b>__msg_bad_inc</b>, <b>__msg_bad_dec</b>,
<b>__msg_iter_subscript_oob</b>, <b>__msg_advance_oob</b>,
<b>__msg_retreat_oob</b>, <b>__msg_iter_compare_bad</b>,
<b>__msg_compare_different</b>, <b>__msg_iter_order_bad</b>,
<b>__msg_order_different</b>, <b>__msg_distance_bad</b>,
<b>__msg_distance_different</b>, <b>__msg_deref_istream</b>,
<b>__msg_inc_istream</b>, <b>__msg_output_ostream</b>,
<b>__msg_deref_istreambuf</b>, <b>__msg_inc_istreambuf</b>,
<b>__msg_insert_after_end</b>, <b>__msg_erase_after_bad</b>,
<b>__msg_valid_range2</b>,
<b>__msg_local_iter_compare_bad</b>,
<b>__msg_non_empty_range</b>, <b>__msg_self_move_assign</b>,
<b>__msg_bucket_index_oob</b>,
<b>__msg_valid_load_factor</b>, <b>__msg_equal_allocs</b>,
<b>__msg_insert_range_from_self</b>,
<b>__msg_irreflexive_ordering</b> } <br>
enum <b>_Distance_precision</b> { <b>__dp_none</b>,
<b>__dp_equality</b>, <b>__dp_sign</b>,
<b>__dp_sign_max_size</b>, <b>__dp_exact</b> }</p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Iterator
&gt; constexpr _Iterator <b>__base</b> (_Iterator __it) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
_Iterator <b>__base</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence, <b>std::random_access_iterator_tag</b>
&gt; &amp;__it) <br>
template&lt;typename _Iterator &gt; constexpr auto
<b>__base</b> (const <b>std::move_iterator</b>&lt; _Iterator
&gt; &amp;__it) &minus;&gt;
decltype(std::make_move_iterator(__base(__it.base()))) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
constexpr <b>std::reverse_iterator</b>&lt; _Iterator &gt;
<b>__base</b> (const <b>std::reverse_iterator</b>&lt;
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence,
<b>std::random_access_iterator_tag</b> &gt; &gt; &amp;__it)
<br>
template&lt;typename _InputIterator , typename _Size &gt;
constexpr bool <b>__can_advance</b> (_InputIterator, _Size)
<br>
template&lt;typename _InputIterator , typename _Diff &gt;
constexpr bool <b>__can_advance</b> (_InputIterator, const
<b>std::pair</b>&lt; _Diff, <b>_Distance_precision</b> &gt;
&amp;, int) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _Size &gt; bool
<b>__can_advance</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence, _Category &gt; &amp;, _Size) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _Diff &gt; bool
<b>__can_advance</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence, _Category &gt; &amp;, const
<b>std::pair</b>&lt; _Diff, <b>_Distance_precision</b> &gt;
&amp;, int) <br>
template&lt;typename _Iterator , typename _Size &gt;
constexpr bool <b>__can_advance</b> (const
<b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__it,
_Size __n) <br>
template&lt;typename _Iterator , typename _Diff &gt;
constexpr bool <b>__can_advance</b> (const
<b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__it,
const <b>std::pair</b>&lt; _Diff, <b>_Distance_precision</b>
&gt; &amp;__dist, int __way) <br>
template&lt;typename _Iterator , typename _Size &gt;
constexpr bool <b>__can_advance</b> (const
<b>std::reverse_iterator</b>&lt; _Iterator &gt; &amp;__it,
_Size __n) <br>
template&lt;typename _Iterator , typename _Diff &gt;
constexpr bool <b>__can_advance</b> (const
<b>std::reverse_iterator</b>&lt; _Iterator &gt; &amp;__it,
const <b>std::pair</b>&lt; _Diff, <b>_Distance_precision</b>
&gt; &amp;__dist, int __way) <br>
template&lt;typename _ForwardIterator , typename _Tp &gt;
constexpr bool <b>__check_partitioned_lower</b>
(_ForwardIterator __first, _ForwardIterator __last, const
_Tp &amp;__value) <br>
template&lt;typename _ForwardIterator , typename _Tp ,
typename _Pred &gt; constexpr bool
<b>__check_partitioned_lower</b> (_ForwardIterator __first,
_ForwardIterator __last, const _Tp &amp;__value, _Pred
__pred) <br>
template&lt;typename _ForwardIterator , typename _Tp &gt;
constexpr bool <b>__check_partitioned_upper</b>
(_ForwardIterator __first, _ForwardIterator __last, const
_Tp &amp;__value) <br>
template&lt;typename _ForwardIterator , typename _Tp ,
typename _Pred &gt; constexpr bool
<b>__check_partitioned_upper</b> (_ForwardIterator __first,
_ForwardIterator __last, const _Tp &amp;__value, _Pred
__pred) <br>
template&lt;typename _Iterator &gt; constexpr bool
<b>__check_singular</b> (_Iterator const &amp;) <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__check_singular</b> (_Tp *const &amp;__ptr) <br>
bool <b>__check_singular_aux</b> (const
<b>_Safe_iterator_base</b> *__x) <br>
bool <b>__check_singular_aux</b> (const void *) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__check_sorted</b> (const _InputIterator &amp;__first,
const _InputIterator &amp;__last) <br>
template&lt;typename _InputIterator , typename _Predicate
&gt; constexpr bool <b>__check_sorted</b> (const
_InputIterator &amp;__first, const _InputIterator
&amp;__last, _Predicate __pred) <br>
template&lt;typename _ForwardIterator , typename _Predicate
&gt; constexpr bool <b>__check_sorted_aux</b>
(_ForwardIterator __first, _ForwardIterator __last,
_Predicate __pred, <b>std::forward_iterator_tag</b>) <br>
template&lt;typename _ForwardIterator &gt; constexpr bool
<b>__check_sorted_aux</b> (_ForwardIterator __first,
_ForwardIterator __last, <b>std::forward_iterator_tag</b>)
<br>
template&lt;typename _InputIterator , typename _Predicate
&gt; constexpr bool <b>__check_sorted_aux</b> (const
_InputIterator &amp;, const _InputIterator &amp;,
_Predicate, <b>std::input_iterator_tag</b>) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__check_sorted_aux</b> (const _InputIterator &amp;, const
_InputIterator &amp;, <b>std::input_iterator_tag</b>) <br>
template&lt;typename _InputIterator1 , typename
_InputIterator2 &gt; constexpr bool
<b>__check_sorted_set</b> (const _InputIterator1
&amp;__first, const _InputIterator1 &amp;__last, const
_InputIterator2 &amp;) <br>
template&lt;typename _InputIterator1 , typename
_InputIterator2 , typename _Predicate &gt; constexpr bool
<b>__check_sorted_set</b> (const _InputIterator1
&amp;__first, const _InputIterator1 &amp;__last, const
_InputIterator2 &amp;, _Predicate __pred) <br>
template&lt;typename _InputIterator , typename _Predicate
&gt; constexpr bool <b>__check_sorted_set_aux</b> (const
_InputIterator &amp;, const _InputIterator &amp;,
_Predicate, std::__false_type) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__check_sorted_set_aux</b> (const _InputIterator &amp;,
const _InputIterator &amp;, std::__false_type) <br>
template&lt;typename _InputIterator , typename _Predicate
&gt; constexpr bool <b>__check_sorted_set_aux</b> (const
_InputIterator &amp;__first, const _InputIterator
&amp;__last, _Predicate __pred, std::__true_type) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__check_sorted_set_aux</b> (const _InputIterator
&amp;__first, const _InputIterator &amp;__last,
std::__true_type) <br>
template&lt;typename _CharT , typename _Integer &gt; const
_CharT * <b>__check_string</b> (const _CharT *__s, _Integer
__n, const char *__file, unsigned int __line, const char
*__function) <br>
template&lt;typename _CharT &gt; const _CharT *
<b>__check_string</b> (const _CharT *__s, const char
*__file, unsigned int __line, const char *__function) <br>
template&lt;typename _InputIterator &gt; _InputIterator
<b>__check_valid_range</b> (const _InputIterator
&amp;__first, const _InputIterator &amp;__last, const char
*__file, unsigned int __line, const char *__function) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _InputIterator &gt; bool
<b>__foreign_iterator</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence, _Category &gt; &amp;__it,
_InputIterator __other, _InputIterator __other_end) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _Integral &gt; bool
<b>__foreign_iterator_aux</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;, _Integral, _Integral, std::__true_type) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _InputIterator &gt; bool
<b>__foreign_iterator_aux</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;__it, _InputIterator __other, _InputIterator
__other_end, std::__false_type) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _OtherIterator , typename
_OtherSequence , typename _OtherCategory &gt; bool
<b>__foreign_iterator_aux2</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;, const <b>_Safe_iterator</b>&lt; _OtherIterator,
_OtherSequence, _OtherCategory &gt; &amp;, const
<b>_Safe_iterator</b>&lt; _OtherIterator, _OtherSequence,
_OtherCategory &gt; &amp;) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _InputIterator &gt; bool
<b>__foreign_iterator_aux2</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;__it, const _InputIterator &amp;__other, const
_InputIterator &amp;__other_end) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _OtherIterator &gt; bool
<b>__foreign_iterator_aux2</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;__it, const <b>_Safe_iterator</b>&lt;
_OtherIterator, _Sequence, _Category &gt; &amp;__other,
const <b>_Safe_iterator</b>&lt; _OtherIterator, _Sequence,
_Category &gt; &amp;) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _InputIterator &gt; bool
<b>__foreign_iterator_aux3</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;, const _InputIterator &amp;, const _InputIterator
&amp;, std::__false_type) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category , typename _InputIterator &gt; bool
<b>__foreign_iterator_aux3</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;__it, const _InputIterator &amp;__other, const
_InputIterator &amp;__other_end, std::__true_type) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category &gt; bool <b>__foreign_iterator_aux4</b>
(const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence,
_Category &gt; &amp;,...) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category &gt; bool <b>__foreign_iterator_aux4</b>
(const <b>_Safe_iterator</b>&lt; _Iterator, _Sequence,
_Category &gt; &amp;__it, const typename
_Sequence::value_type *__other) <br>
template&lt;typename _Iterator &gt; constexpr
_Distance_traits&lt; _Iterator &gt;::__type
<b>__get_distance</b> (_Iterator __lhs, _Iterator __rhs)
<br>
template&lt;typename _Iterator &gt; constexpr
_Distance_traits&lt; _Iterator &gt;::__type
<b>__get_distance</b> (_Iterator __lhs, _Iterator __rhs,
<b>std::input_iterator_tag</b>) <br>
template&lt;typename _Iterator &gt; constexpr
_Distance_traits&lt; _Iterator &gt;::__type
<b>__get_distance</b> (_Iterator __lhs, _Iterator __rhs,
<b>std::random_access_iterator_tag</b>) <br>
template&lt;typename _Iterator &gt; constexpr
_Distance_traits&lt; _Iterator &gt;::__type
<b>__get_distance</b> (const <b>std::move_iterator</b>&lt;
_Iterator &gt; &amp;__first, const
<b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__last)
<br>
template&lt;typename _Iterator &gt; constexpr
_Distance_traits&lt; _Iterator &gt;::__type
<b>__get_distance</b> (const
<b>std::reverse_iterator</b>&lt; _Iterator &gt;
&amp;__first, const <b>std::reverse_iterator</b>&lt;
_Iterator &gt; &amp;__last) <br>
template&lt;typename _Iterator &gt; constexpr bool
<b>__is_irreflexive</b> (_Iterator __it) <br>
template&lt;typename _Iterator , typename _Pred &gt;
constexpr bool <b>__is_irreflexive_pred</b> (_Iterator __it,
_Pred __pred) <br>
template&lt;typename _Iterator &gt; _Iterator
<b>__unsafe</b> (_Iterator __it) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
_Iterator <b>__unsafe</b> (const <b>_Safe_iterator</b>&lt;
_Iterator, _Sequence &gt; &amp;__it) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
_Iterator <b>__unsafe</b> (const
<b>_Safe_local_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;__it) <br>
template&lt;typename _Iterator &gt; constexpr auto
<b>__unsafe</b> (const <b>std::move_iterator</b>&lt;
_Iterator &gt; &amp;__it) &minus;&gt;
decltype(std::make_move_iterator(__unsafe(__it.base())))
<br>
template&lt;typename _Iterator &gt; constexpr auto
<b>__unsafe</b> (const <b>std::reverse_iterator</b>&lt;
_Iterator &gt; &amp;__it) &minus;&gt;
decltype(std::__make_reverse_iterator(__unsafe(__it.base())))
<br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__valid_range</b> (_InputIterator __first, _InputIterator
__last) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__valid_range</b> (_InputIterator __first, _InputIterator
__last, typename _Distance_traits&lt; _InputIterator
&gt;::__type &amp;__dist) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category &gt; bool <b>__valid_range</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;, const <b>_Safe_iterator</b>&lt; _Iterator,
_Sequence, _Category &gt; &amp;) <br>
template&lt;typename _Iterator , typename _Sequence ,
typename _Category &gt; bool <b>__valid_range</b> (const
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence, _Category
&gt; &amp;, const <b>_Safe_iterator</b>&lt; _Iterator,
_Sequence, _Category &gt; &amp;, typename
_Distance_traits&lt; _Iterator &gt;::__type &amp;) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>__valid_range</b> (const
<b>_Safe_local_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;, const <b>_Safe_local_iterator</b>&lt; _Iterator,
_Sequence &gt; &amp;) <br>
template&lt;typename _Iterator , typename _Sequence &gt;
bool <b>__valid_range</b> (const
<b>_Safe_local_iterator</b>&lt; _Iterator, _Sequence &gt;
&amp;, const <b>_Safe_local_iterator</b>&lt; _Iterator,
_Sequence &gt; &amp;, typename _Distance_traits&lt;
_Iterator &gt;::__type &amp;) <br>
template&lt;typename _Iterator &gt; constexpr bool
<b>__valid_range</b> (const <b>std::move_iterator</b>&lt;
_Iterator &gt; &amp;__first, const
<b>std::move_iterator</b>&lt; _Iterator &gt; &amp;__last,
typename _Distance_traits&lt; _Iterator &gt;::__type
&amp;__dist) <br>
template&lt;typename _Iterator &gt; constexpr bool
<b>__valid_range</b> (const <b>std::reverse_iterator</b>&lt;
_Iterator &gt; &amp;__first, const
<b>std::reverse_iterator</b>&lt; _Iterator &gt; &amp;__last,
typename _Distance_traits&lt; _Iterator &gt;::__type
&amp;__dist) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__valid_range_aux</b> (_InputIterator __first,
_InputIterator __last, std::__false_type) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__valid_range_aux</b> (_InputIterator __first,
_InputIterator __last, <b>std::input_iterator_tag</b>) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__valid_range_aux</b> (_InputIterator __first,
_InputIterator __last,
<b>std::random_access_iterator_tag</b>) <br>
template&lt;typename _InputIterator &gt; constexpr bool
<b>__valid_range_aux</b> (_InputIterator __first,
_InputIterator __last, typename _Distance_traits&lt;
_InputIterator &gt;::__type &amp;__dist, std::__false_type)
<br>
template&lt;typename _Integral &gt; constexpr bool
<b>__valid_range_aux</b> (_Integral, _Integral,
std::__true_type) <br>
template&lt;typename _Integral &gt; constexpr bool
<b>__valid_range_aux</b> (_Integral, _Integral, typename
_Distance_traits&lt; _Integral &gt;::__type &amp;__dist,
std::__true_type) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>std::basic_istream</b>&lt; _CharT,
_Traits &gt; &amp; <b>getline</b>
(<b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp;__is, <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__str) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>std::basic_istream</b>&lt; _CharT,
_Traits &gt; &amp; <b>getline</b>
(<b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp;__is, <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__str, _CharT __delim) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator!=</b> (const _CharT *__lhs,
const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator
&gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator!=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator!=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; <b>operator+</b> (_CharT __lhs, const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; <b>operator+</b> (const _CharT *__lhs, const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; <b>operator+</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, _CharT __rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; <b>operator+</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; <b>operator+</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;</b> (const _CharT
*__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>std::basic_ostream</b>&lt; _CharT,
_Traits &gt; &amp; <b>operator&lt;&lt;</b>
(<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt;
&amp;__os, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__str) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const _CharT
*__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&lt;=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator==</b> (const _CharT *__lhs,
const <b>basic_string</b>&lt; _CharT, _Traits, _Allocator
&gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator==</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator==</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;</b> (const _CharT
*__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const _CharT
*__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const _CharT *__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; bool <b>operator&gt;=</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__lhs, const <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__rhs) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; <b>std::basic_istream</b>&lt; _CharT,
_Traits &gt; &amp; <b>operator&gt;&gt;</b>
(<b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp;__is, <b>basic_string</b>&lt; _CharT, _Traits,
_Allocator &gt; &amp;__str) <br>
template&lt;typename _CharT , typename _Traits , typename
_Allocator &gt; void <b>swap</b> (<b>basic_string</b>&lt;
_CharT, _Traits, _Allocator &gt; &amp;__lhs,
<b>basic_string</b>&lt; _CharT, _Traits, _Allocator &gt;
&amp;__rhs)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">GNU debug
classes for public use.</p>

<h2>Typedef Documentation
<a name="Typedef Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>typedef
basic_string&lt;char16_t&gt; __gnu_debug::u16string</b> <br>
A string of <tt>char16_t</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef
basic_string&lt;char32_t&gt; __gnu_debug::u32string</b> <br>
A string of <tt>char32_t</tt>.</p>

<h2>Enumeration Type Documentation
<a name="Enumeration Type Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>enum
__gnu_debug::_Distance_precision</b> <br>
The precision to which we can calculate the distance between
two iterators.</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr _Iterator __gnu_debug::__base
(_Iterator __it)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Helper function to extract base iterator of random access
safe iterator in order to reduce performance impact of debug
mode. Limited to random access iterator because it is the
only category for which it is possible to check for correct
iterators order in the __valid_range function thanks to the
&lt; operator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_before_dereferenceable()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; constexpr bool __gnu_debug::__check_singular (_Tp
*const &amp; __ptr)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Non-NULL pointers are nonsingular.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::__check_singular_aux (const _Safe_iterator_base
* __x)</b> <tt>[inline]</tt> <br>
Iterators that derive from _Safe_iterator_base can be
determined singular or non-singular.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT , typename _Integer &gt; const _CharT *
__gnu_debug::__check_string (const _CharT * __s, _Integer
__n, const char * __file, unsigned int __line, const char *
__function)</b> <tt>[inline]</tt> <br>
Checks that __s is non-NULL or __n == 0, and then returns
__s.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT &gt; const _CharT * __gnu_debug::__check_string
(const _CharT * __s, const char * __file, unsigned int
__line, const char * __function)</b> <tt>[inline]</tt> <br>
Checks that __s is non-NULL and then returns __s.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category ,
typename _OtherIterator , typename _OtherSequence , typename
_OtherCategory &gt; bool
__gnu_debug::__foreign_iterator_aux2 (const
_Safe_iterator&lt; _Iterator, _Sequence, _Category &gt;
&amp;, const _Safe_iterator&lt; _OtherIterator,
_OtherSequence, _OtherCategory &gt; &amp;, const
_Safe_iterator&lt; _OtherIterator, _OtherSequence,
_OtherCategory &gt; &amp;)</b> <tt>[inline]</tt> <br>
Handle debug iterators from different types of
container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category ,
typename _OtherIterator &gt; bool
__gnu_debug::__foreign_iterator_aux2 (const
_Safe_iterator&lt; _Iterator, _Sequence, _Category &gt;
&amp; __it, const _Safe_iterator&lt; _OtherIterator,
_Sequence, _Category &gt; &amp; __other, const
_Safe_iterator&lt; _OtherIterator, _Sequence, _Category &gt;
&amp;)</b> <tt>[inline]</tt> <br>
Handle debug iterators from the same type of container.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr _Distance_traits&lt; _Iterator
&gt;::__type __gnu_debug::__get_distance (_Iterator __lhs,
_Iterator __rhs, std::random_access_iterator_tag)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Determine the distance between two iterators with some known
precision.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator &gt; constexpr bool
__gnu_debug::__valid_range (_InputIterator __first,
_InputIterator __last, typename _Distance_traits&lt;
_InputIterator &gt;::__type &amp; __dist)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Don&rsquo;t know what these iterators are, or if they are
even iterators (we may get an integral type for
InputIterator), so see if they are integral and pass them on
to the next phase otherwise.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__valid_range_aux()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category &gt;
bool __gnu_debug::__valid_range (const _Safe_iterator&lt;
_Iterator, _Sequence, _Category &gt; &amp; __first, const
_Safe_iterator&lt; _Iterator, _Sequence, _Category &gt;
&amp; __last, typename _Distance_traits&lt; _Iterator
&gt;::__type &amp; __dist)</b> <tt>[inline]</tt> <br>
Safe iterators know how to check if they form a valid
range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::__valid_range (const _Safe_local_iterator&lt;
_Iterator, _Sequence &gt; &amp; __first, const
_Safe_local_iterator&lt; _Iterator, _Sequence &gt; &amp;
__last, typename _Distance_traits&lt; _Iterator &gt;::__type
&amp; __dist_info)</b> <tt>[inline]</tt> <br>
Safe local iterators know how to check if they form a valid
range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_InputIterator &gt; constexpr bool
__gnu_debug::__valid_range_aux (_InputIterator __first,
_InputIterator __last, std::__false_type)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
We have iterators, so figure out what kind of iterators they
are to see if we can check the range ahead of time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__iterator_category()</b>, and
<b>__valid_range_aux()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Integral &gt; constexpr bool __gnu_debug::__valid_range_aux
(_Integral, _Integral, std::__true_type)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
We say that integral types for a valid range, and defer to
other routines to realize what to do with integral types
instead of iterators.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__valid_range()</b>, and <b>__valid_range_aux()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
