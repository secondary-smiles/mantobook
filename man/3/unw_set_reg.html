<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:24 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>UNW_SET_REG</title>

</head>
<body>
<h1>unw_set_reg</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">unw_set_reg
&minus;&minus; set register contents</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;libunwind.h&gt;</p>

<p style="margin-left:11%; margin-top: 1em">int
unw_set_reg(unw_cursor_t *cp, unw_regnum_t reg, unw_word_t
val);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
unw_set_reg() routine sets the value of register reg in the
stack frame identified by cursor cp to the value passed in
val.</p>

<p style="margin-left:11%; margin-top: 1em">The register
numbering is target&minus;dependent and described in
separate manual pages (e.g., libunwind&minus;ia64(3) for the
IA&minus;64 target). Furthermore, the exact set of
accessible registers may depend on the type of frame that cp
is referring to. For ordinary stack frames, it is normally
possible to access only the preserved
(&lsquo;&lsquo;callee&minus;saved&rsquo;&rsquo;) registers
and frame&minus;related registers (such as the
stack&minus;pointer). However, for signal frames (see
unw_is_signal_frame(3)), it is usually possible to access
all registers.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
unw_set_reg() can only write the contents of registers whose
values fit in a single word. See unw_set_fpreg(3) for a way
to write registers which do not fit this constraint.</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">On successful
completion, unw_set_reg() returns 0. Otherwise the negative
value of one of the error&minus;codes below is returned.</p>

<h2>THREAD AND SIGNAL SAFETY
<a name="THREAD AND SIGNAL SAFETY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">unw_set_reg()
is thread&minus;safe as well as safe to use from a signal
handler.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">UNW_EUNSPEC</p>

<p style="margin-left:22%;">An unspecified error
occurred.</p>

<p style="margin-left:11%;">UNW_EBADREG</p>

<p style="margin-left:22%;">An attempt was made to write a
register that is either invalid or not accessible in the
current frame.</p>

<p style="margin-left:11%;">UNW_EREADONLY</p>

<p style="margin-left:22%;">An attempt was made to write to
a read&minus;only register.</p>

<p style="margin-left:11%; margin-top: 1em">In addition,
unw_set_reg() may return any error returned by the
access_mem(), access_reg(), and access_fpreg()
call&minus;backs (see unw_create_addr_space(3)).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libunwind(3),
libunwind&minus;ia64(3), unw_get_reg(3),
unw_is_signal_frame(3), unw_set_fpreg(3)</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">David
Mosberger&minus;Tang <br>
Email: <b>dmosberger@gmail.com</b> <br>
WWW: <b>http://www.nongnu.org/libunwind/</b>.</p>
<hr>
</body>
</html>
