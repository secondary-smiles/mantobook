<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:53 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EVP_ENCRYPTINIT</title>

</head>
<body>
<h1>EVP_CIPHER_CTX_set_key_length</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">EVP_CIPHER_fetch,
EVP_CIPHER_up_ref, EVP_CIPHER_free, EVP_CIPHER_CTX_new,
EVP_CIPHER_CTX_reset, EVP_CIPHER_CTX_free,
EVP_EncryptInit_ex, EVP_EncryptInit_ex2, EVP_EncryptUpdate,
EVP_EncryptFinal_ex, EVP_DecryptInit_ex,
EVP_DecryptInit_ex2, EVP_DecryptUpdate, EVP_DecryptFinal_ex,
EVP_CipherInit_ex, EVP_CipherInit_ex2, EVP_CipherUpdate,
EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length,
EVP_CIPHER_CTX_ctrl, EVP_EncryptInit, EVP_EncryptFinal,
EVP_DecryptInit, EVP_DecryptFinal, EVP_CipherInit,
EVP_CipherFinal, EVP_Cipher, EVP_get_cipherbyname,
EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_is_a,
EVP_CIPHER_get0_name, EVP_CIPHER_get0_description,
EVP_CIPHER_names_do_all, EVP_CIPHER_get0_provider,
EVP_CIPHER_get_nid, EVP_CIPHER_get_params,
EVP_CIPHER_gettable_params, EVP_CIPHER_get_block_size,
EVP_CIPHER_get_key_length, EVP_CIPHER_get_iv_length,
EVP_CIPHER_get_flags, EVP_CIPHER_get_mode,
EVP_CIPHER_get_type, EVP_CIPHER_CTX_cipher,
EVP_CIPHER_CTX_get0_cipher, EVP_CIPHER_CTX_get1_cipher,
EVP_CIPHER_CTX_get0_name, EVP_CIPHER_CTX_get_nid,
EVP_CIPHER_CTX_get_params, EVP_CIPHER_gettable_ctx_params,
EVP_CIPHER_CTX_gettable_params, EVP_CIPHER_CTX_set_params,
EVP_CIPHER_settable_ctx_params,
EVP_CIPHER_CTX_settable_params,
EVP_CIPHER_CTX_get_block_size,
EVP_CIPHER_CTX_get_key_length, EVP_CIPHER_CTX_get_iv_length,
EVP_CIPHER_CTX_get_tag_length, EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_flags,
EVP_CIPHER_CTX_set_flags, EVP_CIPHER_CTX_clear_flags,
EVP_CIPHER_CTX_test_flags, EVP_CIPHER_CTX_get_type,
EVP_CIPHER_CTX_get_mode, EVP_CIPHER_CTX_get_num,
EVP_CIPHER_CTX_set_num, EVP_CIPHER_CTX_is_encrypting,
EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_padding, EVP_enc_null,
EVP_CIPHER_do_all_provided, EVP_CIPHER_nid, EVP_CIPHER_name,
EVP_CIPHER_block_size, EVP_CIPHER_key_length,
EVP_CIPHER_iv_length, EVP_CIPHER_flags, EVP_CIPHER_mode,
EVP_CIPHER_type, EVP_CIPHER_CTX_encrypting,
EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size,
EVP_CIPHER_CTX_key_length, EVP_CIPHER_CTX_iv_length,
EVP_CIPHER_CTX_tag_length, EVP_CIPHER_CTX_num,
EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_mode &minus; EVP cipher
routines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/evp.h&gt; <br>
EVP_CIPHER *EVP_CIPHER_fetch(OSSL_LIB_CTX *ctx, const char
*algorithm, <br>
const char *properties); <br>
int EVP_CIPHER_up_ref(EVP_CIPHER *cipher); <br>
void EVP_CIPHER_free(EVP_CIPHER *cipher); <br>
EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void); <br>
int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *ctx); <br>
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx); <br>
int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER
*type, <br>
ENGINE *impl, const unsigned char *key, const unsigned char
*iv); <br>
int EVP_EncryptInit_ex2(EVP_CIPHER_CTX *ctx, const
EVP_CIPHER *type, <br>
const unsigned char *key, const unsigned char *iv, <br>
const OSSL_PARAM params[]); <br>
int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char
*out, <br>
int *outl, const unsigned char *in, int inl); <br>
int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char
*out, int *outl); <br>
int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER
*type, <br>
ENGINE *impl, const unsigned char *key, const unsigned char
*iv); <br>
int EVP_DecryptInit_ex2(EVP_CIPHER_CTX *ctx, const
EVP_CIPHER *type, <br>
const unsigned char *key, const unsigned char *iv, <br>
const OSSL_PARAM params[]); <br>
int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char
*out, <br>
int *outl, const unsigned char *in, int inl); <br>
int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char
*outm, int *outl); <br>
int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER
*type, <br>
ENGINE *impl, const unsigned char *key, const unsigned char
*iv, int enc); <br>
int EVP_CipherInit_ex2(EVP_CIPHER_CTX *ctx, const EVP_CIPHER
*type, <br>
const unsigned char *key, const unsigned char *iv, <br>
int enc, const OSSL_PARAM params[]); <br>
int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char
*out, <br>
int *outl, const unsigned char *in, int inl); <br>
int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char
*outm, int *outl); <br>
int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER
*type, <br>
const unsigned char *key, const unsigned char *iv); <br>
int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char
*out, int *outl); <br>
int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER
*type, <br>
const unsigned char *key, const unsigned char *iv); <br>
int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char
*outm, int *outl); <br>
int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER
*type, <br>
const unsigned char *key, const unsigned char *iv, int enc);
<br>
int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char
*outm, int *outl); <br>
int EVP_Cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, <br>
const unsigned char *in, unsigned int inl); <br>
int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int
padding); <br>
int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int
keylen); <br>
int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int cmd, int
p1, void *p2); <br>
int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned
char *key); <br>
void EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int
flags); <br>
void EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int
flags); <br>
int EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int
flags); <br>
const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
<br>
const EVP_CIPHER *EVP_get_cipherbynid(int nid); <br>
const EVP_CIPHER *EVP_get_cipherbyobj(const ASN1_OBJECT *a);
<br>
int EVP_CIPHER_get_nid(const EVP_CIPHER *e); <br>
int EVP_CIPHER_is_a(const EVP_CIPHER *cipher, const char
*name); <br>
int EVP_CIPHER_names_do_all(const EVP_CIPHER *cipher, <br>
void (*fn)(const char *name, void *data), <br>
void *data); <br>
const char *EVP_CIPHER_get0_name(const EVP_CIPHER *cipher);
<br>
const char *EVP_CIPHER_get0_description(const EVP_CIPHER
*cipher); <br>
const OSSL_PROVIDER *EVP_CIPHER_get0_provider(const
EVP_CIPHER *cipher); <br>
int EVP_CIPHER_get_block_size(const EVP_CIPHER *e); <br>
int EVP_CIPHER_get_key_length(const EVP_CIPHER *e); <br>
int EVP_CIPHER_get_iv_length(const EVP_CIPHER *e); <br>
unsigned long EVP_CIPHER_get_flags(const EVP_CIPHER *e);
<br>
unsigned long EVP_CIPHER_get_mode(const EVP_CIPHER *e); <br>
int EVP_CIPHER_get_type(const EVP_CIPHER *cipher); <br>
const EVP_CIPHER *EVP_CIPHER_CTX_get0_cipher(const
EVP_CIPHER_CTX *ctx); <br>
EVP_CIPHER *EVP_CIPHER_CTX_get1_cipher(const EVP_CIPHER_CTX
*ctx); <br>
int EVP_CIPHER_CTX_get_nid(const EVP_CIPHER_CTX *ctx); <br>
const char *EVP_CIPHER_CTX_get0_name(const EVP_CIPHER_CTX
*ctx); <br>
int EVP_CIPHER_get_params(EVP_CIPHER *cipher, OSSL_PARAM
params[]); <br>
int EVP_CIPHER_CTX_set_params(EVP_CIPHER_CTX *ctx, const
OSSL_PARAM params[]); <br>
int EVP_CIPHER_CTX_get_params(EVP_CIPHER_CTX *ctx,
OSSL_PARAM params[]); <br>
const OSSL_PARAM *EVP_CIPHER_gettable_params(const
EVP_CIPHER *cipher); <br>
const OSSL_PARAM *EVP_CIPHER_settable_ctx_params(const
EVP_CIPHER *cipher); <br>
const OSSL_PARAM *EVP_CIPHER_gettable_ctx_params(const
EVP_CIPHER *cipher); <br>
const OSSL_PARAM
*EVP_CIPHER_CTX_settable_params(EVP_CIPHER_CTX *ctx); <br>
const OSSL_PARAM
*EVP_CIPHER_CTX_gettable_params(EVP_CIPHER_CTX *ctx); <br>
int EVP_CIPHER_CTX_get_block_size(const EVP_CIPHER_CTX
*ctx); <br>
int EVP_CIPHER_CTX_get_key_length(const EVP_CIPHER_CTX
*ctx); <br>
int EVP_CIPHER_CTX_get_iv_length(const EVP_CIPHER_CTX *ctx);
<br>
int EVP_CIPHER_CTX_get_tag_length(const EVP_CIPHER_CTX
*ctx); <br>
void *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX
*ctx); <br>
void EVP_CIPHER_CTX_set_app_data(const EVP_CIPHER_CTX *ctx,
void *data); <br>
int EVP_CIPHER_CTX_get_type(const EVP_CIPHER_CTX *ctx); <br>
int EVP_CIPHER_CTX_get_mode(const EVP_CIPHER_CTX *ctx); <br>
int EVP_CIPHER_CTX_get_num(const EVP_CIPHER_CTX *ctx); <br>
int EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx, int num);
<br>
int EVP_CIPHER_CTX_is_encrypting(const EVP_CIPHER_CTX *ctx);
<br>
int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE
*type); <br>
int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE
*type); <br>
void EVP_CIPHER_do_all_provided(OSSL_LIB_CTX *libctx, <br>
void (*fn)(EVP_CIPHER *cipher, void *arg), <br>
void *arg); <br>
#define EVP_CIPHER_nid EVP_CIPHER_get_nid <br>
#define EVP_CIPHER_name EVP_CIPHER_get0_name <br>
#define EVP_CIPHER_block_size EVP_CIPHER_get_block_size <br>
#define EVP_CIPHER_key_length EVP_CIPHER_get_key_length <br>
#define EVP_CIPHER_iv_length EVP_CIPHER_get_iv_length <br>
#define EVP_CIPHER_flags EVP_CIPHER_get_flags <br>
#define EVP_CIPHER_mode EVP_CIPHER_get_mode <br>
#define EVP_CIPHER_type EVP_CIPHER_get_type <br>
#define EVP_CIPHER_CTX_encrypting
EVP_CIPHER_CTX_is_encrypting <br>
#define EVP_CIPHER_CTX_nid EVP_CIPHER_CTX_get_nid <br>
#define EVP_CIPHER_CTX_block_size
EVP_CIPHER_CTX_get_block_size <br>
#define EVP_CIPHER_CTX_key_length
EVP_CIPHER_CTX_get_key_length <br>
#define EVP_CIPHER_CTX_iv_length
EVP_CIPHER_CTX_get_iv_length <br>
#define EVP_CIPHER_CTX_tag_length
EVP_CIPHER_CTX_get_tag_length <br>
#define EVP_CIPHER_CTX_num EVP_CIPHER_CTX_get_num <br>
#define EVP_CIPHER_CTX_type EVP_CIPHER_CTX_get_type <br>
#define EVP_CIPHER_CTX_mode EVP_CIPHER_CTX_get_mode</p>

<p style="margin-left:11%; margin-top: 1em">The following
function has been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining
<b><small>OPENSSL_API_COMPAT</small></b> with a suitable
version value, see <b>openssl_user_macros</b>(7):</p>

<p style="margin-left:11%; margin-top: 1em">const
EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX
*ctx);</p>

<p style="margin-left:11%; margin-top: 1em">The following
function has been deprecated since OpenSSL 1.1.0, and can be
hidden entirely by defining
<b><small>OPENSSL_API_COMPAT</small></b> with a suitable
version value, see <b>openssl_user_macros</b>(7):</p>

<p style="margin-left:11%; margin-top: 1em">int
EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>EVP</small> cipher routines are a high-level
interface to certain symmetric ciphers.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>EVP_CIPHER</small></b> type is a structure for
cipher method implementation. <b><br>
EVP_CIPHER_fetch()</b></p>

<p style="margin-left:17%;">Fetches the cipher
implementation for the given <i>algorithm</i> from any
provider offering it, within the criteria given by the
<i>properties</i>. See &quot; <small>ALGORITHM
FETCHING&quot;</small> in <b>crypto</b>(7) for further
information.</p>

<p style="margin-left:17%; margin-top: 1em">The returned
value must eventually be freed with
<b>EVP_CIPHER_free()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">Fetched
<b><small>EVP_CIPHER</small></b> structures are reference
counted.</p>

<p style="margin-left:11%;"><b>EVP_CIPHER_up_ref()</b></p>

<p style="margin-left:17%;">Increments the reference count
for an <b><small>EVP_CIPHER</small></b> structure.</p>

<p style="margin-left:11%;"><b>EVP_CIPHER_free()</b></p>

<p style="margin-left:17%;">Decrements the reference count
for the fetched <b><small>EVP_CIPHER</small></b> structure.
If the reference count drops to 0 then the structure is
freed.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_new()</b></p>

<p style="margin-left:17%;">Allocates and returns a cipher
context.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_free()</b></p>

<p style="margin-left:17%;">Clears all information from a
cipher context and frees any allocated memory associated
with it, including <i>ctx</i> itself. This function should
be called after all operations using a cipher are complete
so sensitive information does not remain in memory.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_ctrl()</b></p>

<p style="margin-left:17%;"><i>This is a legacy method.</i>
<b>EVP_CIPHER_CTX_set_params()</b> and
<b>EVP_CIPHER_CTX_get_params()</b> is the mechanism that
should be used to set and get parameters that are used by
providers.</p>

<p style="margin-left:17%; margin-top: 1em">Performs
cipher-specific control actions on context <i>ctx</i>. The
control command is indicated in <i>cmd</i> and any
additional arguments in <i>p1</i> and <i>p2</i>.
<b>EVP_CIPHER_CTX_ctrl()</b> must be called after
<b>EVP_CipherInit_ex2()</b>. Other restrictions may apply
depending on the control type and cipher implementation.</p>

<p style="margin-left:17%; margin-top: 1em">If this
function happens to be used with a fetched
<b><small>EVP_CIPHER</small></b> , it will translate the
controls that are known to OpenSSL into
<b><small>OSSL_PARAM</small></b> (3) parameters with keys
defined by OpenSSL and call
<b>EVP_CIPHER_CTX_get_params()</b> or
<b>EVP_CIPHER_CTX_set_params()</b> as is appropriate for
each control command.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>CONTROLS&quot;</small> below for more information,
including what translations are being done.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_get_params()</b></p>

<p style="margin-left:17%;">Retrieves the requested list of
algorithm <i>params</i> from a <small>CIPHER</small>
<i>cipher</i>. See &quot; <small>PARAMETERS&quot;</small>
below for more information.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_get_params()</b></p>

<p style="margin-left:17%;">Retrieves the requested list of
<i>params</i> from <small>CIPHER</small> context <i>ctx</i>.
See &quot; <small>PARAMETERS&quot;</small> below for more
information.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_set_params()</b></p>

<p style="margin-left:17%;">Sets the list of <i>params</i>
into a <small>CIPHER</small> context <i>ctx</i>. See &quot;
<small>PARAMETERS&quot;</small> below for more
information.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_gettable_params()</b></p>

<p style="margin-left:17%;">Get a constant
<b><small>OSSL_PARAM</small></b> (3) array that describes
the retrievable parameters that can be used with
<b>EVP_CIPHER_get_params()</b>.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_gettable_ctx_params()</b>
and <b>EVP_CIPHER_CTX_gettable_params()</b></p>

<p style="margin-left:17%;">Get a constant
<b><small>OSSL_PARAM</small></b> (3) array that describes
the retrievable parameters that can be used with
<b>EVP_CIPHER_CTX_get_params()</b>.
<b>EVP_CIPHER_gettable_ctx_params()</b> returns the
parameters that can be retrieved from the algorithm, whereas
<b>EVP_CIPHER_CTX_gettable_params()</b> returns the
parameters that can be retrieved in the context&rsquo;s
current state.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_settable_ctx_params()</b>
and <b>EVP_CIPHER_CTX_settable_params()</b></p>

<p style="margin-left:17%;">Get a constant
<b><small>OSSL_PARAM</small></b> (3) array that describes
the settable parameters that can be used with
<b>EVP_CIPHER_CTX_set_params()</b>.
<b>EVP_CIPHER_settable_ctx_params()</b> returns the
parameters that can be set from the algorithm, whereas
<b>EVP_CIPHER_CTX_settable_params()</b> returns the
parameters that can be set in the context&rsquo;s current
state.</p>


<p style="margin-left:11%;"><b>EVP_EncryptInit_ex2()</b></p>

<p style="margin-left:17%;">Sets up cipher context
<i>ctx</i> for encryption with cipher <i>type</i>.
<i>type</i> is typically supplied by calling
<b>EVP_CIPHER_fetch()</b>. <i>type</i> may also be set using
legacy functions such as <b>EVP_aes_256_cbc()</b>, but this
is not recommended for new applications. <i>key</i> is the
symmetric key to use and <i>iv</i> is the <small>IV</small>
to use (if necessary), the actual number of bytes used for
the key and <small>IV</small> depends on the cipher. The
parameters <i>params</i> will be set on the context after
initialisation. It is possible to set all parameters to
<small>NULL</small> except <i>type</i> in an initial call
and supply the remaining parameters in subsequent calls, all
of which have <i>type</i> set to <small>NULL.</small> This
is done when the default cipher parameters are not
appropriate. For <b><small>EVP_CIPH_GCM_MODE</small></b> the
<small>IV</small> will be generated internally if it is not
specified.</p>


<p style="margin-left:11%;"><b>EVP_EncryptInit_ex()</b></p>

<p style="margin-left:17%;">This legacy function is similar
to <b>EVP_EncryptInit_ex2()</b> when <i>impl</i> is
<small>NULL.</small> The implementation of the <i>type</i>
from the <i>impl</i> engine will be used if it exists.</p>

<p style="margin-left:11%;"><b>EVP_EncryptUpdate()</b></p>

<p style="margin-left:17%;">Encrypts <i>inl</i> bytes from
the buffer <i>in</i> and writes the encrypted version to
<i>out</i>. This function can be called multiple times to
encrypt successive blocks of data. The amount of data
written depends on the block alignment of the encrypted
data. For most ciphers and modes, the amount of data written
can be anything from zero bytes to (inl + cipher_block_size
&minus; 1) bytes. For wrap cipher modes, the amount of data
written can be anything from zero bytes to (inl +
cipher_block_size) bytes. For stream ciphers, the amount of
data written can be anything from zero bytes to inl bytes.
Thus, <i>out</i> should contain sufficient room for the
operation being performed. The actual number of bytes
written is placed in <i>outl</i>. It also checks if
<i>in</i> and <i>out</i> are partially overlapping, and if
they are 0 is returned to indicate failure.</p>

<p style="margin-left:17%; margin-top: 1em">If padding is
enabled (the default) then <b>EVP_EncryptFinal_ex()</b>
encrypts the &quot;final&quot; data, that is any data that
remains in a partial block. It uses standard block padding
(aka <small>PKCS</small> padding) as described in the
<small>NOTES</small> section, below. The encrypted final
data is written to <i>out</i> which should have sufficient
space for one cipher block. The number of bytes written is
placed in <i>outl</i>. After this function is called the
encryption operation is finished and no further calls to
<b>EVP_EncryptUpdate()</b> should be made.</p>

<p style="margin-left:17%; margin-top: 1em">If padding is
disabled then <b>EVP_EncryptFinal_ex()</b> will not encrypt
any more data and it will return an error if any data
remains in a partial block: that is if the total data length
is not a multiple of the block size.</p>

<p style="margin-left:11%;"><b>EVP_DecryptInit_ex2()</b>,
<b>EVP_DecryptInit_ex()</b>, <b>EVP_DecryptUpdate()</b> and
<b><br>
EVP_DecryptFinal_ex()</b></p>

<p style="margin-left:17%;">These functions are the
corresponding decryption operations.
<b>EVP_DecryptFinal()</b> will return an error code if
padding is enabled and the final block is not correctly
formatted. The parameters and restrictions are identical to
the encryption operations except that if padding is enabled
the decrypted data buffer <i>out</i> passed to
<b>EVP_DecryptUpdate()</b> should have sufficient room for
(<i>inl</i> + cipher_block_size) bytes unless the cipher
block size is 1 in which case <i>inl</i> bytes is
sufficient.</p>

<p style="margin-left:11%;"><b>EVP_CipherInit_ex2()</b>,
<b>EVP_CipherInit_ex()</b>, <b>EVP_CipherUpdate()</b> and
<b><br>
EVP_CipherFinal_ex()</b></p>

<p style="margin-left:17%;">These functions can be used for
decryption or encryption. The operation performed depends on
the value of the <i>enc</i> parameter. It should be set to 1
for encryption, 0 for decryption and &minus;1 to leave the
value unchanged (the actual value of &rsquo;enc&rsquo; being
supplied in a previous call).</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_reset()</b></p>

<p style="margin-left:17%;">Clears all information from a
cipher context and free up any allocated memory associated
with it, except the <i>ctx</i> itself. This function should
be called anytime <i>ctx</i> is reused by another
<b>EVP_CipherInit()</b> / <b>EVP_CipherUpdate()</b> /
<b>EVP_CipherFinal()</b> series of calls.</p>

<p style="margin-left:11%;"><b>EVP_EncryptInit()</b>,
<b>EVP_DecryptInit()</b> and <b>EVP_CipherInit()</b></p>

<p style="margin-left:17%;">Behave in a similar way to
<b>EVP_EncryptInit_ex()</b>, <b>EVP_DecryptInit_ex()</b> and
<b>EVP_CipherInit_ex()</b> except if the <i>type</i> is not
a fetched cipher they use the default implementation of the
<i>type</i>.</p>

<p style="margin-left:11%;"><b>EVP_EncryptFinal()</b>,
<b>EVP_DecryptFinal()</b> and <b>EVP_CipherFinal()</b></p>

<p style="margin-left:17%;">Identical to
<b>EVP_EncryptFinal_ex()</b>, <b>EVP_DecryptFinal_ex()</b>
and <b>EVP_CipherFinal_ex()</b>. In previous releases they
also cleaned up the <i>ctx</i>, but this is no longer done
and <b>EVP_CIPHER_CTX_cleanup()</b> must be called to free
any context resources.</p>

<p style="margin-left:11%;"><b>EVP_Cipher()</b></p>

<p style="margin-left:17%;">Encrypts or decrypts a maximum
<i>inl</i> amount of bytes from <i>in</i> and leaves the
result in <i>out</i>.</p>

<p style="margin-left:17%; margin-top: 1em">For legacy
ciphers &minus; If the cipher doesn&rsquo;t have the flag
<b><small>EVP_CIPH_FLAG_CUSTOM_CIPHER</small></b> set, then
<i>inl</i> must be a multiple of
<b>EVP_CIPHER_get_block_size()</b>. If it isn&rsquo;t, the
result is undefined. If the cipher has that flag set, then
<i>inl</i> can be any size.</p>

<p style="margin-left:17%; margin-top: 1em">Due to the
constraints of the <small>API</small> contract of this
function it shouldn&rsquo;t be used in applications, please
consider using <b>EVP_CipherUpdate()</b> and
<b>EVP_CipherFinal_ex()</b> instead.</p>

<p style="margin-left:11%;"><b>EVP_get_cipherbyname()</b>,
<b>EVP_get_cipherbynid()</b> and
<b>EVP_get_cipherbyobj()</b></p>

<p style="margin-left:17%;">Returns an
<b><small>EVP_CIPHER</small></b> structure when passed a
cipher name, a cipher <b><small>NID</small></b> or an
<b><small>ASN1_OBJECT</small></b> structure
respectively.</p>


<p style="margin-left:17%; margin-top: 1em"><b>EVP_get_cipherbyname()</b>
will return <small>NULL</small> for algorithms such as
&quot; <small>AES&minus;128&minus;SIV&quot;,
&quot;AES&minus;128&minus;CBC&minus;CTS&quot;</small> and
&quot;
<small>CAMELLIA&minus;128&minus;CBC&minus;CTS&quot;</small>
which were previously only accessible via low level
interfaces.</p>

<p style="margin-left:17%; margin-top: 1em">The
<b>EVP_get_cipherbyname()</b> function is present for
backwards compatibility with OpenSSL prior to version 3 and
is different to the <b>EVP_CIPHER_fetch()</b> function since
it does not attempt to &quot;fetch&quot; an implementation
of the cipher. Additionally, it only knows about ciphers
that are built-in to OpenSSL and have an associated
<small>NID.</small> Similarly <b>EVP_get_cipherbynid()</b>
and <b>EVP_get_cipherbyobj()</b> also return objects without
an associated implementation.</p>

<p style="margin-left:17%; margin-top: 1em">When the cipher
objects returned by these functions are used (such as in a
call to <b>EVP_EncryptInit_ex()</b>) an implementation of
the cipher will be implicitly fetched from the loaded
providers. This fetch could fail if no suitable
implementation is available. Use <b>EVP_CIPHER_fetch()</b>
instead to explicitly fetch the algorithm and an associated
implementation from a provider.</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>ALGORITHM FETCHING&quot;</small> in <b>crypto</b>(7)
for more information about fetching.</p>

<p style="margin-left:17%; margin-top: 1em">The cipher
objects returned from these functions do not need to be
freed with <b>EVP_CIPHER_free()</b>.</p>

<p style="margin-left:11%;"><b>EVP_CIPHER_get_nid()</b> and
<b>EVP_CIPHER_CTX_get_nid()</b></p>

<p style="margin-left:17%;">Return the <small>NID</small>
of a cipher when passed an <b><small>EVP_CIPHER</small></b>
or <b><small>EVP_CIPHER_CTX</small></b> structure. The
actual <small>NID</small> value is an internal value which
may not have a corresponding <small>OBJECT
IDENTIFIER.</small></p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_set_flags()</b>,
<b>EVP_CIPHER_CTX_clear_flags()</b> and <b><br>
EVP_CIPHER_CTX_test_flags()</b></p>

<p style="margin-left:17%;">Sets, clears and tests
<i>ctx</i> flags. See &quot; <small>FLAGS&quot;</small>
below for more information.</p>

<p style="margin-left:17%; margin-top: 1em">For provided
ciphers <b>EVP_CIPHER_CTX_set_flags()</b> should be called
only after the fetched cipher has been assigned to the
<i>ctx</i>. It is recommended to use &quot;
<small>PARAMETERS&quot;</small> instead.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_set_padding()</b></p>

<p style="margin-left:17%;">Enables or disables padding.
This function should be called after the context is set up
for encryption or decryption with
<b>EVP_EncryptInit_ex2()</b>, <b>EVP_DecryptInit_ex2()</b>
or <b>EVP_CipherInit_ex2()</b>. By default encryption
operations are padded using standard block padding and the
padding is checked and removed when decrypting. If the
<i>pad</i> parameter is zero then no padding is performed,
the total amount of data encrypted or decrypted must then be
a multiple of the block size or an error will occur.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_get_key_length()</b>
and <b>EVP_CIPHER_CTX_get_key_length()</b></p>

<p style="margin-left:17%;">Return the key length of a
cipher when passed an <b><small>EVP_CIPHER</small></b> or
<b><small>EVP_CIPHER_CTX</small></b> structure. The constant
<b><small>EVP_MAX_KEY_LENGTH</small></b> is the maximum key
length for all ciphers. Note: although
<b>EVP_CIPHER_get_key_length()</b> is fixed for a given
cipher, the value of <b>EVP_CIPHER_CTX_get_key_length()</b>
may be different for variable key length ciphers.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_set_key_length()</b></p>

<p style="margin-left:17%;">Sets the key length of the
cipher context. If the cipher is a fixed length cipher then
attempting to set the key length to any value other than the
fixed value is an error.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_get_iv_length()</b>
and <b>EVP_CIPHER_CTX_get_iv_length()</b></p>

<p style="margin-left:17%;">Return the <small>IV</small>
length of a cipher when passed an
<b><small>EVP_CIPHER</small></b> or
<b><small>EVP_CIPHER_CTX</small></b> . It will return zero
if the cipher does not use an <small>IV.</small> The
constant <b><small>EVP_MAX_IV_LENGTH</small></b> is the
maximum <small>IV</small> length for all ciphers.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_get_tag_length()</b></p>

<p style="margin-left:17%;">Returns the tag length of an
<small>AEAD</small> cipher when passed a
<b><small>EVP_CIPHER_CTX</small></b> . It will return zero
if the cipher does not support a tag. It returns a default
value if the tag length has not been set.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_get_block_size()</b>
and <b>EVP_CIPHER_CTX_get_block_size()</b></p>

<p style="margin-left:17%;">Return the block size of a
cipher when passed an <b><small>EVP_CIPHER</small></b> or
<b><small>EVP_CIPHER_CTX</small></b> structure. The constant
<b><small>EVP_MAX_BLOCK_LENGTH</small></b> is also the
maximum block length for all ciphers.</p>

<p style="margin-left:11%;"><b>EVP_CIPHER_get_type()</b>
and <b>EVP_CIPHER_CTX_get_type()</b></p>

<p style="margin-left:17%;">Return the type of the passed
cipher or context. This &quot;type&quot; is the actual
<small>NID</small> of the cipher <small>OBJECT
IDENTIFIER</small> and as such it ignores the cipher
parameters (40 bit <small>RC2</small> and 128 bit
<small>RC2</small> have the same <small>NID</small> ). If
the cipher does not have an object identifier or does not
have <small>ASN1</small> support this function will return
<b>NID_undef</b>.</p>

<p style="margin-left:11%;"><b>EVP_CIPHER_is_a()</b></p>

<p style="margin-left:17%;">Returns 1 if <i>cipher</i> is
an implementation of an algorithm that&rsquo;s identifiable
with <i>name</i>, otherwise 0. If <i>cipher</i> is a legacy
cipher (it&rsquo;s the return value from the likes of
<b>EVP_aes128()</b> rather than the result of an
<b>EVP_CIPHER_fetch()</b>), only cipher names registered
with the default library context (see
<b><small>OSSL_LIB_CTX</small></b> (3)) will be
considered.</p>

<p style="margin-left:11%;"><b>EVP_CIPHER_get0_name()</b>
and <b>EVP_CIPHER_CTX_get0_name()</b></p>

<p style="margin-left:17%;">Return the name of the passed
cipher or context. For fetched ciphers with multiple names,
only one of them is returned. See also
<b>EVP_CIPHER_names_do_all()</b>.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_names_do_all()</b></p>

<p style="margin-left:17%;">Traverses all names for the
<i>cipher</i>, and calls <i>fn</i> with each name and
<i>data</i>. This is only useful with fetched
<b><small>EVP_CIPHER</small></b> s.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_get0_description()</b></p>

<p style="margin-left:17%;">Returns a description of the
cipher, meant for display and human consumption. The
description is at the discretion of the cipher
implementation.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_get0_provider()</b></p>

<p style="margin-left:17%;">Returns an
<b><small>OSSL_PROVIDER</small></b> pointer to the provider
that implements the given <b><small>EVP_CIPHER</small></b>
.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_get0_cipher()</b></p>

<p style="margin-left:17%;">Returns the
<b><small>EVP_CIPHER</small></b> structure when passed an
<b><small>EVP_CIPHER_CTX</small></b> structure.
<b>EVP_CIPHER_CTX_get1_cipher()</b> is the same except the
ownership is passed to the caller.</p>

<p style="margin-left:11%;"><b>EVP_CIPHER_get_mode()</b>
and <b>EVP_CIPHER_CTX_get_mode()</b></p>

<p style="margin-left:17%;">Return the block cipher mode:
<small>EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE,
EVP_CIPH_CFB_MODE, EVP_CIPH_OFB_MODE, EVP_CIPH_CTR_MODE,
EVP_CIPH_GCM_MODE, EVP_CIPH_CCM_MODE, EVP_CIPH_XTS_MODE,
EVP_CIPH_WRAP_MODE, EVP_CIPH_OCB_MODE</small> or
<small>EVP_CIPH_SIV_MODE.</small> If the cipher is a stream
cipher then <small>EVP_CIPH_STREAM_CIPHER</small> is
returned.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_get_flags()</b></p>

<p style="margin-left:17%;">Returns any flags associated
with the cipher. See &quot; <small>FLAGS&quot;</small> for a
list of currently defined flags.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_get_num()</b>
and <b>EVP_CIPHER_CTX_set_num()</b></p>

<p style="margin-left:17%;">Gets or sets the cipher
specific &quot;num&quot; parameter for the associated
<i>ctx</i>. Built-in ciphers typically use this to track how
much of the current underlying block has been
&quot;used&quot; already.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_is_encrypting()</b></p>

<p style="margin-left:17%;">Reports whether the <i>ctx</i>
is being used for encryption or decryption.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_flags()</b></p>

<p style="margin-left:17%;">A deprecated macro calling
&quot;EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ctx))&quot;.
Do not use.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_param_to_asn1()</b></p>

<p style="margin-left:17%;">Sets the AlgorithmIdentifier
&quot;parameter&quot; based on the passed cipher. This will
typically include any parameters and an <small>IV.</small>
The cipher <small>IV</small> (if any) must be set when this
call is made. This call should be made before the cipher is
actually &quot;used&quot; (before any
<b>EVP_EncryptUpdate()</b>, <b>EVP_DecryptUpdate()</b> calls
for example). This function may fail if the cipher does not
have any <small>ASN1</small> support.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_asn1_to_param()</b></p>

<p style="margin-left:17%;">Sets the cipher parameters
based on an <small>ASN1</small> AlgorithmIdentifier
&quot;parameter&quot;. The precise effect depends on the
cipher. In the case of <b><small>RC2</small></b> , for
example, it will set the <small>IV</small> and effective key
length. This function should be called after the base cipher
type is set but before the key is set. For example
<b>EVP_CipherInit()</b> will be called with the
<small>IV</small> and key set to <small>NULL,</small>
<b>EVP_CIPHER_asn1_to_param()</b> will be called and finally
<b>EVP_CipherInit()</b> again with all parameters except the
key set to <small>NULL.</small> It is possible for this
function to fail if the cipher does not have any
<small>ASN1</small> support or the parameters cannot be set
(for example the <small>RC2</small> effective key length is
not supported.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_CTX_rand_key()</b></p>

<p style="margin-left:17%;">Generates a random key of the
appropriate length based on the cipher context. The
<b><small>EVP_CIPHER</small></b> can provide its own random
key generation routine to support keys of a specific form.
<i>key</i> must point to a buffer at least as big as the
value returned by
<b>EVP_CIPHER_CTX_get_key_length()</b>.</p>


<p style="margin-left:11%;"><b>EVP_CIPHER_do_all_provided()</b></p>

<p style="margin-left:17%;">Traverses all ciphers
implemented by all activated providers in the given library
context <i>libctx</i>, and for each of the implementations,
calls the given function <i>fn</i> with the implementation
method and the given <i>arg</i> as argument.</p>

<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See
<b><small>OSSL_PARAM</small></b> (3) for information about
passing parameters.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Gettable
<small>EVP_CIPHER</small> parameters</b> <br>
When <b>EVP_CIPHER_fetch()</b> is called it internally calls
<b>EVP_CIPHER_get_params()</b> and caches the results.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_get_params()</b>
can be used with the following
<b><small>OSSL_PARAM</small></b> (3) keys: <br>
&quot;mode&quot; (
<b><small>OSSL_CIPHER_PARAM_MODE</small></b> ) &lt;unsigned
integer&gt;</p>

<p style="margin-left:17%;">Gets the mode for the
associated cipher algorithm <i>cipher</i>. See
&quot;<b>EVP_CIPHER_get_mode()</b> and
<b>EVP_CIPHER_CTX_get_mode()</b>&quot; for a list of valid
modes. Use <b>EVP_CIPHER_get_mode()</b> to retrieve the
cached value.</p>

<p style="margin-left:11%;">&quot;keylen&quot; (
<b><small>OSSL_CIPHER_PARAM_KEYLEN</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets the key length for the
associated cipher algorithm <i>cipher</i>. Use
<b>EVP_CIPHER_get_key_length()</b> to retrieve the cached
value.</p>

<p style="margin-left:11%;">&quot;ivlen&quot; (
<b><small>OSSL_CIPHER_PARAM_IVLEN</small></b> ) &lt;unsigned
integer&gt;</p>

<p style="margin-left:17%;">Gets the <small>IV</small>
length for the associated cipher algorithm <i>cipher</i>.
Use <b>EVP_CIPHER_get_iv_length()</b> to retrieve the cached
value.</p>

<p style="margin-left:11%;">&quot;blocksize&quot; (
<b><small>OSSL_CIPHER_PARAM_BLOCK_SIZE</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets the block size for the
associated cipher algorithm <i>cipher</i>. The block size
should be 1 for stream ciphers. Note that the block size for
a cipher may be different to the block size for the
underlying encryption/decryption primitive. For example
<small>AES</small> in <small>CTR</small> mode has a block
size of 1 (because it operates like a stream cipher), even
though <small>AES</small> has a block size of 16. Use
<b>EVP_CIPHER_get_block_size()</b> to retreive the cached
value.</p>

<p style="margin-left:11%;">&quot;aead&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD</small></b> )
&lt;integer&gt;</p>

<p style="margin-left:17%;">Gets 1 if this is an
<small>AEAD</small> cipher algorithm, otherwise it gets 0.
Use (EVP_CIPHER_get_flags(cipher) &amp;
<small>EVP_CIPH_FLAG_AEAD_CIPHER</small> ) to retrieve the
cached value.</p>

<p style="margin-left:11%;">&quot;custom-iv&quot; (
<b><small>OSSL_CIPHER_PARAM_CUSTOM_IV</small></b> )
&lt;integer&gt;</p>

<p style="margin-left:17%;">Gets 1 if the cipher algorithm
<i>cipher</i> has a custom <small>IV,</small> otherwise it
gets 0. Storing and initializing the <small>IV</small> is
left entirely to the implementation, if a custom
<small>IV</small> is used. Use (EVP_CIPHER_get_flags(cipher)
&amp; <small>EVP_CIPH_CUSTOM_IV</small> ) to retrieve the
cached value.</p>

<p style="margin-left:11%;">&quot;cts&quot; (
<b><small>OSSL_CIPHER_PARAM_CTS</small></b> )
&lt;integer&gt;</p>

<p style="margin-left:17%;">Gets 1 if the cipher algorithm
<i>cipher</i> uses ciphertext stealing, otherwise it gets 0.
This is currently used to indicate that the cipher is a one
shot that only allows a single call to
<b>EVP_CipherUpdate()</b>. Use (EVP_CIPHER_get_flags(cipher)
&amp; <small>EVP_CIPH_FLAG_CTS</small> ) to retrieve the
cached value.</p>

<p style="margin-left:11%;">&quot;tls-multi&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK</small></b> )
&lt;integer&gt;</p>

<p style="margin-left:17%;">Gets 1 if the cipher algorithm
<i>cipher</i> supports interleaving of crypto blocks,
otherwise it gets 0. The interleaving is an optimization
only applicable to certain <small>TLS</small> ciphers. Use
(EVP_CIPHER_get_flags(cipher) &amp;
<small>EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK</small> ) to retrieve
the cached value.</p>

<p style="margin-left:11%;">&quot;has-randkey&quot; (
<b><small>OSSL_CIPHER_PARAM_HAS_RANDKEY</small></b> )
&lt;integer&gt;</p>

<p style="margin-left:17%;">Gets 1 if the cipher algorithm
<i>cipher</i> supports the gettable
<small>EVP_CIPHER_CTX</small> parameter
<b><small>OSSL_CIPHER_PARAM_RANDOM_KEY</small></b> . Only
<small>DES</small> and 3DES set this to 1, all other OpenSSL
ciphers return 0.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Gettable and
Settable <small>EVP_CIPHER_CTX</small> parameters</b> <br>
The following <b><small>OSSL_PARAM</small></b> (3) keys can
be used with both <b>EVP_CIPHER_CTX_get_params()</b> and
<b>EVP_CIPHER_CTX_set_params()</b>. <br>
&quot;padding&quot; (
<b><small>OSSL_CIPHER_PARAM_PADDING</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets or sets the padding mode
for the cipher context <i>ctx</i>. Padding is enabled if the
value is 1, and disabled if the value is 0. See also
<b>EVP_CIPHER_CTX_set_padding()</b>.</p>

<p style="margin-left:11%;">&quot;num&quot; (
<b><small>OSSL_CIPHER_PARAM_NUM</small></b> ) &lt;unsigned
integer&gt;</p>

<p style="margin-left:17%;">Gets or sets the cipher
specific &quot;num&quot; parameter for the cipher context
<i>ctx</i>. Built-in ciphers typically use this to track how
much of the current underlying block has been
&quot;used&quot; already. See also
<b>EVP_CIPHER_CTX_get_num()</b> and
<b>EVP_CIPHER_CTX_set_num()</b>.</p>

<p style="margin-left:11%;">&quot;keylen&quot; (
<b><small>OSSL_CIPHER_PARAM_KEYLEN</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets or sets the key length for
the cipher context <i>ctx</i>. The length of the
&quot;keylen&quot; parameter should not exceed that of a
<b>size_t</b>. See also
<b>EVP_CIPHER_CTX_get_key_length()</b> and
<b>EVP_CIPHER_CTX_set_key_length()</b>.</p>

<p style="margin-left:11%;">&quot;tag&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TAG</small></b> ) &lt;octet
string&gt;</p>

<p style="margin-left:17%;">Gets or sets the
<small>AEAD</small> tag for the associated cipher context
<i>ctx</i>. See &quot; <small>AEAD</small> Interface&quot;
in <b>EVP_EncryptInit</b>(3).</p>

<p style="margin-left:11%;">&quot;keybits&quot; (
<b><small>OSSL_CIPHER_PARAM_RC2_KEYBITS</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets or sets the effective
keybits used for a <small>RC2</small> cipher. The length of
the &quot;keybits&quot; parameter should not exceed that of
a <b>size_t</b>.</p>

<p style="margin-left:11%;">&quot;rounds&quot; (
<b><small>OSSL_CIPHER_PARAM_ROUNDS</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets or sets the number of
rounds to be used for a cipher. This is used by the
<small>RC5</small> cipher.</p>

<p style="margin-left:11%;">&quot;alg_id_param&quot; (
<b><small>OSSL_CIPHER_PARAM_ALGORITHM_ID_PARAMS</small></b>
) &lt;octet string&gt;</p>

<p style="margin-left:17%;">Used to pass the
<small>DER</small> encoded AlgorithmIdentifier parameter to
or from the cipher implementation. Functions like
<b>EVP_CIPHER_param_to_asn1</b>(3) and
<b>EVP_CIPHER_asn1_to_param</b>(3) use this parameter for
any implementation that has the flag
<b><small>EVP_CIPH_FLAG_CUSTOM_ASN1</small></b> set.</p>

<p style="margin-left:11%;">&quot;cts_mode&quot; (
<b><small>OSSL_CIPHER_PARAM_CTS_MODE</small></b> ) &lt;
<small>UTF8</small> string&gt;</p>

<p style="margin-left:17%;">Gets or sets the cipher text
stealing mode. For all modes the output size is the same as
the input size. The input length must be greater than or
equal to the block size. (The block size for
<small>AES</small> and <small>CAMELLIA</small> is 16
bytes).</p>

<p style="margin-left:17%; margin-top: 1em">Valid values
for the mode are: <br>
&quot; <small>CS1&quot;</small></p>

<p style="margin-left:23%;">The <small>NIST</small> variant
of cipher text stealing. For input lengths that are
multiples of the block size it is equivalent to using a
&quot;AES-XXX-CBC&quot; or &quot;CAMELLIA-XXX-CBC&quot;
cipher otherwise the second last cipher text block is a
partial block.</p>

<p style="margin-left:17%;">&quot;
<small>CS2&quot;</small></p>

<p style="margin-left:23%;">For input lengths that are
multiples of the block size it is equivalent to using a
&quot;AES-XXX-CBC&quot; or &quot;CAMELLIA-XXX-CBC&quot;
cipher, otherwise it is the same as &quot;
<small>CS3&quot;</small> mode.</p>

<p style="margin-left:17%;">&quot;
<small>CS3&quot;</small></p>

<p style="margin-left:23%;">The Kerberos5 variant of cipher
text stealing which always swaps the last cipher text block
with the previous block (which may be a partial or full
block depending on the input length). If the input length is
exactly one full block then this is equivalent to using a
&quot;AES-XXX-CBC&quot; or &quot;CAMELLIA-XXX-CBC&quot;
cipher.</p>

<p style="margin-left:17%; margin-top: 1em">The default is
&quot; <small>CS1&quot;.</small> This is only supported for
&quot; <small>AES&minus;128&minus;CBC&minus;CTS&quot;,
&quot;AES&minus;192&minus;CBC&minus;CTS&quot;,
&quot;AES&minus;256&minus;CBC&minus;CTS&quot;,
&quot;CAMELLIA&minus;128&minus;CBC&minus;CTS&quot;,
&quot;CAMELLIA&minus;192&minus;CBC&minus;CTS&quot;</small>
and &quot;
<small>CAMELLIA&minus;256&minus;CBC&minus;CTS&quot;.</small></p>


<p style="margin-left:11%;">&quot;tls1multi_interleave&quot;
(
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE</small></b>
) <br>
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Sets or gets the number of
records being sent in one go for a tls1 multiblock cipher
operation (either 4 or 8 records).</p>

<p style="margin-left:11%; margin-top: 1em"><b>Gettable
<small>EVP_CIPHER_CTX</small> parameters</b> <br>
The following <b><small>OSSL_PARAM</small></b> (3) keys can
be used with <b>EVP_CIPHER_CTX_get_params()</b>: <br>
&quot;ivlen&quot; (
<b><small>OSSL_CIPHER_PARAM_IVLEN</small></b> and &lt;
<b><small>OSSL_CIPHER_PARAM_AEAD_IVLEN</small></b> ) <br>
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets the <small>IV</small>
length for the cipher context <i>ctx</i>. The length of the
&quot;ivlen&quot; parameter should not exceed that of a
<b>size_t</b>. See also
<b>EVP_CIPHER_CTX_get_iv_length()</b>.</p>

<p style="margin-left:11%;">&quot;iv&quot; (
<b><small>OSSL_CIPHER_PARAM_IV</small></b> ) &lt;octet
string <small>OR</small> octet ptr&gt;</p>

<p style="margin-left:17%;">Gets the <small>IV</small> used
to initialize the associated cipher context <i>ctx</i>. See
also <b>EVP_CIPHER_CTX_get_original_iv()</b>.</p>

<p style="margin-left:11%;">&quot;updated-iv&quot; (
<b><small>OSSL_CIPHER_PARAM_UPDATED_IV</small></b> )
&lt;octet string <small>OR</small> octet ptr&gt;</p>

<p style="margin-left:17%;">Gets the updated pseudo-IV
state for the associated cipher context, e.g., the previous
ciphertext block for <small>CBC</small> mode or the
iteratively encrypted <small>IV</small> value for
<small>OFB</small> mode. Note that octet pointer access is
deprecated and is provided only for backwards compatibility
with historical libcrypto APIs. See also
<b>EVP_CIPHER_CTX_get_updated_iv()</b>.</p>

<p style="margin-left:11%;">&quot;randkey&quot; (
<b><small>OSSL_CIPHER_PARAM_RANDOM_KEY</small></b> )
&lt;octet string&gt;</p>

<p style="margin-left:17%;">Gets an implementation specific
randomly generated key for the associated cipher context
<i>ctx</i>. This is currently only supported by
<small>DES</small> and 3DES (which set the key to odd
parity).</p>

<p style="margin-left:11%;">&quot;taglen&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TAGLEN</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets the tag length to be used
for an <small>AEAD</small> cipher for the associated cipher
context <i>ctx</i>. It gets a default value if it has not
been set. The length of the &quot;taglen&quot; parameter
should not exceed that of a <b>size_t</b>. See also
<b>EVP_CIPHER_CTX_get_tag_length()</b>.</p>

<p style="margin-left:11%;">&quot;tlsaadpad&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets the length of the tag that
will be added to a <small>TLS</small> record for the
<small>AEAD</small> tag for the associated cipher context
<i>ctx</i>. The length of the &quot;tlsaadpad&quot;
parameter should not exceed that of a <b>size_t</b>.</p>

<p style="margin-left:11%;">&quot;tlsivgen&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_GET_IV_GEN</small></b>
) &lt;octet string&gt;</p>

<p style="margin-left:17%;">Gets the invocation field
generated for encryption. Can only be called after
&quot;tlsivfixed&quot; is set. This is only used for
<small>GCM</small> mode.</p>

<p style="margin-left:11%;">&quot;tls1multi_enclen&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN</small></b>
) <br>
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Get the total length of the
record returned from the &quot;tls1multi_enc&quot;
operation.</p>

<p style="margin-left:11%;">&quot;tls1multi_maxbufsz&quot;
(
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE</small></b>
) <br>
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets the maximum record length
for a <small>TLS1</small> multiblock cipher operation. The
length of the &quot;tls1multi_maxbufsz&quot; parameter
should not exceed that of a <b>size_t</b>.</p>


<p style="margin-left:11%;">&quot;tls1multi_aadpacklen&quot;
(
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN</small></b>
) <br>
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Gets the result of running the
&quot;tls1multi_aad&quot; operation.</p>

<p style="margin-left:11%;">&quot;tls-mac&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS_MAC</small></b> ) &lt;octet
ptr&gt;</p>

<p style="margin-left:17%;">Used to pass the <small>TLS
MAC</small> data.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Settable
<small>EVP_CIPHER_CTX</small> parameters</b> <br>
The following <b><small>OSSL_PARAM</small></b> (3) keys can
be used with <b>EVP_CIPHER_CTX_set_params()</b>: <br>
&quot;mackey&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_MAC_KEY</small></b> )
&lt;octet string&gt;</p>

<p style="margin-left:17%;">Sets the <small>MAC</small> key
used by composite <small>AEAD</small> ciphers such as
<small>AES&minus;CBC&minus;HMAC&minus;SHA256.</small></p>

<p style="margin-left:11%;">&quot;speed&quot; (
<b><small>OSSL_CIPHER_PARAM_SPEED</small></b> ) &lt;unsigned
integer&gt;</p>

<p style="margin-left:17%;">Sets the speed option for the
associated cipher context. This is only supported by
<small>AES SIV</small> ciphers which disallow multiple
operations by default. Setting &quot;speed&quot; to 1 allows
another encrypt or decrypt operation to be performed. This
is used for performance testing.</p>

<p style="margin-left:11%;">&quot;use-bits&quot; (
<b><small>OSSL_CIPHER_PARAM_USE_BITS</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Determines if the input length
<i>inl</i> passed to <b>EVP_EncryptUpdate()</b>,
<b>EVP_DecryptUpdate()</b> and <b>EVP_CipherUpdate()</b> is
the number of bits or number of bytes. Setting
&quot;use-bits&quot; to 1 uses bits. The default is in
bytes. This is only used for <b><small>CFB1</small></b>
ciphers.</p>

<p style="margin-left:17%; margin-top: 1em">This can be set
using EVP_CIPHER_CTX_set_flags(ctx,
<small>EVP_CIPH_FLAG_LENGTH_BITS</small> ).</p>

<p style="margin-left:11%;">&quot;tls-version&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS_VERSION</small></b> )
&lt;integer&gt;</p>

<p style="margin-left:17%;">Sets the <small>TLS</small>
version.</p>

<p style="margin-left:11%;">&quot;tls-mac-size&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS_MAC_SIZE</small></b> )
&lt;unsigned integer&gt;</p>

<p style="margin-left:17%;">Set the <small>TLS MAC</small>
size.</p>

<p style="margin-left:11%;">&quot;tlsaad&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_AAD</small></b> )
&lt;octet string&gt;</p>

<p style="margin-left:17%;">Sets TLSv1.2 <small>AAD</small>
information for the associated cipher context <i>ctx</i>.
TLSv1.2 <small>AAD</small> information is always 13 bytes in
length and is as defined for the &quot;additional_data&quot;
field described in section 6.2.3.3 of
<small>RFC5246.</small></p>

<p style="margin-left:11%;">&quot;tlsivfixed&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_IV_FIXED</small></b> )
&lt;octet string&gt;</p>

<p style="margin-left:17%;">Sets the fixed portion of an
<small>IV</small> for an <small>AEAD</small> cipher used in
a <small>TLS</small> record encryption/ decryption for the
associated cipher context. <small>TLS</small> record
encryption/decryption always occurs &quot;in place&quot; so
that the input and output buffers are always the same memory
location. <small>AEAD</small> IVs in TLSv1.2 consist of an
implicit &quot;fixed&quot; part and an explicit part that
varies with every record. Setting a <small>TLS</small> fixed
<small>IV</small> changes a cipher to encrypt/decrypt
<small>TLS</small> records. <small>TLS</small> records are
encrypted/decrypted using a single OSSL_FUNC_cipher_cipher
call per record. For a record decryption the first bytes of
the input buffer will be the explicit part of the
<small>IV</small> and the final bytes of the input buffer
will be the <small>AEAD</small> tag. The length of the
explicit part of the <small>IV</small> and the tag length
will depend on the cipher in use and will be defined in the
<small>RFC</small> for the relevant ciphersuite. In order to
allow for &quot;in place&quot; decryption the plaintext
output should be written to the same location in the output
buffer that the ciphertext payload was read from, i.e.
immediately after the explicit <small>IV.</small></p>

<p style="margin-left:17%; margin-top: 1em">When encrypting
a record the first bytes of the input buffer should be empty
to allow space for the explicit <small>IV,</small> as will
the final bytes where the tag will be written. The length of
the input buffer will include the length of the explicit
<small>IV,</small> the payload, and the tag bytes. The
cipher implementation should generate the explicit
<small>IV</small> and write it to the beginning of the
output buffer, do &quot;in place&quot; encryption of the
payload and write that to the output buffer, and finally add
the tag onto the end of the output buffer.</p>

<p style="margin-left:17%; margin-top: 1em">Whether
encrypting or decrypting the value written to <i>*outl</i>
in the OSSL_FUNC_cipher_cipher call should be the length of
the payload excluding the explicit <small>IV</small> length
and the tag length.</p>

<p style="margin-left:11%;">&quot;tlsivinv&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_SET_IV_INV</small></b>
) &lt;octet string&gt;</p>

<p style="margin-left:17%;">Sets the invocation field used
for decryption. Can only be called after
&quot;tlsivfixed&quot; is set. This is only used for
<small>GCM</small> mode.</p>

<p style="margin-left:11%;">&quot;tls1multi_enc&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC</small></b>
) &lt;octet string&gt;</p>

<p style="margin-left:17%;">Triggers a multiblock
<small>TLS1</small> encrypt operation for a
<small>TLS1</small> aware cipher that supports sending 4 or
8 records in one go. The cipher performs both the
<small>MAC</small> and encrypt stages and constructs the
record headers itself. &quot;tls1multi_enc&quot; supplies
the output buffer for the encrypt operation,
&quot;tls1multi_encin&quot; &amp;
&quot;tls1multi_interleave&quot; must also be set in order
to supply values to the encrypt operation.</p>

<p style="margin-left:11%;">&quot;tls1multi_encin&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN</small></b>
) &lt;octet <br>
string&gt;</p>

<p style="margin-left:17%;">Supplies the data to encrypt
for a <small>TLS1</small> multiblock cipher operation.</p>


<p style="margin-left:11%;">&quot;tls1multi_maxsndfrag&quot;
<br>
(
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT</small></b>
) &lt;unsigned <br>
integer&gt;</p>

<p style="margin-left:17%;">Sets the maximum send fragment
size for a <small>TLS1</small> multiblock cipher operation.
It must be set before using &quot;tls1multi_maxbufsz&quot;.
The length of the &quot;tls1multi_maxsndfrag&quot; parameter
should not exceed that of a <b>size_t</b>.</p>

<p style="margin-left:11%;">&quot;tls1multi_aad&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD</small></b>
) &lt;octet string&gt;</p>

<p style="margin-left:17%;">Sets the authenticated
additional data used by a <small>TLS1</small> multiblock
cipher operation. The supplied data consists of 13 bytes of
record data containing: Bytes 0&minus;7: The sequence number
of the first record Byte 8: The record type Byte 9&minus;10:
The protocol version Byte 11&minus;12: Input length (Always
0)</p>


<p style="margin-left:17%; margin-top: 1em">&quot;tls1multi_interleave&quot;
must also be set for this operation.</p>

<h2>CONTROLS
<a name="CONTROLS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Mappings
from <b>EVP_CIPHER_CTX_ctrl()</b> identifiers to
<small>PARAMETERS</small> are listed in the following
section. See the &quot; <small>PARAMETERS&quot;</small>
section for more details.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_ctrl()</b>
can be used to send the following standard controls:
<small><br>
EVP_CTRL_AEAD_SET_IVLEN</small> and
<small>EVP_CTRL_GET_IVLEN</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> and
<b>EVP_CIPHER_CTX_get_params()</b> get called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;ivlen&quot; (
<b><small>OSSL_CIPHER_PARAM_IVLEN</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_AEAD_SET_IV_FIXED</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;tlsivfixed&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_IV_FIXED</small></b>
).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_AEAD_SET_MAC_KEY</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;mackey&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_MAC_KEY</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_AEAD_SET_TAG</small>
and <small>EVP_CTRL_AEAD_GET_TAG</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> and
<b>EVP_CIPHER_CTX_get_params()</b> get called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;tag&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TAG</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_CCM_SET_L</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;ivlen&quot; (
<b><small>OSSL_CIPHER_PARAM_IVLEN</small></b> ) with a value
of (15 &minus; L)</p>


<p style="margin-left:11%;"><small>EVP_CTRL_COPY</small></p>

<p style="margin-left:17%;">There is no
<small>OSSL_PARAM</small> mapping for this. Use
<b>EVP_CIPHER_CTX_copy()</b> instead.</p>


<p style="margin-left:11%;"><small>EVP_CTRL_GCM_SET_IV_INV</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;tlsivinv&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_SET_IV_INV</small></b>
).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_RAND_KEY</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;randkey&quot; (
<b><small>OSSL_CIPHER_PARAM_RANDOM_KEY</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_SET_KEY_LENGTH</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;keylen&quot; (
<b><small>OSSL_CIPHER_PARAM_KEYLEN</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_SET_RC2_KEY_BITS</small>
and <small>EVP_CTRL_GET_RC2_KEY_BITS</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> and
<b>EVP_CIPHER_CTX_get_params()</b> get called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;keybits&quot; (
<b><small>OSSL_CIPHER_PARAM_RC2_KEYBITS</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_SET_RC5_ROUNDS</small>
and <small>EVP_CTRL_GET_RC5_ROUNDS</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> and
<b>EVP_CIPHER_CTX_get_params()</b> get called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;rounds&quot; (
<b><small>OSSL_CIPHER_PARAM_ROUNDS</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_SET_SPEED</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;speed&quot; (
<b><small>OSSL_CIPHER_PARAM_SPEED</small></b> ).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_GCM_IV_GEN</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_get_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;tlsivgen&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_GET_IV_GEN</small></b>
).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_AEAD_TLS1_AAD</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> get called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
&quot;tlsaadpad&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_AAD</small></b> )
followed by <b>EVP_CIPHER_CTX_get_params()</b> with a key of
&quot;tlsaadpad&quot; (
<b><small>OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD</small></b>
).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with an
<b><small>OSSL_PARAM</small></b> (3) item with the key
<small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT</small>
followed by <b>EVP_CIPHER_CTX_get_params()</b> with a key of
&quot;tls1multi_maxbufsz&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE</small></b>
).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_TLS1_1_MULTIBLOCK_AAD</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with
<b><small>OSSL_PARAM</small></b> (3) items with the keys
&quot;tls1multi_aad&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD</small></b>
) and &quot;tls1multi_interleave&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE</small></b>
) followed by <b>EVP_CIPHER_CTX_get_params()</b> with keys
of &quot;tls1multi_aadpacklen&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN</small></b>
) and &quot;tls1multi_interleave&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE</small></b>
).</p>


<p style="margin-left:11%;"><small>EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT</small></p>

<p style="margin-left:17%;">When used with a fetched
<b><small>EVP_CIPHER</small></b> ,
<b>EVP_CIPHER_CTX_set_params()</b> gets called with
<b><small>OSSL_PARAM</small></b> (3) items with the keys
&quot;tls1multi_enc&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC</small></b>
), &quot;tls1multi_encin&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN</small></b>
) and &quot;tls1multi_interleave&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE</small></b>
), followed by <b>EVP_CIPHER_CTX_get_params()</b> with a key
of &quot;tls1multi_enclen&quot; (
<b><small>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN</small></b>
).</p>

<h2>FLAGS
<a name="FLAGS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_set_flags()</b>,
<b>EVP_CIPHER_CTX_clear_flags()</b> and
<b>EVP_CIPHER_CTX_test_flags()</b>. can be used to
manipulate and test these
<b><small>EVP_CIPHER_CTX</small></b> flags: <small><br>
EVP_CIPH_NO_PADDING</small></p>

<p style="margin-left:17%;">Used by
<b>EVP_CIPHER_CTX_set_padding()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;Gettable and Settable <small>EVP_CIPHER_CTX</small>
parameters&quot; &quot;padding&quot;</p>


<p style="margin-left:11%;"><small>EVP_CIPH_FLAG_LENGTH_BITS</small></p>

<p style="margin-left:17%;">See &quot;Settable
<small>EVP_CIPHER_CTX</small> parameters&quot;
&quot;use-bits&quot;.</p>


<p style="margin-left:11%;"><small>EVP_CIPHER_CTX_FLAG_WRAP_ALLOW</small></p>

<p style="margin-left:17%;">Used for Legacy purposes only.
This flag needed to be set to indicate the cipher handled
wrapping.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_flags()</b>
uses the following flags that have mappings to
&quot;Gettable <small>EVP_CIPHER</small> parameters&quot;:
<small><br>
EVP_CIPH_FLAG_AEAD_CIPHER</small></p>

<p style="margin-left:17%;">See &quot;Gettable
<small>EVP_CIPHER</small> parameters&quot;
&quot;aead&quot;.</p>


<p style="margin-left:11%;"><small>EVP_CIPH_CUSTOM_IV</small></p>

<p style="margin-left:17%;">See &quot;Gettable
<small>EVP_CIPHER</small> parameters&quot;
&quot;custom-iv&quot;.</p>


<p style="margin-left:11%;"><small>EVP_CIPH_FLAG_CTS</small></p>

<p style="margin-left:17%;">See &quot;Gettable
<small>EVP_CIPHER</small> parameters&quot;
&quot;cts&quot;.</p>


<p style="margin-left:11%;"><small>EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK</small>
;</p>

<p style="margin-left:17%;">See &quot;Gettable
<small>EVP_CIPHER</small> parameters&quot;
&quot;tls-multi&quot;.</p>


<p style="margin-left:11%;"><small>EVP_CIPH_RAND_KEY</small></p>

<p style="margin-left:17%;">See &quot;Gettable
<small>EVP_CIPHER</small> parameters&quot;
&quot;has-randkey&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_flags()</b>
uses the following flags for legacy purposes only:
<small><br>
EVP_CIPH_VARIABLE_LENGTH <br>
EVP_CIPH_FLAG_CUSTOM_CIPHER <br>
EVP_CIPH_ALWAYS_CALL_INIT <br>
EVP_CIPH_CTRL_INIT <br>
EVP_CIPH_CUSTOM_KEY_LENGTH <br>
EVP_CIPH_CUSTOM_COPY <br>
EVP_CIPH_FLAG_DEFAULT_ASN1</small></p>

<p style="margin-left:17%;">See
<b>EVP_CIPHER_meth_set_flags</b>(3) for further information
related to the above flags.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_fetch()</b>
returns a pointer to a <b><small>EVP_CIPHER</small></b> for
success and <b><small>NULL</small></b> for failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_up_ref()</b>
returns 1 for success or 0 otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_new()</b>
returns a pointer to a newly created
<b><small>EVP_CIPHER_CTX</small></b> for success and
<b><small>NULL</small></b> for failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_EncryptInit_ex2()</b>,
<b>EVP_EncryptUpdate()</b> and <b>EVP_EncryptFinal_ex()</b>
return 1 for success and 0 for failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_DecryptInit_ex2()</b>
and <b>EVP_DecryptUpdate()</b> return 1 for success and 0
for failure. <b>EVP_DecryptFinal_ex()</b> returns 0 if the
decrypt failed or 1 for success.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CipherInit_ex2()</b>
and <b>EVP_CipherUpdate()</b> return 1 for success and 0 for
failure. <b>EVP_CipherFinal_ex()</b> returns 0 for a
decryption failure or 1 for success.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_Cipher()</b>
returns the amount of encrypted / decrypted bytes, or
&minus;1 on failure if the flag
<b><small>EVP_CIPH_FLAG_CUSTOM_CIPHER</small></b> is set for
the cipher. <b>EVP_Cipher()</b> returns 1 on success or 0 on
failure, if the flag
<b><small>EVP_CIPH_FLAG_CUSTOM_CIPHER</small></b> is not set
for the cipher.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_reset()</b>
returns 1 for success and 0 for failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_get_cipherbyname()</b>,
<b>EVP_get_cipherbynid()</b> and
<b>EVP_get_cipherbyobj()</b> return an
<b><small>EVP_CIPHER</small></b> structure or
<small>NULL</small> on error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_get_nid()</b>
and <b>EVP_CIPHER_CTX_get_nid()</b> return a
<small>NID.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_get_block_size()</b>
and <b>EVP_CIPHER_CTX_get_block_size()</b> return the block
size.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_get_key_length()</b>
and <b>EVP_CIPHER_CTX_get_key_length()</b> return the key
length.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_set_padding()</b>
always returns 1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_get_iv_length()</b>
and <b>EVP_CIPHER_CTX_get_iv_length()</b> return the
<small>IV</small> length or zero if the cipher does not use
an <small>IV.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_get_tag_length()</b>
return the tag length or zero if the cipher does not use a
tag.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_get_type()</b>
and <b>EVP_CIPHER_CTX_get_type()</b> return the
<small>NID</small> of the cipher&rsquo;s <small>OBJECT
IDENTIFIER</small> or NID_undef if it has no defined
<small>OBJECT IDENTIFIER.</small></p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_cipher()</b>
returns an <b><small>EVP_CIPHER</small></b> structure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_get_num()</b>
returns a nonnegative num value or
<b><small>EVP_CTRL_RET_UNSUPPORTED</small></b> if the
implementation does not support the call or on any other
error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_set_num()</b>
returns 1 on success and 0 if the implementation does not
support the call or on any other error.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_is_encrypting()</b>
returns 1 if the <i>ctx</i> is set up for encryption 0
otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_param_to_asn1()</b>
and <b>EVP_CIPHER_asn1_to_param()</b> return greater than
zero for success and zero or a negative number on
failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_CTX_rand_key()</b>
returns 1 for success and zero or a negative number for
failure.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_CIPHER_names_do_all()</b>
returns 1 if the callback was called for all names. A return
value of 0 means that the callback was not called for any
names.</p>

<h2>CIPHER LISTING
<a name="CIPHER LISTING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All algorithms
have a fixed key length unless otherwise stated.</p>

<p style="margin-left:11%; margin-top: 1em">Refer to &quot;
<small>SEE ALSO&quot;</small> for the full list of ciphers
available through the <small>EVP</small> interface. <b><br>
EVP_enc_null()</b></p>

<p style="margin-left:17%;">Null cipher: does nothing.</p>

<h2>AEAD INTERFACE
<a name="AEAD INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>EVP</small> interface for Authenticated Encryption
with Associated Data ( <small>AEAD</small> ) modes are
subtly altered and several additional <i>ctrl</i> operations
are supported depending on the mode specified.</p>

<p style="margin-left:11%; margin-top: 1em">To specify
additional authenticated data ( <small>AAD</small> ), a call
to <b>EVP_CipherUpdate()</b>, <b>EVP_EncryptUpdate()</b> or
<b>EVP_DecryptUpdate()</b> should be made with the output
parameter <i>out</i> set to <b><small>NULL</small></b> .</p>

<p style="margin-left:11%; margin-top: 1em">When
decrypting, the return value of <b>EVP_DecryptFinal()</b> or
<b>EVP_CipherFinal()</b> indicates whether the operation was
successful. If it does not indicate success, the
authentication operation has failed and any output data
<b><small>MUST NOT</small></b> be used as it is
corrupted.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>GCM</small>
and <small>OCB</small> Modes</b> <br>
The following <i>ctrl</i>s are supported in
<small>GCM</small> and <small>OCB</small> modes. <br>
EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_SET_IVLEN,</small> ivlen,
<small>NULL</small> )</p>

<p style="margin-left:17%;">Sets the <small>IV</small>
length. This call can only be made before specifying an
<small>IV.</small> If not called a default <small>IV</small>
length is used.</p>

<p style="margin-left:17%; margin-top: 1em">For <small>GCM
AES</small> and <small>OCB AES</small> the default is 12
(i.e. 96 bits). For <small>OCB</small> mode the maximum is
15.</p>

<p style="margin-left:11%;">EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_GET_TAG,</small> taglen, tag)</p>

<p style="margin-left:17%;">Writes &quot;taglen&quot; bytes
of the tag value to the buffer indicated by &quot;tag&quot;.
This call can only be made when encrypting data and
<b>after</b> all data has been processed (e.g. after an
<b>EVP_EncryptFinal()</b> call).</p>

<p style="margin-left:17%; margin-top: 1em">For
<small>OCB,</small> &quot;taglen&quot; must either be 16 or
the value previously set via
<b><small>EVP_CTRL_AEAD_SET_TAG</small></b> .</p>

<p style="margin-left:11%;">EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_SET_TAG,</small> taglen, tag)</p>

<p style="margin-left:17%;">When decrypting, this call sets
the expected tag to &quot;taglen&quot; bytes from
&quot;tag&quot;. &quot;taglen&quot; must be between 1 and 16
inclusive. The tag must be set prior to any call to
<b>EVP_DecryptFinal()</b> or
<b>EVP_DecryptFinal_ex()</b>.</p>

<p style="margin-left:17%; margin-top: 1em">For
<small>GCM,</small> this call is only valid when decrypting
data.</p>

<p style="margin-left:17%; margin-top: 1em">For
<small>OCB,</small> this call is valid when decrypting data
to set the expected tag, and when encrypting to set the
desired tag length.</p>

<p style="margin-left:17%; margin-top: 1em">In
<small>OCB</small> mode, calling this when encrypting with
&quot;tag&quot; set to &quot;NULL&quot; sets the tag length.
The tag length can only be set before specifying an
<small>IV.</small> If this is not called prior to setting
the <small>IV</small> during encryption, then a default tag
length is used.</p>

<p style="margin-left:17%; margin-top: 1em">For <small>OCB
AES,</small> the default tag length is 16 (i.e. 128 bits).
It is also the maximum tag length for
<small>OCB.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small><b>CCM</b></small>
<b>Mode</b> <br>
The <small>EVP</small> interface for <small>CCM</small> mode
is similar to that of the <small>GCM</small> mode but with a
few additional requirements and different <i>ctrl</i>
values.</p>

<p style="margin-left:11%; margin-top: 1em">For
<small>CCM</small> mode, the total plaintext or ciphertext
length <b><small>MUST</small></b> be passed to
<b>EVP_CipherUpdate()</b>, <b>EVP_EncryptUpdate()</b> or
<b>EVP_DecryptUpdate()</b> with the output and input
parameters (<i>in</i> and <i>out</i>) set to
<b><small>NULL</small></b> and the length passed in the
<i>inl</i> parameter.</p>

<p style="margin-left:11%; margin-top: 1em">The following
<i>ctrl</i>s are supported in <small>CCM</small> mode. <br>
EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_SET_TAG,</small> taglen, tag)</p>

<p style="margin-left:17%;">This call is made to set the
expected <b><small>CCM</small></b> tag value when decrypting
or the length of the tag (with the &quot;tag&quot; parameter
set to <small>NULL</small> ) when encrypting. The tag length
is often referred to as <b>M</b>. If not set a default value
is used (12 for <small>AES</small> ). When decrypting, the
tag needs to be set before passing in data to be decrypted,
but as in <small>GCM</small> and <small>OCB</small> mode, it
can be set after passing additional authenticated data (see
&quot; <small>AEAD INTERFACE&quot;</small> ).</p>

<p style="margin-left:11%;">EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_CCM_SET_L,</small> ivlen,
<small>NULL</small> )</p>

<p style="margin-left:17%;">Sets the <small>CCM</small>
<b>L</b> value. If not set a default is used (8 for
<small>AES</small> ).</p>

<p style="margin-left:11%;">EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_SET_IVLEN,</small> ivlen,
<small>NULL</small> )</p>

<p style="margin-left:17%;">Sets the <small>CCM</small>
nonce ( <small>IV</small> ) length. This call can only be
made before specifying a nonce value. The nonce length is
given by <b>15 &minus; L</b> so it is 7 by default for
<small>AES.</small></p>


<p style="margin-left:11%; margin-top: 1em"><small><b>SIV</b></small>
<b>Mode</b> <br>
For <small>SIV</small> mode ciphers the behaviour of the
<small>EVP</small> interface is subtly altered and several
additional ctrl operations are supported.</p>

<p style="margin-left:11%; margin-top: 1em">To specify any
additional authenticated data ( <small>AAD</small> ) and/or
a Nonce, a call to <b>EVP_CipherUpdate()</b>,
<b>EVP_EncryptUpdate()</b> or <b>EVP_DecryptUpdate()</b>
should be made with the output parameter <i>out</i> set to
<b><small>NULL</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><small>RFC5297</small>
states that the Nonce is the last piece of
<small>AAD</small> before the actual encrypt/decrypt takes
place. The <small>API</small> does not differentiate the
Nonce from other <small>AAD.</small></p>

<p style="margin-left:11%; margin-top: 1em">When decrypting
the return value of <b>EVP_DecryptFinal()</b> or
<b>EVP_CipherFinal()</b> indicates if the operation was
successful. If it does not indicate success the
authentication operation has failed and any output data
<b><small>MUST NOT</small></b> be used as it is
corrupted.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>API</small> does not store the the <small>SIV</small>
(Synthetic Initialization Vector) in the cipher text.
Instead, it is stored as the tag within the
<small>EVP_CIPHER_CTX.</small> The <small>SIV</small> must
be retrieved from the context after encryption, and set into
the context before decryption.</p>

<p style="margin-left:11%; margin-top: 1em">This differs
from <small>RFC5297</small> in that the cipher output from
encryption, and the cipher input to decryption, does not
contain the <small>SIV.</small> This also means that the
plain text and cipher text lengths are identical.</p>

<p style="margin-left:11%; margin-top: 1em">The following
ctrls are supported in <small>SIV</small> mode, and are used
to get and set the Synthetic Initialization Vector: <br>
EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_GET_TAG,</small> taglen, tag);</p>

<p style="margin-left:17%;">Writes <i>taglen</i> bytes of
the tag value (the Synthetic Initialization Vector) to the
buffer indicated by <i>tag</i>. This call can only be made
when encrypting data and <b>after</b> all data has been
processed (e.g. after an <b>EVP_EncryptFinal()</b> call).
For <small>SIV</small> mode the taglen must be 16.</p>

<p style="margin-left:11%;">EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_SET_TAG,</small> taglen, tag);</p>

<p style="margin-left:17%;">Sets the expected tag (the
Synthetic Initialization Vector) to <i>taglen</i> bytes from
<i>tag</i>. This call is only legal when decrypting data and
must be made <b>before</b> any data is processed (e.g.
before any <b>EVP_DecryptUpdate()</b> calls). For
<small>SIV</small> mode the taglen must be 16.</p>


<p style="margin-left:11%; margin-top: 1em"><small>SIV</small>
mode makes two passes over the input data, thus, only one
call to <b>EVP_CipherUpdate()</b>,
<b>EVP_EncryptUpdate()</b> or <b>EVP_DecryptUpdate()</b>
should be made with <i>out</i> set to a non&minus;
<b><small>NULL</small></b> value. A call to
<b>EVP_DecryptFinal()</b> or <b>EVP_CipherFinal()</b> is not
required, but will indicate if the update operation
succeeded.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ChaCha20&minus;Poly1305</b>
<br>
The following <i>ctrl</i>s are supported for the
ChaCha20&minus;Poly1305 <small>AEAD</small> algorithm. <br>
EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_SET_IVLEN,</small> ivlen,
<small>NULL</small> )</p>

<p style="margin-left:17%;">Sets the nonce length. This
call is now redundant since the only valid value is the
default length of 12 (i.e. 96 bits). Prior to OpenSSL 3.0 a
nonce of less than 12 bytes could be used to automatically
pad the iv with leading 0 bytes to make it 12 bytes in
length.</p>

<p style="margin-left:11%;">EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_GET_TAG,</small> taglen, tag)</p>

<p style="margin-left:17%;">Writes &quot;taglen&quot; bytes
of the tag value to the buffer indicated by &quot;tag&quot;.
This call can only be made when encrypting data and
<b>after</b> all data has been processed (e.g. after an
<b>EVP_EncryptFinal()</b> call).</p>


<p style="margin-left:17%; margin-top: 1em">&quot;taglen&quot;
specified here must be 16 (
<b><small>POLY1305_BLOCK_SIZE</small></b> , i.e.
128&minus;bits) or less.</p>

<p style="margin-left:11%;">EVP_CIPHER_CTX_ctrl(ctx,
<small>EVP_CTRL_AEAD_SET_TAG,</small> taglen, tag)</p>

<p style="margin-left:17%;">Sets the expected tag to
&quot;taglen&quot; bytes from &quot;tag&quot;. The tag
length can only be set before specifying an
<small>IV.</small> &quot;taglen&quot; must be between 1 and
16 ( <b><small>POLY1305_BLOCK_SIZE</small></b> ) inclusive.
This call is only valid when decrypting data.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Where possible
the <b><small>EVP</small></b> interface to symmetric ciphers
should be used in preference to the low-level interfaces.
This is because the code then becomes transparent to the
cipher used and much more flexible. Additionally, the
<b><small>EVP</small></b> interface will ensure the use of
platform specific cryptographic acceleration such as AES-NI
(the low-level interfaces do not provide the guarantee).</p>


<p style="margin-left:11%; margin-top: 1em"><small>PKCS</small>
padding works by adding <b>n</b> padding bytes of value
<b>n</b> to make the total length of the encrypted data a
multiple of the block size. Padding is always added so if
the data is already a multiple of the block size <b>n</b>
will equal the block size. For example if the block size is
8 and 11 bytes are to be encrypted then 5 padding bytes of
value 5 will be added.</p>

<p style="margin-left:11%; margin-top: 1em">When decrypting
the final block is checked to see if it has the correct
form.</p>

<p style="margin-left:11%; margin-top: 1em">Although the
decryption operation can produce an error if padding is
enabled, it is not a strong test that the input data or key
is correct. A random block has better than 1 in 256 chance
of being of the correct format and problems with the input
data earlier on will not produce a final decrypt error.</p>

<p style="margin-left:11%; margin-top: 1em">If padding is
disabled then the decryption operation will always succeed
if the total amount of data decrypted is a multiple of the
block size.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>EVP_EncryptInit()</b>, <b>EVP_EncryptInit_ex()</b>,
<b>EVP_EncryptFinal()</b>, <b>EVP_DecryptInit()</b>,
<b>EVP_DecryptInit_ex()</b>, <b>EVP_CipherInit()</b>,
<b>EVP_CipherInit_ex()</b> and <b>EVP_CipherFinal()</b> are
obsolete but are retained for compatibility with existing
code. New code should use <b>EVP_EncryptInit_ex2()</b>,
<b>EVP_EncryptFinal_ex()</b>, <b>EVP_DecryptInit_ex2()</b>,
<b>EVP_DecryptFinal_ex()</b>, <b>EVP_CipherInit_ex2()</b>
and <b>EVP_CipherFinal_ex()</b> because they can reuse an
existing context without allocating and freeing it up on
each call.</p>

<p style="margin-left:11%; margin-top: 1em">There are some
differences between functions <b>EVP_CipherInit()</b> and
<b>EVP_CipherInit_ex()</b>, significant in some
circumstances. <b>EVP_CipherInit()</b> fills the passed
context object with zeros. As a consequence,
<b>EVP_CipherInit()</b> does not allow step-by-step
initialization of the ctx when the <i>key</i> and <i>iv</i>
are passed in separate calls. It also means that the flags
set for the <small>CTX</small> are removed, and it is
especially important for the
<b><small>EVP_CIPHER_CTX_FLAG_WRAP_ALLOW</small></b> flag
treated specially in <b>EVP_CipherInit_ex()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Ignoring
failure returns of the <b><small>EVP_CIPHER_CTX</small></b>
initialization functions can lead to subsequent undefined
behavior when calling the functions that update or finalize
the context. The only valid calls on the
<b><small>EVP_CIPHER_CTX</small></b> when initialization
fails are calls that attempt another initialization of the
context or release the context.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_get_cipherbynid()</b>,
and <b>EVP_get_cipherbyobj()</b> are implemented as
macros.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b><small>EVP_MAX_KEY_LENGTH</small></b>
and <b><small>EVP_MAX_IV_LENGTH</small></b> only refer to
the internal ciphers with default key lengths. If custom
ciphers exceed these values the results are unpredictable.
This is because it has become standard practice to define a
generic key as a fixed unsigned char array containing
<b><small>EVP_MAX_KEY_LENGTH</small></b> bytes.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>ASN1</small> code is incomplete (and sometimes
inaccurate) it has only been tested for certain common
S/MIME ciphers ( <small>RC2, DES,</small> triple
<small>DES</small> ) in <small>CBC</small> mode.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Encrypt a
string using <small>IDEA:</small></p>

<p style="margin-left:11%; margin-top: 1em">int
do_crypt(char *outfile) <br>
{ <br>
unsigned char outbuf[1024]; <br>
int outlen, tmplen; <br>
/* <br>
* Bogus key and IV: we'd normally set these from <br>
* another source. <br>
*/ <br>
unsigned char key[] =
{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; <br>
unsigned char iv[] = {1,2,3,4,5,6,7,8}; <br>
char intext[] = &quot;Some Crypto Text&quot;; <br>
EVP_CIPHER_CTX *ctx; <br>
FILE *out; <br>
ctx = EVP_CIPHER_CTX_new(); <br>
if (!EVP_EncryptInit_ex2(ctx, EVP_idea_cbc(), key, iv,
NULL)) { <br>
/* Error */ <br>
EVP_CIPHER_CTX_free(ctx); <br>
return 0; <br>
} <br>
if (!EVP_EncryptUpdate(ctx, outbuf, &amp;outlen, intext,
strlen(intext))) { <br>
/* Error */ <br>
EVP_CIPHER_CTX_free(ctx); <br>
return 0; <br>
} <br>
/* <br>
* Buffer passed to EVP_EncryptFinal() must be after data
just <br>
* encrypted to avoid overwriting it. <br>
*/ <br>
if (!EVP_EncryptFinal_ex(ctx, outbuf + outlen, &amp;tmplen))
{ <br>
/* Error */ <br>
EVP_CIPHER_CTX_free(ctx); <br>
return 0; <br>
} <br>
outlen += tmplen; <br>
EVP_CIPHER_CTX_free(ctx); <br>
/* <br>
* Need binary mode for fopen because encrypted data is <br>
* binary data. Also cannot use strlen() on it because <br>
* it won't be NUL terminated and may contain embedded <br>
* NULs. <br>
*/ <br>
out = fopen(outfile, &quot;wb&quot;); <br>
if (out == NULL) { <br>
/* Error */ <br>
return 0; <br>
} <br>
fwrite(outbuf, 1, outlen, out); <br>
fclose(out); <br>
return 1; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The ciphertext
from the above example can be decrypted using the
<b>openssl</b> utility with the command line (shown on two
lines for clarity):</p>

<p style="margin-left:11%; margin-top: 1em">openssl idea
&minus;d \ <br>
&minus;K 000102030405060708090A0B0C0D0E0F &minus;iv
0102030405060708 &lt;filename</p>

<p style="margin-left:11%; margin-top: 1em">General
encryption and decryption function example using <small>FILE
I/O</small> and <small>AES128</small> with a 128&minus;bit
key:</p>

<p style="margin-left:11%; margin-top: 1em">int
do_crypt(FILE *in, FILE *out, int do_encrypt) <br>
{ <br>
/* Allow enough space in output buffer for additional block
*/ <br>
unsigned char inbuf[1024], outbuf[1024 +
EVP_MAX_BLOCK_LENGTH]; <br>
int inlen, outlen; <br>
EVP_CIPHER_CTX *ctx; <br>
/* <br>
* Bogus key and IV: we'd normally set these from <br>
* another source. <br>
*/ <br>
unsigned char key[] = &quot;0123456789abcdeF&quot;; <br>
unsigned char iv[] = &quot;1234567887654321&quot;; <br>
/* Don't set key or IV right away; we want to check lengths
*/ <br>
ctx = EVP_CIPHER_CTX_new(); <br>
if (!EVP_CipherInit_ex2(ctx, EVP_aes_128_cbc(), NULL, NULL,
<br>
do_encrypt, NULL)) { <br>
/* Error */ <br>
EVP_CIPHER_CTX_free(ctx); <br>
return 0; <br>
} <br>
OPENSSL_assert(EVP_CIPHER_CTX_get_key_length(ctx) == 16);
<br>
OPENSSL_assert(EVP_CIPHER_CTX_get_iv_length(ctx) == 16);
<br>
/* Now we can set key and IV */ <br>
if (!EVP_CipherInit_ex2(ctx, NULL, key, iv, do_encrypt,
NULL)) { <br>
/* Error */ <br>
EVP_CIPHER_CTX_free(ctx); <br>
return 0; <br>
} <br>
for (;;) { <br>
inlen = fread(inbuf, 1, 1024, in); <br>
if (inlen &lt;= 0) <br>
break; <br>
if (!EVP_CipherUpdate(ctx, outbuf, &amp;outlen, inbuf,
inlen)) { <br>
/* Error */ <br>
EVP_CIPHER_CTX_free(ctx); <br>
return 0; <br>
} <br>
fwrite(outbuf, 1, outlen, out); <br>
} <br>
if (!EVP_CipherFinal_ex(ctx, outbuf, &amp;outlen)) { <br>
/* Error */ <br>
EVP_CIPHER_CTX_free(ctx); <br>
return 0; <br>
} <br>
fwrite(outbuf, 1, outlen, out); <br>
EVP_CIPHER_CTX_free(ctx); <br>
return 1; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Encryption
using AES-CBC with a 256&minus;bit key with &quot;
<small>CS1&quot;</small> ciphertext stealing.</p>

<p style="margin-left:11%; margin-top: 1em">int
encrypt(const unsigned char *key, const unsigned char *iv,
<br>
const unsigned char *msg, size_t msg_len, unsigned char
*out) <br>
{ <br>
/* <br>
* This assumes that key size is 32 bytes and the iv is 16
bytes. <br>
* For ciphertext stealing mode the length of the ciphertext
&quot;out&quot; will be <br>
* the same size as the plaintext size &quot;msg_len&quot;.
<br>
* The &quot;msg_len&quot; can be any size &gt;= 16. <br>
*/ <br>
int ret = 0, encrypt = 1, outlen, len; <br>
EVP_CIPHER_CTX *ctx = NULL; <br>
EVP_CIPHER *cipher = NULL; <br>
OSSL_PARAM params[2]; <br>
ctx = EVP_CIPHER_CTX_new(); <br>
cipher = EVP_CIPHER_fetch(NULL,
&quot;AES&minus;256&minus;CBC&minus;CTS&quot;, NULL); <br>
if (ctx == NULL || cipher == NULL) <br>
goto err; <br>
/* <br>
* The default is &quot;CS1&quot; so this is not really
needed, <br>
* but would be needed to set either &quot;CS2&quot; or
&quot;CS3&quot;. <br>
*/ <br>
params[0] =
OSSL_PARAM_construct_utf8_string(OSSL_CIPHER_PARAM_CTS_MODE,
<br>
&quot;CS1&quot;, 0); <br>
params[1] = OSSL_PARAM_construct_end(); <br>
if (!EVP_CipherInit_ex2(ctx, cipher, key, iv, encrypt,
params)) <br>
goto err; <br>
/* NOTE: CTS mode does not support multiple calls to
EVP_CipherUpdate() */ <br>
if (!EVP_CipherUpdate(ctx, out, &amp;outlen, msg, msg_len))
<br>
goto err; <br>
if (!EVP_CipherFinal_ex(ctx, out + outlen, &amp;len)) <br>
goto err; <br>
ret = 1; <br>
err: <br>
EVP_CIPHER_free(cipher); <br>
EVP_CIPHER_CTX_free(ctx); <br>
return ret; <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>evp</b>(7),
<b>property</b>(7), &quot; <small>ALGORITHM
FETCHING&quot;</small> in <b>crypto</b>(7),
<b>provider&minus;cipher</b>(7),
<b>life_cycle&minus;cipher</b>(7)</p>

<p style="margin-left:11%; margin-top: 1em">Supported
ciphers are listed in:</p>


<p style="margin-left:11%; margin-top: 1em"><b>EVP_aes_128_gcm</b>(3),
<b>EVP_aria_128_gcm</b>(3), <b>EVP_bf_cbc</b>(3),
<b>EVP_camellia_128_ecb</b>(3), <b>EVP_cast5_cbc</b>(3),
<b>EVP_chacha20</b>(3), <b>EVP_des_cbc</b>(3),
<b>EVP_desx_cbc</b>(3), <b>EVP_idea_cbc</b>(3),
<b>EVP_rc2_cbc</b>(3), <b>EVP_rc4</b>(3),
<b>EVP_rc5_32_12_16_cbc</b>(3), <b>EVP_seed_cbc</b>(3),
<b>EVP_sm4_cbc</b>(3),</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Support for
<small>OCB</small> mode was added in OpenSSL 1.1.0.</p>


<p style="margin-left:11%; margin-top: 1em"><b><small>EVP_CIPHER_CTX</small></b>
was made opaque in OpenSSL 1.1.0. As a result,
<b>EVP_CIPHER_CTX_reset()</b> appeared and
<b>EVP_CIPHER_CTX_cleanup()</b> disappeared.
<b>EVP_CIPHER_CTX_init()</b> remains as an alias for
<b>EVP_CIPHER_CTX_reset()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_CIPHER_CTX_cipher()</b> function was deprecated in
OpenSSL 3.0; use <b>EVP_CIPHER_CTX_get0_cipher()</b>
instead.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_EncryptInit_ex2()</b>, <b>EVP_DecryptInit_ex2()</b>,
<b>EVP_CipherInit_ex2()</b>, <b>EVP_CIPHER_fetch()</b>,
<b>EVP_CIPHER_free()</b>, <b>EVP_CIPHER_up_ref()</b>,
<b>EVP_CIPHER_CTX_get0_cipher()</b>,
<b>EVP_CIPHER_CTX_get1_cipher()</b>,
<b>EVP_CIPHER_get_params()</b>,
<b>EVP_CIPHER_CTX_set_params()</b>,
<b>EVP_CIPHER_CTX_get_params()</b>,
<b>EVP_CIPHER_gettable_params()</b>,
<b>EVP_CIPHER_settable_ctx_params()</b>,
<b>EVP_CIPHER_gettable_ctx_params()</b>,
<b>EVP_CIPHER_CTX_settable_params()</b> and
<b>EVP_CIPHER_CTX_gettable_params()</b> functions were added
in 3.0.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_CIPHER_nid()</b>, <b>EVP_CIPHER_name()</b>,
<b>EVP_CIPHER_block_size()</b>,
<b>EVP_CIPHER_key_length()</b>,
<b>EVP_CIPHER_iv_length()</b>, <b>EVP_CIPHER_flags()</b>,
<b>EVP_CIPHER_mode()</b>, <b>EVP_CIPHER_type()</b>,
<b>EVP_CIPHER_CTX_nid()</b>,
<b>EVP_CIPHER_CTX_block_size()</b>,
<b>EVP_CIPHER_CTX_key_length()</b>,
<b>EVP_CIPHER_CTX_iv_length()</b>,
<b>EVP_CIPHER_CTX_tag_length()</b>,
<b>EVP_CIPHER_CTX_num()</b>, <b>EVP_CIPHER_CTX_type()</b>,
and <b>EVP_CIPHER_CTX_mode()</b> functions were renamed to
include &quot;get&quot; or &quot;get0&quot; in their names
in OpenSSL 3.0, respectively. The old names are kept as
non-deprecated alias macros.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_CIPHER_CTX_encrypting()</b> function was renamed to
<b>EVP_CIPHER_CTX_is_encrypting()</b> in OpenSSL 3.0. The
old name is kept as non-deprecated alias macro.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>EVP_CIPHER_CTX_flags()</b> macro was deprecated in
OpenSSL 1.1.0.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2000&minus;2023 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
