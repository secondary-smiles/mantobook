<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:14 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::regex_constants</title>

</head>
<body>
<h1>std::regex_constants</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::regex_constants
&minus; ISO C++ 2011 namespace for options and flags used
with std::regex.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>5.1 Regular
Expression Syntax Options</b></p>

<p style="margin-left:17%;">enum <b>syntax_option_type</b>
: unsigned int { <b>_S_icase</b>, <b>_S_nosubs</b>,
<b>_S_optimize</b>, <b>_S_collate</b>, <b>_S_ECMAScript</b>,
<b>_S_basic</b>, <b>_S_extended</b>, <b>_S_awk</b>,
<b>_S_grep</b>, <b>_S_egrep</b>, <b>_S_polynomial</b>,
<b>_S_multiline</b> } <br>
This is a bitmask type indicating how to interpret the
regex. <br>
constexpr <b>syntax_option_type icase</b> <br>
constexpr <b>syntax_option_type nosubs</b> <br>
constexpr <b>syntax_option_type optimize</b> <br>
constexpr <b>syntax_option_type collate</b> <br>
constexpr <b>syntax_option_type ECMAScript</b> <br>
constexpr <b>syntax_option_type basic</b> <br>
constexpr <b>syntax_option_type extended</b> <br>
constexpr <b>syntax_option_type awk</b> <br>
constexpr <b>syntax_option_type grep</b> <br>
constexpr <b>syntax_option_type egrep</b> <br>
constexpr <b>syntax_option_type multiline</b> <br>
constexpr <b>syntax_option_type __multiline</b> <br>
Extension: Equivalent to regex_constants::multiline for
C++11 and C++14. <br>
constexpr <b>syntax_option_type __polynomial</b> <br>
constexpr <b>syntax_option_type operator&amp;</b>
(<b>syntax_option_type</b> __a, <b>syntax_option_type</b>
__b) <br>
This is a bitmask type indicating how to interpret the
regex. <br>
constexpr <b>syntax_option_type operator|</b>
(<b>syntax_option_type</b> __a, <b>syntax_option_type</b>
__b) <br>
This is a bitmask type indicating how to interpret the
regex. <br>
constexpr <b>syntax_option_type operator^</b>
(<b>syntax_option_type</b> __a, <b>syntax_option_type</b>
__b) <br>
This is a bitmask type indicating how to interpret the
regex. <br>
constexpr <b>syntax_option_type operator~</b>
(<b>syntax_option_type</b> __a) <br>
This is a bitmask type indicating how to interpret the
regex. <br>
constexpr <b>syntax_option_type</b> &amp;
<b>operator&amp;=</b> (<b>syntax_option_type</b> &amp;__a,
<b>syntax_option_type</b> __b) <br>
This is a bitmask type indicating how to interpret the
regex. <br>
constexpr <b>syntax_option_type</b> &amp; <b>operator|=</b>
(<b>syntax_option_type</b> &amp;__a,
<b>syntax_option_type</b> __b) <br>
This is a bitmask type indicating how to interpret the
regex. <br>
constexpr <b>syntax_option_type</b> &amp; <b>operator^=</b>
(<b>syntax_option_type</b> &amp;__a,
<b>syntax_option_type</b> __b) <br>
This is a bitmask type indicating how to interpret the
regex.</p>

<p style="margin-left:11%; margin-top: 1em"><b>5.2 Matching
Rules</b> <br>
Matching a regular expression against a sequence of
characters [first, last) proceeds according to the rules of
the grammar specified for the regular expression object,
modified according to the effects listed below for any
bitmask elements set.</p>

<p style="margin-left:17%;">enum <b>match_flag_type</b> :
unsigned int { <b>_S_default</b>, <b>_S_not_bol</b>,
<b>_S_not_eol</b>, <b>_S_not_bow</b>, <b>_S_not_eow</b>,
<b>_S_any</b>, <b>_S_not_null</b>, <b>_S_continuous</b>,
<b>_S_prev_avail</b>, <b>_S_sed</b>, <b>_S_no_copy</b>,
<b>_S_first_only</b>, <b>_S_match_flag_last</b> } <br>
This is a bitmask type indicating regex matching rules. <br>
constexpr <b>match_flag_type match_default</b> <br>
constexpr <b>match_flag_type match_not_bol</b> <br>
constexpr <b>match_flag_type match_not_eol</b> <br>
constexpr <b>match_flag_type match_not_bow</b> <br>
constexpr <b>match_flag_type match_not_eow</b> <br>
constexpr <b>match_flag_type match_any</b> <br>
constexpr <b>match_flag_type match_not_null</b> <br>
constexpr <b>match_flag_type match_continuous</b> <br>
constexpr <b>match_flag_type match_prev_avail</b> <br>
constexpr <b>match_flag_type format_default</b> <br>
constexpr <b>match_flag_type format_sed</b> <br>
constexpr <b>match_flag_type format_no_copy</b> <br>
constexpr <b>match_flag_type format_first_only</b> <br>
constexpr <b>match_flag_type operator&amp;</b>
(<b>match_flag_type</b> __a, <b>match_flag_type</b> __b)
<br>
This is a bitmask type indicating regex matching rules. <br>
constexpr <b>match_flag_type operator|</b>
(<b>match_flag_type</b> __a, <b>match_flag_type</b> __b)
<br>
This is a bitmask type indicating regex matching rules. <br>
constexpr <b>match_flag_type operator^</b>
(<b>match_flag_type</b> __a, <b>match_flag_type</b> __b)
<br>
This is a bitmask type indicating regex matching rules. <br>
constexpr <b>match_flag_type operator~</b>
(<b>match_flag_type</b> __a) <br>
This is a bitmask type indicating regex matching rules. <br>
constexpr <b>match_flag_type</b> &amp; <b>operator&amp;=</b>
(<b>match_flag_type</b> &amp;__a, <b>match_flag_type</b>
__b) <br>
This is a bitmask type indicating regex matching rules. <br>
constexpr <b>match_flag_type</b> &amp; <b>operator|=</b>
(<b>match_flag_type</b> &amp;__a, <b>match_flag_type</b>
__b) <br>
This is a bitmask type indicating regex matching rules. <br>
constexpr <b>match_flag_type</b> &amp; <b>operator^=</b>
(<b>match_flag_type</b> &amp;__a, <b>match_flag_type</b>
__b) <br>
This is a bitmask type indicating regex matching rules.</p>

<p style="margin-left:11%; margin-top: 1em"><b>5.3 Error
Types</b></p>

<p style="margin-left:17%;">enum <b>error_type</b> {
<b>_S_error_collate</b>, <b>_S_error_ctype</b>,
<b>_S_error_escape</b>, <b>_S_error_backref</b>,
<b>_S_error_brack</b>, <b>_S_error_paren</b>,
<b>_S_error_brace</b>, <b>_S_error_badbrace</b>,
<b>_S_error_range</b>, <b>_S_error_space</b>,
<b>_S_error_badrepeat</b>, <b>_S_error_complexity</b>,
<b>_S_error_stack</b>, <b>_S_null</b>, <b>_S_grammar</b> }
<br>
constexpr <b>error_type error_collate</b> (_S_error_collate)
<br>
constexpr <b>error_type error_ctype</b> (_S_error_ctype)
<br>
constexpr <b>error_type error_escape</b> (_S_error_escape)
<br>
constexpr <b>error_type error_backref</b> (_S_error_backref)
<br>
constexpr <b>error_type error_brack</b> (_S_error_brack)
<br>
constexpr <b>error_type error_paren</b> (_S_error_paren)
<br>
constexpr <b>error_type error_brace</b> (_S_error_brace)
<br>
constexpr <b>error_type error_badbrace</b>
(_S_error_badbrace) <br>
constexpr <b>error_type error_range</b> (_S_error_range)
<br>
constexpr <b>error_type error_space</b> (_S_error_space)
<br>
constexpr <b>error_type error_badrepeat</b>
(_S_error_badrepeat) <br>
constexpr <b>error_type error_complexity</b>
(_S_error_complexity) <br>
constexpr <b>error_type error_stack</b> (_S_error_stack)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">ISO C++ 2011
namespace for options and flags used with std::regex.</p>

<h2>Enumeration Type Documentation
<a name="Enumeration Type Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>enum
std::regex_constants::error_type</b> <br>
The expression contained an invalid collating element
name.</p>

<p style="margin-left:11%; margin-top: 1em"><b>enum
std::regex_constants::match_flag_type : unsigned int</b>
<br>
This is a bitmask type indicating regex matching rules. The
<tt>match_flag_type</tt> is implementation defined but it is
valid to perform bitwise operations on these values and
expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em"><b>enum
std::regex_constants::syntax_option_type : unsigned int</b>
<br>
This is a bitmask type indicating how to interpret the
regex. The <tt>syntax_option_type</tt> is implementation
defined but it is valid to perform bitwise operations on
these values and expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em">A valid value
of type syntax_option_type shall have exactly one of the
elements <tt>ECMAScript</tt>, <tt>basic</tt>,
<tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>,
<tt>egrep</tt> set.</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_backref
(_S_error_backref)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained an invalid back reference.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_badbrace
(_S_error_badbrace)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained an invalid range in a {}
expression.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_badrepeat
(_S_error_badrepeat)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
One of <i>*?+{</i> was not preceded by a valid regular
expression.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_brace
(_S_error_brace)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained mismatched { and }</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_brack
(_S_error_brack)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained mismatched [ and ].</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_collate
(_S_error_collate)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained an invalid collating element
name.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_complexity
(_S_error_complexity)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The complexity of an attempted match against a regular
expression exceeded a pre-set level.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_ctype
(_S_error_ctype)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained an invalid character class
name.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_escape
(_S_error_escape)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained an invalid escaped character, or a
trailing escape.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_paren
(_S_error_paren)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained mismatched ( and ).</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_range
(_S_error_range)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
The expression contained an invalid character range, such as
[b-a] in most encodings.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_space
(_S_error_space)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
There was insufficient memory to convert the expression into
a finite state machine.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
error_type std::regex_constants::error_stack
(_S_error_stack)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
There was insufficient memory to determine whether the
regular expression could match the specified character
sequence.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
match_flag_type std::regex_constants::operator&amp;
(match_flag_type __a, match_flag_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating regex matching rules. The
<tt>match_flag_type</tt> is implementation defined but it is
valid to perform bitwise operations on these values and
expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::operator&amp;
(syntax_option_type __a, syntax_option_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating how to interpret the
regex. The <tt>syntax_option_type</tt> is implementation
defined but it is valid to perform bitwise operations on
these values and expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em">A valid value
of type syntax_option_type shall have exactly one of the
elements <tt>ECMAScript</tt>, <tt>basic</tt>,
<tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>,
<tt>egrep</tt> set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
match_flag_type &amp; std::regex_constants::operator&amp;=
(match_flag_type &amp; __a, match_flag_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating regex matching rules. The
<tt>match_flag_type</tt> is implementation defined but it is
valid to perform bitwise operations on these values and
expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type &amp;
std::regex_constants::operator&amp;= (syntax_option_type
&amp; __a, syntax_option_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating how to interpret the
regex. The <tt>syntax_option_type</tt> is implementation
defined but it is valid to perform bitwise operations on
these values and expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em">A valid value
of type syntax_option_type shall have exactly one of the
elements <tt>ECMAScript</tt>, <tt>basic</tt>,
<tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>,
<tt>egrep</tt> set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
match_flag_type std::regex_constants::operator^
(match_flag_type __a, match_flag_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating regex matching rules. The
<tt>match_flag_type</tt> is implementation defined but it is
valid to perform bitwise operations on these values and
expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::operator^
(syntax_option_type __a, syntax_option_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating how to interpret the
regex. The <tt>syntax_option_type</tt> is implementation
defined but it is valid to perform bitwise operations on
these values and expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em">A valid value
of type syntax_option_type shall have exactly one of the
elements <tt>ECMAScript</tt>, <tt>basic</tt>,
<tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>,
<tt>egrep</tt> set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
match_flag_type &amp; std::regex_constants::operator^=
(match_flag_type &amp; __a, match_flag_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating regex matching rules. The
<tt>match_flag_type</tt> is implementation defined but it is
valid to perform bitwise operations on these values and
expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type &amp; std::regex_constants::operator^=
(syntax_option_type &amp; __a, syntax_option_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating how to interpret the
regex. The <tt>syntax_option_type</tt> is implementation
defined but it is valid to perform bitwise operations on
these values and expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em">A valid value
of type syntax_option_type shall have exactly one of the
elements <tt>ECMAScript</tt>, <tt>basic</tt>,
<tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>,
<tt>egrep</tt> set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
match_flag_type std::regex_constants::operator|
(match_flag_type __a, match_flag_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating regex matching rules. The
<tt>match_flag_type</tt> is implementation defined but it is
valid to perform bitwise operations on these values and
expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::operator|
(syntax_option_type __a, syntax_option_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating how to interpret the
regex. The <tt>syntax_option_type</tt> is implementation
defined but it is valid to perform bitwise operations on
these values and expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em">A valid value
of type syntax_option_type shall have exactly one of the
elements <tt>ECMAScript</tt>, <tt>basic</tt>,
<tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>,
<tt>egrep</tt> set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
match_flag_type &amp; std::regex_constants::operator|=
(match_flag_type &amp; __a, match_flag_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating regex matching rules. The
<tt>match_flag_type</tt> is implementation defined but it is
valid to perform bitwise operations on these values and
expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type &amp; std::regex_constants::operator|=
(syntax_option_type &amp; __a, syntax_option_type __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
This is a bitmask type indicating how to interpret the
regex. The <tt>syntax_option_type</tt> is implementation
defined but it is valid to perform bitwise operations on
these values and expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em">A valid value
of type syntax_option_type shall have exactly one of the
elements <tt>ECMAScript</tt>, <tt>basic</tt>,
<tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>,
<tt>egrep</tt> set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
match_flag_type std::regex_constants::operator~
(match_flag_type __a)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
This is a bitmask type indicating regex matching rules. The
<tt>match_flag_type</tt> is implementation defined but it is
valid to perform bitwise operations on these values and
expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::operator~
(syntax_option_type __a)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
This is a bitmask type indicating how to interpret the
regex. The <tt>syntax_option_type</tt> is implementation
defined but it is valid to perform bitwise operations on
these values and expect the right thing to happen.</p>

<p style="margin-left:11%; margin-top: 1em">A valid value
of type syntax_option_type shall have exactly one of the
elements <tt>ECMAScript</tt>, <tt>basic</tt>,
<tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>,
<tt>egrep</tt> set.</p>

<h2>Variable Documentation
<a name="Variable Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::__multiline</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Extension: Equivalent to regex_constants::multiline for
C++11 and C++14.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::__polynomial</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Extension: Ensure both space complexity of compiled regex
and time complexity execution are not exponential. If
specified in a regex with back-references, the exception
regex_constants::error_complexity will be thrown.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::awk</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that the grammar recognized by the regular
expression engine is that used by POSIX utility awk in IEEE
Std 1003.1-2001. This option is identical to
syntax_option_type extended, except that C-style escape
sequences are supported. These sequences are: \\, \a, \b,
\f, \n, \r, \t , \v, \&amp;apos,, &amp;apos,, and \ddd
(where ddd is one, two, or three octal digits).</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::basic</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that the grammar recognized by the regular
expression engine is that used by POSIX basic regular
expressions in IEEE Std 1003.1-2001, Portable Operating
System Interface (POSIX), Base Definitions and Headers,
Section 9, Regular Expressions [IEEE, Information Technology
-- Portable Operating System Interface (POSIX), IEEE
Standard 1003.1-2001].</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::collate</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that character ranges of the form [a-b] should be
locale sensitive.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::ECMAScript</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that the grammar recognized by the regular
expression engine is that used by ECMAScript in ECMA-262
[Ecma International, ECMAScript Language Specification,
Standard Ecma-262, third edition, 1999], as modified in
section [28.13]. This grammar is similar to that defined in
the PERL scripting language but extended with elements found
in the POSIX regular expression grammar.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::egrep</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that the grammar recognized by the regular
expression engine is that used by POSIX utility grep when
given the -E option in IEEE Std 1003.1-2001. This option is
identical to syntax_option_type extended, except that
newlines are treated as whitespace.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
syntax_option_type std::regex_constants::extended</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that the grammar recognized by the regular
expression engine is that used by POSIX extended regular
expressions in IEEE Std 1003.1-2001, Portable Operating
System Interface (POSIX), Base Definitions and Headers,
Section 9, Regular Expressions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>constexpr
match_flag_type std::regex_constants::format_default</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
When a regular expression match is to be replaced by a new
string, the new string is constructed using the rules used
by the ECMAScript replace function in ECMA- 262 [Ecma
International, ECMAScript Language Specification, Standard
Ecma-262, third edition, 1999], part 15.5.4.11
String.prototype.replace. In addition, during search and
replace operations all non-overlapping occurrences of the
regular expression are located and replaced, and sections of
the input that did not match the expression are copied
unchanged to the output string.</p>

<p style="margin-left:11%; margin-top: 1em">Format strings
(from ECMA-262 [15.5.4.11]):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>$$ The dollar-sign itself ($)</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>$&amp; The matched substring.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>$&lsquo; The portion of <i>string</i> that precedes the
matched substring. This would be
match_results::prefix().</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>$&rsquo; The portion of <i>string</i> that follows the
matched substring. This would be
match_results::suffix().</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>$n The nth capture, where n is in [1,9] and $n is not
followed by a decimal digit. If n &lt;=
match_results::size() and the nth capture is undefined, use
the empty string instead. If n &gt; match_results::size(),
the result is implementation-defined.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>$nn The nnth capture, where nn is a two-digit decimal
number on [01, 99]. If nn &lt;= match_results::size() and
the nth capture is undefined, use the empty string instead.
If nn &gt; match_results::size(), the result is
implementation-defined.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>constexpr match_flag_type
std::regex_constants::format_first_only</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
When specified during a search and replace operation, only
the first occurrence of the regular expression shall be
replaced. <b><br>
constexpr match_flag_type
std::regex_constants::format_no_copy</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
During a search and replace operation, sections of the
character container sequence being searched that do not
match the regular expression shall not be copied to the
output string. <b><br>
constexpr match_flag_type
std::regex_constants::format_sed</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
When a regular expression match is to be replaced by a new
string, the new string is constructed using the rules used
by the POSIX sed utility in IEEE Std 1003.1- 2001 [IEEE,
Information Technology -- Portable Operating System
Interface (POSIX), IEEE Standard 1003.1-2001]. <b><br>
constexpr syntax_option_type std::regex_constants::grep</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that the grammar recognized by the regular
expression engine is that used by POSIX utility grep in IEEE
Std 1003.1-2001. This option is identical to
syntax_option_type basic, except that newlines are treated
as whitespace. <b><br>
constexpr syntax_option_type std::regex_constants::icase</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that the matching of regular expressions against a
character sequence shall be performed without regard to
case. <b><br>
constexpr match_flag_type
std::regex_constants::match_any</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
If more than one match is possible then any match is an
acceptable result. <b><br>
constexpr match_flag_type
std::regex_constants::match_continuous</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
The expression only matches a sub-sequence that begins at
first . <br>
Referenced by <b>std::regex_iterator&lt; _Bi_iter, _Ch_type,
_Rx_traits &gt;::operator++()</b>. <b><br>
constexpr match_flag_type
std::regex_constants::match_default</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
The default matching rules. <b><br>
constexpr match_flag_type
std::regex_constants::match_not_bol</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
The first character in the sequence [first, last) is treated
as though it is not at the beginning of a line, so the
character (^) in the regular expression shall not match
[first, first). <b><br>
constexpr match_flag_type
std::regex_constants::match_not_bow</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
The expression \b is not matched against the sub-sequence
[first,first). <b><br>
constexpr match_flag_type
std::regex_constants::match_not_eol</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
The last character in the sequence [first, last) is treated
as though it is not at the end of a line, so the character
($) in the regular expression shall not match [last, last).
<b><br>
constexpr match_flag_type
std::regex_constants::match_not_eow</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
The expression \b should not be matched against the
sub-sequence [last,last). <b><br>
constexpr match_flag_type
std::regex_constants::match_not_null</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
The expression does not match an empty sequence. <br>
Referenced by <b>std::regex_iterator&lt; _Bi_iter, _Ch_type,
_Rx_traits &gt;::operator++()</b>. <b><br>
constexpr match_flag_type
std::regex_constants::match_prev_avail</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr] <br>
--first</tt> is a valid iterator position. When this flag is
set then the flags <tt>match_not_bol</tt> and
<tt>match_not_bow</tt> are ignored by the algorithms
<tt>regex_match</tt>, <tt>regex_search</tt>, and
<tt>regex_replace</tt>, and by the iterators
<tt>regex_iterator</tt> and <tt>regex_token_iterator</tt>.
<br>
Referenced by <b>std::regex_iterator&lt; _Bi_iter, _Ch_type,
_Rx_traits &gt;::operator++()</b>. <b><br>
constexpr syntax_option_type
std::regex_constants::multiline</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Specifies that the <tt>^</tt> anchor matches at the
beginning of a line, and the <tt>$</tt> anchor matches at
the end of a line, not only at the beginning/end of the
input. Valid for the ECMAScript syntax, ignored otherwise.
<b><br>
Since</b></p>

<p style="margin-left:17%;">C++17</p>

<p style="margin-left:11%;"><b>constexpr syntax_option_type
std::regex_constants::nosubs</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Specifies that when a regular expression is matched against
a character container sequence, no sub-expression matches
are to be stored in the supplied match_results structure.
<b><br>
constexpr syntax_option_type
std::regex_constants::optimize</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Specifies that the regular expression engine should pay more
attention to the speed with which regular expressions are
matched, and less to the speed with which regular expression
objects are constructed. Otherwise it has no detectable
effect on the program output.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%;">Generated automatically by
Doxygen for libstdc++ from the source code.</p>
<hr>
</body>
</html>
