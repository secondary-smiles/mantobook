<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:33 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LTTNG&minus;UST</title>

</head>
<body>
<h1>lttng_ust_tracepoint</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">lttng-ust
&minus; LTTng user space tracing</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;lttng/tracepoint.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em">#define
<b>LTTNG_UST_TP_ARGS</b>(<i>args</i>...) <br>
#define <b>LTTNG_UST_TP_ENUM_VALUES</b>(<i>values</i>...)
<br>
#define <b>LTTNG_UST_TP_FIELDS</b>(<i>fields</i>...) <br>
#define <b>LTTNG_UST_TRACEPOINT_ENUM</b>(<i>prov_name</i>,
<i>enum_name</i>, <i>mappings</i>) <br>
#define <b>LTTNG_UST_TRACEPOINT_EVENT</b>(<i>prov_name</i>,
<i>t_name</i>, <i>args</i>, <i>fields</i>) <br>
#define
<b>LTTNG_UST_TRACEPOINT_EVENT_CLASS</b>(<i>cls_prov_name</i>,
<i>cls_name</i>, <i><br>
args</i>, <i>fields</i>) <br>
#define
<b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE</b>(<i>cls_prov_name</i>,
<i>cls_name</i>, <i><br>
inst_prov_name</i>, <i>t_name</i>, <i>args</i>) <br>
#define
<b>LTTNG_UST_TRACEPOINT_LOGLEVEL</b>(<i>prov_name</i>,
<i>t_name</i>, <i>level</i>) <br>
#define <b>lttng_ust_do_tracepoint</b>(<i>prov_name</i>,
<i>t_name</i>, ...) <br>
#define <b>lttng_ust_field_array</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <br>
#define
<b>lttng_ust_field_array_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <br>
#define <b>lttng_ust_field_array_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <br>
#define
<b>lttng_ust_field_array_nowrite_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
count</i>) <br>
#define
<b>lttng_ust_field_array_network</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <br>
#define
<b>lttng_ust_field_array_network_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i><br>
expr</i>, <i>count</i>) <br>
#define
<b>lttng_ust_field_array_network_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
count</i>) <br>
#define
<b>lttng_ust_field_array_network_nowrite_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i><br>
expr</i>, <i>count</i>) <br>
#define <b>lttng_ust_field_array_text</b>(char,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <br>
#define <b>lttng_ust_field_array_text_nowrite</b>(char,
<i>field_name</i>, <i>expr</i>, <i><br>
count</i>) <br>
#define <b>lttng_ust_field_enum</b>(<i>prov_name</i>,
<i>enum_name</i>, <i>int_type</i>, <i>field_name</i>,
<i><br>
expr</i>) <br>
#define
<b>lttng_ust_field_enum_nowrite</b>(<i>prov_name</i>,
<i>enum_name</i>, <i>int_type</i>, <i><br>
field_name</i>, <i>expr</i>) <br>
#define <b>lttng_ust_field_enum_value</b>(<i>label</i>,
<i>value</i>) <br>
#define <b>lttng_ust_field_enum_range</b>(<i>label</i>,
<i>start</i>, <i>end</i>) <br>
#define <b>lttng_ust_field_float</b>(<i>float_type</i>,
<i>field_name</i>, <i>expr</i>) <br>
#define
<b>lttng_ust_field_float_nowrite</b>(<i>float_type</i>,
<i>field_name</i>, <i>expr</i>) <br>
#define <b>lttng_ust_field_integer</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>) <br>
#define <b>lttng_ust_field_integer_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>) <br>
#define
<b>lttng_ust_field_integer_network</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>) <br>
#define
<b>lttng_ust_field_integer_network_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>) <br>
#define
<b>lttng_ust_field_integer_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>) <br>
#define <b>lttng_ust_field_sequence</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <br>
#define
<b>lttng_ust_field_sequence_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <br>
#define <b>lttng_ust_field_sequence_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <br>
#define
<b>lttng_ust_field_sequence_nowrite_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <br>
#define
<b>lttng_ust_field_sequence_network</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <br>
#define
<b>lttng_ust_field_sequence_network_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i><br>
expr</i>, <i>len_type</i>, <i><br>
len_expr</i>) <br>
#define
<b>lttng_ust_field_sequence_network_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <br>
#define
<b>lttng_ust_field_sequence_network_nowrite_hex</b>(<i>int_type</i>,
<i><br>
field_name</i>, <i><br>
expr</i>, <i>len_type</i>, <i><br>
len_expr</i>) <br>
#define <b>lttng_ust_field_sequence_text</b>(char,
<i>field_name</i>, <i>expr</i>, <i>len_type</i>, <i><br>
len_expr</i>) <br>
#define <b>lttng_ust_field_sequence_text_nowrite</b>(char,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <br>
#define <b>lttng_ust_field_string</b>(<i>field_name</i>,
<i>expr</i>) <br>
#define
<b>lttng_ust_field_string_nowrite</b>(<i>field_name</i>,
<i>expr</i>) <br>
#define <b>lttng_ust_tracepoint</b>(<i>prov_name</i>,
<i>t_name</i>, ...) <br>
#define
<b>lttng_ust_tracepoint_enabled</b>(<i>prov_name</i>,
<i>t_name</i>)</p>

<p style="margin-left:11%; margin-top: 1em">Link with,
following this manual page:</p>

<p style="margin-left:17%; margin-top: 1em">&bull;
<b>-llttng-ust -ldl</b></p>

<p style="margin-left:17%; margin-top: 1em">&bull; If you
define <b>_LGPL_SOURCE</b> before including
<b>&lt;lttng/tracepoint.h&gt;</b> (directly or indirectly):
<b>-llttng-ust-common</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The <i>Linux
Trace Toolkit: next generation</i> &lt;http://lttng.org/&gt;
is an open source software package used for correlated
tracing of the Linux kernel, user applications, and user
libraries.</p>


<p style="margin-left:11%; margin-top: 1em">LTTng&minus;UST
is the user space tracing component of the LTTng project. It
is a port to user space of the low&minus;overhead tracing
capabilities of the LTTng Linux kernel tracer. The
<b>liblttng-ust</b> library is used to trace user
applications and libraries.</p>


<p style="margin-left:17%; margin-top: 1em"><b><big>Note</big></b>
<br>
This man page is about the <b>liblttng-ust</b> library. The
LTTng&minus;UST project also provides Java and Python
packages to trace applications written in those languages.
How to instrument and trace Java and Python applications is
documented in the online LTTng documentation
&lt;http://lttng.org/docs/&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">There are three
ways to use <b>liblttng-ust</b>:</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Using
the <b>lttng_ust_tracef</b>(3) API, which is similar to
<b>printf</b>(3).</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Using
the <b>lttng_ust_tracelog</b>(3) API, which is
<b>lttng_ust_tracef</b>(3) with a log level parameter.</p>

<p style="margin-left:17%; margin-top: 1em">&bull; Defining
your own tracepoints. See the <i>Creating a tracepoint
provider</i> section below.</p>


<p style="margin-left:11%; margin-top: 1em"><b><big>Compatibility
with previous APIs</big></b> <big><br>
Since LTTng&minus;UST&nbsp;2.13, the
<b>LTTNG_UST_COMPAT_API_VERSION</b> definition controls
which LTTng&minus;UST APIs are available
(compiled):</big></p>


<p style="margin-left:11%; margin-top: 1em"><big>Undefined</big></p>

<p style="margin-left:17%;"><big>All APIs are
available.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big><i>N</i>
(0 or positive integer)</big></p>

<p style="margin-left:17%;"><big>API version&nbsp;<i>N</i>,
and all the following existing APIs, are available. Previous
APIs are not available (not compiled).</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The
following table shows the mapping from LTTng&minus;UST
versions (up to LTTng&minus;UST&nbsp;2.13.5) to available
API versions:</big></p>


<p align="center" style="margin-top: 1em"><big><img src="grohtml-33395101.png" alt="Image grohtml-33395101.png"></big></p>

<p style="margin-left:11%;"><big>This manual page
<b>only</b> documents version&nbsp;1 of the API.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>If you
wish to have access to version&nbsp;0 of the API (for
example, the <b>tracepoint()</b>, <b>ctf_integer()</b>, and
<b>TRACEPOINT_EVENT()</b> macros), then either don&rsquo;t
define <b>LTTNG_UST_COMPAT_API_VERSION</b>, or define it to
<b>0</b> before including any LTTng&minus;UST
header.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b>Creating
a tracepoint provider</b> <br>
Creating a tracepoint provider is the first step of using
<b>liblttng-ust</b>. The next steps are:</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>&bull;
<i>Instrumenting your application with</i>
<b>lttng_ust_tracepoint()</b> calls</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>&bull;
Building your application with LTTng&minus;UST support,
either <i>statically</i> or <i>dynamically</i>.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>A
<b>tracepoint provider</b> is a compiled object containing
the event probes corresponding to your custom tracepoint
definitions. A tracepoint provider contains the code to get
the size of an event and to serialize it, amongst other
things.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>To create
a tracepoint provider, start with the following
<i>tracepoint provider header</i> template:</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#undef
LTTNG_UST_TRACEPOINT_PROVIDER <br>
#define LTTNG_UST_TRACEPOINT_PROVIDER my_provider</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#undef
LTTNG_UST_TRACEPOINT_INCLUDE <br>
#define LTTNG_UST_TRACEPOINT_INCLUDE
&quot;./tp.h&quot;</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#if
!defined(_TP_H) || \ <br>
defined(LTTNG_UST_TRACEPOINT_HEADER_MULTI_READ) <br>
#define _TP_H</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#include
&lt;lttng/tracepoint.h&gt;</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>/* <br>
* LTTNG_UST_TRACEPOINT_EVENT(),
LTTNG_UST_TRACEPOINT_EVENT_CLASS(), <br>
* LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(), <br>
* LTTNG_UST_TRACEPOINT_LOGLEVEL(), and
&lsquo;LTTNG_UST_TRACEPOINT_ENUM()&lsquo; <br>
* are used here. <br>
*/</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#endif /*
_TP_H */</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#include
&lt;lttng/tracepoint&minus;event.h&gt;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>In this
template, the tracepoint provider is named
<b>my_provider</b> (<b>LTTNG_UST_TRACEPOINT_PROVIDER</b>
definition). The file needs to bear the name of the
<b>LTTNG_UST_TRACEPOINT_INCLUDE</b> definition (<b>tp.h</b>
in this case). Between <b>#include
&lt;lttng/tracepoint.h&gt;</b> and <b>#endif</b> go the
invocations of the <b>LTTNG_UST_TRACEPOINT_EVENT()</b>,
<b>LTTNG_UST_TRACEPOINT_EVENT_CLASS()</b>,
<b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE()</b>,
<b>LTTNG_UST_TRACEPOINT_LOGLEVEL()</b>, and
<b>LTTNG_UST_TRACEPOINT_ENUM()</b> macros.</big></p>


<p style="margin-left:17%; margin-top: 1em"><big><b><big>Note</big></b>
<br>
You can avoid writing the prologue and epilogue boilerplate
in the template file above by using the
<b>lttng-gen-tp</b>(1) tool shipped with
LTTng&minus;UST.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The
tracepoint provider header file needs to be included in a
source file which looks like this:</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#define
LTTNG_UST_TRACEPOINT_CREATE_PROBES</big></p>

<p style="margin-left:17%; margin-top: 1em"><big>#include
&quot;tp.h&quot;</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>Together,
those two files (let&rsquo;s call them <b>tp.h</b> and
<b>tp.c</b>) form the tracepoint provider sources, ready to
be compiled.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>You can
create multiple tracepoint providers to be used in a single
application, but each one must have its own header
file.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>The
<b>LTTNG_UST_TRACEPOINT_EVENT()</b> usage section below
shows how to use the <b>LTTNG_UST_TRACEPOINT_EVENT()</b>
macro to define the actual tracepoints in the tracepoint
provider header file.</big></p>

<p style="margin-left:11%; margin-top: 1em"><big>See the
<i>EXAMPLE</i> section below for a complete
example.</big></p>


<p style="margin-left:11%; margin-top: 1em"><big><b><big>LTTNG_UST_TRACEPOINT_EVENT()</big></b>
<big>usage <br>
The <b>LTTNG_UST_TRACEPOINT_EVENT()</b> macro is used in a
template provider header file (see the <i>Creating a
tracepoint provider</i> section above) to define
LTTng&minus;UST tracepoints.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
<b>LTTNG_UST_TRACEPOINT_EVENT()</b> usage template is as
follows:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>LTTNG_UST_TRACEPOINT_EVENT(
<br>
/* Tracepoint provider name */ <br>
my_provider,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Tracepoint/event name */ <br>
my_tracepoint,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
List of tracepoint arguments (input) */ <br>
LTTNG_UST_TP_ARGS( <br>
... <br>
),</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
List of fields of eventual event (output) */ <br>
LTTNG_UST_TP_FIELDS( <br>
... <br>
) <br>
)</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
<b>LTTNG_UST_TP_ARGS()</b> macro contains the input
arguments of the tracepoint. Those arguments can be used in
the argument expressions of the output fields defined in
<b>LTTNG_UST_TP_FIELDS()</b>.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
format of the <b>LTTNG_UST_TP_ARGS()</b> parameters is: C
type, then argument name; repeat as needed, up to ten times.
For example:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>LTTNG_UST_TP_ARGS(
<br>
int, my_int, <br>
const char *, my_string, <br>
FILE *, my_file, <br>
double, my_float, <br>
struct my_data *, my_data <br>
)</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
<b>LTTNG_UST_TP_FIELDS()</b> macro contains the output
fields of the tracepoint, that is, the actual data that can
be recorded in the payload of an event emitted by this
tracepoint.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
<b>LTTNG_UST_TP_FIELDS()</b> macro contains a list of
<b>lttng_ust_field_*()</b> macros NOT separated by commas.
The available macros are documented in the <i>Available</i>
<b>lttng_ust_field_*()</b> field type macros section
below.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Available
field macros</b> <br>
This section documents the available
<b>lttng_ust_field_*()</b> macros that can be inserted in
the <b>LTTNG_UST_TP_FIELDS()</b> macro of the
<b>LTTNG_UST_TRACEPOINT_EVENT()</b> macro.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Standard
integer, displayed in base 10:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_integer</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>) <b><br>
lttng_ust_field_integer_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Standard
integer, displayed in base 16:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_integer_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Integer
in network byte order (big endian), displayed in base
10:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_integer_network</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Integer
in network byte order, displayed in base 16:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_integer_network_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Floating
point number:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_float</b>(<i>float_type</i>,
<i>field_name</i>, <i>expr</i>) <b><br>
lttng_ust_field_float_nowrite</b>(<i>float_type</i>,
<i>field_name</i>, <i>expr</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Null&minus;terminated
string:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_string</b>(<i>field_name</i>,
<i>expr</i>) <b><br>
lttng_ust_field_string_nowrite</b>(<i>field_name</i>,
<i>expr</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Statically&minus;sized
array of integers (<b>_hex</b> versions displayed in
hexadecimal, <b>_network</b> versions in network byte
order):</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_array</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <b><br>
lttng_ust_field_array_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <b><br>
lttng_ust_field_array_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <b><br>
lttng_ust_field_array_nowrite_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <b><br>
lttng_ust_field_array_network</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <b><br>
lttng_ust_field_array_network_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
count</i>) <b><br>
lttng_ust_field_array_network_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <b><br>

lttng_ust_field_array_network_nowrite_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i><br>
expr</i>, <i>count</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Statically&minus;sized
array, printed as text; no need to be
null&minus;terminated:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_array_text</b>(char,
<i>field_name</i>, <i>expr</i>, <i>count</i>) <b><br>
lttng_ust_field_array_text_nowrite</b>(char,
<i>field_name</i>, <i>expr</i>,
<i>count</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Dynamically&minus;sized
array of integers (<b>_hex</b> versions displayed in
hexadecimal, <b>_network</b> versions in network byte
order):</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_sequence</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>len_type</i>, <i><br>
len_expr</i>) <b><br>
lttng_ust_field_sequence_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <b><br>
lttng_ust_field_sequence_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i>len_type</i>, <i><br>
len_expr</i>) <b><br>
lttng_ust_field_sequence_nowrite_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <b><br>
lttng_ust_field_sequence_network</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <b><br>

lttng_ust_field_sequence_network_nowrite</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <b><br>
lttng_ust_field_sequence_network_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>) <b><br>

lttng_ust_field_sequence_network_nowrite_hex</b>(<i>int_type</i>,
<i>field_name</i>, <i><br>
expr</i>, <i>len_type</i>, <i><br>
len_expr</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Dynamically&minus;sized
array, displayed as text; no need to be
null&minus;terminated:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_sequence_text</b>(char,
<i>field_name</i>, <i>expr</i>, <i>len_type</i>, <i><br>
len_expr</i>) <b><br>
lttng_ust_field_sequence_text_nowrite</b>(char,
<i>field_name</i>, <i>expr</i>, <i><br>
len_type</i>, <i>len_expr</i>)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Enumeration.
The enumeration field must be defined before using this
macro with the <b>LTTNG_UST_TRACEPOINT_ENUM()</b> macro. See
the <b>LTTNG_UST_TRACEPOINT_ENUM()</b> usage section for
more information.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_enum</b>(<i>prov_name</i>,
<i>enum_name</i>, <i>int_type</i>, <i>field_name</i>,
<i><br>
expr</i>) <b><br>
lttng_ust_field_enum_nowrite</b>(<i>prov_name</i>,
<i>enum_name</i>, <i>int_type</i>, <i><br>
field_name</i>, <i>expr</i>)</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
parameters are:</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>count</i></big></big></p>

<p style="margin-left:17%;"><big><big>Number of elements in
array/sequence. This must be known at compile
time.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>enum_name</i></big></big></p>

<p style="margin-left:17%;"><big><big>Name of an
enumeration field previously defined with the
<b>LTTNG_UST_TRACEPOINT_ENUM()</b> macro. See the
<b>LTTNG_UST_TRACEPOINT_ENUM()</b> usage section for more
information.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>expr</i></big></big></p>

<p style="margin-left:17%;"><big><big>C expression
resulting in the field&rsquo;s value. This expression can
use one or more arguments passed to the tracepoint. The
arguments of a given tracepoint are defined in the
<b>LTTNG_UST_TP_ARGS()</b> macro (see the <i>Creating a
tracepoint provider</i> section above).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>field_name</i></big></big></p>

<p style="margin-left:17%;"><big><big>Event field name (C
identifier syntax, NOT a literal string).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>float_type</i></big></big></p>

<p style="margin-left:17%;"><big><big>Float C type
(<b>float</b> or <b>double</b>). The size of this type
determines the size of the floating point number
field.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>int_type</i></big></big></p>

<p style="margin-left:17%;"><big><big>Integer C type. The
size of this type determines the size of the
integer/enumeration field.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>len_expr</i></big></big></p>

<p style="margin-left:17%;"><big><big>C expression
resulting in the sequence&rsquo;s length. This expression
can use one or more arguments passed to the
tracepoint.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>len_type</i></big></big></p>

<p style="margin-left:17%;"><big><big>Unsigned integer C
type of sequence&rsquo;s length.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>prov_name</i></big></big></p>

<p style="margin-left:17%;"><big><big>Tracepoint provider
name. This must be the same as the tracepoint provider name
used in a previous field definition.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
<b>_nowrite</b> versions omit themselves from the recorded
trace, but are otherwise identical. Their primary purpose is
to make some of the event context available to the event
filters without having to commit the data to
sub&minus;buffers. See <b>lttng-enable-event</b>(1) to learn
more about dynamic event filtering.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>See
the <i>EXAMPLE</i> section below for a complete
example.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_ENUM()</b>
usage <br>
An enumeration field is a list of mappings between an
integers, or a range of integers, and strings (sometimes
called <i>labels</i> or <i>enumerators</i>). Enumeration
fields can be used to have a more compact trace when the
possible values for a field are limited.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>An
enumeration field is defined with the
<b>LTTNG_UST_TRACEPOINT_ENUM()</b> macro:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>LTTNG_UST_TRACEPOINT_ENUM(
<br>
/* Tracepoint provider name */ <br>
my_provider,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Enumeration name (unique in the whole tracepoint provider)
*/ <br>
my_enum,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Enumeration mappings */ <br>
LTTNG_UST_TP_ENUM_VALUES( <br>
... <br>
) <br>
)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TP_ENUM_VALUES()</b>
contains a list of enumeration mappings, NOT separated by
commas. Two macros can be used in the
<b>LTTNG_UST_TP_ENUM_VALUES()</b>:
<b>lttng_ust_field_enum_value()</b> and
<b>lttng_ust_field_enum_range()</b>.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>lttng_ust_field_enum_value()</b>
is a single value mapping:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_enum_value</b>(<i>label</i>,
<i>value</i>)</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>This
macro maps the given <i>label</i> string to the value
<i>value</i>.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>lttng_ust_field_enum_range()</b>
is a range mapping:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b>lttng_ust_field_enum_range</b>(<i>label</i>,
<i>start</i>, <i>end</i>)</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>This
macro maps the given <i>label</i> string to the range of
integers from <i>start</i> to <i>end</i>, inclusively. Range
mappings may overlap, but the behaviour is
implementation&minus;defined: each trace reader handles
overlapping ranges as it wishes.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>See
the <i>EXAMPLE</i> section below for a complete
example.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_EVENT_CLASS()</b>
usage <br>
A <b>tracepoint class</b> is a class of tracepoints sharing
the same field types and names. A tracepoint instance is one
instance of such a declared tracepoint class, with its own
event name.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>LTTng&minus;UST
creates one event serialization function per tracepoint
class. Using <b>LTTNG_UST_TRACEPOINT_EVENT()</b> creates one
tracepoint class per tracepoint definition, whereas using
<b>LTTNG_UST_TRACEPOINT_EVENT_CLASS()</b> and
<b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE()</b> creates one
tracepoint class, and one or more tracepoint instances of
this class. In other words, many tracepoints can reuse the
same serialization code. Reusing the same code, when
possible, can reduce cache pollution, thus improve
performance.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
<b>LTTNG_UST_TRACEPOINT_EVENT_CLASS()</b> macro accepts the
same parameters as the <b>LTTNG_UST_TRACEPOINT_EVENT()</b>
macro, except that instead of an event name, its second
parameter is the <i>tracepoint class
name</i>:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>#define
LTTNG_UST_TRACEPOINT_PROVIDER my_provider</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
... */</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>LTTNG_UST_TRACEPOINT_EVENT_CLASS(
<br>
/* Tracepoint class provider name */ <br>
my_provider,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Tracepoint class name */ <br>
my_tracepoint_class,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
List of tracepoint arguments (input) */ <br>
LTTNG_UST_TP_ARGS( <br>
... <br>
),</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
List of fields of eventual event (output) */ <br>
LTTNG_UST_TP_FIELDS( <br>
... <br>
) <br>
)</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>Once
the tracepoint class is defined, you can create as many
tracepoint instances as needed:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>#define
LTTNG_UST_TRACEPOINT_PROVIDER natality</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
... */</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(
<br>
/* Name of the tracepoint class provider */ <br>
my_provider,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Tracepoint class name */ <br>
my_tracepoint_class,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Name of the local (instance) tracepoint provider */ <br>
natality,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Tracepoint/event name */ <br>
my_tracepoint,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
List of tracepoint arguments (input) */ <br>
LTTNG_UST_TP_ARGS( <br>
... <br>
) <br>
)</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>As
you can see, the
<b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE()</b> does not
contain the <b>LTTNG_UST_TP_FIELDS()</b> macro, because they
are defined at the <b>LTTNG_UST_TRACEPOINT_EVENT_CLASS()</b>
level.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>Note
that the <b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE()</b> macro
requires two provider names:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
The name of the tracepoint class provider
(<b>my_provider</b> in the example above).</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>This
is the same as the first argument of the
<b>LTTNG_UST_TRACEPOINT_EVENT_CLASS()</b> expansion to refer
to.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>&bull;
The name of the local, or instance, provider
(<b>natality</b> in the example above).</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>This
is the provider name which becomes the prefix part of the
name of the events which such a tracepoint
creates.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
two provider names may be different if the tracepoint class
and the tracepoint instance macros are in two different
translation units.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>See
the <i>EXAMPLE</i> section below for a complete
example.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL()</b>
usage <br>
Optionally, a <b>log level</b> can be assigned to a defined
tracepoint. Assigning different levels of severity to
tracepoints can be useful: when controlling tracing
sessions, you can choose to only enable events falling into
a specific log level range using the <b>--loglevel</b> and
<b>--loglevel-only</b> options of the
<b>lttng-enable-event</b>(1) command.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>Log
levels are assigned to tracepoints that are already defined
using the <b>LTTNG_UST_TRACEPOINT_LOGLEVEL()</b> macro. The
latter must be used after having used
<b>LTTNG_UST_TRACEPOINT_EVENT()</b> or
<b>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE()</b> for a given
tracepoint. The <b>LTTNG_UST_TRACEPOINT_LOGLEVEL()</b> macro
is used as follows:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>LTTNG_UST_TRACEPOINT_LOGLEVEL(
<br>
/* Tracepoint provider name */ <br>
my_provider,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Tracepoint/event name */ <br>
my_tracepoint,</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>/*
Log level */ <br>
LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO <br>
)</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>The
available log level definitions are:</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_EMERG</b></big></big></p>

<p style="margin-left:17%;"><big><big>System is
unusable.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_ALERT</b></big></big></p>

<p style="margin-left:17%;"><big><big>Action must be taken
immediately.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_CRIT</b></big></big></p>

<p style="margin-left:17%;"><big><big>Critical
conditions.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_ERR</b></big></big></p>

<p style="margin-left:17%;"><big><big>Error
conditions.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_WARNING</b></big></big></p>

<p style="margin-left:17%;"><big><big>Warning
conditions.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_NOTICE</b></big></big></p>

<p style="margin-left:17%;"><big><big>Normal, but
significant, condition.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO</b></big></big></p>

<p style="margin-left:17%;"><big><big>Informational
message.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_SYSTEM</b></big></big></p>

<p style="margin-left:17%;"><big><big>Debug information
with system&minus;level scope (set of
programs).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_PROGRAM</b></big></big></p>

<p style="margin-left:17%;"><big><big>Debug information
with program&minus;level scope (set of
processes).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_PROCESS</b></big></big></p>

<p style="margin-left:17%;"><big><big>Debug information
with process&minus;level scope (set of
modules).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_MODULE</b></big></big></p>

<p style="margin-left:17%;"><big><big>Debug information
with module (executable/library) scope (set of
units).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_UNIT</b></big></big></p>

<p style="margin-left:17%;"><big><big>Debug information
with compilation unit scope (set of
functions).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_FUNCTION</b></big></big></p>

<p style="margin-left:17%;"><big><big>Debug information
with function&minus;level scope.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG_LINE</b></big></big></p>

<p style="margin-left:17%;"><big><big>Debug information
with line&minus;level scope (default log
level).</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>LTTNG_UST_TRACEPOINT_LOGLEVEL_DEBUG</b></big></big></p>

<p style="margin-left:17%;"><big><big>Debug&minus;level
message.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>See
the <i>EXAMPLE</i> section below for a complete
example.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>Instrumenting
your application</b> <br>
Once the tracepoint provider is created (see the <i>Creating
a tracepoint provider</i> section above), you can instrument
your application with the defined tracepoints thanks to the
<b>lttng_ust_tracepoint()</b> macro:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>#define
<b>lttng_ust_tracepoint</b>(<i>prov_name</i>, <i>t_name</i>,
...)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>With:</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>prov_name</i></big></big></p>

<p style="margin-left:17%;"><big><big>Tracepoint provider
name.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><i>t_name</i></big></big></p>

<p style="margin-left:17%;"><big><big>Tracepoint/event
name.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>...</b></big></big></p>

<p style="margin-left:17%;"><big><big>Tracepoint arguments,
if any.</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>Make
sure to include the tracepoint provider header file anywhere
you use <b>lttng_ust_tracepoint()</b> for this
provider.</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b><big>Note</big></b>
<br>
Even though LTTng&minus;UST supports
<b>lttng_ust_tracepoint()</b> call site duplicates having
the same provider and tracepoint names, it is recommended to
use a provider/tracepoint name pair only once within the
application source code to help map events back to their
call sites when analyzing the trace.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big>Sometimes,
arguments to the tracepoint are expensive to compute (take
call stack, for example). To avoid the computation when the
tracepoint is disabled, you can use the
<b>lttng_ust_tracepoint_enabled()</b> and
<b>lttng_ust_do_tracepoint()</b> macros:</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>#define
<b>lttng_ust_tracepoint_enabled</b>(<i>prov_name</i>,
<i>t_name</i>) <br>
#define <b>lttng_ust_do_tracepoint</b>(<i>prov_name</i>,
<i>t_name</i>, ...)</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>lttng_ust_tracepoint_enabled()</b>
returns a non&minus;zero value if the tracepoint named
<i>t_name</i> from the provider named <i>prov_name</i> is
enabled at run time.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b>lttng_ust_do_tracepoint()</b>
is like <b>lttng_ust_tracepoint()</b>, except that it
doesn&rsquo;t check if the tracepoint is enabled. Using
<b>lttng_ust_tracepoint()</b> with
<b>lttng_ust_tracepoint_enabled()</b> is dangerous since
<b>lttng_ust_tracepoint()</b> also contains the
<b>lttng_ust_tracepoint_enabled()</b> check, thus a race
condition is possible in this situation:</big></big></p>

<p style="margin-left:17%; margin-top: 1em"><big><big>if
(lttng_ust_tracepoint_enabled(my_provider, my_tracepoint)) {
<br>
stuff = prepare_stuff(); <br>
}</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big>lttng_ust_tracepoint(my_provider,
my_tracepoint, stuff);</big></big></p>

<p style="margin-left:11%; margin-top: 1em"><big><big>If
the tracepoint is enabled after the condition, then
<b>stuff</b> is not prepared: the emitted event will either
contain wrong data, or the whole application could crash
(segmentation fault, for example).</big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><b><big>Note</big></b>
<br>
Neither <b>lttng_ust_tracepoint_enabled()</b> nor
<b>lttng_ust_do_tracepoint()</b> have a <b>STAP_PROBEV()</b>
call, so if you need it, you should emit this call
yourself.</big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><b><big>Statically
linking the tracepoint provider</big></b> <big><br>
With the static linking method, compiled tracepoint
providers are copied into the target
application.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>Define
<b>LTTNG_UST_TRACEPOINT_DEFINE</b> definition below the
<b>LTTNG_UST_TRACEPOINT_CREATE_PROBES</b> definition in the
tracepoint provider source:</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>#define
LTTNG_UST_TRACEPOINT_CREATE_PROBES <br>
#define LTTNG_UST_TRACEPOINT_DEFINE</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>#include
&quot;tp.h&quot;</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>Create
the tracepoint provider object file:</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>$
cc &minus;c &minus;I. tp.c</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><b><big>Note</big></b>
<br>
Although an application instrumented with LTTng&minus;UST
tracepoints can be compiled with a C++ compiler, tracepoint
probes should be compiled with a C
compiler.</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>At
this point, you <i>can</i> archive this tracepoint provider
object file, possibly with other object files of your
application or with other tracepoint provider object files,
as a static library:</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>$
ar rc tp.a tp.o</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>Using
a static library does have the advantage of centralising the
tracepoint providers objects so they can be shared between
multiple applications. This way, when the tracepoint
provider is modified, the source code changes don&rsquo;t
have to be patched into each application&rsquo;s source code
tree. The applications need to be relinked after each
change, but need not to be otherwise recompiled (unless the
tracepoint provider&rsquo;s API
changes).</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big>Then,
link your application with this object file (or with the
static library containing it) and with <b>liblttng-ust</b>
and <b>libdl</b> (<b>libc</b> on a BSD
system):</big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big>$
cc &minus;o app tp.o app.o &minus;llttng&minus;ust
&minus;ldl</big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><b><big>Dynamically
loading the tracepoint provider</big></b> <big><br>
The second approach to package the tracepoint provider is to
use the dynamic loader: the library and its member functions
are explicitly sought, loaded at run
time.</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>In
this scenario, the tracepoint provider is compiled as a
shared object.</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>The
process to create the tracepoint provider shared object is
pretty much the same as the <i>static linking method</i>,
except that:</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>&bull;
Since the tracepoint provider is not part of the
application, <b>LTTNG_UST_TRACEPOINT_DEFINE</b> must be
defined, for each tracepoint provider, in exactly one source
file of the <i>application</i></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>&bull;
<b>LTTNG_UST_TRACEPOINT_PROBE_DYNAMIC_LINKAGE</b> must be
defined next to
<b>LTTNG_UST_TRACEPOINT_DEFINE</b></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>Regarding
<b>LTTNG_UST_TRACEPOINT_DEFINE</b> and
<b>LTTNG_UST_TRACEPOINT_PROBE_DYNAMIC_LINKAGE</b>, the
recommended practice is to use a separate C source file in
your application to define them, then include the tracepoint
provider header files afterwards. For example, as
<b>tp-define.c</b>:</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>#define
LTTNG_UST_TRACEPOINT_DEFINE <br>
#define
LTTNG_UST_TRACEPOINT_PROBE_DYNAMIC_LINKAGE</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>#include
&quot;tp.h&quot;</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>The
tracepoint provider object file used to create the shared
library is built like it is using the static linking method,
but with the <b>-fpic</b>
option:</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>$
cc &minus;c &minus;fpic &minus;I.
tp.c</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>It
is then linked as a shared library like
this:</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>$
cc &minus;shared
&minus;Wl,&minus;&minus;no&minus;as&minus;needed &minus;o
tp.so tp.o
&minus;llttng&minus;ust</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>This
tracepoint provider shared object isn&rsquo;t linked with
the user application: it must be loaded manually. This is
why the application is built with no mention of this
tracepoint provider, but still needs
libdl:</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>$
cc &minus;o app app.o tp&minus;define.o
&minus;ldl</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>There
are two ways to dynamically load the tracepoint provider
shared object:</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>&bull;
Load it manually from the application using
<b>dlopen</b>(3)</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>&bull;
Make the dynamic loader load it with the <b>LD_PRELOAD</b>
environment variable (see
<b>ld.so</b>(8))</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>If
the application does not dynamically load the tracepoint
provider shared object using one of the methods above,
tracing is disabled for this application, and the events are
not listed in the output of
<b>lttng-list</b>(1).</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>Note
that it is not safe to use <b>dlclose</b>(3) on a tracepoint
provider shared object that is being actively used for
tracing, due to a lack of reference counting from
LTTng&minus;UST to the shared
object.</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>For
example, statically linking a tracepoint provider to a
shared object which is to be dynamically loaded by an
application (a plugin, for example) is not safe: the shared
object, which contains the tracepoint provider, could be
dynamically closed (<b>dlclose</b>(3)) at any time by the
application.</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>To
instrument a shared object,
either:</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>&bull;
Statically link the tracepoint provider to the application,
or</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big>&bull;
Build the tracepoint provider as a shared object (following
the procedure shown in this section), and preload it when
tracing is needed using the <b>LD_PRELOAD</b> environment
variable.</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><b>Using
LTTng&minus;UST with daemons</b> <br>
Some extra care is needed when using <b>liblttng-ust</b>
with daemon applications that call <b>fork</b>(2),
<b>clone</b>(2), or BSD&rsquo;s <b>rfork</b>(2) without a
following <b>exec</b>(3) family system call. The library
<b>liblttng-ust-fork.so</b> needs to be preloaded before
starting the application with the <b>LD_PRELOAD</b>
environment variable (see
<b>ld.so</b>(8)).</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>To
use <b>liblttng-ust</b> with a daemon application which
closes file descriptors that were not opened by it, preload
the <b>liblttng-ust-fd.so</b> library before you start the
application. Typical use cases include daemons closing all
file descriptors after <b>fork</b>(2), and buggy
applications doing
&ldquo;double&minus;closes&rdquo;.</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><b>Context
information</b> <br>
Context information can be prepended by the LTTng&minus;UST
tracer before each event, or before specific
events.</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>Context
fields can be added to specific channels using
<b>lttng-add-context</b>(1).</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>The
following context fields are supported by
LTTng&minus;UST:</big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big>General
context fields</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><b>cpu_id</b></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big>CPU
ID.</big></big></big></big></p>


<p style="margin-left:29%; margin-top: 1em"><big><big><big><big><b><big>Note</big></b>
<br>
This context field is always enabled, and it cannot be added
with <b>lttng-add-context</b>(1). Its main purpose is to be
used for dynamic event filtering. See
<b>lttng-enable-event</b>(1) for more information about
event filtering.</big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><b><big>ip</big></b></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Instruction
pointer: enables recording the exact address from which an
event was emitted. This context field can be used to
reverse&minus;lookup the source location that caused the
event to be emitted.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>pthread_id</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>POSIX
thread identifier.</big></big></big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big><big><big>Can
be used on architectures where <b>pthread_t</b> maps nicely
to an <b>unsigned long</b>
type.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>Process
context fields</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>procname</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Thread
name, as set by <b>exec</b>(3) or <b>prctl</b>(2). It is
recommended that programs set their thread name with
<b>prctl</b>(2) before hitting the first tracepoint for that
thread.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>vpid</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Virtual
process ID: process ID as seen from the point of view of the
current process ID namespace (see
<b>pid_namespaces</b>(7)).</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>vtid</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Virtual
thread ID: thread ID as seen from the point of view of the
current process ID namespace (see
<b>pid_namespaces</b>(7)).</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>perf
context fields</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>perf:thread:COUNTER</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>perf
counter named <i>COUNTER</i>. Use <b>lttng add-context
--list</b> to list the available perf
counters.</big></big></big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big><big><big>Only
available on IA&minus;32 and x86&minus;64
architectures.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>perf:thread:raw:rN:NAME</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>perf
counter with raw ID <i>N</i> and custom name <i>NAME</i>.
See <b>lttng-add-context</b>(1) for more
details.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>Namespace
context fields (see
<b>namespaces</b>(7))</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>cgroup_ns</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>Inode
number of the current control group namespace (see
<b>cgroup_namespaces</b>(7)) in the proc file
system.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>ipc_ns</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>Inode
number of the current IPC namespace (see
<b>ipc_namespaces</b>(7)) in the proc file
system.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>mnt_ns</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>Inode
number of the current mount point namespace (see
<b>mount_namespaces</b>(7)) in the proc file
system.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>net_ns</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>Inode
number of the current network namespace (see
<b>network_namespaces</b>(7)) in the proc file
system.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>pid_ns</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>Inode
number of the current process ID namespace (see
<b>pid_namespaces</b>(7)) in the proc file
system.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>time_ns</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>Inode
number of the current clock namespace (see
<b>time_namespaces</b>(7)) in the proc file
system.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>user_ns</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>Inode
number of the current user namespace (see
<b>user_namespaces</b>(7)) in the proc file
system.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>uts_ns</b></big></big></big></big></big></p>

<p style="margin-left:23%;"><big><big><big><big><big>Inode
number of the current UTS namespace (see
<b>uts_namespaces</b>(7)) in the proc file
system.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>Credential
context fields (see
<b>credentials</b>(7))</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>vuid</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Virtual
real user ID: real user ID as seen from the point of view of
the current user namespace (see
<b>user_namespaces</b>(7)).</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>vgid</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Virtual
real group ID: real group ID as seen from the point of view
of the current user namespace (see
<b>user_namespaces</b>(7)).</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>veuid</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Virtual
effective user ID: effective user ID as seen from the point
of view of the current user namespace (see
<b>user_namespaces</b>(7)).</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>vegid</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Virtual
effective group ID: effective group ID as seen from the
point of view of the current user namespace (see
<b>user_namespaces</b>(7)).</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>vsuid</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Virtual
saved set&minus;user ID: saved set&minus;user ID as seen
from the point of view of the current user namespace (see
<b>user_namespaces</b>(7)).</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b>vsgid</b></big></big></big></big></big></p>


<p style="margin-left:23%;"><big><big><big><big><big>Virtual
saved set&minus;group ID: saved set&minus;group ID as seen
from the point of view of the current user namespace (see
<b>user_namespaces</b>(7)).</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>LTTng&minus;UST
state dump</b> <br>
If an application that uses <b>liblttng-ust</b> becomes part
of a tracing session, information about its currently loaded
shared objects, their build IDs, and their debug link
information are emitted as events by the
tracer.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>The
following LTTng&minus;UST state dump events exist and must
be enabled to record application state dumps. Note that,
during the state dump phase, LTTng&minus;UST can also emit
<i>shared library load/unload</i> events (see <i>Shared
library load/unload tracking</i>
below).</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_statedump:start</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when the state dump
begins.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>This
event has no fields.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_statedump:end</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when the state dump ends. Once this event is emitted, it is
guaranteed that, for a given process, the state dump is
complete.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>This
event has no fields.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_statedump:bin_info</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when information about a currently loaded executable or
shared object is found.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>Fields:</big></big></big></big></big></p>


<p align="center" style="margin-top: 1em"><big><big><big><big><big><img src="grohtml-33395102.png" alt="Image grohtml-33395102.png"></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_statedump:build_id</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when a build ID is found in a currently loaded shared
library. See Debugging Information in Separate Files
&lt;https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html&gt;
for more information about build
IDs.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>Fields:</big></big></big></big></big></p>


<p align="center" style="margin-top: 1em"><big><big><big><big><big><img src="grohtml-33395103.png" alt="Image grohtml-33395103.png"></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_statedump:debug_link</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when debug link information is found in a currently loaded
shared library. See Debugging Information in Separate Files
&lt;https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html&gt;
for more information about debug
links.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>Fields:</big></big></big></big></big></p>


<p align="center" style="margin-top: 1em"><big><big><big><big><big><img src="grohtml-33395104.png" alt="Image grohtml-33395104.png"></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_statedump:procname</b></big></big></big></big></big></p>

<p style="margin-left:17%;"><big><big><big><big><big>The
process procname at process
start.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>Fields:</big></big></big></big></big></p>


<p align="center" style="margin-top: 1em"><big><big><big><big><big><img src="grohtml-33395105.png" alt="Image grohtml-33395105.png"></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>Shared
library load/unload tracking</b> <br>
The <i>LTTng&minus;UST state dump</i> and the
LTTng&minus;UST helper library to instrument the dynamic
linker (see <b>liblttng-ust-dl</b>(3)) can emit <b>shared
library load/unload tracking</b>
events.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>The
following shared library load/unload tracking events exist
and must be enabled to track the loading and unloading of
shared libraries:</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_lib:load</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when a shared library (shared object) is
loaded.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>Fields:</big></big></big></big></big></p>


<p align="center" style="margin-top: 1em"><big><big><big><big><big><img src="grohtml-33395106.png" alt="Image grohtml-33395106.png"></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_lib:unload</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when a shared library (shared object) is
unloaded.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>Fields:</big></big></big></big></big></p>


<p align="center" style="margin-top: 1em"><big><big><big><big><big><img src="grohtml-33395107.png" alt="Image grohtml-33395107.png"></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_lib:build_id</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when a build ID is found in a loaded shared library (shared
object). See Debugging Information in Separate Files
&lt;https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html&gt;
for more information about build
IDs.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>Fields:</big></big></big></big></big></p>


<p align="center" style="margin-top: 1em"><big><big><big><big><big><img src="grohtml-33395108.png" alt="Image grohtml-33395108.png"></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>lttng_ust_lib:debug_link</b></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big>Emitted
when debug link information is found in a loaded shared
library (shared object). See Debugging Information in
Separate Files
&lt;https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html&gt;
for more information about debug
links.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>Fields:</big></big></big></big></big></p>


<p align="center" style="margin-top: 1em"><big><big><big><big><big><img src="grohtml-33395109.png" alt="Image grohtml-33395109.png"></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b>Detect
if LTTng&minus;UST is loaded</b> <br>
To detect if <b>liblttng-ust</b> is loaded from an
application:</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>1.
Define the <b>lttng_ust_loaded</b> weak symbol
globally:</big></big></big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big><big><big>int
lttng_ust_loaded
__attribute__((weak));</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>This
weak symbol is set by the constructor of
<b>liblttng-ust</b>.</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>2.
Test <b>lttng_ust_loaded</b> where
needed:</big></big></big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big><big><big>/*
... */</big></big></big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big><big><big>if
(lttng_ust_loaded) { <br>
/* LTTng&minus;UST is loaded */ <br>
} else { <br>
/* LTTng&minus;UST is NOT loaded */ <br>
}</big></big></big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big><big><big>/*
... */</big></big></big></big></big></p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>



<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><b><big>Note</big></b>
<br>
A few examples are available in the directory of
LTTng&minus;UST&rsquo;s source
tree.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>This
example shows all the features documented in the previous
sections. The <i>static linking</i> method is chosen here to
link the application with the tracepoint
provider.</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>You
can compile the source files and link them together
statically like this:</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>$
cc &minus;c &minus;I. tp.c <br>
$ cc &minus;c app.c <br>
$ cc &minus;o app tp.o app.o &minus;llttng&minus;ust
&minus;ldl</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>Using
the <b>lttng</b>(1) tool, create an LTTng tracing session,
enable all the events of this tracepoint provider, and start
tracing:</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>$
lttng create my&minus;session <br>
$ lttng enable&minus;event &minus;&minus;userspace
'my_provider:*' <br>
$ lttng start</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>You
may also enable specific
events:</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>$
lttng enable&minus;event &minus;&minus;userspace
my_provider:big_event <br>
$ lttng enable&minus;event &minus;&minus;userspace
my_provider:event_instance2</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>Run
the application:</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>$
./app some arguments</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big>Stop
the current tracing session and inspect the recorded
events:</big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big>$
lttng stop <br>
$ lttng view</big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><b><big>Tracepoint
provider header file <br>

tp.h</big></b><big>:</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#undef
LTTNG_UST_TRACEPOINT_PROVIDER <br>
#define LTTNG_UST_TRACEPOINT_PROVIDER
my_provider</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#undef
LTTNG_USTTRACEPOINT_INCLUDE <br>
#define LTTNG_USTTRACEPOINT_INCLUDE
&quot;./tp.h&quot;</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#if
!defined(_TP_H) || \ <br>
defined(LTTNG_UST_TRACEPOINT_HEADER_MULTI_READ) <br>
#define _TP_H</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#include
&lt;lttng/tracepoint.h&gt; <br>
#include
&lt;stdio.h&gt;</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#include
&quot;app.h&quot;</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_EVENT(
<br>
my_provider, <br>
simple_event, <br>
LTTNG_UST_TP_ARGS( <br>
int, my_integer_arg, <br>
const char *, my_string_arg <br>
), <br>
LTTNG_UST_TP_FIELDS( <br>
lttng_ust_field_string(argc, my_string_arg) <br>
lttng_ust_field_integer(int, argv, my_integer_arg) <br>
) <br>
)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_ENUM(
<br>
my_provider, <br>
my_enum, <br>
LTTNG_UST_TP_ENUM_VALUES( <br>
lttng_ust_field_enum_value(&quot;ZERO&quot;, 0) <br>
lttng_ust_field_enum_value(&quot;ONE&quot;, 1) <br>
lttng_ust_field_enum_value(&quot;TWO&quot;, 2) <br>
lttng_ust_field_enum_range(&quot;A RANGE&quot;, 52, 125)
<br>
lttng_ust_field_enum_value(&quot;ONE THOUSAND&quot;, 1000)
<br>
) <br>
)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_EVENT(
<br>
my_provider, <br>
big_event, <br>
LTTNG_UST_TP_ARGS( <br>
int, my_integer_arg, <br>
const char *, my_string_arg, <br>
FILE *, stream, <br>
double, flt_arg, <br>
int *, array_arg <br>
), <br>
LTTNG_UST_TP_FIELDS( <br>
lttng_ust_field_integer(int, int_field1, my_integer_arg * 2)
<br>
lttng_ust_field_integer_hex(long int, stream_pos, <br>
ftell(stream)) <br>
lttng_ust_field_float(double, float_field, flt_arg) <br>
lttng_ust_field_string(string_field, my_string_arg) <br>
lttng_ust_field_array(int, array_field, array_arg, 7) <br>
lttng_ust_field_array_text(char, array_text_field, <br>
array_arg, 5) <br>
lttng_ust_field_sequence(int, seq_field, array_arg, int,
<br>
my_integer_arg / 10) <br>
lttng_ust_field_sequence_text(char, seq_text_field, <br>
array_arg, int, <br>
my_integer_arg / 5) <br>
lttng_ust_field_enum(my_provider, my_enum, int, <br>
enum_field, array_arg[1]) <br>
) <br>
)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_LOGLEVEL(my_provider,
big_event, <br>

LTTNG_UST_TRACEPOINT_LOGLEVEL_WARNING)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_EVENT_CLASS(
<br>
my_provider, <br>
my_tracepoint_class, <br>
LTTNG_UST_TP_ARGS( <br>
int, my_integer_arg, <br>
struct app_struct *, app_struct_arg <br>
), <br>
LTTNG_UST_TP_FIELDS( <br>
lttng_ust_field_integer(int, a, my_integer_arg) <br>
lttng_ust_field_integer(unsigned long, b,
app_struct_arg&minus;&gt;b) <br>
lttng_ust_field_string(c, app_struct_arg&minus;&gt;c) <br>
) <br>
)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(
<br>
my_provider, <br>
my_tracepoint_class, <br>
my_provider, <br>
event_instance1, <br>
LTTNG_UST_TP_ARGS( <br>
int, my_integer_arg, <br>
struct app_struct *, app_struct_arg <br>
) <br>
)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(
<br>
my_provider, <br>
my_tracepoint_class, <br>
my_provider, <br>
event_instance2, <br>
LTTNG_UST_TP_ARGS( <br>
int, my_integer_arg, <br>
struct app_struct *, app_struct_arg <br>
) <br>
)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_LOGLEVEL(my_provider,
event_instance2, <br>

LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>LTTNG_UST_TRACEPOINT_EVENT_INSTANCE(
<br>
my_provider, <br>
my_tracepoint_class, <br>
my_provider, <br>
event_instance3, <br>
LTTNG_UST_TP_ARGS( <br>
int, my_integer_arg, <br>
struct app_struct *, app_struct_arg <br>
) <br>
)</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#endif
/* _TP_H */</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#include
&lt;lttng/tracepoint&minus;event.h&gt;</big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><b>Tracepoint
provider source file <br>
tp.c</b>:</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#define
LTTNG_UST_TRACEPOINT_CREATE_PROBES <br>
#define
LTTNG_UST_TRACEPOINT_DEFINE</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#include
&quot;tp.h&quot;</big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><b>Application
header file <br>
app.h</b>:</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#ifndef
_APP_H <br>
#define _APP_H</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>struct
app_struct { <br>
unsigned long b; <br>
const char *c; <br>
double d; <br>
};</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#endif
/* _APP_H */</big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><b>Application
source file <br>
app.c</b>:</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#include
&lt;stdlib.h&gt; <br>
#include
&lt;stdio.h&gt;</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>#include
&quot;tp.h&quot; <br>
#include
&quot;app.h&quot;</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>static
int array_of_ints[] = { <br>
100, &minus;35, 1, 23, 14, &minus;6, 28, 1001, &minus;3000,
<br>
};</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>int
main(int argc, char* argv[]) <br>
{ <br>
FILE *stream; <br>
struct app_struct
app_struct;</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>lttng_ust_tracepoint(my_provider,
simple_event, argc, argv[0]); <br>
stream = fopen(&quot;/tmp/app.txt&quot;,
&quot;w&quot;);</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>if
(!stream) { <br>
fprintf(stderr, <br>
&quot;Error: Cannot open /tmp/app.txt for writing\n&quot;);
<br>
return EXIT_FAILURE; <br>
}</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>if
(fprintf(stream, &quot;0123456789&quot;) != 10) { <br>
fclose(stream); <br>
fprintf(stderr, &quot;Error: Cannot write to
/tmp/app.txt\n&quot;); <br>
return EXIT_FAILURE; <br>
}</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>lttng_ust_tracepoint(my_provider,
big_event, 35, <br>
&quot;hello tracepoint&quot;, stream, &minus;3.14, <br>
array_of_ints); <br>
fclose(stream); <br>
app_struct.b = argc; <br>
app_struct.c = &quot;[the string]&quot;; <br>
lttng_ust_tracepoint(my_provider, event_instance1, 23, <br>
&amp;app_struct); <br>
app_struct.b = argc * 5; <br>
app_struct.c = &quot;[other string]&quot;; <br>
lttng_ust_tracepoint(my_provider, event_instance2, 17, <br>
&amp;app_struct); <br>
app_struct.b = 23; <br>
app_struct.c = &quot;nothing&quot;; <br>
lttng_ust_tracepoint(my_provider, event_instance3,
&minus;52, <br>
&amp;app_struct); <br>
return EXIT_SUCCESS; <br>
}</big></big></big></big></big></big></p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><b>LTTNG_HOME</b></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big>Alternative
user&rsquo;s home directory. This variable is useful when
the user running the instrumented application has a
non&minus;writable home
directory.</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>Unix
sockets used for the communication between
<b>liblttng-ust</b> and the LTTng session and consumer
daemons (part of the LTTng&minus;tools project) are located
in a specific directory under <b>$LTTNG_HOME</b> (or
<b>$HOME</b> if <b>$LTTNG_HOME</b> is not
set).</big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><b>LTTNG_UST_ALLOW_BLOCKING</b></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big>If
set, allow the application to retry event tracing when
there&rsquo;s no space left for the event record in the
sub&minus;buffer, therefore effectively blocking the
application until space is made available or the configured
timeout is reached.</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>To
allow an application to block during tracing, you also need
to specify a blocking timeout when you create a channel with
the <b>--blocking-timeout</b> option of the
<b>lttng-enable-channel</b>(1)
command.</big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big>This
option can be useful in workloads generating very large
trace data throughput, where blocking the application is an
acceptable trade&minus;off to prevent discarding event
records.</big></big></big></big></big></big></p>


<p style="margin-left:23%; margin-top: 1em"><big><big><big><big><big><big><b><big>Warning</big></b>
<br>
Setting this environment variable may significantly affect
application timings.</big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><b><big>LTTNG_UST_ABORT_ON_CRITICAL</big></b></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big><big>If
set, abort the instrumented application on a critical error
message.</big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><b>LTTNG_UST_CLOCK_PLUGIN</b></big></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big><big>Path
to the shared object which acts as the clock override
plugin. An example of such a plugin can be found in the
LTTng&minus;UST documentation
under</big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><b>LTTNG_UST_DEBUG</b></big></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big><big>If
set, enable <b>liblttng-ust</b>'s debug and error
output.</big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><b>LTTNG_UST_GETCPU_PLUGIN</b></big></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big><big>Path
to the shared object which acts as the <b>getcpu()</b>
override plugin. An example of such a plugin can be found in
the LTTng&minus;UST documentation
under</big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><b>LTTNG_UST_REGISTER_TIMEOUT</b></big></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big><big>Waiting
time for the <i>registration done</i> session daemon command
before proceeding to execute the main program
(milliseconds).</big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>The
value <b>0</b> means <i>do not wait</i>. The value <b>-1</b>
means <i>wait forever</i>. Setting this environment variable
to <b>0</b> is recommended for applications with time
constraints on the process startup
time.</big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>Default:
3000.</big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><b>LTTNG_UST_WITHOUT_BADDR_STATEDUMP</b></big></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big><big>If
set, prevents <b>liblttng-ust</b> from performing a base
address state dump (see the <i>LTTng&minus;UST state
dump</i> section
above).</big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><b>LTTNG_UST_WITHOUT_PROCNAME_STATEDUMP</b></big></big></big></big></big></big></big></p>


<p style="margin-left:17%;"><big><big><big><big><big><big><big>If
set, prevents <b>liblttng-ust</b> from performing a procname
state dump (see the <i>LTTng&minus;UST state dump</i>
section
above).</big></big></big></big></big></big></big></p>

<h2>BUGS
<a name="BUGS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big>If
you encounter any issue or usability problem, please report
it on the LTTng bug tracker
&lt;https://bugs.lttng.org/projects/lttng-ust&gt;.</big></big></big></big></big></big></big></p>

<h2>RESOURCES
<a name="RESOURCES"></a>
</h2>



<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>&bull;
LTTng project website
&lt;http://lttng.org&gt;</big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>&bull;
LTTng documentation
&lt;http://lttng.org/docs&gt;</big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>&bull;
Git repositories
&lt;http://git.lttng.org&gt;</big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>&bull;
GitHub organization
&lt;http://github.com/lttng&gt;</big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>&bull;
Continuous integration
&lt;http://ci.lttng.org/&gt;</big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>&bull;
Mailing list &lt;http://lists.lttng.org&gt; for support and
development:
<b>lttng-dev@lists.lttng.org</b></big></big></big></big></big></big></big></p>


<p style="margin-left:17%; margin-top: 1em"><big><big><big><big><big><big><big>&bull;
IRC channel &lt;irc://irc.oftc.net/lttng&gt;: <b>#lttng</b>
on
<b>irc.oftc.net</b></big></big></big></big></big></big></big></p>

<h2>COPYRIGHTS
<a name="COPYRIGHTS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big>This
library is part of the LTTng&minus;UST
project.</big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big>This
library is distributed under the GNU Lesser General Public
License, version 2.1
&lt;http://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html&gt;.
See the for more
details.</big></big></big></big></big></big></big></p>

<h2>THANKS
<a name="THANKS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big>Thanks
to Ericsson for funding this work, providing real&minus;life
use cases, and
testing.</big></big></big></big></big></big></big></p>


<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big>Special
thanks to Michel Dagenais and the DORSAL laboratory
&lt;http://www.dorsal.polymtl.ca/&gt; at &Eacute;cole
Polytechnique de Montr&eacute;al for the LTTng
journey.</big></big></big></big></big></big></big></p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big>LTTng&minus;UST
was originally written by Mathieu Desnoyers, with additional
contributions from various other people. It is currently
maintained by Mathieu Desnoyers
&lt;mailto:mathieu.desnoyers@efficios.com&gt;.</big></big></big></big></big></big></big></p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><big><big><big><big><big><big><big><b>lttng_ust_tracef</b>(3),
<b>lttng_ust_tracelog</b>(3), <b>lttng-gen-tp</b>(1),
<b>lttng-ust-dl</b>(3), <b>lttng-ust-cyg-profile</b>(3),
<b>lttng</b>(1), <b>lttng-enable-event</b>(1),
<b>lttng-list</b>(1), <b>lttng-add-context</b>(1),
<b>babeltrace</b>(1), <b>dlopen</b>(3),
<b>ld.so</b>(8)</big></big></big></big></big></big></big></p>
<hr>
</body>
</html>
