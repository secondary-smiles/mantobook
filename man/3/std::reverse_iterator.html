<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:13 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::reverse_iterator&lt; _Iterator &gt;</title>

</head>
<body>
<h1>std::reverse_iterator</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::reverse_iterator&lt;
_Iterator &gt;</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;iterator&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::iterator&lt; iterator_traits&lt; _Iterator
&gt;::iterator_category, iterator_traits&lt; _Iterator
&gt;::value_type, iterator_traits&lt; _Iterator
&gt;::difference_type, iterator_traits&lt; _Iterator
&gt;::pointer, iterator_traits&lt; _Iterator &gt;::reference
&gt;</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">using <b>difference_type</b> =
iter_difference_t&lt; _Iterator &gt; <br>
using <b>iterator_category</b> =
__detail::__clamp_iter_cat&lt; typename
__traits_type::iterator_category,
<b>random_access_iterator_tag</b> &gt; <br>
using <b>iterator_concept</b> = __conditional_t&lt;
random_access_iterator&lt; _Iterator &gt;,
<b>random_access_iterator_tag</b>,
<b>bidirectional_iterator_tag</b> &gt; <br>
typedef _Iterator <b>iterator_type</b> <br>
typedef __traits_type::pointer <b>pointer</b> <br>
using <b>reference</b> = iter_reference_t&lt; _Iterator &gt;
<br>
using <b>value_type</b> = iter_value_t&lt; _Iterator
&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">constexpr
<b>reverse_iterator</b> () noexcept(/*<b>conditional</b> */)
<br>
constexpr <b>reverse_iterator</b> (const
<b>reverse_iterator</b> &amp;__x)
noexcept(/*<b>conditional</b> */) <br>
template&lt;typename _Iter &gt; <br>
requires __convertible&lt;_Iter&gt;constexpr
<b>reverse_iterator</b> (const <b>reverse_iterator</b>&lt;
_Iter &gt; &amp;__x) noexcept(/*<b>conditional</b> */)&quot;
<br>
constexpr <b>reverse_iterator</b> (iterator_type __x)
noexcept(/*<b>conditional</b> */) <br>
constexpr iterator_type <b>base</b> () const
noexcept(/*<b>conditional</b> */) <br>
constexpr reference <b>operator*</b> () const <br>
constexpr <b>reverse_iterator operator+</b> (difference_type
__n) const <br>
constexpr <b>reverse_iterator</b> &amp; <b>operator++</b> ()
<br>
constexpr <b>reverse_iterator operator++</b> (int) <br>
constexpr <b>reverse_iterator</b> &amp; <b>operator+=</b>
(difference_type __n) <br>
constexpr <b>reverse_iterator operator&minus;</b>
(difference_type __n) const <br>
constexpr <b>reverse_iterator</b> &amp;
<b>operator&minus;&minus;</b> () <br>
constexpr <b>reverse_iterator operator&minus;&minus;</b>
(int) <br>
constexpr <b>reverse_iterator</b> &amp;
<b>operator&minus;=</b> (difference_type __n) <br>
constexpr pointer <b>operator&minus;&gt;</b> () const
<b><br>
reverse_iterator</b> &amp; <b>operator=</b> (const
<b>reverse_iterator</b> &amp;)=default <br>
template&lt;typename _Iter &gt; <br>
requires __convertible&lt;_Iter&gt; &amp;&amp;
assignable_from&lt;_Iterator&amp;, const
_Iter&amp;&gt;constexpr <b>reverse_iterator</b> &amp;
<b>operator=</b> (const <b>reverse_iterator</b>&lt; _Iter
&gt; &amp;__x) noexcept(/*<b>conditional</b> */)&quot; <br>
constexpr reference <b>operator[]</b> (difference_type __n)
const</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Types</b></p>

<p style="margin-left:17%;">typedef
<b>iterator_traits</b>&lt; _Iterator &gt;
<b>__traits_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Attributes</b></p>

<p style="margin-left:17%;">_Iterator <b>current</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">constexpr
iter_rvalue_reference_t&lt; _Iterator &gt; <b>iter_move</b>
(const <b>reverse_iterator</b> &amp;__i)
noexcept(is_nothrow_copy_constructible_v&lt; _Iterator &gt;
&amp;&amp;noexcept(ranges::iter_move(&minus;&minus;<b>std::declval</b>&lt;
_Iterator &amp; &gt;()))) <br>
template&lt;indirectly_swappable&lt; _Iterator &gt;
_Iter2&gt; constexpr void <b>iter_swap</b> (const
<b>reverse_iterator</b> &amp;__x, const
<b>reverse_iterator</b>&lt; _Iter2 &gt; &amp;__y)
noexcept(is_nothrow_copy_constructible_v&lt; _Iterator &gt;
&amp;&amp;is_nothrow_copy_constructible_v&lt; _Iter2 &gt;
&amp;&amp;noexcept(ranges::iter_swap(&minus;&minus;<b>std::declval</b>&lt;
_Iterator &amp; &gt;(),
&minus;&minus;<b>std::declval</b>&lt; _Iter2 &amp;
&gt;())))</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator&gt;</b> <br>
class std::reverse_iterator&lt; _Iterator
&gt;&quot;Bidirectional and random access iterators have
corresponding reverse iterator adaptors that iterate through
the data structure in the opposite direction. They have the
same signatures as the corresponding iterators. The
fundamental relation between a reverse iterator and its
corresponding iterator <tt>i</tt> is established by the
identity:</p>


<p style="margin-left:11%; margin-top: 1em">&amp;*(reverse_iterator(i))
== &amp;*(i &minus; 1)</p>

<p style="margin-left:11%; margin-top: 1em"><i>This mapping
is dictated by the fact that while there is always a pointer
past the end of an array, there might not be a valid pointer
before the beginning of an array.</i> [24.4.1]/1,2</p>

<p style="margin-left:11%; margin-top: 1em">Reverse
iterators can be tricky and surprising at first. Their
semantics make sense, however, and the trickiness is a side
effect of the requirement that the iterators must be
safe.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr std::reverse_iterator&lt; _Iterator
&gt;::reverse_iterator ()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
The default constructor value-initializes member
<tt>current</tt>. If it is a pointer, that means it is
zero-initialized.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr std::reverse_iterator&lt; _Iterator
&gt;::reverse_iterator (iterator_type __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
This iterator will move in the opposite direction that
<tt>x</tt> does.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr std::reverse_iterator&lt; _Iterator
&gt;::reverse_iterator (const reverse_iterator&lt; _Iterator
&gt; &amp; __x)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
The copy constructor is normal.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; template&lt;typename _Iter &gt;</b> <br>
requires __convertible&lt;_Iter&gt;constexpr
<b>std::reverse_iterator</b>&lt; _Iterator
&gt;::reverse_iterator (const <b>reverse_iterator</b>&lt;
_Iter &gt; &amp; __x) <tt>[inline]</tt>,
<tt>[constexpr]</tt>, <tt>[noexcept]</tt>&quot; A
reverse_iterator across other types can be copied if the
underlying iterator can be converted to the type of
<tt>current</tt>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr iterator_type
std::reverse_iterator&lt; _Iterator &gt;::base () const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt><b>,</b>
<tt>[noexcept]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;"><tt>current</tt>, the iterator
used for underlying work.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::operator==()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reference std::reverse_iterator&lt;
_Iterator &gt;::operator* () const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;">A reference to the value at
<tt>--current</tt></p>

<p style="margin-left:11%; margin-top: 1em">This requires
that <tt>--current</tt> is dereferenceable.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Warning</b></p>

<p style="margin-left:17%;">This implementation requires
that for an iterator of the underlying iterator type,
<tt>x</tt>, a reference obtained by <tt>*x</tt> remains
valid after <tt>x</tt> has been modified or destroyed. This
is a bug: http://gcc.gnu.org/PR51823</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reverse_iterator
std::reverse_iterator&lt; _Iterator &gt;::operator+
(difference_type __n) const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;">A reverse_iterator that refers
to <tt>current</tt> - <i>__n</i></p>

<p style="margin-left:11%; margin-top: 1em">The underlying
iterator must be a Random Access Iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reverse_iterator &amp;
std::reverse_iterator&lt; _Iterator &gt;::operator++ ()</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;"><tt>*this</tt></p>

<p style="margin-left:11%; margin-top: 1em">Decrements the
underlying iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reverse_iterator
std::reverse_iterator&lt; _Iterator &gt;::operator++
(int)</b> <tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt>
<b><br>
Returns</b></p>

<p style="margin-left:17%;">The original value of
<tt>*this</tt></p>

<p style="margin-left:11%; margin-top: 1em">Decrements the
underlying iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reverse_iterator &amp;
std::reverse_iterator&lt; _Iterator &gt;::operator+=
(difference_type __n)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;">*this</p>

<p style="margin-left:11%; margin-top: 1em">Moves the
underlying iterator backwards <i>__n</i> steps. The
underlying iterator must be a Random Access Iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reverse_iterator
std::reverse_iterator&lt; _Iterator &gt;::operator&minus;
(difference_type __n) const</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;">A reverse_iterator that refers
to <tt>current</tt> - <i>__n</i></p>

<p style="margin-left:11%; margin-top: 1em">The underlying
iterator must be a Random Access Iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reverse_iterator &amp;
std::reverse_iterator&lt; _Iterator
&gt;::operator&minus;&minus; ()</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;"><tt>*this</tt></p>

<p style="margin-left:11%; margin-top: 1em">Increments the
underlying iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reverse_iterator
std::reverse_iterator&lt; _Iterator
&gt;::operator&minus;&minus; (int)</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;">A reverse_iterator with the
previous value of <tt>*this</tt></p>

<p style="margin-left:11%; margin-top: 1em">Increments the
underlying iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reverse_iterator &amp;
std::reverse_iterator&lt; _Iterator &gt;::operator&minus;=
(difference_type __n)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;">*this</p>

<p style="margin-left:11%; margin-top: 1em">Moves the
underlying iterator forwards <i>__n</i> steps. The
underlying iterator must be a Random Access Iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr pointer std::reverse_iterator&lt;
_Iterator &gt;::operator&minus;&gt; () const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;">A pointer to the value at
<tt>--current</tt></p>

<p style="margin-left:11%; margin-top: 1em">This requires
that <tt>--current</tt> is dereferenceable.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator &gt; constexpr reference std::reverse_iterator&lt;
_Iterator &gt;::operator[] (difference_type __n) const</b>
<tt>[inline]</tt><b>,</b> <tt>[constexpr]</tt> <b><br>
Returns</b></p>

<p style="margin-left:17%;">The value at <tt>current</tt> -
<i>__n</i> - 1</p>

<p style="margin-left:11%; margin-top: 1em">The underlying
iterator must be a Random Access Iterator.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
