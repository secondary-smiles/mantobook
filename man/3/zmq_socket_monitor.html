<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:48 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ZMQ_SOCKET_MONITOR</title>

</head>
<body>
<h1>zmq_socket_monitor</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">zmq_socket_monitor
&minus; monitor socket events</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
zmq_socket_monitor (void</b> <i>*socket</i><b>, char</b>
<i>*endpoint</i><b>, int</b> <i>events</i><b>);</b></p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>zmq_socket_monitor()</i> method lets an application
thread track socket events (like connects) on a ZeroMQ
socket. Each call to this method creates a <i>ZMQ_PAIR</i>
socket and binds that to the specified inproc://
<i>endpoint</i>. To collect the socket events, you must
create your own <i>ZMQ_PAIR</i> socket, and connect that to
the endpoint.</p>

<p style="margin-left:11%; margin-top: 1em">Note that there
is also a DRAFT function
<b>zmq_socket_monitor_versioned</b>(3), which allows to
subscribe to events that provide more information. Calling
zmq_socket_monitor is equivalent to calling
<i>zmq_socket_monitor_versioned</i> with the
<i>event_version</i> parameter set to 1, with the exception
of error cases.</p>

<p style="margin-left:11%; margin-top: 1em">The
<i>events</i> argument is a bitmask of the socket events you
wish to monitor, see <i>Supported events</i> below. To
monitor all events, use the event value ZMQ_EVENT_ALL. NOTE:
as new events are added, the catch&minus;all value will
start returning them. An application that relies on a strict
and fixed sequence of events must not use ZMQ_EVENT_ALL in
order to guarantee compatibility with future versions.</p>

<p style="margin-left:11%; margin-top: 1em">Each event is
sent as two frames. The first frame contains an event number
(16 bits), and an event value (32 bits) that provides
additional data according to the event number. The second
frame contains a string that specifies the affected
endpoint.</p>

<p style="margin-left:17%; margin-top: 1em">The
_zmq_socket_monitor()_ method supports only
connection&minus;oriented <br>
transports, that is, TCP, IPC, and TIPC.</p>

<h2>SUPPORTED EVENTS
<a name="SUPPORTED EVENTS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_CONNECTED</b>
<br>
The socket has successfully connected to a remote peer. The
event value is the file descriptor (FD) of the underlying
network socket. Warning: there is no guarantee that the FD
is still valid by the time your code receives this
event.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_CONNECT_DELAYED</b>
<br>
A connect request on the socket is pending. The event value
is unspecified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_CONNECT_RETRIED</b>
<br>
A connect request failed, and is now being retried. The
event value is the reconnect interval in milliseconds. Note
that the reconnect interval is recalculated at each
retry.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_LISTENING</b>
<br>
The socket was successfully bound to a network interface.
The event value is the FD of the underlying network socket.
Warning: there is no guarantee that the FD is still valid by
the time your code receives this event.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_BIND_FAILED</b>
<br>
The socket could not bind to a given interface. The event
value is the errno generated by the system bind call.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_ACCEPTED</b>
<br>
The socket has accepted a connection from a remote peer. The
event value is the FD of the underlying network socket.
Warning: there is no guarantee that the FD is still valid by
the time your code receives this event.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_ACCEPT_FAILED</b>
<br>
The socket has rejected a connection from a remote peer. The
event value is the errno generated by the accept call.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_CLOSED</b>
<br>
The socket was closed. The event value is the FD of the (now
closed) network socket.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_CLOSE_FAILED</b>
<br>
The socket close failed. The event value is the errno
returned by the system call. Note that this event occurs
only on IPC transports.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_DISCONNECTED</b>
<br>
The socket was disconnected unexpectedly. The event value is
the FD of the underlying network socket. Warning: this
socket will be closed.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_MONITOR_STOPPED</b>
<br>
Monitoring on this socket ended.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_HANDSHAKE_FAILED_NO_DETAIL</b>
<br>
Unspecified error during handshake. The event value is an
errno.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_HANDSHAKE_SUCCEEDED</b>
<br>
The ZMTP security mechanism handshake succeeded. The event
value is unspecified.</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_HANDSHAKE_FAILED_PROTOCOL</b>
<br>
The ZMTP security mechanism handshake failed due to some
mechanism protocol error, either between the ZMTP mechanism
peers, or between the mechanism server and the ZAP handler.
This indicates a configuration or implementation error in
either peer resp. the ZAP handler. The event value is one of
the ZMQ_PROTOCOL_ERROR_* values:
ZMQ_PROTOCOL_ERROR_ZMTP_UNSPECIFIED
ZMQ_PROTOCOL_ERROR_ZMTP_UNEXPECTED_COMMAND
ZMQ_PROTOCOL_ERROR_ZMTP_INVALID_SEQUENCE
ZMQ_PROTOCOL_ERROR_ZMTP_KEY_EXCHANGE
ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_UNSPECIFIED
ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_MESSAGE
ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_HELLO
ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_INITIATE
ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_ERROR
ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_READY
ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_WELCOME
ZMQ_PROTOCOL_ERROR_ZMTP_INVALID_METADATA
ZMQ_PROTOCOL_ERROR_ZMTP_CRYPTOGRAPHIC
ZMQ_PROTOCOL_ERROR_ZMTP_MECHANISM_MISMATCH
ZMQ_PROTOCOL_ERROR_ZAP_UNSPECIFIED
ZMQ_PROTOCOL_ERROR_ZAP_MALFORMED_REPLY
ZMQ_PROTOCOL_ERROR_ZAP_BAD_REQUEST_ID
ZMQ_PROTOCOL_ERROR_ZAP_BAD_VERSION
ZMQ_PROTOCOL_ERROR_ZAP_INVALID_STATUS_CODE
ZMQ_PROTOCOL_ERROR_ZAP_INVALID_METADATA</p>


<p style="margin-left:11%; margin-top: 1em"><b>ZMQ_EVENT_HANDSHAKE_FAILED_AUTH</b>
<br>
The ZMTP security mechanism handshake failed due to an
authentication failure. The event value is the status code
returned by the ZAP handler (i.e. 300, 400 or 500).</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>zmq_socket_monitor()</i> function returns a value of 0 or
greater if successful. Otherwise it returns &minus;1 and
sets <i>errno</i> to one of the values defined below.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ETERM</b></p>

<p style="margin-left:17%;">The 0MQ <i>context</i>
associated with the specified <i>socket</i> was
terminated.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EPROTONOSUPPORT</b></p>

<p style="margin-left:17%;">The requested <i>transport</i>
protocol is not supported. Monitor sockets are required to
use the inproc:// transport.</p>


<p style="margin-left:11%; margin-top: 1em"><b>EINVAL</b></p>

<p style="margin-left:17%;">The endpoint supplied is
invalid.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Monitoring
client and server sockets</b>.</p>

<p style="margin-left:17%; margin-top: 1em">// Read one
event off the monitor socket; return value and address <br>
// by reference, if not null, and event number by value.
Returns &minus;1 <br>
// in case of error.</p>

<p style="margin-left:17%; margin-top: 1em">static int <br>
get_monitor_event (void *monitor, int *value, char
**address) <br>
{ <br>
// First frame in message contains event number and value
<br>
zmq_msg_t msg; <br>
zmq_msg_init (&amp;msg); <br>
if (zmq_msg_recv (&amp;msg, monitor, 0) == &minus;1) <br>
return &minus;1; // Interrupted, presumably <br>
assert (zmq_msg_more (&amp;msg));</p>

<p style="margin-left:17%; margin-top: 1em">uint8_t *data =
(uint8_t *) zmq_msg_data (&amp;msg); <br>
uint16_t event = *(uint16_t *) (data); <br>
if (value) <br>
*value = *(uint32_t *) (data + 2);</p>

<p style="margin-left:17%; margin-top: 1em">// Second frame
in message contains event address <br>
zmq_msg_init (&amp;msg); <br>
if (zmq_msg_recv (&amp;msg, monitor, 0) == &minus;1) <br>
return &minus;1; // Interrupted, presumably <br>
assert (!zmq_msg_more (&amp;msg));</p>

<p style="margin-left:17%; margin-top: 1em">if (address) {
<br>
uint8_t *data = (uint8_t *) zmq_msg_data (&amp;msg); <br>
size_t size = zmq_msg_size (&amp;msg); <br>
*address = (char *) malloc (size + 1); <br>
memcpy (*address, data, size); <br>
(*address)[size] = 0; <br>
} <br>
return event; <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">int main (void)
<br>
{ <br>
void *ctx = zmq_ctx_new (); <br>
assert (ctx);</p>

<p style="margin-left:17%; margin-top: 1em">// We'll
monitor these two sockets <br>
void *client = zmq_socket (ctx, ZMQ_DEALER); <br>
assert (client); <br>
void *server = zmq_socket (ctx, ZMQ_DEALER); <br>
assert (server);</p>

<p style="margin-left:17%; margin-top: 1em">// Socket
monitoring only works over inproc:// <br>
int rc = zmq_socket_monitor (client,
&quot;tcp://127.0.0.1:9999&quot;, 0); <br>
assert (rc == &minus;1); <br>
assert (zmq_errno () == EPROTONOSUPPORT);</p>

<p style="margin-left:17%; margin-top: 1em">// Monitor all
events on client and server sockets <br>
rc = zmq_socket_monitor (client,
&quot;inproc://monitor&minus;client&quot;, ZMQ_EVENT_ALL);
<br>
assert (rc == 0); <br>
rc = zmq_socket_monitor (server,
&quot;inproc://monitor&minus;server&quot;, ZMQ_EVENT_ALL);
<br>
assert (rc == 0);</p>

<p style="margin-left:17%; margin-top: 1em">// Create two
sockets for collecting monitor events <br>
void *client_mon = zmq_socket (ctx, ZMQ_PAIR); <br>
assert (client_mon); <br>
void *server_mon = zmq_socket (ctx, ZMQ_PAIR); <br>
assert (server_mon);</p>

<p style="margin-left:17%; margin-top: 1em">// Connect
these to the inproc endpoints so they'll get events <br>
rc = zmq_connect (client_mon,
&quot;inproc://monitor&minus;client&quot;); <br>
assert (rc == 0); <br>
rc = zmq_connect (server_mon,
&quot;inproc://monitor&minus;server&quot;); <br>
assert (rc == 0);</p>

<p style="margin-left:17%; margin-top: 1em">// Now do a
basic ping test <br>
rc = zmq_bind (server, &quot;tcp://127.0.0.1:9998&quot;);
<br>
assert (rc == 0); <br>
rc = zmq_connect (client, &quot;tcp://127.0.0.1:9998&quot;);
<br>
assert (rc == 0); <br>
bounce (client, server);</p>

<p style="margin-left:17%; margin-top: 1em">// Close client
and server <br>
close_zero_linger (client); <br>
close_zero_linger (server);</p>

<p style="margin-left:17%; margin-top: 1em">// Now collect
and check events from both sockets <br>
int event = get_monitor_event (client_mon, NULL, NULL); <br>
if (event == ZMQ_EVENT_CONNECT_DELAYED) <br>
event = get_monitor_event (client_mon, NULL, NULL); <br>
assert (event == ZMQ_EVENT_CONNECTED); <br>
event = get_monitor_event (client_mon, NULL, NULL); <br>
assert (event == ZMQ_EVENT_HANDSHAKE_SUCCEEDED); <br>
event = get_monitor_event (client_mon, NULL, NULL); <br>
assert (event == ZMQ_EVENT_MONITOR_STOPPED);</p>

<p style="margin-left:17%; margin-top: 1em">// This is the
flow of server events <br>
event = get_monitor_event (server_mon, NULL, NULL); <br>
assert (event == ZMQ_EVENT_LISTENING); <br>
event = get_monitor_event (server_mon, NULL, NULL); <br>
assert (event == ZMQ_EVENT_ACCEPTED); <br>
event = get_monitor_event (server_mon, NULL, NULL); <br>
assert (event == ZMQ_EVENT_HANDSHAKE_SUCCEEDED); <br>
event = get_monitor_event (server_mon, NULL, NULL); <br>
assert (event == ZMQ_EVENT_CLOSED); <br>
event = get_monitor_event (server_mon, NULL, NULL); <br>
assert (event == ZMQ_EVENT_MONITOR_STOPPED);</p>

<p style="margin-left:17%; margin-top: 1em">// Close down
the sockets <br>
close_zero_linger (client_mon); <br>
close_zero_linger (server_mon); <br>
zmq_ctx_term (ctx);</p>

<p style="margin-left:17%; margin-top: 1em">return 0 ; <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>zmq</b>(7)</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This page was
written by the 0MQ community. To make a change please read
the 0MQ Contribution Policy at
<b><font color="#0000FF">http://www.zeromq.org/docs:contributing</font></b><font color="#000000">.</font></p>
<hr>
</body>
</html>
