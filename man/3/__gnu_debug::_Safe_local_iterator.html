<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:12 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence &gt;</title>

</head>
<body>
<h1>__gnu_debug::_Safe_local_iterator</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">__gnu_debug::_Safe_local_iterator&lt;
_Iterator, _Sequence &gt; &minus; Safe iterator wrapper.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;safe_local_iterator.h&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
_Iterator, and
<b>__gnu_debug::_Safe_local_iterator_base</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef
_Traits::difference_type <b>difference_type</b> <br>
typedef _Traits::iterator_category <b>iterator_category</b>
<br>
typedef _Iterator <b>iterator_type</b> <br>
typedef _Traits::pointer <b>pointer</b> <br>
typedef _Traits::reference <b>reference</b> <br>
typedef _Traits::value_type <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>_Safe_local_iterator</b> ()
noexcept <b><br>
_Safe_local_iterator</b> (_Iterator __i, const
<b>_Safe_sequence_base</b> *__cont) <br>
Safe iterator construction from an unsafe iterator and its
sequence. <b><br>
_Safe_local_iterator</b> (<b>_Safe_local_iterator</b>
&amp;&amp;__x) noexcept <br>
Move construction. <b><br>
_Safe_local_iterator</b> (const <b>_Safe_local_iterator</b>
&amp;__x) noexcept <br>
Copy construction. <br>
template&lt;typename _MutableIterator &gt;
<b>_Safe_local_iterator</b> (const
<b>_Safe_local_iterator</b>&lt; _MutableIterator, typename
__gnu_cxx::__enable_if&lt; _IsConstant::__value
&amp;&amp;std::__are_same&lt; _MutableIterator,
_OtherIterator &gt;::__value, _Sequence &gt;::__type &gt;
&amp;__x) noexcept <br>
Converting constructor from a mutable iterator to a constant
iterator. <br>
void <b>_M_attach</b> (<b>_Safe_sequence_base</b> *__seq)
<br>
void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b>
*__seq) <br>
bool <b>_M_attached_to</b> (const <b>_Safe_sequence_base</b>
*__seq) const <br>
bool <b>_M_can_compare</b> (const <b>_Safe_iterator_base</b>
&amp;__x) const throw () <br>
bool <b>_M_dereferenceable</b> () const <br>
Is the iterator dereferenceable? <br>
_Distance_traits&lt; _Iterator &gt;::__type
<b>_M_get_distance_to</b> (const <b>_Safe_local_iterator</b>
&amp;__rhs) const <br>
__gnu_cxx::__conditional_type&lt; _IsConstant::__value,
const_Sequence *, _Sequence * &gt;::__type
<b>_M_get_sequence</b> () const <br>
template&lt;typename _Other &gt; bool
<b>_M_in_same_bucket</b> (const
<b>_Safe_local_iterator</b>&lt; _Other, _Sequence &gt;
&amp;__other) const <br>
Is this iterator part of the same bucket as the other one?
<br>
bool <b>_M_incrementable</b> () const <br>
Is the iterator incrementable? <br>
void <b>_M_invalidate</b> () <br>
bool <b>_M_is_begin</b> () const <br>
Is this iterator equal to the sequence&rsquo;s begin(bucket)
iterator? <br>
bool <b>_M_is_end</b> () const <br>
Is this iterator equal to the sequence&rsquo;s end(bucket)
iterator? <br>
void <b>_M_reset</b> () throw () <br>
bool <b>_M_singular</b> () const throw () <br>
void <b>_M_unlink</b> () throw () <br>
bool <b>_M_valid_range</b> (const
<b>_Safe_local_iterator</b> &amp;__rhs, <b>std::pair</b>&lt;
difference_type, <b>_Distance_precision</b> &gt;
&amp;__dist_info) const <br>
bool <b>_M_value_initialized</b> () const <br>
Is the iterator value-initialized? <br>
const _Iterator &amp; <b>base</b> () const noexcept <br>
_Iterator &amp; <b>base</b> () noexcept <br>
Return the underlying iterator. <br>
size_type <b>bucket</b> () const <br>
Return the bucket. <b><br>
operator _Iterator</b> () const <br>
Conversion to underlying non-debug iterator to allow better
interaction with non-debug containers. <br>
reference <b>operator*</b> () const <br>
Iterator dereference. <b><br>
_Safe_local_iterator</b> &amp; <b>operator++</b> () <br>
Iterator preincrement. <b><br>
_Safe_local_iterator operator++</b> (int) <br>
Iterator postincrement. <br>
pointer <b>operator&minus;&gt;</b> () const <br>
Iterator dereference. <b><br>
_Safe_local_iterator</b> &amp; <b>operator=</b>
(<b>_Safe_local_iterator</b> &amp;&amp;__x) noexcept <br>
Move assignment. <b><br>
_Safe_local_iterator</b> &amp; <b>operator=</b> (const
<b>_Safe_local_iterator</b> &amp;__x) <br>
Copy assignment.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Public Member Functions</b></p>

<p style="margin-left:17%;">static constexpr bool
<b>_S_constant</b> () <br>
Determine if this is a constant iterator.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Attributes</b></p>

<p style="margin-left:17%;"><b>_Safe_iterator_base</b> *
<b>_M_next <br>
_Safe_iterator_base</b> * <b>_M_prior <br>
_Safe_sequence_base</b> * <b>_M_sequence</b> <br>
unsigned int <b>_M_version</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;">void <b>_M_attach</b>
(<b>_Safe_sequence_base</b> *__seq, bool __constant) <br>
void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b>
*__seq, bool __constant) throw () <br>
void <b>_M_detach</b> () <br>
void <b>_M_detach_single</b> () throw () <b><br>
_Safe_unordered_container_base</b> * <b>_M_get_container</b>
() const noexcept <br>
__gnu_cxx::__mutex &amp; <b>_M_get_mutex</b> () throw ()</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">bool <b>operator!=</b> (const
<b>_Self</b> &amp;__lhs, const <b>_OtherSelf</b> &amp;__rhs)
noexcept <br>
bool <b>operator!=</b> (const <b>_Self</b> &amp;__lhs, const
<b>_Self</b> &amp;__rhs) noexcept <br>
bool <b>operator==</b> (const <b>_Self</b> &amp;__lhs, const
<b>_OtherSelf</b> &amp;__rhs) noexcept <br>
bool <b>operator==</b> (const <b>_Self</b> &amp;__lhs, const
<b>_Self</b> &amp;__rhs) noexcept</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator, typename _Sequence&gt;</b> <br>
class __gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;&quot;Safe iterator wrapper.</p>

<p style="margin-left:11%; margin-top: 1em">The class
template _Safe_local_iterator is a wrapper around an
iterator that tracks the iterator&rsquo;s movement among
sequences and checks that operations performed on the
&rsquo;safe&rsquo; iterator are legal. In additional to the
basic iterator operations (which are validated, and then
passed to the underlying iterator), _Safe_local_iterator has
member functions for iterator invalidation,
attaching/detaching the iterator from sequences, and
querying the iterator&rsquo;s state.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt;
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_Safe_local_iterator ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <b><br>
Postcondition</b></p>

<p style="margin-left:17%;">the iterator is singular and
unattached</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt;
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_Safe_local_iterator (_Iterator __i, const
_Safe_sequence_base * __cont)</b> <tt>[inline]</tt> <br>
Safe iterator construction from an unsafe iterator and its
sequence.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;"><tt>seq</tt> is not NULL</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">this is not singular</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt;
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_Safe_local_iterator (const _Safe_local_iterator&lt;
_Iterator, _Sequence &gt; &amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Copy construction.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt;
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_Safe_local_iterator (_Safe_local_iterator&lt;
_Iterator, _Sequence &gt; &amp;&amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Move construction.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">__x is singular and
unattached</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_local_iterator_base::_M_detach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; template&lt;typename
_MutableIterator &gt; __gnu_debug::_Safe_local_iterator&lt;
_Iterator, _Sequence &gt;::_Safe_local_iterator (const
_Safe_local_iterator&lt; _MutableIterator, typename
__gnu_cxx::__enable_if&lt; _IsConstant::__value
&amp;&amp;std::__are_same&lt; _MutableIterator,
_OtherIterator &gt;::__value, _Sequence &gt;::__type &gt;
&amp; __x)</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Converting constructor from a mutable iterator to a constant
iterator.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; void
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_attach (_Safe_sequence_base * __seq)</b>
<tt>[inline]</tt> <br>
Attach iterator to the given sequence.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator_base::_M_attach()</b>,
and <b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_S_constant()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_local_iterator_base::_M_attach
(_Safe_sequence_base * __seq, bool __constant)</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
Attaches this iterator to the given container, detaching it
from whatever container it was attached to originally. If
the new container is the NULL pointer, the iterator is left
unattached.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()</b>,
and <b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; void
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_attach_single (_Safe_sequence_base * __seq)</b>
<tt>[inline]</tt> <br>
Likewise, but not thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator_base::_M_attach_single()</b>,
and <b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_S_constant()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_local_iterator_base::_M_attach_single
(_Safe_sequence_base * __seq, bool __constant)</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
Likewise, but not thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach_single()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_attached_to (const
_Safe_sequence_base * __seq) const</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Determines if we are attached to the given sequence.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_can_compare (const
_Safe_iterator_base &amp; __x) const</b>
<tt>[inherited]</tt> <br>
Can we compare this iterator to the given iterator
<tt>__x</tt>? Returns true if both iterators are nonsingular
and reference the same sequence.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_dereferenceable () const</b> <tt>[inline]</tt> <br>
Is the iterator dereferenceable?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_is_end()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator*()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator&minus;&gt;()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_local_iterator_base::_M_detach ()</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
Detach the iterator for whatever container it is attached
to, if any.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_local_iterator_base::_M_detach_single
()</b> <tt>[protected]</tt><b>,</b> <tt>[inherited]</tt>
<br>
Likewise, but not thread-safe.</p>


<p style="margin-left:11%; margin-top: 1em"><b>__gnu_cxx::__mutex
&amp; __gnu_debug::_Safe_iterator_base::_M_get_mutex ()</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
For use in _Safe_iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator++()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator++()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; template&lt;typename
_Other &gt; bool __gnu_debug::_Safe_local_iterator&lt;
_Iterator, _Sequence &gt;::_M_in_same_bucket (const
_Safe_local_iterator&lt; _Other, _Sequence &gt; &amp;
__other) const</b> <tt>[inline]</tt> <br>
Is this iterator part of the same bucket as the other
one?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::bucket()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_incrementable () const</b> <tt>[inline]</tt> <br>
Is the iterator incrementable?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_is_end()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator++()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_invalidate ()</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Invalidate the iterator, making it singular.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_is_begin () const</b> <tt>[inline]</tt> <br>
Is this iterator equal to the sequence&rsquo;s begin(bucket)
iterator?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::bucket()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_is_end () const</b> <tt>[inline]</tt> <br>
Is this iterator equal to the sequence&rsquo;s end(bucket)
iterator?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::bucket()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_dereferenceable()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_incrementable()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_reset ()</b>
<tt>[inherited]</tt> <br>
Reset all member variables</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_singular () const</b>
<tt>[inherited]</tt> <br>
Is this iterator singular?</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>,
<b>__gnu_debug::__check_singular_aux()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_dereferenceable()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_dereferenceable()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_incrementable()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_incrementable()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_unlink ()</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Unlink itself</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_next</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_prior</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; bool
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_M_value_initialized () const</b> <tt>[inline]</tt>
<br>
Is the iterator value-initialized?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; static constexpr bool
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::_S_constant ()</b> <tt>[inline]</tt><b>,</b>
<tt>[static]</tt><b>,</b> <tt>[constexpr]</tt> <br>
Determine if this is a constant iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach_single()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; _Iterator &amp;
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::base ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Return the underlying iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_is_begin()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_is_end()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::bucket()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator*()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator++()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator&minus;&gt;()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; size_type
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::bucket () const</b> <tt>[inline]</tt> <br>
Return the bucket.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_in_same_bucket()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_is_begin()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_is_end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt;
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::operator _Iterator () const</b> <tt>[inline]</tt> <br>
Conversion to underlying non-debug iterator to allow better
interaction with non-debug containers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; reference
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::operator* () const</b> <tt>[inline]</tt> <br>
Iterator dereference.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">iterator is dereferenceable</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_dereferenceable()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; _Safe_local_iterator
&amp; __gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator++ ()</b> <tt>[inline]</tt> <br>
Iterator preincrement.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">iterator is incrementable</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_incrementable()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; _Safe_local_iterator
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::operator++ (int)</b> <tt>[inline]</tt> <br>
Iterator postincrement.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">iterator is incrementable</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_incrementable()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; pointer
__gnu_debug::_Safe_local_iterator&lt; _Iterator, _Sequence
&gt;::operator&minus;&gt; () const</b> <tt>[inline]</tt>
<br>
Iterator dereference.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">iterator is dereferenceable</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_dereferenceable()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; _Safe_local_iterator
&amp; __gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator= (_Safe_local_iterator&lt;
_Iterator, _Sequence &gt; &amp;&amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Move assignment.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">__x is singular and
unattached</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_local_iterator_base::_M_detach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>,
<b>__gnu_debug::_Safe_sequence_base::_M_version</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence &gt; _Safe_local_iterator
&amp; __gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator= (const _Safe_local_iterator&lt;
_Iterator, _Sequence &gt; &amp; __x)</b> <tt>[inline]</tt>
<br>
Copy assignment.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_local_iterator_base::_M_detach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>,
<b>__gnu_debug::_Safe_sequence_base::_M_version</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::base()</b>.</p>

<h2>Member Data Documentation
<a name="Member Data Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>_Safe_iterator_base*
__gnu_debug::_Safe_iterator_base::_M_next</b>
<tt>[inherited]</tt> <br>
Pointer to the next iterator in the sequence&rsquo;s list of
iterators. Only valid when _M_sequence != NULL.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_sequence&lt; _SafeSequence
&gt;::_M_invalidate_if()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>_Safe_iterator_base*
__gnu_debug::_Safe_iterator_base::_M_prior</b>
<tt>[inherited]</tt> <br>
Pointer to the previous iterator in the sequence&rsquo;s
list of iterators. Only valid when _M_sequence != NULL.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_sequence&lt; _SafeSequence
&gt;::_M_invalidate_if()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>_Safe_sequence_base*
__gnu_debug::_Safe_iterator_base::_M_sequence</b>
<tt>[inherited]</tt> <br>
The sequence this iterator references; may be NULL to
indicate a singular iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>,
<b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>,
<b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_attached_to()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>unsigned int
__gnu_debug::_Safe_iterator_base::_M_version</b>
<tt>[inherited]</tt> <br>
The version number of this iterator. The sentinel value 0 is
used to indicate an invalidated iterator (i.e., one that is
singular because of an operation on the container). This
version number must equal the version number in the sequence
referenced by _M_sequence for the iterator to be
non-singular.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator_base::_M_invalidate()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
