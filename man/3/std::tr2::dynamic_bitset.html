<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:14 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;</title>

</head>
<body>
<h1>std::tr2::dynamic_bitset</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::tr2::dynamic_bitset&lt;
_WordT, _Alloc &gt; &minus; The dynamic_bitset class
represents a sequence of bits.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Inherits
<b>std::tr2::__dynamic_bitset_base&lt; _WordT, _Alloc
&gt;</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">class <b>reference</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef
<b>__dynamic_bitset_base</b>&lt; _WordT, _Alloc &gt;
<b>_Base</b> <br>
typedef _Alloc <b>allocator_type</b> <br>
typedef _WordT <b>block_type</b> <br>
typedef bool <b>const_reference</b> <br>
typedef size_t <b>size_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>dynamic_bitset</b>
()=default <br>
All bits set to zero. <b><br>
dynamic_bitset</b> (const allocator_type &amp;__alloc) <br>
All bits set to zero. <b><br>
dynamic_bitset</b> (const char *__str, const allocator_type
&amp;__alloc=allocator_type()) <br>
Construct from a string. <b><br>
dynamic_bitset</b> (const <b>dynamic_bitset</b>
&amp;)=default <br>
Copy constructor. <br>
template&lt;typename _CharT , typename _Traits , typename
_Alloc1 &gt; <b>dynamic_bitset</b> (const
<b>std::basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt;
&amp;__str, typename <b>basic_string</b>&lt; _CharT,
_Traits, _Alloc1 &gt;::size_type __pos=0, typename
<b>basic_string</b>&lt; _CharT, _Traits, _Alloc1
&gt;::size_type __n=<b>std::basic_string</b>&lt; _CharT,
_Traits, _Alloc1 &gt;::npos, _CharT
__zero=_CharT(&rsquo;0&rsquo;), _CharT
__one=_CharT(&rsquo;1&rsquo;), const allocator_type
&amp;__alloc=allocator_type()) <br>
Use a subset of a string. <b><br>
dynamic_bitset</b> (<b>dynamic_bitset</b> &amp;&amp;__b)
noexcept <br>
Move constructor. <b><br>
dynamic_bitset</b> (<b>initializer_list</b>&lt; block_type
&gt; __il, const allocator_type
&amp;__alloc=allocator_type()) <b><br>
dynamic_bitset</b> (size_type __nbits, unsigned long long
__val=0ULL, const allocator_type
&amp;__alloc=allocator_type()) <br>
Initial bits bitwise-copied from a single word (others set
to zero). <br>
template&lt;typename _Traits = std::char_traits&lt;char&gt;,
typename _CharT = typename _Traits::char_type&gt; void
<b>_M_copy_from_ptr</b> (const _CharT *, size_t, size_t,
size_t, _CharT __zero=_CharT(&rsquo;0&rsquo;), _CharT
__one=_CharT(&rsquo;1&rsquo;)) <br>
template&lt;typename _CharT , typename _Traits , typename
_Alloc1 &gt; void <b>_M_copy_from_string</b> (const
<b>basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt;
&amp;__str, size_t __pos, size_t __n, _CharT
__zero=_CharT(&rsquo;0&rsquo;), _CharT
__one=_CharT(&rsquo;1&rsquo;)) <br>
template&lt;typename _CharT , typename _Traits , typename
_Alloc1 &gt; void <b>_M_copy_to_string</b>
(<b>std::basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt;
&amp;__str, _CharT __zero=_CharT(&rsquo;0&rsquo;), _CharT
__one=_CharT(&rsquo;1&rsquo;)) const <br>
bool <b>all</b> () const <br>
Tests whether all the bits are on. <br>
bool <b>any</b> () const <br>
Tests whether any of the bits are on. <br>
template&lt;typename _BlockInputIterator &gt; void
<b>append</b> (_BlockInputIterator __first,
_BlockInputIterator __last) <br>
Append an iterator range of blocks. <br>
void <b>append</b> (block_type __block) <br>
Append a block. <br>
void <b>append</b> (<b>initializer_list</b>&lt; block_type
&gt; __il) <br>
void <b>clear</b> () <br>
Clear the bitset. <br>
size_type <b>count</b> () const noexcept <br>
Returns the number of bits which are set. <br>
bool <b>empty</b> () const noexcept <br>
Returns true if the dynamic_bitset is empty. <br>
size_type <b>find_first</b> () const <br>
Finds the index of the first &rsquo;on&rsquo; bit. <br>
size_type <b>find_next</b> (size_t __prev) const <br>
Finds the index of the next &rsquo;on&rsquo; bit after prev.
<b><br>
dynamic_bitset</b> &amp; <b>flip</b> () <br>
Toggles every bit to its opposite value. <b><br>
dynamic_bitset</b> &amp; <b>flip</b> (size_type __pos) <br>
Toggles a given bit to its opposite value. <br>
allocator_type <b>get_allocator</b> () const noexcept <br>
Return the allocator for the bitset. <br>
bool <b>is_proper_subset_of</b> (const <b>dynamic_bitset</b>
&amp;__b) const <br>
bool <b>is_subset_of</b> (const <b>dynamic_bitset</b>
&amp;__b) const <br>
constexpr size_type <b>max_size</b> () noexcept <br>
Returns the maximum size of a dynamic_bitset object having
the same type as *this. The real answer is max() *
bits_per_block but is likely to overflow. <br>
bool <b>none</b> () const <br>
Tests whether any of the bits are on. <br>
size_type <b>num_blocks</b> () const noexcept <br>
Returns the total number of blocks. <b><br>
dynamic_bitset</b> &amp; <b>operator=</b> (const
<b>dynamic_bitset</b> &amp;)=default <br>
Copy assignment operator. <b><br>
dynamic_bitset</b> &amp; <b>operator=</b>
(<b>dynamic_bitset</b> &amp;&amp;__b)
noexcept(<b>std::is_nothrow_move_assignable</b>&lt;
<b>_Base</b> &gt;::value) <br>
Move assignment operator. <b><br>
dynamic_bitset operator~</b> () const <br>
See the no-argument flip(). <br>
void <b>push_back</b> (bool __bit) <br>
Push a bit onto the high end of the bitset. <b><br>
dynamic_bitset</b> &amp; <b>reset</b> () <br>
Sets every bit to false. <b><br>
dynamic_bitset</b> &amp; <b>reset</b> (size_type __pos) <br>
Sets a given bit to false. <br>
void <b>resize</b> (size_type __nbits, bool __value=false)
<br>
Resize the bitset. <b><br>
dynamic_bitset</b> &amp; <b>set</b> () <br>
Sets every bit to true. <b><br>
dynamic_bitset</b> &amp; <b>set</b> (size_type __pos, bool
__val=true) <br>
Sets a given bit to a particular value. <br>
size_type <b>size</b> () const noexcept <br>
Returns the total number of bits. <br>
void <b>swap</b> (<b>dynamic_bitset</b> &amp;__b) noexcept
<br>
Swap with another bitset. <br>
bool <b>test</b> (size_type __pos) const <br>
Tests the value of a bit. <br>
template&lt;typename _CharT = char, typename _Traits =
std::char_traits&lt;_CharT&gt;, typename _Alloc1 =
std::allocator&lt;_CharT&gt;&gt;
<b>std::basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt;
<b>to_string</b> (_CharT __zero=_CharT(&rsquo;0&rsquo;),
_CharT __one=_CharT(&rsquo;1&rsquo;)) const <br>
Returns a character interpretation of the dynamic_bitset.
<br>
unsigned long long <b>to_ullong</b> () const <br>
Returns a numerical interpretation of the dynamic_bitset.
<br>
unsigned long <b>to_ulong</b> () const <br>
Returns a numerical interpretation of the
dynamic_bitset.</p>


<p style="margin-left:23%; margin-top: 1em"><b>dynamic_bitset</b>
&amp; <b>operator&amp;=</b> (const <b>dynamic_bitset</b>
&amp;__rhs) <br>
Operations on dynamic_bitsets. <b><br>
dynamic_bitset</b> &amp; <b>operator&amp;=</b>
(<b>dynamic_bitset</b> &amp;&amp;__rhs) <br>
Operations on dynamic_bitsets. <b><br>
dynamic_bitset</b> &amp; <b>operator|=</b> (const
<b>dynamic_bitset</b> &amp;__rhs) <br>
Operations on dynamic_bitsets. <b><br>
dynamic_bitset</b> &amp; <b>operator^=</b> (const
<b>dynamic_bitset</b> &amp;__rhs) <br>
Operations on dynamic_bitsets. <b><br>
dynamic_bitset</b> &amp; <b>operator&minus;=</b> (const
<b>dynamic_bitset</b> &amp;__rhs) <br>
Operations on dynamic_bitsets.</p>


<p style="margin-left:23%; margin-top: 1em"><b>dynamic_bitset</b>
&amp; <b>operator&lt;&lt;=</b> (size_type __pos) <br>
Operations on dynamic_bitsets. <b><br>
dynamic_bitset</b> &amp; <b>operator&gt;&gt;=</b> (size_type
__pos) <br>
Operations on dynamic_bitsets.</p>

<p style="margin-left:23%; margin-top: 1em"><b>reference
operator[]</b> (size_type __pos) <br>
Array-indexing support. <br>
const_reference <b>operator[]</b> (size_type __pos) const
<br>
Array-indexing support.</p>


<p style="margin-left:23%; margin-top: 1em"><b>dynamic_bitset
operator&lt;&lt;</b> (size_type __pos) const <br>
Self-explanatory. <b><br>
dynamic_bitset operator&gt;&gt;</b> (size_type __pos) const
<br>
Self-explanatory.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Public Attributes</b></p>

<p style="margin-left:17%;">static const size_type
<b>bits_per_block</b> <br>
static const size_type <b>npos</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">bool <b>operator&lt;</b> (const
<b>dynamic_bitset</b> &amp;__lhs, const
<b>dynamic_bitset</b> &amp;__rhs) noexcept <br>
bool <b>operator==</b> (const <b>dynamic_bitset</b>
&amp;__lhs, const <b>dynamic_bitset</b> &amp;__rhs) noexcept
<br>
class <b>reference</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt;</b> <br>
class std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;&quot;The dynamic_bitset class represents a sequence of
bits.</p>

<p style="margin-left:11%; margin-top: 1em">See N2050,
Proposal to Add a Dynamically Sizeable Bitset to the
Standard Library.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf</p>

<p style="margin-left:11%; margin-top: 1em">In the general
unoptimized case, storage is allocated in word-sized blocks.
Let B be the number of bits in a word, then (Nb+(B-1))/B
words will be used for storage. B - NbB bits are unused.
(They are the high-order bits in the highest word.) It is a
class invariant that those unused bits are always zero.</p>

<p style="margin-left:11%; margin-top: 1em">If you think of
dynamic_bitset as &rsquo;a simple array of bits,&rsquo; be
aware that your mental picture is reversed: a dynamic_bitset
behaves the same way as bits in integers do, with the bit at
index 0 in the &rsquo;least significant / right-hand&rsquo;
position, and the bit at index Nb-1 in the &rsquo;most
significant / left-hand&rsquo; position. Thus, unlike other
containers, a dynamic_bitset&rsquo;s index &rsquo;counts
from right to left,&rsquo; to put it very loosely.</p>

<p style="margin-left:11%; margin-top: 1em">This behavior
is preserved when translating to and from strings. For
example, the first line of the following program probably
prints &rsquo;b(&rsquo;a&rsquo;) is 0001100001&rsquo; on a
modern ASCII system.</p>

<p style="margin-left:11%; margin-top: 1em">#include
&lt;dynamic_bitset&gt; <br>
#include &lt;iostream&gt; <br>
#include &lt;sstream&gt;</p>

<p style="margin-left:11%; margin-top: 1em">using namespace
std;</p>

<p style="margin-left:11%; margin-top: 1em">int main() <br>
{ <br>
long a = &rsquo;a&rsquo;; <br>
dynamic_bitset&lt;&gt; b(a);</p>

<p style="margin-left:11%; margin-top: 1em">cout &lt;&lt;
&quot;b(&rsquo;a&rsquo;) is &quot; &lt;&lt; b &lt;&lt;
endl;</p>

<p style="margin-left:11%; margin-top: 1em">ostringstream
s; <br>
s &lt;&lt; b; <br>
string str = s.str(); <br>
cout &lt;&lt; &quot;index 3 in the string is &quot; &lt;&lt;
str[3] &lt;&lt; &quot; but\n&quot; <br>
&lt;&lt; &quot;index 3 in the bitset is &quot; &lt;&lt; b[3]
&lt;&lt; endl; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Most of the
actual code isn&rsquo;t contained in dynamic_bitset&lt;&gt;
itself, but in the base class __dynamic_bitset_base. The
base class works with whole words, not with individual bits.
This allows us to specialize __dynamic_bitset_base for the
important special case where the dynamic_bitset is only a
single word.</p>

<p style="margin-left:11%; margin-top: 1em">Extra confusion
can result due to the fact that the storage for
__dynamic_bitset_base <i>is</i> a vector, and is indexed as
such. This is carefully encapsulated.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset ()</b> <tt>[default]</tt> <br>
All bits set to zero.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&lt;&lt;()</b>, and
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&gt;&gt;()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset (const allocator_type &amp;
__alloc)</b> <tt>[inline]</tt><b>,</b> <tt>[explicit]</tt>
<br>
All bits set to zero.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset (size_type __nbits, unsigned long long
__val =</b> <tt>0ULL</tt><b>, const allocator_type &amp;
__alloc =</b> <tt>allocator_type()</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt> <br>
Initial bits bitwise-copied from a single word (others set
to zero).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; template&lt;typename _CharT
, typename _Traits , typename _Alloc1 &gt;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset (const std::basic_string&lt; _CharT,
_Traits, _Alloc1 &gt; &amp; __str, typename basic_string&lt;
_CharT, _Traits, _Alloc1 &gt;::size_type __pos =</b>
<tt>0</tt><b>, typename basic_string&lt; _CharT, _Traits,
_Alloc1 &gt;::size_type __n =
std::basic_string</b><tt>&lt;_CharT, _Traits,
_Alloc1&gt;::npos</tt><b>, _CharT __zero =</b>
<tt>_CharT(&rsquo;0&rsquo;)</tt><b>, _CharT __one =</b>
<tt>_CharT(&rsquo;1&rsquo;)</tt><b>, const allocator_type
&amp; __alloc =</b> <tt>allocator_type()</tt><b>)</b>
<tt>[inline]</tt><b>,</b> <tt>[explicit]</tt> <br>
Use a subset of a string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__str</i> A string of
&rsquo;0&rsquo; and &rsquo;1&rsquo; characters. <i><br>
__pos</i> Index of the first character in <tt>__str</tt> to
use. <i><br>
__n</i> The number of characters to copy. <i><br>
__zero</i> The character to use for unset bits. <i><br>
__one</i> The character to use for set bits. <i><br>
__alloc</i> An allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<tt>__pos</tt> is bigger the size of <tt>__str</tt>. <i><br>
std::invalid_argument</i> If a character appears in the
string which is neither &rsquo;0&rsquo; nor
&rsquo;1&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::resize()</b>, and <b>std::basic_string&lt; _CharT,
_Traits, _Alloc &gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset (const char * __str, const
allocator_type &amp; __alloc =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
Construct from a string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__str</i> A string of
&rsquo;0&rsquo; and &rsquo;1&rsquo; characters. <i><br>
__alloc</i> An allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::invalid_argument</i> If
a character appears in the string which is neither
&rsquo;0&rsquo; nor &rsquo;1&rsquo;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset (const dynamic_bitset&lt; _WordT,
_Alloc &gt; &amp;)</b> <tt>[default]</tt> <br>
Copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset (dynamic_bitset&lt; _WordT, _Alloc &gt;
&amp;&amp; __b)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Move constructor.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; bool
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::all ()
const</b> <tt>[inline]</tt> <br>
Tests whether all the bits are on.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if all the bits are
set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; bool
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::any ()
const</b> <tt>[inline]</tt> <br>
Tests whether any of the bits are on.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if at least one bit is
set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; template&lt;typename
_BlockInputIterator &gt; void std::tr2::dynamic_bitset&lt;
_WordT, _Alloc &gt;::append (_BlockInputIterator __first,
_BlockInputIterator __last)</b> <tt>[inline]</tt> <br>
Append an iterator range of blocks.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::append()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; void
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::append
(block_type __block)</b> <tt>[inline]</tt> <br>
Append a block.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::append()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; void
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::clear
()</b> <tt>[inline]</tt> <br>
Clear the bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; size_type
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::count ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the number of bits which are set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; bool
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::empty ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns true if the dynamic_bitset is empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; size_type
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::find_first
() const</b> <tt>[inline]</tt> <br>
Finds the index of the first &rsquo;on&rsquo; bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The index of the first bit set,
or size() if not found.</p>

<p style="margin-left:11%; margin-top: 1em"><b>See
also</b></p>

<p style="margin-left:17%;">find_next</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; size_type
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::find_next
(size_t __prev) const</b> <tt>[inline]</tt> <br>
Finds the index of the next &rsquo;on&rsquo; bit after
prev.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The index of the next bit set,
or size() if not found.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__prev</i> Where to start
searching.</p>

<p style="margin-left:11%; margin-top: 1em"><b>See
also</b></p>

<p style="margin-left:17%;">find_first</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::flip
()</b> <tt>[inline]</tt> <br>
Toggles every bit to its opposite value.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator~()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::flip
(size_type __pos)</b> <tt>[inline]</tt> <br>
Toggles a given bit to its opposite value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> The index of the
bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__pos</i> is bigger the size of the set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; allocator_type
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::get_allocator () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Return the allocator for the bitset.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; constexpr size_type
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::max_size
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the maximum size of a dynamic_bitset object having
the same type as *this. The real answer is max() *
bits_per_block but is likely to overflow.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::numeric_limits&lt; _Tp &gt;::max()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; bool
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::none ()
const</b> <tt>[inline]</tt> <br>
Tests whether any of the bits are on.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if none of the bits are
set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; size_type
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::num_blocks
() const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Returns the total number of blocks.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&amp;= (const dynamic_bitset&lt; _WordT,
_Alloc &gt; &amp; __rhs)</b> <tt>[inline]</tt> <br>
Operations on dynamic_bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__rhs</i> A same-sized
dynamic_bitset.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&amp;= (dynamic_bitset&lt; _WordT, _Alloc &gt;
&amp;&amp; __rhs)</b> <tt>[inline]</tt> <br>
Operations on dynamic_bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__rhs</i> A same-sized
dynamic_bitset.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&minus;= (const dynamic_bitset&lt; _WordT,
_Alloc &gt; &amp; __rhs)</b> <tt>[inline]</tt> <br>
Operations on dynamic_bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__rhs</i> A same-sized
dynamic_bitset.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&lt;&lt; (size_type __pos) const</b>
<tt>[inline]</tt> <br>
Self-explanatory.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&lt;&lt;= (size_type __pos)</b>
<tt>[inline]</tt> <br>
Operations on dynamic_bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> The number of
places to shift.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::operator=
(const dynamic_bitset&lt; _WordT, _Alloc &gt; &amp;)</b>
<tt>[default]</tt> <br>
Copy assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::operator=
(dynamic_bitset&lt; _WordT, _Alloc &gt; &amp;&amp; __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Move assignment operator.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::get_allocator()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&gt;&gt; (size_type __pos) const</b>
<tt>[inline]</tt> <br>
Self-explanatory.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::operator&gt;&gt;= (size_type __pos)</b>
<tt>[inline]</tt> <br>
Operations on dynamic_bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> The number of
places to shift.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; reference
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::operator[]
(size_type __pos)</b> <tt>[inline]</tt> <br>
Array-indexing support.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> Index into the
dynamic_bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A bool for a &rsquo;const
dynamic_bitset&rsquo;. For non-const bitsets, an instance of
the reference proxy class.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">These operators do no range
checking and throw no exceptions, as required by DR 11 to
the standard.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; const_reference
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::operator[]
(size_type __pos) const</b> <tt>[inline]</tt> <br>
Array-indexing support.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> Index into the
dynamic_bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A bool for a &rsquo;const
dynamic_bitset&rsquo;. For non-const bitsets, an instance of
the reference proxy class.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">These operators do no range
checking and throw no exceptions, as required by DR 11 to
the standard.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::operator^=
(const dynamic_bitset&lt; _WordT, _Alloc &gt; &amp;
__rhs)</b> <tt>[inline]</tt> <br>
Operations on dynamic_bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__rhs</i> A same-sized
dynamic_bitset.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::operator|=
(const dynamic_bitset&lt; _WordT, _Alloc &gt; &amp;
__rhs)</b> <tt>[inline]</tt> <br>
Operations on dynamic_bitsets.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__rhs</i> A same-sized
dynamic_bitset.</p>

<p style="margin-left:11%; margin-top: 1em">These should be
self-explanatory.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::operator~
() const</b> <tt>[inline]</tt> <br>
See the no-argument flip().</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::flip()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; void
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::push_back
(bool __bit)</b> <tt>[inline]</tt> <br>
Push a bit onto the high end of the bitset.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::size()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::reset
()</b> <tt>[inline]</tt> <br>
Sets every bit to false.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::reset
(size_type __pos)</b> <tt>[inline]</tt> <br>
Sets a given bit to false.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> The index of the
bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__pos</i> is bigger the size of the set.</p>

<p style="margin-left:11%; margin-top: 1em">Same as writing
<tt>set(__pos, false)</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; void
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::resize
(size_type __nbits, bool __value =</b>
<tt>false</tt><b>)</b> <tt>[inline]</tt> <br>
Resize the bitset.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::dynamic_bitset()</b>, and
<b>std::tr2::operator&gt;&gt;()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::set ()</b>
<tt>[inline]</tt> <br>
Sets every bit to true.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; dynamic_bitset &amp;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::set
(size_type __pos, bool __val =</b> <tt>true</tt><b>)</b>
<tt>[inline]</tt> <br>
Sets a given bit to a particular value.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> The index of the
bit. <i><br>
__val</i> Either true or false, defaults to true.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__pos</i> is bigger the size of the set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; size_type
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::size ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns the total number of bits.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::tr2::operator&gt;&gt;()</b>, and
<b>std::tr2::dynamic_bitset&lt; _WordT, _Alloc
&gt;::push_back()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; void
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::swap
(dynamic_bitset&lt; _WordT, _Alloc &gt; &amp; __b)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Swap with another bitset.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::swap()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; bool
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::test
(size_type __pos) const</b> <tt>[inline]</tt> <br>
Tests the value of a bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> The index of a
bit.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The value at <i>__pos</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If
<i>__pos</i> is bigger the size of the set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; template&lt;typename _CharT
= char, typename _Traits = std::char_traits&lt;_CharT&gt;,
typename _Alloc1 = std::allocator&lt;_CharT&gt;&gt;
std::basic_string&lt; _CharT, _Traits, _Alloc1 &gt;
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::to_string
(_CharT __zero =</b> <tt>_CharT(&rsquo;0&rsquo;)</tt><b>,
_CharT __one =</b> <tt>_CharT(&rsquo;1&rsquo;)</tt><b>)
const</b> <tt>[inline]</tt> <br>
Returns a character interpretation of the
dynamic_bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The string equivalent of the
bits.</p>

<p style="margin-left:11%; margin-top: 1em">Note the
ordering of the bits: decreasing character positions
correspond to increasing bit positions (see the main class
notes for an example).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; unsigned long long
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::to_ullong
() const</b> <tt>[inline]</tt> <br>
Returns a numerical interpretation of the
dynamic_bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The integral equivalent of the
bits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::overflow_error</i> If
there are too many bits to be represented in an <tt>unsigned
long</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_WordT = unsigned long long, typename _Alloc =
std::allocator&lt;_WordT&gt;&gt; unsigned long
std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::to_ulong
() const</b> <tt>[inline]</tt> <br>
Returns a numerical interpretation of the
dynamic_bitset.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The integral equivalent of the
bits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::overflow_error</i> If
there are too many bits to be represented in an <tt>unsigned
long</tt>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
