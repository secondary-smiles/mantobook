<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:18 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Term::ANSIColor</title>

</head>
<body>
<h1>Term::ANSIColor</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Term::ANSIColor
&minus; Color screen output using ANSI escape sequences</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use
Term::ANSIColor; <br>
print color('bold blue'); <br>
print &quot;This text is bold blue.\n&quot;; <br>
print color('reset'); <br>
print &quot;This text is normal.\n&quot;; <br>
print colored(&quot;Yellow on magenta.&quot;, 'yellow
on_magenta'), &quot;\n&quot;; <br>
print &quot;This text is normal.\n&quot;; <br>
print colored(['yellow on_magenta'], 'Yellow on magenta.',
&quot;\n&quot;); <br>
print colored(['red on_bright_yellow'], 'Red on bright
yellow.', &quot;\n&quot;); <br>
print colored(['bright_red on_black'], 'Bright red on
black.', &quot;\n&quot;); <br>
print &quot;\n&quot;; <br>
# Map escape sequences back to color names. <br>
use Term::ANSIColor 1.04 qw(uncolor); <br>
my @names = uncolor('01;31'); <br>
print join(q{ }, @names), &quot;\n&quot;; <br>
# Strip all color escape sequences. <br>
use Term::ANSIColor 2.01 qw(colorstrip); <br>
print colorstrip(&quot;\e[1mThis is bold\e[0m&quot;),
&quot;\n&quot;; <br>
# Determine whether a color is valid. <br>
use Term::ANSIColor 2.02 qw(colorvalid); <br>
my $valid = colorvalid('blue bold', 'on_magenta'); <br>
print &quot;Color string is &quot;, $valid ?
&quot;valid\n&quot; : &quot;invalid\n&quot;; <br>
# Create new aliases for colors. <br>
use Term::ANSIColor 4.00 qw(coloralias); <br>
coloralias('alert', 'red'); <br>
print &quot;Alert is &quot;, coloralias('alert'),
&quot;\n&quot;; <br>
print colored(&quot;This is in red.&quot;, 'alert'),
&quot;\n&quot;; <br>
use Term::ANSIColor qw(:constants); <br>
print BOLD, BLUE, &quot;This text is in bold blue.\n&quot;,
RESET; <br>
use Term::ANSIColor qw(:constants); <br>
{ <br>
local $Term::ANSIColor::AUTORESET = 1; <br>
print BOLD BLUE &quot;This text is in bold blue.\n&quot;;
<br>
print &quot;This text is normal.\n&quot;; <br>
} <br>
use Term::ANSIColor 2.00 qw(:pushpop); <br>
print PUSHCOLOR RED ON_GREEN &quot;This text is red on
green.\n&quot;; <br>
print PUSHCOLOR BRIGHT_BLUE &quot;This text is bright blue
on green.\n&quot;; <br>
print RESET BRIGHT_BLUE &quot;This text is just bright
blue.\n&quot;; <br>
print POPCOLOR &quot;Back to red on green.\n&quot;; <br>
print LOCALCOLOR GREEN ON_BLUE &quot;This text is green on
blue.\n&quot;; <br>
print &quot;This text is red on green.\n&quot;; <br>
{ <br>
local $Term::ANSIColor::AUTOLOCAL = 1; <br>
print ON_BLUE &quot;This text is red on blue.\n&quot;; <br>
print &quot;This text is red on green.\n&quot;; <br>
} <br>
print POPCOLOR &quot;Back to whatever we started
as.\n&quot;;</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module has
two interfaces, one through <b>color()</b> and
<b>colored()</b> and the other through constants. It also
offers the utility functions <b>uncolor()</b>,
<b>colorstrip()</b>, <b>colorvalid()</b>, and
<b>coloralias()</b>, which have to be explicitly imported to
be used (see &quot; <small>SYNOPSIS&quot;</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">If you are
using Term::ANSIColor in a console command, consider
supporting the <small>CLICOLOR</small> standard. See
&quot;Supporting <small>CLICOLOR&quot;</small> for more
information.</p>

<p style="margin-left:11%; margin-top: 1em">See &quot;
<small>COMPATIBILITY&quot;</small> for the versions of
Term::ANSIColor that introduced particular features and the
versions of Perl that included them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Supported
Colors</b> <br>
Terminal emulators that support color divide into four
types: ones that support only eight colors, ones that
support sixteen, ones that support 256, and ones that
support 24&minus;bit color. This module provides the
<small>ANSI</small> escape codes for all of them. These
colors are referred to as <small>ANSI</small> colors 0
through 7 (normal), 8 through 15 (16&minus;color), 16
through 255 (256&minus;color), and true color (called
direct-color by <b>xterm</b>).</p>

<p style="margin-left:11%; margin-top: 1em">Unfortunately,
interpretation of colors 0 through 7 often depends on
whether the emulator supports eight colors or sixteen
colors. Emulators that only support eight colors (such as
the Linux console) will display colors 0 through 7 with
normal brightness and ignore colors 8 through 15, treating
them the same as white. Emulators that support 16 colors,
such as gnome-terminal, normally display colors 0 through 7
as dim or darker versions and colors 8 through 15 as normal
brightness. On such emulators, the &quot;normal&quot; white
(color 7) usually is shown as pale grey, requiring bright
white (15) to be used to get a real white color. Bright
black usually is a dark grey color, although some terminals
display it as pure black. Some sixteen-color terminal
emulators also treat normal yellow (color 3) as orange or
brown, and bright yellow (color 11) as yellow.</p>

<p style="margin-left:11%; margin-top: 1em">Following the
normal convention of sixteen-color emulators, this module
provides a pair of attributes for each color. For every
normal color (0 through 7), the corresponding bright color
(8 through 15) is obtained by prepending the string
&quot;bright_&quot; to the normal color name. For example,
&quot;red&quot; is color 1 and &quot;bright_red&quot; is
color 9. The same applies for background colors:
&quot;on_red&quot; is the normal color and
&quot;on_bright_red&quot; is the bright color. Capitalize
these strings for the constant interface.</p>

<p style="margin-left:11%; margin-top: 1em">There is
unfortunately no way to know whether the current emulator
supports more than eight colors, which makes the choice of
colors difficult. The most conservative choice is to use
only the regular colors, which are at least displayed on all
emulators. However, they will appear dark in sixteen-color
terminal emulators, including most common emulators in
<small>UNIX X</small> environments. If you know the display
is one of those emulators, you may wish to use the bright
variants instead. Even better, offer the user a way to
configure the colors for a given application to fit their
terminal emulator.</p>

<p style="margin-left:11%; margin-top: 1em">For
256&minus;color emulators, this module additionally provides
&quot;ansi0&quot; through &quot;ansi15&quot;, which are the
same as colors 0 through 15 in sixteen-color emulators but
use the 256&minus;color escape syntax, &quot;grey0&quot;
through &quot;grey23&quot; ranging from nearly black to
nearly white, and a set of <small>RGB</small> colors. The
<small>RGB</small> colors are of the form
&quot;rgb<i>RGB</i>&quot; where <i>R</i>, <i>G</i>, and
<i>B</i> are numbers from 0 to 5 giving the intensity of
red, green, and blue. The grey and <small>RGB</small> colors
are also available as &quot;ansi16&quot; through
&quot;ansi255&quot; if you want simple names for all 256
colors. &quot;on_&quot; variants of all of these colors are
also provided. These colors may be ignored completely on
non&minus;256&minus;color terminals or may be misinterpreted
and produce random behavior. Additional attributes such as
blink, italic, or bold may not work with the 256&minus;color
palette.</p>

<p style="margin-left:11%; margin-top: 1em">For true color
emulators, this module supports attributes of the form
&quot;r<i>NNN</i>g<i>NNN</i>b<i>NNN</i>&quot; and
&quot;on_r<i>NNN</i>g<i>NNN</i>b<i>NNN</i>&quot; for all
values of <i><small>NNN</small></i> between 0 and 255. These
represent foreground and background colors, respectively,
with the <small>RGB</small> values given by the
<i><small>NNN</small></i> numbers. These colors may be
ignored completely on non-true-color terminals or may be
misinterpreted and produce random behavior.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Function
Interface</b> <br>
The function interface uses attribute strings to describe
the colors and text attributes to assign to text. The
recognized non-color attributes are clear, reset, bold,
dark, faint, italic, underline, underscore, blink, reverse,
and concealed. Clear and reset (reset to default
attributes), dark and faint (dim and saturated), and
underline and underscore are equivalent, so use whichever is
the most intuitive to you.</p>

<p style="margin-left:11%; margin-top: 1em">Note that not
all attributes are supported by all terminal types, and some
terminals may not support any of these sequences. Dark and
faint, italic, blink, and concealed in particular are
frequently not implemented.</p>

<p style="margin-left:11%; margin-top: 1em">The recognized
normal foreground color attributes (colors 0 to 7) are:</p>

<p style="margin-left:11%; margin-top: 1em">black red green
yellow blue magenta cyan white</p>

<p style="margin-left:11%; margin-top: 1em">The
corresponding bright foreground color attributes (colors 8
to 15) are:</p>

<p style="margin-left:11%; margin-top: 1em">bright_black
bright_red bright_green bright_yellow <br>
bright_blue bright_magenta bright_cyan bright_white</p>

<p style="margin-left:11%; margin-top: 1em">The recognized
normal background color attributes (colors 0 to 7) are:</p>

<p style="margin-left:11%; margin-top: 1em">on_black on_red
on_green on yellow <br>
on_blue on_magenta on_cyan on_white</p>

<p style="margin-left:11%; margin-top: 1em">The recognized
bright background color attributes (colors 8 to 15) are:</p>


<p style="margin-left:11%; margin-top: 1em">on_bright_black
on_bright_red on_bright_green on_bright_yellow <br>
on_bright_blue on_bright_magenta on_bright_cyan
on_bright_white</p>

<p style="margin-left:11%; margin-top: 1em">For
256&minus;color terminals, the recognized foreground colors
are:</p>

<p style="margin-left:11%; margin-top: 1em">ansi0 ..
ansi255 <br>
grey0 .. grey23</p>

<p style="margin-left:11%; margin-top: 1em">plus
&quot;rgb<i>RGB</i>&quot; for <i>R</i>, <i>G</i>, and
<i>B</i> values from 0 to 5, such as &quot;rgb000&quot; or
&quot;rgb515&quot;. Similarly, the recognized background
colors are:</p>

<p style="margin-left:11%; margin-top: 1em">on_ansi0 ..
on_ansi255 <br>
on_grey0 .. on_grey23</p>

<p style="margin-left:11%; margin-top: 1em">plus
&quot;on_rgb<i>RGB</i>&quot; for <i>R</i>, <i>G</i>, and
<i>B</i> values from 0 to 5.</p>

<p style="margin-left:11%; margin-top: 1em">For true color
terminals, the recognized foreground colors are
&quot;r<i>RRR</i>g<i>GGG</i>b<i>BBB</i>&quot; for
<i><small>RRR</small></i> , <i><small>GGG</small></i> , and
<i><small>BBB</small></i> values between 0 and 255.
Similarly, the recognized background colors are
&quot;on_r<i>RRR</i>g<i>GGG</i>b<i>BBB</i>&quot; for
<i><small>RRR</small></i> , <i><small>GGG</small></i> , and
<i><small>BBB</small></i> values between 0 and 255.</p>

<p style="margin-left:11%; margin-top: 1em">For any of the
above listed attributes, case is not significant.</p>

<p style="margin-left:11%; margin-top: 1em">Attributes,
once set, last until they are unset (by printing the
attribute &quot;clear&quot; or &quot;reset&quot;). Be
careful to do this, or otherwise your attribute will last
after your script is done running, and people get very
annoyed at having their prompt and typing changed to weird
colors. <br>
color(ATTR[, <small>ATTR ...</small> ])</p>

<p style="margin-left:17%;"><b>color()</b> takes any number
of strings as arguments and considers them to be
space-separated lists of attributes. It then forms and
returns the escape sequence to set those attributes. It
doesn&rsquo;t print it out, just returns it, so you&rsquo;ll
have to print it yourself if you want to. This is so that
you can save it as a string, pass it to something else, send
it to a file handle, or do anything else with it that you
might care to. <b>color()</b> throws an exception if given
an invalid attribute.</p>

<p style="margin-left:11%;">colored( <small>STRING,</small>
ATTR[, <small>ATTR ...</small> ]) <br>
colored( <small>ATTR&minus;REF,</small> STRING[,
<small>STRING...</small> ])</p>

<p style="margin-left:17%;">As an aid in resetting colors,
<b>colored()</b> takes a scalar as the first argument and
any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the
attributes will be set as requested before the string and
reset to normal after the string. Alternately, you can pass
a reference to an array as the first argument, and then the
contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to
colorize.</p>

<p style="margin-left:17%; margin-top: 1em">Normally,
<b>colored()</b> just puts attribute codes at the beginning
and end of the string, but if you set
$Term::ANSIColor::EACHLINE to some string, that string will
be considered the line delimiter and the attribute will be
set at the beginning of each line of the passed string and
reset at the end of each line. This is often desirable if
the output contains newlines and you&rsquo;re using
background colors, since a background color that persists
across a newline is often interpreted by the terminal as
providing the default background color for the next line.
Programs like pagers can also be confused by attributes that
span lines. Normally you&rsquo;ll want to set
$Term::ANSIColor::EACHLINE to &quot;\n&quot; to use this
feature.</p>

<p style="margin-left:17%; margin-top: 1em">Particularly
consider setting $Term::ANSIColor::EACHLINE if you are
interleaving output to standard output and standard error
and you aren&rsquo;t flushing standard output (via
<b>autoflush()</b> or setting $|). If you don&rsquo;t, the
code to reset the color may unexpectedly sit in the standard
output buffer rather than going to the display, causing
standard error output to appear in the wrong color.</p>

<p style="margin-left:11%;">uncolor( <small>ESCAPE</small>
)</p>

<p style="margin-left:17%;"><b>uncolor()</b> performs the
opposite translation as <b>color()</b>, turning escape
sequences into a list of strings corresponding to the
attributes being set by those sequences. <b>uncolor()</b>
will never return &quot;ansi16&quot; through
&quot;ansi255&quot;, instead preferring the &quot;grey&quot;
and &quot;rgb&quot; names (and likewise for
&quot;on_ansi16&quot; through &quot;on_ansi255&quot;).</p>

<p style="margin-left:11%;">colorstrip(STRING[,
<small>STRING ...</small> ])</p>

<p style="margin-left:17%;"><b>colorstrip()</b> removes all
color escape sequences from the provided strings, returning
the modified strings separately in array context or joined
together in scalar context. Its arguments are not
modified.</p>

<p style="margin-left:11%;">colorvalid(ATTR[, <small>ATTR
...</small> ])</p>

<p style="margin-left:17%;"><b>colorvalid()</b> takes
attribute strings the same as <b>color()</b> and returns
true if all attributes are known and false otherwise.</p>

<p style="margin-left:11%;">coloralias(ALIAS[, <small>ATTR
...</small> ])</p>

<p style="margin-left:17%;">If <small>ATTR</small> is
specified, it is interpreted as a list of space-separated
strings naming attributes or existing aliases. In this case,
<b>coloralias()</b> sets up an alias of <small>ALIAS</small>
for the set of attributes given by <small>ATTR.</small> From
that point forward, <small>ALIAS</small> can be passed into
<b>color()</b>, <b>colored()</b>, and <b>colorvalid()</b>
and will have the same meaning as the sequence of attributes
given in <small>ATTR.</small> One possible use of this
facility is to give more meaningful names to the
256&minus;color <small>RGB</small> colors. Only
<small>ASCII</small> alphanumerics, &quot;.&quot;,
&quot;_&quot;, and &quot;&minus;&quot; are allowed in alias
names.</p>

<p style="margin-left:17%; margin-top: 1em">If
<small>ATTR</small> includes aliases, those aliases will be
expanded at definition time and their values will be used to
define the new alias. This means that if you define an alias
A in terms of another alias B, and then later redefine alias
B, the value of alias A will not change.</p>

<p style="margin-left:17%; margin-top: 1em">If
<small>ATTR</small> is not specified, <b>coloralias()</b>
returns the standard attribute or attributes to which
<small>ALIAS</small> is aliased, if any, or undef if
<small>ALIAS</small> does not exist. If it is aliased to
multiple attributes, the return value will be a single
string and the attributes will be separated by spaces.</p>

<p style="margin-left:17%; margin-top: 1em">This is the
same facility used by the <small>ANSI_COLORS_ALIASES</small>
environment variable (see &quot;
<small>ENVIRONMENT&quot;</small> below) but can be used at
runtime, not just when the module is loaded.</p>

<p style="margin-left:17%; margin-top: 1em">Later
invocations of <b>coloralias()</b> with the same
<small>ALIAS</small> will override earlier aliases. There is
no way to remove an alias.</p>

<p style="margin-left:17%; margin-top: 1em">Aliases have no
effect on the return value of <b>uncolor()</b>.</p>


<p style="margin-left:17%; margin-top: 1em"><b><small>WARNING</small></b>
: Aliases are global and affect all callers in the same
process. There is no way to set an alias limited to a
particular block of code or a particular object.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Constant
Interface</b> <br>
Alternately, if you import &quot;:constants&quot;, you can
use the following constants directly:</p>

<p style="margin-left:11%; margin-top: 1em">CLEAR RESET
BOLD DARK <br>
FAINT ITALIC UNDERLINE UNDERSCORE <br>
BLINK REVERSE CONCEALED <br>
BLACK RED GREEN YELLOW <br>
BLUE MAGENTA CYAN WHITE <br>
BRIGHT_BLACK BRIGHT_RED BRIGHT_GREEN BRIGHT_YELLOW <br>
BRIGHT_BLUE BRIGHT_MAGENTA BRIGHT_CYAN BRIGHT_WHITE <br>
ON_BLACK ON_RED ON_GREEN ON_YELLOW <br>
ON_BLUE ON_MAGENTA ON_CYAN ON_WHITE <br>
ON_BRIGHT_BLACK ON_BRIGHT_RED ON_BRIGHT_GREEN
ON_BRIGHT_YELLOW <br>
ON_BRIGHT_BLUE ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN
ON_BRIGHT_WHITE</p>

<p style="margin-left:11%; margin-top: 1em">These are the
same as color(&rsquo;attribute&rsquo;) and can be used if
you prefer typing:</p>

<p style="margin-left:11%; margin-top: 1em">print BOLD BLUE
ON_WHITE &quot;Text&quot;, RESET, &quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">to</p>

<p style="margin-left:11%; margin-top: 1em">print colored
(&quot;Text&quot;, 'bold blue on_white'),
&quot;\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">(Note that the
newline is kept separate to avoid confusing the terminal as
described above since a background color is being used.)</p>

<p style="margin-left:11%; margin-top: 1em">If you import
&quot;:constants256&quot;, you can use the following
constants directly:</p>

<p style="margin-left:11%; margin-top: 1em">ANSI0 ..
ANSI255 <br>
GREY0 .. GREY23 <br>
RGBXYZ (for X, Y, and Z values from 0 to 5, like RGB000 or
RGB515) <br>
ON_ANSI0 .. ON_ANSI255 <br>
ON_GREY0 .. ON_GREY23 <br>
ON_RGBXYZ (for X, Y, and Z values from 0 to 5)</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;:constants256&quot; does not include the other
constants, so if you want to mix both, you need to include
&quot;:constants&quot; as well. You may want to explicitly
import at least &quot;RESET&quot;, as in:</p>

<p style="margin-left:11%; margin-top: 1em">use
Term::ANSIColor 4.00 qw(RESET :constants256);</p>

<p style="margin-left:11%; margin-top: 1em">True color and
aliases are not supported by the constant interface.</p>

<p style="margin-left:11%; margin-top: 1em">When using the
constants, if you don&rsquo;t want to have to remember to
add the &quot;, RESET&quot; at the end of each print line,
you can set $Term::ANSIColor::AUTORESET to a true value.
Then, the display mode will automatically be reset if there
is no comma after the constant. In other words, with that
variable set:</p>

<p style="margin-left:11%; margin-top: 1em">print BOLD BLUE
&quot;Text\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">will reset the
display mode afterward, whereas:</p>

<p style="margin-left:11%; margin-top: 1em">print BOLD,
BLUE, &quot;Text\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">will not. If
you are using background colors, you will probably want to
either use <b>say()</b> (in newer versions of Perl) or print
the newline with a separate print statement to avoid
confusing the terminal.</p>

<p style="margin-left:11%; margin-top: 1em">If
$Term::ANSIColor::AUTOLOCAL is set (see below), it takes
precedence over $Term::ANSIColor::AUTORESET, and the latter
is ignored.</p>

<p style="margin-left:11%; margin-top: 1em">The subroutine
interface has the advantage over the constants interface in
that only two subroutines are exported into your namespace,
versus thirty-eight in the constants interface, and aliases
and true color attributes are supported. On the flip side,
the constants interface has the advantage of better compile
time error checking, since misspelled names of colors or
attributes in calls to <b>color()</b> and <b>colored()</b>
won&rsquo;t be caught until runtime whereas misspelled names
of constants will be caught at compile time. So, pollute
your namespace with almost two dozen subroutines that you
may not even use that often, or risk a silly bug by
mistyping an attribute. Your choice, <small>TMTOWTDI</small>
after all.</p>

<p style="margin-left:11%; margin-top: 1em"><b>The Color
Stack</b> <br>
You can import &quot;:pushpop&quot; and maintain a stack of
colors using <small>PUSHCOLOR, POPCOLOR,</small> and
<small>LOCALCOLOR. PUSHCOLOR</small> takes the attribute
string that starts its argument and pushes it onto a stack
of attributes. <small>POPCOLOR</small> removes the top of
the stack and restores the previous attributes set by the
argument of a prior <small>PUSHCOLOR. LOCALCOLOR</small>
surrounds its argument in a <small>PUSHCOLOR</small> and
<small>POPCOLOR</small> so that the color resets
afterward.</p>

<p style="margin-left:11%; margin-top: 1em">If
$Term::ANSIColor::AUTOLOCAL is set, each sequence of color
constants will be implicitly preceded by
<small>LOCALCOLOR.</small> In other words, the
following:</p>

<p style="margin-left:11%; margin-top: 1em">{ <br>
local $Term::ANSIColor::AUTOLOCAL = 1; <br>
print BLUE &quot;Text\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">is equivalent
to:</p>

<p style="margin-left:11%; margin-top: 1em">print
LOCALCOLOR BLUE &quot;Text\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If
$Term::ANSIColor::AUTOLOCAL is set, it takes precedence over
$Term::ANSIColor::AUTORESET, and the latter is ignored.</p>

<p style="margin-left:11%; margin-top: 1em">When using
<small>PUSHCOLOR, POPCOLOR,</small> and
<small>LOCALCOLOR,</small> it&rsquo;s particularly important
to not put commas between the constants.</p>

<p style="margin-left:11%; margin-top: 1em">print PUSHCOLOR
BLUE &quot;Text\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">will correctly
push <small>BLUE</small> onto the top of the stack.</p>

<p style="margin-left:11%; margin-top: 1em">print
PUSHCOLOR, BLUE, &quot;Text\n&quot;; # wrong!</p>

<p style="margin-left:11%; margin-top: 1em">will not, and a
subsequent pop won&rsquo;t restore the correct attributes.
<small>PUSHCOLOR</small> pushes the attributes set by its
argument, which is normally a string of color constants. It
can&rsquo;t ask the terminal what the current attributes
are.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Supporting
<small>CLICOLOR</small></b> <br>
&lt;https://bixense.com/clicolors/&gt; proposes a standard
for enabling and disabling color output from console
commands using two environment variables,
<small>CLICOLOR</small> and <small>CLICOLOR_FORCE.</small>
Term::ANSIColor cannot automatically support this standard,
since the correct action depends on where the output is
going and Term::ANSIColor may be used in a context where
colors should always be generated even if
<small>CLICOLOR</small> is set in the environment. But you
can use the supported environment variable
<small>ANSI_COLORS_DISABLED</small> to implement
<small>CLICOLOR</small> in your own programs with code like
this:</p>

<p style="margin-left:11%; margin-top: 1em">if
(exists($ENV{CLICOLOR}) &amp;&amp; $ENV{CLICOLOR} == 0) {
<br>
if (!$ENV{CLICOLOR_FORCE}) { <br>
$ENV{ANSI_COLORS_DISABLED} = 1; <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If you are
using the constant interface, be sure to include this code
before you use any color constants (such as at the very top
of your script), since this environment variable is only
honored the first time a color constant is seen.</p>

<p style="margin-left:11%; margin-top: 1em">Be aware that
this will export <small>ANSI_COLORS_DISABLED</small> to any
child processes of your program as well.</p>

<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Bad color
mapping %s</p>

<p style="margin-left:17%;">(W) The specified color mapping
from <small>ANSI_COLORS_ALIASES</small> is not valid and
could not be parsed. It was ignored.</p>

<p style="margin-left:11%;">Bad escape sequence %s</p>

<p style="margin-left:17%;">(F) You passed an invalid
<small>ANSI</small> escape sequence to <b>uncolor()</b>.</p>

<p style="margin-left:11%;">Bareword &quot;%s&quot; not
allowed while &quot;strict subs&quot; in use</p>

<p style="margin-left:17%;">(F) You probably mistyped a
constant color name such as:</p>

<p style="margin-left:17%; margin-top: 1em">$Foobar =
FOOBAR . &quot;This line should be blue\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">or:</p>

<p style="margin-left:17%; margin-top: 1em">@Foobar =
FOOBAR, &quot;This line should be blue\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">This will only
show up under use strict (another good reason to run under
use strict).</p>

<p style="margin-left:11%;">Cannot alias standard color
%s</p>

<p style="margin-left:17%;">(F) The alias name passed to
<b>coloralias()</b> matches a standard color name. Standard
color names cannot be aliased.</p>

<p style="margin-left:11%;">Cannot alias standard color %s
in %s</p>

<p style="margin-left:17%;">(W) The same, but in
<small>ANSI_COLORS_ALIASES.</small> The color mapping was
ignored.</p>

<p style="margin-left:11%;">Invalid alias name %s</p>

<p style="margin-left:17%;">(F) You passed an invalid alias
name to <b>coloralias()</b>. Alias names must consist only
of alphanumerics, &quot;.&quot;, &quot;&minus;&quot;, and
&quot;_&quot;.</p>

<p style="margin-left:11%;">Invalid alias name %s in %s</p>

<p style="margin-left:17%;">(W) You specified an invalid
alias name on the left hand of the equal sign in a color
mapping in <small>ANSI_COLORS_ALIASES.</small> The color
mapping was ignored.</p>

<p style="margin-left:11%;">Invalid attribute name %s</p>

<p style="margin-left:17%;">(F) You passed an invalid
attribute name to <b>color()</b>, <b>colored()</b>, or
<b>coloralias()</b>.</p>

<p style="margin-left:11%;">Invalid attribute name %s in
%s</p>

<p style="margin-left:17%;">(W) You specified an invalid
attribute name on the right hand of the equal sign in a
color mapping in <small>ANSI_COLORS_ALIASES.</small> The
color mapping was ignored.</p>

<p style="margin-left:11%;">Name &quot;%s&quot; used only
once: possible typo</p>

<p style="margin-left:17%;">(W) You probably mistyped a
constant color name such as:</p>

<p style="margin-left:17%; margin-top: 1em">print FOOBAR
&quot;This text is color FOOBAR\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">It&rsquo;s
probably better to always use commas after constant names in
order to force the next error.</p>

<p style="margin-left:11%;">No comma allowed after
filehandle</p>

<p style="margin-left:17%;">(F) You probably mistyped a
constant color name such as:</p>

<p style="margin-left:17%; margin-top: 1em">print FOOBAR,
&quot;This text is color FOOBAR\n&quot;;</p>

<p style="margin-left:17%; margin-top: 1em">Generating this
fatal compile error is one of the main advantages of using
the constants interface, since you&rsquo;ll immediately know
if you mistype a color name.</p>

<p style="margin-left:11%;">No name for escape sequence
%s</p>

<p style="margin-left:17%;">(F) The <small>ANSI</small>
escape sequence passed to <b>uncolor()</b> contains escapes
which aren&rsquo;t recognized and can&rsquo;t be translated
to names.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><small>ANSI_COLORS_ALIASES</small></p>

<p style="margin-left:17%;">This environment variable
allows the user to specify custom color aliases that will be
understood by <b>color()</b>, <b>colored()</b>, and
<b>colorvalid()</b>. None of the other functions will be
affected, and no new color constants will be created. The
custom colors are aliases for existing color names; no new
escape sequences can be introduced. Only alphanumerics,
&quot;.&quot;, &quot;_&quot;, and &quot;&minus;&quot; are
allowed in alias names.</p>

<p style="margin-left:17%; margin-top: 1em">The format
is:</p>


<p style="margin-left:17%; margin-top: 1em">ANSI_COLORS_ALIASES='newcolor1=oldcolor1,newcolor2=oldcolor2'</p>

<p style="margin-left:17%; margin-top: 1em">Whitespace is
ignored. The alias value can be a single attribute or a
space-separated list of attributes.</p>

<p style="margin-left:17%; margin-top: 1em">For example the
Solarized &lt;https://ethanschoonover.com/solarized&gt;
colors can be mapped with:</p>


<p style="margin-left:17%; margin-top: 1em">ANSI_COLORS_ALIASES='\
<br>
base00=bright_yellow, on_base00=on_bright_yellow,\ <br>
base01=bright_green, on_base01=on_bright_green, \ <br>
base02=black, on_base02=on_black, \ <br>
base03=bright_black, on_base03=on_bright_black, \ <br>
base0=bright_blue, on_base0=on_bright_blue, \ <br>
base1=bright_cyan, on_base1=on_bright_cyan, \ <br>
base2=white, on_base2=on_white, \ <br>
base3=bright_white, on_base3=on_bright_white, \ <br>
orange=bright_red, on_orange=on_bright_red, \ <br>
violet=bright_magenta,on_violet=on_bright_magenta'</p>

<p style="margin-left:17%; margin-top: 1em">This
environment variable is read and applied when the
Term::ANSIColor module is loaded and is then subsequently
ignored. Changes to <small>ANSI_COLORS_ALIASES</small> after
the module is loaded will have no effect. See
<b>coloralias()</b> for an equivalent facility that can be
used at runtime.</p>


<p style="margin-left:11%;"><small>ANSI_COLORS_DISABLED</small></p>

<p style="margin-left:17%;">If this environment variable is
set to a true value, all of the functions defined by this
module (<b>color()</b>, <b>colored()</b>, and all of the
constants) will not output any escape sequences and instead
will just return the empty string or pass through the
original text as appropriate. This is intended to support
easy use of scripts using this module on platforms that
don&rsquo;t support <small>ANSI</small> escape
sequences.</p>

<p style="margin-left:11%;"><small>NO_COLOR</small></p>

<p style="margin-left:17%;">If this environment variable is
set to any value, it suppresses generation of escape
sequences the same as if <small>ANSI_COLORS_DISABLED</small>
is set to a true value. This implements the
&lt;https://no&minus;color.org/&gt; informal standard.
Programs that want to enable color despite
<small>NO_COLOR</small> being set will need to unset that
environment variable before any constant or function
provided by this module is used.</p>

<h2>COMPATIBILITY
<a name="COMPATIBILITY"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">Term::ANSIColor
was first included with Perl in Perl 5.6.0.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>uncolor()</b> function and support for
<small>ANSI_COLORS_DISABLED</small> were added in
Term::ANSIColor 1.04, included in Perl 5.8.0.</p>

<p style="margin-left:11%; margin-top: 1em">Support for
dark was added in Term::ANSIColor 1.08, included in Perl
5.8.4.</p>

<p style="margin-left:11%; margin-top: 1em">The color
stack, including the &quot;:pushpop&quot; import tag,
<small>PUSHCOLOR, POPCOLOR, LOCALCOLOR,</small> and the
$Term::ANSIColor::AUTOLOCAL variable, was added in
Term::ANSIColor 2.00, included in Perl 5.10.1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>colorstrip()</b>
was added in Term::ANSIColor 2.01 and <b>colorvalid()</b>
was added in Term::ANSIColor 2.02, both included in Perl
5.11.0.</p>

<p style="margin-left:11%; margin-top: 1em">Support for
colors 8 through 15 (the &quot;bright_&quot; variants) was
added in Term::ANSIColor 3.00, included in Perl 5.13.3.</p>

<p style="margin-left:11%; margin-top: 1em">Support for
italic was added in Term::ANSIColor 3.02, included in Perl
5.17.1.</p>

<p style="margin-left:11%; margin-top: 1em">Support for
colors 16 through 256 (the &quot;ansi&quot;,
&quot;rgb&quot;, and &quot;grey&quot; colors), the
&quot;:constants256&quot; import tag, the
<b>coloralias()</b> function, and support for the
<small>ANSI_COLORS_ALIASES</small> environment variable were
added in Term::ANSIColor 4.00, included in Perl 5.17.8.</p>


<p style="margin-left:11%; margin-top: 1em">$Term::ANSIColor::AUTOLOCAL
was changed to take precedence over
$Term::ANSIColor::AUTORESET, rather than the other way
around, in Term::ANSIColor 4.00, included in Perl
5.17.8.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;ansi16&quot;
through &quot;ansi255&quot;, as aliases for the
&quot;rgb&quot; and &quot;grey&quot; colors, and the
corresponding &quot;on_ansi&quot; names and &quot;ANSI&quot;
and &quot;ON_ANSI&quot; constants were added in
Term::ANSIColor 4.06, included in Perl 5.25.7.</p>

<p style="margin-left:11%; margin-top: 1em">Support for
true color (the &quot;rNNNgNNNbNNN&quot; and
&quot;on_rNNNgNNNbNNN&quot; attributes), defining aliases in
terms of other aliases, and aliases mapping to multiple
attributes instead of only a single attribute was added in
Term::ANSIColor 5.00.</p>

<p style="margin-left:11%; margin-top: 1em">Support for
<small>NO_COLOR</small> was added in Term::ANSIColor
5.01.</p>

<h2>RESTRICTIONS
<a name="RESTRICTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Both
<b>colored()</b> and many uses of the color constants will
add the reset escape sequence after a newline. If a program
mixes colored output to standard output with output to
standard error, this can result in the standard error text
having the wrong color because the reset escape sequence
hasn&rsquo;t yet been flushed to the display (since standard
output to a terminal is line-buffered by default). To avoid
this, either set <b>autoflush()</b> on <small>STDOUT</small>
or set $Term::ANSIColor::EACHLINE to &quot;\n&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">It would be
nice if one could leave off the commas around the constants
entirely and just say:</p>

<p style="margin-left:11%; margin-top: 1em">print BOLD BLUE
ON_WHITE &quot;Text\n&quot; RESET;</p>

<p style="margin-left:11%; margin-top: 1em">but the syntax
of Perl doesn&rsquo;t allow this. You need a comma after the
string. (Of course, you may consider it a bug that commas
between all the constants aren&rsquo;t required, in which
case you may feel free to insert commas unless you&rsquo;re
using $Term::ANSIColor::AUTORESET or
<small>PUSHCOLOR/POPCOLOR.</small> )</p>

<p style="margin-left:11%; margin-top: 1em">For easier
debugging, you may prefer to always use the commas when not
setting $Term::ANSIColor::AUTORESET or
<small>PUSHCOLOR/POPCOLOR</small> so that you&rsquo;ll get a
fatal compile error rather than a warning.</p>

<p style="margin-left:11%; margin-top: 1em">It&rsquo;s not
possible to use this module to embed formatting and color
attributes using Perl formats. They replace the escape
character with a space (as documented in
<b>perlform</b>(1)), resulting in garbled output from the
unrecognized attribute. Even if there were a way around that
problem, the format doesn&rsquo;t know that the non-printing
escape sequence is zero-length and would incorrectly format
the output. For formatted output using color or other
attributes, either use <b>sprintf()</b> instead or use
<b>formline()</b> and then add the color or other attributes
after formatting and before output.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The codes
generated by this module are standard terminal control
codes, complying with <small>ECMA&minus;048</small> and
<small>ISO 6429</small> (generally referred to as &quot;
<small>ANSI</small> color&quot; for the color codes). The
non-color control codes (bold, dark, italic, underline, and
reverse) are part of the earlier <small>ANSI X3.64</small>
standard for control sequences for video terminals and
peripherals.</p>

<p style="margin-left:11%; margin-top: 1em">Note that not
all displays are <small>ISO</small> 6429&minus;compliant, or
even X3.64&minus;compliant (or are even attempting to be
so). This module will not work as expected on displays that
do not honor these escape sequences, such as cmd.exe,
4nt.exe, and command.com under either Windows
<small>NT</small> or Windows 2000. They may just be ignored,
or they may display as an <small>ESC</small> character
followed by some apparent garbage.</p>

<p style="margin-left:11%; margin-top: 1em">Jean Delvare
provided the following table of different common terminal
emulators and their support for the various attributes and
others have helped me flesh it out:</p>

<p style="margin-left:11%; margin-top: 1em">clear bold
faint under blink reverse conceal <br>

&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;
<br>
xterm yes yes no yes yes yes yes <br>
linux yes yes yes bold yes yes no <br>
rxvt yes yes no yes bold/black yes no <br>
dtterm yes yes yes yes reverse yes yes <br>
teraterm yes reverse no yes rev/red yes no <br>
aixterm kinda normal no yes no yes yes <br>
PuTTY yes color no yes no yes no <br>
Windows yes no no no no yes no <br>
Cygwin SSH yes yes no color color color yes <br>
Terminal.app yes yes no yes yes yes yes</p>

<p style="margin-left:11%; margin-top: 1em">Windows is
Windows telnet, Cygwin <small>SSH</small> is the OpenSSH
implementation under Cygwin on Windows <small>NT,</small>
and Mac Terminal is the Terminal application in Mac
<small>OS X.</small> Where the entry is other than yes or
no, that emulator displays the given attribute as something
else instead. Note that on an aixterm, clear doesn&rsquo;t
reset colors; you have to explicitly set the colors back to
what you want. More entries in this table are welcome.</p>

<p style="margin-left:11%; margin-top: 1em">Support for
code 3 (italic) is rare and therefore not mentioned in that
table. It is not believed to be fully supported by any of
the terminals listed, although it&rsquo;s displayed as green
in the Linux console, but it is reportedly supported by
urxvt.</p>

<p style="margin-left:11%; margin-top: 1em">Note that codes
6 (rapid blink) and 9 (strike-through) are specified in
<small>ANSI X3.64</small> and <small>ECMA&minus;048</small>
but are not commonly supported by most displays and
emulators and therefore aren&rsquo;t supported by this
module. <small>ECMA&minus;048</small> also specifies a large
number of other attributes, including a sequence of
attributes for font changes, Fraktur characters,
double-underlining, framing, circling, and overlining. As
none of these attributes are widely supported or useful,
they also aren&rsquo;t currently supported by this
module.</p>

<p style="margin-left:11%; margin-top: 1em">Most modern X
terminal emulators support 256 colors. Known to not support
those colors are aterm, rxvt, Terminal.app, and
<small>TTY/VC.</small></p>

<p style="margin-left:11%; margin-top: 1em">For information
on true color support in various terminal emulators, see
True Colour support
&lt;https://gist.github.com/XVilka/8346728&gt;.</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Original idea
(using constants) by Zenin, reimplemented using subs by Russ
Allbery &lt;rra@cpan.org&gt;, and then combined with the
original idea by Russ with input from Zenin. 256&minus;color
support is based on work by Kurt Starsinic. Russ Allbery now
maintains this module.</p>


<p style="margin-left:11%; margin-top: 1em"><small>PUSHCOLOR,
POPCOLOR,</small> and <small>LOCALCOLOR</small> were
contributed by openmethods.com voice solutions.</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
1996&minus;1998, 2000&minus;2002, 2005&minus;2006,
2008&minus;2018, 2020 Russ Allbery &lt;rra@cpan.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Copyright 1996
Zenin</p>

<p style="margin-left:11%; margin-top: 1em">Copyright 2012
Kurt Starsinic &lt;kstarsinic@gmail.com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you may redistribute it and/or modify it
under the same terms as Perl itself.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>CPAN</small> module Term::ExtendedColor provides a
different and more comprehensive interface for
256&minus;color emulators that may be more convenient. The
<small>CPAN</small> module Win32::Console::ANSI provides
<small>ANSI</small> color (and other escape sequence)
support in the Win32 Console environment. The
<small>CPAN</small> module Term::Chrome provides a different
interface using objects and operator overloading.</p>


<p style="margin-left:11%; margin-top: 1em"><small>ECMA&minus;048</small>
is available on-line (at least at the time of this writing)
at
&lt;https://www.ecma&minus;international.org/publications/standards/Ecma&minus;048.htm&gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><small>ISO
6429</small> is available from <small>ISO</small> for a
charge; the author of this module does not own a copy of it.
Since the source material for <small>ISO 6429</small> was
<small>ECMA&minus;048</small> and the latter is available
for free, there seems little reason to obtain the
<small>ISO</small> standard.</p>

<p style="margin-left:11%; margin-top: 1em">The
256&minus;color control sequences are documented at
&lt;https://invisible&minus;island.net/xterm/ctlseqs/ctlseqs.html&gt;
(search for 256&minus;color).</p>

<p style="margin-left:11%; margin-top: 1em">Information
about true color support in various terminal emulators and
test programs you can run to check the true color support in
your terminal emulator are available at
&lt;https://gist.github.com/XVilka/8346728&gt;.</p>


<p style="margin-left:11%; margin-top: 1em"><small>CLICOLORS</small>
&lt;https://bixense.com/clicolors/&gt; and
<small>NO_COLOR</small> &lt;https://no-color.org/&gt; are
useful standards to be aware of, and ideally follow, for any
application using color. Term::ANSIColor complies with the
latter.</p>

<p style="margin-left:11%; margin-top: 1em">The current
version of this module is always available from its web site
at &lt;https://www.eyrie.org/~eagle/software/ansicolor/&gt;.
It is also part of the Perl core distribution as of
5.6.0.</p>
<hr>
</body>
</html>
