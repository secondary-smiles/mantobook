<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:17 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>TAP::Parser</title>

</head>
<body>
<h1>TAP::Parser</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">TAP::Parser
&minus; Parse TAP output</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Version
3.44</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use
TAP::Parser; <br>
my $parser = TAP::Parser&minus;&gt;new( { source =&gt;
$source } ); <br>
while ( my $result = $parser&minus;&gt;next ) { <br>
print $result&minus;&gt;as_string; <br>
}</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">&quot;TAP::Parser&quot;
is designed to produce a proper parse of <small>TAP</small>
output. For an example of how to run tests through this
module, see the simple harnesses &quot;examples/&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">There&rsquo;s a
wiki dedicated to the Test Anything Protocol:</p>


<p style="margin-left:11%; margin-top: 1em">&lt;http://testanything.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">It includes the
TAP::Parser Cookbook:</p>


<p style="margin-left:11%; margin-top: 1em">&lt;http://testanything.org/testing&minus;with&minus;tap/perl/tap::parser&minus;cookbook.html&gt;</p>

<h2>METHODS
<a name="METHODS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Class
Methods</b> <i><br>
&quot;new&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $parser =
TAP::Parser&minus;&gt;new(\%args);</p>

<p style="margin-left:11%; margin-top: 1em">Returns a new
&quot;TAP::Parser&quot; object.</p>

<p style="margin-left:11%; margin-top: 1em">The arguments
should be a hashref with <i>one</i> of the following
keys:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="12%">


<p>&quot;source&quot;</p></td>
<td width="71%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>CHANGED</small>
in 3.18</i></p>

<p style="margin-left:17%; margin-top: 1em">This is the
preferred method of passing input to the constructor.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;source&quot; is used to create a TAP::Parser::Source
that is passed to the &quot;iterator_factory_class&quot;
which in turn figures out how to handle the source and
creates a &lt;TAP::Parser::Iterator&gt; for it. The iterator
is used by the parser to read in the <small>TAP</small>
stream.</p>

<p style="margin-left:17%; margin-top: 1em">To configure
the <i>IteratorFactory</i> use the &quot;sources&quot;
parameter below.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;source&quot;, &quot;tap&quot; and &quot;exec&quot; are
<i>mutually exclusive</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em">&quot;tap&quot;</p></td>
<td width="75%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>CHANGED</small>
in 3.18</i></p>

<p style="margin-left:17%; margin-top: 1em">The value
should be the complete <small>TAP</small> output.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>tap</i>
is used to create a TAP::Parser::Source that is passed to
the &quot;iterator_factory_class&quot; which in turn figures
out how to handle the source and creates a
&lt;TAP::Parser::Iterator&gt; for it. The iterator is used
by the parser to read in the <small>TAP</small> stream.</p>

<p style="margin-left:17%; margin-top: 1em">To configure
the <i>IteratorFactory</i> use the &quot;sources&quot;
parameter below.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;source&quot;, &quot;tap&quot; and &quot;exec&quot; are
<i>mutually exclusive</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em">&quot;exec&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Must be passed
an array reference.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>exec</i>
array ref is used to create a TAP::Parser::Source that is
passed to the &quot;iterator_factory_class&quot; which in
turn figures out how to handle the source and creates a
&lt;TAP::Parser::Iterator&gt; for it. The iterator is used
by the parser to read in the <small>TAP</small> stream.</p>

<p style="margin-left:17%; margin-top: 1em">By default the
TAP::Parser::SourceHandler::Executable class will create a
TAP::Parser::Iterator::Process object to handle the source.
This passes the array reference strings as command arguments
to IPC::Open3::open3:</p>

<p style="margin-left:17%; margin-top: 1em">exec =&gt; [
'/usr/bin/ruby', 't/my_test.rb' ]</p>

<p style="margin-left:17%; margin-top: 1em">If any
&quot;test_args&quot; are given they will be appended to the
end of the command argument list.</p>

<p style="margin-left:17%; margin-top: 1em">To configure
the <i>IteratorFactory</i> use the &quot;sources&quot;
parameter below.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
&quot;source&quot;, &quot;tap&quot; and &quot;exec&quot; are
<i>mutually exclusive</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The following
keys are optional.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em">&quot;sources&quot;</p></td>
<td width="69%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>NEW</small>
to 3.18</i>.</p>

<p style="margin-left:17%; margin-top: 1em">If set,
&quot;sources&quot; must be a hashref containing the names
of the TAP::Parser::SourceHandlers to load and/or configure.
The values are a hash of configuration that will be
accessible to the source handlers via &quot;config_for&quot;
in TAP::Parser::Source.</p>

<p style="margin-left:17%; margin-top: 1em">For
example:</p>

<p style="margin-left:17%; margin-top: 1em">sources =&gt; {
<br>
Perl =&gt; { exec =&gt; '/path/to/custom/perl' }, <br>
File =&gt; { extensions =&gt; [ '.tap', '.txt' ] }, <br>
MyCustom =&gt; { some =&gt; 'config' }, <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">This will cause
&quot;TAP::Parser&quot; to pass custom configuration to two
of the built&minus; in source handlers &minus;
TAP::Parser::SourceHandler::Perl,
TAP::Parser::SourceHandler::File &minus; and attempt to load
the &quot;MyCustom&quot; class. See
&quot;load_handlers&quot; in TAP::Parser::IteratorFactory
for more detail.</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;sources&quot; parameter affects how
&quot;source&quot;, &quot;tap&quot; and &quot;exec&quot;
parameters are handled.</p>

<p style="margin-left:17%; margin-top: 1em">See
TAP::Parser::IteratorFactory, TAP::Parser::SourceHandler and
subclasses for more details.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em">&quot;callback&quot;</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If present,
each callback corresponding to a given result type will be
called with the result as the argument if the
&quot;run&quot; method is used:</p>

<p style="margin-left:17%; margin-top: 1em">my %callbacks =
( <br>
test =&gt; \&amp;test_callback, <br>
plan =&gt; \&amp;plan_callback, <br>
comment =&gt; \&amp;comment_callback, <br>
bailout =&gt; \&amp;bailout_callback, <br>
unknown =&gt; \&amp;unknown_callback, <br>
); <br>
my $aggregator = TAP::Parser::Aggregator&minus;&gt;new; <br>
for my $file ( @test_files ) { <br>
my $parser = TAP::Parser&minus;&gt;new( <br>
{ <br>
source =&gt; $file, <br>
callbacks =&gt; \%callbacks, <br>
} <br>
); <br>
$parser&minus;&gt;run; <br>
$aggregator&minus;&gt;add( $file, $parser ); <br>
}</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em">&quot;switches&quot;</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If using a Perl
file as a source, optional switches may be passed which will
be used when invoking the perl executable.</p>

<p style="margin-left:17%; margin-top: 1em">my $parser =
TAP::Parser&minus;&gt;new( { <br>
source =&gt; $test_file, <br>
switches =&gt; [ '&minus;Ilib' ], <br>
} );</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="17%">


<p style="margin-top: 1em">&quot;test_args&quot;</p></td>
<td width="66%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Used in
conjunction with the &quot;source&quot; and &quot;exec&quot;
option to supply a reference to an @ARGV style array of
arguments to pass to the test program.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">&quot;spool&quot;</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If passed a
filehandle will write a copy of all parsed
<small>TAP</small> to that handle.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">&quot;merge&quot;</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If false,
<small>STDERR</small> is not captured (though it is
&rsquo;relayed&rsquo; to keep it somewhat synchronized with
<small>STDOUT.</small> )</p>

<p style="margin-left:17%; margin-top: 1em">If true,
<small>STDERR</small> and <small>STDOUT</small> are the same
filehandle. This may cause breakage if <small>STDERR</small>
contains anything resembling <small>TAP</small> format, but
does allow exact synchronization.</p>

<p style="margin-left:17%; margin-top: 1em">Subtleties of
this behavior may be platform-dependent and may change in
the future.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p style="margin-top: 1em">&quot;grammar_class&quot;</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option was
introduced to let you easily customize which <i>grammar</i>
class the parser should use. It defaults to
TAP::Parser::Grammar.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;make_grammar&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="34%">



<p style="margin-top: 1em">&quot;result_factory_class&quot;</p> </td>
<td width="49%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This option was
introduced to let you easily customize which <i>result</i>
factory class the parser should use. It defaults to
TAP::Parser::ResultFactory.</p>

<p style="margin-left:17%; margin-top: 1em">See also
&quot;make_result&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="37%">



<p style="margin-top: 1em">&quot;iterator_factory_class&quot;</p> </td>
<td width="46%">
</td></tr>
</table>


<p style="margin-left:17%; margin-top: 1em"><i><small>CHANGED</small>
in 3.18</i></p>

<p style="margin-left:17%; margin-top: 1em">This option was
introduced to let you easily customize which <i>iterator</i>
factory class the parser should use. It defaults to
TAP::Parser::IteratorFactory.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Instance
Methods</b> <i><br>
&quot;next&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $parser =
TAP::Parser&minus;&gt;new( { source =&gt; $file } ); <br>
while ( my $result = $parser&minus;&gt;next ) { <br>
print $result&minus;&gt;as_string, &quot;\n&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This method
returns the results of the parsing, one result at a time.
Note that it is destructive. You can&rsquo;t rewind and
examine previous results.</p>

<p style="margin-left:11%; margin-top: 1em">If callbacks
are used, they will be issued before this call returns.</p>

<p style="margin-left:11%; margin-top: 1em">Each result
returned is a subclass of TAP::Parser::Result. See that
module and related classes for more information on how to
use them.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;run&quot;</i></p>


<p style="margin-left:11%; margin-top: 1em">$parser&minus;&gt;run;</p>

<p style="margin-left:11%; margin-top: 1em">This method
merely runs the parser and parses all of the
<small>TAP.</small></p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;make_grammar&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Make a new
TAP::Parser::Grammar object and return it. Passes through
any arguments given.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;grammar_class&quot; can be customized, as described in
&quot;new&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;make_result&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Make a new
TAP::Parser::Result object using the parser&rsquo;s
TAP::Parser::ResultFactory, and return it. Passes through
any arguments given.</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;result_factory_class&quot; can be customized, as
described in &quot;new&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;make_iterator_factory&quot;</i></p>


<p style="margin-left:11%; margin-top: 1em"><i><small>NEW</small>
to 3.18</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Make a new
TAP::Parser::IteratorFactory object and return it. Passes
through any arguments given.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;iterator_factory_class&quot;
can be customized, as described in &quot;new&quot;.</p>

<h2>INDIVIDUAL RESULTS
<a name="INDIVIDUAL RESULTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;ve
read this far in the docs, you&rsquo;ve seen this:</p>

<p style="margin-left:11%; margin-top: 1em">while ( my
$result = $parser&minus;&gt;next ) { <br>
print $result&minus;&gt;as_string; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Each result
returned is a TAP::Parser::Result subclass, referred to as
<i>result types</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Result
types</b> <br>
Basically, you fetch individual results from the
<small>TAP.</small> The six types, with examples of each,
are as follows:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">Version</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">TAP version
12</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em">Plan</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">1..42</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em">Pragma</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">pragma
+strict</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="6%">


<p style="margin-top: 1em">Test</p></td>
<td width="77%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">ok 3 &minus; We
should start with some foobar!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">Comment</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em"># Hope we don't
use up the foobar.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">Bailout</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Bail out! We
ran out of foobar!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">Unknown</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">... yo, this
ain't TAP! ...</p>

<p style="margin-left:11%; margin-top: 1em">Each result
fetched is a result object of a different type. There are
common methods to each result object and different types may
have methods unique to their type. Sometimes a type method
may be overridden in a subclass, but its use is guaranteed
to be identical.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Common type
methods</b> <i><br>
&quot;type&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
type of result, such as &quot;comment&quot; or
&quot;test&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;as_string&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Prints a string
representation of the token. This might not be the exact
output, however. Tests will have test numbers added if not
present, <small>TODO</small> and <small>SKIP</small>
directives will be capitalized and, in general, things will
be cleaned up. If you need the original text for the token,
see the &quot;raw&quot; method.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;raw&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
original line of text which was parsed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_plan&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not this is the test plan line.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_test&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not this is a test line.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_comment&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not this is a comment. Comments will generally
only appear in the <small>TAP</small> stream if
<small>STDERR</small> is merged to <small>STDOUT.</small>
See the &quot;merge&quot; option.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_bailout&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not this is bailout line.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_yaml&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not the current item is a <small>YAML</small>
block.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_unknown&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Indicates
whether or not the current line could be parsed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_ok&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$result&minus;&gt;is_ok ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">Reports whether
or not a given result has passed. Anything which is
<b>not</b> a test result returns true. This is merely
provided as a convenient shortcut which allows you to do
this:</p>

<p style="margin-left:11%; margin-top: 1em">my $parser =
TAP::Parser&minus;&gt;new( { source =&gt; $source } ); <br>
while ( my $result = $parser&minus;&gt;next ) { <br>
# only print failing results <br>
print $result&minus;&gt;as_string unless
$result&minus;&gt;is_ok; <br>
}</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;plan&quot;
methods</b> <br>
if ( $result&minus;&gt;is_plan ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the $result object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;plan&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$result&minus;&gt;is_plan ) { <br>
print $result&minus;&gt;plan; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This is merely
a synonym for &quot;as_string&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;directive&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $directive =
$result&minus;&gt;directive;</p>

<p style="margin-left:11%; margin-top: 1em">If a
<small>SKIP</small> directive is included with the plan,
this method will return it.</p>

<p style="margin-left:11%; margin-top: 1em">1..0 # SKIP:
why bother?</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;explanation&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $explanation
= $result&minus;&gt;explanation;</p>

<p style="margin-left:11%; margin-top: 1em">If a
<small>SKIP</small> directive was included with the plan,
this method will return the explanation, if any.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;pragma&quot;
methods</b> <br>
if ( $result&minus;&gt;is_pragma ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the $result object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;pragmas&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns a list
of pragmas each of which is a + or &minus; followed by the
pragma name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;comment&quot;
methods</b> <br>
if ( $result&minus;&gt;is_comment ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the $result object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;comment&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$result&minus;&gt;is_comment ) { <br>
my $comment = $result&minus;&gt;comment; <br>
print &quot;I have something to say: $comment&quot;; <br>
}</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;bailout&quot;
methods</b> <br>
if ( $result&minus;&gt;is_bailout ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the $result object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;explanation&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$result&minus;&gt;is_bailout ) { <br>
my $explanation = $result&minus;&gt;explanation; <br>
print &quot;We bailed out because ($explanation)&quot;; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">If, and only
if, a token is a bailout token, you can get an
&quot;explanation&quot; via this method. The explanation is
the text after the mystical &quot;Bail out!&quot; words
which appear in the tap output.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;unknown&quot;
methods</b> <br>
if ( $result&minus;&gt;is_unknown ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">There are no
unique methods for unknown results.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;test&quot;
methods</b> <br>
if ( $result&minus;&gt;is_test ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">If the above
evaluates as true, the following methods will be available
on the $result object.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;ok&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $ok =
$result&minus;&gt;ok;</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
literal text of the &quot;ok&quot; or &quot;not ok&quot;
status.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;number&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $test_number
= $result&minus;&gt;number;</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
number of the test, even if the original <small>TAP</small>
output did not supply that number.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;description&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $description
= $result&minus;&gt;description;</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
description of the test, if any. This is the portion after
the test number but before the directive.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;directive&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $directive =
$result&minus;&gt;directive;</p>

<p style="margin-left:11%; margin-top: 1em">Returns either
&quot;TODO&quot; or &quot;SKIP&quot; if either directive was
present for a test line.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;explanation&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $explanation
= $result&minus;&gt;explanation;</p>

<p style="margin-left:11%; margin-top: 1em">If a test had
either a &quot;TODO&quot; or &quot;SKIP&quot; directive,
this method will return the accompanying explanation, if
present.</p>

<p style="margin-left:11%; margin-top: 1em">not ok 17
&minus; 'Pigs can fly' # TODO not enough acid</p>

<p style="margin-left:11%; margin-top: 1em">For the above
line, the explanation is <i>not enough acid</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_ok&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$result&minus;&gt;is_ok ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not the test passed.
Remember that for <small>TODO</small> tests, the test always
passes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
this was formerly &quot;passed&quot;. The latter method is
deprecated and will issue a warning.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_actual_ok&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$result&minus;&gt;is_actual_ok ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not the test passed,
regardless of its <small>TODO</small> status.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
this was formerly &quot;actual_passed&quot;. The latter
method is deprecated and will issue a warning.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_unplanned&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$test&minus;&gt;is_unplanned ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">If a test
number is greater than the number of planned tests, this
method will return true. Unplanned tests will <i>always</i>
return false for &quot;is_ok&quot;, regardless of whether or
not the test &quot;has_todo&quot; (see
TAP::Parser::Result::Test for more information about
this).</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;has_skip&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$result&minus;&gt;has_skip ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not this test had a
<small>SKIP</small> directive.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;has_todo&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$result&minus;&gt;has_todo ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not this test had a
<small>TODO</small> directive.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
<small>TODO</small> tests <i>always</i> pass. If you need to
know whether or not they really passed, check the
&quot;is_actual_ok&quot; method.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;in_todo&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$parser&minus;&gt;in_todo ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">True while the
most recent result was a <small>TODO.</small> Becomes true
before the <small>TODO</small> result is returned and stays
true until just before the next non&minus;
<small>TODO</small> test is returned.</p>

<h2>TOTAL RESULTS
<a name="TOTAL RESULTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">After parsing
the <small>TAP,</small> there are many methods available to
let you dig through the results and determine what is
meaningful to you.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Individual
Results</b> <br>
These results refer to individual tests which are run.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;passed&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my @passed =
$parser&minus;&gt;passed; # the test numbers which passed
<br>
my $passed = $parser&minus;&gt;passed; # the number of tests
which passed</p>

<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests passed. If a test
failed but had a <small>TODO</small> directive, it will be
counted as a passed test.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;failed&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my @failed =
$parser&minus;&gt;failed; # the test numbers which failed
<br>
my $failed = $parser&minus;&gt;failed; # the number of tests
which failed</p>

<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests failed. If a test
passed but had a <small>TODO</small> directive, it will
<b><small>NOT</small></b> be counted as a failed test.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;actual_passed&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em"># the test
numbers which actually passed <br>
my @actual_passed = $parser&minus;&gt;actual_passed; <br>
# the number of tests which actually passed <br>
my $actual_passed = $parser&minus;&gt;actual_passed;</p>

<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests actually passed,
regardless of whether or not a <small>TODO</small> directive
was found.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;actual_ok&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">This method is
a synonym for &quot;actual_passed&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;actual_failed&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em"># the test
numbers which actually failed <br>
my @actual_failed = $parser&minus;&gt;actual_failed; <br>
# the number of tests which actually failed <br>
my $actual_failed = $parser&minus;&gt;actual_failed;</p>

<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests actually failed,
regardless of whether or not a <small>TODO</small> directive
was found.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;todo&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my @todo =
$parser&minus;&gt;todo; # the test numbers with todo
directives <br>
my $todo = $parser&minus;&gt;todo; # the number of tests
with todo directives</p>

<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests had
<small>TODO</small> directives.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;todo_passed&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em"># the test
numbers which unexpectedly succeeded <br>
my @todo_passed = $parser&minus;&gt;todo_passed; <br>
# the number of tests which unexpectedly succeeded <br>
my $todo_passed = $parser&minus;&gt;todo_passed;</p>

<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests actually passed but
were declared as &quot; <small>TODO&quot;</small> tests.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;todo_failed&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em"># deprecated in
favor of 'todo_passed'. This method was horribly
misnamed.</p>

<p style="margin-left:11%; margin-top: 1em">This was a
badly misnamed method. It indicates which
<small>TODO</small> tests unexpectedly succeeded. Will now
issue a warning and call &quot;todo_passed&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;skipped&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my @skipped =
$parser&minus;&gt;skipped; # the test numbers with SKIP
directives <br>
my $skipped = $parser&minus;&gt;skipped; # the number of
tests with SKIP directives</p>

<p style="margin-left:11%; margin-top: 1em">This method
lets you know which (or how many) tests had
<small>SKIP</small> directives.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Pragmas</b>
<i><br>
&quot;pragma&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Get or set a
pragma. To get the state of a pragma:</p>

<p style="margin-left:11%; margin-top: 1em">if (
$p&minus;&gt;pragma('strict') ) { <br>
# be strict <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">To set the
state of a pragma:</p>


<p style="margin-left:11%; margin-top: 1em">$p&minus;&gt;pragma('strict',
1); # enable strict mode</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;pragmas&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Get a list of
all the currently enabled pragmas:</p>

<p style="margin-left:11%; margin-top: 1em">my
@pragmas_enabled = $p&minus;&gt;pragmas;</p>

<p style="margin-left:11%; margin-top: 1em"><b>Summary
Results</b> <br>
These results are &quot;meta&quot; information about the
total results of an individual test program.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;plan&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my $plan =
$parser&minus;&gt;plan;</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
test plan, if found.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;good_plan&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Deprecated. Use
&quot;is_good_plan&quot; instead.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;is_good_plan&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$parser&minus;&gt;is_good_plan ) { ... }</p>

<p style="margin-left:11%; margin-top: 1em">Returns a
boolean value indicating whether or not the number of tests
planned matches the number of tests run.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Note:</b>
this was formerly &quot;good_plan&quot;. The latter method
is deprecated and will issue a warning.</p>

<p style="margin-left:11%; margin-top: 1em">And since
we&rsquo;re on that subject ...</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;tests_planned&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">print
$parser&minus;&gt;tests_planned;</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
number of tests planned, according to the plan. For example,
a plan of &rsquo;1..17&rsquo; will mean that 17 tests were
planned.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;tests_run&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">print
$parser&minus;&gt;tests_run;</p>

<p style="margin-left:11%; margin-top: 1em">Returns the
number of tests which actually were run. Hopefully this will
match the number of
&quot;$parser&minus;&gt;tests_planned&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;skip_all&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns a true
value (actually the reason for skipping) if all tests were
skipped.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;start_time&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
wall-clock time when the Parser was created.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;end_time&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
wall-clock time when the end of <small>TAP</small> input was
seen.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;start_times&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
<small>CPU</small> times (like &quot;times&quot; in perlfunc
when the Parser was created.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;end_times&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Returns the
<small>CPU</small> times (like &quot;times&quot; in perlfunc
when the end of <small>TAP</small> input was seen.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;has_problems&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">if (
$parser&minus;&gt;has_problems ) { <br>
... <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This is a
&rsquo;catch&minus;all&rsquo; method which returns true if
any tests have currently failed, any <small>TODO</small>
tests unexpectedly succeeded, or any parse errors
occurred.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;version&quot;</i></p>


<p style="margin-left:11%; margin-top: 1em">$parser&minus;&gt;version;</p>

<p style="margin-left:11%; margin-top: 1em">Once the parser
is done, this will return the version number for the parsed
<small>TAP.</small> Version numbers were introduced with
<small>TAP</small> version 13 so if no version number is
found version 12 is assumed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;exit&quot;</i></p>


<p style="margin-left:11%; margin-top: 1em">$parser&minus;&gt;exit;</p>

<p style="margin-left:11%; margin-top: 1em">Once the parser
is done, this will return the exit status. If the parser ran
an executable, it returns the exit status of the
executable.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;wait&quot;</i></p>


<p style="margin-left:11%; margin-top: 1em">$parser&minus;&gt;wait;</p>

<p style="margin-left:11%; margin-top: 1em">Once the parser
is done, this will return the wait status. If the parser ran
an executable, it returns the wait status of the executable.
Otherwise, this merely returns the &quot;exit&quot;
status.</p>


<p style="margin-left:11%; margin-top: 1em"><b>&quot;ignore_exit&quot;</b>
<br>
$parser&minus;&gt;ignore_exit(1);</p>

<p style="margin-left:11%; margin-top: 1em">Tell the parser
to ignore the exit status from the test when determining
whether the test passed. Normally tests with non-zero exit
status are considered to have failed even if all individual
tests passed. In cases where it is not possible to control
the exit value of the test script use this option to ignore
it.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;parse_errors&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">my @errors =
$parser&minus;&gt;parse_errors; # the parser errors <br>
my $errors = $parser&minus;&gt;parse_errors; # the number of
parser_errors</p>

<p style="margin-left:11%; margin-top: 1em">Fortunately,
all <small>TAP</small> output is perfect. In the event that
it is not, this method will return parser errors. Note that
a junk line which the parser does not recognize is
&quot;not&quot; an error. This allows this parser to handle
future versions of <small>TAP.</small> The following are all
<small>TAP</small> errors reported by the parser:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="21%">


<p style="margin-top: 1em">Misplaced plan</p></td>
<td width="62%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">The plan (for
example, &rsquo;1..5&rsquo;), must only come at the
beginning or end of the <small>TAP</small> output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="11%">


<p style="margin-top: 1em">No plan</p></td>
<td width="72%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Gotta have a
plan!</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p style="margin-top: 1em">More than one plan</p></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">1..3 <br>
ok 1 &minus; input file opened <br>
not ok 2 &minus; first line of the input valid # todo some
data <br>
ok 3 read the rest of the file <br>
1..3</p>

<p style="margin-left:17%; margin-top: 1em">Right. Very
funny. Don&rsquo;t do that.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="43%">


<p style="margin-top: 1em">Test numbers out of sequence</p></td>
<td width="40%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">1..3 <br>
ok 1 &minus; input file opened <br>
not ok 2 &minus; first line of the input valid # todo some
data <br>
ok 2 read the rest of the file</p>

<p style="margin-left:17%; margin-top: 1em">That last test
line above should have the number &rsquo;3&rsquo; instead of
&rsquo;2&rsquo;.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
it&rsquo;s perfectly acceptable for some lines to have test
numbers and others to not have them. However, when a test
number is found, it must be in sequence. The following is
also an error:</p>

<p style="margin-left:17%; margin-top: 1em">1..3 <br>
ok 1 &minus; input file opened <br>
not ok &minus; first line of the input valid # todo some
data <br>
ok 2 read the rest of the file</p>

<p style="margin-left:17%; margin-top: 1em">But this is
not:</p>

<p style="margin-left:17%; margin-top: 1em">1..3 <br>
ok &minus; input file opened <br>
not ok &minus; first line of the input valid # todo some
data <br>
ok 3 read the rest of the file</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;get_select_handles&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Get an a list
of file handles which can be passed to &quot;select&quot; to
determine the readiness of this parser.</p>


<p style="margin-left:11%; margin-top: 1em"><i>&quot;delete_spool&quot;</i></p>

<p style="margin-left:11%; margin-top: 1em">Delete and
return the spool.</p>

<p style="margin-left:11%; margin-top: 1em">my $fh =
$parser&minus;&gt;delete_spool;</p>

<h2>CALLBACKS
<a name="CALLBACKS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As mentioned
earlier, a &quot;callback&quot; key may be added to the
&quot;TAP::Parser&quot; constructor. If present, each
callback corresponding to a given result type will be called
with the result as the argument if the &quot;run&quot;
method is used. The callback is expected to be a subroutine
reference (or anonymous subroutine) which is invoked with
the parser result as its argument.</p>

<p style="margin-left:11%; margin-top: 1em">my %callbacks =
( <br>
test =&gt; \&amp;test_callback, <br>
plan =&gt; \&amp;plan_callback, <br>
comment =&gt; \&amp;comment_callback, <br>
bailout =&gt; \&amp;bailout_callback, <br>
unknown =&gt; \&amp;unknown_callback, <br>
); <br>
my $aggregator = TAP::Parser::Aggregator&minus;&gt;new; <br>
for my $file ( @test_files ) { <br>
my $parser = TAP::Parser&minus;&gt;new( <br>
{ <br>
source =&gt; $file, <br>
callbacks =&gt; \%callbacks, <br>
} <br>
); <br>
$parser&minus;&gt;run; <br>
$aggregator&minus;&gt;add( $file, $parser ); <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Callbacks may
also be added like this:</p>


<p style="margin-left:11%; margin-top: 1em">$parser&minus;&gt;callback(
test =&gt; \&amp;test_callback ); <br>
$parser&minus;&gt;callback( plan =&gt; \&amp;plan_callback
);</p>

<p style="margin-left:11%; margin-top: 1em">The following
keys allowed for callbacks. These keys are
case-sensitive.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em">&quot;test&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
&quot;$result&minus;&gt;is_test&quot; returns true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em">&quot;version&quot;</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
&quot;$result&minus;&gt;is_version&quot; returns true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em">&quot;plan&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
&quot;$result&minus;&gt;is_plan&quot; returns true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em">&quot;comment&quot;</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
&quot;$result&minus;&gt;is_comment&quot; returns true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em">&quot;bailout&quot;</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
&quot;$result&minus;&gt;is_unknown&quot; returns true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em">&quot;yaml&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
&quot;$result&minus;&gt;is_yaml&quot; returns true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="14%">


<p style="margin-top: 1em">&quot;unknown&quot;</p></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked if
&quot;$result&minus;&gt;is_unknown&quot; returns true.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="9%">


<p style="margin-top: 1em">&quot;ELSE&quot;</p></td>
<td width="74%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If a result
does not have a callback defined for it, this callback will
be invoked. Thus, if all of the previous result types are
specified as callbacks, this callback will <i>never</i> be
invoked.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em">&quot;ALL&quot;</p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">This callback
will always be invoked and this will happen for each result
after one of the above callbacks is invoked. For example, if
Term::ANSIColor is loaded, you could use the following to
color your test output:</p>

<p style="margin-left:17%; margin-top: 1em">my %callbacks =
( <br>
test =&gt; sub { <br>
my $test = shift; <br>
if ( $test&minus;&gt;is_ok &amp;&amp; not
$test&minus;&gt;directive ) { <br>
# normal passing test <br>
print color 'green'; <br>
} <br>
elsif ( !$test&minus;&gt;is_ok ) { # even if it's TODO <br>
print color 'white on_red'; <br>
} <br>
elsif ( $test&minus;&gt;has_skip ) { <br>
print color 'white on_blue'; <br>
} <br>
elsif ( $test&minus;&gt;has_todo ) { <br>
print color 'white'; <br>
} <br>
}, <br>
ELSE =&gt; sub { <br>
# plan, comment, and so on (anything which isn't a test
line) <br>
print color 'black on_white'; <br>
}, <br>
ALL =&gt; sub { <br>
# now print them <br>
print shift&minus;&gt;as_string; <br>
print color 'reset'; <br>
print &quot;\n&quot;; <br>
}, <br>
);</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="8%">


<p style="margin-top: 1em">&quot;EOF&quot;</p></td>
<td width="75%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">Invoked when
there are no more lines to be parsed. Since there is no
accompanying TAP::Parser::Result object the
&quot;TAP::Parser&quot; object is passed instead.</p>

<h2>TAP GRAMMAR
<a name="TAP GRAMMAR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
looking for an <small>EBNF</small> grammar, see
TAP::Parser::Grammar.</p>

<h2>BACKWARDS COMPATIBILITY
<a name="BACKWARDS COMPATIBILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Perl-QA
list attempted to ensure backwards compatibility with
Test::Harness. However, there are some minor
differences.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Differences</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="15%">


<p style="margin-top: 1em"><small>TODO</small> plans</p></td>
<td width="68%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">A little-known
feature of Test::Harness is that it supported
<small>TODO</small> lists in the plan:</p>

<p style="margin-left:17%; margin-top: 1em">1..2 todo 2
<br>
ok 1 &minus; We have liftoff <br>
not ok 2 &minus; Anti&minus;gravity device activated</p>

<p style="margin-left:17%; margin-top: 1em">Under
Test::Harness, test number 2 would <i>pass</i> because it
was listed as a <small>TODO</small> test on the plan line.
However, we are not aware of anyone actually using this
feature and hard-coding test numbers is discouraged because
it&rsquo;s very easy to add a test and break the test number
sequence. This makes test suites very fragile. Instead, the
following should be used:</p>

<p style="margin-left:17%; margin-top: 1em">1..2 <br>
ok 1 &minus; We have liftoff <br>
not ok 2 &minus; Anti&minus;gravity device activated #
TODO</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="23%">


<p style="margin-top: 1em">&rsquo;Missing&rsquo; tests</p></td>
<td width="60%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">It rarely
happens, but sometimes a harness might encounter
&rsquo;missing tests:</p>

<p style="margin-left:17%; margin-top: 1em">ok 1 <br>
ok 2 <br>
ok 15 <br>
ok 16 <br>
ok 17</p>

<p style="margin-left:17%; margin-top: 1em">Test::Harness
would report tests 3&minus;14 as having failed. For the
&quot;TAP::Parser&quot;, these tests are not considered
failed because they&rsquo;ve never run. They&rsquo;re
reported as parse failures (tests out of sequence).</p>

<h2>SUBCLASSING
<a name="SUBCLASSING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">If you find you
need to provide custom functionality (as you would have
using Test::Harness::Straps), you&rsquo;re in luck:
&quot;TAP::Parser&quot; and friends are designed to be
easily plugged-into and/or subclassed.</p>

<p style="margin-left:11%; margin-top: 1em">Before you
start, it&rsquo;s important to know a few things: <br>
1.</p>

<p style="margin-left:14%;">All &quot;TAP::*&quot; objects
inherit from TAP::Object.</p>

<p style="margin-left:11%;">2.</p>

<p style="margin-left:14%;">Many &quot;TAP::*&quot; classes
have a <i><small>SUBCLASSING</small></i> section to guide
you.</p>

<p style="margin-left:11%;">3.</p>

<p style="margin-left:14%;">Note that
&quot;TAP::Parser&quot; is designed to be the central
&quot;maker&quot; &minus; ie: it is responsible for creating
most new objects in the &quot;TAP::Parser::*&quot;
namespace.</p>

<p style="margin-left:14%; margin-top: 1em">This makes it
possible for you to have a single point of configuring what
subclasses should be used, which means that in many cases
you&rsquo;ll find you only need to sub-class one of the
parser&rsquo;s components.</p>

<p style="margin-left:14%; margin-top: 1em">The exception
to this rule are <i>SourceHandlers</i> &amp;
<i>Iterators</i>, but those are both created with
customizable <i>IteratorFactory</i>.</p>

<p style="margin-left:11%;">4.</p>

<p style="margin-left:14%;">By subclassing, you may end up
overriding undocumented methods. That&rsquo;s not a bad
thing per se, but be forewarned that undocumented methods
may change without warning from one release to the next
&minus; we cannot guarantee backwards compatibility. If any
<i>documented</i> method needs changing, it will be
deprecated first, and changed in a later release.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Parser
Components</b> <i><br>
Sources</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<small>TAP</small> parser consumes input from a single
<i>raw source</i> of <small>TAP,</small> which could come
from anywhere (a file, an executable, a database, an
<small>IO</small> handle, a <small>URI,</small> etc..). The
source gets bundled up in a TAP::Parser::Source object which
gathers some meta data about it. The parser then uses a
TAP::Parser::IteratorFactory to determine which
TAP::Parser::SourceHandler to use to turn the raw source
into a stream of <small>TAP</small> by way of
&quot;Iterators&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If you simply
want &quot;TAP::Parser&quot; to handle a new source of
<small>TAP</small> you probably don&rsquo;t need to subclass
&quot;TAP::Parser&quot; itself. Rather, you&rsquo;ll need to
create a new TAP::Parser::SourceHandler class, and just plug
it into the parser using the <i>sources</i> param to
&quot;new&quot;. Before you start writing one, read through
TAP::Parser::IteratorFactory to get a feel for how the
system works first.</p>

<p style="margin-left:11%; margin-top: 1em">If you find you
really need to use your own iterator factory you can still
do so without sub-classing &quot;TAP::Parser&quot; by
setting &quot;iterator_factory_class&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If you just
need to customize the objects on creation, subclass
TAP::Parser and override
&quot;make_iterator_factory&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;make_source&quot; &amp; &quot;make_perl_source&quot;
have been <i><small>DEPRECATED</small></i> and are now
removed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Iterators</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<small>TAP</small> parser uses <i>iterators</i> to loop
through the <i>stream</i> of <small>TAP</small> read in from
the <i>source</i> it was given. There are a few types of
Iterators available by default, all sub-classes of
TAP::Parser::Iterator. Choosing which iterator to use is the
responsibility of the <i>iterator factory</i>, though it
simply delegates to the <i>Source Handler</i> it uses.</p>

<p style="margin-left:11%; margin-top: 1em">If you&rsquo;re
writing your own TAP::Parser::SourceHandler, you may need to
create your own iterators too. If so you&rsquo;ll need to
subclass TAP::Parser::Iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
&quot;make_iterator&quot; has been
<i><small>DEPRECATED</small></i> and is now removed.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Results</i></p>

<p style="margin-left:11%; margin-top: 1em">A
<small>TAP</small> parser creates TAP::Parser::Results as it
iterates through the input <i>stream</i>. There are quite a
few result types available; choosing which class to use is
the responsibility of the <i>result factory</i>.</p>

<p style="margin-left:11%; margin-top: 1em">To create your
own result types you have two options: <br>
option 1</p>

<p style="margin-left:14%;">Subclass TAP::Parser::Result
and register your new result type/class with the default
TAP::Parser::ResultFactory.</p>

<p style="margin-left:11%;">option 2</p>

<p style="margin-left:14%;">Subclass
TAP::Parser::ResultFactory itself and implement your own
TAP::Parser::Result creation logic. Then you&rsquo;ll need
to customize the class used by your parser by setting the
&quot;result_factory_class&quot; parameter. See
&quot;new&quot; for more details.</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
customize the objects on creation, subclass TAP::Parser and
override &quot;make_result&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Grammar</i></p>


<p style="margin-left:11%; margin-top: 1em">TAP::Parser::Grammar
is the heart of the parser. It tokenizes the
<small>TAP</small> input <i>stream</i> and produces results.
If you need to customize its behaviour you should probably
familiarize yourself with the source first. Enough
lecturing.</p>

<p style="margin-left:11%; margin-top: 1em">Subclass
TAP::Parser::Grammar and customize your parser by setting
the &quot;grammar_class&quot; parameter. See &quot;new&quot;
for more details.</p>

<p style="margin-left:11%; margin-top: 1em">If you need to
customize the objects on creation, subclass TAP::Parser and
override &quot;make_grammar&quot;</p>

<h2>ACKNOWLEDGMENTS
<a name="ACKNOWLEDGMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All of the
following have helped. Bug reports, patches, (im)moral
support, or just words of encouragement have all been
forthcoming.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Michael Schwern</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Andy Lester</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>chromatic</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p><small>GEOFFR</small></p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Shlomi Fish</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Torsten Schoenfeld</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Jerry Gay</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Aristotle</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Adam Kennedy</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Yves Orton</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Adrian Howard</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Sean &amp; Lil</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Andreas J. Koenig</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Florian Ragwitz</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Corion</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Mark Stosberg</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Matt Kraai</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>David Wheeler</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Alex Vandiver</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Cosimo Streppone</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="28%">


<p>Ville Skyttae</p></td>
<td width="55%">
</td></tr>
</table>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Curtis
&quot;Ovid&quot; Poe &lt;ovid@cpan.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Andy Armstong
&lt;andy@hexten.net&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Eric Wilhelm @
&lt;ewilhelm at cpan dot org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Michael Peters
&lt;mpeters at plusthree dot com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Leif Eriksen
&lt;leif dot eriksen at bigpond dot com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Steve Purkis
&lt;spurkis@cpan.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Nicholas Clark
&lt;nick@ccl4.org&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Lee Johnson
&lt;notfadeaway at btinternet dot com&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Philippe Bruhat
&lt;book@cpan.org&gt;</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Please report
any bugs or feature requests to
&quot;bug&minus;test&minus;harness@rt.cpan.org&quot;, or
through the web interface at
&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test&minus;Harness&gt;.
We will be notified, and then you&rsquo;ll automatically be
notified of progress on your bug as we make changes.</p>

<p style="margin-left:11%; margin-top: 1em">Obviously, bugs
which include patches are best. If you prefer, you can patch
against bleed by via anonymous checkout of the latest
version:</p>

<p style="margin-left:11%; margin-top: 1em">git clone
git://github.com/Perl&minus;Toolchain&minus;Gang/Test&minus;Harness.git</p>

<h2>COPYRIGHT &amp; LICENSE
<a name="COPYRIGHT &amp; LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2006&minus;2008 Curtis &quot;Ovid&quot; Poe, all rights
reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
