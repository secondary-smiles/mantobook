<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:22 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>BN_ADD</title>

</head>
<body>
<h1>BN_add</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">BN_add, BN_sub,
BN_mul, BN_sqr, BN_div, BN_mod, BN_nnmod, BN_mod_add,
BN_mod_sub, BN_mod_mul, BN_mod_sqr, BN_mod_sqrt, BN_exp,
BN_mod_exp, BN_gcd &minus; arithmetic operations on
BIGNUMs</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/bn.h&gt; <br>
int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
<br>
int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
<br>
int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
<br>
int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx); <br>
int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const
BIGNUM *d, <br>
BN_CTX *ctx); <br>
int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m,
BN_CTX *ctx); <br>
int BN_nnmod(BIGNUM *r, const BIGNUM *a, const BIGNUM *m,
BN_CTX *ctx); <br>
int BN_mod_add(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM
*m, <br>
BN_CTX *ctx); <br>
int BN_mod_sub(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM
*m, <br>
BN_CTX *ctx); <br>
int BN_mod_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM
*m, <br>
BN_CTX *ctx); <br>
int BN_mod_sqr(BIGNUM *r, BIGNUM *a, const BIGNUM *m, BN_CTX
*ctx); <br>
BIGNUM *BN_mod_sqrt(BIGNUM *in, BIGNUM *a, const BIGNUM *p,
BN_CTX *ctx); <br>
int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);
<br>
int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p, <br>
const BIGNUM *m, BN_CTX *ctx); <br>
int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX
*ctx);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>BN_add()</b>
adds <i>a</i> and <i>b</i> and places the result in <i>r</i>
(&quot;r=a+b&quot;). <i>r</i> may be the same
<b><small>BIGNUM</small></b> as <i>a</i> or <i>b</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_sub()</b>
subtracts <i>b</i> from <i>a</i> and places the result in
<i>r</i> (&quot;r=a&minus;b&quot;). <i>r</i> may be the same
<b><small>BIGNUM</small></b> as <i>a</i> or <i>b</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_mul()</b>
multiplies <i>a</i> and <i>b</i> and places the result in
<i>r</i> (&quot;r=a*b&quot;). <i>r</i> may be the same
<b><small>BIGNUM</small></b> as <i>a</i> or <i>b</i>. For
multiplication by powers of 2, use <b>BN_lshift</b>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_sqr()</b>
takes the square of <i>a</i> and places the result in
<i>r</i> (&quot;r=a^2&quot;). <i>r</i> and <i>a</i> may be
the same <b><small>BIGNUM</small></b> . This function is
faster than BN_mul(r,a,a).</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_div()</b>
divides <i>a</i> by <i>d</i> and places the result in
<i>dv</i> and the remainder in <i>rem</i> (&quot;dv=a/d,
rem=a%d&quot;). Either of <i>dv</i> and <i>rem</i> may be
<b><small>NULL</small></b> , in which case the respective
value is not returned. The result is rounded towards zero;
thus if <i>a</i> is negative, the remainder will be zero or
negative. For division by powers of 2, use
<b>BN_rshift</b>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_mod()</b>
corresponds to <b>BN_div()</b> with <i>dv</i> set to
<b><small>NULL</small></b> .</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_nnmod()</b>
reduces <i>a</i> modulo <i>m</i> and places the nonnegative
remainder in <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_mod_add()</b>
adds <i>a</i> to <i>b</i> modulo <i>m</i> and places the
nonnegative result in <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_mod_sub()</b>
subtracts <i>b</i> from <i>a</i> modulo <i>m</i> and places
the nonnegative result in <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_mod_mul()</b>
multiplies <i>a</i> by <i>b</i> and finds the nonnegative
remainder respective to modulus <i>m</i> (&quot;r=(a*b) mod
m&quot;). <i>r</i> may be the same
<b><small>BIGNUM</small></b> as <i>a</i> or <i>b</i>. For
more efficient algorithms for repeated computations using
the same modulus, see <b>BN_mod_mul_montgomery</b>(3) and
<b>BN_mod_mul_reciprocal</b>(3).</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_mod_sqr()</b>
takes the square of <i>a</i> modulo <b>m</b> and places the
result in <i>r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_mod_sqrt()</b>
returns the modular square root of <i>a</i> such that
&quot;in^2 = a (mod p)&quot;. The modulus <i>p</i> must be a
prime, otherwise an error or an incorrect &quot;result&quot;
will be returned. The result is stored into <i>in</i> which
can be <small>NULL.</small> The result will be newly
allocated in that case.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_exp()</b>
raises <i>a</i> to the <i>p</i>&minus;th power and places
the result in <i>r</i> (&quot;r=a^p&quot;). This function is
faster than repeated applications of <b>BN_mul()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_mod_exp()</b>
computes <i>a</i> to the <i>p</i>&minus;th power modulo
<i>m</i> (&quot;r=a^p % m&quot;). This function uses less
time and space than <b>BN_exp()</b>. Do not call this
function when <b>m</b> is even and any of the parameters
have the <b><small>BN_FLG_CONSTTIME</small></b> flag
set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>BN_gcd()</b>
computes the greatest common divisor of <i>a</i> and
<i>b</i> and places the result in <i>r</i>. <i>r</i> may be
the same <b><small>BIGNUM</small></b> as <i>a</i> or
<i>b</i>.</p>

<p style="margin-left:11%; margin-top: 1em">For all
functions, <i>ctx</i> is a previously allocated
<b><small>BN_CTX</small></b> used for temporary variables;
see <b>BN_CTX_new</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">Unless noted
otherwise, the result <b><small>BIGNUM</small></b> must be
different from the arguments.</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>BN_mod_sqrt()</b> returns the result (possibly incorrect
if <i>p</i> is not a prime), or <small>NULL.</small></p>

<p style="margin-left:11%; margin-top: 1em">For all
remaining functions, 1 is returned for success, 0 on error.
The return value should always be checked (e.g., &quot;if
(!BN_add(r,a,b)) goto err;&quot;). The error codes can be
obtained by <b>ERR_get_error</b>(3).</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ERR_get_error</b>(3),
<b>BN_CTX_new</b>(3), <b>BN_add_word</b>(3),
<b>BN_set_bit</b>(3)</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2000&minus;2022 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
