<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:34 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>MPI_File_open</title>

</head>
<body>
<h1>MPI_File_open</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>MPI_File_open</b>
&minus; Opens a file (collective).</p>

<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<h2>C Syntax
<a name="C Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
int MPI_File_open(MPI_Comm <i>comm</i>, const char
<i>*filename</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>int <i>amode</i>, MPI_Info <i>info</i>,</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>MPI_File <i>*fh</i>)</p></td></tr>
</table>

<h2>Fortran Syntax
<a name="Fortran Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE MPI <br>
! or the older form: INCLUDE &rsquo;mpif.h&rsquo; <br>
MPI_FILE_OPEN(<i>COMM</i>, <i>FILENAME</i>, <i>AMODE</i>,
<i>INFO</i>, <i>FH</i>, <i>IERROR</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>CHARACTER*(*)</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">


<p><i>FILENAME</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%"></td>
<td width="62%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">


<p>INTEGER</p></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="7%">


<p><i>COMM, AMODE, INFO, FH, IERROR</i></p></td>
<td width="62%">
</td></tr>
</table>

<h2>Fortran 2008 Syntax
<a name="Fortran 2008 Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">USE mpi_f08
<br>
MPI_File_open(<i>comm</i>, <i>filename</i>, <i>amode</i>,
<i>info</i>, <i>fh</i>, <i>ierror</i>)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Comm), INTENT(IN) :: <i>comm</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>CHARACTER(LEN=*), INTENT(IN) :: <i>filename</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, INTENT(IN) :: <i>amode</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_Info), INTENT(IN) :: <i>info</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>TYPE(MPI_File), INTENT(OUT) :: <i>fh</i></p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>INTEGER, OPTIONAL, INTENT(OUT) :: <i>ierror</i></p></td></tr>
</table>

<h2>C++ Syntax
<a name="C++ Syntax"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;mpi.h&gt; <br>
static MPI::File MPI::File::Open(const MPI::Intracomm&amp;
<i>comm</i>,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>const char* <i>filename</i>, int <i>amode</i>, const
MPI::Info&amp; <i>info</i>)</p></td></tr>
</table>

<h2>INPUT PARAMETERS
<a name="INPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p style="margin-top: 1em">comm</p></td>
<td width="3%"></td>
<td width="46%">


<p style="margin-top: 1em">Communicator (handle).</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>filename</p></td>
<td width="3%"></td>
<td width="46%">


<p>Name of file to open (string).</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>amode</p></td>
<td width="3%"></td>
<td width="46%">


<p>File access mode (integer).</p></td>
<td width="28%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="12%">


<p>info</p></td>
<td width="3%"></td>
<td width="46%">


<p>Info object (handle).</p></td>
<td width="28%">
</td></tr>
</table>

<h2>OUTPUT PARAMETERS
<a name="OUTPUT PARAMETERS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em">fh</p></td>
<td width="6%"></td>
<td width="57%">


<p style="margin-top: 1em">New file handle (handle).</p></td>
<td width="17%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>IERROR</p></td>
<td width="6%"></td>
<td width="57%">


<p>Fortran only: Error status (integer).</p></td>
<td width="17%">
</td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">MPI_File_open
opens the file identified by the filename <i>filename</i> on
all processes in the <i>comm</i> communicator group.
MPI_File_open is a collective routine; all processes must
provide the same value for <i>amode,</i> and all processes
must provide filenames that reference the same file which
are textually identical (note: Open MPI I/O plugins may have
restrictions on characters that can be used in filenames.
For example, the ROMIO plugin may disallow the colon
(&quot;:&quot;) character from appearing in a filename). A
process can open a file independently of other processes by
using the MPI_COMM_SELF communicator. The file handle
returned, <i>fh,</i> can be subsequently used to access the
file until the file is closed using MPI_File_close. Before
calling MPI_Finalize, the user is required to close (via
MPI_File_close) all files that were opened with
MPI_File_open. Note that the communicator <i>comm</i> is
unaffected by MPI_File_open and continues to be usable in
all MPI routines. Furthermore, use of <i>comm</i> will not
interfere with I/O behavior.</p>

<p style="margin-left:11%; margin-top: 1em">Initially, all
processes view the file as a linear byte stream; that is,
the <i>etype</i> and <i>filetype</i> are both MPI_BYTE. The
file view can be changed via the MPI_File_set_view
routine.</p>

<p style="margin-left:11%; margin-top: 1em">The following
access modes are supported (specified in amode, in a
bit-vector OR in one of the following integer
constants):</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p style="margin-top: 1em">o</p></td>
<td width="3%"></td>
<td width="82%">


<p style="margin-top: 1em">MPI_MODE_APPEND</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>o</p></td>
<td width="3%"></td>
<td width="82%">


<p>MPI_MODE_CREATE -- Create the file if it does not
exist.</p> </td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>o</p></td>
<td width="3%"></td>
<td width="82%">


<p>MPI_MODE_DELETE_ON_CLOSE</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>o</p></td>
<td width="3%"></td>
<td width="82%">


<p>MPI_MODE_EXCL -- Error creating a file that already
exists.</p> </td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>o</p></td>
<td width="3%"></td>
<td width="82%">


<p>MPI_MODE_RDONLY -- Read only.</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>o</p></td>
<td width="3%"></td>
<td width="82%">


<p>MPI_MODE_RDWR -- Reading and writing.</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>o</p></td>
<td width="3%"></td>
<td width="82%">


<p>MPI_MODE_SEQUENTIAL</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>o</p></td>
<td width="3%"></td>
<td width="82%">


<p>MPI_MODE_WRONLY -- Write only.</p></td></tr>
<tr valign="top" align="left">
<td width="14%"></td>
<td width="1%">


<p>o</p></td>
<td width="3%"></td>
<td width="82%">


<p>MPI_MODE_UNIQUE_OPEN</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The modes
MPI_MODE_RDONLY, MPI_MODE_RDWR, MPI_MODE_WRONLY, and
MPI_MODE_CREATE have identical semantics to their POSIX
counterparts. It is erroneous to specify MPI_MODE_CREATE in
conjunction with MPI_MODE_RDONLY. Errors related to the
access mode are raised in the class MPI_ERR_AMODE.</p>

<p style="margin-left:11%; margin-top: 1em">On single-node
clusters, files are opened by default using nonatomic mode
file consistency semantics. The more stringent atomic-mode
consistency semantics, required for atomicity of overlapping
accesses, are the default when processors in a communicator
group reside on more than one node. This setting can be
changed using MPI_File_set_atomicity.</p>

<p style="margin-left:11%; margin-top: 1em">The
MPI_File_open interface allows the user to pass information
via the <i>info</i> argument. It can be set to
MPI_INFO_NULL. See the HINTS section for a list of hints
that can be set.</p>

<h2>HINTS
<a name="HINTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
hints can be used as values for the <i>info</i>
argument.</p>

<p style="margin-left:11%; margin-top: 1em">SETTABLE
HINTS:</p>

<p style="margin-left:11%; margin-top: 1em">-
MPI_INFO_NULL</p>

<p style="margin-left:11%; margin-top: 1em">-
shared_file_timeout: Amount of time (in seconds) to wait for
access to the shared file pointer before exiting with
MPI_ERR_TIMEDOUT.</p>

<p style="margin-left:11%; margin-top: 1em">-
rwlock_timeout: Amount of time (in seconds) to wait for
obtaining a read or write lock on a contiguous chunk of a
UNIX file before exiting with MPI_ERR_TIMEDOUT.</p>

<p style="margin-left:11%; margin-top: 1em">-
noncoll_read_bufsize: Maximum size of the buffer used by MPI
I/O to satisfy multiple noncontiguous read requests in the
noncollective data-access routines. (See NOTE, below.)</p>

<p style="margin-left:11%; margin-top: 1em">-
noncoll_write_bufsize: Maximum size of the buffer used by
MPI I/O to satisfy multiple noncontiguous write requests in
the noncollective data-access routines. (See NOTE,
below.)</p>

<p style="margin-left:11%; margin-top: 1em">-
coll_read_bufsize: Maximum size of the buffer used by MPI
I/O to satisfy multiple noncontiguous read requests in the
collective data-access routines. (See NOTE, below.)</p>

<p style="margin-left:11%; margin-top: 1em">-
coll_write_bufsize: Maximum size of the buffer used by MPI
I/O to satisfy multiple noncontiguous write requests in the
collective data-access routines. (See NOTE, below.)</p>

<p style="margin-left:11%; margin-top: 1em">NOTE: A buffer
size smaller than the distance (in bytes) in a UNIX file
between the first byte and the last byte of the access
request causes MPI I/O to iterate and perform multiple UNIX
read() or write() calls. If the request includes multiple
noncontiguous chunks of data, and the buffer size is greater
than the size of those chunks, then the UNIX read() or
write() (made at the MPI I/O level) will access data not
requested by this process in order to reduce the total
number of write() calls made. If this is not desirable
behavior, you should reduce this buffer size to equal the
size of the contiguous chunks within the aggregate
request.</p>

<p style="margin-left:11%; margin-top: 1em">-
mpiio_concurrency: (boolean) controls whether nonblocking
I/O routines can bind an extra thread to an LWP.</p>

<p style="margin-left:11%; margin-top: 1em">-
mpiio_coll_contiguous: (boolean) controls whether subsequent
collective data accesses will request collectively
contiguous regions of the file.</p>

<p style="margin-left:11%; margin-top: 1em">NON-SETTABLE
HINTS:</p>

<p style="margin-left:11%; margin-top: 1em">- filename:
Access this hint to get the name of the file.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Almost all MPI
routines return an error value; C routines as the value of
the function and Fortran routines in the last argument. C++
functions do not return errors. If the default error handler
is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the
C++ exception mechanism will be used to throw an
MPI::Exception object.</p>

<p style="margin-left:11%; margin-top: 1em">Before the
error value is returned, the current MPI error handler is
called. For MPI I/O function errors, the default error
handler is set to MPI_ERRORS_RETURN. The error handler may
be changed with MPI_File_set_errhandler; the predefined
error handler MPI_ERRORS_ARE_FATAL may be used to make I/O
errors fatal. Note that MPI does not guarantee that an MPI
program can continue past an error.</p>
<hr>
</body>
</html>
