<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:14 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::shared_ptr&lt; _Tp &gt;</title>

</head>
<body>
<h1>std::shared_ptr</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::shared_ptr&lt;
_Tp &gt; &minus; A smart pointer with reference-counted copy
semantics.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;memory&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
std::__shared_ptr&lt; _Tp, _Lp &gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">using <b>element_type</b> =
typename __shared_ptr&lt; _Tp &gt;::element_type <br>
The type pointed to by the stored pointer,
remove_extent_t&lt;_Tp&gt; <br>
using <b>weak_type</b> = <b>weak_ptr</b>&lt; _Tp &gt; <br>
The corresponding weak_ptr type for this shared_ptr.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;">constexpr <b>shared_ptr</b> ()
noexcept <br>
Construct an empty shared_ptr. <br>
template&lt;typename _Yp , typename =
_Constructible&lt;_Yp*&gt;&gt; <b>shared_ptr</b> (_Yp *__p)
<br>
Construct a shared_ptr that owns the pointer <i>__p</i>.
<br>
template&lt;typename _Yp , typename _Deleter , typename =
_Constructible&lt;_Yp*, _Deleter&gt;&gt; <b>shared_ptr</b>
(_Yp *__p, _Deleter __d) <br>
Construct a shared_ptr that owns the pointer <i>__p</i> and
the deleter <i>__d</i>. <br>
template&lt;typename _Yp , typename _Deleter , typename
_Alloc , typename = _Constructible&lt;_Yp*, _Deleter,
_Alloc&gt;&gt; <b>shared_ptr</b> (_Yp *__p, _Deleter __d,
_Alloc __a) <br>
Construct a shared_ptr that owns the pointer <i>__p</i> and
the deleter <i>__d</i>. <br>
template&lt;typename _Yp , typename =
_Constructible&lt;auto_ptr&lt;_Yp&gt;&gt;&gt;
<b>shared_ptr</b> (<b>auto_ptr</b>&lt; _Yp &gt;
&amp;&amp;__r) <b><br>
shared_ptr</b> (const <b>shared_ptr</b> &amp;)
noexcept=default <br>
Copy constructor. <br>
template&lt;typename _Yp , typename =
_Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;
<b>shared_ptr</b> (const <b>shared_ptr</b>&lt; _Yp &gt;
&amp;__r) noexcept <br>
If <i>__r</i> is empty, constructs an empty shared_ptr;
otherwise construct a shared_ptr that shares ownership with
<i>__r</i>. <br>
template&lt;typename _Yp &gt; <b>shared_ptr</b> (const
<b>shared_ptr</b>&lt; _Yp &gt; &amp;__r, <b>element_type</b>
*__p) noexcept <br>
Constructs a <tt>shared_ptr</tt> instance that stores
<tt>__p</tt> and shares ownership with <tt>__r</tt>. <br>
template&lt;typename _Yp , typename =
_Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;
<b>shared_ptr</b> (const <b>weak_ptr</b>&lt; _Yp &gt;
&amp;__r) <br>
Constructs a shared_ptr that shares ownership with
<i>__r</i> and stores a copy of the pointer stored in
<i>__r</i>. <br>
template&lt;typename _Deleter &gt; <b>shared_ptr</b>
(nullptr_t __p, _Deleter __d) <br>
Construct a shared_ptr that owns a null pointer and the
deleter <i>__d</i>. <br>
template&lt;typename _Deleter , typename _Alloc &gt;
<b>shared_ptr</b> (nullptr_t __p, _Deleter __d, _Alloc __a)
<br>
Construct a shared_ptr that owns a null pointer and the
deleter <i>__d</i>. <br>
constexpr <b>shared_ptr</b> (nullptr_t) noexcept <br>
Construct an empty shared_ptr. <b><br>
shared_ptr</b> (<b>shared_ptr</b> &amp;&amp;__r) noexcept
<br>
Move-constructs a shared_ptr instance from <i>__r</i>. <br>
template&lt;typename _Yp , typename =
_Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt;
<b>shared_ptr</b> (<b>shared_ptr</b>&lt; _Yp &gt;
&amp;&amp;__r) noexcept <br>
Move-constructs a shared_ptr instance from <i>__r</i>. <br>
template&lt;typename _Yp &gt; <b>shared_ptr</b>
(<b>shared_ptr</b>&lt; _Yp &gt; &amp;&amp;__r,
<b>element_type</b> *__p) noexcept <br>
Constructs a <tt>shared_ptr</tt> instance that stores
<tt>__p</tt> and shares ownership with <tt>__r</tt>. <br>
template&lt;typename _Tp1 , typename &gt; <b>shared_ptr</b>
(<b>std::auto_ptr</b>&lt; _Tp1 &gt; &amp;&amp;__r) <br>
template&lt;typename _Yp , typename _Del , typename =
_Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;&gt;
<b>shared_ptr</b> (<b>unique_ptr</b>&lt; _Yp, _Del &gt;
&amp;&amp;__r) <b><br>
element_type</b> * <b>get</b> () const noexcept <br>
Return the stored pointer. <b><br>
operator bool</b> () const noexcept <br>
Return true if the stored pointer is not null. <b><br>
element_type</b> &amp; <b>operator*</b> () const noexcept
<b><br>
element_type</b> * <b>operator&minus;&gt;</b> () const
noexcept <br>
template&lt;typename _Yp &gt; _Assignable&lt;
<b>auto_ptr</b>&lt; _Yp &gt; &gt; <b>operator=</b>
(<b>auto_ptr</b>&lt; _Yp &gt; &amp;&amp;__r) <b><br>
shared_ptr</b> &amp; <b>operator=</b> (const
<b>shared_ptr</b> &amp;) noexcept=default <br>
template&lt;typename _Yp &gt; _Assignable&lt; const
<b>shared_ptr</b>&lt; _Yp &gt; &amp; &gt; <b>operator=</b>
(const <b>shared_ptr</b>&lt; _Yp &gt; &amp;__r) noexcept
<b><br>
shared_ptr</b> &amp; <b>operator=</b> (<b>shared_ptr</b>
&amp;&amp;__r) noexcept <br>
template&lt;class _Yp &gt; _Assignable&lt;
<b>shared_ptr</b>&lt; _Yp &gt; &gt; <b>operator=</b>
(<b>shared_ptr</b>&lt; _Yp &gt; &amp;&amp;__r) noexcept <br>
template&lt;typename _Yp , typename _Del &gt;
_Assignable&lt; <b>unique_ptr</b>&lt; _Yp, _Del &gt; &gt;
<b>operator=</b> (<b>unique_ptr</b>&lt; _Yp, _Del &gt;
&amp;&amp;__r) <br>
void <b>reset</b> () noexcept <br>
template&lt;typename _Yp &gt; _SafeConv&lt; _Yp &gt;
<b>reset</b> (_Yp *__p) <br>
template&lt;typename _Yp , typename _Deleter &gt;
_SafeConv&lt; _Yp &gt; <b>reset</b> (_Yp *__p, _Deleter __d)
<br>
template&lt;typename _Yp , typename _Deleter , typename
_Alloc &gt; _SafeConv&lt; _Yp &gt; <b>reset</b> (_Yp *__p,
_Deleter __d, _Alloc __a) <br>
void <b>swap</b> (__shared_ptr&lt; _Tp, _Lp &gt;
&amp;__other) noexcept <br>
Exchange both the owned pointer and the stored pointer. <br>
bool <b>unique</b> () const noexcept <br>
Return true if use_count() == 1. <br>
long <b>use_count</b> () const noexcept <br>
If *this owns a pointer, return the number of owners,
otherwise zero.</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_Tp1 &gt; bool <b>owner_before</b> (__shared_ptr&lt; _Tp1,
_Lp &gt; const &amp;__rhs) const noexcept <br>
Define an ordering based on ownership. <br>
template&lt;typename _Tp1 &gt; bool <b>owner_before</b>
(__weak_ptr&lt; _Tp1, _Lp &gt; const &amp;__rhs) const
noexcept <br>
Define an ordering based on ownership.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename _Yp ,
typename _Alloc &gt; <b>shared_ptr</b>&lt; _BoundedArray&lt;
_Yp &gt; &gt; <b>allocate_shared</b> (const _Alloc &amp;)
<br>
template&lt;typename _Yp , typename _Alloc , typename...
_Args&gt; <b>shared_ptr</b>&lt; _NonArray&lt; _Yp &gt; &gt;
<b>allocate_shared</b> (const _Alloc &amp;, _Args
&amp;&amp;...) <br>
template&lt;typename _Yp , typename _Alloc &gt;
<b>shared_ptr</b>&lt; _BoundedArray&lt; _Yp &gt; &gt;
<b>allocate_shared</b> (const _Alloc &amp;, const
<b>remove_extent_t</b>&lt; _Yp &gt; &amp;) <br>
template&lt;typename _Yp , typename _Alloc &gt;
<b>shared_ptr</b>&lt; _UnboundedArray&lt; _Yp &gt; &gt;
<b>allocate_shared</b> (const _Alloc &amp;, size_t) <br>
template&lt;typename _Yp , typename _Alloc &gt;
<b>shared_ptr</b>&lt; _UnboundedArray&lt; _Yp &gt; &gt;
<b>allocate_shared</b> (const _Alloc &amp;, size_t, const
<b>remove_extent_t</b>&lt; _Yp &gt; &amp;) <br>
template&lt;typename _Yp , typename _Alloc &gt;
<b>shared_ptr</b>&lt; _NotUnboundedArray&lt; _Yp &gt; &gt;
<b>allocate_shared_for_overwrite</b> (const _Alloc &amp;)
<br>
template&lt;typename _Yp , typename _Alloc &gt;
<b>shared_ptr</b>&lt; _UnboundedArray&lt; _Yp &gt; &gt;
<b>allocate_shared_for_overwrite</b> (const _Alloc &amp;,
size_t) <br>
template&lt;typename _Yp &gt; <b>shared_ptr</b>&lt;
_BoundedArray&lt; _Yp &gt; &gt; <b>make_shared</b> () <br>
template&lt;typename _Yp , typename... _Args&gt;
<b>shared_ptr</b>&lt; _NonArray&lt; _Yp &gt; &gt;
<b>make_shared</b> (_Args &amp;&amp;...) <br>
template&lt;typename _Yp &gt; <b>shared_ptr</b>&lt;
_BoundedArray&lt; _Yp &gt; &gt; <b>make_shared</b> (const
<b>remove_extent_t</b>&lt; _Yp &gt; &amp;) <br>
template&lt;typename _Yp &gt; <b>shared_ptr</b>&lt;
_UnboundedArray&lt; _Yp &gt; &gt; <b>make_shared</b>
(size_t) <br>
template&lt;typename _Yp &gt; <b>shared_ptr</b>&lt;
_UnboundedArray&lt; _Yp &gt; &gt; <b>make_shared</b>
(size_t, const <b>remove_extent_t</b>&lt; _Yp &gt; &amp;)
<br>
template&lt;typename _Yp &gt; <b>shared_ptr</b>&lt;
_NotUnboundedArray&lt; _Yp &gt; &gt;
<b>make_shared_for_overwrite</b> () <br>
template&lt;typename _Yp &gt; <b>shared_ptr</b>&lt;
_UnboundedArray&lt; _Yp &gt; &gt;
<b>make_shared_for_overwrite</b> (size_t) <br>
class <b>weak_ptr&lt; _Tp &gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Related
Functions</b> <br>
(Note that these are not member functions.)</p>

<p style="margin-left:17%;">template&lt;typename _Del ,
typename _Tp &gt; _Del * <b>get_deleter</b> (const
<b>shared_ptr</b>&lt; _Tp &gt; &amp;__p) noexcept <br>
20.7.2.2.10 shared_ptr get_deleter <br>
template&lt;typename _Ch , typename _Tr , typename _Tp ,
_Lock_policy _Lp&gt; <b>std::basic_ostream</b>&lt; _Ch, _Tr
&gt; &amp; <b>operator&lt;&lt;</b>
(<b>std::basic_ostream</b>&lt; _Ch, _Tr &gt; &amp;__os,
const __shared_ptr&lt; _Tp, _Lp &gt; &amp;__p) <br>
Write the stored pointer to an ostream.</p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_Tp , typename _Up &gt; bool <b>operator==</b> (const
<b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, const
<b>shared_ptr</b>&lt; _Up &gt; &amp;__b) noexcept <br>
template&lt;typename _Tp &gt; bool <b>operator==</b> (const
<b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
<br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp &gt; bool <b>operator==</b>
(nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator!=</b> (const <b>shared_ptr</b>&lt; _Tp &gt;
&amp;__a, const <b>shared_ptr</b>&lt; _Up &gt; &amp;__b)
noexcept <br>
Inequality operator for shared_ptr objects, compares the
stored pointers. <br>
template&lt;typename _Tp &gt; bool <b>operator!=</b> (const
<b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
<br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp &gt; bool <b>operator!=</b>
(nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator&lt;</b> (const <b>shared_ptr</b>&lt; _Tp &gt;
&amp;__a, const <b>shared_ptr</b>&lt; _Up &gt; &amp;__b)
noexcept <br>
Relational operator for shared_ptr objects, compares the
stored pointers. <br>
template&lt;typename _Tp &gt; bool <b>operator&lt;</b>
(const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp &gt; bool <b>operator&lt;</b>
(nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator&lt;=</b> (const <b>shared_ptr</b>&lt; _Tp &gt;
&amp;__a, const <b>shared_ptr</b>&lt; _Up &gt; &amp;__b)
noexcept <br>
Relational operator for shared_ptr objects, compares the
stored pointers. <br>
template&lt;typename _Tp &gt; bool <b>operator&lt;=</b>
(const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp &gt; bool <b>operator&lt;=</b>
(nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator&gt;</b> (const <b>shared_ptr</b>&lt; _Tp &gt;
&amp;__a, const <b>shared_ptr</b>&lt; _Up &gt; &amp;__b)
noexcept <br>
Relational operator for shared_ptr objects, compares the
stored pointers. <br>
template&lt;typename _Tp &gt; bool <b>operator&gt;</b>
(const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp &gt; bool <b>operator&gt;</b>
(nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp , typename _Up &gt; bool
<b>operator&gt;=</b> (const <b>shared_ptr</b>&lt; _Tp &gt;
&amp;__a, const <b>shared_ptr</b>&lt; _Up &gt; &amp;__b)
noexcept <br>
Relational operator for shared_ptr objects, compares the
stored pointers. <br>
template&lt;typename _Tp &gt; bool <b>operator&gt;=</b>
(const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp &gt; bool <b>operator&gt;=</b>
(nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a)
noexcept <br>
shared_ptr comparison with nullptr <br>
template&lt;typename _Tp &gt; void <b>swap</b>
(<b>shared_ptr</b>&lt; _Tp &gt; &amp;__a,
<b>shared_ptr</b>&lt; _Tp &gt; &amp;__b) noexcept <br>
Swap overload for shared_ptr. <br>
template&lt;typename _Tp , typename _Up &gt;
<b>shared_ptr</b>&lt; _Tp &gt; <b>static_pointer_cast</b>
(const <b>shared_ptr</b>&lt; _Up &gt; &amp;__r) noexcept
<br>
Convert type of <tt>shared_ptr</tt>, via
<tt>static_cast</tt> <br>
template&lt;typename _Tp , typename _Up &gt;
<b>shared_ptr</b>&lt; _Tp &gt; <b>const_pointer_cast</b>
(const <b>shared_ptr</b>&lt; _Up &gt; &amp;__r) noexcept
<br>
Convert type of <tt>shared_ptr</tt>, via <tt>const_cast</tt>
<br>
template&lt;typename _Tp , typename _Up &gt;
<b>shared_ptr</b>&lt; _Tp &gt; <b>dynamic_pointer_cast</b>
(const <b>shared_ptr</b>&lt; _Up &gt; &amp;__r) noexcept
<br>
Convert type of <tt>shared_ptr</tt>, via
<tt>dynamic_cast</tt> <br>
template&lt;typename _Tp , typename _Up &gt;
<b>shared_ptr</b>&lt; _Tp &gt;
<b>reinterpret_pointer_cast</b> (const <b>shared_ptr</b>&lt;
_Up &gt; &amp;__r) noexcept <br>
Convert type of <tt>shared_ptr</tt>, via
<tt>reinterpret_cast</tt> <br>
template&lt;typename _Tp , typename _Up &gt;
<b>shared_ptr</b>&lt; _Tp &gt; <b>static_pointer_cast</b>
(<b>shared_ptr</b>&lt; _Up &gt; &amp;&amp;__r) noexcept <br>
Convert type of <tt>shared_ptr</tt> rvalue, via
<tt>static_cast</tt> <br>
template&lt;typename _Tp , typename _Up &gt;
<b>shared_ptr</b>&lt; _Tp &gt; <b>const_pointer_cast</b>
(<b>shared_ptr</b>&lt; _Up &gt; &amp;&amp;__r) noexcept <br>
Convert type of <tt>shared_ptr</tt> rvalue, via
<tt>const_cast</tt> <br>
template&lt;typename _Tp , typename _Up &gt;
<b>shared_ptr</b>&lt; _Tp &gt; <b>dynamic_pointer_cast</b>
(<b>shared_ptr</b>&lt; _Up &gt; &amp;&amp;__r) noexcept <br>
Convert type of <tt>shared_ptr</tt> rvalue, via
<tt>dynamic_cast</tt> <br>
template&lt;typename _Tp , typename _Up &gt;
<b>shared_ptr</b>&lt; _Tp &gt;
<b>reinterpret_pointer_cast</b> (<b>shared_ptr</b>&lt; _Up
&gt; &amp;&amp;__r) noexcept <br>
Convert type of <tt>shared_ptr</tt> rvalue, via
<tt>reinterpret_cast</tt></p>


<p style="margin-left:23%; margin-top: 1em">template&lt;typename
_Tp , typename _Alloc , typename... _Args&gt;
<b>shared_ptr</b>&lt; _NonArray&lt; _Tp &gt; &gt;
<b>allocate_shared</b> (const _Alloc &amp;__a, _Args
&amp;&amp;... __args) <br>
Create an object that is owned by a shared_ptr. <br>
template&lt;typename _Tp , typename... _Args&gt;
<b>shared_ptr</b>&lt; _NonArray&lt; _Tp &gt; &gt;
<b>make_shared</b> (_Args &amp;&amp;... __args) <br>
Create an object that is owned by a shared_ptr. <br>
template&lt;typename _Tp , typename _Alloc &gt;
<b>shared_ptr</b>&lt; _UnboundedArray&lt; _Tp &gt; &gt;
<b>allocate_shared</b> (const _Alloc &amp;__a, size_t __n)
<br>
Create an object that is owned by a shared_ptr. <br>
template&lt;typename _Tp , typename _Alloc &gt;
<b>shared_ptr</b>&lt; _BoundedArray&lt; _Tp &gt; &gt;
<b>allocate_shared</b> (const _Alloc &amp;__a) <br>
Create an object that is owned by a shared_ptr.</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp&gt;</b> <br>
class std::shared_ptr&lt; _Tp &gt;&quot;A smart pointer with
reference-counted copy semantics.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++11</p>

<p style="margin-left:11%; margin-top: 1em">A
<tt>shared_ptr</tt> object is either empty or <i>owns</i> a
pointer passed to the constructor. Copies of a
<tt>shared_ptr</tt> share ownership of the same pointer.
When the last <tt>shared_ptr</tt> that owns the pointer is
destroyed or reset, the owned pointer is freed (either by
<tt>delete</tt> or by invoking a custom deleter that was
passed to the constructor).</p>

<p style="margin-left:11%; margin-top: 1em">A
<tt>shared_ptr</tt> also stores another pointer, which is
usually (but not always) the same pointer as it owns. The
stored pointer can be retrieved by calling the
<tt>get()</tt> member function.</p>

<p style="margin-left:11%; margin-top: 1em">The equality
and relational operators for <tt>shared_ptr</tt> only
compare the stored pointer returned by <tt>get()</tt>, not
the owned pointer. To test whether two <tt>shared_ptr</tt>
objects share ownership of the same pointer see
<tt>std::shared_ptr::owner_before</tt> and
<tt>std::owner_less</tt>.</p>

<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; using std::shared_ptr&lt; _Tp &gt;::element_type =
typename __shared_ptr&lt;_Tp&gt;::element_type</b> <br>
The type pointed to by the stored pointer,
remove_extent_t&lt;_Tp&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; using std::shared_ptr&lt; _Tp &gt;::weak_type =
weak_ptr&lt;_Tp&gt;</b> <br>
The corresponding weak_ptr type for this shared_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++17</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; constexpr std::shared_ptr&lt; _Tp &gt;::shared_ptr
()</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Construct an empty shared_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">use_count()==0 &amp;&amp;
get()==0</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; std::shared_ptr&lt; _Tp &gt;::shared_ptr (const
shared_ptr&lt; _Tp &gt; &amp;)</b>
<tt>[default]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Yp , typename =
_Constructible&lt;_Yp*&gt;&gt; std::shared_ptr&lt; _Tp
&gt;::shared_ptr (_Yp * __p)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
Construct a shared_ptr that owns the pointer <i>__p</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer that is
convertible to element_type*.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <tt>delete</tt> <i>__p</i> is called.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Yp , typename _Deleter ,
typename = _Constructible&lt;_Yp*, _Deleter&gt;&gt;
std::shared_ptr&lt; _Tp &gt;::shared_ptr (_Yp * __p,
_Deleter __d)</b> <tt>[inline]</tt> <br>
Construct a shared_ptr that owns the pointer <i>__p</i> and
the deleter <i>__d</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer. <i><br>
__d</i> A deleter.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <i>__d(__p)</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Requirements:
_Deleter&rsquo;s copy constructor and destructor must not
throw</p>

<p style="margin-left:11%; margin-top: 1em">__shared_ptr
will release __p by calling __d(__p)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Deleter &gt;
std::shared_ptr&lt; _Tp &gt;::shared_ptr (nullptr_t __p,
_Deleter __d)</b> <tt>[inline]</tt> <br>
Construct a shared_ptr that owns a null pointer and the
deleter <i>__d</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A null pointer
constant. <i><br>
__d</i> A deleter.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <i>__d(__p)</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Requirements:
_Deleter&rsquo;s copy constructor and destructor must not
throw</p>

<p style="margin-left:11%; margin-top: 1em">The last owner
will call __d(__p)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Yp , typename _Deleter ,
typename _Alloc , typename = _Constructible&lt;_Yp*,
_Deleter, _Alloc&gt;&gt; std::shared_ptr&lt; _Tp
&gt;::shared_ptr (_Yp * __p, _Deleter __d, _Alloc __a)</b>
<tt>[inline]</tt> <br>
Construct a shared_ptr that owns the pointer <i>__p</i> and
the deleter <i>__d</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A pointer. <i><br>
__d</i> A deleter. <i><br>
__a</i> An allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <i>__d(__p)</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Requirements:
_Deleter&rsquo;s copy constructor and destructor must not
throw _Alloc&rsquo;s copy constructor and destructor must
not throw.</p>

<p style="margin-left:11%; margin-top: 1em">__shared_ptr
will release __p by calling __d(__p)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Deleter , typename _Alloc
&gt; std::shared_ptr&lt; _Tp &gt;::shared_ptr (nullptr_t
__p, _Deleter __d, _Alloc __a)</b> <tt>[inline]</tt> <br>
Construct a shared_ptr that owns a null pointer and the
deleter <i>__d</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> A null pointer
constant. <i><br>
__d</i> A deleter. <i><br>
__a</i> An allocator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">use_count() == 1 &amp;&amp;
get() == __p</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::bad_alloc,in</i> which
case <i>__d(__p)</i> is called.</p>

<p style="margin-left:11%; margin-top: 1em">Requirements:
_Deleter&rsquo;s copy constructor and destructor must not
throw _Alloc&rsquo;s copy constructor and destructor must
not throw.</p>

<p style="margin-left:11%; margin-top: 1em">The last owner
will call __d(__p)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Yp &gt; std::shared_ptr&lt;
_Tp &gt;::shared_ptr (const shared_ptr&lt; _Yp &gt; &amp;
__r, element_type * __p)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Constructs a <tt>shared_ptr</tt> instance that stores
<tt>__p</tt> and shares ownership with <tt>__r</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__r</i> A
<tt>shared_ptr</tt>. <i><br>
__p</i> A pointer that will remain valid while <tt>*__r</tt>
is valid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;"><tt>get() == __p &amp;&amp;
use_count() == __r.use_count()</tt></p>

<p style="margin-left:11%; margin-top: 1em">This can be
used to construct a <tt>shared_ptr</tt> to a sub-object of
an object managed by an existing <tt>shared_ptr</tt>. The
complete object will remain valid while any
<tt>shared_ptr</tt> owns it, even if they don&rsquo;t store
a pointer to the complete object.</p>


<p style="margin-left:11%; margin-top: 1em">shared_ptr&lt;pair&lt;int,int&gt;&gt;
pii(new pair&lt;int,int&gt;()); <br>
shared_ptr&lt;int&gt; pi(pii, &amp;pii&minus;&gt;first);
<br>
assert(pii.use_count() == 2);</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Yp &gt; std::shared_ptr&lt;
_Tp &gt;::shared_ptr (shared_ptr&lt; _Yp &gt; &amp;&amp;
__r, element_type * __p)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Constructs a <tt>shared_ptr</tt> instance that stores
<tt>__p</tt> and shares ownership with <tt>__r</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__r</i> A
<tt>shared_ptr</tt>. <i><br>
__p</i> A pointer that will remain valid while <tt>*__r</tt>
is valid.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;"><tt>get() == __p &amp;&amp;
!__r.use_count() &amp;&amp; !__r.get()</tt></p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++17</p>

<p style="margin-left:11%; margin-top: 1em">This can be
used to construct a <tt>shared_ptr</tt> to a sub-object of
an object managed by an existing <tt>shared_ptr</tt>. The
complete object will remain valid while any
<tt>shared_ptr</tt> owns it, even if they don&rsquo;t store
a pointer to the complete object.</p>


<p style="margin-left:11%; margin-top: 1em">shared_ptr&lt;pair&lt;int,int&gt;&gt;
pii(new pair&lt;int,int&gt;()); <br>
shared_ptr&lt;int&gt; pi1(pii, &amp;pii&minus;&gt;first);
<br>
assert(pii.use_count() == 2); <br>
shared_ptr&lt;int&gt; pi2(std::move(pii),
&amp;pii&minus;&gt;second); <br>
assert(pii.use_count() == 0);</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Yp , typename =
_Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;
std::shared_ptr&lt; _Tp &gt;::shared_ptr (const
shared_ptr&lt; _Yp &gt; &amp; __r)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
If <i>__r</i> is empty, constructs an empty shared_ptr;
otherwise construct a shared_ptr that shares ownership with
<i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__r</i> A shared_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">get() == __r.get() &amp;&amp;
use_count() == __r.use_count()</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; std::shared_ptr&lt; _Tp &gt;::shared_ptr
(shared_ptr&lt; _Tp &gt; &amp;&amp; __r)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Move-constructs a shared_ptr instance from <i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__r</i> A shared_ptr
rvalue.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">*this contains the old value of
<i>__r</i>, <i>__r</i> is empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Yp , typename =
_Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt;
std::shared_ptr&lt; _Tp &gt;::shared_ptr (shared_ptr&lt; _Yp
&gt; &amp;&amp; __r)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Move-constructs a shared_ptr instance from <i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__r</i> A shared_ptr
rvalue.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">*this contains the old value of
<i>__r</i>, <i>__r</i> is empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; template&lt;typename _Yp , typename =
_Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;
std::shared_ptr&lt; _Tp &gt;::shared_ptr (const weak_ptr&lt;
_Yp &gt; &amp; __r)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
Constructs a shared_ptr that shares ownership with
<i>__r</i> and stores a copy of the pointer stored in
<i>__r</i>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__r</i> A weak_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">use_count() ==
__r.use_count()</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>bad_weak_ptr</i> when
__r.expired(), in which case the constructor has no
effect.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp &gt; constexpr std::shared_ptr&lt; _Tp &gt;::shared_ptr
(nullptr_t)</b> <tt>[inline]</tt><b>,</b>
<tt>[constexpr]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Construct an empty shared_ptr.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">use_count() == 0 &amp;&amp;
get() == nullptr</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , _Lock_policy _Lp&gt; element_type *
std::__shared_ptr&lt; _Tp, _Lp &gt;::get () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt><b>,</b>
<tt>[inherited]</tt> <br>
Return the stored pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , _Lock_policy _Lp&gt; std::__shared_ptr&lt; _Tp, _Lp
&gt;::operator bool () const</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt><b>,</b> <tt>[noexcept]</tt><b>,</b>
<tt>[inherited]</tt> <br>
Return true if the stored pointer is not null.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , _Lock_policy _Lp&gt; template&lt;typename _Tp1 &gt;
bool std::__shared_ptr&lt; _Tp, _Lp &gt;::owner_before
(__shared_ptr&lt; _Tp1, _Lp &gt; const &amp; __rhs)
const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt><b>,</b> <tt>[inherited]</tt> <br>
Define an ordering based on ownership. This function defines
a strict weak ordering between two shared_ptr or weak_ptr
objects, such that one object is less than the other unless
they share ownership of the same pointer, or are both
empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , _Lock_policy _Lp&gt; template&lt;typename _Tp1 &gt;
bool std::__shared_ptr&lt; _Tp, _Lp &gt;::owner_before
(__weak_ptr&lt; _Tp1, _Lp &gt; const &amp; __rhs) const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt><b>,</b>
<tt>[inherited]</tt> <br>
Define an ordering based on ownership. This function defines
a strict weak ordering between two shared_ptr or weak_ptr
objects, such that one object is less than the other unless
they share ownership of the same pointer, or are both
empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , _Lock_policy _Lp&gt; void std::__shared_ptr&lt; _Tp,
_Lp &gt;::swap (__shared_ptr&lt; _Tp, _Lp &gt; &amp;
__other)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt><b>,</b> <tt>[inherited]</tt> <br>
Exchange both the owned pointer and the stored pointer.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , _Lock_policy _Lp&gt; bool std::__shared_ptr&lt; _Tp,
_Lp &gt;::unique () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt><b>,</b> <tt>[inherited]</tt> <br>
Return true if use_count() == 1.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Tp , _Lock_policy _Lp&gt; long std::__shared_ptr&lt; _Tp,
_Lp &gt;::use_count () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt><b>,</b> <tt>[inherited]</tt> <br>
If *this owns a pointer, return the number of owners,
otherwise zero.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
