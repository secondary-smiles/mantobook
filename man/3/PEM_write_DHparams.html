<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:49 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PEM_READ_BIO_PRIVATEKEY</title>

</head>
<body>
<h1>PEM_write_DHparams</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">pem_password_cb,
PEM_read_bio_PrivateKey_ex, PEM_read_bio_PrivateKey,
PEM_read_PrivateKey_ex, PEM_read_PrivateKey,
PEM_write_bio_PrivateKey_ex, PEM_write_bio_PrivateKey,
PEM_write_bio_PrivateKey_traditional,
PEM_write_PrivateKey_ex, PEM_write_PrivateKey,
PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey,
PEM_write_bio_PKCS8PrivateKey_nid,
PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY_ex,
PEM_read_bio_PUBKEY, PEM_read_PUBKEY_ex, PEM_read_PUBKEY,
PEM_write_bio_PUBKEY_ex, PEM_write_bio_PUBKEY,
PEM_write_PUBKEY_ex, PEM_write_PUBKEY,
PEM_read_bio_RSAPrivateKey, PEM_read_RSAPrivateKey,
PEM_write_bio_RSAPrivateKey, PEM_write_RSAPrivateKey,
PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey,
PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey,
PEM_read_bio_RSA_PUBKEY, PEM_read_RSA_PUBKEY,
PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY,
PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey,
PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey,
PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY,
PEM_write_bio_DSA_PUBKEY, PEM_write_DSA_PUBKEY,
PEM_read_bio_Parameters_ex, PEM_read_bio_Parameters,
PEM_write_bio_Parameters, PEM_read_bio_DSAparams,
PEM_read_DSAparams, PEM_write_bio_DSAparams,
PEM_write_DSAparams, PEM_read_bio_DHparams,
PEM_read_DHparams, PEM_write_bio_DHparams,
PEM_write_DHparams, PEM_read_bio_X509, PEM_read_X509,
PEM_write_bio_X509, PEM_write_X509, PEM_read_bio_X509_AUX,
PEM_read_X509_AUX, PEM_write_bio_X509_AUX,
PEM_write_X509_AUX, PEM_read_bio_X509_REQ,
PEM_read_X509_REQ, PEM_write_bio_X509_REQ,
PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW,
PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL,
PEM_read_X509_CRL, PEM_write_bio_X509_CRL,
PEM_write_X509_CRL, PEM_read_bio_PKCS7, PEM_read_PKCS7,
PEM_write_bio_PKCS7, PEM_write_PKCS7 &minus; PEM
routines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;openssl/pem.h&gt; <br>
typedef int pem_password_cb(char *buf, int size, int rwflag,
void *u); <br>
EVP_PKEY *PEM_read_bio_PrivateKey_ex(BIO *bp, EVP_PKEY **x,
<br>
pem_password_cb *cb, void *u, <br>
OSSL_LIB_CTX *libctx, const char *propq); <br>
EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
<br>
pem_password_cb *cb, void *u); <br>
EVP_PKEY *PEM_read_PrivateKey_ex(FILE *fp, EVP_PKEY **x,
pem_password_cb *cb, <br>
void *u, OSSL_LIB_CTX *libctx, <br>
const char *propq); <br>
EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_PrivateKey_ex(BIO *bp, const EVP_PKEY *x,
<br>
const EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u, <br>
OSSL_LIB_CTX *libctx, const char *propq); <br>
int PEM_write_bio_PrivateKey(BIO *bp, const EVP_PKEY *x,
const EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_PrivateKey_traditional(BIO *bp, EVP_PKEY
*x, <br>
const EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_PrivateKey_ex(FILE *fp, EVP_PKEY *x, const
EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u, <br>
OSSL_LIB_CTX *libctx, const char *propq); <br>
int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const
EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x,
const EVP_CIPHER *enc, <br>
char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const
EVP_CIPHER *enc, <br>
char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, const
EVP_PKEY *x, int nid, <br>
char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_PKCS8PrivateKey_nid(FILE *fp, const EVP_PKEY
*x, int nid, <br>
char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
EVP_PKEY *PEM_read_bio_PUBKEY_ex(BIO *bp, EVP_PKEY **x, <br>
pem_password_cb *cb, void *u, <br>
OSSL_LIB_CTX *libctx, const char *propq); <br>
EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x, <br>
pem_password_cb *cb, void *u); <br>
EVP_PKEY *PEM_read_PUBKEY_ex(FILE *fp, EVP_PKEY **x, <br>
pem_password_cb *cb, void *u, <br>
OSSL_LIB_CTX *libctx, const char *propq); <br>
EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_PUBKEY_ex(BIO *bp, EVP_PKEY *x, <br>
OSSL_LIB_CTX *libctx, const char *propq); <br>
int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x); <br>
int PEM_write_PUBKEY_ex(FILE *fp, EVP_PKEY *x, <br>
OSSL_LIB_CTX *libctx, const char *propq); <br>
int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x); <br>
EVP_PKEY *PEM_read_bio_Parameters_ex(BIO *bp, EVP_PKEY **x,
<br>
OSSL_LIB_CTX *libctx, const char *propq); <br>
EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x);
<br>
int PEM_write_bio_Parameters(BIO *bp, const EVP_PKEY *x);
<br>
X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb
*cb, void *u); <br>
X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb,
void *u); <br>
int PEM_write_bio_X509(BIO *bp, X509 *x); <br>
int PEM_write_X509(FILE *fp, X509 *x); <br>
X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x,
pem_password_cb *cb, void *u); <br>
X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb
*cb, void *u); <br>
int PEM_write_bio_X509_AUX(BIO *bp, X509 *x); <br>
int PEM_write_X509_AUX(FILE *fp, X509 *x); <br>
X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x, <br>
pem_password_cb *cb, void *u); <br>
X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x); <br>
int PEM_write_X509_REQ(FILE *fp, X509_REQ *x); <br>
int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x); <br>
int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x); <br>
X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x, <br>
pem_password_cb *cb, void *u); <br>
X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x); <br>
int PEM_write_X509_CRL(FILE *fp, X509_CRL *x); <br>
PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x,
pem_password_cb *cb, void *u); <br>
PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb
*cb, void *u); <br>
int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x); <br>
int PEM_write_PKCS7(FILE *fp, PKCS7 *x);</p>

<p style="margin-left:11%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining
<b><small>OPENSSL_API_COMPAT</small></b> with a suitable
version value, see <b>openssl_user_macros</b>(7):</p>

<p style="margin-left:11%; margin-top: 1em">RSA
*PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x, <br>
pem_password_cb *cb, void *u); <br>
RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const
EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const
EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x, <br>
pem_password_cb *cb, void *u); <br>
RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x); <br>
int PEM_write_RSAPublicKey(FILE *fp, RSA *x); <br>
RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x, <br>
pem_password_cb *cb, void *u); <br>
RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x); <br>
int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x); <br>
DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x, <br>
pem_password_cb *cb, void *u); <br>
DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const
EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const
EVP_CIPHER *enc, <br>
unsigned char *kstr, int klen, <br>
pem_password_cb *cb, void *u); <br>
DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x, <br>
pem_password_cb *cb, void *u); <br>
DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x, <br>
pem_password_cb *cb, void *u); <br>
int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x); <br>
int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x); <br>
DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x,
pem_password_cb *cb, void *u); <br>
DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb
*cb, void *u); <br>
int PEM_write_bio_DSAparams(BIO *bp, DSA *x); <br>
int PEM_write_DSAparams(FILE *fp, DSA *x); <br>
DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb
*cb, void *u); <br>
DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb,
void *u); <br>
int PEM_write_bio_DHparams(BIO *bp, DH *x); <br>
int PEM_write_DHparams(FILE *fp, DH *x);</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All of the
functions described on this page that have a
<i><small>TYPE</small></i> of <b><small>DH</small></b> ,
<b><small>DSA</small></b> and <b><small>RSA</small></b> are
deprecated. Applications should use
<b>OSSL_ENCODER_to_bio</b>(3) and
<b>OSSL_DECODER_from_bio</b>(3) instead.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> functions read or write structures in
<small>PEM</small> format. In this sense <small>PEM</small>
format is simply base64 encoded data surrounded by header
lines.</p>

<p style="margin-left:11%; margin-top: 1em">For more
details about the meaning of arguments see the <b><small>PEM
FUNCTION ARGUMENTS</small></b> section.</p>

<p style="margin-left:11%; margin-top: 1em">Each operation
has four functions associated with it. For brevity the term
&quot; <b><i><small>TYPE</small></i></b> functions&quot;
will be used below to collectively refer to the
<b>PEM_read_bio_</b> <b><i><small>TYPE</small></i></b> (),
<b>PEM_read_</b> <b><i><small>TYPE</small></i></b> (),
<b>PEM_write_bio_</b> <b><i><small>TYPE</small></i></b> (),
and <b>PEM_write_</b> <b><i><small>TYPE</small></i></b> ()
functions.</p>

<p style="margin-left:11%; margin-top: 1em">Some operations
have additional variants that take a library context
<i>libctx</i> and a property query string <i>propq</i>. The
<b>X509</b>, <b>X509_REQ</b> and <b>X509_CRL</b> objects may
have an associated library context or property query string
but there are no variants of these functions that take a
library context or property query string parameter. In this
case it is possible to set the appropriate library context
or property query string by creating an empty <b>X509</b>,
<b>X509_REQ</b> or <b>X509_CRL</b> object using
<b>X509_new_ex</b>(3), <b>X509_REQ_new_ex</b>(3) or
<b>X509_CRL_new_ex</b>(3) respectively. Then pass the empty
object as a parameter to the relevant <small>PEM</small>
function. See the &quot; <small>EXAMPLES&quot;</small>
section below.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PrivateKey</b> functions read or write a private key in
<small>PEM</small> format using an <small>EVP_PKEY</small>
structure. The write routines use PKCS#8 private key format
and are equivalent to
<b>PEM_write_bio_PKCS8PrivateKey()</b>. The read functions
transparently handle traditional and PKCS#8 format encrypted
and unencrypted keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PEM_write_bio_PrivateKey_traditional()</b>
writes out a private key in the &quot;traditional&quot;
format with a simple private key marker and should only be
used for compatibility with legacy programs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PEM_write_bio_PKCS8PrivateKey()</b>
and <b>PEM_write_PKCS8PrivateKey()</b> write a private key
in an <small>EVP_PKEY</small> structure in PKCS#8
EncryptedPrivateKeyInfo format using PKCS#5 v2.0 password
based encryption algorithms. The <i>cipher</i> argument
specifies the encryption algorithm to use: unlike some other
<small>PEM</small> routines the encryption is applied at the
PKCS#8 level and not in the <small>PEM</small> headers. If
<i>cipher</i> is <small>NULL</small> then no encryption is
used and a PKCS#8 PrivateKeyInfo structure is used
instead.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PEM_write_bio_PKCS8PrivateKey_nid()</b>
and <b>PEM_write_PKCS8PrivateKey_nid()</b> also write out a
private key as a PKCS#8 EncryptedPrivateKeyInfo however it
uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead.
The algorithm to use is specified in the <i>nid</i>
parameter and should be the <small>NID</small> of the
corresponding <small>OBJECT IDENTIFIER</small> (see
<small>NOTES</small> section).</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>PUBKEY</small></b> functions process a public key
using an <small>EVP_PKEY</small> structure. The public key
is encoded as a SubjectPublicKeyInfo structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>RSAPrivateKey</b> functions process an <small>RSA</small>
private key using an <small>RSA</small> structure. The write
routines uses traditional format. The read routines handles
the same formats as the <b>PrivateKey</b> functions but an
error occurs if the private key is not
<small>RSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>RSAPublicKey</b> functions process an <small>RSA</small>
public key using an <small>RSA</small> structure. The public
key is encoded using a PKCS#1 RSAPublicKey structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>RSA_PUBKEY</small></b> functions also process an
<small>RSA</small> public key using an <small>RSA</small>
structure. However, the public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the
public key is not <small>RSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>DSAPrivateKey</b> functions process a <small>DSA</small>
private key using a <small>DSA</small> structure. The write
routines uses traditional format. The read routines handles
the same formats as the <b>PrivateKey</b> functions but an
error occurs if the private key is not
<small>DSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>DSA_PUBKEY</small></b> functions process a
<small>DSA</small> public key using a <small>DSA</small>
structure. The public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the
public key is not <small>DSA.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>Parameters</b> functions read or write key parameters in
<small>PEM</small> format using an <small>EVP_PKEY</small>
structure. The encoding depends on the type of key; for
<small>DSA</small> key parameters, it will be a Dss-Parms
structure as defined in <small>RFC2459,</small> and for
<small>DH</small> key parameters, it will be a PKCS#3
DHparameter structure. <i>These functions only exist for
the</i> <b><i><small>BIO</small></i></b> <i>type</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>DSAparams</b> functions process <small>DSA</small>
parameters using a <small>DSA</small> structure. The
parameters are encoded using a Dss-Parms structure as
defined in <small>RFC2459.</small></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>DHparams</b> functions process <small>DH</small>
parameters using a <small>DH</small> structure. The
parameters are encoded using a PKCS#3 DHparameter
structure.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>X509</b>
functions process an X509 certificate using an X509
structure. They will also process a trusted X509 certificate
but any trust settings are discarded.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_AUX</b> functions process a trusted X509 certificate
using an X509 structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_REQ</b> and <b>X509_REQ_NEW</b> functions process a
PKCS#10 certificate request using an X509_REQ structure. The
<b>X509_REQ</b> write functions use <b><small>CERTIFICATE
REQUEST</small></b> in the header whereas the
<b>X509_REQ_NEW</b> functions use <b><small>NEW CERTIFICATE
REQUEST</small></b> (as required by some CAs). The
<b>X509_REQ</b> read functions will handle either form so
there are no <b>X509_REQ_NEW</b> read functions.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>X509_CRL</b> functions process an X509 <small>CRL</small>
using an X509_CRL structure.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b><small>PKCS7</small></b> functions process a PKCS#7
ContentInfo using a <small>PKCS7</small> structure.</p>

<h2>PEM FUNCTION ARGUMENTS
<a name="PEM FUNCTION ARGUMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> functions have many common arguments.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>bp</i>
<small>BIO</small> parameter (if present) specifies the
<small>BIO</small> to read from or write to.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>fp</i>
<small>FILE</small> parameter (if present) specifies the
<small>FILE</small> pointer to read from or write to.</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> read functions all take an argument
<b><i><small>TYPE</small></i></b> <i>**x</i> and return a
<b><i><small>TYPE</small></i></b> <i>*</i> pointer. Where
<b><i><small>TYPE</small></i></b> is whatever structure the
function uses. If <i>x</i> is <small>NULL</small> then the
parameter is ignored. If <i>x</i> is not <small>NULL</small>
but <i>*x</i> is <small>NULL</small> then the structure
returned will be written to <i>*x</i>. If neither <i>x</i>
nor <i>*x</i> is <small>NULL</small> then an attempt is made
to reuse the structure at <i>*x</i> (but see
<small>BUGS</small> and <small>EXAMPLES</small> sections).
Irrespective of the value of <i>x</i> a pointer to the
structure is always returned (or <small>NULL</small> if an
error occurred).</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> functions which write private keys take
an <i>enc</i> parameter which specifies the encryption
algorithm to use, encryption is done at the
<small>PEM</small> level. If this parameter is set to
<small>NULL</small> then the private key is written in
unencrypted form.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>cb</i>
argument is the callback to use when querying for the pass
phrase used for encrypted <small>PEM</small> structures
(normally only private keys).</p>

<p style="margin-left:11%; margin-top: 1em">For the
<small>PEM</small> write routines if the <i>kstr</i>
parameter is not <small>NULL</small> then <i>klen</i> bytes
at <i>kstr</i> are used as the passphrase and <i>cb</i> is
ignored.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<i>cb</i> parameters is set to <small>NULL</small> and the
<i>u</i> parameter is not <small>NULL</small> then the
<i>u</i> parameter is interpreted as a <small>NUL</small>
terminated string to use as the passphrase. If both
<i>cb</i> and <i>u</i> are <small>NULL</small> then the
default callback routine is used which will typically prompt
for the passphrase on the current terminal with echoing
turned off.</p>

<p style="margin-left:11%; margin-top: 1em">The default
passphrase callback is sometimes inappropriate (for example
in a <small>GUI</small> application) so an alternative can
be supplied. The callback routine has the following
form:</p>

<p style="margin-left:11%; margin-top: 1em">int cb(char
*buf, int size, int rwflag, void *u);</p>

<p style="margin-left:11%; margin-top: 1em"><i>buf</i> is
the buffer to write the passphrase to. <i>size</i> is the
maximum length of the passphrase (i.e. the size of buf).
<i>rwflag</i> is a flag which is set to 0 when reading and 1
when writing. A typical routine will ask the user to verify
the passphrase (for example by prompting for it twice) if
<i>rwflag</i> is 1. The <i>u</i> parameter has the same
value as the <i>u</i> parameter passed to the
<small>PEM</small> routine. It allows arbitrary data to be
passed to the callback by the application (for example a
window handle in a <small>GUI</small> application). The
callback <i>must</i> return the number of characters in the
passphrase or &minus;1 if an error occurred. The passphrase
can be arbitrary data; in the case where it is a string, it
is not <small>NUL</small> terminated. See the &quot;
<small>EXAMPLES&quot;</small> section below.</p>

<p style="margin-left:11%; margin-top: 1em">Some
implementations may need to use cryptographic algorithms
during their operation. If this is the case and
<i>libctx</i> and <i>propq</i> parameters have been passed
then any algorithm fetches will use that library context and
property query string. Otherwise the default library context
and property query string will be used.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> reading functions will skip any
extraneous content or <small>PEM</small> data of a different
type than they expect. This allows for example having a
certificate (or multiple certificates) and a key in the
<small>PEM</small> format in a single file.</p>

<p style="margin-left:11%; margin-top: 1em">The old
<b>PrivateKey</b> write routines are retained for
compatibility. New applications should write private keys
using the <b>PEM_write_bio_PKCS8PrivateKey()</b> or
<b>PEM_write_PKCS8PrivateKey()</b> routines because they are
more secure (they use an iteration count of 2048 whereas the
traditional routines use a count of 1) unless compatibility
with older versions of OpenSSL is important.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>PrivateKey</b> read routines can be used in all
applications because they handle all formats
transparently.</p>

<p style="margin-left:11%; margin-top: 1em">A frequent
cause of problems is attempting to use the
<small>PEM</small> routines like this:</p>

<p style="margin-left:11%; margin-top: 1em">X509 *x; <br>
PEM_read_bio_X509(bp, &amp;x, 0, NULL);</p>

<p style="margin-left:11%; margin-top: 1em">this is a bug
because an attempt will be made to reuse the data at
<i>x</i> which is an uninitialised pointer.</p>

<p style="margin-left:11%; margin-top: 1em">These functions
make no assumption regarding the pass phrase received from
the password callback. It will simply be treated as a byte
sequence.</p>

<h2>PEM ENCRYPTION FORMAT
<a name="PEM ENCRYPTION FORMAT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These old
<b>PrivateKey</b> routines use a non standard technique for
encryption.</p>

<p style="margin-left:11%; margin-top: 1em">The private key
(or other data) takes the following form:</p>


<p style="margin-left:11%; margin-top: 1em">&minus;&minus;&minus;&minus;&minus;BEGIN
RSA PRIVATE KEY&minus;&minus;&minus;&minus;&minus; <br>
Proc&minus;Type: 4,ENCRYPTED <br>
DEK&minus;Info: DES&minus;EDE3&minus;CBC,3F17F5316E2BAC89
<br>
...base64 encoded data... <br>
&minus;&minus;&minus;&minus;&minus;END RSA PRIVATE
KEY&minus;&minus;&minus;&minus;&minus;</p>

<p style="margin-left:11%; margin-top: 1em">The line
beginning with <i>Proc-Type</i> contains the version and the
protection on the encapsulated data. The line beginning
<i>DEK-Info</i> contains two comma separated values: the
encryption algorithm name as used by
<b>EVP_get_cipherbyname()</b> and an initialization vector
used by the cipher encoded as a set of hexadecimal digits.
After those two lines is the base64&minus;encoded encrypted
data.</p>

<p style="margin-left:11%; margin-top: 1em">The encryption
key is derived using <b>EVP_BytesToKey()</b>. The
cipher&rsquo;s initialization vector is passed to
<b>EVP_BytesToKey()</b> as the <i>salt</i> parameter.
Internally, <b><small>PKCS5_SALT_LEN</small></b> bytes of
the salt are used (regardless of the size of the
initialization vector). The user&rsquo;s password is passed
to <b>EVP_BytesToKey()</b> using the <i>data</i> and
<i>datal</i> parameters. Finally, the library uses an
iteration count of 1 for <b>EVP_BytesToKey()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">The <i>key</i>
derived by <b>EVP_BytesToKey()</b> along with the original
initialization vector is then used to decrypt the encrypted
data. The <i>iv</i> produced by <b>EVP_BytesToKey()</b> is
not utilized or needed, and <small>NULL</small> should be
passed to the function.</p>

<p style="margin-left:11%; margin-top: 1em">The pseudo code
to derive the key would look similar to:</p>

<p style="margin-left:11%; margin-top: 1em">EVP_CIPHER*
cipher = EVP_des_ede3_cbc(); <br>
EVP_MD* md = EVP_md5(); <br>
unsigned int nkey = EVP_CIPHER_get_key_length(cipher); <br>
unsigned int niv = EVP_CIPHER_get_iv_length(cipher); <br>
unsigned char key[nkey]; <br>
unsigned char iv[niv]; <br>
memcpy(iv, HexToBin(&quot;3F17F5316E2BAC89&quot;), niv);
<br>
rc = EVP_BytesToKey(cipher, md, iv /*salt*/, pword, plen, 1,
key, NULL /*iv*/); <br>
if (rc != nkey) <br>
/* Error */ <br>
/* On success, use key and iv to initialize the cipher
*/</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<small>PEM</small> read routines in some versions of OpenSSL
will not correctly reuse an existing structure. Therefore,
the following:</p>


<p style="margin-left:11%; margin-top: 1em">PEM_read_bio_X509(bp,
&amp;x, 0, NULL);</p>

<p style="margin-left:11%; margin-top: 1em">where <i>x</i>
already contains a valid certificate, may not work,
whereas:</p>

<p style="margin-left:11%; margin-top: 1em">X509_free(x);
<br>
x = PEM_read_bio_X509(bp, NULL, 0, NULL);</p>

<p style="margin-left:11%; margin-top: 1em">is guaranteed
to work. It is always acceptable for <i>x</i> to contain a
newly allocated, empty <b>X509</b> object (for example
allocated via <b>X509_new_ex</b>(3)).</p>

<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The read
routines return either a pointer to the structure read or
<small>NULL</small> if an error occurred.</p>

<p style="margin-left:11%; margin-top: 1em">The write
routines return 1 for success or 0 for failure.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Although the
<small>PEM</small> routines take several arguments in almost
all applications most of them are set to 0 or
<small>NULL.</small></p>

<p style="margin-left:11%; margin-top: 1em">To read a
certificate with a library context in <small>PEM</small>
format from a <small>BIO:</small></p>

<p style="margin-left:11%; margin-top: 1em">X509 *x =
X509_new_ex(libctx, NULL); <br>
if (x == NULL) <br>
/* Error */ <br>
if (PEM_read_bio_X509(bp, &amp;x, 0, NULL) == NULL) <br>
/* Error */</p>

<p style="margin-left:11%; margin-top: 1em">Read a
certificate in <small>PEM</small> format from a
<small>BIO:</small></p>

<p style="margin-left:11%; margin-top: 1em">X509 *x; <br>
x = PEM_read_bio_X509(bp, NULL, 0, NULL); <br>
if (x == NULL) <br>
/* Error */</p>

<p style="margin-left:11%; margin-top: 1em">Alternative
method:</p>

<p style="margin-left:11%; margin-top: 1em">X509 *x = NULL;
<br>
if (!PEM_read_bio_X509(bp, &amp;x, 0, NULL)) <br>
/* Error */</p>

<p style="margin-left:11%; margin-top: 1em">Write a
certificate to a <small>BIO:</small></p>

<p style="margin-left:11%; margin-top: 1em">if
(!PEM_write_bio_X509(bp, x)) <br>
/* Error */</p>

<p style="margin-left:11%; margin-top: 1em">Write a private
key (using traditional format) to a <small>BIO</small> using
triple <small>DES</small> encryption, the pass phrase is
prompted for:</p>

<p style="margin-left:11%; margin-top: 1em">if
(!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(),
NULL, 0, 0, NULL)) <br>
/* Error */</p>

<p style="margin-left:11%; margin-top: 1em">Write a private
key (using PKCS#8 format) to a <small>BIO</small> using
triple <small>DES</small> encryption, using the pass phrase
&quot;hello&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">if
(!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(),
<br>
NULL, 0, 0, &quot;hello&quot;)) <br>
/* Error */</p>

<p style="margin-left:11%; margin-top: 1em">Read a private
key from a <small>BIO</small> using a pass phrase
callback:</p>

<p style="margin-left:11%; margin-top: 1em">key =
PEM_read_bio_PrivateKey(bp, NULL, pass_cb, &quot;My Private
Key&quot;); <br>
if (key == NULL) <br>
/* Error */</p>

<p style="margin-left:11%; margin-top: 1em">Skeleton pass
phrase callback:</p>

<p style="margin-left:11%; margin-top: 1em">int
pass_cb(char *buf, int size, int rwflag, void *u) <br>
{ <br>
/* We'd probably do something else if 'rwflag' is 1 */ <br>
printf(&quot;Enter pass phrase for \&quot;%s\&quot;\n&quot;,
(char *)u); <br>
/* get pass phrase, length 'len' into 'tmp' */ <br>
char *tmp = &quot;hello&quot;; <br>
if (tmp == NULL) /* An error occurred */ <br>
return &minus;1; <br>
size_t len = strlen(tmp); <br>
if (len &gt; size) <br>
len = size; <br>
memcpy(buf, tmp, len); <br>
return len; <br>
}</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>EVP_EncryptInit</b>(3),
<b>EVP_BytesToKey</b>(3),
<b>passphrase&minus;encoding</b>(7)</p>

<h2>HISTORY
<a name="HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The old
Netscape certificate sequences were no longer documented in
OpenSSL 1.1.0; applications should use the
<small>PKCS7</small> standard instead as they will be
formally deprecated in a future releases.</p>


<p style="margin-left:11%; margin-top: 1em"><b>PEM_read_bio_PrivateKey_ex()</b>,
<b>PEM_read_PrivateKey_ex()</b>,
<b>PEM_read_bio_PUBKEY_ex()</b>, <b>PEM_read_PUBKEY_ex()</b>
and <b>PEM_read_bio_Parameters_ex()</b> were introduced in
OpenSSL 3.0.</p>

<p style="margin-left:11%; margin-top: 1em">The functions
<b>PEM_read_bio_RSAPrivateKey()</b>,
<b>PEM_read_RSAPrivateKey()</b>,
<b>PEM_write_bio_RSAPrivateKey()</b>,
<b>PEM_write_RSAPrivateKey()</b>,
<b>PEM_read_bio_RSAPublicKey()</b>,
<b>PEM_read_RSAPublicKey()</b>,
<b>PEM_write_bio_RSAPublicKey()</b>,
<b>PEM_write_RSAPublicKey()</b>,
<b>PEM_read_bio_RSA_PUBKEY()</b>,
<b>PEM_read_RSA_PUBKEY()</b>,
<b>PEM_write_bio_RSA_PUBKEY()</b>,
<b>PEM_write_RSA_PUBKEY()</b>,
<b>PEM_read_bio_DSAPrivateKey()</b>,
<b>PEM_read_DSAPrivateKey()</b>,
<b>PEM_write_bio_DSAPrivateKey()</b>,
<b>PEM_write_DSAPrivateKey()</b>,
<b>PEM_read_bio_DSA_PUBKEY()</b>,
<b>PEM_read_DSA_PUBKEY()</b>,
<b>PEM_write_bio_DSA_PUBKEY()</b>,
<b>PEM_write_DSA_PUBKEY()</b>;
<b>PEM_read_bio_DSAparams()</b>,
<b>PEM_read_DSAparams()</b>,
<b>PEM_write_bio_DSAparams()</b>,
<b>PEM_write_DSAparams()</b>,
<b>PEM_read_bio_DHparams()</b>, <b>PEM_read_DHparams()</b>,
<b>PEM_write_bio_DHparams()</b> and
<b>PEM_write_DHparams()</b> were deprecated in 3.0.</p>

<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright
2001&minus;2022 The OpenSSL Project Authors. All Rights
Reserved.</p>

<p style="margin-left:11%; margin-top: 1em">Licensed under
the Apache License 2.0 (the &quot;License&quot;). You may
not use this file except in compliance with the License. You
can obtain a copy in the file <small>LICENSE</small> in the
source distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr>
</body>
</html>
