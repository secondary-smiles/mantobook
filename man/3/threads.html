<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:19 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>threads</title>

</head>
<body>
<h1>threads</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">threads &minus;
Perl interpreter&minus;based threads</p>

<h2>VERSION
<a name="VERSION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
describes threads version 2.27</p>

<h2>WARNING
<a name="WARNING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
&quot;interpreter-based threads&quot; provided by Perl are
not the fast, lightweight system for multitasking that one
might expect or hope for. Threads are implemented in a way
that makes them easy to misuse. Few people know how to use
them correctly or will be able to provide help.</p>

<p style="margin-left:11%; margin-top: 1em">The use of
interpreter-based threads in perl is officially
discouraged.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use threads
('yield', <br>
'stack_size' =&gt; 64*4096, <br>
'exit' =&gt; 'threads_only', <br>
'stringify'); <br>
sub start_thread { <br>
my @args = @_; <br>
print('Thread started: ', join(' ', @args), &quot;\n&quot;);
<br>
} <br>
my $thr = threads&minus;&gt;create('start_thread',
'argument'); <br>
$thr&minus;&gt;join(); <br>
threads&minus;&gt;create(sub { print(&quot;I am a
thread\n&quot;); })&minus;&gt;join(); <br>
my $thr2 = async { foreach (@files) { ... } }; <br>
$thr2&minus;&gt;join(); <br>
if (my $err = $thr2&minus;&gt;error()) { <br>
warn(&quot;Thread error: $err\n&quot;); <br>
} <br>
# Invoke thread in list context (implicit) so it can return
a list <br>
my ($thr) = threads&minus;&gt;create(sub { return (qw/a b
c/); }); <br>
# or specify list context explicitly <br>
my $thr = threads&minus;&gt;create({'context' =&gt; 'list'},
<br>
sub { return (qw/a b c/); }); <br>
my @results = $thr&minus;&gt;join(); <br>
$thr&minus;&gt;detach(); <br>
# Get a thread's object <br>
$thr = threads&minus;&gt;self(); <br>
$thr = threads&minus;&gt;object($tid); <br>
# Get a thread's ID <br>
$tid = threads&minus;&gt;tid(); <br>
$tid = $thr&minus;&gt;tid(); <br>
$tid = &quot;$thr&quot;; <br>
# Give other threads a chance to run <br>
threads&minus;&gt;yield(); <br>
yield(); <br>
# Lists of non&minus;detached threads <br>
my @threads = threads&minus;&gt;list(); <br>
my $thread_count = threads&minus;&gt;list(); <br>
my @running = threads&minus;&gt;list(threads::running); <br>
my @joinable = threads&minus;&gt;list(threads::joinable);
<br>
# Test thread objects <br>
if ($thr1 == $thr2) { <br>
... <br>
} <br>
# Manage thread stack size <br>
$stack_size = threads&minus;&gt;get_stack_size(); <br>
$old_size = threads&minus;&gt;set_stack_size(32*4096); <br>
# Create a thread with a specific context and stack size
<br>
my $thr = threads&minus;&gt;create({ 'context' =&gt; 'list',
<br>
'stack_size' =&gt; 32*4096, <br>
'exit' =&gt; 'thread_only' }, <br>
\&amp;foo); <br>
# Get thread's context <br>
my $wantarray = $thr&minus;&gt;wantarray(); <br>
# Check thread's state <br>
if ($thr&minus;&gt;is_running()) { <br>
sleep(1); <br>
} <br>
if ($thr&minus;&gt;is_joinable()) { <br>
$thr&minus;&gt;join(); <br>
} <br>
# Send a signal to a thread <br>
$thr&minus;&gt;kill('SIGUSR1'); <br>
# Exit a thread <br>
threads&minus;&gt;exit();</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Since Perl 5.8,
thread programming has been available using a model called
<i>interpreter threads</i> which provides a new Perl
interpreter for each thread, and, by default, results in no
data or state information being shared between threads.</p>

<p style="margin-left:11%; margin-top: 1em">(Prior to Perl
5.8, <i>5005threads</i> was available through the
&quot;Thread.pm&quot; <small>API.</small> This threading
model has been deprecated, and was removed as of Perl
5.10.0.)</p>

<p style="margin-left:11%; margin-top: 1em">As just
mentioned, all variables are, by default, thread local. To
use shared variables, you need to also load
threads::shared:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use threads::shared;</p>

<p style="margin-left:11%; margin-top: 1em">When loading
threads::shared, you must &quot;use threads&quot; before you
&quot;use threads::shared&quot;. (&quot;threads&quot; will
emit a warning if you do it the other way around.)</p>

<p style="margin-left:11%; margin-top: 1em">It is strongly
recommended that you enable threads via &quot;use
threads&quot; as early as possible in your script.</p>

<p style="margin-left:11%; margin-top: 1em">If needed,
scripts can be written so as to run on both threaded and
non-threaded Perls:</p>

<p style="margin-left:11%; margin-top: 1em">my
$can_use_threads = eval 'use threads; 1'; <br>
if ($can_use_threads) { <br>
# Do processing using threads <br>
... <br>
} else { <br>
# Do it without using threads <br>
... <br>
} <br>
$thr = threads&minus;&gt;create( <small>FUNCTION,
ARGS</small> )</p>

<p style="margin-left:17%;">This will create a new thread
that will begin execution with the specified entry point
function, and give it the <i><small>ARGS</small></i> list as
parameters. It will return the corresponding threads object,
or &quot;undef&quot; if thread creation failed.</p>


<p style="margin-left:17%; margin-top: 1em"><i><small>FUNCTION</small></i>
may either be the name of a function, an anonymous
subroutine, or a code ref.</p>

<p style="margin-left:17%; margin-top: 1em">my $thr =
threads&minus;&gt;create('func_name', ...); <br>
# or <br>
my $thr = threads&minus;&gt;create(sub { ... }, ...); <br>
# or <br>
my $thr = threads&minus;&gt;create(\&amp;func, ...);</p>

<p style="margin-left:17%; margin-top: 1em">The
&quot;&minus;&gt;new()&quot; method is an alias for
&quot;&minus;&gt;create()&quot;.</p>


<p style="margin-left:11%;">$thr&minus;&gt;<b>join()</b></p>

<p style="margin-left:17%;">This will wait for the
corresponding thread to complete its execution. When the
thread finishes, &quot;&minus;&gt;join()&quot; will return
the return value(s) of the entry point function.</p>

<p style="margin-left:17%; margin-top: 1em">The context
(void, scalar or list) for the return value(s) for
&quot;&minus;&gt;join()&quot; is determined at the time of
thread creation.</p>

<p style="margin-left:17%; margin-top: 1em"># Create thread
in list context (implicit) <br>
my ($thr1) = threads&minus;&gt;create(sub { <br>
my @results = qw(a b c); <br>
return (@results); <br>
}); <br>
# or (explicit) <br>
my $thr1 = threads&minus;&gt;create({'context' =&gt;
'list'}, <br>
sub { <br>
my @results = qw(a b c); <br>
return (@results); <br>
}); <br>
# Retrieve list results from thread <br>
my @res1 = $thr1&minus;&gt;join(); <br>
# Create thread in scalar context (implicit) <br>
my $thr2 = threads&minus;&gt;create(sub { <br>
my $result = 42; <br>
return ($result); <br>
}); <br>
# Retrieve scalar result from thread <br>
my $res2 = $thr2&minus;&gt;join(); <br>
# Create a thread in void context (explicit) <br>
my $thr3 = threads&minus;&gt;create({'void' =&gt; 1}, <br>
sub { print(&quot;Hello, world\n&quot;); }); <br>
# Join the thread in void context (i.e., no return value)
<br>
$thr3&minus;&gt;join();</p>

<p style="margin-left:17%; margin-top: 1em">See &quot;
<small>THREAD CONTEXT&quot;</small> for more details.</p>

<p style="margin-left:17%; margin-top: 1em">If the program
exits without all threads having either been joined or
detached, then a warning will be issued.</p>

<p style="margin-left:17%; margin-top: 1em">Calling
&quot;&minus;&gt;join()&quot; or
&quot;&minus;&gt;detach()&quot; on an already joined thread
will cause an error to be thrown.</p>


<p style="margin-left:11%;">$thr&minus;&gt;<b>detach()</b></p>

<p style="margin-left:17%;">Makes the thread unjoinable,
and causes any eventual return value to be discarded. When
the program exits, any detached threads that are still
running are silently terminated.</p>

<p style="margin-left:17%; margin-top: 1em">If the program
exits without all threads having either been joined or
detached, then a warning will be issued.</p>

<p style="margin-left:17%; margin-top: 1em">Calling
&quot;&minus;&gt;join()&quot; or
&quot;&minus;&gt;detach()&quot; on an already detached
thread will cause an error to be thrown.</p>


<p style="margin-left:11%;">threads&minus;&gt;<b>detach()</b></p>

<p style="margin-left:17%;">Class method that allows a
thread to detach itself.</p>


<p style="margin-left:11%;">threads&minus;&gt;<b>self()</b></p>

<p style="margin-left:17%;">Class method that allows a
thread to obtain its own <i>threads</i> object.</p>


<p style="margin-left:11%;">$thr&minus;&gt;<b>tid()</b></p>

<p style="margin-left:17%;">Returns the <small>ID</small>
of the thread. Thread IDs are unique integers with the main
thread in a program being 0, and incrementing by 1 for every
thread created.</p>


<p style="margin-left:11%;">threads&minus;&gt;<b>tid()</b></p>

<p style="margin-left:17%;">Class method that allows a
thread to obtain its own <small>ID.</small></p>

<p style="margin-left:11%;">&quot;$thr&quot;</p>

<p style="margin-left:17%;">If you add the
&quot;stringify&quot; import option to your &quot;use
threads&quot; declaration, then using a threads object in a
string or a string context (e.g., as a hash key) will cause
its <small>ID</small> to be used as the value:</p>

<p style="margin-left:17%; margin-top: 1em">use threads
qw(stringify); <br>
my $thr = threads&minus;&gt;create(...); <br>
print(&quot;Thread $thr started\n&quot;); # Prints: Thread 1
started</p>


<p style="margin-left:11%;">threads&minus;&gt;object($tid)</p>

<p style="margin-left:17%;">This will return the
<i>threads</i> object for the <i>active</i> thread
associated with the specified thread <small>ID.</small> If
$tid is the value for the current thread, then this call
works the same as &quot;&minus;&gt;self()&quot;. Otherwise,
returns &quot;undef&quot; if there is no thread associated
with the <small>TID,</small> if the thread is joined or
detached, if no <small>TID</small> is specified or if the
specified <small>TID</small> is undef.</p>


<p style="margin-left:11%;">threads&minus;&gt;<b>yield()</b></p>

<p style="margin-left:17%;">This is a suggestion to the
<small>OS</small> to let this thread yield
<small>CPU</small> time to other threads. What actually
happens is highly dependent upon the underlying thread
implementation.</p>

<p style="margin-left:17%; margin-top: 1em">You may do
&quot;use threads qw(yield)&quot;, and then just use
&quot;yield()&quot; in your code.</p>


<p style="margin-left:11%;">threads&minus;&gt;<b>list()</b>
<br>
threads&minus;&gt;list(threads::all) <br>
threads&minus;&gt;list(threads::running) <br>
threads&minus;&gt;list(threads::joinable)</p>

<p style="margin-left:17%;">With no arguments (or using
&quot;threads::all&quot;) and in a list context, returns a
list of all non-joined, non-detached <i>threads</i> objects.
In a scalar context, returns a count of the same.</p>

<p style="margin-left:17%; margin-top: 1em">With a
<i>true</i> argument (using &quot;threads::running&quot;),
returns a list of all non-joined, non-detached
<i>threads</i> objects that are still running.</p>

<p style="margin-left:17%; margin-top: 1em">With a
<i>false</i> argument (using &quot;threads::joinable&quot;),
returns a list of all non-joined, non-detached
<i>threads</i> objects that have finished running (i.e., for
which &quot;&minus;&gt;join()&quot; will not
<i>block</i>).</p>


<p style="margin-left:11%;">$thr1&minus;&gt;equal($thr2)</p>

<p style="margin-left:17%;">Tests if two threads objects
are the same thread or not. This is overloaded to the more
natural forms:</p>

<p style="margin-left:17%; margin-top: 1em">if ($thr1 ==
$thr2) { <br>
print(&quot;Threads are the same\n&quot;); <br>
} <br>
# or <br>
if ($thr1 != $thr2) { <br>
print(&quot;Threads differ\n&quot;); <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">(Thread
comparison is based on thread IDs.)</p>

<p style="margin-left:11%;">async <small>BLOCK</small>
;</p>

<p style="margin-left:17%;">&quot;async&quot; creates a
thread to execute the block immediately following it. This
block is treated as an anonymous subroutine, and so must
have a semicolon after the closing brace. Like
&quot;threads&minus;&gt;create()&quot;, &quot;async&quot;
returns a <i>threads</i> object.</p>


<p style="margin-left:11%;">$thr&minus;&gt;<b>error()</b></p>

<p style="margin-left:17%;">Threads are executed in an
&quot;eval&quot; context. This method will return
&quot;undef&quot; if the thread terminates <i>normally</i>.
Otherwise, it returns the value of $@ associated with the
thread&rsquo;s execution status in its &quot;eval&quot;
context.</p>


<p style="margin-left:11%;">$thr&minus;&gt;<b>_handle()</b></p>

<p style="margin-left:17%;">This <i>private</i> method
returns a pointer (i.e., the memory location expressed as an
unsigned integer) to the internal thread structure
associated with a threads object. For Win32, this is a
pointer to the &quot;HANDLE&quot; value returned by
&quot;CreateThread&quot; (i.e., &quot;HANDLE *&quot;); for
other platforms, it is a pointer to the
&quot;pthread_t&quot; structure used in the
&quot;pthread_create&quot; call (i.e., &quot;pthread_t
*&quot;).</p>

<p style="margin-left:17%; margin-top: 1em">This method is
of no use for general Perl threads programming. Its intent
is to provide other (XS-based) thread modules with the
capability to access, and possibly manipulate, the
underlying thread structure associated with a Perl
thread.</p>


<p style="margin-left:11%;">threads&minus;&gt;<b>_handle()</b></p>

<p style="margin-left:17%;">Class method that allows a
thread to obtain its own <i>handle</i>.</p>

<h2>EXITING A THREAD
<a name="EXITING A THREAD"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The usual
method for terminating a thread is to <b>return()</b> from
the entry point function with the appropriate return
value(s). <br>
threads&minus;&gt;<b>exit()</b></p>

<p style="margin-left:17%;">If needed, a thread can be
exited at any time by calling
&quot;threads&minus;&gt;exit()&quot;. This will cause the
thread to return &quot;undef&quot; in a scalar context, or
the empty list in a list context.</p>

<p style="margin-left:17%; margin-top: 1em">When called
from the <i>main</i> thread, this behaves the same as
exit(0).</p>


<p style="margin-left:11%;">threads&minus;&gt;exit(status)</p>

<p style="margin-left:17%;">When called from a thread, this
behaves like &quot;threads&minus;&gt;exit()&quot; (i.e., the
exit status code is ignored).</p>

<p style="margin-left:17%; margin-top: 1em">When called
from the <i>main</i> thread, this behaves the same as
&quot;exit(status)&quot;.</p>

<p style="margin-left:11%;"><b>die()</b></p>

<p style="margin-left:17%;">Calling &quot;die()&quot; in a
thread indicates an abnormal exit for the thread. Any
$SIG{__DIE__} handler in the thread will be called first,
and then the thread will exit with a warning message that
will contain any arguments passed in the &quot;die()&quot;
call.</p>

<p style="margin-left:11%;">exit(status)</p>

<p style="margin-left:17%;">Calling <b>exit()</b> inside a
thread causes the whole application to terminate. Because of
this, the use of &quot;exit()&quot; inside threaded code, or
in modules that might be used in threaded applications, is
strongly discouraged.</p>

<p style="margin-left:17%; margin-top: 1em">If
&quot;exit()&quot; really is needed, then consider using the
following:</p>


<p style="margin-left:17%; margin-top: 1em">threads&minus;&gt;exit()
if threads&minus;&gt;can('exit'); # Thread friendly <br>
exit(status);</p>

<p style="margin-left:11%;">use threads &rsquo;exit&rsquo;
=&gt; &rsquo;threads_only&rsquo;</p>

<p style="margin-left:17%;">This globally overrides the
default behavior of calling &quot;exit()&quot; inside a
thread, and effectively causes such calls to behave the same
as &quot;threads&minus;&gt;exit()&quot;. In other words,
with this setting, calling &quot;exit()&quot; causes only
the thread to terminate.</p>

<p style="margin-left:17%; margin-top: 1em">Because of its
global effect, this setting should not be used inside
modules or the like.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>main</i>
thread is unaffected by this setting.</p>


<p style="margin-left:11%;">threads&minus;&gt;create({&rsquo;exit&rsquo;
=&gt; &rsquo;thread_only&rsquo;}, ...)</p>

<p style="margin-left:17%;">This overrides the default
behavior of &quot;exit()&quot; inside the newly created
thread only.</p>


<p style="margin-left:11%;">$thr&minus;&gt;set_thread_exit_only(boolean)</p>

<p style="margin-left:17%;">This can be used to change the
<i>exit thread only</i> behavior for a thread after it has
been created. With a <i>true</i> argument,
&quot;exit()&quot; will cause only the thread to exit. With
a <i>false</i> argument, &quot;exit()&quot; will terminate
the application.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>main</i>
thread is unaffected by this call.</p>


<p style="margin-left:11%;">threads&minus;&gt;set_thread_exit_only(boolean)</p>

<p style="margin-left:17%;">Class method for use inside a
thread to change its own behavior for
&quot;exit()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">The <i>main</i>
thread is unaffected by this call.</p>

<h2>THREAD STATE
<a name="THREAD STATE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
boolean methods are useful in determining the <i>state</i>
of a thread. <br>
$thr&minus;&gt;<b>is_running()</b></p>

<p style="margin-left:17%;">Returns true if a thread is
still running (i.e., if its entry point function has not yet
finished or exited).</p>


<p style="margin-left:11%;">$thr&minus;&gt;<b>is_joinable()</b></p>

<p style="margin-left:17%;">Returns true if the thread has
finished running, is not detached and has not yet been
joined. In other words, the thread is ready to be joined,
and a call to &quot;$thr&minus;&gt;join()&quot; will not
<i>block</i>.</p>


<p style="margin-left:11%;">$thr&minus;&gt;<b>is_detached()</b></p>

<p style="margin-left:17%;">Returns true if the thread has
been detached.</p>


<p style="margin-left:11%;">threads&minus;&gt;<b>is_detached()</b></p>

<p style="margin-left:17%;">Class method that allows a
thread to determine whether or not it is detached.</p>

<h2>THREAD CONTEXT
<a name="THREAD CONTEXT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">As with
subroutines, the type of value returned from a
thread&rsquo;s entry point function may be determined by the
thread&rsquo;s <i>context</i>: list, scalar or void. The
thread&rsquo;s context is determined at thread creation.
This is necessary so that the context is available to the
entry point function via <b>wantarray()</b>. The thread may
then specify a value of the appropriate type to be returned
from &quot;&minus;&gt;join()&quot;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Explicit
context</b> <br>
Because thread creation and thread joining may occur in
different contexts, it may be desirable to state the context
explicitly to the thread&rsquo;s entry point function. This
may be done by calling &quot;&minus;&gt;create()&quot; with
a hash reference as the first argument:</p>

<p style="margin-left:11%; margin-top: 1em">my $thr =
threads&minus;&gt;create({'context' =&gt; 'list'},
\&amp;foo); <br>
... <br>
my @results = $thr&minus;&gt;join();</p>

<p style="margin-left:11%; margin-top: 1em">In the above,
the threads object is returned to the parent thread in
scalar context, and the thread&rsquo;s entry point function
&quot;foo&quot; will be called in list (array) context such
that the parent thread can receive a list (array) from the
&quot;&minus;&gt;join()&quot; call. ('array' is synonymous
with 'list'.)</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, if
you need the threads object, but your thread will not be
returning a value (i.e., <i>void</i> context), you would do
the following:</p>

<p style="margin-left:11%; margin-top: 1em">my $thr =
threads&minus;&gt;create({'context' =&gt; 'void'},
\&amp;foo); <br>
... <br>
$thr&minus;&gt;join();</p>

<p style="margin-left:11%; margin-top: 1em">The context
type may also be used as the <i>key</i> in the hash
reference followed by a <i>true</i> value:</p>


<p style="margin-left:11%; margin-top: 1em">threads&minus;&gt;create({'scalar'
=&gt; 1}, \&amp;foo); <br>
... <br>
my ($thr) = threads&minus;&gt;list(); <br>
my $result = $thr&minus;&gt;join();</p>

<p style="margin-left:11%; margin-top: 1em"><b>Implicit
context</b> <br>
If not explicitly stated, the thread&rsquo;s context is
implied from the context of the
&quot;&minus;&gt;create()&quot; call:</p>

<p style="margin-left:11%; margin-top: 1em"># Create thread
in list context <br>
my ($thr) = threads&minus;&gt;create(...); <br>
# Create thread in scalar context <br>
my $thr = threads&minus;&gt;create(...); <br>
# Create thread in void context <br>
threads&minus;&gt;create(...);</p>


<p style="margin-left:11%; margin-top: 1em"><b>$thr&minus;&gt;wantarray()</b>
<br>
This returns the thread&rsquo;s context in the same manner
as <b>wantarray()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>threads&minus;&gt;wantarray()</b>
<br>
Class method to return the current thread&rsquo;s context.
This returns the same value as running <b>wantarray()</b>
inside the current thread&rsquo;s entry point function.</p>

<h2>THREAD STACK SIZE
<a name="THREAD STACK SIZE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The default
per-thread stack size for different platforms varies
significantly, and is almost always far more than is needed
for most applications. On Win32, Perl&rsquo;s makefile
explicitly sets the default stack to 16 <small>MB</small> ;
on most other platforms, the system default is used, which
again may be much larger than is needed.</p>

<p style="margin-left:11%; margin-top: 1em">By tuning the
stack size to more accurately reflect your
application&rsquo;s needs, you may significantly reduce your
application&rsquo;s memory usage, and increase the number of
simultaneously running threads.</p>

<p style="margin-left:11%; margin-top: 1em">Note that on
Windows, address space allocation granularity is 64
<small>KB,</small> therefore, setting the stack smaller than
that on Win32 Perl will not save any more memory. <br>
threads&minus;&gt;<b>get_stack_size()</b>;</p>

<p style="margin-left:17%;">Returns the current default
per-thread stack size. The default is zero, which means the
system default stack size is currently in use.</p>

<p style="margin-left:11%;">$size =
$thr&minus;&gt;<b>get_stack_size()</b>;</p>

<p style="margin-left:17%;">Returns the stack size for a
particular thread. A return value of zero indicates the
system default stack size was used for the thread.</p>

<p style="margin-left:11%;">$old_size =
threads&minus;&gt;set_stack_size($new_size);</p>

<p style="margin-left:17%;">Sets a new default per-thread
stack size, and returns the previous setting.</p>

<p style="margin-left:17%; margin-top: 1em">Some platforms
have a minimum thread stack size. Trying to set the stack
size below this value will result in a warning, and the
minimum stack size will be used.</p>

<p style="margin-left:17%; margin-top: 1em">Some Linux
platforms have a maximum stack size. Setting too large of a
stack size will cause thread creation to fail.</p>

<p style="margin-left:17%; margin-top: 1em">If needed,
$new_size will be rounded up to the next multiple of the
memory page size (usually 4096 or 8192).</p>

<p style="margin-left:17%; margin-top: 1em">Threads created
after the stack size is set will then either call
&quot;pthread_attr_setstacksize()&quot; <i>(for pthreads
platforms)</i>, or supply the stack size to
&quot;CreateThread()&quot; <i>(for Win32 Perl)</i>.</p>

<p style="margin-left:17%; margin-top: 1em">(Obviously,
this call does not affect any currently extant threads.)</p>

<p style="margin-left:11%;">use threads
(&rsquo;stack_size&rsquo; =&gt; <small>VALUE</small> );</p>

<p style="margin-left:17%;">This sets the default
per-thread stack size at the start of the application.</p>

<p style="margin-left:11%;">$ENV{&rsquo;
<small>PERL5_ITHREADS_STACK_SIZE</small> &rsquo;}</p>

<p style="margin-left:17%;">The default per-thread stack
size may be set at the start of the application through the
use of the environment variable
&quot;PERL5_ITHREADS_STACK_SIZE&quot;:</p>


<p style="margin-left:17%; margin-top: 1em">PERL5_ITHREADS_STACK_SIZE=1048576
<br>
export PERL5_ITHREADS_STACK_SIZE <br>
perl &minus;e'use threads;
print(threads&minus;&gt;get_stack_size(),
&quot;\n&quot;)'</p>

<p style="margin-left:17%; margin-top: 1em">This value
overrides any &quot;stack_size&quot; parameter given to
&quot;use threads&quot;. Its primary purpose is to permit
setting the per-thread stack size for legacy threaded
applications.</p>


<p style="margin-left:11%;">threads&minus;&gt;create({&rsquo;stack_size&rsquo;
=&gt; <small>VALUE</small> }, <small>FUNCTION, ARGS</small>
)</p>

<p style="margin-left:17%;">To specify a particular stack
size for any individual thread, call
&quot;&minus;&gt;create()&quot; with a hash reference as the
first argument:</p>

<p style="margin-left:17%; margin-top: 1em">my $thr =
threads&minus;&gt;create({'stack_size' =&gt; 32*4096}, <br>
\&amp;foo, @args);</p>

<p style="margin-left:11%;">$thr2 = $thr1&minus;&gt;create(
<small>FUNCTION, ARGS</small> )</p>

<p style="margin-left:17%;">This creates a new thread
($thr2) that inherits the stack size from an existing thread
($thr1). This is shorthand for the following:</p>

<p style="margin-left:17%; margin-top: 1em">my $stack_size
= $thr1&minus;&gt;get_stack_size(); <br>
my $thr2 = threads&minus;&gt;create({'stack_size' =&gt;
$stack_size}, <br>
FUNCTION, ARGS);</p>

<h2>THREAD SIGNALLING
<a name="THREAD SIGNALLING"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">When safe
signals is in effect (the default behavior &minus; see
&quot;Unsafe signals&quot; for more details), then signals
may be sent and acted upon by individual threads. <br>
$thr&minus;&gt;kill(&rsquo; <small>SIG...</small>
&rsquo;);</p>

<p style="margin-left:17%;">Sends the specified signal to
the thread. Signal names and (positive) signal numbers are
the same as those supported by <b>kill()</b>. For example,
&rsquo; <small>SIGTERM</small> &rsquo;, &rsquo;
<small>TERM</small> &rsquo; and (depending on the
<small>OS</small> ) 15 are all valid arguments to
&quot;&minus;&gt;kill()&quot;.</p>

<p style="margin-left:17%; margin-top: 1em">Returns the
thread object to allow for method chaining:</p>


<p style="margin-left:17%; margin-top: 1em">$thr&minus;&gt;kill('SIG...')&minus;&gt;join();</p>

<p style="margin-left:11%; margin-top: 1em">Signal handlers
need to be set up in the threads for the signals they are
expected to act upon. Here&rsquo;s an example for
<i>cancelling</i> a thread:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
sub thr_func <br>
{ <br>
# Thread 'cancellation' signal handler <br>
$SIG{'KILL'} = sub { threads&minus;&gt;exit(); }; <br>
... <br>
} <br>
# Create a thread <br>
my $thr = threads&minus;&gt;create('thr_func'); <br>
... <br>
# Signal the thread to terminate, and then detach <br>
# it so that it will get cleaned up automatically <br>
$thr&minus;&gt;kill('KILL')&minus;&gt;detach();</p>

<p style="margin-left:11%; margin-top: 1em">Here&rsquo;s
another simplistic example that illustrates the use of
thread signalling in conjunction with a semaphore to provide
rudimentary <i>suspend</i> and <i>resume</i>
capabilities:</p>

<p style="margin-left:11%; margin-top: 1em">use threads;
<br>
use Thread::Semaphore; <br>
sub thr_func <br>
{ <br>
my $sema = shift; <br>
# Thread 'suspend/resume' signal handler <br>
$SIG{'STOP'} = sub { <br>
$sema&minus;&gt;down(); # Thread suspended <br>
$sema&minus;&gt;up(); # Thread resumes <br>
}; <br>
... <br>
} <br>
# Create a semaphore and pass it to a thread <br>
my $sema = Thread::Semaphore&minus;&gt;new(); <br>
my $thr = threads&minus;&gt;create('thr_func', $sema); <br>
# Suspend the thread <br>
$sema&minus;&gt;down(); <br>
$thr&minus;&gt;kill('STOP'); <br>
... <br>
# Allow the thread to continue <br>
$sema&minus;&gt;up();</p>


<p style="margin-left:11%; margin-top: 1em"><small>CAVEAT:</small>
The thread signalling capability provided by this module
does not actually send signals via the <small>OS.</small> It
<i>emulates</i> signals at the Perl-level such that signal
handlers are called in the appropriate thread. For example,
sending &quot;$thr&minus;&gt;kill('STOP')&quot; does not
actually suspend a thread (or the whole process), but does
cause a $SIG{'STOP'} handler to be called in that thread (as
illustrated above).</p>

<p style="margin-left:11%; margin-top: 1em">As such,
signals that would normally not be appropriate to use in the
&quot;kill()&quot; command (e.g., &quot;kill('KILL',
$$)&quot;) are okay to use with the
&quot;&minus;&gt;kill()&quot; method (again, as illustrated
above).</p>


<p style="margin-left:11%; margin-top: 1em">Correspondingly,
sending a signal to a thread does not disrupt the operation
the thread is currently working on: The signal will be acted
upon after the current operation has completed. For
instance, if the thread is <i>stuck</i> on an I/O call,
sending it a signal will not cause the I/O call to be
interrupted such that the signal is acted up
immediately.</p>

<p style="margin-left:11%; margin-top: 1em">Sending a
signal to a terminated/finished thread is ignored.</p>

<h2>WARNINGS
<a name="WARNINGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perl exited
with active threads:</p>

<p style="margin-left:17%;">If the program exits without
all threads having either been joined or detached, then this
warning will be issued.</p>


<p style="margin-left:17%; margin-top: 1em"><small>NOTE:</small>
If the <i>main</i> thread exits, then this warning cannot be
suppressed using &quot;no warnings 'threads';&quot; as
suggested below.</p>

<p style="margin-left:11%;">Thread creation failed:
pthread_create returned #</p>

<p style="margin-left:17%;">See the appropriate <i>man</i>
page for &quot;pthread_create&quot; to determine the actual
cause for the failure.</p>

<p style="margin-left:11%;">Thread # terminated abnormally:
...</p>

<p style="margin-left:17%;">A thread terminated in some
manner other than just returning from its entry point
function, or by using &quot;threads&minus;&gt;exit()&quot;.
For example, the thread may have terminated because of an
error, or by using &quot;die&quot;.</p>

<p style="margin-left:11%;">Using minimum thread stack size
of #</p>

<p style="margin-left:17%;">Some platforms have a minimum
thread stack size. Trying to set the stack size below this
value will result in the above warning, and the stack size
will be set to the minimum.</p>

<p style="margin-left:11%;">Thread creation failed:
pthread_attr_setstacksize( <i><small>SIZE</small></i> )
returned 22</p>

<p style="margin-left:17%;">The specified
<i><small>SIZE</small></i> exceeds the system&rsquo;s
maximum stack size. Use a smaller value for the stack
size.</p>

<p style="margin-left:11%; margin-top: 1em">If needed,
thread warnings can be suppressed by using:</p>

<p style="margin-left:11%; margin-top: 1em">no warnings
'threads';</p>

<p style="margin-left:11%; margin-top: 1em">in the
appropriate scope.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This Perl not
built to support threads</p>

<p style="margin-left:17%;">The particular copy of Perl
that you&rsquo;re trying to use was not built using the
&quot;useithreads&quot; configuration option.</p>

<p style="margin-left:17%; margin-top: 1em">Having threads
support requires all of Perl and all of the
<small>XS</small> modules in the Perl installation to be
rebuilt; it is not just a question of adding the threads
module (i.e., threaded and non-threaded Perls are binary
incompatible).</p>

<p style="margin-left:11%;">Cannot change stack size of an
existing thread</p>

<p style="margin-left:17%;">The stack size of currently
extant threads cannot be changed, therefore, the following
results in the above error:</p>


<p style="margin-left:17%; margin-top: 1em">$thr&minus;&gt;set_stack_size($size);</p>

<p style="margin-left:11%;">Cannot signal threads without
safe signals</p>

<p style="margin-left:17%;">Safe signals must be in effect
to use the &quot;&minus;&gt;kill()&quot; signalling method.
See &quot;Unsafe signals&quot; for more details.</p>

<p style="margin-left:11%;">Unrecognized signal name:
...</p>

<p style="margin-left:17%;">The particular copy of Perl
that you&rsquo;re trying to use does not support the
specified signal being used in a
&quot;&minus;&gt;kill()&quot; call.</p>

<h2>BUGS AND LIMITATIONS
<a name="BUGS AND LIMITATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Before you
consider posting a bug report, please consult, and possibly
post a message to the discussion forum to see if what
you&rsquo;ve encountered is a known problem. <br>
Thread-safe modules</p>

<p style="margin-left:17%;">See &quot;Making your module
threadsafe&quot; in perlmod when creating modules that may
be used in threaded applications, especially if those
modules use non-Perl data, or <small>XS</small> code.</p>

<p style="margin-left:11%;">Using non-thread-safe
modules</p>

<p style="margin-left:17%;">Unfortunately, you may
encounter Perl modules that are not <i>thread-safe</i>. For
example, they may crash the Perl interpreter during
execution, or may dump core on termination. Depending on the
module and the requirements of your application, it may be
possible to work around such difficulties.</p>

<p style="margin-left:17%; margin-top: 1em">If the module
will only be used inside a thread, you can try loading the
module from inside the thread entry point function using
&quot;require&quot; (and &quot;import&quot; if needed):</p>

<p style="margin-left:17%; margin-top: 1em">sub thr_func
<br>
{ <br>
require Unsafe::Module <br>
# Unsafe::Module&minus;&gt;import(...); <br>
.... <br>
}</p>

<p style="margin-left:17%; margin-top: 1em">If the module
is needed inside the <i>main</i> thread, try modifying your
application so that the module is loaded (again using
&quot;require&quot; and &quot;&minus;&gt;import()&quot;)
after any threads are started, and in such a way that no
other threads are started afterwards.</p>

<p style="margin-left:17%; margin-top: 1em">If the above
does not work, or is not adequate for your application, then
file a bug report on &lt;https://rt.cpan.org/Public/&gt;
against the problematic module.</p>

<p style="margin-left:11%;">Memory consumption</p>

<p style="margin-left:17%;">On most systems, frequent and
continual creation and destruction of threads can lead to
ever-increasing growth in the memory footprint of the Perl
interpreter. While it is simple to just launch threads and
then &quot;&minus;&gt;join()&quot; or
&quot;&minus;&gt;detach()&quot; them, for long-lived
applications, it is better to maintain a pool of threads,
and to reuse them for the work needed, using queues to
notify threads of pending work. The <small>CPAN</small>
distribution of this module contains a simple example
(<i>examples/pool_reuse.pl</i>) illustrating the creation,
use and monitoring of a pool of <i>reusable</i> threads.</p>

<p style="margin-left:11%;">Current working directory</p>

<p style="margin-left:17%;">On all platforms except
MSWin32, the setting for the current working directory is
shared among all threads such that changing it in one thread
(e.g., using &quot;chdir()&quot;) will affect all the
threads in the application.</p>

<p style="margin-left:17%; margin-top: 1em">On MSWin32,
each thread maintains its own the current working directory
setting.</p>

<p style="margin-left:11%;">Locales</p>

<p style="margin-left:17%;">Prior to Perl 5.28, locales
could not be used with threads, due to various race
conditions. Starting in that release, on systems that
implement thread-safe locale functions, threads can be used,
with some caveats. This includes Windows starting with
Visual Studio 2005, and systems compatible with <small>POSIX
2008.</small> See &quot;Multi-threaded operation&quot; in
perllocale.</p>

<p style="margin-left:17%; margin-top: 1em">Each thread
(except the main thread) is started using the C locale. The
main thread is started like all other Perl programs; see
&quot; <small>ENVIRONMENT&quot;</small> in perllocale. You
can switch locales in any thread as often as you like.</p>

<p style="margin-left:17%; margin-top: 1em">If you want to
inherit the parent thread&rsquo;s locale, you can, in the
parent, set a variable like so:</p>

<p style="margin-left:17%; margin-top: 1em">$foo =
POSIX::setlocale(LC_ALL, NULL);</p>

<p style="margin-left:17%; margin-top: 1em">and then pass
to threads&minus;&gt;<b>create()</b> a sub that closes over
$foo. Then, in the child, you say</p>


<p style="margin-left:17%; margin-top: 1em">POSIX::setlocale(LC_ALL,
$foo);</p>

<p style="margin-left:17%; margin-top: 1em">Or you can use
the facilities in threads::shared to pass $foo; or if the
environment hasn&rsquo;t changed, in the child, do</p>


<p style="margin-left:17%; margin-top: 1em">POSIX::setlocale(LC_ALL,
&quot;&quot;);</p>

<p style="margin-left:11%;">Environment variables</p>

<p style="margin-left:17%;">Currently, on all platforms
except MSWin32, all <i>system</i> calls (e.g., using
&quot;system()&quot; or back-ticks) made from threads use
the environment variable settings from the <i>main</i>
thread. In other words, changes made to %ENV in a thread
will not be visible in <i>system</i> calls made by that
thread.</p>

<p style="margin-left:17%; margin-top: 1em">To work around
this, set environment variables as part of the <i>system</i>
call. For example:</p>

<p style="margin-left:17%; margin-top: 1em">my $msg =
'hello'; <br>
system(&quot;FOO=$msg; echo \$FOO&quot;); # Outputs 'hello'
to STDOUT</p>

<p style="margin-left:17%; margin-top: 1em">On MSWin32,
each thread maintains its own set of environment
variables.</p>

<p style="margin-left:11%;">Catching signals</p>

<p style="margin-left:17%;">Signals are <i>caught</i> by
the main thread (thread <small>ID</small> = 0) of a script.
Therefore, setting up signal handlers in threads for
purposes other than &quot; <small>THREAD
SIGNALLING&quot;</small> as documented above will not
accomplish what is intended.</p>

<p style="margin-left:17%; margin-top: 1em">This is
especially true if trying to catch &quot;SIGALRM&quot; in a
thread. To handle alarms in threads, set up a signal handler
in the main thread, and then use &quot; <small>THREAD
SIGNALLING&quot;</small> to relay the signal to the
thread:</p>

<p style="margin-left:17%; margin-top: 1em"># Create thread
with a task that may time out <br>
my $thr = threads&minus;&gt;create(sub { <br>
threads&minus;&gt;yield(); <br>
eval { <br>
$SIG{ALRM} = sub { die(&quot;Timeout\n&quot;); }; <br>
alarm(10); <br>
... # Do work here <br>
alarm(0); <br>
}; <br>
if ($@ =~ /Timeout/) { <br>
warn(&quot;Task in thread timed out\n&quot;); <br>
} <br>
}; <br>
# Set signal handler to relay SIGALRM to thread <br>
$SIG{ALRM} = sub { $thr&minus;&gt;kill('ALRM') }; <br>
... # Main thread continues working</p>

<p style="margin-left:11%;">Parent-child threads</p>

<p style="margin-left:17%;">On some platforms, it might not
be possible to destroy <i>parent</i> threads while there are
still existing <i>child</i> threads.</p>

<p style="margin-left:11%;">Unsafe signals</p>

<p style="margin-left:17%;">Since Perl 5.8.0, signals have
been made safer in Perl by postponing their handling until
the interpreter is in a <i>safe</i> state. See &quot;Safe
Signals&quot; in perl58delta and &quot;Deferred Signals
(Safe Signals)&quot; in perlipc for more details.</p>

<p style="margin-left:17%; margin-top: 1em">Safe signals is
the default behavior, and the old, immediate, unsafe
signalling behavior is only in effect in the following
situations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>Perl has been built with &quot;PERL_OLD_SIGNALS&quot;
(see &quot;perl &minus;V&quot;).</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>The environment variable &quot;PERL_SIGNALS&quot; is set
to &quot;unsafe&quot; (see &quot;
<small>PERL_SIGNALS&quot;</small> in perlrun).</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="77%">


<p>The module Perl::Unsafe::Signals is used.</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">If unsafe
signals is in effect, then signal handling is not
thread-safe, and the &quot;&minus;&gt;kill()&quot;
signalling method cannot be used.</p>

<p style="margin-left:11%;">Identity of objects returned
from threads</p>

<p style="margin-left:17%;">When a value is returned from a
thread through a &quot;join&quot; operation, the value and
everything that it references is copied across to the
joining thread, in much the same way that values are copied
upon thread creation. This works fine for most kinds of
value, including arrays, hashes, and subroutines. The
copying recurses through array elements, reference scalars,
variables closed over by subroutines, and other kinds of
reference.</p>

<p style="margin-left:17%; margin-top: 1em">However,
everything referenced by the returned value is a fresh copy
in the joining thread, even if a returned object had in the
child thread been a copy of something that previously
existed in the parent thread. After joining, the parent will
therefore have a duplicate of each such object. This
sometimes matters, especially if the object gets mutated;
this can especially matter for private data to which a
returned subroutine provides access.</p>

<p style="margin-left:11%;">Returning blessed objects from
threads</p>

<p style="margin-left:17%;">Returning blessed objects from
threads does not work. Depending on the classes involved,
you may be able to work around this by returning a
serialized version of the object (e.g., using Data::Dumper
or Storable), and then reconstituting it in the joining
thread. If you&rsquo;re using Perl 5.10.0 or later, and if
the class supports shared objects, you can pass them via
shared queues.</p>

<p style="margin-left:11%;"><small>END</small> blocks in
threads</p>

<p style="margin-left:17%;">It is possible to add
<small>END</small> blocks to threads by using require or
eval with the appropriate code. These &quot;END&quot; blocks
will then be executed when the thread&rsquo;s interpreter is
destroyed (i.e., either during a
&quot;&minus;&gt;join()&quot; call, or at program
termination).</p>

<p style="margin-left:17%; margin-top: 1em">However,
calling any threads methods in such an &quot;END&quot; block
will most likely <i>fail</i> (e.g., the application may
hang, or generate an error) due to mutexes that are needed
to control functionality within the threads module.</p>

<p style="margin-left:17%; margin-top: 1em">For this
reason, the use of &quot;END&quot; blocks in threads is
<b>strongly</b> discouraged.</p>

<p style="margin-left:11%;">Open directory handles</p>

<p style="margin-left:17%;">In perl 5.14 and higher, on
systems other than Windows that do not support the
&quot;fchdir&quot; C function, directory handles (see
opendir) will not be copied to new threads. You can use the
&quot;d_fchdir&quot; variable in Config.pm to determine
whether your system supports it.</p>

<p style="margin-left:17%; margin-top: 1em">In prior perl
versions, spawning threads with open directory handles would
crash the interpreter. [perl #75154]
&lt;https://rt.perl.org/rt3/Public/Bug/Display.html?id=75154&gt;</p>

<p style="margin-left:11%;">Detached threads and global
destruction</p>

<p style="margin-left:17%;">If the main thread exits while
there are detached threads which are still running, then
Perl&rsquo;s global destruction phase is not executed
because otherwise certain global structures that control the
operation of threads and that are allocated in the main
thread&rsquo;s memory may get destroyed before the detached
thread is destroyed.</p>

<p style="margin-left:17%; margin-top: 1em">If you are
using any code that requires the execution of the global
destruction phase for clean up (e.g., removing temp files),
then do not use detached threads, but rather join all
threads before exiting the program.</p>

<p style="margin-left:11%;">Perl Bugs and the
<small>CPAN</small> Version of threads</p>

<p style="margin-left:17%;">Support for threads extends
beyond the code in this module (i.e., <i>threads.pm</i> and
<i>threads.xs</i>), and into the Perl interpreter itself.
Older versions of Perl contain bugs that may manifest
themselves despite using the latest version of threads from
<small>CPAN.</small> There is no workaround for this other
than upgrading to the latest version of Perl.</p>

<p style="margin-left:17%; margin-top: 1em">Even with the
latest version of Perl, it is known that certain constructs
with threads may result in warning messages concerning
leaked scalars or unreferenced scalars. However, such
warnings are harmless, and may safely be ignored.</p>

<p style="margin-left:17%; margin-top: 1em">You can search
for threads related bug reports at
&lt;https://rt.cpan.org/Public/&gt;. If needed submit any
new bugs, problems, patches, etc. to:
&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=threads&gt;</p>

<h2>REQUIREMENTS
<a name="REQUIREMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Perl 5.8.0 or
later</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">threads on
MetaCPAN: &lt;https://metacpan.org/release/threads&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Code repository
for <small>CPAN</small> distribution:
&lt;https://github.com/Dual&minus;Life/threads&gt;</p>


<p style="margin-left:11%; margin-top: 1em">threads::shared,
perlthrtut</p>


<p style="margin-left:11%; margin-top: 1em">&lt;https://www.perl.com/pub/a/2002/06/11/threads.html&gt;
and
&lt;https://www.perl.com/pub/a/2002/09/04/threads.html&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Perl threads
mailing list:
&lt;https://lists.perl.org/list/ithreads.html&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Stack size
discussion:
&lt;https://www.perlmonks.org/?node_id=532956&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Sample code in
the <i>examples</i> directory of this distribution on
<small>CPAN.</small></p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Artur Bergman
&lt;sky <small>AT</small> crucially <small>DOT</small>
net&gt;</p>


<p style="margin-left:11%; margin-top: 1em"><small>CPAN</small>
version produced by Jerry D. Hedden &lt;jdhedden
<small>AT</small> cpan <small>DOT</small> org&gt;</p>

<h2>LICENSE
<a name="LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">threads is
released under the same license as Perl.</p>

<h2>ACKNOWLEDGEMENTS
<a name="ACKNOWLEDGEMENTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Richard
Soderberg &lt;perl <small>AT</small> crystalflame
<small>DOT</small> net&gt; &minus; Helping me out tons,
trying to find reasons for races and other weird bugs!</p>

<p style="margin-left:11%; margin-top: 1em">Simon Cozens
&lt;simon <small>AT</small> brecon <small>DOT</small> co
<small>DOT</small> uk&gt; &minus; Being there to answer
zillions of annoying questions</p>

<p style="margin-left:11%; margin-top: 1em">Rocco Caputo
&lt;troc <small>AT</small> netrus <small>DOT</small>
net&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Vipul Ved
Prakash &lt;mail <small>AT</small> vipul <small>DOT</small>
net&gt; &minus; Helping with debugging</p>

<p style="margin-left:11%; margin-top: 1em">Dean Arnold
&lt;darnold <small>AT</small> presicient <small>DOT</small>
com&gt; &minus; Stack size <small>API</small></p>
<hr>
</body>
</html>
