<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:02 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>seccomp_rule_add</title>

</head>
<body>
<h1>seccomp_rule_add_array</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">seccomp_rule_add,
seccomp_rule_add_exact &minus; Add a seccomp filter rule</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;seccomp.h&gt;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef void
* scmp_filter_ctx;</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
SCMP_SYS(</b><i>syscall_name</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>struct
scmp_arg_cmp SCMP_CMP(unsigned int</b> <i>arg</i><b>, <br>
enum scmp_compare</b> <i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A0(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A1(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A2(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A3(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A4(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A5(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>struct
scmp_arg_cmp SCMP_CMP64(unsigned int</b> <i>arg</i><b>, <br>
enum scmp_compare</b> <i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A0_64(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A1_64(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A2_64(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A3_64(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A4_64(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A5_64(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>struct
scmp_arg_cmp SCMP_CMP32(unsigned int</b> <i>arg</i><b>, <br>
enum scmp_compare</b> <i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A0_32(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A1_32(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A2_32(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A3_32(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A4_32(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>); <br>
struct scmp_arg_cmp SCMP_A5_32(enum scmp_compare</b>
<i>op</i><b>,</b> <i>...</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
seccomp_rule_add(scmp_filter_ctx</b> <i>ctx</i><b>,
uint32_t</b> <i>action</i><b>, <br>
int</b> <i>syscall</i><b>, unsigned int</b>
<i>arg_cnt</i><b>,</b> <i>...</i><b>); <br>
int seccomp_rule_add_exact(scmp_filter_ctx</b>
<i>ctx</i><b>, uint32_t</b> <i>action</i><b>, <br>
int</b> <i>syscall</i><b>, unsigned int</b>
<i>arg_cnt</i><b>,</b> <i>...</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
seccomp_rule_add_array(scmp_filter_ctx</b> <i>ctx</i><b>,
<br>
uint32_t</b> <i>action</i><b>, int</b> <i>syscall</i><b>,
<br>
unsigned int</b> <i>arg_cnt</i><b>, <br>
const struct scmp_arg_cmp *</b><i>arg_array</i><b>); <br>
int seccomp_rule_add_exact_array(scmp_filter_ctx</b>
<i>ctx</i><b>, <br>
uint32_t</b> <i>action</i><b>, int</b> <i>syscall</i><b>,
<br>
unsigned int</b> <i>arg_cnt</i><b>, <br>
const struct scmp_arg_cmp *</b><i>arg_array</i><b>);</b></p>

<p style="margin-left:11%; margin-top: 1em">Link with
<i>&minus;lseccomp</i>.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>seccomp_rule_add</b>(), <b>seccomp_rule_add_array</b>(),
<b>seccomp_rule_add_exact</b>(), and
<b>seccomp_rule_add_exact_array</b>() functions all add a
new filter rule to the current seccomp filter. The
<b>seccomp_rule_add</b>() and
<b>seccomp_rule_add_array</b>() functions will make a
&quot;best effort&quot; to add the rule as specified, but
may alter the rule slightly due to architecture specifics
(e.g. internal rewriting of multiplexed syscalls, like
socket and ipc functions on x86). The
<b>seccomp_rule_add_exact</b>() and
<b>seccomp_rule_add_exact_array</b>() functions will attempt
to add the rule exactly as specified so it may behave
differently on different architectures. While it does not
guarantee a exact filter ruleset, <b>seccomp_rule_add</b>()
and <b>seccomp_rule_add_array</b>() do guarantee the same
behavior regardless of the architecture.</p>

<p style="margin-left:11%; margin-top: 1em">The newly added
filter rule does not take effect until the entire filter is
loaded into the kernel using <b>seccomp_load</b>(3). When
adding rules to a filter, it is important to consider the
impact of previously loaded filters; see the
<b>seccomp_load</b>(3) documentation for more
information.</p>

<p style="margin-left:11%; margin-top: 1em">All of the
filter rules supplied by the calling application are
combined into a union, with additional logic to eliminate
redundant syscall filters. For example, if a rule is added
which allows a given syscall with a specific set of argument
values and later a rule is added which allows the same
syscall regardless the argument values then the first, more
specific rule, is effectively dropped from the filter by the
second more generic rule.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>SCMP_CMP</b>(), <b>SCMP_CMP64</b>(),
<b>SCMP_A{0-5}</b>(), and <b>SCMP_A{0-5}_64</b>() macros
generate a scmp_arg_cmp structure for use with the above
functions. The <b>SCMP_CMP</b>() and <b>SCMP_CMP64</b>()
macros allows the caller to specify an arbitrary argument
along with the comparison operator, 64-bit mask, and 64-bit
datum values where the <b>SCMP_A{0-5}</b>() and
<b>SCMP_A{0-5}_64</b>() macros are specific to a certain
argument.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>SCMP_CMP32</b>() and <b>SCMP_A{0-5}_32</b>() macros are
similar to the variants above, but they take 32-bit mask and
32-bit datum values.</p>

<p style="margin-left:11%; margin-top: 1em">It is
recommended that whenever possible developers avoid using
the <b>SCMP_CMP</b>() and <b>SCMP_A{0-5}</b>() macros and
use the variants which are explicitly 32 or 64-bit. This
should help eliminate problems caused by an unwanted sign
extension of negative datum values.</p>

<p style="margin-left:11%; margin-top: 1em">If syscall
argument comparisons are included in the filter rule, all of
the comparisons must be true for the rule to match.</p>

<p style="margin-left:11%; margin-top: 1em">When adding
syscall argument comparisons to the filter it is important
to remember that while it is possible to have multiple
comparisons in a single rule, you can only compare each
argument once in a single rule. In other words, you can not
have multiple comparisons of the 3rd syscall argument in a
single rule.</p>

<p style="margin-left:11%; margin-top: 1em">In a filter
containing multiple architectures, it is an error to add a
filter rule for a syscall that does not exist in all of the
filter&rsquo;s architectures.</p>

<p style="margin-left:11%; margin-top: 1em">While it is
possible to specify the <i>syscall</i> value directly using
the standard <b>__NR_syscall</b> values, in order to ensure
proper operation across multiple architectures it is highly
recommended to use the <b>SCMP_SYS</b>() macro instead. See
the EXAMPLES section below. It is also important to remember
that regardless of the architectures present in the filter,
the syscall numbers used in filter rules are interpreted in
the context of the native architecture.</p>

<p style="margin-left:11%; margin-top: 1em">Starting with
Linux v4.8, there may be a need to create a rule with a
syscall value of -1 to allow tracing programs to skip a
syscall invocation; in order to create a rule with a -1
syscall value it is necessary to first set the
<b>SCMP_FLTATR_API_TSKIP</b> attribute. See
<b>seccomp_attr_set</b>(3) for more information.</p>

<p style="margin-left:11%; margin-top: 1em">The filter
context <i>ctx</i> is the value returned by the call to
<b>seccomp_init</b>(3).</p>

<p style="margin-left:11%; margin-top: 1em">Valid
<i>action</i> values are as follows: <b><br>
SCMP_ACT_KILL</b></p>

<p style="margin-left:22%;">The thread will be killed by
the kernel when it calls a syscall that matches the filter
rule.</p>


<p style="margin-left:11%;"><b>SCMP_ACT_KILL_PROCESS</b></p>

<p style="margin-left:22%;">The process will be killed by
the kernel when it calls a syscall that matches the filter
rule.</p>

<p style="margin-left:11%;"><b>SCMP_ACT_TRAP</b></p>

<p style="margin-left:22%;">The thread will throw a SIGSYS
signal when it calls a syscall that matches the filter
rule.</p>

<p style="margin-left:11%;"><b>SCMP_ACT_ERRNO(uint16_t
errno)</b></p>

<p style="margin-left:22%;">The thread will receive a
return value of <i>errno</i> when it calls a syscall that
matches the filter rule.</p>

<p style="margin-left:11%;"><b>SCMP_ACT_TRACE(uint16_t
msg_num)</b></p>

<p style="margin-left:22%;">If the thread is being traced
and the tracing process specified the
<b>PTRACE_O_TRACESECCOMP</b> option in the call to
<b>ptrace</b>(2), the tracing process will be notified, via
<b>PTRACE_EVENT_SECCOMP</b> , and the value provided in
<i>msg_num</i> can be retrieved using the
<b>PTRACE_GETEVENTMSG</b> option.</p>

<p style="margin-left:11%;"><b>SCMP_ACT_LOG</b></p>

<p style="margin-left:22%;">The seccomp filter will have no
effect on the thread calling the syscall if it matches the
filter rule but the syscall will be logged.</p>

<p style="margin-left:11%;"><b>SCMP_ACT_ALLOW</b></p>

<p style="margin-left:22%;">The seccomp filter will have no
effect on the thread calling the syscall if it matches the
filter rule.</p>

<p style="margin-left:11%;"><b>SCMP_ACT_NOTIFY</b></p>

<p style="margin-left:22%;">A monitoring process will be
notified when a process running the seccomp filter calls a
syscall that matches the filter rule. The process that
invokes the syscall waits in the kernel until the monitoring
process has responded via <b>seccomp_notify_respond (3)</b>
.</p>

<p style="margin-left:22%; margin-top: 1em">When a filter
utilizing <b>SCMP_ACT_NOTIFY</b> is loaded into the kernel,
the kernel generates a notification fd that must be used to
communicate between the monitoring process and the
process(es) being filtered. See <b>seccomp_notif_fd (3)</b>
for more information.</p>

<p style="margin-left:11%; margin-top: 1em">Valid
comparison <i>op</i> values are as follows: <b><br>
SCMP_CMP_NE</b></p>

<p style="margin-left:22%;">Matches when the argument value
is not equal to the datum value, example:</p>

<p style="margin-left:22%; margin-top: 1em">SCMP_CMP(
<i>arg</i> , SCMP_CMP_NE , <i>datum</i> )</p>

<p style="margin-left:11%;"><b>SCMP_CMP_LT</b></p>

<p style="margin-left:22%;">Matches when the argument value
is less than the datum value, example:</p>

<p style="margin-left:22%; margin-top: 1em">SCMP_CMP(
<i>arg</i> , SCMP_CMP_LT , <i>datum</i> )</p>

<p style="margin-left:11%;"><b>SCMP_CMP_LE</b></p>

<p style="margin-left:22%;">Matches when the argument value
is less than or equal to the datum value, example:</p>

<p style="margin-left:22%; margin-top: 1em">SCMP_CMP(
<i>arg</i> , SCMP_CMP_LE , <i>datum</i> )</p>

<p style="margin-left:11%;"><b>SCMP_CMP_EQ</b></p>

<p style="margin-left:22%;">Matches when the argument value
is equal to the datum value, example:</p>

<p style="margin-left:22%; margin-top: 1em">SCMP_CMP(
<i>arg</i> , SCMP_CMP_EQ , <i>datum</i> )</p>

<p style="margin-left:11%;"><b>SCMP_CMP_GE</b></p>

<p style="margin-left:22%;">Matches when the argument value
is greater than or equal to the datum value, example:</p>

<p style="margin-left:22%; margin-top: 1em">SCMP_CMP(
<i>arg</i> , SCMP_CMP_GE , <i>datum</i> )</p>

<p style="margin-left:11%;"><b>SCMP_CMP_GT</b></p>

<p style="margin-left:22%;">Matches when the argument value
is greater than the datum value, example:</p>

<p style="margin-left:22%; margin-top: 1em">SCMP_CMP(
<i>arg</i> , SCMP_CMP_GT , <i>datum</i> )</p>

<p style="margin-left:11%;"><b>SCMP_CMP_MASKED_EQ</b></p>

<p style="margin-left:22%;">Matches when the masked
argument value is equal to the masked datum value,
example:</p>

<p style="margin-left:22%; margin-top: 1em">SCMP_CMP(
<i>arg</i> , SCMP_CMP_MASKED_EQ , <i>mask</i> , <i>datum</i>
)</p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>SCMP_SYS</b>() macro returns a value suitable for use as
the <i>syscall</i> value in the <b>seccomp_rule_add*</b>()
functions. In a similar manner, the <b>SCMP_CMP</b>() and
<b>SCMP_A*</b>() macros return values suitable for use as
argument comparisons in the <b>seccomp_rule_add</b>() and
<b>seccomp_rule_add_exact</b>() functions.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>seccomp_rule_add</b>(), <b>seccomp_rule_add_array</b>(),
<b>seccomp_rule_add_exact</b>(), and
<b>seccomp_rule_add_exact_array</b>() functions return zero
on success or one of the following error codes on
failure:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>-EDOM</b></p></td>
<td width="4%"></td>
<td width="46%">


<p>Architecture specific failure.</p></td>
<td width="32%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>-EEXIST</b></p>

<p style="margin-left:22%;">The rule already exists.</p>

<p style="margin-left:11%;"><b>-EACCCES</b></p>

<p style="margin-left:22%;">The rule conflicts with the
filter (for example, the rule <i>action</i> equals the
default action of the filter).</p>

<p style="margin-left:11%;"><b>-EFAULT</b></p>

<p style="margin-left:22%;">Internal libseccomp
failure.</p>

<p style="margin-left:11%;"><b>-EINVAL</b></p>

<p style="margin-left:22%;">Invalid input, either the
context or architecture token is invalid.</p>

<p style="margin-left:11%;"><b>-ENOMEM</b></p>

<p style="margin-left:22%;">The library was unable to
allocate enough memory.</p>

<p style="margin-left:11%;"><b>-EOPNOTSUPP</b></p>

<p style="margin-left:22%;">The library doesn&rsquo;t
support the particular operation.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">#include
&lt;fcntl.h&gt; <br>
#include &lt;seccomp.h&gt; <br>
#include &lt;sys/stat.h&gt; <br>
#include &lt;sys/types.h&gt; <br>
#include &lt;stddef.h&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="-3%">


<p>#define BUF_SIZE</p></td>
<td width="23%"></td>
<td width="7%"></td>
<td width="62%">


<p>256</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">int main(int
argc, char *argv[]) <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>int rc = &minus;1;</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>scmp_filter_ctx ctx;</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>struct scmp_arg_cmp arg_cmp[] = { SCMP_A0(SCMP_CMP_EQ,
2) };</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>int fd;</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>unsigned char buf[BUF_SIZE];</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>ctx = seccomp_init(SCMP_ACT_KILL);</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (ctx == NULL)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>goto out;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>/* ... */</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>fd = open(&quot;file.txt&quot;, 0);</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>/* ... */</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW,
SCMP_SYS(close), 0);</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (rc &lt; 0)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>goto out;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW,
SCMP_SYS(exit_group), 0);</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (rc &lt; 0)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>goto out;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW,
SCMP_SYS(exit), 0);</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (rc &lt; 0)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>goto out;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW,
SCMP_SYS(read), 3,</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="69%">


<p>SCMP_A0(SCMP_CMP_EQ, fd),</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="69%">


<p>SCMP_A1(SCMP_CMP_EQ, (scmp_datum_t)buf),</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="69%">


<p>SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (rc &lt; 0)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>goto out;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW,
SCMP_SYS(write), 1,</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="69%">


<p>SCMP_CMP(0, SCMP_CMP_EQ, fd));</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (rc &lt; 0)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>goto out;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>rc = seccomp_rule_add_array(ctx, SCMP_ACT_ALLOW,
SCMP_SYS(write), 1,</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">
</td>
<td width="69%">


<p>arg_cmp);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (rc &lt; 0)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>goto out;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>rc = seccomp_load(ctx);</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>if (rc &lt; 0)</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%">
</td>
<td width="8%">
</td>
<td width="8%">


<p>goto out;</p></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="8%">


<p>/* ... */</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">out:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>seccomp_release(ctx);</p></td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>return &minus;rc;</p></td></tr>
</table>

<p style="margin-left:11%;">}</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">While the
seccomp filter can be generated independent of the kernel,
kernel support is required to load and enforce the seccomp
filter generated by libseccomp.</p>

<p style="margin-left:11%; margin-top: 1em">The libseccomp
project site, with more information and the source code
repository, can be found at
https://github.com/seccomp/libseccomp. This tool, as well as
the libseccomp library, is currently under development,
please report any bugs at the project site or directly to
the author.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The runtime
behavior of seccomp filters is dependent upon the kernel
version, the processor architecture, and other libraries
including libc. This could affect the return code of a
seccomp filter.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>*</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>PowerPC glibc will not return a negative number when the
<b>getpid()</b> syscall is invoked. If a seccomp filter has
been created where <b>getpid()</b> will return a negative
number from the kernel, then PowerPC glibc will return the
absolute value of the errno. In this case, it is very
difficult for an application to distinguish between the
errno and a valid pid.</p></td></tr>
</table>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Paul Moore
&lt;paul@paul-moore.com&gt;</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>seccomp_syscall_resolve_name_rewrite</b>(3),
<b>seccomp_syscall_priority</b>(3), <b>seccomp_load</b>(3),
<b>seccomp_attr_set</b>(3)</p>
<hr>
</body>
</html>
