<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:10 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::__detail</title>

</head>
<body>
<h1>std::__detail</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">std::__detail
&minus; Implementation details not part of the namespace std
interface.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Classes</b></p>

<p style="margin-left:17%;">struct <b>_BracketMatcher</b>
<br>
Matches a character range (bracket expression) <br>
class <b>_Compiler</b> <br>
Builds an NFA from an input iterator range. <br>
class <b>_Executor</b> <br>
Takes a regex and an input string and does the matching.
<br>
struct <b>_List_node_base</b> <br>
Common part of a node in the list. <br>
struct <b>_List_node_header</b> <br>
The list node header. <br>
struct <b>_Quoted_string</b> <br>
Struct for delimited strings. <br>
class <b>_Scanner</b> <br>
Scans an input range for regex tokens. <br>
class <b>_StateSeq</b> <br>
Describes a sequence of one or more _State, its current
start and end(s). This structure contains fragments of an
NFA during construction.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Typedefs</b></p>

<p style="margin-left:17%;">using <b>__bare_timed_wait</b>
= __timed_waiter&lt; <b>std::false_type</b> &gt; <br>
using <b>__bare_wait</b> = __waiter&lt;
<b>std::false_type</b> &gt; <br>
template&lt;typename _Cat , typename _Limit , typename
_Otherwise = _Cat&gt; using <b>__clamp_iter_cat</b> =
__conditional_t&lt; derived_from&lt; _Cat, _Limit &gt;,
_Limit, _Otherwise &gt; <br>
template&lt;typename _Tp , typename _Up &gt; using
<b>__cmp3way_res_t</b> = decltype(<b>std::declval</b>&lt;
_Tp &gt;()&lt;=&gt; <b>std::declval</b>&lt; _Up &gt;()) <br>
template&lt;typename _Tp &gt; using <b>__cref</b> = const
<b>remove_reference_t</b>&lt; _Tp &gt; &amp; <br>
using <b>__enters_timed_wait</b> = __timed_waiter&lt;
<b>std::true_type</b> &gt; <br>
using <b>__enters_wait</b> = __waiter&lt;
<b>std::true_type</b> &gt; <br>
template&lt;typename _Tp &gt; using
<b>__integer_from_chars_result_type</b> =
<b>enable_if_t</b>&lt; __or_&lt; __is_signed_integer&lt; _Tp
&gt;, __is_unsigned_integer&lt; _Tp &gt;, <b>is_same</b>&lt;
char, <b>remove_cv_t</b>&lt; _Tp &gt; &gt; &gt;::value,
<b>from_chars_result</b> &gt; <br>
template&lt;typename _Tp &gt; using
<b>__integer_to_chars_result_type</b> =
<b>enable_if_t</b>&lt; __or_&lt; __is_signed_integer&lt; _Tp
&gt;, __is_unsigned_integer&lt; _Tp &gt;, <b>is_same</b>&lt;
char, <b>remove_cv_t</b>&lt; _Tp &gt; &gt; &gt;::value,
<b>to_chars_result</b> &gt; <br>
template&lt;typename _Iter &gt; using <b>__iter_concept</b>
= typename __iter_concept_impl&lt; _Iter &gt;::type <br>
template&lt;typename _Tp &gt; using <b>__iter_diff_t</b> =
typename __iter_traits&lt; _Tp, incrementable_traits&lt; _Tp
&gt; &gt;::difference_type <br>
template&lt;typename _Iter , typename _Tp = _Iter&gt; using
<b>__iter_traits</b> = typename __iter_traits_impl&lt;
_Iter, _Tp &gt;::type <br>
template&lt;typename _Tp &gt; using <b>__iter_value_t</b> =
typename __iter_traits&lt; _Tp,
indirectly_readable_traits&lt; _Tp &gt; &gt;::value_type
<br>
using <b>__platform_wait_t</b> = unsigned int <br>
template&lt;typename _Tp &gt; using <b>__range_iter_t</b> =
decltype(ranges::__cust_access::__begin(<b>std::declval</b>&lt;
_Tp &amp; &gt;())) <br>
template&lt;typename _Tp , typename _Up = _Tp&gt; using
<b>__synth3way_t</b> =
decltype(__detail::__synth3way(<b>std::declval</b>&lt; _Tp
&amp; &gt;(), <b>std::declval</b>&lt; _Up &amp; &gt;()))
<br>
template&lt;typename _Tp &gt; using
<b>__unsigned_least_t</b> = typename
__to_chars_unsigned_type&lt; _Tp &gt;::type <br>
using <b>__wait_clock_t</b> = <b>chrono::steady_clock</b>
<br>
template&lt;typename _Tp &gt; using <b>__with_ref</b> = _Tp
&amp; <br>
template&lt;typename _CharT &gt; using <b>_Matcher</b> =
std::function&lt; bool(_CharT)&gt; <br>
typedef long <b>_StateIdT</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Enumerations</b></p>

<p style="margin-left:17%;">enum <b>_Opcode</b> : int {
<b>_S_opcode_unknown</b>, <b>_S_opcode_alternative</b>,
<b>_S_opcode_repeat</b>, <b>_S_opcode_backref</b>,
<b>_S_opcode_line_begin_assertion</b>,
<b>_S_opcode_line_end_assertion</b>,
<b>_S_opcode_word_boundary</b>,
<b>_S_opcode_subexpr_lookahead</b>,
<b>_S_opcode_subexpr_begin</b>,
<b>_S_opcode_subexpr_end</b>, <b>_S_opcode_dummy</b>,
<b>_S_opcode_match</b>, <b>_S_opcode_accept</b> } <br>
Operation codes that define the type of transitions within
the base NFA that represents the regular expression. <br>
enum class <b>_RegexExecutorPolicy</b> : int {
<b>_S_auto</b>, <b>_S_alternate</b> }</p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;">template&lt;typename _Res ,
typename _Tp &gt; constexpr _Res <b>__abs_r</b> (_Tp __val)
<br>
template&lt;typename &gt; void <b>__abs_r</b> (bool)=delete
<br>
template&lt;typename _Tp &gt; bool <b>__atomic_compare</b>
(const _Tp &amp;__a, const _Tp &amp;__b) <br>
template&lt;typename _Pred , typename _Spin =
__default_spin_policy&gt; bool <b>__atomic_spin</b> (_Pred
&amp;__pred, _Spin __spin=_Spin{ }) noexcept <br>
template&lt;typename... _Ts&gt; constexpr auto
<b>__common_cmp_cat</b> () <br>
template&lt;typename _Clock , typename _Dur &gt; bool
<b>__cond_wait_until</b> (__condvar &amp;__cv, <b>mutex</b>
&amp;__mx, const <b>chrono::time_point</b>&lt; _Clock, _Dur
&gt; &amp;__atime) <br>
template&lt;typename _Clock , typename _Dur &gt; bool
<b>__cond_wait_until_impl</b> (__condvar &amp;__cv,
<b>mutex</b> &amp;__mx, const <b>chrono::time_point</b>&lt;
_Clock, _Dur &gt; &amp;__atime) <br>
template&lt;typename _Container , typename _UnsafeContainer
, typename _Predicate &gt; _Container::size_type
<b>__erase_nodes_if</b> (_Container &amp;__cont,
_UnsafeContainer &amp;__ucont, _Predicate __pred) <br>
template&lt;typename _ValT , typename _CharT , typename
_Traits &gt; <b>basic_istream</b>&lt; _CharT, _Traits &gt;
&amp; <b>__extract_params</b> (<b>basic_istream</b>&lt;
_CharT, _Traits &gt; &amp;__is, <b>vector</b>&lt; _ValT &gt;
&amp;__vals, size_t __n) <br>
template&lt;bool _DecOnly, typename _Tp &gt; constexpr bool
<b>__from_chars_alnum</b> (const char *&amp;__first, const
char *__last, _Tp &amp;__val, int __base) <br>
std::from_chars implementation for integers in any base. If
_DecOnly is true, then we may assume __base is at most 10.
<br>
template&lt;bool _DecOnly = false&gt; constexpr unsigned
char <b>__from_chars_alnum_to_val</b> (unsigned char __c)
<br>
template&lt;bool _DecOnly, typename _Tp &gt; constexpr bool
<b>__from_chars_pow2_base</b> (const char *&amp;__first,
const char *__last, _Tp &amp;__val, int __base) <br>
std::from_chars implementation for integers in a
power-of-two base. If _DecOnly is true, then we may assume
__base is at most 8. <br>
template&lt;typename _Tp &gt; constexpr _Tp <b>__gcd</b>
(_Tp __m, _Tp __n) <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__p1_representable_as_double</b> (_Tp __x) noexcept <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__raise_and_add</b> (_Tp &amp;__val, int __base, unsigned
char __c) <br>
template&lt;typename _BiIter , typename _Alloc , typename
_CharT , typename _TraitsT &gt; bool
<b>__regex_algo_impl</b> (_BiIter __s, _BiIter __e,
<b>match_results</b>&lt; _BiIter, _Alloc &gt; &amp;__m,
const <b>basic_regex</b>&lt; _CharT, _TraitsT &gt;
&amp;__re, <b>regex_constants::match_flag_type</b> __flags,
_RegexExecutorPolicy __policy, bool __match_mode) <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__representable_as_double</b> (_Tp __x) noexcept <br>
template&lt;typename _Tp &gt; void
<b>__return_temporary_buffer</b> (_Tp *__p, size_t __len)
<br>
void <b>__thread_relax</b> () noexcept <br>
void <b>__thread_yield</b> () noexcept <br>
template&lt;typename _Tp &gt; constexpr <b>to_chars_result
__to_chars</b> (char *__first, char *__last, _Tp __val, int
__base) noexcept <br>
template&lt;typename _Tp &gt; constexpr
__integer_to_chars_result_type&lt; _Tp &gt;
<b>__to_chars_10</b> (char *__first, char *__last, _Tp
__val) noexcept <br>
template&lt;typename _Tp &gt; constexpr void
<b>__to_chars_10_impl</b> (char *__first, unsigned __len,
_Tp __val) noexcept <br>
template&lt;typename _Tp &gt; constexpr
__integer_to_chars_result_type&lt; _Tp &gt;
<b>__to_chars_16</b> (char *__first, char *__last, _Tp
__val) noexcept <br>
template&lt;typename _Tp &gt; constexpr
__integer_to_chars_result_type&lt; _Tp &gt;
<b>__to_chars_2</b> (char *__first, char *__last, _Tp __val)
noexcept <br>
template&lt;typename _Tp &gt; constexpr
__integer_to_chars_result_type&lt; _Tp &gt;
<b>__to_chars_8</b> (char *__first, char *__last, _Tp __val)
noexcept <br>
template&lt;typename _Tp &gt; constexpr unsigned
<b>__to_chars_len</b> (_Tp __value, int __base) noexcept
<br>
template&lt;typename _Tp &gt; constexpr unsigned
<b>__to_chars_len_2</b> (_Tp __value) noexcept <br>
template&lt;typename _Dur &gt; <b>__wait_clock_t::time_point
__to_wait_clock</b> (const <b>chrono::time_point</b>&lt;
<b>__wait_clock_t</b>, _Dur &gt; &amp;__atime) noexcept <br>
template&lt;typename _Clock , typename _Dur &gt;
<b>__wait_clock_t::time_point __to_wait_clock</b> (const
<b>chrono::time_point</b>&lt; _Clock, _Dur &gt;
&amp;__atime) noexcept <br>
template&lt;typename _CharT , typename _Traits , typename
_String &gt; <b>std::basic_ostream</b>&lt; _CharT, _Traits
&gt; &amp; <b>operator&lt;&lt;</b>
(<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt;
&amp;__os, const <b>_Quoted_string</b>&lt; _String, _CharT
&gt; &amp;__str) <br>
Inserter for quoted strings. <br>
template&lt;typename _CharT , typename _Traits &gt;
<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;
<b>operator&lt;&lt;</b> (<b>std::basic_ostream</b>&lt;
_CharT, _Traits &gt; &amp;__os, const
<b>_Quoted_string</b>&lt; const _CharT *, _CharT &gt;
&amp;__str) <br>
Inserter for quoted strings. <br>
template&lt;typename _CharT , typename _Traits , typename
_Alloc &gt; <b>std::basic_istream</b>&lt; _CharT, _Traits
&gt; &amp; <b>operator&gt;&gt;</b>
(<b>std::basic_istream</b>&lt; _CharT, _Traits &gt;
&amp;__is, const <b>_Quoted_string</b>&lt;
<b>basic_string</b>&lt; _CharT, _Traits, _Alloc &gt; &amp;,
_CharT &gt; &amp;__str) <br>
Extractor for delimited strings. The left and right
delimiters can be different.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Variables</b></p>

<p style="margin-left:17%;">constexpr auto
<b>__atomic_spin_count</b> <br>
constexpr auto <b>__atomic_spin_count_relax</b> <br>
template&lt;typename _Tp &gt; constexpr unsigned
<b>__cmp_cat_id</b> <br>
template&lt;&gt; constexpr unsigned <b>__cmp_cat_id&lt;
partial_ordering &gt;</b> <br>
template&lt;&gt; constexpr unsigned <b>__cmp_cat_id&lt;
strong_ordering &gt;</b> <br>
template&lt;&gt; constexpr unsigned <b>__cmp_cat_id&lt;
weak_ordering &gt;</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__destructible</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__destructible&lt; _Tp &amp; &gt;</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__destructible&lt; _Tp &amp;&amp; &gt;</b> <br>
template&lt;typename _Tp , size_t _Nm&gt; constexpr bool
<b>__destructible&lt; _Tp[_Nm]&gt;</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__destructible_impl</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__destructible_impl&lt; _Tp &gt;</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__is_span</b> <br>
template&lt;typename _Tp , size_t _Num&gt; constexpr bool
<b>__is_span&lt; span&lt; _Tp, _Num &gt; &gt;</b> <br>
template&lt;typename _Tp &gt; constexpr bool
<b>__is_std_array</b> <br>
constexpr size_t <b>__platform_wait_alignment</b> <br>
constexpr struct std::__detail::_Synth3way
<b>__synth3way</b> <br>
constexpr _StateIdT <b>_S_invalid_state_id</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Implementation
details not part of the namespace std interface.</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;bool
_DecOnly, typename _Tp &gt; constexpr bool
std::__detail::__from_chars_alnum (const char *&amp;
__first, const char * __last, _Tp &amp; __val, int
__base)</b> <tt>[constexpr]</tt> <br>
std::from_chars implementation for integers in any base. If
_DecOnly is true, then we may assume __base is at most
10.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;bool
_DecOnly, typename _Tp &gt; constexpr bool
std::__detail::__from_chars_pow2_base (const char *&amp;
__first, const char * __last, _Tp &amp; __val, int
__base)</b> <tt>[constexpr]</tt> <br>
std::from_chars implementation for integers in a
power-of-two base. If _DecOnly is true, then we may assume
__base is at most 8.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT , typename _Traits , typename _String &gt;
std::basic_ostream&lt; _CharT, _Traits &gt; &amp;
std::__detail::operator&lt;&lt; (std::basic_ostream&lt;
_CharT, _Traits &gt; &amp; __os, const _Quoted_string&lt;
_String, _CharT &gt; &amp; __str)</b> <br>
Inserter for quoted strings.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT , typename _Traits &gt; std::basic_ostream&lt;
_CharT, _Traits &gt; &amp; std::__detail::operator&lt;&lt;
(std::basic_ostream&lt; _CharT, _Traits &gt; &amp; __os,
const _Quoted_string&lt; const _CharT *, _CharT &gt; &amp;
__str)</b> <br>
Inserter for quoted strings.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_CharT , typename _Traits , typename _Alloc &gt;
std::basic_istream&lt; _CharT, _Traits &gt; &amp;
std::__detail::operator&gt;&gt; (std::basic_istream&lt;
_CharT, _Traits &gt; &amp; __is, const _Quoted_string&lt;
basic_string&lt; _CharT, _Traits, _Alloc &gt; &amp;, _CharT
&gt; &amp; __str)</b> <br>
Extractor for delimited strings. The left and right
delimiters can be different.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::basic_ios&lt; _CharT, _Traits &gt;::clear()</b>,
<b>std::ios_base::flags()</b>, <b>std::basic_ios&lt; _CharT,
_Traits &gt;::good()</b>, <b>std::ios_base::setf()</b>,
<b>std::ios_base::skipws</b>, and <b>std::basic_istream&lt;
_CharT, _Traits &gt;::unget()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
