<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:12 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence, _Category &gt;</title>

</head>
<body>
<h1>__gnu_debug::_Safe_iterator</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">__gnu_debug::_Safe_iterator&lt;
_Iterator, _Sequence, _Category &gt; &minus; Safe iterator
wrapper.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;safe_iterator.h&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em">Inherits
_Iterator, and <b>__gnu_debug::_Safe_iterator_base</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Inherited by
__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
std::random_access_iterator_tag &gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef
<b>_Safe_iterator</b>&lt; _Iterator, _Sequence,
iterator_category &gt; <b>_Self</b> <br>
typedef _Traits::difference_type <b>difference_type</b> <br>
typedef _Traits::iterator_category <b>iterator_category</b>
<br>
using <b>iterator_concept</b> =
std::__detail::__iter_concept&lt; _Iterator &gt; <br>
typedef _Iterator <b>iterator_type</b> <br>
typedef _Traits::pointer <b>pointer</b> <br>
typedef _Traits::reference <b>reference</b> <br>
typedef _Traits::value_type <b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>_Safe_iterator</b> ()
noexcept <b><br>
_Safe_iterator</b> (_Iterator __i, const
<b>_Safe_sequence_base</b> *__seq) noexcept <br>
Safe iterator construction from an unsafe iterator and its
sequence. <b><br>
_Safe_iterator</b> (<b>_Safe_iterator</b> &amp;&amp;__x)
noexcept <br>
Move construction. <b><br>
_Safe_iterator</b> (const <b>_Safe_iterator</b> &amp;__x)
noexcept <br>
Copy construction. <br>
template&lt;typename _MutableIterator &gt;
<b>_Safe_iterator</b> (const <b>_Safe_iterator</b>&lt;
_MutableIterator, _Sequence, typename
__gnu_cxx::__enable_if&lt; _IsConstant::__value
&amp;&amp;std::__are_same&lt; _MutableIterator,
_OtherIterator &gt;::__value, _Category &gt;::__type &gt;
&amp;__x) noexcept <br>
Converting constructor from a mutable iterator to a constant
iterator. <br>
void <b>_M_attach</b> (<b>_Safe_sequence_base</b> *__seq)
<br>
void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b>
*__seq) <br>
bool <b>_M_attached_to</b> (const <b>_Safe_sequence_base</b>
*__seq) const <br>
bool <b>_M_before_dereferenceable</b> () const <br>
Is the iterator before a dereferenceable one? <br>
template&lt;typename _Diff &gt; bool <b>_M_can_advance</b>
(const <b>std::pair</b>&lt; _Diff,
<b>_Distance_precision</b> &gt; &amp;__dist, int __way)
const <br>
bool <b>_M_can_advance</b> (difference_type __n, bool
__strict=false) const <br>
bool <b>_M_can_compare</b> (const <b>_Safe_iterator_base</b>
&amp;__x) const throw () <br>
bool <b>_M_dereferenceable</b> () const <br>
Is the iterator dereferenceable? <br>
void <b>_M_detach_single</b> () throw () <br>
_Distance_traits&lt; _Iterator &gt;::__type
<b>_M_get_distance_from_begin</b> () const <br>
_Distance_traits&lt; _Iterator &gt;::__type
<b>_M_get_distance_to</b> (const <b>_Safe_iterator</b>
&amp;__rhs) const <br>
_Distance_traits&lt; _Iterator &gt;::__type
<b>_M_get_distance_to_end</b> () const <br>
__gnu_cxx::__conditional_type&lt; _IsConstant::__value,
const_Sequence *, _Sequence * &gt;::__type
<b>_M_get_sequence</b> () const <br>
bool <b>_M_incrementable</b> () const <br>
Is the iterator incrementable? <br>
void <b>_M_invalidate</b> () <br>
bool <b>_M_is_before_begin</b> () const <br>
Is this iterator equal to the sequence&rsquo;s
before_begin() iterator if any? <br>
bool <b>_M_is_begin</b> () const <br>
Is this iterator equal to the sequence&rsquo;s begin()
iterator? <br>
bool <b>_M_is_beginnest</b> () const <br>
Is this iterator equal to the sequence&rsquo;s
before_begin() iterator if any or begin() otherwise? <br>
bool <b>_M_is_end</b> () const <br>
Is this iterator equal to the sequence&rsquo;s end()
iterator? <br>
void <b>_M_reset</b> () throw () <br>
bool <b>_M_singular</b> () const throw () <br>
void <b>_M_unlink</b> () throw () <br>
bool <b>_M_valid_range</b> (const <b>_Safe_iterator</b>
&amp;__rhs, <b>std::pair</b>&lt; difference_type,
<b>_Distance_precision</b> &gt; &amp;__dist, bool
__check_dereferenceable=true) const <br>
bool <b>_M_value_initialized</b> () const <br>
Is the iterator value-initialized? <br>
const _Iterator &amp; <b>base</b> () const noexcept <br>
_Iterator &amp; <b>base</b> () noexcept <br>
Return the underlying iterator. <b><br>
operator _Iterator</b> () const noexcept <br>
Conversion to underlying non-debug iterator to allow better
interaction with non-debug containers. <br>
reference <b>operator*</b> () const noexcept <br>
Iterator dereference. <b><br>
_Safe_iterator</b> &amp; <b>operator++</b> () noexcept <br>
Iterator preincrement. <b><br>
_Safe_iterator operator++</b> (int) noexcept <br>
Iterator postincrement. <br>
pointer <b>operator&minus;&gt;</b> () const noexcept <br>
Iterator dereference. <b><br>
_Safe_iterator</b> &amp; <b>operator=</b>
(<b>_Safe_iterator</b> &amp;&amp;__x) noexcept <br>
Move assignment. <b><br>
_Safe_iterator</b> &amp; <b>operator=</b> (const
<b>_Safe_iterator</b> &amp;__x) noexcept <br>
Copy assignment.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Public Member Functions</b></p>

<p style="margin-left:17%;">static constexpr bool
<b>_S_constant</b> () <br>
Determine if this is a constant iterator.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Attributes</b></p>

<p style="margin-left:17%;"><b>_Safe_iterator_base</b> *
<b>_M_next <br>
_Safe_iterator_base</b> * <b>_M_prior <br>
_Safe_sequence_base</b> * <b>_M_sequence</b> <br>
unsigned int <b>_M_version</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Types</b></p>

<p style="margin-left:17%;">typedef std::__are_same&lt;
typename _Sequence::_Base::const_iterator, _Iterator &gt;
<b>_IsConstant</b> <br>
typedef __gnu_cxx::__conditional_type&lt;
_IsConstant::__value, typename_Sequence::_Base::iterator,
typename_Sequence::_Base::const_iterator &gt;::__type
<b>_OtherIterator</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Member Functions</b></p>

<p style="margin-left:17%;"><b>_Safe_iterator</b> (const
<b>_Safe_iterator</b> &amp;__x, _Unchecked) noexcept <br>
void <b>_M_attach</b> (<b>_Safe_sequence_base</b> *__seq,
bool __constant) <br>
void <b>_M_attach_single</b> (<b>_Safe_sequence_base</b>
*__seq, bool __constant) throw () <br>
void <b>_M_detach</b> () <br>
__gnu_cxx::__mutex &amp; <b>_M_get_mutex</b> () throw ()</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename _IteR &gt;
bool <b>operator!=</b> (const <b>_Self</b> &amp;__lhs, const
<b>_Safe_iterator</b>&lt; _IteR, _Sequence,
iterator_category &gt; &amp;__rhs) noexcept <br>
bool <b>operator!=</b> (const <b>_Self</b> &amp;__lhs, const
<b>_Self</b> &amp;__rhs) noexcept <br>
template&lt;typename _IteR &gt; bool <b>operator==</b>
(const <b>_Self</b> &amp;__lhs, const
<b>_Safe_iterator</b>&lt; _IteR, _Sequence,
iterator_category &gt; &amp;__rhs) noexcept <br>
bool <b>operator==</b> (const <b>_Self</b> &amp;__lhs, const
<b>_Self</b> &amp;__rhs) noexcept</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator, typename _Sequence, typename _Category = typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;</b>
<br>
class __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;&quot;Safe iterator wrapper.</p>

<p style="margin-left:11%; margin-top: 1em">The class
template _Safe_iterator is a wrapper around an iterator that
tracks the iterator&rsquo;s movement among sequences and
checks that operations performed on the &rsquo;safe&rsquo;
iterator are legal. In additional to the basic iterator
operations (which are validated, and then passed to the
underlying iterator), _Safe_iterator has member functions
for iterator invalidation, attaching/detaching the iterator
from sequences, and querying the iterator&rsquo;s state.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
_Iterator must be the first base class so that it gets
initialized before the iterator is being attached to the
container&rsquo;s list of iterators and it is being detached
before _Iterator get destroyed. Otherwise it would result in
a data race.</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <b><br>
Postcondition</b></p>

<p style="margin-left:17%;">the iterator is singular and
unattached</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator (_Iterator __i, const
_Safe_sequence_base * __seq)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Safe iterator construction from an unsafe iterator and its
sequence.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;"><tt>seq</tt> is not NULL</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">this is not singular</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator (const _Safe_iterator&lt;
_Iterator, _Sequence, _Category &gt; &amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Copy construction.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator (_Safe_iterator&lt;
_Iterator, _Sequence, _Category &gt; &amp;&amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Move construction.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">__x is singular and
unattached</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_detach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
template&lt;typename _MutableIterator &gt;
__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator (const _Safe_iterator&lt;
_MutableIterator, _Sequence, typename
__gnu_cxx::__enable_if&lt; _IsConstant::__value
&amp;&amp;std::__are_same&lt; _MutableIterator,
_OtherIterator &gt;::__value, _Category &gt;::__type &gt;
&amp; __x)</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Converting constructor from a mutable iterator to a constant
iterator.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
void __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach (_Safe_sequence_base * __seq)</b>
<tt>[inline]</tt> <br>
Attach iterator to the given sequence.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_attach()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_S_constant()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_attach
(_Safe_sequence_base * __seq, bool __constant)</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
Attaches this iterator to the given sequence, detaching it
from whatever sequence it was attached to originally. If the
new sequence is the NULL pointer, the iterator is left
unattached.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base()</b>,
and <b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
void __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach_single (_Safe_sequence_base *
__seq)</b> <tt>[inline]</tt> <br>
Likewise, but not thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_attach_single()</b>,
and <b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_S_constant()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_attach_single
(_Safe_sequence_base * __seq, bool __constant)</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
Likewise, but not thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach_single()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_attached_to (const
_Safe_sequence_base * __seq) const</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Determines if we are attached to the given sequence.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
bool __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_before_dereferenceable () const</b>
<tt>[inline]</tt> <br>
Is the iterator before a dereferenceable one?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::__base()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_incrementable()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_can_compare (const
_Safe_iterator_base &amp; __x) const</b>
<tt>[inherited]</tt> <br>
Can we compare this iterator to the given iterator
<tt>__x</tt>? Returns true if both iterators are nonsingular
and reference the same sequence.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
bool __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_dereferenceable () const</b>
<tt>[inline]</tt> <br>
Is the iterator dereferenceable?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_before_begin()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_end()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator*()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator&minus;&gt;()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_detach ()</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
Detach the iterator for whatever sequence it is attached to,
if any.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_detach_single ()</b>
<tt>[inherited]</tt> <br>
Likewise, but not thread-safe.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>__gnu_cxx::__mutex
&amp; __gnu_debug::_Safe_iterator_base::_M_get_mutex ()</b>
<tt>[protected]</tt><b>,</b> <tt>[inherited]</tt> <br>
For use in _Safe_iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator++()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator++()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
bool __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_incrementable () const</b>
<tt>[inline]</tt> <br>
Is the iterator incrementable?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_end()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_before_dereferenceable()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator++()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_invalidate ()</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Invalidate the iterator, making it singular.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
bool __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_before_begin () const</b>
<tt>[inline]</tt> <br>
Is this iterator equal to the sequence&rsquo;s
before_begin() iterator if any?</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_dereferenceable()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
bool __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_begin () const</b> <tt>[inline]</tt>
<br>
Is this iterator equal to the sequence&rsquo;s begin()
iterator?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
bool __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_beginnest () const</b>
<tt>[inline]</tt> <br>
Is this iterator equal to the sequence&rsquo;s
before_begin() iterator if any or begin() otherwise?</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
bool __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_end () const</b> <tt>[inline]</tt>
<br>
Is this iterator equal to the sequence&rsquo;s end()
iterator?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_dereferenceable()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_incrementable()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_reset ()</b>
<tt>[inherited]</tt> <br>
Reset all member variables</p>

<p style="margin-left:11%; margin-top: 1em"><b>bool
__gnu_debug::_Safe_iterator_base::_M_singular () const</b>
<tt>[inherited]</tt> <br>
Is this iterator singular?</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>,
<b>__gnu_debug::__check_singular_aux()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_dereferenceable()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_dereferenceable()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_incrementable()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_incrementable()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
__gnu_debug::_Safe_iterator_base::_M_unlink ()</b>
<tt>[inline]</tt><b>,</b> <tt>[inherited]</tt> <br>
Unlink itself</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_next</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_prior</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
bool __gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized () const</b>
<tt>[inline]</tt> <br>
Is the iterator value-initialized?</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
static constexpr bool __gnu_debug::_Safe_iterator&lt;
_Iterator, _Sequence, _Category &gt;::_S_constant ()</b>
<tt>[inline]</tt><b>,</b> <tt>[static]</tt><b>,</b>
<tt>[constexpr]</tt> <br>
Determine if this is a constant iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach_single()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
_Iterator &amp; __gnu_debug::_Safe_iterator&lt; _Iterator,
_Sequence, _Category &gt;::base ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Return the underlying iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_before_dereferenceable()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_begin()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_is_end()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator*()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator++()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator&minus;&gt;()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator _Iterator () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Conversion to underlying non-debug iterator to allow better
interaction with non-debug containers.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
reference __gnu_debug::_Safe_iterator&lt; _Iterator,
_Sequence, _Category &gt;::operator* () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Iterator dereference.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">iterator is dereferenceable</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_dereferenceable()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
_Safe_iterator &amp; __gnu_debug::_Safe_iterator&lt;
_Iterator, _Sequence, _Category &gt;::operator++ ()</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Iterator preincrement.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">iterator is incrementable</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_incrementable()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
_Safe_iterator __gnu_debug::_Safe_iterator&lt; _Iterator,
_Sequence, _Category &gt;::operator++ (int)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Iterator postincrement.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">iterator is incrementable</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_incrementable()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
pointer __gnu_debug::_Safe_iterator&lt; _Iterator,
_Sequence, _Category &gt;::operator&minus;&gt; () const</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Iterator dereference.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Precondition</b></p>

<p style="margin-left:17%;">iterator is dereferenceable</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_dereferenceable()</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
_Safe_iterator &amp; __gnu_debug::_Safe_iterator&lt;
_Iterator, _Sequence, _Category &gt;::operator=
(_Safe_iterator&lt; _Iterator, _Sequence, _Category &gt;
&amp;&amp; __x)</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Move assignment.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Postcondition</b></p>

<p style="margin-left:17%;">__x is singular and
unattached</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::__addressof()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_detach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>,
<b>__gnu_debug::_Safe_sequence_base::_M_version</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Iterator , typename _Sequence , typename _Category =
typename
std::iterator_traits&lt;_Iterator&gt;::iterator_category&gt;
_Safe_iterator &amp; __gnu_debug::_Safe_iterator&lt;
_Iterator, _Sequence, _Category &gt;::operator= (const
_Safe_iterator&lt; _Iterator, _Sequence, _Category &gt;
&amp; __x)</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt>
<br>
Copy assignment.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_attach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_detach()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_get_mutex()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_sequence</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_singular()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_version</b>,
<b>__gnu_debug::_Safe_sequence_base::_M_version</b>, and
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::base()</b>.</p>

<h2>Member Data Documentation
<a name="Member Data Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>_Safe_iterator_base*
__gnu_debug::_Safe_iterator_base::_M_next</b>
<tt>[inherited]</tt> <br>
Pointer to the next iterator in the sequence&rsquo;s list of
iterators. Only valid when _M_sequence != NULL.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_sequence&lt; _SafeSequence
&gt;::_M_invalidate_if()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>_Safe_iterator_base*
__gnu_debug::_Safe_iterator_base::_M_prior</b>
<tt>[inherited]</tt> <br>
Pointer to the previous iterator in the sequence&rsquo;s
list of iterators. Only valid when _M_sequence != NULL.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_sequence&lt; _SafeSequence
&gt;::_M_invalidate_if()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>, and
<b>__gnu_debug::_Safe_iterator_base::_M_unlink()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>_Safe_sequence_base*
__gnu_debug::_Safe_iterator_base::_M_sequence</b>
<tt>[inherited]</tt> <br>
The sequence this iterator references; may be NULL to
indicate a singular iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_Safe_iterator()</b>,
<b>__gnu_debug::_Safe_iterator_base::_Safe_iterator_base()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_Safe_local_iterator()</b>,
<b>__gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()</b>,
<b>__gnu_debug::_Safe_iterator_base::_M_attached_to()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>unsigned int
__gnu_debug::_Safe_iterator_base::_M_version</b>
<tt>[inherited]</tt> <br>
The version number of this iterator. The sentinel value 0 is
used to indicate an invalidated iterator (i.e., one that is
singular because of an operation on the container). This
version number must equal the version number in the sequence
referenced by _M_sequence for the iterator to be
non-singular.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>__gnu_debug::_Safe_iterator_base::_M_invalidate()</b>,
<b>__gnu_debug::_Safe_sequence&lt; _Sequence
&gt;::_M_transfer_from_if()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::_M_value_initialized()</b>,
<b>__gnu_debug::_Safe_iterator&lt; _Iterator, _Sequence,
_Category &gt;::operator=()</b>, and
<b>__gnu_debug::_Safe_local_iterator&lt; _Iterator,
_Sequence &gt;::operator=()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
