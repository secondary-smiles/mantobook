<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:14 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::regex_traits&lt; _Ch_type &gt;</title>

</head>
<body>
<h1>std::regex_traits</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">std::regex_traits&lt;
_Ch_type &gt; &minus; Describes aspects of a regular
expression.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;regex&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _RegexMask
<b>char_class_type</b> <br>
typedef _Ch_type <b>char_type</b> <br>
typedef <b>std::locale locale_type</b> <br>
typedef <b>std::basic_string</b>&lt; char_type &gt;
<b>string_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>regex_traits</b> () <br>
Constructs a default traits object. <b><br>
locale_type getloc</b> () const <br>
Gets a copy of the current locale in use by the regex_traits
object. <b><br>
locale_type imbue</b> (<b>locale_type</b> __loc) <br>
Imbues the regex_traits object with a copy of a new locale.
<br>
bool <b>isctype</b> (_Ch_type __c, char_class_type __f)
const <br>
Determines if <tt>c</tt> is a member of an identified class.
<br>
template&lt;typename _Fwd_iter &gt; char_class_type
<b>lookup_classname</b> (_Fwd_iter __first, _Fwd_iter
__last, bool __icase=false) const <br>
Maps one or more characters to a named character
classification. <br>
template&lt;typename _Fwd_iter &gt; <b>string_type
lookup_collatename</b> (_Fwd_iter __first, _Fwd_iter __last)
const <br>
Gets a collation element by name. <br>
template&lt;typename _Fwd_iter &gt; <b>string_type
transform</b> (_Fwd_iter __first, _Fwd_iter __last) const
<br>
Gets a sort key for a character sequence. <br>
template&lt;typename _Fwd_iter &gt; <b>string_type
transform_primary</b> (_Fwd_iter __first, _Fwd_iter __last)
const <br>
Gets a sort key for a character sequence, independent of
case. <br>
char_type <b>translate</b> (char_type __c) const <br>
Performs the identity translation. <br>
char_type <b>translate_nocase</b> (char_type __c) const <br>
Translates a character into a case-insensitive equivalent.
<br>
int <b>value</b> (_Ch_type __ch, int __radix) const <br>
Converts a digit to an int.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Static
Public Member Functions</b></p>

<p style="margin-left:17%;">static std::size_t
<b>length</b> (const char_type *__p) <br>
Gives the length of a C-style string starting at
<tt>__p</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Protected
Attributes</b></p>

<p style="margin-left:17%;"><b>locale_type
_M_locale</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type&gt;</b> <br>
class std::regex_traits&lt; _Ch_type &gt;&quot;Describes
aspects of a regular expression.</p>

<p style="margin-left:11%; margin-top: 1em">A regular
expression traits class that satisfies the requirements of
section [28.7].</p>

<p style="margin-left:11%; margin-top: 1em">The class regex
is parameterized around a set of related types and functions
used to complete the definition of its semantics. This class
satisfies the requirements of such a traits class.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++11</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; std::regex_traits&lt; _Ch_type
&gt;::regex_traits ()</b> <tt>[inline]</tt> <br>
Constructs a default traits object.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; locale_type std::regex_traits&lt; _Ch_type
&gt;::getloc () const</b> <tt>[inline]</tt> <br>
Gets a copy of the current locale in use by the regex_traits
object.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::regex_traits&lt; _CharType &gt;::isctype()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; locale_type std::regex_traits&lt; _Ch_type
&gt;::imbue (locale_type __loc)</b> <tt>[inline]</tt> <br>
Imbues the regex_traits object with a copy of a new
locale.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__loc</i> A locale.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a copy of the previous locale
in use by the regex_traits object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">Calling imbue with a different
locale than the one currently in use invalidates all cached
data held by *this.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::swap()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; bool std::regex_traits&lt; _Ch_type
&gt;::isctype (_Ch_type __c, char_class_type __f) const</b>
<br>
Determines if <tt>c</tt> is a member of an identified
class.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__c</i> a character. <i><br>
__f</i> a class type (as returned from
lookup_classname).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">true if the character
<tt>__c</tt> is a member of the classification represented
by <tt>__f</tt>, false otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::bad_cast</i> if the
current locale does not have a ctype facet.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; static std::size_t std::regex_traits&lt;
_Ch_type &gt;::length (const char_type * __p)</b>
<tt>[inline]</tt><b>,</b> <tt>[static]</tt> <br>
Gives the length of a C-style string starting at
<tt>__p</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__p</i> a pointer to the
start of a character sequence.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the number of characters
between <tt>*__p</tt> and the first default-initialized
value of type <tt>char_type</tt>. In other words, uses the
C-string algorithm for determining the length of a sequence
of characters.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::basic_string&lt; _CharT, _Traits, _Alloc
&gt;::length()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; template&lt;typename _Fwd_iter &gt;
regex_traits&lt; _Ch_type &gt;::char_class_type
std::regex_traits&lt; _Ch_type &gt;::lookup_classname
(_Fwd_iter __first, _Fwd_iter __last, bool __icase =</b>
<tt>false</tt><b>) const</b> <br>
Maps one or more characters to a named character
classification.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> beginning of the
character sequence. <i><br>
__last</i> one-past-the-end of the character sequence.
<i><br>
__icase</i> ignores the case of the classification name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">an unspecified value that
represents the character classification named by the
character sequence designated by the iterator range
[__first, __last). If <tt>icase</tt> is true, the returned
mask identifies the classification regardless of the case of
the characters to be matched (for example, [[:lower:]] is
the same as [[:alpha:]]), otherwise a case-dependent
classification is returned. The value returned shall be
independent of the case of the characters in the character
sequence. If the name is not recognized then returns a value
that compares equal to 0.</p>

<p style="margin-left:11%; margin-top: 1em">At least the
following names (or their wide-character equivalent) are
supported.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>d</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>w</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>s</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>alnum</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>alpha</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>blank</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>cntrl</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>digit</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>graph</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>lower</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>print</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>punct</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>space</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>upper</p></td>
<td width="77%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="9%">


<p>xdigit</p></td>
<td width="77%">
</td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; template&lt;typename _Fwd_iter &gt;
regex_traits&lt; _Ch_type &gt;::string_type
std::regex_traits&lt; _Ch_type &gt;::lookup_collatename
(_Fwd_iter __first, _Fwd_iter __last) const</b> <br>
Gets a collation element by name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> beginning of the
collation element name. <i><br>
__last</i> one-past-the-end of the collation element
name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a sequence of one or more
characters that represents the collating element consisting
of the character sequence designated by the iterator range
[__first, __last). Returns an empty string if the character
sequence is not a valid collating element.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; template&lt;typename _Fwd_iter &gt;
string_type std::regex_traits&lt; _Ch_type &gt;::transform
(_Fwd_iter __first, _Fwd_iter __last) const</b>
<tt>[inline]</tt> <br>
Gets a sort key for a character sequence.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> beginning of the
character sequence. <i><br>
__last</i> one-past-the-end of the character sequence.</p>

<p style="margin-left:11%; margin-top: 1em">Returns a sort
key for the character sequence designated by the iterator
range [F1, F2) such that if the character sequence [G1, G2)
sorts before the character sequence [H1, H2) then
v.transform(G1, G2) &lt; v.transform(H1, H2).</p>

<p style="margin-left:11%; margin-top: 1em">What this
really does is provide a more efficient way to compare a
string to multiple other strings in locales with fancy
collation rules and equivalence classes.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a locale-specific sort key
equivalent to the input range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::bad_cast</i> if the
current locale does not have a collate facet.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::basic_string&lt; _CharT, _Traits, _Alloc
&gt;::data()</b>, and <b>std::basic_string&lt; _CharT,
_Traits, _Alloc &gt;::size()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::regex_traits&lt; _Ch_type
&gt;::transform_primary()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; template&lt;typename _Fwd_iter &gt;
string_type std::regex_traits&lt; _Ch_type
&gt;::transform_primary (_Fwd_iter __first, _Fwd_iter
__last) const</b> <tt>[inline]</tt> <br>
Gets a sort key for a character sequence, independent of
case.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> beginning of the
character sequence. <i><br>
__last</i> one-past-the-end of the character sequence.</p>

<p style="margin-left:11%; margin-top: 1em">Effects: if
typeid(use_facet&lt;collate&lt;_Ch_type&gt; &gt;) ==
typeid(collate_byname&lt;_Ch_type&gt;) and the form of the
sort key returned by
collate_byname&lt;_Ch_type&gt;::transform(__first, __last)
is known and can be converted into a primary sort key then
returns that key, otherwise returns an empty string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Todo</b></p>

<p style="margin-left:17%;">Implement this function
correctly.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::regex_traits&lt; _Ch_type &gt;::transform()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; char_type std::regex_traits&lt; _Ch_type
&gt;::translate (char_type __c) const</b> <tt>[inline]</tt>
<br>
Performs the identity translation.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__c</i> A character to the
locale-specific character set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">__c.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; char_type std::regex_traits&lt; _Ch_type
&gt;::translate_nocase (char_type __c) const</b>
<tt>[inline]</tt> <br>
Translates a character into a case-insensitive
equivalent.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__c</i> A character to the
locale-specific character set.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the locale-specific lower-case
equivalent of __c.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::bad_cast</i> if the
imbued locale does not support the ctype facet.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Ch_type &gt; int std::regex_traits&lt; _Ch_type &gt;::value
(_Ch_type __ch, int __radix) const</b> <br>
Converts a digit to an int.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__ch</i> a character
representing a digit. <i><br>
__radix</i> the radix if the numeric conversion (limited to
8, 10, or 16).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the value represented by the
digit __ch in base radix if the character __ch is a valid
digit in base radix; otherwise returns -1.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::basic_ios&lt; _CharT, _Traits &gt;::fail()</b>,
<b>std::hex()</b>, and <b>std::oct()</b>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
