<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:29 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>libalpm_list</title>

</head>
<body>
<h1>libalpm_list</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">libalpm_list
&minus; libalpm_list(3)</p>

<p style="margin-left:11%; margin-top: 1em">&minus;
Functions to manipulate <b>alpm_list_t</b> lists.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Data
Structures</b></p>

<p style="margin-left:17%;">struct <b>alpm_list_t</b> <br>
A doubly linked list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Macros</b></p>

<p style="margin-left:17%;">#define <b>FREELIST</b>(p) do {
<b>alpm_list_free_inner</b>(p, free);
<b>alpm_list_free</b>(p); p = NULL; } while(0) <br>
Frees a list and its contents.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Typedefs</b></p>

<p style="margin-left:17%;">typedef void(*
<b>alpm_list_fn_free</b>) (void *item) <br>
item deallocation callback. <br>
typedef int(* <b>alpm_list_fn_cmp</b>) (const void *, const
void *) <br>
item comparison callback</p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;">void <b>alpm_list_free</b>
(<b>alpm_list_t</b> *list) <br>
Free a list, but not the contained data. <br>
void <b>alpm_list_free_inner</b> (<b>alpm_list_t</b> *list,
<b>alpm_list_fn_free</b> fn) <br>
Free the internal data of a list structure but not the list
itself. <b><br>
alpm_list_t</b> * <b>alpm_list_add</b> (<b>alpm_list_t</b>
*list, void *data) <br>
Add a new item to the end of the list. <b><br>
alpm_list_t</b> * <b>alpm_list_append</b>
(<b>alpm_list_t</b> **list, void *data) <br>
Add a new item to the end of the list. <b><br>
alpm_list_t</b> * <b>alpm_list_append_strdup</b>
(<b>alpm_list_t</b> **list, const char *data) <br>
Duplicate and append a string to a list. <b><br>
alpm_list_t</b> * <b>alpm_list_add_sorted</b>
(<b>alpm_list_t</b> *list, void *data,
<b>alpm_list_fn_cmp</b> fn) <br>
Add items to a list in sorted order. <b><br>
alpm_list_t</b> * <b>alpm_list_join</b> (<b>alpm_list_t</b>
*first, <b>alpm_list_t</b> *second) <br>
Join two lists. <b><br>
alpm_list_t</b> * <b>alpm_list_mmerge</b>
(<b>alpm_list_t</b> *left, <b>alpm_list_t</b> *right,
<b>alpm_list_fn_cmp</b> fn) <br>
Merge the two sorted sublists into one sorted list. <b><br>
alpm_list_t</b> * <b>alpm_list_msort</b> (<b>alpm_list_t</b>
*list, size_t n, <b>alpm_list_fn_cmp</b> fn) <br>
Sort a list of size <tt>n</tt> using mergesort algorithm.
<b><br>
alpm_list_t</b> * <b>alpm_list_remove_item</b>
(<b>alpm_list_t</b> *haystack, <b>alpm_list_t</b> *item)
<br>
Remove an item from the list. <b><br>
alpm_list_t</b> * <b>alpm_list_remove</b>
(<b>alpm_list_t</b> *haystack, const void *needle,
<b>alpm_list_fn_cmp</b> fn, void **data) <br>
Remove an item from the list. <b><br>
alpm_list_t</b> * <b>alpm_list_remove_str</b>
(<b>alpm_list_t</b> *haystack, const char *needle, char
**data) <br>
Remove a string from a list. <b><br>
alpm_list_t</b> * <b>alpm_list_remove_dupes</b> (const
<b>alpm_list_t</b> *list) <br>
Create a new list without any duplicates. <b><br>
alpm_list_t</b> * <b>alpm_list_strdup</b> (const
<b>alpm_list_t</b> *list) <br>
Copy a string list, including data. <b><br>
alpm_list_t</b> * <b>alpm_list_copy</b> (const
<b>alpm_list_t</b> *list) <br>
Copy a list, without copying data. <b><br>
alpm_list_t</b> * <b>alpm_list_copy_data</b> (const
<b>alpm_list_t</b> *list, size_t size) <br>
Copy a list and copy the data. <b><br>
alpm_list_t</b> * <b>alpm_list_reverse</b>
(<b>alpm_list_t</b> *list) <br>
Create a new list in reverse order. <b><br>
alpm_list_t</b> * <b>alpm_list_nth</b> (const
<b>alpm_list_t</b> *list, size_t n) <br>
Return nth element from list (starting from 0). <b><br>
alpm_list_t</b> * <b>alpm_list_next</b> (const
<b>alpm_list_t</b> *list) <br>
Get the next element of a list. <b><br>
alpm_list_t</b> * <b>alpm_list_previous</b> (const
<b>alpm_list_t</b> *list) <br>
Get the previous element of a list. <b><br>
alpm_list_t</b> * <b>alpm_list_last</b> (const
<b>alpm_list_t</b> *list) <br>
Get the last item in the list. <br>
size_t <b>alpm_list_count</b> (const <b>alpm_list_t</b>
*list) <br>
Get the number of items in a list. <br>
void * <b>alpm_list_find</b> (const <b>alpm_list_t</b>
*haystack, const void *needle, <b>alpm_list_fn_cmp</b> fn)
<br>
Find an item in a list. <br>
void * <b>alpm_list_find_ptr</b> (const <b>alpm_list_t</b>
*haystack, const void *needle) <br>
Find an item in a list. <br>
char * <b>alpm_list_find_str</b> (const <b>alpm_list_t</b>
*haystack, const char *needle) <br>
Find a string in a list. <br>
void <b>alpm_list_diff_sorted</b> (const <b>alpm_list_t</b>
*left, const <b>alpm_list_t</b> *right,
<b>alpm_list_fn_cmp</b> fn, <b>alpm_list_t</b> **onlyleft,
<b>alpm_list_t</b> **onlyright) <br>
Find the differences between list <tt>left</tt> and list
<tt>right</tt> <b><br>
alpm_list_t</b> * <b>alpm_list_diff</b> (const
<b>alpm_list_t</b> *lhs, const <b>alpm_list_t</b> *rhs,
<b>alpm_list_fn_cmp</b> fn) <br>
Find the items in list <tt>lhs</tt> that are not present in
list <tt>rhs</tt>. <br>
void * <b>alpm_list_to_array</b> (const <b>alpm_list_t</b>
*list, size_t n, size_t size) <br>
Copy a list and data into a standard C array of fixed
length.</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Functions to
manipulate <b>alpm_list_t</b> lists.</p>

<p style="margin-left:11%; margin-top: 1em">These functions
are designed to create, destroy, and modify lists of type
<b>alpm_list_t</b>. This is an internal list type used by
libalpm that is publicly exposed for use by frontends if
desired.</p>

<p style="margin-left:11%; margin-top: 1em">It is exposed
so front ends can use it to prevent the need to reimplement
lists of their own; however, it is not required that the
front end uses it.</p>

<h2>Data Structure Documentation
<a name="Data Structure Documentation"></a>
</h2>


<h2>struct alpm_list_t
<a name="struct alpm_list_t"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A doubly linked
list.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Data
Fields:</b></p>

<p style="margin-left:17%;">void * <i>data</i> data held by
the list node</p>

<p style="margin-left:17%; margin-top: 1em">struct
__alpm_list_t * <i>next</i> pointer to the next node</p>

<p style="margin-left:17%; margin-top: 1em">struct
__alpm_list_t * <i>prev</i> pointer to the previous node</p>

<h2>Macro Definition Documentation
<a name="Macro Definition Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#define
FREELIST(p) do { alpm_list_free_inner(p, free);
alpm_list_free(p); p = NULL; } while(0)</b> <br>
Frees a list and its contents.</p>

<h2>Typedef Documentation
<a name="Typedef Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>typedef
int(* alpm_list_fn_cmp) (const void *, const void *)</b>
<br>
item comparison callback</p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef
void(* alpm_list_fn_free) (void *item)</b> <br>
item deallocation callback.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>item</i> the item to
free</p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_add (alpm_list_t * list, void * data)</b> <br>
Add a new item to the end of the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to add to
<i><br>
data</i> the new item to be added to the list</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the resultant list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_add_sorted (alpm_list_t * list, void * data,
alpm_list_fn_cmp fn)</b> <br>
Add items to a list in sorted order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to add to
<i><br>
data</i> the new item to be added to the list <i><br>
fn</i> the comparison function to use to determine order</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the resultant list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_append (alpm_list_t ** list, void * data)</b>
<br>
Add a new item to the end of the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to add to
<i><br>
data</i> the new item to be added to the list</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the newly added item</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_append_strdup (alpm_list_t ** list, const char *
data)</b> <br>
Duplicate and append a string to a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to append
to <i><br>
data</i> the string to duplicate and append</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the newly added item</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_copy (const alpm_list_t * list)</b> <br>
Copy a list, without copying data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to
copy</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a copy of the original list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_copy_data (const alpm_list_t * list, size_t
size)</b> <br>
Copy a list and copy the data. Note that the data elements
to be copied should not contain pointers and should also be
of constant size.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to copy
<i><br>
size</i> the size of each data element</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a copy of the original list,
data copied as well</p>

<p style="margin-left:11%; margin-top: 1em"><b>size_t
alpm_list_count (const alpm_list_t * list)</b> <br>
Get the number of items in a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the number of list items</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_diff (const alpm_list_t * lhs, const alpm_list_t
* rhs, alpm_list_fn_cmp fn)</b> <br>
Find the items in list <tt>lhs</tt> that are not present in
list <tt>rhs</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>lhs</i> the first list
<i><br>
rhs</i> the second list <i><br>
fn</i> the comparison function</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a list containing all items in
<tt>lhs</tt> not present in <tt>rhs</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
alpm_list_diff_sorted (const alpm_list_t * left, const
alpm_list_t * right, alpm_list_fn_cmp fn, alpm_list_t **
onlyleft, alpm_list_t ** onlyright)</b> <br>
Find the differences between list <tt>left</tt> and list
<tt>right</tt> The two lists must be sorted. Items only in
list <tt>left</tt> are added to the <tt>onlyleft</tt> list.
Items only in list <tt>right</tt> are added to the
<tt>onlyright</tt> list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>left</i> the first list
<i><br>
right</i> the second list <i><br>
fn</i> the comparison function <i><br>
onlyleft</i> pointer to the first result list <i><br>
onlyright</i> pointer to the second result list</p>

<p style="margin-left:11%; margin-top: 1em"><b>void *
alpm_list_find (const alpm_list_t * haystack, const void *
needle, alpm_list_fn_cmp fn)</b> <br>
Find an item in a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>needle</i> the item to
search <i><br>
haystack</i> the list <i><br>
fn</i> the comparison function for searching (!= NULL)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;"><tt>needle</tt> if found, NULL
otherwise</p>

<p style="margin-left:11%; margin-top: 1em"><b>void *
alpm_list_find_ptr (const alpm_list_t * haystack, const void
* needle)</b> <br>
Find an item in a list. Search for the item whose data
matches that of the <tt>needle</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>needle</i> the data to
search for (== comparison) <i><br>
haystack</i> the list</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;"><tt>needle</tt> if found, NULL
otherwise</p>

<p style="margin-left:11%; margin-top: 1em"><b>char *
alpm_list_find_str (const alpm_list_t * haystack, const char
* needle)</b> <br>
Find a string in a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>needle</i> the string to
search for <i><br>
haystack</i> the list</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;"><tt>needle</tt> if found, NULL
otherwise</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
alpm_list_free (alpm_list_t * list)</b> <br>
Free a list, but not the contained data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to
free</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
alpm_list_free_inner (alpm_list_t * list, alpm_list_fn_free
fn)</b> <br>
Free the internal data of a list structure but not the list
itself.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to free
<i><br>
fn</i> a free function for the internal data</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_join (alpm_list_t * first, alpm_list_t *
second)</b> <br>
Join two lists. The two lists must be independent. Do not
free the original lists after calling this function, as this
is not a copy operation. The list pointers passed in should
be considered invalid after calling this function.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>first</i> the first list
<i><br>
second</i> the second list</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the resultant joined list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_last (const alpm_list_t * list)</b> <br>
Get the last item in the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the last element in the
list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_mmerge (alpm_list_t * left, alpm_list_t * right,
alpm_list_fn_cmp fn)</b> <br>
Merge the two sorted sublists into one sorted list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>left</i> the first list
<i><br>
right</i> the second list <i><br>
fn</i> comparison function for determining merge order</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the resultant list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_msort (alpm_list_t * list, size_t n,
alpm_list_fn_cmp fn)</b> <br>
Sort a list of size <tt>n</tt> using mergesort
algorithm.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to sort
<i><br>
n</i> the size of the list <i><br>
fn</i> the comparison function for determining order</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the resultant list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_next (const alpm_list_t * list)</b> <br>
Get the next element of a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list node</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the next element, or NULL when
no more elements exist</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_nth (const alpm_list_t * list, size_t n)</b>
<br>
Return nth element from list (starting from 0).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list <i><br>
n</i> the index of the item to find (n &lt;
alpm_list_count(list) IS needed)</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">an <b>alpm_list_t</b> node for
index <tt>n</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_previous (const alpm_list_t * list)</b> <br>
Get the previous element of a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list head</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the previous element, or NULL
when no previous element exist</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_remove (alpm_list_t * haystack, const void *
needle, alpm_list_fn_cmp fn, void ** data)</b> <br>
Remove an item from the list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>haystack</i> the list to
remove the item from <i><br>
needle</i> the data member of the item we&rsquo;re removing
<i><br>
fn</i> the comparison function for searching <i><br>
data</i> output parameter containing data of the removed
item</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the resultant list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_remove_dupes (const alpm_list_t * list)</b> <br>
Create a new list without any duplicates. This does NOT copy
data members.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to
copy</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a new list containing
non-duplicate items</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_remove_item (alpm_list_t * haystack, alpm_list_t
* item)</b> <br>
Remove an item from the list. item is not freed; this is the
responsibility of the caller.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>haystack</i> the list to
remove the item from <i><br>
item</i> the item to remove from the list</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the resultant list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_remove_str (alpm_list_t * haystack, const char *
needle, char ** data)</b> <br>
Remove a string from a list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>haystack</i> the list to
remove the item from <i><br>
needle</i> the data member of the item we&rsquo;re removing
<i><br>
data</i> output parameter containing data of the removed
item</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the resultant list</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_reverse (alpm_list_t * list)</b> <br>
Create a new list in reverse order.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to
copy</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a new list in reverse order</p>

<p style="margin-left:11%; margin-top: 1em"><b>alpm_list_t
* alpm_list_strdup (const alpm_list_t * list)</b> <br>
Copy a string list, including data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to
copy</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">a copy of the original list</p>

<p style="margin-left:11%; margin-top: 1em"><b>void *
alpm_list_to_array (const alpm_list_t * list, size_t n,
size_t size)</b> <br>
Copy a list and data into a standard C array of fixed
length. Note that the data elements are shallow copied so
any contained pointers will point to the original data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>list</i> the list to copy
<i><br>
n</i> the size of the list <i><br>
size</i> the size of each data element</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">an array version of the
original list, data copied as well</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libalpm from the source
code.</p>
<hr>
</body>
</html>
