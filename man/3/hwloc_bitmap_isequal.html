<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:15 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>hwlocality_bitmap</title>

</head>
<body>
<h1>hwloc_bitmap_isequal</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">hwlocality_bitmap
&minus; The bitmap API</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>Macros</b></p>

<p style="margin-left:17%;">#define
<b>hwloc_bitmap_foreach_begin</b>(id, bitmap) <br>
#define <b>hwloc_bitmap_foreach_end</b>()</p>


<p style="margin-left:11%; margin-top: 1em"><b>Typedefs</b></p>

<p style="margin-left:17%;">typedef struct hwloc_bitmap_s *
<b>hwloc_bitmap_t</b> <br>
typedef const struct hwloc_bitmap_s *
<b>hwloc_const_bitmap_t</b></p>


<p style="margin-left:11%; margin-top: 1em"><b>Functions</b></p>

<p style="margin-left:17%;"><b>hwloc_bitmap_t
hwloc_bitmap_alloc</b> (void) <b><br>
hwloc_bitmap_t hwloc_bitmap_alloc_full</b> (void) <br>
void <b>hwloc_bitmap_free</b> (<b>hwloc_bitmap_t</b> bitmap)
<b><br>
hwloc_bitmap_t hwloc_bitmap_dup</b>
(<b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_copy</b> (<b>hwloc_bitmap_t</b> dst,
<b>hwloc_const_bitmap_t</b> src) <br>
int <b>hwloc_bitmap_snprintf</b> (char *restrict buf, size_t
buflen, <b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_asprintf</b> (char **strp,
<b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_sscanf</b> (<b>hwloc_bitmap_t</b>
bitmap, const char *restrict string) <br>
int <b>hwloc_bitmap_list_snprintf</b> (char *restrict buf,
size_t buflen, <b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_list_asprintf</b> (char **strp,
<b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_list_sscanf</b> (<b>hwloc_bitmap_t</b>
bitmap, const char *restrict string) <br>
int <b>hwloc_bitmap_taskset_snprintf</b> (char *restrict
buf, size_t buflen, <b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_taskset_asprintf</b> (char **strp,
<b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_taskset_sscanf</b>
(<b>hwloc_bitmap_t</b> bitmap, const char *restrict string)
<br>
void <b>hwloc_bitmap_zero</b> (<b>hwloc_bitmap_t</b> bitmap)
<br>
void <b>hwloc_bitmap_fill</b> (<b>hwloc_bitmap_t</b> bitmap)
<br>
int <b>hwloc_bitmap_only</b> (<b>hwloc_bitmap_t</b> bitmap,
unsigned id) <br>
int <b>hwloc_bitmap_allbut</b> (<b>hwloc_bitmap_t</b>
bitmap, unsigned id) <br>
int <b>hwloc_bitmap_from_ulong</b> (<b>hwloc_bitmap_t</b>
bitmap, unsigned long mask) <br>
int <b>hwloc_bitmap_from_ith_ulong</b>
(<b>hwloc_bitmap_t</b> bitmap, unsigned i, unsigned long
mask) <br>
int <b>hwloc_bitmap_from_ulongs</b> (<b>hwloc_bitmap_t</b>
bitmap, unsigned nr, const unsigned long *masks) <br>
int <b>hwloc_bitmap_set</b> (<b>hwloc_bitmap_t</b> bitmap,
unsigned id) <br>
int <b>hwloc_bitmap_set_range</b> (<b>hwloc_bitmap_t</b>
bitmap, unsigned begin, int end) <br>
int <b>hwloc_bitmap_set_ith_ulong</b> (<b>hwloc_bitmap_t</b>
bitmap, unsigned i, unsigned long mask) <br>
int <b>hwloc_bitmap_clr</b> (<b>hwloc_bitmap_t</b> bitmap,
unsigned id) <br>
int <b>hwloc_bitmap_clr_range</b> (<b>hwloc_bitmap_t</b>
bitmap, unsigned begin, int end) <br>
int <b>hwloc_bitmap_singlify</b> (<b>hwloc_bitmap_t</b>
bitmap) <br>
unsigned long <b>hwloc_bitmap_to_ulong</b>
(<b>hwloc_const_bitmap_t</b> bitmap) <br>
unsigned long <b>hwloc_bitmap_to_ith_ulong</b>
(<b>hwloc_const_bitmap_t</b> bitmap, unsigned i) <br>
int <b>hwloc_bitmap_to_ulongs</b>
(<b>hwloc_const_bitmap_t</b> bitmap, unsigned nr, unsigned
long *masks) <br>
int <b>hwloc_bitmap_nr_ulongs</b>
(<b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_isset</b> (<b>hwloc_const_bitmap_t</b>
bitmap, unsigned id) <br>
int <b>hwloc_bitmap_iszero</b> (<b>hwloc_const_bitmap_t</b>
bitmap) <br>
int <b>hwloc_bitmap_isfull</b> (<b>hwloc_const_bitmap_t</b>
bitmap) <br>
int <b>hwloc_bitmap_first</b> (<b>hwloc_const_bitmap_t</b>
bitmap) <br>
int <b>hwloc_bitmap_next</b> (<b>hwloc_const_bitmap_t</b>
bitmap, int prev) <br>
int <b>hwloc_bitmap_last</b> (<b>hwloc_const_bitmap_t</b>
bitmap) <br>
int <b>hwloc_bitmap_weight</b> (<b>hwloc_const_bitmap_t</b>
bitmap) <br>
int <b>hwloc_bitmap_first_unset</b>
(<b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_next_unset</b>
(<b>hwloc_const_bitmap_t</b> bitmap, int prev) <br>
int <b>hwloc_bitmap_last_unset</b>
(<b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_or</b> (<b>hwloc_bitmap_t</b> res,
<b>hwloc_const_bitmap_t</b> bitmap1,
<b>hwloc_const_bitmap_t</b> bitmap2) <br>
int <b>hwloc_bitmap_and</b> (<b>hwloc_bitmap_t</b> res,
<b>hwloc_const_bitmap_t</b> bitmap1,
<b>hwloc_const_bitmap_t</b> bitmap2) <br>
int <b>hwloc_bitmap_andnot</b> (<b>hwloc_bitmap_t</b> res,
<b>hwloc_const_bitmap_t</b> bitmap1,
<b>hwloc_const_bitmap_t</b> bitmap2) <br>
int <b>hwloc_bitmap_xor</b> (<b>hwloc_bitmap_t</b> res,
<b>hwloc_const_bitmap_t</b> bitmap1,
<b>hwloc_const_bitmap_t</b> bitmap2) <br>
int <b>hwloc_bitmap_not</b> (<b>hwloc_bitmap_t</b> res,
<b>hwloc_const_bitmap_t</b> bitmap) <br>
int <b>hwloc_bitmap_intersects</b>
(<b>hwloc_const_bitmap_t</b> bitmap1,
<b>hwloc_const_bitmap_t</b> bitmap2) <br>
int <b>hwloc_bitmap_isincluded</b>
(<b>hwloc_const_bitmap_t</b> sub_bitmap,
<b>hwloc_const_bitmap_t</b> super_bitmap) <br>
int <b>hwloc_bitmap_isequal</b> (<b>hwloc_const_bitmap_t</b>
bitmap1, <b>hwloc_const_bitmap_t</b> bitmap2) <br>
int <b>hwloc_bitmap_compare_first</b>
(<b>hwloc_const_bitmap_t</b> bitmap1,
<b>hwloc_const_bitmap_t</b> bitmap2) <br>
int <b>hwloc_bitmap_compare</b> (<b>hwloc_const_bitmap_t</b>
bitmap1, <b>hwloc_const_bitmap_t</b> bitmap2)</p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>hwloc_bitmap_t</b> type represents a set of integers
(positive or null). A bitmap may be of infinite size (all
bits are set after some point). A bitmap may even be full if
all bits are set.</p>

<p style="margin-left:11%; margin-top: 1em">Bitmaps are
used by hwloc for sets of OS processors (which may actually
be hardware threads) as by <b>hwloc_cpuset_t</b> (a typedef
for <b>hwloc_bitmap_t</b>), or sets of NUMA memory nodes as
<b>hwloc_nodeset_t</b> (also a typedef for
<b>hwloc_bitmap_t</b>). Those are used for cpuset and
nodeset fields in the <b>hwloc_obj</b> structure, see
<b>Object Sets (hwloc_cpuset_t and hwloc_nodeset_t)</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Both CPU and
node sets are always indexed by OS physical number.</i>
However users should usually not build CPU and node sets
manually (e.g. with <b>hwloc_bitmap_set()</b>). One should
rather use existing object sets and combine them with
<b>hwloc_bitmap_or()</b>, etc. For instance, binding the
current thread on a pair of cores may be performed with:</p>

<p style="margin-left:11%; margin-top: 1em">hwloc_obj_t
core1 = ... , core2 = ... ; <br>
hwloc_bitmap_t set = hwloc_bitmap_alloc(); <br>
hwloc_bitmap_or(set, core1-&gt;cpuset, core2-&gt;cpuset);
<br>
hwloc_set_cpubind(topology, set, HWLOC_CPUBIND_THREAD); <br>
hwloc_bitmap_free(set);</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">Most functions below return an
int that may be negative in case of error. The usual error
case would be an internal failure to realloc/extend the
storage of the bitmap (<tt>errno</tt> would be set to
<tt>ENOMEM</tt>).</p>

<p style="margin-left:17%; margin-top: 1em">Several
examples of using the bitmap API are available under the
doc/examples/ directory in the source tree. Regression tests
such as tests/hwloc/hwloc_bitmap*.c also make intensive use
of this API.</p>

<h2>Macro Definition Documentation
<a name="Macro Definition Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#define
hwloc_bitmap_foreach_begin(id, bitmap)</b> <br>
Loop macro iterating on bitmap <tt>bitmap</tt>. The loop
must start with <b>hwloc_bitmap_foreach_begin()</b> and end
with <b>hwloc_bitmap_foreach_end()</b> followed by a
terminating &rsquo;;&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em"><tt>id</tt> is
the loop variable; it should be an unsigned int. The first
iteration will set <tt>id</tt> to the lowest index in the
bitmap. Successive iterations will iterate through, in
order, all remaining indexes set in the bitmap. To be
specific: each iteration will return a value for <tt>id</tt>
such that hwloc_bitmap_isset(bitmap, id) is true.</p>

<p style="margin-left:11%; margin-top: 1em">The assert
prevents the loop from being infinite if the bitmap is
infinitely set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>#define
hwloc_bitmap_foreach_end()</b> <br>
End of loop macro iterating on a bitmap. Needs a terminating
&rsquo;;&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>See
also</b></p>


<p style="margin-left:17%;"><b>hwloc_bitmap_foreach_begin()</b></p>

<h2>Typedef Documentation
<a name="Typedef Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>typedef
struct hwloc_bitmap_s* hwloc_bitmap_t</b> <br>
Set of bits represented as an opaque pointer to an internal
bitmap.</p>

<p style="margin-left:11%; margin-top: 1em"><b>typedef
const struct hwloc_bitmap_s* hwloc_const_bitmap_t</b> <br>
a non-modifiable <b>hwloc_bitmap_t</b></p>

<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_allbut (hwloc_bitmap_t bitmap, unsigned id)</b>
<br>
Fill the bitmap <tt>and</tt> clear the index
<tt>id</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hwloc_bitmap_t
hwloc_bitmap_alloc (void)</b> <br>
Allocate a new empty bitmap.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A valid bitmap or
<tt>NULL</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">The bitmap
should be freed by a corresponding call to
<b>hwloc_bitmap_free()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hwloc_bitmap_t
hwloc_bitmap_alloc_full (void)</b> <br>
Allocate a new full bitmap.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_and (hwloc_bitmap_t res, hwloc_const_bitmap_t
bitmap1, hwloc_const_bitmap_t bitmap2)</b> <br>
And bitmaps <tt>bitmap1</tt> and <tt>bitmap2</tt> and store
the result in bitmap <tt>res</tt>. <tt>res</tt> can be the
same as <tt>bitmap1</tt> or <tt>bitmap2</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_andnot (hwloc_bitmap_t res,
hwloc_const_bitmap_t bitmap1, hwloc_const_bitmap_t
bitmap2)</b> <br>
And bitmap <tt>bitmap1</tt> and the negation of
<tt>bitmap2</tt> and store the result in bitmap
<tt>res</tt>. <tt>res</tt> can be the same as
<tt>bitmap1</tt> or <tt>bitmap2</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_asprintf (char ** strp, hwloc_const_bitmap_t
bitmap)</b> <br>
Stringify a bitmap into a newly allocated string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 on error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_clr (hwloc_bitmap_t bitmap, unsigned id)</b>
<br>
Remove index <tt>id</tt> from bitmap <tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_clr_range (hwloc_bitmap_t bitmap, unsigned
begin, int end)</b> <br>
Remove indexes from <tt>begin</tt> to <tt>end</tt> in bitmap
<tt>bitmap</tt>. If <tt>end</tt> is <tt>-1</tt>, the range
is infinite.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_compare (hwloc_const_bitmap_t bitmap1,
hwloc_const_bitmap_t bitmap2)</b> <br>
Compare bitmaps <tt>bitmap1</tt> and <tt>bitmap2</tt> in
lexicographic order. Lexicographic comparison of bitmaps,
starting for their highest indexes. Compare last indexes
first, then second, etc. The empty bitmap is considered
lower than anything.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if <tt>bitmap1</tt> is
considered smaller than <tt>bitmap2</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">1 if
<tt>bitmap1</tt> is considered larger than
<tt>bitmap2</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">0 if bitmaps
are equal (contrary to
<b>hwloc_bitmap_compare_first()</b>).</p>

<p style="margin-left:11%; margin-top: 1em">For instance
comparing binary bitmaps 0011 and 0110 returns -1 (hence
0011 is considered smaller than 0110). Comparing 00101 and
01010 returns -1 too.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">This is different from the
non-existing hwloc_bitmap_compare_last() which would only
compare the highest index of each bitmap.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_compare_first (hwloc_const_bitmap_t bitmap1,
hwloc_const_bitmap_t bitmap2)</b> <br>
Compare bitmaps <tt>bitmap1</tt> and <tt>bitmap2</tt> using
their lowest index. A bitmap is considered smaller if its
least significant bit is smaller. The empty bitmap is
considered higher than anything (because its least
significant bit does not exist).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if <tt>bitmap1</tt> is
considered smaller than <tt>bitmap2</tt>.</p>

<p style="margin-left:17%; margin-top: 1em">1 if
<tt>bitmap1</tt> is considered larger than
<tt>bitmap2</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">For instance
comparing binary bitmaps 0011 and 0110 returns -1 (hence
0011 is considered smaller than 0110) because least
significant bit of 0011 (0001) is smaller than least
significant bit of 0110 (0010). Comparing 01001 and 00110
would also return -1 for the same reason.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">0 if bitmaps are considered
equal, even if they are not strictly equal. They just need
to have the same least significant bit. For instance,
comparing binary bitmaps 0010 and 0110 returns 0 because
they have the same least significant bit.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_copy (hwloc_bitmap_t dst, hwloc_const_bitmap_t
src)</b> <br>
Copy the contents of bitmap <tt>src</tt> into the already
allocated bitmap <tt>dst</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>hwloc_bitmap_t
hwloc_bitmap_dup (hwloc_const_bitmap_t bitmap)</b> <br>
Duplicate bitmap <tt>bitmap</tt> by allocating a new bitmap
and copying <tt>bitmap</tt> contents. If <tt>bitmap</tt> is
<tt>NULL</tt>, <tt>NULL</tt> is returned.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
hwloc_bitmap_fill (hwloc_bitmap_t bitmap)</b> <br>
Fill bitmap <tt>bitmap</tt> with all possible indexes (even
if those objects don&rsquo;t exist or are otherwise
unavailable)</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_first (hwloc_const_bitmap_t bitmap)</b> <br>
Compute the first index (least significant bit) in bitmap
<tt>bitmap</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if no index is set in
<tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_first_unset (hwloc_const_bitmap_t bitmap)</b>
<br>
Compute the first unset index (least significant bit) in
bitmap <tt>bitmap</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if no index is unset in
<tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>void
hwloc_bitmap_free (hwloc_bitmap_t bitmap)</b> <br>
Free bitmap <tt>bitmap</tt>. If <tt>bitmap</tt> is
<tt>NULL</tt>, no operation is performed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_from_ith_ulong (hwloc_bitmap_t bitmap, unsigned
i, unsigned long mask)</b> <br>
Setup bitmap <tt>bitmap</tt> from unsigned long
<tt>mask</tt> used as <tt>i</tt> -th subset.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_from_ulong (hwloc_bitmap_t bitmap, unsigned
long mask)</b> <br>
Setup bitmap <tt>bitmap</tt> from unsigned long
<tt>mask</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_from_ulongs (hwloc_bitmap_t bitmap, unsigned
nr, const unsigned long * masks)</b> <br>
Setup bitmap <tt>bitmap</tt> from unsigned longs
<tt>masks</tt> used as first <tt>nr</tt> subsets.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_intersects (hwloc_const_bitmap_t bitmap1,
hwloc_const_bitmap_t bitmap2)</b> <br>
Test whether bitmaps <tt>bitmap1</tt> and <tt>bitmap2</tt>
intersects.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">1 if bitmaps intersect, 0
otherwise.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_isequal (hwloc_const_bitmap_t bitmap1,
hwloc_const_bitmap_t bitmap2)</b> <br>
Test whether bitmap <tt>bitmap1</tt> is equal to bitmap
<tt>bitmap2</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">1 if bitmaps are equal, 0
otherwise.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_isfull (hwloc_const_bitmap_t bitmap)</b> <br>
Test whether bitmap <tt>bitmap</tt> is completely full.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">1 if bitmap is full, 0
otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">A full bitmap is always
infinitely set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_isincluded (hwloc_const_bitmap_t sub_bitmap,
hwloc_const_bitmap_t super_bitmap)</b> <br>
Test whether bitmap <tt>sub_bitmap</tt> is part of bitmap
<tt>super_bitmap</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">1 if <tt>sub_bitmap</tt> is
included in <tt>super_bitmap</tt>, 0 otherwise.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">The empty bitmap is considered
included in any other bitmap.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_isset (hwloc_const_bitmap_t bitmap, unsigned
id)</b> <br>
Test whether index <tt>id</tt> is part of bitmap
<tt>bitmap</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">1 if the bit at index
<tt>id</tt> is set in bitmap <tt>bitmap</tt>, 0
otherwise.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_iszero (hwloc_const_bitmap_t bitmap)</b> <br>
Test whether bitmap <tt>bitmap</tt> is empty.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">1 if bitmap is empty, 0
otherwise.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_last (hwloc_const_bitmap_t bitmap)</b> <br>
Compute the last index (most significant bit) in bitmap
<tt>bitmap</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if no index is set in
<tt>bitmap</tt>, or if <tt>bitmap</tt> is infinitely
set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_last_unset (hwloc_const_bitmap_t bitmap)</b>
<br>
Compute the last unset index (most significant bit) in
bitmap <tt>bitmap</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if no index is unset in
<tt>bitmap</tt>, or if <tt>bitmap</tt> is infinitely
set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_list_asprintf (char ** strp,
hwloc_const_bitmap_t bitmap)</b> <br>
Stringify a bitmap into a newly allocated list string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 on error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_list_snprintf (char *restrict buf, size_t
buflen, hwloc_const_bitmap_t bitmap)</b> <br>
Stringify a bitmap in the list format. Lists are
comma-separated indexes or ranges. Ranges are dash separated
indexes. The last range may not have an ending indexes if
the bitmap is infinitely set.</p>

<p style="margin-left:11%; margin-top: 1em">Up to
<tt>buflen</tt> characters may be written in buffer
<tt>buf</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>buflen</tt> is 0, <tt>buf</tt> may safely be
<tt>NULL</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the number of characters that
were actually written if not truncating, or that would have
been written (not including the ending \0).</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_list_sscanf (hwloc_bitmap_t bitmap, const char
*restrict string)</b> <br>
Parse a list string and stores it in bitmap
<tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_next (hwloc_const_bitmap_t bitmap, int
prev)</b> <br>
Compute the next index in bitmap <tt>bitmap</tt> which is
after index <tt>prev</tt>. If <tt>prev</tt> is -1, the first
index is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if no index with higher
index is set in <tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_next_unset (hwloc_const_bitmap_t bitmap, int
prev)</b> <br>
Compute the next unset index in bitmap <tt>bitmap</tt> which
is after index <tt>prev</tt>. If <tt>prev</tt> is -1, the
first unset index is returned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if no index with higher
index is unset in <tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_not (hwloc_bitmap_t res, hwloc_const_bitmap_t
bitmap)</b> <br>
Negate bitmap <tt>bitmap</tt> and store the result in bitmap
<tt>res</tt>. <tt>res</tt> can be the same as
<tt>bitmap</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_nr_ulongs (hwloc_const_bitmap_t bitmap)</b>
<br>
Return the number of unsigned longs required for storing
bitmap <tt>bitmap</tt> entirely. This is the number of
contiguous unsigned longs from the very first bit of the
bitmap (even if unset) up to the last set bit. This is
useful for knowing the <tt>nr</tt> parameter to pass to
<b>hwloc_bitmap_to_ulongs()</b> (or which calls to
<b>hwloc_bitmap_to_ith_ulong()</b> are needed) to entirely
convert a bitmap into multiple unsigned longs.</p>

<p style="margin-left:11%; margin-top: 1em">When called on
the output of <b>hwloc_topology_get_topology_cpuset()</b>,
the returned number is large enough for all cpusets of the
topology.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 if <tt>bitmap</tt> is
infinite.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_only (hwloc_bitmap_t bitmap, unsigned id)</b>
<br>
Empty the bitmap <tt>bitmap</tt> and add bit
<tt>id</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_or (hwloc_bitmap_t res, hwloc_const_bitmap_t
bitmap1, hwloc_const_bitmap_t bitmap2)</b> <br>
Or bitmaps <tt>bitmap1</tt> and <tt>bitmap2</tt> and store
the result in bitmap <tt>res</tt>. <tt>res</tt> can be the
same as <tt>bitmap1</tt> or <tt>bitmap2</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_set (hwloc_bitmap_t bitmap, unsigned id)</b>
<br>
Add index <tt>id</tt> in bitmap <tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_set_ith_ulong (hwloc_bitmap_t bitmap, unsigned
i, unsigned long mask)</b> <br>
Replace <tt>i</tt> -th subset of bitmap <tt>bitmap</tt> with
unsigned long <tt>mask</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_set_range (hwloc_bitmap_t bitmap, unsigned
begin, int end)</b> <br>
Add indexes from <tt>begin</tt> to <tt>end</tt> in bitmap
<tt>bitmap</tt>. If <tt>end</tt> is <tt>-1</tt>, the range
is infinite.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_singlify (hwloc_bitmap_t bitmap)</b> <br>
Keep a single index among those set in bitmap
<tt>bitmap</tt>. May be useful before binding so that the
process does not have a chance of migrating between multiple
processors in the original mask. Instead of running the task
on any PU inside the given CPU set, the operating system
scheduler will be forced to run it on a single of these PUs.
It avoids a migration overhead and cache-line ping-pongs
between PUs.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Note</b></p>

<p style="margin-left:17%;">This function is NOT meant to
distribute multiple processes within a single CPU set. It
always return the same single bit when called multiple times
on the same input set. <b>hwloc_distrib()</b> may be used
for generating CPU sets to distribute multiple tasks below a
single multi-PU object.</p>

<p style="margin-left:17%; margin-top: 1em">This function
cannot be applied to an object set directly. It should be
applied to a copy (which may be obtained with
<b>hwloc_bitmap_dup()</b>).</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_snprintf (char *restrict buf, size_t buflen,
hwloc_const_bitmap_t bitmap)</b> <br>
Stringify a bitmap. Up to <tt>buflen</tt> characters may be
written in buffer <tt>buf</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>buflen</tt> is 0, <tt>buf</tt> may safely be
<tt>NULL</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the number of characters that
were actually written if not truncating, or that would have
been written (not including the ending \0).</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_sscanf (hwloc_bitmap_t bitmap, const char
*restrict string)</b> <br>
Parse a bitmap string and stores it in bitmap
<tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_taskset_asprintf (char ** strp,
hwloc_const_bitmap_t bitmap)</b> <br>
Stringify a bitmap into a newly allocated taskset-specific
string.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">-1 on error.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_taskset_snprintf (char *restrict buf, size_t
buflen, hwloc_const_bitmap_t bitmap)</b> <br>
Stringify a bitmap in the taskset-specific format. The
taskset command manipulates bitmap strings that contain a
single (possible very long) hexadecimal number starting with
0x.</p>

<p style="margin-left:11%; margin-top: 1em">Up to
<tt>buflen</tt> characters may be written in buffer
<tt>buf</tt>.</p>

<p style="margin-left:11%; margin-top: 1em">If
<tt>buflen</tt> is 0, <tt>buf</tt> may safely be
<tt>NULL</tt>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the number of characters that
were actually written if not truncating, or that would have
been written (not including the ending \0).</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_taskset_sscanf (hwloc_bitmap_t bitmap, const
char *restrict string)</b> <br>
Parse a taskset-specific bitmap string and stores it in
bitmap <tt>bitmap</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>unsigned
long hwloc_bitmap_to_ith_ulong (hwloc_const_bitmap_t bitmap,
unsigned i)</b> <br>
Convert the <tt>i</tt> -th subset of bitmap <tt>bitmap</tt>
into unsigned long mask.</p>

<p style="margin-left:11%; margin-top: 1em"><b>unsigned
long hwloc_bitmap_to_ulong (hwloc_const_bitmap_t bitmap)</b>
<br>
Convert the beginning part of bitmap <tt>bitmap</tt> into
unsigned long <tt>mask</tt>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_to_ulongs (hwloc_const_bitmap_t bitmap,
unsigned nr, unsigned long * masks)</b> <br>
Convert the first <tt>nr</tt> subsets of bitmap
<tt>bitmap</tt> into the array of <tt>nr</tt> unsigned long
<tt>masks</tt>. <tt>nr</tt> may be determined earlier with
<b>hwloc_bitmap_nr_ulongs()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">0</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_weight (hwloc_const_bitmap_t bitmap)</b> <br>
Compute the &rsquo;weight&rsquo; of bitmap <tt>bitmap</tt>
(i.e., number of indexes that are in the bitmap).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">the number of indexes that are
in the bitmap.</p>

<p style="margin-left:17%; margin-top: 1em">-1 if
<tt>bitmap</tt> is infinitely set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>int
hwloc_bitmap_xor (hwloc_bitmap_t res, hwloc_const_bitmap_t
bitmap1, hwloc_const_bitmap_t bitmap2)</b> <br>
Xor bitmaps <tt>bitmap1</tt> and <tt>bitmap2</tt> and store
the result in bitmap <tt>res</tt>. <tt>res</tt> can be the
same as <tt>bitmap1</tt> or <tt>bitmap2</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>void
hwloc_bitmap_zero (hwloc_bitmap_t bitmap)</b> <br>
Empty the bitmap <tt>bitmap</tt>.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for Hardware Locality (hwloc) from
the source code.</p>
<hr>
</body>
</html>
