<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:54:26 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Compress::Zlib</title>

</head>
<body>
<h1>Compress::Zlib</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Compress::Zlib
&minus; Interface to zlib compression library</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">use
Compress::Zlib ; <br>
($d, $status) = deflateInit( [OPT] ) ; <br>
$status = $d&minus;&gt;deflate($input, $output) ; <br>
$status = $d&minus;&gt;flush([$flush_type]) ; <br>
$d&minus;&gt;deflateParams(OPTS) ; <br>
$d&minus;&gt;deflateTune(OPTS) ; <br>
$d&minus;&gt;dict_adler() ; <br>
$d&minus;&gt;crc32() ; <br>
$d&minus;&gt;adler32() ; <br>
$d&minus;&gt;total_in() ; <br>
$d&minus;&gt;total_out() ; <br>
$d&minus;&gt;msg() ; <br>
$d&minus;&gt;get_Strategy(); <br>
$d&minus;&gt;get_Level(); <br>
$d&minus;&gt;get_BufSize(); <br>
($i, $status) = inflateInit( [OPT] ) ; <br>
$status = $i&minus;&gt;inflate($input, $output [, $eof]) ;
<br>
$status = $i&minus;&gt;inflateSync($input) ; <br>
$i&minus;&gt;dict_adler() ; <br>
$d&minus;&gt;crc32() ; <br>
$d&minus;&gt;adler32() ; <br>
$i&minus;&gt;total_in() ; <br>
$i&minus;&gt;total_out() ; <br>
$i&minus;&gt;msg() ; <br>
$d&minus;&gt;get_BufSize(); <br>
$dest = compress($source) ; <br>
$dest = uncompress($source) ; <br>
$gz = gzopen($filename or filehandle, $mode) ; <br>
$bytesread = $gz&minus;&gt;gzread($buffer [,$size]) ; <br>
$bytesread = $gz&minus;&gt;gzreadline($line) ; <br>
$byteswritten = $gz&minus;&gt;gzwrite($buffer) ; <br>
$status = $gz&minus;&gt;gzflush($flush) ; <br>
$offset = $gz&minus;&gt;gztell() ; <br>
$status = $gz&minus;&gt;gzseek($offset, $whence) ; <br>
$status = $gz&minus;&gt;gzclose() ; <br>
$status = $gz&minus;&gt;gzeof() ; <br>
$status = $gz&minus;&gt;gzsetparams($level, $strategy) ;
<br>
$errstring = $gz&minus;&gt;gzerror() ; <br>
$gzerrno <br>
$dest = Compress::Zlib::memGzip($buffer) ; <br>
$dest = Compress::Zlib::memGunzip($buffer) ; <br>
$crc = adler32($buffer [,$crc]) ; <br>
$crc = crc32($buffer [,$crc]) ; <br>
$crc = crc32_combine($crc1, $crc2, $len2); <br>
$adler = adler32_combine($adler1, $adler2, $len2); <br>
my $version = Compress::Raw::Zlib::zlib_version();</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<i>Compress::Zlib</i> module provides a Perl interface to
the <i>zlib</i> compression library (see &quot;
<small>AUTHOR&quot;</small> for details about where to get
<i>zlib</i>).</p>

<p style="margin-left:11%; margin-top: 1em">The
&quot;Compress::Zlib&quot; module can be split into two
general areas of functionality, namely a simple read/write
interface to <i>gzip</i> files and a low-level in-memory
compression/decompression interface.</p>

<p style="margin-left:11%; margin-top: 1em">Each of these
areas will be discussed in the following sections.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Notes for
users of Compress::Zlib version 1</b> <br>
The main change in &quot;Compress::Zlib&quot; version 2.x is
that it does not now interface directly to the zlib library.
Instead it uses the &quot;IO::Compress::Gzip&quot; and
&quot;IO::Uncompress::Gunzip&quot; modules for
reading/writing gzip files, and the
&quot;Compress::Raw::Zlib&quot; module for some low-level
zlib access.</p>

<p style="margin-left:11%; margin-top: 1em">The interface
provided by version 2 of this module should be 100% backward
compatible with version 1. If you find a difference in the
expected behaviour please contact the author (See &quot;
<small>AUTHOR&quot;</small> ). See &quot; <small>GZIP
INTERFACE&quot;</small></p>

<p style="margin-left:11%; margin-top: 1em">With the
creation of the &quot;IO::Compress&quot; and
&quot;IO::Uncompress&quot; modules no new features are
planned for &quot;Compress::Zlib&quot; &minus; the new
modules do everything that &quot;Compress::Zlib&quot; does
and then some. Development on &quot;Compress::Zlib&quot;
will be limited to bug fixes only.</p>

<p style="margin-left:11%; margin-top: 1em">If you are
writing new code, your first port of call should be one of
the new &quot;IO::Compress&quot; or
&quot;IO::Uncompress&quot; modules.</p>

<h2>GZIP INTERFACE
<a name="GZIP INTERFACE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A number of
functions are supplied in <i>zlib</i> for reading and
writing <i>gzip</i> files that conform to <small>RFC
1952.</small> This module provides an interface to most of
them.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
previously used &quot;Compress::Zlib&quot; 1.x, the
following enhancements/changes have been made to the
&quot;gzopen&quot; interface:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="4%"></td>
<td width="82%">


<p>If you want to open either <small>STDIN</small> or
<small>STDOUT</small> with &quot;gzopen&quot;, you can now
optionally use the special filename
&quot;&quot;&minus;&quot;&quot; as a synonym for
&quot;\*STDIN&quot; and &quot;\*STDOUT&quot;.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="4%"></td>
<td width="82%">


<p>In &quot;Compress::Zlib&quot; version 1.x,
&quot;gzopen&quot; used the zlib library to open the
underlying file. This made things especially tricky when a
Perl filehandle was passed to &quot;gzopen&quot;. Behind the
scenes the numeric C file descriptor had to be extracted
from the Perl filehandle and this passed to the zlib
library.</p> </td></tr>
</table>

<p style="margin-left:18%; margin-top: 1em">Apart from
being non-portable to some operating systems, this made it
difficult to use &quot;gzopen&quot; in situations where you
wanted to extract/create a gzip data stream that is embedded
in a larger file, without having to resort to opening and
closing the file multiple times.</p>

<p style="margin-left:18%; margin-top: 1em">It also made it
impossible to pass a perl filehandle that wasn&rsquo;t
associated with a real filesystem file, like, say, an
&quot;IO::String&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">In
&quot;Compress::Zlib&quot; version 2.x, the
&quot;gzopen&quot; interface has been completely rewritten
to use the IO::Compress::Gzip for writing gzip files and
IO::Uncompress::Gunzip for reading gzip files. None of the
limitations mentioned above apply.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">3.</p></td>
<td width="4%"></td>
<td width="82%">


<p style="margin-top: 1em">Addition of &quot;gzseek&quot;
to provide a restricted &quot;seek&quot; interface.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="4%"></td>
<td width="82%">


<p>Added &quot;gztell&quot;.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A more complete
and flexible interface for reading/writing gzip
files/buffers is included with the module
&quot;IO&minus;Compress&minus;Zlib&quot;. See
IO::Compress::Gzip and IO::Uncompress::Gunzip for more
details. <b><br>
$gz = gzopen($filename, $mode) <br>
$gz = gzopen($filehandle, $mode)</b></p>

<p style="margin-left:18%;">This function opens either the
<i>gzip</i> file $filename for reading or writing or
attaches to the opened filehandle, $filehandle. It returns
an object on success and &quot;undef&quot; on failure.</p>

<p style="margin-left:18%; margin-top: 1em">When writing a
gzip file this interface will <i>always</i> create the
smallest possible gzip header (exactly 10 bytes). If you
want greater control over what gets stored in the gzip
header (like the original filename or a comment) use
IO::Compress::Gzip instead. Similarly if you want to read
the contents of the gzip header use
IO::Uncompress::Gunzip.</p>

<p style="margin-left:18%; margin-top: 1em">The second
parameter, $mode, is used to specify whether the file is
opened for reading or writing and to optionally specify a
compression level and compression strategy when writing. The
format of the $mode parameter is similar to the mode
parameter to the &rsquo;C&rsquo; function &quot;fopen&quot;,
so &quot;rb&quot; is used to open for reading,
&quot;wb&quot; for writing and &quot;ab&quot; for appending
(writing at the end of the file).</p>

<p style="margin-left:18%; margin-top: 1em">To specify a
compression level when writing, append a digit between 0 and
9 to the mode string -- 0 means no compression and 9 means
maximum compression. If no compression level is specified
Z_DEFAULT_COMPRESSION is used.</p>

<p style="margin-left:18%; margin-top: 1em">To specify the
compression strategy when writing, append &rsquo;f&rsquo;
for filtered data, &rsquo;h&rsquo; for Huffman only
compression, or &rsquo;R&rsquo; for run-length encoding. If
no strategy is specified Z_DEFAULT_STRATEGY is used.</p>

<p style="margin-left:18%; margin-top: 1em">So, for
example, &quot;wb9&quot; means open for writing with the
maximum compression using the default strategy and
&quot;wb4R&quot; means open for writing with compression
level 4 and run-length encoding.</p>

<p style="margin-left:18%; margin-top: 1em">Refer to the
<i>zlib</i> documentation for the exact format of the $mode
parameter.</p>

<p style="margin-left:11%;"><b>$bytesread =
$gz&minus;&gt;gzread($buffer [, $size]) ;</b></p>

<p style="margin-left:18%;">Reads $size bytes from the
compressed file into $buffer. If $size is not specified, it
will default to 4096. If the scalar $buffer is not large
enough, it will be extended automatically.</p>

<p style="margin-left:18%; margin-top: 1em">Returns the
number of bytes actually read. On <small>EOF</small> it
returns 0 and in the case of an error, &minus;1.</p>

<p style="margin-left:11%;"><b>$bytesread =
$gz&minus;&gt;gzreadline($line) ;</b></p>

<p style="margin-left:18%;">Reads the next line from the
compressed file into $line.</p>

<p style="margin-left:18%; margin-top: 1em">Returns the
number of bytes actually read. On <small>EOF</small> it
returns 0 and in the case of an error, &minus;1.</p>

<p style="margin-left:18%; margin-top: 1em">It is legal to
intermix calls to &quot;gzread&quot; and
&quot;gzreadline&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">To maintain
backward compatibility with version 1.x of this module
&quot;gzreadline&quot; ignores the $/ variable &minus; it
<i>always</i> uses the string &quot;\n&quot; as the line
delimiter.</p>

<p style="margin-left:18%; margin-top: 1em">If you want to
read a gzip file a line at a time and have it respect the $/
variable (or $INPUT_RECORD_SEPARATOR, or $RS when
&quot;English&quot; is in use) see
IO::Uncompress::Gunzip.</p>

<p style="margin-left:11%;"><b>$byteswritten =
$gz&minus;&gt;gzwrite($buffer) ;</b></p>

<p style="margin-left:18%;">Writes the contents of $buffer
to the compressed file. Returns the number of bytes actually
written, or 0 on error.</p>

<p style="margin-left:11%;"><b>$status =
$gz&minus;&gt;gzflush($flush_type) ;</b></p>

<p style="margin-left:18%;">Flushes all pending output into
the compressed file.</p>

<p style="margin-left:18%; margin-top: 1em">This method
takes an optional parameter, $flush_type, that controls how
the flushing will be carried out. By default the $flush_type
used is &quot;Z_FINISH&quot;. Other valid values for
$flush_type are &quot;Z_NO_FLUSH&quot;,
&quot;Z_SYNC_FLUSH&quot;, &quot;Z_FULL_FLUSH&quot; and
&quot;Z_BLOCK&quot;. It is strongly recommended that you
only set the &quot;flush_type&quot; parameter if you fully
understand the implications of what it does &minus; overuse
of &quot;flush&quot; can seriously degrade the level of
compression achieved. See the &quot;zlib&quot; documentation
for details.</p>

<p style="margin-left:18%; margin-top: 1em">Returns 0 on
success.</p>

<p style="margin-left:11%;"><b>$offset =
$gz&minus;&gt;gztell() ;</b></p>

<p style="margin-left:18%;">Returns the uncompressed file
offset.</p>

<p style="margin-left:11%;"><b>$status =
$gz&minus;&gt;gzseek($offset, $whence) ;</b></p>

<p style="margin-left:18%;">Provides a sub-set of the
&quot;seek&quot; functionality, with the restriction that it
is only legal to seek forward in the compressed file. It is
a fatal error to attempt to seek backward.</p>

<p style="margin-left:18%; margin-top: 1em">When opened for
writing, empty parts of the file will have
<small>NULL</small> (0x00) bytes written to them.</p>

<p style="margin-left:18%; margin-top: 1em">The $whence
parameter should be one of <small>SEEK_SET, SEEK_CUR</small>
or <small>SEEK_END.</small></p>

<p style="margin-left:18%; margin-top: 1em">Returns 1 on
success, 0 on failure.</p>


<p style="margin-left:11%;"><b>$gz&minus;&gt;gzclose</b></p>

<p style="margin-left:18%;">Closes the compressed file. Any
pending data is flushed to the file before it is closed.</p>

<p style="margin-left:18%; margin-top: 1em">Returns 0 on
success.</p>


<p style="margin-left:11%;"><b>$gz&minus;&gt;gzsetparams($level,
$strategy</b></p>

<p style="margin-left:18%;">Change settings for the deflate
stream $gz.</p>

<p style="margin-left:18%; margin-top: 1em">The list of the
valid options is shown below. Options not specified will
remain unchanged.</p>

<p style="margin-left:18%; margin-top: 1em">Note: This
method is only available if you are running zlib 1.0.6 or
better. <b><br>
$level</b></p>

<p style="margin-left:26%;">Defines the compression level.
Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;,
&quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;,
and &quot;Z_DEFAULT_COMPRESSION&quot;.</p>

<p style="margin-left:18%;"><b>$strategy</b></p>

<p style="margin-left:26%;">Defines the strategy used to
tune the compression. The valid values are
&quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot; and
&quot;Z_HUFFMAN_ONLY&quot;.</p>


<p style="margin-left:11%;"><b>$gz&minus;&gt;gzerror</b></p>

<p style="margin-left:18%;">Returns the <i>zlib</i> error
message or number for the last operation associated with
$gz. The return value will be the <i>zlib</i> error number
when used in a numeric context and the <i>zlib</i> error
message when used in a string context. The <i>zlib</i> error
number constants, shown below, are available for use.</p>

<p style="margin-left:18%; margin-top: 1em">Z_OK <br>
Z_STREAM_END <br>
Z_ERRNO <br>
Z_STREAM_ERROR <br>
Z_DATA_ERROR <br>
Z_MEM_ERROR <br>
Z_BUF_ERROR</p>

<p style="margin-left:11%;"><b>$gzerrno</b></p>

<p style="margin-left:18%;">The $gzerrno scalar holds the
error code associated with the most recent <i>gzip</i>
routine. Note that unlike &quot;gzerror()&quot;, the error
is <i>not</i> associated with a particular file.</p>

<p style="margin-left:18%; margin-top: 1em">As with
&quot;gzerror()&quot; it returns an error number in numeric
context and an error message in string context. Unlike
&quot;gzerror()&quot; though, the error message will
correspond to the <i>zlib</i> message when the error is
associated with <i>zlib</i> itself, or the
<small>UNIX</small> error message when it is not (i.e.
<i>zlib</i> returned &quot;Z_ERRORNO&quot;).</p>

<p style="margin-left:18%; margin-top: 1em">As there is an
overlap between the error numbers used by <i>zlib</i> and
<small>UNIX,</small> $gzerrno should only be used to check
for the presence of <i>an</i> error in numeric context. Use
&quot;gzerror()&quot; to check for specific <i>zlib</i>
errors. The <i>gzcat</i> example below shows how the
variable can be used safely.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Examples</b>
<br>
Here is an example script which uses the interface. It
implements a <i>gzcat</i> function.</p>

<p style="margin-left:11%; margin-top: 1em">use strict ;
<br>
use warnings ; <br>
use Compress::Zlib ; <br>
# use stdin if no files supplied <br>
@ARGV = '&minus;' unless @ARGV ; <br>
foreach my $file (@ARGV) { <br>
my $buffer ; <br>
my $gz = gzopen($file, &quot;rb&quot;) <br>
or die &quot;Cannot open $file: $gzerrno\n&quot; ; <br>
print $buffer while $gz&minus;&gt;gzread($buffer) &gt; 0 ;
<br>
die &quot;Error reading from $file: $gzerrno&quot; .
($gzerrno+0) . &quot;\n&quot; <br>
if $gzerrno != Z_STREAM_END ; <br>
$gz&minus;&gt;gzclose() ; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Below is a
script which makes use of &quot;gzreadline&quot;. It
implements a very simple <i>grep</i> like script.</p>

<p style="margin-left:11%; margin-top: 1em">use strict ;
<br>
use warnings ; <br>
use Compress::Zlib ; <br>
die &quot;Usage: gzgrep pattern [file...]\n&quot; <br>
unless @ARGV &gt;= 1; <br>
my $pattern = shift ; <br>
# use stdin if no files supplied <br>
@ARGV = '&minus;' unless @ARGV ; <br>
foreach my $file (@ARGV) { <br>
my $gz = gzopen($file, &quot;rb&quot;) <br>
or die &quot;Cannot open $file: $gzerrno\n&quot; ; <br>
while ($gz&minus;&gt;gzreadline($_) &gt; 0) { <br>
print if /$pattern/ ; <br>
} <br>
die &quot;Error reading from $file: $gzerrno\n&quot; <br>
if $gzerrno != Z_STREAM_END ; <br>
$gz&minus;&gt;gzclose() ; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">This script,
<i>gzstream</i>, does the opposite of the <i>gzcat</i>
script above. It reads from standard input and writes a gzip
data stream to standard output.</p>

<p style="margin-left:11%; margin-top: 1em">use strict ;
<br>
use warnings ; <br>
use Compress::Zlib ; <br>
binmode STDOUT; # gzopen only sets it on the fd <br>
my $gz = gzopen(\*STDOUT, &quot;wb&quot;) <br>
or die &quot;Cannot open stdout: $gzerrno\n&quot; ; <br>
while (&lt;&gt;) { <br>
$gz&minus;&gt;gzwrite($_) <br>
or die &quot;error writing: $gzerrno\n&quot; ; <br>
} <br>
$gz&minus;&gt;gzclose ;</p>


<p style="margin-left:11%; margin-top: 1em"><b>Compress::Zlib::memGzip</b>
<br>
This function is used to create an in-memory gzip file with
the minimum possible gzip header (exactly 10 bytes).</p>

<p style="margin-left:11%; margin-top: 1em">$dest =
Compress::Zlib::memGzip($buffer) <br>
or die &quot;Cannot compress: $gzerrno\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If successful,
it returns the in-memory gzip file. Otherwise it returns
&quot;undef&quot; and the $gzerrno variable will store the
zlib error code.</p>

<p style="margin-left:11%; margin-top: 1em">The $buffer
parameter can either be a scalar or a scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">See
IO::Compress::Gzip for an alternative way to carry out
in-memory gzip compression.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Compress::Zlib::memGunzip</b>
<br>
This function is used to uncompress an in-memory gzip
file.</p>

<p style="margin-left:11%; margin-top: 1em">$dest =
Compress::Zlib::memGunzip($buffer) <br>
or die &quot;Cannot uncompress: $gzerrno\n&quot;;</p>

<p style="margin-left:11%; margin-top: 1em">If successful,
it returns the uncompressed gzip file. Otherwise it returns
&quot;undef&quot; and the $gzerrno variable will store the
zlib error code.</p>

<p style="margin-left:11%; margin-top: 1em">The $buffer
parameter can either be a scalar or a scalar reference. The
contents of the $buffer parameter are destroyed after
calling this function.</p>

<p style="margin-left:11%; margin-top: 1em">If $buffer
consists of multiple concatenated gzip data streams only the
first will be uncompressed. Use &quot;gunzip&quot; with the
&quot;MultiStream&quot; option in the
&quot;IO::Uncompress::Gunzip&quot; module if you need to
deal with concatenated data streams.</p>

<p style="margin-left:11%; margin-top: 1em">See
IO::Uncompress::Gunzip for an alternative way to carry out
in-memory gzip uncompression.</p>

<h2>COMPRESS/UNCOMPRESS
<a name="COMPRESS/UNCOMPRESS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Two functions
are provided to perform in-memory compression/uncompression
of <small>RFC 1950</small> data streams. They are called
&quot;compress&quot; and &quot;uncompress&quot;. <b><br>
$dest = compress($source [, $level] ) ;</b></p>

<p style="margin-left:18%;">Compresses $source. If
successful it returns the compressed data. Otherwise it
returns <i>undef</i>.</p>

<p style="margin-left:18%; margin-top: 1em">The source
buffer, $source, can either be a scalar or a scalar
reference.</p>

<p style="margin-left:18%; margin-top: 1em">The $level
parameter defines the compression level. Valid values are 0
through 9, &quot;Z_NO_COMPRESSION&quot;,
&quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;,
and &quot;Z_DEFAULT_COMPRESSION&quot;. If $level is not
specified &quot;Z_DEFAULT_COMPRESSION&quot; will be
used.</p>

<p style="margin-left:11%;"><b>$dest = uncompress($source)
;</b></p>

<p style="margin-left:18%;">Uncompresses $source. If
successful it returns the uncompressed data. Otherwise it
returns <i>undef</i>.</p>

<p style="margin-left:18%; margin-top: 1em">The source
buffer can either be a scalar or a scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">Please note:
the two functions defined above are <i>not</i> compatible
with the Unix commands of the same name.</p>

<p style="margin-left:11%; margin-top: 1em">See IO::Deflate
and IO::Inflate included with this distribution for an
alternative interface for reading/writing <small>RFC
1950</small> files/buffers.</p>

<h2>Deflate Interface
<a name="Deflate Interface"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
defines an interface that allows in-memory compression using
the <i>deflate</i> interface provided by zlib.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
definition of the interface available:</p>

<p style="margin-left:11%; margin-top: 1em"><b>($d,
$status) = deflateInit( [ <small>OPT</small> ] )</b> <br>
Initialises a deflation stream.</p>

<p style="margin-left:11%; margin-top: 1em">It combines the
features of the <i>zlib</i> functions
&quot;deflateInit&quot;, &quot;deflateInit2&quot; and
&quot;deflateSetDictionary&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If successful,
it will return the initialised deflation stream, $d and
$status of &quot;Z_OK&quot; in a list context. In scalar
context it returns the deflation stream, $d, only.</p>

<p style="margin-left:11%; margin-top: 1em">If not
successful, the returned deflation stream ($d) will be
<i>undef</i> and $status will hold the exact <i>zlib</i>
error code.</p>

<p style="margin-left:11%; margin-top: 1em">The function
optionally takes a number of named options specified as
&quot;&minus;Name=&gt;value&quot; pairs. This allows
individual options to be tailored without having to specify
them all in the parameter list.</p>

<p style="margin-left:11%; margin-top: 1em">For backward
compatibility, it is also possible to pass the parameters as
a reference to a hash containing the name=&gt;value
pairs.</p>

<p style="margin-left:11%; margin-top: 1em">The function
takes one optional parameter, a reference to a hash. The
contents of the hash allow the deflation interface to be
tailored.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a list
of the valid options: <b><br>
&minus;Level</b></p>

<p style="margin-left:18%;">Defines the compression level.
Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;,
&quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;,
and &quot;Z_DEFAULT_COMPRESSION&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
Z_DEFAULT_COMPRESSION.</p>

<p style="margin-left:11%;"><b>&minus;Method</b></p>

<p style="margin-left:18%;">Defines the compression method.
The only valid value at present (and the default) is
Z_DEFLATED.</p>

<p style="margin-left:11%;"><b>&minus;WindowBits</b></p>

<p style="margin-left:18%;">To create an <small>RFC
1950</small> data stream, set &quot;WindowBits&quot; to a
positive number.</p>

<p style="margin-left:18%; margin-top: 1em">To create an
<small>RFC 1951</small> data stream, set
&quot;WindowBits&quot; to &quot;&minus;MAX_WBITS&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">For a full
definition of the meaning and valid values for
&quot;WindowBits&quot; refer to the <i>zlib</i>
documentation for <i>deflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<small>MAX_WBITS.</small></p>

<p style="margin-left:11%;"><b>&minus;MemLevel</b></p>

<p style="margin-left:18%;">For a definition of the meaning
and valid values for &quot;MemLevel&quot; refer to the
<i>zlib</i> documentation for <i>deflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<small>MAX_MEM_LEVEL.</small></p>

<p style="margin-left:11%;"><b>&minus;Strategy</b></p>

<p style="margin-left:18%;">Defines the strategy used to
tune the compression. The valid values are
&quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot; and
&quot;Z_HUFFMAN_ONLY&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
Z_DEFAULT_STRATEGY.</p>

<p style="margin-left:11%;"><b>&minus;Dictionary</b></p>

<p style="margin-left:18%;">When a dictionary is specified
<i>Compress::Zlib</i> will automatically call
&quot;deflateSetDictionary&quot; directly after calling
&quot;deflateInit&quot;. The Adler32 value for the
dictionary can be obtained by calling the method
&quot;$d&minus;&gt;dict_adler()&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
no dictionary.</p>

<p style="margin-left:11%;"><b>&minus;Bufsize</b></p>

<p style="margin-left:18%;">Sets the initial size for the
deflation buffer. If the buffer has to be reallocated to
increase the size, it will grow in increments of
&quot;Bufsize&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">The default is
4096.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of using the &quot;deflateInit&quot; optional
parameter list to override the default buffer size and
compression level. All other options will take their default
values.</p>

<p style="margin-left:11%; margin-top: 1em">deflateInit(
&minus;Bufsize =&gt; 300, <br>
&minus;Level =&gt; Z_BEST_SPEED ) ;</p>

<p style="margin-left:11%; margin-top: 1em"><b>($out,
$status) = $d&minus;&gt;deflate($buffer)</b> <br>
Deflates the contents of $buffer. The buffer can either be a
scalar or a scalar reference. When finished, $buffer will be
completely processed (assuming there were no errors). If the
deflation was successful it returns the deflated output,
$out, and a status value, $status, of &quot;Z_OK&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">On error, $out
will be <i>undef</i> and $status will contain the
<i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">In a scalar
context &quot;deflate&quot; will return $out only.</p>

<p style="margin-left:11%; margin-top: 1em">As with the
<i>deflate</i> function in <i>zlib</i>, it is not
necessarily the case that any output will be produced by
this method. So don&rsquo;t rely on the fact that $out is
empty for an error test.</p>

<p style="margin-left:11%; margin-top: 1em"><b>($out,
$status) = $d&minus;&gt;flush() =head2 ($out, $status) =
$d&minus;&gt;flush($flush_type)</b> <br>
Typically used to finish the deflation. Any pending output
will be returned via $out. $status will have a value
&quot;Z_OK&quot; if successful.</p>

<p style="margin-left:11%; margin-top: 1em">In a scalar
context &quot;flush&quot; will return $out only.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using
&quot;Z_FINISH&quot;) or when you want to create a <i>full
flush point</i> (using &quot;Z_FULL_FLUSH&quot;).</p>

<p style="margin-left:11%; margin-top: 1em">By default the
&quot;flush_type&quot; used is &quot;Z_FINISH&quot;. Other
valid values for &quot;flush_type&quot; are
&quot;Z_NO_FLUSH&quot;, &quot;Z_PARTIAL_FLUSH&quot;,
&quot;Z_SYNC_FLUSH&quot; and &quot;Z_FULL_FLUSH&quot;. It is
strongly recommended that you only set the
&quot;flush_type&quot; parameter if you fully understand the
implications of what it does. See the &quot;zlib&quot;
documentation for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$d&minus;&gt;deflateParams([ <small>OPT</small> ])</b> <br>
Change settings for the deflate stream $d.</p>

<p style="margin-left:11%; margin-top: 1em">The list of the
valid options is shown below. Options not specified will
remain unchanged. <b><br>
&minus;Level</b></p>

<p style="margin-left:18%;">Defines the compression level.
Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;,
&quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;,
and &quot;Z_DEFAULT_COMPRESSION&quot;.</p>

<p style="margin-left:11%;"><b>&minus;Strategy</b></p>

<p style="margin-left:18%;">Defines the strategy used to
tune the compression. The valid values are
&quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot; and
&quot;Z_HUFFMAN_ONLY&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;dict_adler()</b>
<br>
Returns the adler32 value for the dictionary.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;msg()</b>
<br>
Returns the last error message generated by zlib.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;total_in()</b>
<br>
Returns the total number of bytes uncompressed bytes input
to deflate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$d&minus;&gt;total_out()</b>
<br>
Returns the total number of compressed bytes output from
deflate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
Here is a trivial example of using &quot;deflate&quot;. It
simply reads standard input, deflates it and writes it to
standard output.</p>

<p style="margin-left:11%; margin-top: 1em">use strict ;
<br>
use warnings ; <br>
use Compress::Zlib ; <br>
binmode STDIN; <br>
binmode STDOUT; <br>
my $x = deflateInit() <br>
or die &quot;Cannot create a deflation stream\n&quot; ; <br>
my ($output, $status) ; <br>
while (&lt;&gt;) <br>
{ <br>
($output, $status) = $x&minus;&gt;deflate($_) ; <br>
$status == Z_OK <br>
or die &quot;deflation failed\n&quot; ; <br>
print $output ; <br>
} <br>
($output, $status) = $x&minus;&gt;flush() ; <br>
$status == Z_OK <br>
or die &quot;deflation failed\n&quot; ; <br>
print $output ;</p>

<h2>Inflate Interface
<a name="Inflate Interface"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This section
defines the interface available that allows in-memory
uncompression using the <i>deflate</i> interface provided by
zlib.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a
definition of the interface:</p>

<p style="margin-left:11%; margin-top: 1em"><b>($i,
$status) = inflateInit()</b> <br>
Initialises an inflation stream.</p>

<p style="margin-left:11%; margin-top: 1em">In a list
context it returns the inflation stream, $i, and the
<i>zlib</i> status code in $status. In a scalar context it
returns the inflation stream only.</p>

<p style="margin-left:11%; margin-top: 1em">If successful,
$i will hold the inflation stream and $status will be
&quot;Z_OK&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">If not
successful, $i will be <i>undef</i> and $status will hold
the <i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">The function
optionally takes a number of named options specified as
&quot;&minus;Name=&gt;value&quot; pairs. This allows
individual options to be tailored without having to specify
them all in the parameter list.</p>

<p style="margin-left:11%; margin-top: 1em">For backward
compatibility, it is also possible to pass the parameters as
a reference to a hash containing the name=&gt;value
pairs.</p>

<p style="margin-left:11%; margin-top: 1em">The function
takes one optional parameter, a reference to a hash. The
contents of the hash allow the deflation interface to be
tailored.</p>

<p style="margin-left:11%; margin-top: 1em">Here is a list
of the valid options: <b><br>
&minus;WindowBits</b></p>

<p style="margin-left:18%;">To uncompress an <small>RFC
1950</small> data stream, set &quot;WindowBits&quot; to a
positive number.</p>

<p style="margin-left:18%; margin-top: 1em">To uncompress
an <small>RFC 1951</small> data stream, set
&quot;WindowBits&quot; to &quot;&minus;MAX_WBITS&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">For a full
definition of the meaning and valid values for
&quot;WindowBits&quot; refer to the <i>zlib</i>
documentation for <i>inflateInit2</i>.</p>

<p style="margin-left:18%; margin-top: 1em">Defaults to
<small>MAX_WBITS.</small></p>

<p style="margin-left:11%;"><b>&minus;Bufsize</b></p>

<p style="margin-left:18%;">Sets the initial size for the
inflation buffer. If the buffer has to be reallocated to
increase the size, it will grow in increments of
&quot;Bufsize&quot;.</p>

<p style="margin-left:18%; margin-top: 1em">Default is
4096.</p>

<p style="margin-left:11%;"><b>&minus;Dictionary</b></p>

<p style="margin-left:18%;">The default is no
dictionary.</p>

<p style="margin-left:11%; margin-top: 1em">Here is an
example of using the &quot;inflateInit&quot; optional
parameter to override the default buffer size.</p>

<p style="margin-left:11%; margin-top: 1em">inflateInit(
&minus;Bufsize =&gt; 300 ) ;</p>

<p style="margin-left:11%; margin-top: 1em"><b>($out,
$status) = $i&minus;&gt;inflate($buffer)</b> <br>
Inflates the complete contents of $buffer. The buffer can
either be a scalar or a scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">Returns
&quot;Z_OK&quot; if successful and &quot;Z_STREAM_END&quot;
if the end of the compressed data has been successfully
reached. If not successful, $out will be <i>undef</i> and
$status will hold the <i>zlib</i> error code.</p>

<p style="margin-left:11%; margin-top: 1em">The $buffer
parameter is modified by &quot;inflate&quot;. On completion
it will contain what remains of the input buffer after
inflation. This means that $buffer will be an empty string
when the return status is &quot;Z_OK&quot;. When the return
status is &quot;Z_STREAM_END&quot; the $buffer parameter
will contains what (if anything) was stored in the input
buffer after the deflated data stream.</p>

<p style="margin-left:11%; margin-top: 1em">This feature is
useful when processing a file format that encapsulates a
compressed data stream (e.g. gzip, zip).</p>

<p style="margin-left:11%; margin-top: 1em"><b>$status =
$i&minus;&gt;inflateSync($buffer)</b> <br>
Scans $buffer until it reaches either a <i>full flush
point</i> or the end of the buffer.</p>

<p style="margin-left:11%; margin-top: 1em">If a <i>full
flush point</i> is found, &quot;Z_OK&quot; is returned and
$buffer will be have all data up to the flush point removed.
This can then be passed to the &quot;deflate&quot;
method.</p>

<p style="margin-left:11%; margin-top: 1em">Any other
return code means that a flush point was not found. If more
data is available, &quot;inflateSync&quot; can be called
repeatedly with more compressed data until the flush point
is found.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;dict_adler()</b>
<br>
Returns the adler32 value for the dictionary.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;msg()</b>
<br>
Returns the last error message generated by zlib.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;total_in()</b>
<br>
Returns the total number of bytes compressed bytes input to
inflate.</p>


<p style="margin-left:11%; margin-top: 1em"><b>$i&minus;&gt;total_out()</b>
<br>
Returns the total number of uncompressed bytes output from
inflate.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Example</b>
<br>
Here is an example of using &quot;inflate&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">use strict ;
<br>
use warnings ; <br>
use Compress::Zlib ; <br>
my $x = inflateInit() <br>
or die &quot;Cannot create a inflation stream\n&quot; ; <br>
my $input = '' ; <br>
binmode STDIN; <br>
binmode STDOUT; <br>
my ($output, $status) ; <br>
while (read(STDIN, $input, 4096)) <br>
{ <br>
($output, $status) = $x&minus;&gt;inflate(\$input) ; <br>
print $output <br>
if $status == Z_OK or $status == Z_STREAM_END ; <br>
last if $status != Z_OK ; <br>
} <br>
die &quot;inflation failed\n&quot; <br>
unless $status == Z_STREAM_END ;</p>

<h2>CHECKSUM FUNCTIONS
<a name="CHECKSUM FUNCTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Two functions
are provided by <i>zlib</i> to calculate checksums. For the
Perl interface, the order of the two parameters in both
functions has been reversed. This allows both running
checksums and one off calculations to be done.</p>

<p style="margin-left:11%; margin-top: 1em">$crc =
adler32($buffer [,$crc]) ; <br>
$crc = crc32($buffer [,$crc]) ;</p>

<p style="margin-left:11%; margin-top: 1em">The buffer
parameters can either be a scalar or a scalar reference.</p>

<p style="margin-left:11%; margin-top: 1em">If the $crc
parameters is &quot;undef&quot;, the crc value will be
reset.</p>

<p style="margin-left:11%; margin-top: 1em">If you have
built this module with zlib 1.2.3 or better, two more
CRC-related functions are available.</p>

<p style="margin-left:11%; margin-top: 1em">$crc =
crc32_combine($crc1, $crc2, $len2); <br>
$adler = adler32_combine($adler1, $adler2, $len2);</p>

<p style="margin-left:11%; margin-top: 1em">These functions
allow checksums to be merged. Refer to the <i>zlib</i>
documentation for more details.</p>

<h2>Misc
<a name="Misc"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>my $version
= Compress::Zlib::zlib_version();</b> <br>
Returns the version of the zlib library.</p>

<h2>CONSTANTS
<a name="CONSTANTS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">All the
<i>zlib</i> constants are automatically imported when you
make use of <i>Compress::Zlib</i>.</p>

<h2>SUPPORT
<a name="SUPPORT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">General
feedback/questions/bug reports should be sent to
&lt;https://github.com/pmqs/IO&minus;Compress/issues&gt;
(preferred) or
&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=IO&minus;Compress&gt;.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">IO::Compress::Gzip,
IO::Uncompress::Gunzip, IO::Compress::Deflate,
IO::Uncompress::Inflate, IO::Compress::RawDeflate,
IO::Uncompress::RawInflate, IO::Compress::Bzip2,
IO::Uncompress::Bunzip2, IO::Compress::Lzma,
IO::Uncompress::UnLzma, IO::Compress::Xz,
IO::Uncompress::UnXz, IO::Compress::Lzip,
IO::Uncompress::UnLzip, IO::Compress::Lzop,
IO::Uncompress::UnLzop, IO::Compress::Lzf,
IO::Uncompress::UnLzf, IO::Compress::Zstd,
IO::Uncompress::UnZstd, IO::Uncompress::AnyInflate,
IO::Uncompress::AnyUncompress</p>


<p style="margin-left:11%; margin-top: 1em">IO::Compress::FAQ</p>


<p style="margin-left:11%; margin-top: 1em">File::GlobMapper,
Archive::Zip, Archive::Tar, IO::Zlib</p>

<p style="margin-left:11%; margin-top: 1em">For <small>RFC
1950, 1951</small> and 1952 see
&lt;https://datatracker.ietf.org/doc/html/rfc1950&gt;,
&lt;https://datatracker.ietf.org/doc/html/rfc1951&gt; and
&lt;https://datatracker.ietf.org/doc/html/rfc1952&gt;</p>

<p style="margin-left:11%; margin-top: 1em">The <i>zlib</i>
compression library was written by Jean-loup Gailly
&quot;gzip@prep.ai.mit.edu&quot; and Mark Adler
&quot;madler@alumni.caltech.edu&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The primary
site for the <i>zlib</i> compression library is
&lt;http://www.zlib.org&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">The primary
site for gzip is &lt;http://www.gzip.org&gt;.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This module was
written by Paul Marquess, &quot;pmqs@cpan.org&quot;.</p>

<h2>MODIFICATION HISTORY
<a name="MODIFICATION HISTORY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">See the Changes
file.</p>

<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Copyright (c)
1995&minus;2022 Paul Marquess. All rights reserved.</p>

<p style="margin-left:11%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr>
</body>
</html>
