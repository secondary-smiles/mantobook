<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:56:13 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;</title>

</head>
<body>
<h1>std::map</h1>



<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">std::map&lt;
_Key, _Tp, _Compare, _Alloc &gt; &minus; A standard
container made up of (key,value) pairs, which can be
retrieved based on a key, in logarithmic time.</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><tt>#include
&lt;map&gt;</tt></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Types</b></p>

<p style="margin-left:17%;">typedef _Alloc
<b>allocator_type</b> <br>
typedef _Rep_type::const_iterator <b>const_iterator</b> <br>
typedef _Alloc_traits::const_pointer <b>const_pointer</b>
<br>
typedef _Alloc_traits::const_reference
<b>const_reference</b> <br>
typedef <b>_Rep_type::const_reverse_iterator
const_reverse_iterator</b> <br>
typedef _Rep_type::difference_type <b>difference_type</b>
<br>
using <b>insert_return_type</b> = typename
<b>_Rep_type::insert_return_type</b> <br>
typedef _Rep_type::iterator <b>iterator</b> <br>
typedef _Compare <b>key_compare</b> <br>
typedef _Key <b>key_type</b> <br>
typedef _Tp <b>mapped_type</b> <br>
using <b>node_type</b> = typename
<b>_Rep_type::node_type</b> <br>
typedef _Alloc_traits::pointer <b>pointer</b> <br>
typedef _Alloc_traits::reference <b>reference</b> <br>
typedef <b>_Rep_type::reverse_iterator reverse_iterator</b>
<br>
typedef _Rep_type::size_type <b>size_type</b> <br>
typedef <b>std::pair</b>&lt; const _Key, _Tp &gt;
<b>value_type</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>Public
Member Functions</b></p>

<p style="margin-left:17%;"><b>map</b> ()=default <br>
Default constructor creates no elements. <br>
template&lt;typename _InputIterator &gt; <b>map</b>
(_InputIterator __first, _InputIterator __last) <br>
Builds a map from a range. <br>
template&lt;typename _InputIterator &gt; <b>map</b>
(_InputIterator __first, _InputIterator __last, const
_Compare &amp;__comp, const allocator_type
&amp;__a=allocator_type()) <br>
Builds a map from a range. <br>
template&lt;typename _InputIterator &gt; <b>map</b>
(_InputIterator __first, _InputIterator __last, const
allocator_type &amp;__a) <br>
Allocator-extended range constructor. <b><br>
map</b> (const _Compare &amp;__comp, const allocator_type
&amp;__a=allocator_type()) <br>
Creates a map with no elements. <b><br>
map</b> (const allocator_type &amp;__a) <br>
Allocator-extended default constructor. <b><br>
map</b> (const <b>map</b> &amp;)=default <br>
Map copy constructor. <b><br>
map</b> (const <b>map</b> &amp;__m, const
__type_identity_t&lt; allocator_type &gt; &amp;__a) <br>
Allocator-extended copy constructor. <b><br>
map</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt;
__l, const _Compare &amp;__comp=_Compare(), const
allocator_type &amp;__a=allocator_type()) <br>
Builds a map from an initializer_list. <b><br>
map</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt;
__l, const allocator_type &amp;__a) <br>
Allocator-extended initialier-list constructor. <b><br>
map</b> (<b>map</b> &amp;&amp;)=default <br>
Map move constructor. <b><br>
map</b> (<b>map</b> &amp;&amp;__m, const
__type_identity_t&lt; allocator_type &gt; &amp;__a)
noexcept(<b>is_nothrow_copy_constructible</b>&lt; _Compare
&gt;::value &amp;&amp;_Alloc_traits::_S_always_equal()) <br>
Allocator-extended move constructor. <b><br>
~map</b> ()=default <br>
mapped_type &amp; <b>at</b> (const key_type &amp;__k) <br>
Access to map data. <br>
const mapped_type &amp; <b>at</b> (const key_type &amp;__k)
const <br>
const_iterator <b>begin</b> () const noexcept <br>
iterator <b>begin</b> () noexcept <br>
const_iterator <b>cbegin</b> () const noexcept <br>
const_iterator <b>cend</b> () const noexcept <br>
void <b>clear</b> () noexcept <b><br>
const_reverse_iterator crbegin</b> () const noexcept <b><br>
const_reverse_iterator crend</b> () const noexcept <br>
template&lt;typename... _Args&gt; <b>std::pair</b>&lt;
iterator, bool &gt; <b>emplace</b> (_Args &amp;&amp;...
__args) <br>
Attempts to build and insert a std::pair into the map. <br>
template&lt;typename... _Args&gt; iterator
<b>emplace_hint</b> (const_iterator __pos, _Args
&amp;&amp;... __args) <br>
Attempts to build and insert a std::pair into the map. <br>
bool <b>empty</b> () const noexcept <br>
const_iterator <b>end</b> () const noexcept <br>
iterator <b>end</b> () noexcept <br>
size_type <b>erase</b> (const key_type &amp;__x) <br>
Erases elements according to the provided key. <br>
iterator <b>erase</b> (const_iterator __first,
const_iterator __last) <br>
Erases a [first,last) range of elements from a map. <br>
node_type <b>extract</b> (const key_type &amp;__x) <br>
Extract a node. <br>
node_type <b>extract</b> (const_iterator __pos) <br>
Extract a node. <br>
allocator_type <b>get_allocator</b> () const noexcept <br>
Get a copy of the memory allocation object. <br>
template&lt;typename _InputIterator &gt; void <b>insert</b>
(_InputIterator __first, _InputIterator __last) <br>
Template function that attempts to insert a range of
elements. <br>
iterator <b>insert</b> (const_iterator __hint, node_type
&amp;&amp;__nh) <br>
Re-insert an extracted node. <br>
insert_return_type <b>insert</b> (node_type &amp;&amp;__nh)
<br>
Re-insert an extracted node. <br>
void <b>insert</b> (<b>std::initializer_list</b>&lt;
<b>value_type</b> &gt; __list) <br>
Attempts to insert a list of std::pairs into the map. <br>
template&lt;typename _Obj &gt; <b>pair</b>&lt; iterator,
bool &gt; <b>insert_or_assign</b> (const key_type &amp;__k,
_Obj &amp;&amp;__obj) <br>
Attempts to insert or assign a std::pair into the map. <br>
template&lt;typename _Obj &gt; iterator
<b>insert_or_assign</b> (const_iterator __hint, const
key_type &amp;__k, _Obj &amp;&amp;__obj) <br>
Attempts to insert or assign a std::pair into the map. <br>
template&lt;typename _Obj &gt; iterator
<b>insert_or_assign</b> (const_iterator __hint, key_type
&amp;&amp;__k, _Obj &amp;&amp;__obj) <br>
template&lt;typename _Obj &gt; <b>pair</b>&lt; iterator,
bool &gt; <b>insert_or_assign</b> (key_type &amp;&amp;__k,
_Obj &amp;&amp;__obj) <br>
key_compare <b>key_comp</b> () const <br>
size_type <b>max_size</b> () const noexcept <br>
template&lt;typename _Cmp2 &gt; void <b>merge</b>
(<b>map</b>&lt; _Key, _Tp, _Cmp2, _Alloc &gt;
&amp;&amp;__source) <br>
template&lt;typename _Cmp2 &gt; void <b>merge</b>
(<b>map</b>&lt; _Key, _Tp, _Cmp2, _Alloc &gt; &amp;__source)
<br>
template&lt;typename _Cmp2 &gt; void <b>merge</b>
(<b>multimap</b>&lt; _Key, _Tp, _Cmp2, _Alloc &gt;
&amp;&amp;__source) <br>
template&lt;typename _Cmp2 &gt; void <b>merge</b>
(<b>multimap</b>&lt; _Key, _Tp, _Cmp2, _Alloc &gt;
&amp;__source) <b><br>
map</b> &amp; <b>operator=</b> (const <b>map</b>
&amp;)=default <br>
Map assignment operator. <b><br>
map</b> &amp; <b>operator=</b> (<b>initializer_list</b>&lt;
<b>value_type</b> &gt; __l) <br>
Map list assignment operator. <b><br>
map</b> &amp; <b>operator=</b> (<b>map</b>
&amp;&amp;)=default <br>
Move assignment operator. <br>
mapped_type &amp; <b>operator[]</b> (const key_type
&amp;__k) <br>
Subscript ( [] ) access to map data. <br>
mapped_type &amp; <b>operator[]</b> (key_type &amp;&amp;__k)
<b><br>
const_reverse_iterator rbegin</b> () const noexcept <b><br>
reverse_iterator rbegin</b> () noexcept <b><br>
const_reverse_iterator rend</b> () const noexcept <b><br>
reverse_iterator rend</b> () noexcept <br>
size_type <b>size</b> () const noexcept <br>
void <b>swap</b> (<b>map</b> &amp;__x)
noexcept(/*<b>conditional</b> */) <br>
Swaps data with another map. <br>
template&lt;typename... _Args&gt; <b>pair</b>&lt; iterator,
bool &gt; <b>try_emplace</b> (const key_type &amp;__k, _Args
&amp;&amp;... __args) <br>
Attempts to build and insert a std::pair into the map. <br>
template&lt;typename... _Args&gt; iterator
<b>try_emplace</b> (const_iterator __hint, const key_type
&amp;__k, _Args &amp;&amp;... __args) <br>
Attempts to build and insert a std::pair into the map. <br>
template&lt;typename... _Args&gt; iterator
<b>try_emplace</b> (const_iterator __hint, key_type
&amp;&amp;__k, _Args &amp;&amp;... __args) <br>
template&lt;typename... _Args&gt; <b>pair</b>&lt; iterator,
bool &gt; <b>try_emplace</b> (key_type &amp;&amp;__k, _Args
&amp;&amp;... __args) <br>
value_compare <b>value_comp</b> () const</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
iterator, bool &gt; <b>insert</b> (const <b>value_type</b>
&amp;__x) <br>
Attempts to insert a std::pair into the map. <b><br>
std::pair</b>&lt; iterator, bool &gt; <b>insert</b>
(<b>value_type</b> &amp;&amp;__x) <br>
Attempts to insert a std::pair into the map. <br>
template&lt;typename _Pair &gt; __enable_if_t&lt;
<b>is_constructible</b>&lt; <b>value_type</b>, _Pair
&gt;::value, <b>pair</b>&lt; iterator, bool &gt; &gt;
<b>insert</b> (_Pair &amp;&amp;__x) <br>
Attempts to insert a std::pair into the map.</p>

<p style="margin-left:23%; margin-top: 1em">iterator
<b>insert</b> (const_iterator __position, const
<b>value_type</b> &amp;__x) <br>
Attempts to insert a std::pair into the map. <br>
iterator <b>insert</b> (const_iterator __position,
<b>value_type</b> &amp;&amp;__x) <br>
Attempts to insert a std::pair into the map. <br>
template&lt;typename _Pair &gt; __enable_if_t&lt;
<b>is_constructible</b>&lt; <b>value_type</b>, _Pair
&gt;::value, iterator &gt; <b>insert</b> (const_iterator
__position, _Pair &amp;&amp;__x) <br>
Attempts to insert a std::pair into the map.</p>

<p style="margin-left:23%; margin-top: 1em">iterator
<b>erase</b> (const_iterator __position) <br>
Erases an element from a map. <br>
_GLIBCXX_ABI_TAG_CXX11 iterator <b>erase</b> (iterator
__position) <br>
Erases an element from a map.</p>

<p style="margin-left:23%; margin-top: 1em">iterator
<b>find</b> (const key_type &amp;__x) <br>
Tries to locate an element in a map. <br>
template&lt;typename _Kt &gt; auto <b>find</b> (const _Kt
&amp;__x) &minus;&gt; decltype(_M_t._M_find_tr(__x)) <br>
Tries to locate an element in a map.</p>

<p style="margin-left:23%; margin-top: 1em">const_iterator
<b>find</b> (const key_type &amp;__x) const <br>
Tries to locate an element in a map. <br>
template&lt;typename _Kt &gt; auto <b>find</b> (const _Kt
&amp;__x) const &minus;&gt; decltype(_M_t._M_find_tr(__x))
<br>
Tries to locate an element in a map.</p>

<p style="margin-left:23%; margin-top: 1em">size_type
<b>count</b> (const key_type &amp;__x) const <br>
Finds the number of elements with given key. <br>
template&lt;typename _Kt &gt; auto <b>count</b> (const _Kt
&amp;__x) const &minus;&gt; decltype(_M_t._M_count_tr(__x))
<br>
Finds the number of elements with given key.</p>

<p style="margin-left:23%; margin-top: 1em">bool
<b>contains</b> (const key_type &amp;__x) const <br>
Finds whether an element with the given key exists. <br>
template&lt;typename _Kt &gt; auto <b>contains</b> (const
_Kt &amp;__x) const &minus;&gt;
decltype(_M_t._M_find_tr(__x), void(), true) <br>
Finds whether an element with the given key exists.</p>

<p style="margin-left:23%; margin-top: 1em">iterator
<b>lower_bound</b> (const key_type &amp;__x) <br>
Finds the beginning of a subsequence matching given key.
<br>
template&lt;typename _Kt &gt; auto <b>lower_bound</b> (const
_Kt &amp;__x) &minus;&gt;
decltype(iterator(_M_t._M_lower_bound_tr(__x))) <br>
Finds the beginning of a subsequence matching given key.</p>

<p style="margin-left:23%; margin-top: 1em">const_iterator
<b>lower_bound</b> (const key_type &amp;__x) const <br>
Finds the beginning of a subsequence matching given key.
<br>
template&lt;typename _Kt &gt; auto <b>lower_bound</b> (const
_Kt &amp;__x) const &minus;&gt;
decltype(const_iterator(_M_t._M_lower_bound_tr(__x))) <br>
Finds the beginning of a subsequence matching given key.</p>

<p style="margin-left:23%; margin-top: 1em">iterator
<b>upper_bound</b> (const key_type &amp;__x) <br>
Finds the end of a subsequence matching given key. <br>
template&lt;typename _Kt &gt; auto <b>upper_bound</b> (const
_Kt &amp;__x) &minus;&gt;
decltype(iterator(_M_t._M_upper_bound_tr(__x))) <br>
Finds the end of a subsequence matching given key.</p>

<p style="margin-left:23%; margin-top: 1em">const_iterator
<b>upper_bound</b> (const key_type &amp;__x) const <br>
Finds the end of a subsequence matching given key. <br>
template&lt;typename _Kt &gt; auto <b>upper_bound</b> (const
_Kt &amp;__x) const &minus;&gt;
decltype(const_iterator(_M_t._M_upper_bound_tr(__x))) <br>
Finds the end of a subsequence matching given key.</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
iterator, iterator &gt; <b>equal_range</b> (const key_type
&amp;__x) <br>
Finds a subsequence matching given key. <br>
template&lt;typename _Kt &gt; auto <b>equal_range</b> (const
_Kt &amp;__x) &minus;&gt; decltype(<b>pair</b>&lt; iterator,
iterator &gt;(_M_t._M_equal_range_tr(__x))) <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:23%; margin-top: 1em"><b>std::pair</b>&lt;
const_iterator, const_iterator &gt; <b>equal_range</b>
(const key_type &amp;__x) const <br>
Finds a subsequence matching given key. <br>
template&lt;typename _Kt &gt; auto <b>equal_range</b> (const
_Kt &amp;__x) const &minus;&gt; decltype(<b>pair</b>&lt;
const_iterator, const_iterator
&gt;(_M_t._M_equal_range_tr(__x))) <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Friends</b></p>

<p style="margin-left:17%;">template&lt;typename _K1 ,
typename _T1 , typename _C1 , typename _A1 &gt; bool
<b>operator&lt;</b> (const <b>map</b>&lt; _K1, _T1, _C1, _A1
&gt; &amp;, const <b>map</b>&lt; _K1, _T1, _C1, _A1 &gt;
&amp;) <br>
template&lt;typename _K1 , typename _T1 , typename _C1 ,
typename _A1 &gt; bool <b>operator==</b> (const
<b>map</b>&lt; _K1, _T1, _C1, _A1 &gt; &amp;, const
<b>map</b>&lt; _K1, _T1, _C1, _A1 &gt; &amp;) <br>
template&lt;typename , typename &gt; struct
<b>std::_Rb_tree_merge_helper</b></p>

<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key, typename _Tp, typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt;
&gt;&gt;</b> <br>
class std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;&quot;A
standard container made up of (key,value) pairs, which can
be retrieved based on a key, in logarithmic time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Since</b></p>

<p style="margin-left:17%;">C++98</p>

<p style="margin-left:11%; margin-top: 1em"><b>Template
Parameters</b></p>

<p style="margin-left:17%;"><i>_Key</i> Type of key
objects. <i><br>
_Tp</i> Type of mapped objects. <i><br>
_Compare</i> Comparison function object type, defaults to
less&lt;_Key&gt;. <i><br>
_Alloc</i> Allocator type, defaults to
allocator&lt;pair&lt;const _Key, _Tp&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Meets the
requirements of a <tt>container</tt>, a <tt>reversible
container</tt>, and an <tt>associative container</tt> (using
unique keys). For a <tt>map&lt;Key,T&gt;</tt> the key_type
is Key, the mapped_type is T, and the value_type is
std::pair&lt;const Key,T&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Maps support
bidirectional iterators.</p>

<p style="margin-left:11%; margin-top: 1em">The private
tree data is declared exactly the same way for map and
multimap; the distinction is made entirely in how the tree
functions are called (*_unique versus *_equal, same as the
standard).</p>

<h2>Constructor &amp; Destructor Documentation
<a name="Constructor &amp; Destructor Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map ()</b>
<tt>[default]</tt> <br>
Default constructor creates no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map (const
_Compare &amp; __comp, const allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
Creates a map with no elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__comp</i> A comparison
object. <i><br>
__a</i> An allocator object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map (const
map&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;)</b>
<tt>[default]</tt> <br>
Map copy constructor. Whether the allocator is copied
depends on the allocator traits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map (map&lt;
_Key, _Tp, _Compare, _Alloc &gt; &amp;&amp;)</b>
<tt>[default]</tt> <br>
Map move constructor. The newly-created map contains the
exact contents of the moved instance. The moved instance is
a valid, but unspecified, map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map
(initializer_list&lt; value_type &gt; __l, const _Compare
&amp; __comp =</b> <tt>_Compare()</tt><b>, const
allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds a map from an initializer_list.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An initializer_list.
<i><br>
__comp</i> A comparison object. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create a map
consisting of copies of the elements in the initializer_list
<i>__l</i>. This is linear in N if the range is already
sorted, and NlogN otherwise (where N is
<i>__l.size()</i>).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map (const
allocator_type &amp; __a)</b> <tt>[inline]</tt><b>,</b>
<tt>[explicit]</tt> <br>
Allocator-extended default constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map (const
map&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp; __m, const
__type_identity_t&lt; allocator_type &gt; &amp; __a)</b>
<tt>[inline]</tt> <br>
Allocator-extended copy constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map (map&lt;
_Key, _Tp, _Compare, _Alloc &gt; &amp;&amp; __m, const
__type_identity_t&lt; allocator_type &gt; &amp; __a)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Allocator-extended move constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::map
(initializer_list&lt; value_type &gt; __l, const
allocator_type &amp; __a)</b> <tt>[inline]</tt> <br>
Allocator-extended initialier-list constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _InputIterator &gt; std::map&lt; _Key,
_Tp, _Compare, _Alloc &gt;::map (_InputIterator __first,
_InputIterator __last, const allocator_type &amp; __a)</b>
<tt>[inline]</tt> <br>
Allocator-extended range constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _InputIterator &gt; std::map&lt; _Key,
_Tp, _Compare, _Alloc &gt;::map (_InputIterator __first,
_InputIterator __last)</b> <tt>[inline]</tt> <br>
Builds a map from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator.</p>

<p style="margin-left:11%; margin-top: 1em">Create a map
consisting of copies of the elements from [__first,__last).
This is linear in N if the range is already sorted, and
NlogN otherwise (where N is distance(__first,__last)).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _InputIterator &gt; std::map&lt; _Key,
_Tp, _Compare, _Alloc &gt;::map (_InputIterator __first,
_InputIterator __last, const _Compare &amp; __comp, const
allocator_type &amp; __a =</b>
<tt>allocator_type()</tt><b>)</b> <tt>[inline]</tt> <br>
Builds a map from a range.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> An input
iterator. <i><br>
__last</i> An input iterator. <i><br>
__comp</i> A comparison functor. <i><br>
__a</i> An allocator object.</p>

<p style="margin-left:11%; margin-top: 1em">Create a map
consisting of copies of the elements from [__first,__last).
This is linear in N if the range is already sorted, and
NlogN otherwise (where N is distance(__first,__last)).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::~map ()</b>
<tt>[default]</tt> <br>
The dtor only erases the elements, and note that if the
elements themselves are pointers, the pointed-to memory is
not touched in any way. Managing the pointer is the
user&rsquo;s responsibility.</p>

<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
mapped_type &amp; std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::at (const key_type &amp; __k)</b> <tt>[inline]</tt>
<br>
Access to map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A reference to the data whose
key is equivalent to <i>__k</i>, if such a data is present
in the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Exceptions</b></p>

<p style="margin-left:17%;"><i>std::out_of_range</i> If no
such data is present.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::end()</b>,
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::key_comp()</b>, and <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::lower_bound()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::begin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first pair in the map. Iteration is done in ascending order
according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::begin ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read/write iterator that points to the first pair
in the map. Iteration is done in ascending order according
to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::cbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points to the
first pair in the map. Iteration is done in ascending order
according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::cend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last pair in the map. Iteration is done in ascending
order according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::clear
()</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Erases all elements in a map. Note that this function only
erases the elements, and that if the elements themselves are
pointers, the pointed-to memory is not touched in any way.
Managing the pointer is the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::contains (const _Kt &amp; __x) const
&minus;&gt; decltype(_M_t._M_find_tr(__x), void(),
true)</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds whether
an element with the given key exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pairs to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if there is an element
with the specified key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
bool std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::contains
(const key_type &amp; __x) const</b> <tt>[inline]</tt> <br>
Finds whether an element with the given key exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pairs to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">True if there is an element
with the specified key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::count (const _Kt &amp; __x) const
&minus;&gt; decltype(_M_t._M_count_tr(__x))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds the
number of elements with given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pairs to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Number of elements with
specified key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
only makes sense for multimaps; for map the result will
either be 0 (not present) or 1 (present).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::count (const key_type &amp; __x) const</b>
<tt>[inline]</tt> <br>
Finds the number of elements with given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pairs to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Number of elements with
specified key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
only makes sense for multimaps; for map the result will
either be 0 (not present) or 1 (present).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_reverse_iterator std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::crbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last pair in the map. Iteration is done in descending
order according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_reverse_iterator std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::crend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to one before the first pair in the map. Iteration is done
in descending order according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename... _Args&gt; std::pair&lt; iterator,
bool &gt; std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace (_Args &amp;&amp;... __args)</b>
<tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__args</i> Arguments used to
generate a new pair instance (see std::piecewise_contruct
for passing arguments to each part of the pair
constructor).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to build and insert a (key, value) pair into the
map. A map relies on unique keys and thus a pair is only
inserted if its first element (the key) is not already
present in the map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace_hint()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::end()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::key_comp()</b>, and <b>std::map&lt;
_Key, _Tp, _Compare, _Alloc &gt;::lower_bound()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename... _Args&gt; iterator std::map&lt;
_Key, _Tp, _Compare, _Alloc &gt;::emplace_hint
(const_iterator __pos, _Args &amp;&amp;... __args)</b>
<tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__pos</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__args</i> Arguments used to generate a new pair instance
(see std::piecewise_contruct for passing arguments to each
part of the pair constructor).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of the std::pair built from <i>__args</i>
(may or may not be that std::pair).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
emplace() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time (if the hint is not taken).</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace()</b>, <b>std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::insert()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::insert_or_assign()</b>, and
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::try_emplace()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
bool std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::empty ()
const</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns true if the map is empty. (Thus begin() would equal
end().)</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::end () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) iterator that points one past
the last pair in the map. Iteration is done in ascending
order according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::end
()</b> <tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Returns a read/write iterator that points one past the last
pair in the map. Iteration is done in ascending order
according to the keys.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::at()</b>,
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace()</b>, <b>std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::extract()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::insert()</b>, <b>std::map&lt; _Key,
_Tp, _Compare, _Alloc &gt;::insert_or_assign()</b>,
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::operator[]()</b>, and <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::try_emplace()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::equal_range (const _Kt &amp; __x)
&minus;&gt; decltype(pair&lt;iterator,
iterator&gt;(_M_t._M_equal_range_tr(__x)))</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p><tt>[inline]</tt>&quot;</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Finds a
subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pairs to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
is equivalent to</p>


<p style="margin-left:11%; margin-top: 1em">std::make_pair(c.lower_bound(val),
<br>
c.upper_bound(val))</p>

<p style="margin-left:11%; margin-top: 1em">(but is faster
than making the calls separately).</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for multimaps.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::equal_range (const _Kt &amp; __x)
const &minus;&gt; decltype(pair&lt;const_iterator,
const_iterator&gt;(</b> <br>
_M_t._M_equal_range_tr(__x))) <tt>[inline]</tt>&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Finds a
subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pairs to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of read-only (constant)
iterators that possibly points to the subsequence matching
given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
is equivalent to</p>


<p style="margin-left:11%; margin-top: 1em">std::make_pair(c.lower_bound(val),
<br>
c.upper_bound(val))</p>

<p style="margin-left:11%; margin-top: 1em">(but is faster
than making the calls separately).</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for multimaps.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::pair&lt; iterator, iterator &gt; std::map&lt; _Key,
_Tp, _Compare, _Alloc &gt;::equal_range (const key_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pairs to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of iterators that possibly
points to the subsequence matching given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
is equivalent to</p>


<p style="margin-left:11%; margin-top: 1em">std::make_pair(c.lower_bound(val),
<br>
c.upper_bound(val))</p>

<p style="margin-left:11%; margin-top: 1em">(but is faster
than making the calls separately).</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for multimaps.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::pair&lt; const_iterator, const_iterator &gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::equal_range
(const key_type &amp; __x) const</b> <tt>[inline]</tt> <br>
Finds a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pairs to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Pair of read-only (constant)
iterators that possibly points to the subsequence matching
given key.</p>

<p style="margin-left:11%; margin-top: 1em">This function
is equivalent to</p>


<p style="margin-left:11%; margin-top: 1em">std::make_pair(c.lower_bound(val),
<br>
c.upper_bound(val))</p>

<p style="margin-left:11%; margin-top: 1em">(but is faster
than making the calls separately).</p>

<p style="margin-left:11%; margin-top: 1em">This function
probably only makes sense for multimaps.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::erase (const key_type &amp; __x)</b> <tt>[inline]</tt>
<br>
Erases elements according to the provided key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of element to be
erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The number of elements
erased.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases all the elements located by the given key from a map.
Note that this function only erases the element, and that if
the element is itself a pointer, the pointed-to memory is
not touched in any way. Managing the pointer is the
user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::erase (const_iterator __first, const_iterator
__last)</b> <tt>[inline]</tt> <br>
Erases a [first,last) range of elements from a map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the start of the range to be erased. <i><br>
__last</i> Iterator pointing to the end of the range to be
erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">The iterator <i>__last</i>.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases a sequence of elements from a map. Note that this
function only erases the element, and that if the element is
itself a pointer, the pointed-to memory is not touched in
any way. Managing the pointer is the user&rsquo;s
responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::erase (const_iterator __position)</b>
<tt>[inline]</tt> <br>
Erases an element from a map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
pointing to the element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element immediately following <i>position</i> prior to the
element being erased. If no such element exists, end() is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases an element, pointed to by the given iterator, from a
map. Note that this function only erases the element, and
that if the element is itself a pointer, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
_GLIBCXX_ABI_TAG_CXX11 iterator std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::erase (iterator __position)</b>
<tt>[inline]</tt> <br>
Erases an element from a map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
pointing to the element to be erased.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator pointing to the
element immediately following <i>position</i> prior to the
element being erased. If no such element exists, end() is
returned.</p>

<p style="margin-left:11%; margin-top: 1em">This function
erases an element, pointed to by the given iterator, from a
map. Note that this function only erases the element, and
that if the element is itself a pointer, the pointed-to
memory is not touched in any way. Managing the pointer is
the user&rsquo;s responsibility.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
node_type std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::extract (const key_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Extract a node.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
node_type std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::extract (const_iterator __pos)</b> <tt>[inline]</tt>
<br>
Extract a node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::end()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::find (const _Kt &amp; __x)
&minus;&gt; decltype(_M_t._M_find_tr(__x))</b> <tt><br>
[inline]</tt>&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Tries to locate
an element in a map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after pair. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::find (const _Kt &amp; __x) const
&minus;&gt; decltype(_M_t._M_find_tr(__x))</b> <tt><br>
[inline]</tt>&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Tries to locate
an element in a map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) iterator
pointing to sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns a constant
iterator pointing to the sought after pair. If unsuccessful
it returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::find
(const key_type &amp; __x)</b> <tt>[inline]</tt> <br>
Tries to locate an element in a map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to
sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns an iterator
pointing to the sought after pair. If unsuccessful it
returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::find (const key_type &amp; __x) const</b>
<tt>[inline]</tt> <br>
Tries to locate an element in a map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) iterator
pointing to sought-after element, or end() if not found.</p>

<p style="margin-left:11%; margin-top: 1em">This function
takes a key and tries to locate the element with which the
key matches. If successful the function returns a constant
iterator pointing to the sought after pair. If unsuccessful
it returns the past-the-end ( <tt>end()</tt> ) iterator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
allocator_type std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::get_allocator () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Get a copy of the memory allocation object.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _InputIterator &gt; void std::map&lt;
_Key, _Tp, _Compare, _Alloc &gt;::insert (_InputIterator
__first, _InputIterator __last)</b> <tt>[inline]</tt> <br>
Template function that attempts to insert a range of
elements.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__first</i> Iterator
pointing to the start of the range to be inserted. <i><br>
__last</i> Iterator pointing to the end of the range.</p>

<p style="margin-left:11%; margin-top: 1em">Complexity
similar to that of the range constructor.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Pair &gt; __enable_if_t&lt;
is_constructible&lt; value_type, _Pair &gt;::value, pair&lt;
iterator, bool &gt; &gt; std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::insert (_Pair &amp;&amp; __x)</b>
<tt>[inline]</tt> <br>
Attempts to insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Pair to be inserted
(see std::make_pair for easy creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the map. A map
relies on unique keys and thus a pair is only inserted if
its first element (the key) is not already present in the
map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace_hint()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::end()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::key_comp()</b>, and <b>std::map&lt;
_Key, _Tp, _Compare, _Alloc &gt;::lower_bound()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::pair&lt; iterator, bool &gt; std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::insert (const value_type &amp;
__x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Pair to be inserted
(see std::make_pair for easy creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the map. A map
relies on unique keys and thus a pair is only inserted if
its first element (the key) is not already present in the
map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::insert (const_iterator __hint, node_type &amp;&amp;
__nh)</b> <tt>[inline]</tt> <br>
Re-insert an extracted node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Pair &gt; __enable_if_t&lt;
is_constructible&lt; value_type, _Pair &gt;::value, iterator
&gt; std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert
(const_iterator __position, _Pair &amp;&amp; __x)</b>
<tt>[inline]</tt> <br>
Attempts to insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
that serves as a hint as to where the pair should be
inserted. <i><br>
__x</i> Pair to be inserted (see std::make_pair for easy
creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time (if the hint is not taken).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::insert (const_iterator __position, const value_type
&amp; __x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
that serves as a hint as to where the pair should be
inserted. <i><br>
__x</i> Pair to be inserted (see std::make_pair for easy
creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time (if the hint is not taken).</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::insert (const_iterator __position, value_type
&amp;&amp; __x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__position</i> An iterator
that serves as a hint as to where the pair should be
inserted. <i><br>
__x</i> Pair to be inserted (see std::make_pair for easy
creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
insert() does. Note that the first parameter is only a hint
and can potentially improve the performance of the insertion
process. A bad hint would cause no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time (if the hint is not taken).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
insert_return_type std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::insert (node_type &amp;&amp; __nh)</b>
<tt>[inline]</tt> <br>
Re-insert an extracted node.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::insert()</b>, and <b>std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::operator[]()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::insert
(std::initializer_list&lt; value_type &gt; __list)</b>
<tt>[inline]</tt> <br>
Attempts to insert a list of std::pairs into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__list</i> A
std::initializer_list&lt;value_type&gt; of pairs to be
inserted.</p>

<p style="margin-left:11%; margin-top: 1em">Complexity
similar to that of the range constructor.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::insert()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
std::pair&lt; iterator, bool &gt; std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::insert (value_type &amp;&amp;
__x)</b> <tt>[inline]</tt> <br>
Attempts to insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Pair to be inserted
(see std::make_pair for easy creation of pairs).</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the map. A map
relies on unique keys and thus a pair is only inserted if
its first element (the key) is not already present in the
map.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::move()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Obj &gt; pair&lt; iterator, bool &gt;
std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::insert_or_assign (const key_type &amp; __k, _Obj
&amp;&amp; __obj)</b> <tt>[inline]</tt> <br>
Attempts to insert or assign a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> Key to use for
finding a possibly existing pair in the map. <i><br>
__obj</i> Argument used to generate the .second for a pair
instance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the map. A map
relies on unique keys and thus a pair is only inserted if
its first element (the key) is not already present in the
map. If the pair was already in the map, the .second of the
pair is assigned from __obj.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace_hint()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::end()</b>,
<b>std::forward_as_tuple()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::key_comp()</b>, <b>std::map&lt; _Key,
_Tp, _Compare, _Alloc &gt;::lower_bound()</b>, and
<b>std::piecewise_construct</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Obj &gt; iterator std::map&lt; _Key,
_Tp, _Compare, _Alloc &gt;::insert_or_assign (const_iterator
__hint, const key_type &amp; __k, _Obj &amp;&amp; __obj)</b>
<tt>[inline]</tt> <br>
Attempts to insert or assign a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__k</i> Key to use for finding a possibly existing pair in
the map. <i><br>
__obj</i> Argument used to generate the .second for a pair
instance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of <i>__x</i> (may or may not be the pair
passed in).</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to insert a (key, value) pair into the map. A map
relies on unique keys and thus a pair is only inserted if
its first element (the key) is not already present in the
map. If the pair was already in the map, the .second of the
pair is assigned from __obj.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace_hint()</b>, <b>std::forward_as_tuple()</b>,
and <b>std::piecewise_construct</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
key_compare std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::key_comp () const</b> <tt>[inline]</tt> <br>
Returns the key comparison object out of which the map was
constructed.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::at()</b>,
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace()</b>, <b>std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::insert()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::insert_or_assign()</b>,
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::operator[]()</b>, and <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::try_emplace()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::lower_bound (const _Kt &amp; __x)
&minus;&gt;
decltype(iterator(_M_t._M_lower_bound_tr(__x)))</b> <tt><br>
[inline]</tt>&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Finds the
beginning of a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to first
element equal to or greater than key, or end().</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the first element of a subsequence of elements that
matches the given key. If unsuccessful it returns an
iterator pointing to the first element that has a greater
value than given key or end() if no such element exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::lower_bound (const _Kt &amp; __x)
const &minus;&gt;
decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))</b>
<tt><br>
[inline]</tt>&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Finds the
beginning of a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) iterator
pointing to first element equal to or greater than key, or
end().</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the first element of a subsequence of elements that
matches the given key. If unsuccessful it returns an
iterator pointing to the first element that has a greater
value than given key or end() if no such element exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::lower_bound (const key_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Finds the beginning of a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to first
element equal to or greater than key, or end().</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the first element of a subsequence of elements that
matches the given key. If unsuccessful it returns an
iterator pointing to the first element that has a greater
value than given key or end() if no such element exists.</p>

<p style="margin-left:11%; margin-top: 1em">Referenced by
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::at()</b>,
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace()</b>, <b>std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::insert()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::insert_or_assign()</b>,
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::operator[]()</b>, and <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::try_emplace()</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::lower_bound (const key_type &amp; __x) const</b>
<tt>[inline]</tt> <br>
Finds the beginning of a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) iterator
pointing to first element equal to or greater than key, or
end().</p>

<p style="margin-left:11%; margin-top: 1em">This function
returns the first element of a subsequence of elements that
matches the given key. If unsuccessful it returns an
iterator pointing to the first element that has a greater
value than given key or end() if no such element exists.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::max_size () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the maximum size of the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
map &amp; std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::operator= (const map&lt; _Key, _Tp, _Compare, _Alloc
&gt; &amp;)</b> <tt>[default]</tt> <br>
Map assignment operator. Whether the allocator is copied
depends on the allocator traits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
map &amp; std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::operator= (initializer_list&lt; value_type &gt;
__l)</b> <tt>[inline]</tt> <br>
Map list assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__l</i> An
initializer_list.</p>

<p style="margin-left:11%; margin-top: 1em">This function
fills a map with copies of the elements in the initializer
list <i>__l</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
assignment completely changes the map and that the resulting
map&rsquo;s size is the same as the number of elements
assigned.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
map &amp; std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::operator= (map&lt; _Key, _Tp, _Compare, _Alloc &gt;
&amp;&amp;)</b> <tt>[default]</tt> <br>
Move assignment operator.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
mapped_type &amp; std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::operator[] (const key_type &amp; __k)</b>
<tt>[inline]</tt> <br>
Subscript ( [] ) access to map data.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> The key for which
data should be retrieved.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A reference to the data of the
(key,data) pair.</p>

<p style="margin-left:11%; margin-top: 1em">Allows for easy
lookup with the subscript ( [] ) operator. Returns data
associated with the key specified in subscript. If the key
does not exist, a pair with that key is created using
default values, which is then returned.</p>

<p style="margin-left:11%; margin-top: 1em">Lookup requires
logarithmic time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::end()</b>,
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::insert()</b>, <b>std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::key_comp()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::lower_bound()</b>, and
<b>std::piecewise_construct</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_reverse_iterator std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::rbegin () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to the last pair in the map. Iteration is done in descending
order according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
reverse_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::rbegin ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to the
last pair in the map. Iteration is done in descending order
according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_reverse_iterator std::map&lt; _Key, _Tp, _Compare,
_Alloc &gt;::rend () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read-only (constant) reverse iterator that points
to one before the first pair in the map. Iteration is done
in descending order according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
reverse_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::rend ()</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns a read/write reverse iterator that points to one
before the first pair in the map. Iteration is done in
descending order according to the keys.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
size_type std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::size () const</b> <tt>[inline]</tt><b>,</b>
<tt>[noexcept]</tt> <br>
Returns the size of the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
void std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;::swap
(map&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp; __x)</b>
<tt>[inline]</tt><b>,</b> <tt>[noexcept]</tt> <br>
Swaps data with another map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> A map of the same
element and allocator types.</p>

<p style="margin-left:11%; margin-top: 1em">This exchanges
the elements between two maps in constant time. (It is only
swapping a pointer, an integer, and an instance of the
<tt>Compare</tt> type (which itself is often stateless and
empty), so it should be quite fast.) Note that the global
std::swap() function is specialized such that
std::swap(m1,m2) will feed to this function.</p>

<p style="margin-left:11%; margin-top: 1em">Whether the
allocators are swapped depends on the allocator traits.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename... _Args&gt; pair&lt; iterator, bool
&gt; std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::try_emplace (const key_type &amp; __k, _Args
&amp;&amp;... __args)</b> <tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__k</i> Key to use for
finding a possibly existing pair in the map. <i><br>
__args</i> Arguments used to generate the .second for a new
pair instance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">A pair, of which the first
element is an iterator that points to the possibly inserted
pair, and the second is a bool that is true if the pair was
actually inserted.</p>

<p style="margin-left:11%; margin-top: 1em">This function
attempts to build and insert a (key, value) pair into the
map. A map relies on unique keys and thus a pair is only
inserted if its first element (the key) is not already
present in the map. If a pair is not inserted, this function
has no effect.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time.</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace_hint()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::end()</b>,
<b>std::forward_as_tuple()</b>, <b>std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::key_comp()</b>, <b>std::map&lt; _Key,
_Tp, _Compare, _Alloc &gt;::lower_bound()</b>, and
<b>std::piecewise_construct</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename... _Args&gt; iterator std::map&lt;
_Key, _Tp, _Compare, _Alloc &gt;::try_emplace
(const_iterator __hint, const key_type &amp; __k, _Args
&amp;&amp;... __args)</b> <tt>[inline]</tt> <br>
Attempts to build and insert a std::pair into the map.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__hint</i> An iterator that
serves as a hint as to where the pair should be inserted.
<i><br>
__k</i> Key to use for finding a possibly existing pair in
the map. <i><br>
__args</i> Arguments used to generate the .second for a new
pair instance.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">An iterator that points to the
element with key of the std::pair built from <i>__args</i>
(may or may not be that std::pair).</p>

<p style="margin-left:11%; margin-top: 1em">This function
is not concerned about whether the insertion took place, and
thus does not return a boolean like the single-argument
try_emplace() does. However, if insertion did not take
place, this function has no effect. Note that the first
parameter is only a hint and can potentially improve the
performance of the insertion process. A bad hint would cause
no gains in efficiency.</p>

<p style="margin-left:11%; margin-top: 1em">See
https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
for more on <i>hinting</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Insertion
requires logarithmic time (if the hint is not taken).</p>

<p style="margin-left:11%; margin-top: 1em">References
<b>std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::emplace_hint()</b>, <b>std::forward_as_tuple()</b>,
and <b>std::piecewise_construct</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::upper_bound (const _Kt &amp; __x)
&minus;&gt;
decltype(iterator(_M_t._M_upper_bound_tr(__x)))</b> <tt><br>
[inline]</tt>&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Finds the end
of a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to the first
element greater than key, or end().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
template&lt;typename _Kt &gt; auto std::map&lt; _Key, _Tp,
_Compare, _Alloc &gt;::upper_bound (const _Kt &amp; __x)
const &minus;&gt;
decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))</b>
<tt><br>
[inline]</tt>&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Finds the end
of a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) iterator
pointing to first iterator greater than key, or end().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::upper_bound (const key_type &amp; __x)</b>
<tt>[inline]</tt> <br>
Finds the end of a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Iterator pointing to the first
element greater than key, or end().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
const_iterator std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::upper_bound (const key_type &amp; __x) const</b>
<tt>[inline]</tt> <br>
Finds the end of a subsequence matching given key.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Parameters</b></p>

<p style="margin-left:17%;"><i>__x</i> Key of (key, value)
pair to be located.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Returns</b></p>

<p style="margin-left:17%;">Read-only (constant) iterator
pointing to first iterator greater than key, or end().</p>


<p style="margin-left:11%; margin-top: 1em"><b>template&lt;typename
_Key , typename _Tp , typename _Compare =
std::less&lt;_Key&gt;, typename _Alloc =
std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;&gt;
value_compare std::map&lt; _Key, _Tp, _Compare, _Alloc
&gt;::value_comp () const</b> <tt>[inline]</tt> <br>
Returns a value comparison object, built from the key
comparison object out of which the map was constructed.</p>

<h2>Author
<a name="Author"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Generated
automatically by Doxygen for libstdc++ from the source
code.</p>
<hr>
</body>
</html>
