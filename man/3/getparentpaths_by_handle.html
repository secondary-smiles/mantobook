<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon May 29 22:55:05 2023 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HANDLE</title>

</head>
<body>
<h1>getparentpaths_by_handle</h1>



<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">path_to_handle,
path_to_fshandle, fd_to_handle, handle_to_fshandle,
open_by_handle, readlink_by_handle, attr_multi_by_handle,
attr_list_by_handle, fssetdm_by_handle, free_handle,
getparents_by_handle, getparentpaths_by_handle &minus; file
handle operations</p>

<h2>C SYNOPSIS
<a name="C SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>#include
&lt;sys/types.h&gt; <br>
#include &lt;xfs/handle.h&gt;</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int&nbsp;path_to_handle(char
*</b><i>path</i><b>, void **</b><i>hanp</i><b>, size_t
*</b><i>hlen</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;path_to_fshandle(char
*</b><i>path</i><b>, void **</b><i>hanp</i><b>, size_t
*</b><i>hlen</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;fd_to_handle(int</b>
<i>fd</i><b>, void **</b><i>hanp</i><b>, size_t
*</b><i>hlen</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;handle_to_fshandle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>, void
**</b><i>fshanp</i><b>, size_t
*</b><i>fshlen</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>int&nbsp;open_by_handle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>, int</b>
<i>oflag</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;readlink_by_handle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>, void
*</b><i>buf</i><b>, size_t</b> <i>bs</i><b>);</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;attr_multi_by_handle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>, void
*</b><i>buf</i><b>, int</b> <i>rtrvcnt</i><b>, int</b>
<i>flags</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;attr_list_by_handle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>, char
*</b><i>buf</i><b>, size_t</b> <i>bufsiz</i><b>, int</b>
<i>flags</i><b>, struct attrlist_cursor
*</b><i>cursor</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;fssetdm_by_handle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>, struct
fsdmidata *</b><i>fssetdm</i><b>);</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p style="margin-top: 1em"><b>void&nbsp;free_handle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>);</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;getparents_by_handle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>, parent_t
*</b><i>buf</i><b>, size_t</b> <i>bufsiz</i><b>,
parent_cursor_t *</b><i>cursor</i><b>, unsigned int
*</b><i>count</i><b>, unsigned int
*</b><i>more</i><b>);</b></p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">



<p style="margin-top: 1em"><b>int&nbsp;getparentpaths_by_handle(void
*</b><i>hanp</i><b>, size_t</b> <i>hlen</i><b>, parent_t
*</b><i>buf</i><b>, size_t</b> <i>bufsiz</i><b>,
parent_cursor_t *</b><i>cursor</i><b>, unsigned int
*</b><i>count</i><b>, unsigned int
*</b><i>more</i><b>);</b></p> </td></tr>
</table>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">These functions
provide a way to perform certain filesystem operations
without using a file descriptor to access filesystem
objects. They are intended for use by a limited set of
system utilities such as backup programs. They are supported
only by the XFS filesystem. Link with the <b>libhandle</b>
library to access these functions.</p>

<p style="margin-left:11%; margin-top: 1em">A handle,
<i>hanp</i>, uniquely identifies a filesystem object or an
entire filesystem. There is one and only one handle per
filesystem or filesystem object. Handles consist of some
number of bytes. The size of a handle (i.e. the number of
bytes comprising it) varies by the type of handle and may
vary for different objects of the same type. The content of
a handle is opaque to applications. Since handle sizes vary
and their contents are opaque, handles are described by two
quantities, a pointer (<i>hanp</i>) and a size
(<i>hlen</i>). The size, <i>hlen</i>, indicates the number
of bytes in the handle which are pointed to by the
pointer.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>path_to_handle</b>() function returns the handle for the
object given by the <i>path</i> argument. If the final
component of the path name is a symbolic link, the handle
returned is that of the link itself.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>path_to_fshandle</b>() function returns the handle for
the filesystem in which the object given by the <i>path</i>
argument resides.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>fd_to_handle</b>() function returns the handle for the
object referenced by the <i>fd</i> argument, which must be a
valid file descriptor.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>handle_to_fshandle</b>() function returns the handle for
the filesystem in which the object referenced by the handle
given by the <i>hanp</i> and <i>hlen</i> arguments
resides.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>open_by_handle</b>() function opens a file descriptor for
the object referenced by a handle. It is analogous and
identical to <b>open</b>(2) with the exception of accepting
handles instead of path names.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>readlink_by_handle</b>() function returns the contents of
a symbolic link referenced by a handle.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>attr_multi_by_handle</b>() function manipulates multiple
user attributes on a filesystem object. It is analogous and
identical to <b>attr_multif</b>(3) except that a handle is
specified instead of a file descriptor.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>attr_list_by_handle</b>() function returns the names of
the user attributes of a filesystem object. It is analogous
and identical to <b>attr_listf</b>(3) except that a handle
is specified instead of a file descriptor.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>fssetdm_by_handle</b>() function sets the
<b>di_dmevmask</b> and <b>di_dmstate</b> fields in an XFS
on-disk inode. It is analogous to the <b>XFS_IOC_FSSETDM
xfsctl</b>(3) command, except that a handle is specified
instead of a file. This function is not supported on
Linux.</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>free_handle</b>() function frees the storage allocated
for handles returned by the following functions:
<b>path_to_handle</b>(), <b>path_to_fshandle</b>(),
<b>fd_to_handle</b>(), and <b>handle_to_fshandle</b>().</p>

<p style="margin-left:11%; margin-top: 1em">The
<b>getparents_by_handle</b>() function returns an array of
<b>parent_t</b> structures for each hardlink to the inode
represented by the given handle. The parent structure
encodes the parent inode number, generation number and the
basename of the link. <b>This function is not operational on
Linux.</b></p>

<p style="margin-left:11%; margin-top: 1em">The
<b>getparentpaths_by_handle</b>() function is identical to
the <b>getparents_by_handle</b>() function except that
instead of returning the basename it returns the path of the
link up to the mount point. <b>This function is also not
operational on Linux.</b></p>

<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The function
<b>free_handle</b>() has no failure indication. The other
functions return the value 0 to the calling process if they
succeed; otherwise, they return the value &minus;1 and set
<i>errno</i> to indicate the error.</p>

<h2>ERRORS
<a name="ERRORS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>EACCES</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">Search permission was denied for
a component of <i>path</i>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EBADF</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>fd</i> is not a valid and open file descriptor.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EFAULT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>An argument pointed to an invalid address.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EINVAL</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>path</i> is in a filesystem that does not support
these functions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ELOOP</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Too many symbolic links were encountered in translating
the path name.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>ENAMETOOLONG</b></p>

<p style="margin-left:22%;">A component of <i>path</i> or
the entire length of <i>path</i> exceeds filesystem
limits.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>ENOENT</b></p></td>
<td width="2%"></td>
<td width="72%">


<p>A component of <i>path</i> does not exist.</p></td>
<td width="6%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>EPERM</b></p></td>
<td width="2%"></td>
<td width="72%">


<p>The caller does not have sufficient privileges.</p></td>
<td width="6%">
</td></tr>
</table>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>open</b>(2),
<b>readlink</b>(2), <b>attr_multi</b>(3),
<b>attr_list</b>(3), <b>xfsctl</b>(3), <b>xfs</b>(5).</p>
<hr>
</body>
</html>
